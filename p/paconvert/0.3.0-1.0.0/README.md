# Comparing `tmp/paconvert-0.3.0-py3-none-any.whl.zip` & `tmp/paconvert-1.0.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,24 +1,24 @@
-Zip file size: 80153 bytes, number of entries: 22
--rw-r--r--  2.0 unx      638 b- defN 23-Jul-31 17:36 paconvert/__init__.py
--rw-r--r--  2.0 unx    11032 b- defN 23-Oct-11 06:57 paconvert/api_alias_mapping.json
--rw-r--r--  2.0 unx   266695 b- defN 23-Oct-17 06:28 paconvert/api_mapping.json
--rw-r--r--  2.0 unx   129384 b- defN 23-Oct-17 06:28 paconvert/api_matcher.py
--rw-r--r--  2.0 unx     1701 b- defN 23-Sep-14 03:19 paconvert/attribute_mapping.json
--rw-r--r--  2.0 unx    17157 b- defN 23-Oct-09 07:08 paconvert/base.py
--rw-r--r--  2.0 unx    11094 b- defN 23-Sep-13 13:36 paconvert/converter.py
--rw-r--r--  2.0 unx    22800 b- defN 23-Sep-21 13:57 paconvert/example_code.py
--rw-r--r--  2.0 unx     5338 b- defN 23-Jul-31 17:36 paconvert/legacy.py
--rw-r--r--  2.0 unx     5203 b- defN 23-Sep-13 15:01 paconvert/main.py
--rw-r--r--  2.0 unx     3593 b- defN 23-Jul-31 17:36 paconvert/utils.py
--rw-r--r--  2.0 unx      610 b- defN 23-Jul-31 17:36 paconvert/transformer/__init__.py
--rw-r--r--  2.0 unx    26828 b- defN 23-Oct-09 06:53 paconvert/transformer/basic_transformer.py
--rw-r--r--  2.0 unx     9864 b- defN 23-Sep-04 10:56 paconvert/transformer/custom_op_transformer.py
--rw-r--r--  2.0 unx    10775 b- defN 23-Oct-17 06:28 paconvert/transformer/import_transformer.py
--rw-r--r--  2.0 unx     2957 b- defN 23-Sep-01 12:06 paconvert/transformer/tensor_requires_grad_transformer.py
--rw-r--r--  2.0 unx    11438 b- defN 23-Oct-17 07:57 paconvert-0.3.0.dist-info/LICENSE
--rw-r--r--  2.0 unx     7802 b- defN 23-Oct-17 07:57 paconvert-0.3.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Oct-17 07:57 paconvert-0.3.0.dist-info/WHEEL
--rw-r--r--  2.0 unx       51 b- defN 23-Oct-17 07:57 paconvert-0.3.0.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       10 b- defN 23-Oct-17 07:57 paconvert-0.3.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     1888 b- defN 23-Oct-17 07:57 paconvert-0.3.0.dist-info/RECORD
-22 files, 546950 bytes uncompressed, 77089 bytes compressed:  85.9%
+Zip file size: 88002 bytes, number of entries: 22
+-rw-r--r--  2.0 unx      638 b- defN 23-Dec-19 10:20 paconvert/__init__.py
+-rw-r--r--  2.0 unx    11983 b- defN 24-Apr-09 11:22 paconvert/api_alias_mapping.json
+-rw-r--r--  2.0 unx   322892 b- defN 24-Apr-24 11:55 paconvert/api_mapping.json
+-rw-r--r--  2.0 unx   137850 b- defN 24-Apr-24 11:55 paconvert/api_matcher.py
+-rw-r--r--  2.0 unx     4873 b- defN 24-Mar-06 07:36 paconvert/attribute_mapping.json
+-rw-r--r--  2.0 unx    17447 b- defN 24-Apr-09 11:22 paconvert/base.py
+-rw-r--r--  2.0 unx    11926 b- defN 24-Mar-28 08:07 paconvert/converter.py
+-rw-r--r--  2.0 unx    22800 b- defN 23-Dec-19 10:20 paconvert/example_code.py
+-rw-r--r--  2.0 unx     5338 b- defN 23-Dec-19 10:20 paconvert/legacy.py
+-rw-r--r--  2.0 unx     5180 b- defN 24-Mar-06 08:03 paconvert/main.py
+-rw-r--r--  2.0 unx     3583 b- defN 24-Mar-06 07:36 paconvert/utils.py
+-rw-r--r--  2.0 unx      610 b- defN 23-Dec-19 10:20 paconvert/transformer/__init__.py
+-rw-r--r--  2.0 unx    27694 b- defN 24-Mar-25 13:42 paconvert/transformer/basic_transformer.py
+-rw-r--r--  2.0 unx     9864 b- defN 23-Dec-19 10:20 paconvert/transformer/custom_op_transformer.py
+-rw-r--r--  2.0 unx    13551 b- defN 24-Apr-09 11:22 paconvert/transformer/import_transformer.py
+-rw-r--r--  2.0 unx     2957 b- defN 23-Dec-19 10:20 paconvert/transformer/tensor_requires_grad_transformer.py
+-rw-r--r--  2.0 unx    11438 b- defN 24-Apr-24 12:10 paconvert-1.0.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     8071 b- defN 24-Apr-24 12:10 paconvert-1.0.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-Apr-24 12:10 paconvert-1.0.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       51 b- defN 24-Apr-24 12:10 paconvert-1.0.0.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       10 b- defN 24-Apr-24 12:10 paconvert-1.0.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1888 b- defN 24-Apr-24 12:10 paconvert-1.0.0.dist-info/RECORD
+22 files, 620736 bytes uncompressed, 84938 bytes compressed:  86.3%
```

## zipnote {}

```diff
@@ -42,26 +42,26 @@
 
 Filename: paconvert/transformer/import_transformer.py
 Comment: 
 
 Filename: paconvert/transformer/tensor_requires_grad_transformer.py
 Comment: 
 
-Filename: paconvert-0.3.0.dist-info/LICENSE
+Filename: paconvert-1.0.0.dist-info/LICENSE
 Comment: 
 
-Filename: paconvert-0.3.0.dist-info/METADATA
+Filename: paconvert-1.0.0.dist-info/METADATA
 Comment: 
 
-Filename: paconvert-0.3.0.dist-info/WHEEL
+Filename: paconvert-1.0.0.dist-info/WHEEL
 Comment: 
 
-Filename: paconvert-0.3.0.dist-info/entry_points.txt
+Filename: paconvert-1.0.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: paconvert-0.3.0.dist-info/top_level.txt
+Filename: paconvert-1.0.0.dist-info/top_level.txt
 Comment: 
 
-Filename: paconvert-0.3.0.dist-info/RECORD
+Filename: paconvert-1.0.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## paconvert/api_alias_mapping.json

### Pretty-printed

 * *Similarity: 0.9104477611940298%*

 * *Differences: {"'torch.clip'": "'torch.clamp'",*

 * * "'torch.distributions.transforms.AbsTransform'": "'torch.distributions.AbsTransform'",*

 * * "'torch.distributions.transforms.AffineTransform'": "'torch.distributions.AffineTransform'",*

 * * "'torch.distributions.transforms.ExpTransform'": "'torch.distributions.ExpTransform'",*

 * * "'torch.distributions.transforms.IndependentTransform'": "'torch.distributions.IndependentTransform'",*

 * * "'torch.distributions.transforms.PowerTransform'": "'torch.distributions.PowerTransform'",*

 * * "'torch.dis […]*

```diff
@@ -43,14 +43,15 @@
     "torch.atan2": "torch.arctan2",
     "torch.atanh": "torch.arctanh",
     "torch.autograd.function.Function": "torch.autograd.Function",
     "torch.avg_pool1d": "torch.nn.functional.avg_pool1d",
     "torch.bilinear": "torch.nn.functional.bilinear",
     "torch.celu_": "torch.nn.functional.celu_",
     "torch.channel_shuffle": "torch.nn.functional.channel_shuffle",
+    "torch.clip": "torch.clamp",
     "torch.conv1d": "torch.nn.functional.conv1d",
     "torch.conv2d": "torch.nn.functional.conv2d",
     "torch.conv3d": "torch.nn.functional.conv3d",
     "torch.conv_tbc": "torch.nn.functional.conv_tbc",
     "torch.conv_transpose1d": "torch.nn.functional.conv_transpose1d",
     "torch.conv_transpose2d": "torch.nn.functional.conv_transpose2d",
     "torch.conv_transpose3d": "torch.nn.functional.conv_transpose3d",
@@ -73,47 +74,55 @@
     "torch.distributions.laplace.Laplace": "torch.distributions.Laplace",
     "torch.distributions.log_normal.LogNormal": "torch.distributions.LogNormal",
     "torch.distributions.multinomial.Multinomial": "torch.distributions.Multinomial",
     "torch.distributions.multivariate_normal.MultivariateNormal": "torch.distributions.MultivariateNormal",
     "torch.distributions.normal.Normal": "torch.distributions.Normal",
     "torch.distributions.one_hot_categorical.OneHotCategorical": "torch.distributions.OneHotCategorical",
     "torch.distributions.transformed_distribution.TransformedDistribution": "torch.distributions.TransformedDistribution",
+    "torch.distributions.transforms.AbsTransform": "torch.distributions.AbsTransform",
+    "torch.distributions.transforms.AffineTransform": "torch.distributions.AffineTransform",
     "torch.distributions.transforms.CatTransform": "torch.distributions.CatTransform",
     "torch.distributions.transforms.ComposeTransform": "torch.distributions.ComposeTransform",
     "torch.distributions.transforms.CumulativeDistributionTransform": "torch.distributions.CumulativeDistributionTransform",
+    "torch.distributions.transforms.ExpTransform": "torch.distributions.ExpTransform",
+    "torch.distributions.transforms.IndependentTransform": "torch.distributions.IndependentTransform",
+    "torch.distributions.transforms.PowerTransform": "torch.distributions.PowerTransform",
+    "torch.distributions.transforms.ReshapeTransform": "torch.distributions.ReshapeTransform",
     "torch.distributions.transforms.SigmoidTransform": "torch.distributions.SigmoidTransform",
     "torch.distributions.transforms.SoftmaxTransform": "torch.distributions.SoftmaxTransform",
     "torch.distributions.transforms.SoftplusTransform": "torch.distributions.SoftplusTransform",
     "torch.distributions.transforms.StackTransform": "torch.distributions.StackTransform",
     "torch.distributions.transforms.StickBreakingTransform": "torch.distributions.StickBreakingTransform",
+    "torch.distributions.transforms.TanhTransform": "torch.distributions.TanhTransform",
     "torch.distributions.transforms.Transform": "torch.distributions.Transform",
     "torch.distributions.uniform.Uniform": "torch.distributions.Uniform",
     "torch.div": "torch.divide",
     "torch.erf": "torch.special.erf",
     "torch.erfc": "torch.special.erfc",
     "torch.erfinv": "torch.special.erfinv",
     "torch.exp2": "torch.special.exp2",
     "torch.expm1": "torch.special.expm1",
+    "torch.ge": "torch.greater_equal",
     "torch.group_norm": "torch.nn.functional.group_norm",
+    "torch.gt": "torch.greater",
     "torch.hardshrink": "torch.nn.functional.hardshrink",
     "torch.i0": "torch.special.i0",
     "torch.igamma": "torch.special.gammainc",
     "torch.igammac": "torch.special.gammaincc",
-    "torch.inverse": "torch.linalg.inv",
     "torch.layer_norm": "torch.nn.functional.layer_norm",
     "torch.logit": "torch.special.logit",
     "torch.logsumexp": "torch.special.logsumexp",
     "torch.matmul": "torch.linalg.matmul",
     "torch.matrix_exp": "torch.linalg.matrix_exp",
     "torch.matrix_power": "torch.linalg.matrix_power",
     "torch.mul": "torch.multiply",
     "torch.nn.NLLLoss2d": "torch.nn.NLLLoss",
-    "torch.nn.modules.AvgPool1d": "torch.nn.modules.AvgPool2d",
-    "torch.nn.modules.AvgPool2d": "torch.nn.modules.AvgPool2d",
-    "torch.nn.modules.AvgPool3d": "torch.nn.modules.AvgPool2d",
+    "torch.nn.modules.AvgPool1d": "torch.nn.AvgPool1d",
+    "torch.nn.modules.AvgPool2d": "torch.nn.AvgPool2d",
+    "torch.nn.modules.AvgPool3d": "torch.nn.AvgPool3d",
     "torch.nn.modules.BatchNorm1d": "torch.nn.BatchNorm1d",
     "torch.nn.modules.BatchNorm2d": "torch.nn.BatchNorm2d",
     "torch.nn.modules.BatchNorm3d": "torch.nn.BatchNorm3d",
     "torch.nn.modules.CosineSimilarity": "torch.nn.CosineSimilarity",
     "torch.nn.modules.Dropout": "torch.nn.Dropout",
     "torch.nn.modules.GroupNorm": "torch.nn.GroupNorm",
     "torch.nn.modules.LSTM": "torch.nn.LSTM",
@@ -129,17 +138,17 @@
     "torch.nn.modules.batchnorm.BatchNorm2d": "torch.nn.BatchNorm2d",
     "torch.nn.modules.batchnorm.BatchNorm3d": "torch.nn.BatchNorm3d",
     "torch.nn.modules.batchnorm.SyncBatchNorm": "torch.nn.SyncBatchNorm",
     "torch.nn.modules.conv.Conv2d": "torch.nn.Conv2d",
     "torch.nn.modules.distance.CosineSimilarity": "torch.nn.CosineSimilarity",
     "torch.nn.modules.linear.Linear": "torch.nn.linear",
     "torch.nn.modules.module.Module": "torch.nn.Module",
-    "torch.nn.modules.pooling.AvgPool1d": "torch.nn.modules.AvgPool1d",
-    "torch.nn.modules.pooling.AvgPool2d": "torch.nn.modules.AvgPool2d",
-    "torch.nn.modules.pooling.AvgPool3d": "torch.nn.modules.AvgPool3d",
+    "torch.nn.modules.pooling.AvgPool1d": "torch.nn.AvgPool1d",
+    "torch.nn.modules.pooling.AvgPool2d": "torch.nn.AvgPool2d",
+    "torch.nn.modules.pooling.AvgPool3d": "torch.nn.AvgPool3d",
     "torch.nn.modules.rnn.LSTM": "torch.nn.LSTM",
     "torch.nn.modules.rnn.RNN": "torch.nn.RNN",
     "torch.nn.modules.rnn.RNNBase": "torch.nn.RNNBase",
     "torch.nn.modules.rnn.RNNCell": "torch.nn.RNNCell",
     "torch.nn.modules.rnn.RNNCellBase": "torch.nn.RNNCellBase",
     "torch.nn.modules.sparse.Embedding": "torch.nn.Embedding",
     "torch.nn.parallel.DataParallel": "torch.nn.DataParallel",
@@ -168,22 +177,26 @@
     "torch.sinc": "torch.special.sinc",
     "torch.sub": "torch.subtract",
     "torch.tanh": "torch.nn.functional.tanh",
     "torch.threshold": "torch.nn.functional.threshold",
     "torch.threshold_": "torch.nn.functional.threshold_",
     "torch.torch.Tensor": "torch.Tensor",
     "torch.torch.finfo": "torch.finfo",
+    "torch.torch.int32": "torch.int32",
     "torch.trapz": "torch.trapezoid",
     "torch.utils.data._utils.collate.default_collate": "torch.utils.data.default_collate",
     "torch.utils.data.dataloader.DataLoader": "torch.utils.data.DataLoader",
     "torch.utils.data.dataloader.default_collate": "torch.utils.data.default_collate",
     "torch.utils.data.dataset.ConcatDataset": "torch.utils.data.ConcatDataset",
     "torch.utils.data.dataset.Dataset": "torch.utils.data.Dataset",
     "torch.utils.data.distributed.DistributedSampler": "torch.utils.data.DistributedSampler",
     "torch.utils.data.sampler.BatchSampler": "torch.utils.data.BatchSampler",
     "torch.utils.data.sampler.RandomSampler": "torch.utils.data.RandomSampler",
     "torch.utils.data.sampler.Sampler": "torch.utils.data.Sampler",
     "torch.utils.data.sampler.SequentialSampler": "torch.utils.data.SequentialSampler",
     "torch.utils.data.sampler.SubsetRandomSampler": "torch.utils.data.SubsetRandomSampler",
     "torch.utils.data.sampler.WeightedRandomSampler": "torch.utils.data.WeightedRandomSampler",
-    "torch.xlogy": "torch.special.xlogy"
+    "torch.xlogy": "torch.special.xlogy",
+    "transformers.generation.logits_process.LogitsProcessorList": "transformers.generation.LogitsProcessorList",
+    "transformers.modeling_utils.PreTrainedModel": "transformers.PreTrainedModel",
+    "transformers.utils.logging.get_logger": "transformers.logging.get_logger"
 }
```

## paconvert/api_mapping.json

### Pretty-printed

 * *Similarity: 0.8144243803391383%*

 * *Differences: {"'fairscale.nn.model_parallel.initialize.get_model_parallel_rank'": "OrderedDict([('Matcher', "*

 * *                                                                     "'GenericMatcher'), "*

 * *                                                                     "('paddle_api', "*

 * *                                                                     "'paddle.distributed.get_rank'), "*

 * *                                                                     "('args_list', ['group'])])",*

 * * "'fairscale.nn.model_parallel.ini […]*

```diff
@@ -1,67 +1,240 @@
 {
+    "fairscale.nn.model_parallel.initialize.get_model_parallel_rank": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "group"
+        ],
+        "paddle_api": "paddle.distributed.get_rank"
+    },
+    "fairscale.nn.model_parallel.initialize.get_model_parallel_world_size": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "group"
+        ],
+        "paddle_api": "paddle.distributed.get_world_size"
+    },
+    "fairscale.nn.model_parallel.initialize.initialize_model_parallel": {
+        "Matcher": "FSInitializeModelParallelMatcher",
+        "args_list": [
+            "model_parallel_size_",
+            "pipeline_length",
+            "*",
+            "model_parallel_backend",
+            "pipeline_backend",
+            "ddp_backend"
+        ],
+        "kwargs_change": {
+            "ddp_backend": "",
+            "model_parallel_backend": "",
+            "pipeline_backend": ""
+        },
+        "min_input_args": 1
+    },
+    "fairscale.nn.model_parallel.initialize.model_parallel_is_initialized": {
+        "Matcher": "FSModelParallelIsInitializedMatcher"
+    },
+    "fairscale.nn.model_parallel.layers.ColumnParallelLinear": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "in_features",
+            "out_features",
+            "bias",
+            "gather_output",
+            "init_method",
+            "stride",
+            "keep_master_weight_for_test"
+        ],
+        "kwargs_change": {
+            "bias": "has_bias",
+            "init_method": "",
+            "keep_master_weight_for_test": ""
+        },
+        "paddle_api": "paddle.distributed.fleet.meta_parallel.ColumnParallelLinear",
+        "paddle_default_kwargs": {
+            "has_bias": "True"
+        },
+        "unsupport_args": [
+            "stride"
+        ]
+    },
+    "fairscale.nn.model_parallel.layers.ParallelEmbedding": {
+        "Matcher": "FSParallelEmbeddingMatcher",
+        "args_list": [
+            "num_embeddings",
+            "embedding_dim",
+            "padding_idx",
+            "norm_type",
+            "scale_grad_by_freq",
+            "sparse",
+            "init_method",
+            "keep_master_weight_for_test"
+        ],
+        "kwargs_change": {
+            "init_method": "",
+            "keep_master_weight_for_test": ""
+        },
+        "unsupport_args": [
+            "padding_idx",
+            "norm_type",
+            "scale_grad_by_freq",
+            "sparse"
+        ]
+    },
+    "fairscale.nn.model_parallel.layers.RowParallelLinear": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "in_features",
+            "out_features",
+            "bias",
+            "input_is_parallel",
+            "init_method",
+            "stride",
+            "keep_master_weight_for_test"
+        ],
+        "kwargs_change": {
+            "bias": "has_bias",
+            "init_method": "",
+            "keep_master_weight_for_test": ""
+        },
+        "paddle_api": "paddle.distributed.fleet.meta_parallel.RowParallelLinear",
+        "paddle_default_kwargs": {
+            "has_bias": "True"
+        },
+        "unsupport_args": [
+            "stride"
+        ]
+    },
+    "flash_attn.flash_attn_interface.flash_attn_func": {
+        "Matcher": "FAFlashAttnFuncMatcher",
+        "args_list": [
+            "q",
+            "k",
+            "v",
+            "dropout_p",
+            "softmax_scale",
+            "causal",
+            "window_size",
+            "alibi_slopes",
+            "deterministic",
+            "return_attn_probs"
+        ],
+        "kwargs_change": {
+            "k": "key",
+            "q": "query",
+            "v": "value"
+        },
+        "paddle_api": "paddle.nn.functional.flash_attention",
+        "unsupport_args": [
+            "window_size",
+            "alibi_slopes",
+            "deterministic",
+            "return_attn_probs"
+        ]
+    },
+    "flash_attn.flash_attn_interface.flash_attn_unpadded_func": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "q",
+            "k",
+            "v",
+            "cu_seqlens_q",
+            "cu_seqlens_k",
+            "max_seqlen_q",
+            "max_seqlen_k",
+            "dropout_p",
+            "softmax_scale",
+            "casul",
+            "window_size",
+            "alibi_slopes",
+            "deterministic",
+            "return_attn_probs"
+        ],
+        "kwargs_change": {
+            "k": "key",
+            "q": "query",
+            "softmax_scale": "scale",
+            "v": "value"
+        },
+        "paddle_api": "paddle.nn.functional.flash_attn_unpadded",
+        "unsupport_args": [
+            "window_size",
+            "alibi_slopes",
+            "deterministic",
+            "return_attn_probs"
+        ]
+    },
+    "os.environ.get": {
+        "Matcher": "OsEnvironGetMatcher",
+        "args_list": [
+            "key",
+            "value"
+        ]
+    },
     "setuptools.setup": {
-        "Matcher": "SetUpMatcher"
+        "Matcher": "SetUpMatcher",
+        "min_input_args": 0
     },
     "torch.BoolTensor": {
         "Matcher": "TensorMatcher",
-        "paddle_api": "paddle.Tensor"
+        "paddle_api": "paddle.bool"
     },
     "torch.ByteTensor": {
         "Matcher": "TensorMatcher",
-        "paddle_api": "paddle.Tensor"
+        "paddle_api": "paddle.uint8"
     },
     "torch.DoubleTensor": {
         "Matcher": "TensorMatcher",
-        "paddle_api": "paddle.Tensor"
+        "paddle_api": "paddle.float64"
     },
     "torch.FloatTensor": {
         "Matcher": "TensorMatcher",
-        "paddle_api": "paddle.Tensor"
+        "paddle_api": "paddle.float32"
     },
     "torch.Generator": {
         "Matcher": "GeneratorMatcher",
         "args_list": [
             "device"
         ],
         "min_input_args": 0
     },
     "torch.HalfTensor": {
         "Matcher": "TensorMatcher",
-        "paddle_api": "paddle.Tensor"
+        "paddle_api": "paddle.float16"
     },
     "torch.IntTensor": {
         "Matcher": "TensorMatcher",
-        "paddle_api": "paddle.Tensor"
+        "paddle_api": "paddle.int32"
     },
     "torch.LongTensor": {
         "Matcher": "TensorMatcher",
-        "paddle_api": "paddle.Tensor"
+        "paddle_api": "paddle.int64"
     },
     "torch.ShortTensor": {
         "Matcher": "TensorMatcher",
-        "paddle_api": "paddle.Tensor"
+        "paddle_api": "paddle.int16"
     },
     "torch.Size": {
         "Matcher": "SizeMatcher",
+        "min_input_args": 0,
         "paddle_api": "list"
     },
     "torch.Tensor": {
         "Matcher": "TensorMatcher",
         "paddle_api": "paddle.Tensor"
     },
     "torch.Tensor.abs": {
         "Matcher": "GenericMatcher",
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.abs"
     },
     "torch.Tensor.abs_": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "min_input_args": 0,
-        "paddle_api": "paddle.abs_"
+        "paddle_api": "paddle.Tensor.abs_"
     },
     "torch.Tensor.add": {
         "Matcher": "TensorAddMatcher",
         "args_list": [
             "other",
             "*",
             "alpha"
@@ -168,18 +341,21 @@
             "alpha"
         ],
         "min_input_args": 2,
         "paddle_api": "paddle.outer"
     },
     "torch.Tensor.addr_": {},
     "torch.Tensor.adjoint": {
-        "Matcher": "AdjointMatcher"
+        "Matcher": "AdjointMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.align_as": {},
-    "torch.Tensor.align_to": {},
+    "torch.Tensor.align_to": {
+        "min_input_args": 0
+    },
     "torch.Tensor.all": {
         "Matcher": "TensorToBoolMatcher",
         "args_list": [
             "dim",
             "keepdim"
         ],
         "kwargs_change": {
@@ -233,14 +409,15 @@
             "dim",
             "keepdim"
         ],
         "min_input_args": 0
     },
     "torch.Tensor.angle": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.angle"
     },
     "torch.Tensor.any": {
         "Matcher": "TensorToBoolMatcher",
         "args_list": [
             "dim",
             "keepdim"
@@ -250,75 +427,81 @@
         },
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.any"
     },
     "torch.Tensor.apply_": {},
     "torch.Tensor.arccos": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.acos"
     },
     "torch.Tensor.arccos_": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "min_input_args": 0,
-        "paddle_api": "paddle.acos_"
+        "paddle_api": "paddle.Tensor.acos_"
     },
     "torch.Tensor.arccosh": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.acosh"
     },
     "torch.Tensor.arccosh_": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "min_input_args": 0,
-        "paddle_api": "paddle.acosh_"
+        "paddle_api": "paddle.Tensor.acosh_"
     },
     "torch.Tensor.arcsin": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.arcsin_": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "min_input_args": 0,
-        "paddle_api": "paddle.asin_"
+        "paddle_api": "paddle.Tensor.asin_"
     },
     "torch.Tensor.arcsinh": {
-        "Matcher": "TensorFunc2PaddleFunc",
-        "paddle_api": "paddle.asinh"
+        "Matcher": "GenericMatcher",
+        "min_input_args": 0,
+        "paddle_api": "paddle.Tensor.asinh"
     },
     "torch.Tensor.arcsinh_": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "min_input_args": 0,
-        "paddle_api": "paddle.asinh_"
+        "paddle_api": "paddle.Tensor.asinh_"
     },
     "torch.Tensor.arctan": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.arctan2": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "args_list": [
             "other"
         ],
         "kwargs_change": {
             "other": "y"
         },
         "min_input_args": 1,
-        "paddle_api": "paddle.atan2"
+        "paddle_api": "paddle.Tensor.atan2"
     },
     "torch.Tensor.arctan2_": {},
     "torch.Tensor.arctan_": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "min_input_args": 0,
-        "paddle_api": "paddle.atan_"
+        "paddle_api": "paddle.Tensor.atan_"
     },
     "torch.Tensor.arctanh": {
-        "Matcher": "TensorFunc2PaddleFunc",
-        "paddle_api": "paddle.atanh"
+        "Matcher": "GenericMatcher",
+        "min_input_args": 0,
+        "paddle_api": "paddle.Tensor.atanh"
     },
     "torch.Tensor.arctanh_": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "min_input_args": 0,
-        "paddle_api": "paddle.atanh_"
+        "paddle_api": "paddle.Tensor.atanh_"
     },
     "torch.Tensor.argmax": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "dim",
             "keepdim"
         ],
@@ -350,17 +533,31 @@
             "dim": "axis"
         },
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.argsort"
     },
     "torch.Tensor.argwhere": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.nonzero"
     },
-    "torch.Tensor.as_strided": {},
+    "torch.Tensor.as_strided": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "size",
+            "stride",
+            "storage_offset"
+        ],
+        "kwargs_change": {
+            "size": "shape",
+            "storage_offset": "offset"
+        },
+        "min_input_args": 2,
+        "paddle_api": "paddle.Tensor.as_strided"
+    },
     "torch.Tensor.as_subclass": {},
     "torch.Tensor.backward": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "gradient",
             "retain_graph",
             "create_graph",
@@ -386,33 +583,35 @@
             "alpha"
         ],
         "min_input_args": 2,
         "paddle_api": "paddle.bmm"
     },
     "torch.Tensor.baddbmm_": {},
     "torch.Tensor.bernoulli": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "args_list": [
             "p",
             "*",
             "generator"
         ],
         "min_input_args": 0,
-        "paddle_api": "paddle.bernoulli",
+        "paddle_api": "paddle.Tensor.bernoulli",
         "unsupport_args": [
             "p"
         ]
     },
     "torch.Tensor.bernoulli_": {},
     "torch.Tensor.bfloat16": {
         "Matcher": "TensorBF16Matcher",
         "args_list": [
+            "*",
             "memory_format"
         ],
-        "min_input_args": 0
+        "min_input_args": 0,
+        "paddle_api": "paddle.Tensor.astype"
     },
     "torch.Tensor.bincount": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "weights",
             "minlength"
         ],
@@ -509,17 +708,19 @@
         },
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.bmm"
     },
     "torch.Tensor.bool": {
         "Matcher": "TensorBoolMatcher",
         "args_list": [
+            "*",
             "memory_format"
         ],
-        "min_input_args": 0
+        "min_input_args": 0,
+        "paddle_api": "paddle.Tensor.astype"
     },
     "torch.Tensor.broadcast_to": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "size"
         ],
         "kwargs_change": {
@@ -527,47 +728,57 @@
         },
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.broadcast_to"
     },
     "torch.Tensor.byte": {
         "Matcher": "TensorByteMatcher",
         "args_list": [
+            "*",
             "memory_format"
         ],
-        "min_input_args": 0
+        "min_input_args": 0,
+        "paddle_api": "paddle.Tensor.astype"
     },
     "torch.Tensor.cauchy_": {},
     "torch.Tensor.cdouble": {
         "Matcher": "TensorCdoubleMatcher",
         "args_list": [
+            "*",
             "memory_format"
         ],
-        "min_input_args": 0
+        "min_input_args": 0,
+        "paddle_api": "paddle.Tensor.astype"
     },
     "torch.Tensor.ceil": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.ceil_": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.ceil_"
     },
     "torch.Tensor.cfloat": {
         "Matcher": "TensorCfloatMatcher",
         "args_list": [
+            "*",
             "memory_format"
         ],
-        "min_input_args": 0
+        "min_input_args": 0,
+        "paddle_api": "paddle.Tensor.astype"
     },
     "torch.Tensor.chalf": {},
     "torch.Tensor.char": {
         "Matcher": "TensorCharMatcher",
         "args_list": [
+            "*",
             "memory_format"
         ],
-        "min_input_args": 0
+        "min_input_args": 0,
+        "paddle_api": "paddle.Tensor.astype"
     },
     "torch.Tensor.cholesky": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "upper"
         ],
         "min_input_args": 0,
@@ -576,15 +787,26 @@
     "torch.Tensor.cholesky_inverse": {
         "Matcher": "CholeskyInverseMatcher",
         "args_list": [
             "upper"
         ],
         "min_input_args": 0
     },
-    "torch.Tensor.cholesky_solve": {},
+    "torch.Tensor.cholesky_solve": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "input2",
+            "upper"
+        ],
+        "kwargs_change": {
+            "input2": "y"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.Tensor.cholesky_solve"
+    },
     "torch.Tensor.chunk": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "chunks",
             "dim"
         ],
         "kwargs_change": {
@@ -595,93 +817,109 @@
     },
     "torch.Tensor.clamp": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "min",
             "max"
         ],
-        "min_input_args": 0,
+        "min_input_args": 1,
         "paddle_api": "paddle.Tensor.clip"
     },
     "torch.Tensor.clamp_": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "min",
             "max"
         ],
-        "min_input_args": 0,
+        "min_input_args": 1,
         "paddle_api": "paddle.Tensor.clip_"
     },
     "torch.Tensor.clip": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "args_list": [
+            "min",
+            "max"
+        ],
+        "min_input_args": 1
     },
     "torch.Tensor.clip_": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "min",
             "max"
         ],
-        "min_input_args": 0,
+        "min_input_args": 1,
         "paddle_api": "paddle.Tensor.clip_"
     },
     "torch.Tensor.clone": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "*",
             "memory_format"
         ],
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.clone"
     },
     "torch.Tensor.coalesce": {
-        "Matcher": "TensorFunc2PaddleFunc",
-        "paddle_api": "paddle.sparse.coalesce"
+        "Matcher": "GenericMatcher",
+        "min_input_args": 0,
+        "paddle_api": "paddle.Tensor.coalesce"
     },
     "torch.Tensor.conj": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.conj_physical": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.conj"
     },
     "torch.Tensor.conj_physical_": {},
     "torch.Tensor.contiguous": {
-        "Matcher": "TensorSkipMatcher"
+        "Matcher": "TensorSkipMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.copy_": {
         "Matcher": "TensorCopy_Matcher",
         "args_list": [
-            "src",
+            "other",
             "non_blocking"
         ],
-        "min_input_args": 1
+        "kwargs_change": {
+            "non_blocking": ""
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.assign"
     },
     "torch.Tensor.copysign": {},
     "torch.Tensor.copysign_": {},
     "torch.Tensor.corrcoef": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.corrcoef"
     },
     "torch.Tensor.cos": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.cos"
     },
     "torch.Tensor.cos_": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "min_input_args": 0,
-        "paddle_api": "paddle.cos_"
+        "paddle_api": "paddle.Tensor.cos_"
     },
     "torch.Tensor.cosh": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.cosh"
     },
     "torch.Tensor.cosh_": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "min_input_args": 0,
-        "paddle_api": "paddle.cosh_"
+        "paddle_api": "paddle.Tensor.cosh_"
     },
     "torch.Tensor.count_nonzero": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "dim"
         ],
         "kwargs_change": {
@@ -702,14 +940,15 @@
             "correction": "ddof"
         },
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.cov"
     },
     "torch.Tensor.cpu": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.cpu"
     },
     "torch.Tensor.cross": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "other",
             "dim"
@@ -718,24 +957,49 @@
             "dim": "axis",
             "other": "y"
         },
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.cross"
     },
     "torch.Tensor.cuda": {
-        "Matcher": "TensorSkipMatcher",
+        "Matcher": "TensorCudaMatcher",
         "args_list": [
             "device",
             "non_blocking",
             "memory_format"
         ],
-        "min_input_args": 0
+        "kwargs_change": {
+            "device": "device_id",
+            "memory_format": ""
+        },
+        "min_input_args": 0,
+        "paddle_api": "paddle.Tensor.cuda"
+    },
+    "torch.Tensor.cummax": {
+        "Matcher": "DoubleAssignMatcher",
+        "args_list": [
+            "dim"
+        ],
+        "kwargs_change": {
+            "dim": "axis"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.Tensor.cummax"
+    },
+    "torch.Tensor.cummin": {
+        "Matcher": "DoubleAssignMatcher",
+        "args_list": [
+            "dim"
+        ],
+        "kwargs_change": {
+            "dim": "axis"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.Tensor.cummin"
     },
-    "torch.Tensor.cummax": {},
-    "torch.Tensor.cummin": {},
     "torch.Tensor.cumprod": {
         "Matcher": "UnchangeMatcher",
         "args_list": [
             "dim",
             "*",
             "dtype"
         ],
@@ -754,14 +1018,15 @@
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.cumprod_"
     },
     "torch.Tensor.cumsum": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "dim",
+            "*",
             "dtype"
         ],
         "kwargs_change": {
             "dim": "axis",
             "dtype": "dtype"
         },
         "min_input_args": 1,
@@ -779,58 +1044,60 @@
             "dtype": "dtype"
         },
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.cumsum_"
     },
     "torch.Tensor.data_ptr": {},
     "torch.Tensor.deg2rad": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.dense_dim": {},
     "torch.Tensor.dequantize": {},
     "torch.Tensor.det": {
         "Matcher": "GenericMatcher",
         "paddle_api": "paddle.Tensor.det"
     },
     "torch.Tensor.detach": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.detach"
     },
     "torch.Tensor.detach_": {
         "Matcher": "GenericMatcher",
         "paddle_api": "paddle.Tensor.detach_"
     },
     "torch.Tensor.diag": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "args_list": [
             "diagonal"
         ],
         "kwargs_change": {
             "diagonal": "offset"
         },
         "min_input_args": 0,
-        "paddle_api": "paddle.diag"
+        "paddle_api": "paddle.Tensor.diag"
     },
     "torch.Tensor.diag_embed": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "args_list": [
             "offset",
             "dim1",
             "dim2"
         ],
         "min_input_args": 0,
-        "paddle_api": "paddle.nn.functional.diag_embed"
+        "paddle_api": "paddle.Tensor.diag_embed"
     },
     "torch.Tensor.diagflat": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "args_list": [
             "offset"
         ],
         "min_input_args": 0,
-        "paddle_api": "paddle.diagflat"
+        "paddle_api": "paddle.Tensor.diagflat"
     },
     "torch.Tensor.diagonal": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "offset",
             "dim1",
             "dim2"
@@ -838,15 +1105,30 @@
         "kwargs_change": {
             "dim1": "axis1",
             "dim2": "axis2"
         },
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.diagonal"
     },
-    "torch.Tensor.diagonal_scatter": {},
+    "torch.Tensor.diagonal_scatter": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "src",
+            "offset",
+            "dim1",
+            "dim2"
+        ],
+        "kwargs_change": {
+            "dim1": "axis1",
+            "dim2": "axis2",
+            "src": "y"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.Tensor.diagonal_scatter"
+    },
     "torch.Tensor.diff": {
         "Matcher": "DiffMatcher",
         "args_list": [
             "n",
             "dim",
             "prepend",
             "append"
@@ -855,23 +1137,25 @@
             "dim": "axis"
         },
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.diff"
     },
     "torch.Tensor.digamma": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.digamma"
     },
     "torch.Tensor.digamma_": {
         "Matcher": "GenericMatcher",
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.digamma_"
     },
     "torch.Tensor.dim": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.dim"
     },
     "torch.Tensor.dist": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "other",
             "p"
@@ -912,22 +1196,27 @@
         },
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.dot"
     },
     "torch.Tensor.double": {
         "Matcher": "TensorDoubleMatcher",
         "args_list": [
+            "*",
             "memory_format"
         ],
-        "min_input_args": 0
+        "min_input_args": 0,
+        "paddle_api": "paddle.Tensor.astype"
     },
     "torch.Tensor.dsplit": {},
-    "torch.Tensor.eig": {},
+    "torch.Tensor.eig": {
+        "min_input_args": 0
+    },
     "torch.Tensor.element_size": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.element_size"
     },
     "torch.Tensor.eq": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "other"
         ],
@@ -957,39 +1246,45 @@
             "other": "y"
         },
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.equal_all"
     },
     "torch.Tensor.erf": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.erf"
     },
     "torch.Tensor.erf_": {
         "Matcher": "TensorFunc2PaddleFunc",
         "min_input_args": 0,
         "paddle_api": "paddle.erf_"
     },
     "torch.Tensor.erfc": {
-        "Matcher": "ErfCMatcher"
+        "Matcher": "ErfCMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.erfc_": {},
     "torch.Tensor.erfinv": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.erfinv"
     },
     "torch.Tensor.erfinv_": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.erfinv_"
     },
     "torch.Tensor.exp": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.exp"
     },
     "torch.Tensor.exp_": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.exp_"
     },
     "torch.Tensor.expand": {
         "Matcher": "TensorExpandMatcher",
         "paddle_api": "paddle.Tensor.expand"
     },
     "torch.Tensor.expand_as": {
@@ -1000,15 +1295,16 @@
         "kwargs_change": {
             "other": "y"
         },
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.expand_as"
     },
     "torch.Tensor.expm1": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.expm1_": {
         "Matcher": "TensorFunc2PaddleFunc",
         "min_input_args": 0,
         "paddle_api": "paddle.expm1_"
     },
     "torch.Tensor.exponential_": {
@@ -1042,14 +1338,15 @@
             "fill_value": "value"
         },
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.fill_diagonal_"
     },
     "torch.Tensor.fix": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.trunc"
     },
     "torch.Tensor.fix_": {},
     "torch.Tensor.flatten": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "start_dim",
@@ -1071,40 +1368,58 @@
             "dims": "axis"
         },
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.flip"
     },
     "torch.Tensor.fliplr": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.flip",
         "paddle_default_kwargs": {
             "axis": 1
         }
     },
     "torch.Tensor.flipud": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.flip",
         "paddle_default_kwargs": {
             "axis": 0
         }
     },
     "torch.Tensor.float": {
         "Matcher": "TensorFloatMatcher",
         "args_list": [
+            "*",
             "memory_format"
         ],
-        "min_input_args": 0
+        "min_input_args": 0,
+        "paddle_api": "paddle.Tensor.astype"
+    },
+    "torch.Tensor.float_power": {
+        "Matcher": "FloatPowerMatcher",
+        "args_list": [
+            "exponent"
+        ],
+        "min_input_args": 1
+    },
+    "torch.Tensor.float_power_": {
+        "Matcher": "FloatPowerInplaceMatcher",
+        "args_list": [
+            "exponent"
+        ],
+        "min_input_args": 1
     },
-    "torch.Tensor.float_power": {},
-    "torch.Tensor.float_power_": {},
     "torch.Tensor.floor": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.floor_": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.floor_"
     },
     "torch.Tensor.floor_divide": {
         "Matcher": "Num2TensorBinaryMatcher",
         "args_list": [
             "other"
         ],
@@ -1161,14 +1476,15 @@
     "torch.Tensor.frac_": {
         "Matcher": "GenericMatcher",
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.frac_"
     },
     "torch.Tensor.frexp": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.frexp"
     },
     "torch.Tensor.gather": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "dim",
             "index"
@@ -1213,14 +1529,15 @@
             "vec2": "y"
         },
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.outer"
     },
     "torch.Tensor.get_device": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.place.gpu_device_id"
     },
     "torch.Tensor.greater": {
         "Matcher": "Num2TensorBinaryMatcher",
         "args_list": [
             "other"
         ],
@@ -1259,17 +1576,19 @@
         ],
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.greater_equal_"
     },
     "torch.Tensor.half": {
         "Matcher": "TensorFP16Matcher",
         "args_list": [
+            "*",
             "memory_format"
         ],
-        "min_input_args": 0
+        "min_input_args": 0,
+        "paddle_api": "paddle.Tensor.astype"
     },
     "torch.Tensor.hardshrink": {
         "Matcher": "TensorFunc2PaddleFunc",
         "args_list": [
             "lambd"
         ],
         "kwargs_change": {
@@ -1298,22 +1617,40 @@
         ],
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.histogram"
     },
     "torch.Tensor.histogram": {},
     "torch.Tensor.hsplit": {},
     "torch.Tensor.hypot": {
-        "Matcher": "HypotMatcher",
+        "Matcher": "GenericMatcher",
         "args_list": [
             "other"
         ],
-        "min_input_args": 1
+        "kwargs_change": {
+            "other": "y"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.Tensor.hypot"
+    },
+    "torch.Tensor.hypot_": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "other"
+        ],
+        "kwargs_change": {
+            "other": "y"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.Tensor.hypot_"
+    },
+    "torch.Tensor.i0": {
+        "Matcher": "GenericMatcher",
+        "min_input_args": 0,
+        "paddle_api": "paddle.Tensor.i0"
     },
-    "torch.Tensor.hypot_": {},
-    "torch.Tensor.i0": {},
     "torch.Tensor.i0_": {
         "Matcher": "GenericMatcher",
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.i0_"
     },
     "torch.Tensor.igamma": {},
     "torch.Tensor.igamma_": {},
@@ -1324,42 +1661,84 @@
         "args_list": [
             "dim",
             "index",
             "source",
             "*",
             "alpha"
         ],
+        "kwargs_change": {
+            "dim": "axis"
+        },
         "min_input_args": 3,
-        "paddle_api": "paddle.index_add"
+        "paddle_api": "paddle.Tensor.index_add"
     },
     "torch.Tensor.index_add_": {
         "Matcher": "IndexAddMatcher",
         "args_list": [
             "dim",
             "index",
             "source",
             "*",
             "alpha"
         ],
+        "kwargs_change": {
+            "dim": "axis"
+        },
         "min_input_args": 3,
-        "paddle_api": "paddle.index_add_"
+        "paddle_api": "paddle.Tensor.index_add_"
     },
     "torch.Tensor.index_copy": {},
     "torch.Tensor.index_copy_": {
         "Matcher": "TensorIndexCopyMatcher",
         "args_list": [
             "dim",
             "index",
-            "tensor"
+            "source"
         ],
         "min_input_args": 3
     },
-    "torch.Tensor.index_fill": {},
-    "torch.Tensor.index_fill_": {},
-    "torch.Tensor.index_put": {},
+    "torch.Tensor.index_fill": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "dim",
+            "index",
+            "value"
+        ],
+        "kwargs_change": {
+            "dim": "axis"
+        },
+        "min_input_args": 3,
+        "paddle_api": "paddle.Tensor.index_fill"
+    },
+    "torch.Tensor.index_fill_": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "dim",
+            "index",
+            "value"
+        ],
+        "kwargs_change": {
+            "dim": "axis"
+        },
+        "min_input_args": 3,
+        "paddle_api": "paddle.Tensor.index_fill_"
+    },
+    "torch.Tensor.index_put": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "indices",
+            "values",
+            "accumulate"
+        ],
+        "kwargs_change": {
+            "values": "value"
+        },
+        "min_input_args": 2,
+        "paddle_api": "paddle.Tensor.index_put"
+    },
     "torch.Tensor.index_put_": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "indices",
             "values",
             "accumulate"
         ],
@@ -1381,14 +1760,15 @@
             "dim": "axis"
         },
         "min_input_args": 2,
         "paddle_api": "paddle.Tensor.index_select"
     },
     "torch.Tensor.indices": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.indices"
     },
     "torch.Tensor.inner": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "other"
         ],
@@ -1397,45 +1777,54 @@
         },
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.inner"
     },
     "torch.Tensor.int": {
         "Matcher": "TensorIntMatcher",
         "args_list": [
+            "*",
             "memory_format"
         ],
-        "min_input_args": 0
+        "min_input_args": 0,
+        "paddle_api": "paddle.Tensor.astype"
     },
     "torch.Tensor.int_repr": {},
     "torch.Tensor.inverse": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.inverse"
     },
     "torch.Tensor.is_coalesced": {},
     "torch.Tensor.is_complex": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.is_complex"
     },
     "torch.Tensor.is_conj": {},
     "torch.Tensor.is_contiguous": {
-        "Matcher": "SetTrueMatcher"
+        "Matcher": "SetTrueMatcher",
+        "min_input_args": 0
     },
-    "torch.Tensor.is_cuda": {},
     "torch.Tensor.is_floating_point": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.is_floating_point"
     },
     "torch.Tensor.is_inference": {},
-    "torch.Tensor.is_meta": {},
-    "torch.Tensor.is_pinned": {},
-    "torch.Tensor.is_quantized": {},
+    "torch.Tensor.is_pinned": {
+        "Matcher": "Is_PinnedMatcher",
+        "min_input_args": 0
+    },
     "torch.Tensor.is_set_to": {},
-    "torch.Tensor.is_shared": {},
+    "torch.Tensor.is_shared": {
+        "min_input_args": 0
+    },
     "torch.Tensor.is_signed": {
-        "Matcher": "TensorIsSignedMatcher"
+        "Matcher": "TensorIsSignedMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.isclose": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "other",
             "rtol",
             "atol",
@@ -1445,45 +1834,49 @@
             "other": "y"
         },
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.isclose"
     },
     "torch.Tensor.isfinite": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.isfinite"
     },
     "torch.Tensor.isinf": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.isinf"
     },
     "torch.Tensor.isnan": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.isnan"
     },
     "torch.Tensor.isneginf": {},
     "torch.Tensor.isposinf": {},
     "torch.Tensor.isreal": {},
     "torch.Tensor.istft": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "args_list": [
             "n_fft",
             "hop_length",
             "win_length",
             "window",
             "center",
             "normalized",
             "onesided",
             "length",
             "return_complex"
         ],
         "min_input_args": 1,
-        "paddle_api": "paddle.signal.istft"
+        "paddle_api": "paddle.Tensor.istft"
     },
     "torch.Tensor.item": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.kthvalue": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "k",
             "dim",
             "keepdim"
@@ -1597,43 +1990,48 @@
             "other"
         ],
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.less_equal_"
     },
     "torch.Tensor.lgamma": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.lgamma"
     },
     "torch.Tensor.lgamma_": {
         "Matcher": "GenericMatcher",
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.lgamma_"
     },
     "torch.Tensor.log": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.log"
     },
     "torch.Tensor.log10": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.log10"
     },
     "torch.Tensor.log10_": {
         "Matcher": "GenericMatcher",
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.log10_"
     },
     "torch.Tensor.log1p": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.log1p_": {
         "Matcher": "UnchangeMatcher",
         "min_input_args": 0
     },
     "torch.Tensor.log2": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.log2"
     },
     "torch.Tensor.log2_": {
         "Matcher": "GenericMatcher",
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.log2_"
     },
@@ -1665,15 +2063,16 @@
         "kwargs_change": {
             "dim": "axis"
         },
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.logcumsumexp"
     },
     "torch.Tensor.logdet": {
-        "Matcher": "LogDetMatcher"
+        "Matcher": "LogDetMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.logical_and": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "other"
         ],
         "kwargs_change": {
@@ -1691,14 +2090,15 @@
             "other": "y"
         },
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.logical_and_"
     },
     "torch.Tensor.logical_not": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.logical_not"
     },
     "torch.Tensor.logical_not_": {
         "Matcher": "TensorInplaceReserveTypeMatcher",
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.logical_not_"
     },
@@ -1773,39 +2173,52 @@
         },
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.logsumexp"
     },
     "torch.Tensor.long": {
         "Matcher": "TensorLongMatcher",
         "args_list": [
+            "*",
             "memory_format"
         ],
-        "min_input_args": 0
+        "min_input_args": 0,
+        "paddle_api": "paddle.Tensor.astype"
+    },
+    "torch.Tensor.lstsq": {
+        "min_input_args": 1
     },
-    "torch.Tensor.lstsq": {},
     "torch.Tensor.lu": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "pivot",
             "get_infos"
         ],
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.lu"
     },
     "torch.Tensor.lu_solve": {},
     "torch.Tensor.map_": {},
     "torch.Tensor.masked_fill": {
-        "Matcher": "TensorMaskedFillMatcher",
+        "Matcher": "GenericMatcher",
         "args_list": [
             "mask",
             "value"
         ],
-        "min_input_args": 2
+        "min_input_args": 2,
+        "paddle_api": "paddle.Tensor.masked_fill"
+    },
+    "torch.Tensor.masked_fill_": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "mask",
+            "value"
+        ],
+        "min_input_args": 2,
+        "paddle_api": "paddle.Tensor.masked_fill_"
     },
-    "torch.Tensor.masked_fill_": {},
     "torch.Tensor.masked_scatter": {},
     "torch.Tensor.masked_scatter_": {},
     "torch.Tensor.masked_select": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "mask"
         ],
@@ -1944,26 +2357,27 @@
             "source",
             "destination"
         ],
         "min_input_args": 2,
         "paddle_api": "paddle.Tensor.moveaxis"
     },
     "torch.Tensor.msort": {
-        "Matcher": "MSortMatcher"
+        "Matcher": "MSortMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.multinomial": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "args_list": [
             "num_samples",
             "replacement",
             "*",
             "generator"
         ],
         "min_input_args": 1,
-        "paddle_api": "paddle.multinomial"
+        "paddle_api": "paddle.Tensor.multinomial"
     },
     "torch.Tensor.multiply": {
         "Matcher": "TensorMultiplyMatcher",
         "args_list": [
             "other"
         ],
         "min_input_args": 1,
@@ -2048,18 +2462,15 @@
             "*",
             "interpolation"
         ],
         "kwargs_change": {
             "dim": "axis"
         },
         "min_input_args": 1,
-        "paddle_api": "paddle.Tensor.nanquantile",
-        "unsupport_args": [
-            "interpolation"
-        ]
+        "paddle_api": "paddle.Tensor.nanquantile"
     },
     "torch.Tensor.nansum": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "dim",
             "keepdim",
             "*",
@@ -2075,49 +2486,54 @@
     "torch.Tensor.narrow": {
         "Matcher": "NarrowMatcher",
         "args_list": [
             "dim",
             "start",
             "length"
         ],
-        "min_input_args": 3
+        "min_input_args": 3,
+        "paddle_api": "paddle.slice"
     },
     "torch.Tensor.narrow_copy": {
         "Matcher": "NarrowCopyMatcher",
         "args_list": [
             "dim",
             "start",
             "length"
         ],
         "min_input_args": 3
     },
     "torch.Tensor.ndimension": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.ndimension"
     },
     "torch.Tensor.neg": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.neg"
     },
     "torch.Tensor.neg_": {
         "Matcher": "GenericMatcher",
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.neg_"
     },
     "torch.Tensor.negative": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.neg"
     },
     "torch.Tensor.negative_": {
         "Matcher": "GenericMatcher",
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.neg_"
     },
     "torch.Tensor.nelement": {
         "Matcher": "Func2Attribute",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.size"
     },
     "torch.Tensor.new_empty": {
         "Matcher": "TensorNew_Matcher",
         "args_list": [
             "size",
             "*",
@@ -2162,17 +2578,15 @@
     "torch.Tensor.new_tensor": {
         "Matcher": "TensorNewTensorMatcher",
         "args_list": [
             "data",
             "*",
             "dtype",
             "device",
-            "requires_grad",
-            "layout",
-            "pin_memory"
+            "requires_grad"
         ],
         "kwargs_change": {
             "device": "place"
         },
         "min_input_args": 1,
         "paddle_api": "paddle.to_tensor"
     },
@@ -2199,15 +2613,20 @@
             "other": "y"
         },
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.nextafter"
     },
     "torch.Tensor.nextafter_": {},
     "torch.Tensor.nonzero": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "args_list": [
+            "*",
+            "as_tuple"
+        ],
+        "min_input_args": 0
     },
     "torch.Tensor.norm": {
         "Matcher": "NormMatcher",
         "args_list": [
             "p",
             "dim",
             "keepdim",
@@ -2237,14 +2656,15 @@
             "other"
         ],
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.not_equal_"
     },
     "torch.Tensor.numel": {
         "Matcher": "Func2Attribute",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.size"
     },
     "torch.Tensor.numpy": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "*",
             "force"
@@ -2254,35 +2674,41 @@
         },
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.numpy"
     },
     "torch.Tensor.orgqr": {},
     "torch.Tensor.ormqr": {},
     "torch.Tensor.outer": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "args_list": [
             "vec2"
         ],
         "kwargs_change": {
             "vec2": "y"
         },
         "min_input_args": 1,
-        "paddle_api": "paddle.outer"
+        "paddle_api": "paddle.Tensor.outer"
     },
     "torch.Tensor.permute": {
         "Matcher": "TensorPermuteMatcher",
+        "args_list": [
+            "*dims"
+        ],
+        "min_input_args": 1,
         "paddle_api": "paddle.Tensor.transpose"
     },
     "torch.Tensor.pin_memory": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.pin_memory"
     },
     "torch.Tensor.pinverse": {
-        "Matcher": "TensorFunc2PaddleFunc",
-        "paddle_api": "paddle.linalg.pinv"
+        "Matcher": "GenericMatcher",
+        "min_input_args": 0,
+        "paddle_api": "paddle.Tensor.pinv"
     },
     "torch.Tensor.polygamma": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "n"
         ],
         "min_input_args": 1,
@@ -2320,14 +2746,15 @@
         "paddle_api": "paddle.Tensor.pow_"
     },
     "torch.Tensor.prod": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "dim",
             "keepdim",
+            "*",
             "dtype"
         ],
         "kwargs_change": {
             "dim": "axis",
             "dtype": "dtype"
         },
         "min_input_args": 0,
@@ -2344,195 +2771,238 @@
         "args_list": [
             "some"
         ],
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.qr"
     },
     "torch.Tensor.qscheme": {},
-    "torch.Tensor.quantile": {},
+    "torch.Tensor.quantile": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "q",
+            "dim",
+            "keepdim",
+            "*",
+            "interpolation"
+        ],
+        "kwargs_change": {
+            "dim": "axis"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.Tensor.quantile"
+    },
     "torch.Tensor.rad2deg": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.random_": {},
     "torch.Tensor.ravel": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.flatten"
     },
     "torch.Tensor.reciprocal": {
-        "Matcher": "TensorFunc2PaddleFunc",
-        "paddle_api": "paddle.reciprocal"
+        "Matcher": "GenericMatcher",
+        "min_input_args": 0,
+        "paddle_api": "paddle.Tensor.reciprocal"
     },
     "torch.Tensor.reciprocal_": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.reciprocal_"
     },
     "torch.Tensor.record_stream": {},
-    "torch.Tensor.refine_names": {},
+    "torch.Tensor.refine_names": {
+        "min_input_args": 0
+    },
     "torch.Tensor.register_hook": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "hook"
         ],
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.register_hook"
     },
     "torch.Tensor.remainder": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "args_list": [
             "divisor"
         ],
         "kwargs_change": {
             "divisor": "y"
         },
         "min_input_args": 1,
-        "paddle_api": "paddle.remainder"
+        "paddle_api": "paddle.Tensor.remainder"
     },
     "torch.Tensor.remainder_": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "args_list": [
-            "divisor"
+            "other"
         ],
         "kwargs_change": {
-            "divisor": "y"
+            "other": "y"
         },
         "min_input_args": 1,
-        "paddle_api": "paddle.remainder_"
+        "paddle_api": "paddle.Tensor.remainder_"
     },
     "torch.Tensor.rename": {
-        "Matcher": "TensorRenameMatcher"
+        "Matcher": "TensorRenameMatcher",
+        "args_list": [
+            "*names",
+            "**rename_map"
+        ],
+        "min_input_args": 0
+    },
+    "torch.Tensor.rename_": {
+        "min_input_args": 0
     },
-    "torch.Tensor.rename_": {},
     "torch.Tensor.renorm": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "args_list": [
             "p",
             "dim",
             "maxnorm"
         ],
         "kwargs_change": {
             "dim": "axis",
             "maxnorm": "max_norm"
         },
         "min_input_args": 3,
-        "paddle_api": "paddle.renorm"
+        "paddle_api": "paddle.Tensor.renorm"
     },
     "torch.Tensor.renorm_": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "args_list": [
             "p",
             "dim",
             "maxnorm"
         ],
         "kwargs_change": {
             "dim": "axis",
             "maxnorm": "max_norm"
         },
         "min_input_args": 3,
-        "paddle_api": "paddle.renorm_"
+        "paddle_api": "paddle.Tensor.renorm_"
     },
     "torch.Tensor.repeat": {
-        "Matcher": "TensorRepeatMatcher"
+        "Matcher": "TensorRepeatMatcher",
+        "args_list": [
+            "*repeats"
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.Tensor.tile"
     },
     "torch.Tensor.repeat_interleave": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "repeats",
             "dim",
             "*",
             "output_size"
         ],
         "kwargs_change": {
-            "dim": "axis"
+            "dim": "axis",
+            "output_size": ""
         },
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.repeat_interleave"
     },
-    "torch.Tensor.requires_grad": {},
     "torch.Tensor.requires_grad_": {
         "Matcher": "TensorRequiresGrad_Matcher",
         "args_list": [
             "requires_grad"
         ],
         "min_input_args": 0
     },
     "torch.Tensor.reshape": {
-        "Matcher": "TensorReshapeMatcher"
+        "Matcher": "TensorReshapeMatcher",
+        "args_list": [
+            "*shape"
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.Tensor.reshape"
     },
     "torch.Tensor.reshape_as": {
         "Matcher": "TensorReshape_asMatcher",
         "args_list": [
             "other"
         ],
         "min_input_args": 1
     },
     "torch.Tensor.resize_": {},
     "torch.Tensor.resize_as_": {
         "Matcher": "TensorResize_as_Matcher",
         "args_list": [
             "the_template",
+            "*",
             "memory_format"
         ],
         "kwargs_change": {
             "memory_format": ""
         },
         "min_input_args": 1
     },
     "torch.Tensor.resolve_conj": {},
     "torch.Tensor.resolve_neg": {},
     "torch.Tensor.retain_grad": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.retain_grads"
     },
     "torch.Tensor.retains_grad": {},
     "torch.Tensor.roll": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "shifts",
             "dims"
         ],
         "kwargs_change": {
             "dims": "axis"
         },
-        "min_input_args": 2,
+        "min_input_args": 1,
         "paddle_api": "paddle.Tensor.roll"
     },
     "torch.Tensor.rot90": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "args_list": [
             "k",
             "dims"
         ],
         "kwargs_change": {
             "dims": "axes"
         },
         "min_input_args": 0,
-        "paddle_api": "paddle.rot90"
+        "paddle_api": "paddle.Tensor.rot90"
     },
     "torch.Tensor.round": {
         "Matcher": "TensorRoundMatcher",
         "args_list": [
             "*",
             "decimals"
         ],
-        "min_input_args": 0
+        "min_input_args": 0,
+        "paddle_api": "paddle.Tensor.round"
     },
     "torch.Tensor.round_": {
         "Matcher": "TensorRound_Matcher",
         "args_list": [
             "*",
             "decimals"
         ],
-        "min_input_args": 0
+        "min_input_args": 0,
+        "paddle_api": "paddle.Tensor.round_"
     },
     "torch.Tensor.rsqrt": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.rsqrt"
     },
     "torch.Tensor.rsqrt_": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.rsqrt_"
     },
     "torch.Tensor.scatter": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "dim",
             "index",
@@ -2553,25 +3023,29 @@
         ]
     },
     "torch.Tensor.scatter_": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "dim",
             "index",
-            "src",
+            "value",
             "*",
+            "src",
             "reduce"
         ],
         "kwargs_change": {
             "dim": "axis",
             "index": "indices",
-            "src": "values"
+            "value": "values"
         },
         "min_input_args": 3,
-        "paddle_api": "paddle.Tensor.put_along_axis_"
+        "paddle_api": "paddle.Tensor.put_along_axis_",
+        "unsupport_args": [
+            "src"
+        ]
     },
     "torch.Tensor.scatter_add": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "dim",
             "index",
             "src"
@@ -2615,69 +3089,86 @@
         ],
         "min_input_args": 2
     },
     "torch.Tensor.select_scatter": {},
     "torch.Tensor.set_": {},
     "torch.Tensor.sgn": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.sgn"
     },
     "torch.Tensor.sgn_": {},
-    "torch.Tensor.share_memory_": {},
+    "torch.Tensor.share_memory_": {
+        "min_input_args": 0
+    },
     "torch.Tensor.short": {
         "Matcher": "TensorShortMatcher",
         "args_list": [
+            "*",
             "memory_format"
         ],
-        "min_input_args": 0
+        "min_input_args": 0,
+        "paddle_api": "paddle.Tensor.astype"
     },
     "torch.Tensor.sigmoid": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.sigmoid"
     },
     "torch.Tensor.sigmoid_": {
         "Matcher": "GenericMatcher",
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.sigmoid_"
     },
     "torch.Tensor.sign": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.sign_": {},
-    "torch.Tensor.signbit": {},
+    "torch.Tensor.signbit": {
+        "Matcher": "GenericMatcher",
+        "args_list": [],
+        "min_input_args": 1,
+        "paddle_api": "paddle.Tensor.signbit"
+    },
     "torch.Tensor.sin": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.sin_": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "min_input_args": 0,
-        "paddle_api": "paddle.sin_"
+        "paddle_api": "paddle.Tensor.sin_"
     },
     "torch.Tensor.sinc": {
-        "Matcher": "SincMatcher"
+        "Matcher": "SincMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.sinc_": {},
     "torch.Tensor.sinh": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.sinh_": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "min_input_args": 0,
-        "paddle_api": "paddle.sinh_"
+        "paddle_api": "paddle.Tensor.sinh_"
     },
     "torch.Tensor.size": {
         "Matcher": "TensorSizeMatcher",
         "args_list": [
             "dim"
         ],
-        "min_input_args": 0
+        "min_input_args": 0,
+        "paddle_api": "paddle.Tensor.shape"
     },
     "torch.Tensor.slice_scatter": {},
     "torch.Tensor.slogdet": {
         "Matcher": "SLogDetMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.linalg.slogdet"
     },
     "torch.Tensor.smm": {},
     "torch.Tensor.softmax": {
         "Matcher": "TensorSoftmaxMatcher",
         "args_list": [
             "dim",
@@ -2717,18 +3208,20 @@
             "split_size",
             "dim"
         ],
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.split"
     },
     "torch.Tensor.sqrt": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.sqrt_": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.sqrt_"
     },
     "torch.Tensor.square": {
         "Matcher": "GenericMatcher",
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.square"
     },
@@ -2773,18 +3266,24 @@
         "kwargs_change": {
             "correction": "unbiased",
             "dim": "axis"
         },
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.std"
     },
-    "torch.Tensor.stft": {},
-    "torch.Tensor.storage": {},
+    "torch.Tensor.stft": {
+        "min_input_args": 1
+    },
+    "torch.Tensor.storage": {
+        "min_input_args": 0
+    },
     "torch.Tensor.storage_offset": {},
-    "torch.Tensor.storage_type": {},
+    "torch.Tensor.storage_type": {
+        "min_input_args": 0
+    },
     "torch.Tensor.stride": {},
     "torch.Tensor.subtract": {
         "Matcher": "TensorSubtractMatcher",
         "args_list": [
             "other",
             "*",
             "alpha"
@@ -2832,27 +3331,38 @@
     },
     "torch.Tensor.swapaxes": {
         "Matcher": "SwapAxesMatcher",
         "args_list": [
             "axis0",
             "axis1"
         ],
-        "min_input_args": 2
+        "min_input_args": 2,
+        "paddle_api": "paddle.transpose"
     },
     "torch.Tensor.swapdims": {
         "Matcher": "SwapAxesMatcher",
         "args_list": [
             "dim0",
             "dim1"
         ],
-        "min_input_args": 2
+        "min_input_args": 2,
+        "paddle_api": "paddle.transpose"
+    },
+    "torch.Tensor.symeig": {
+        "Matcher": "SymeigMatcher",
+        "args_list": [
+            "eigenvectors",
+            "upper"
+        ],
+        "min_input_args": 0,
+        "paddle_api": "paddle.linalg.eigh"
     },
-    "torch.Tensor.symeig": {},
     "torch.Tensor.t": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.t"
     },
     "torch.Tensor.t_": {},
     "torch.Tensor.take": {
         "Matcher": "TensorTakeMatcher",
         "args_list": [
             "index"
@@ -2869,43 +3379,71 @@
         "kwargs_change": {
             "dim": "axis"
         },
         "min_input_args": 2,
         "paddle_api": "paddle.Tensor.take_along_axis"
     },
     "torch.Tensor.tan": {
-        "Matcher": "TensorFunc2PaddleFunc",
-        "paddle_api": "paddle.tan"
+        "Matcher": "GenericMatcher",
+        "min_input_args": 0,
+        "paddle_api": "paddle.Tensor.tan"
     },
     "torch.Tensor.tan_": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "min_input_args": 0,
-        "paddle_api": "paddle.tan_"
+        "paddle_api": "paddle.Tensor.tan_"
     },
     "torch.Tensor.tanh": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.tanh_": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "min_input_args": 0,
-        "paddle_api": "paddle.tanh_"
+        "paddle_api": "paddle.Tensor.tanh_"
     },
     "torch.Tensor.tensor_split": {},
-    "torch.Tensor.tile": {},
+    "torch.Tensor.tile": {
+        "Matcher": "TensorTileMatcher",
+        "args_list": [
+            "*dims"
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.Tensor.tile"
+    },
     "torch.Tensor.to": {
-        "Matcher": "TensorToMatcher"
+        "Matcher": "TensorToMatcher",
+        "args_list": [
+            "other",
+            "device",
+            "dtype",
+            "non_blocking",
+            "copy",
+            "memory_format"
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.Tensor.to"
     },
     "torch.Tensor.to_dense": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.to_dense"
     },
     "torch.Tensor.to_mkldnn": {},
-    "torch.Tensor.to_sparse": {},
+    "torch.Tensor.to_sparse": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "sparse_dim"
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.Tensor.to_sparse_coo"
+    },
     "torch.Tensor.tolist": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.topk": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "k",
             "dim",
             "largest",
@@ -2914,58 +3452,69 @@
         "kwargs_change": {
             "dim": "axis"
         },
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.topk"
     },
     "torch.Tensor.trace": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.transpose": {
         "Matcher": "TensorTransposeMatcher",
         "args_list": [
             "dim0",
             "dim1"
         ],
         "min_input_args": 2,
         "paddle_api": "paddle.Tensor.transpose"
     },
     "torch.Tensor.transpose_": {},
-    "torch.Tensor.triangular_solve": {},
+    "torch.Tensor.triangular_solve": {
+        "Matcher": "TensorTriangularSolveMatcher",
+        "args_list": [
+            "A",
+            "upper",
+            "transpose",
+            "unitriangular"
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.linalg.triangular_solve"
+    },
     "torch.Tensor.tril": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "args_list": [
             "diagonal"
         ],
         "min_input_args": 0,
-        "paddle_api": "paddle.tril"
+        "paddle_api": "paddle.Tensor.tril"
     },
     "torch.Tensor.tril_": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "args_list": [
             "diagonal"
         ],
         "min_input_args": 0,
-        "paddle_api": "paddle.tril_"
+        "paddle_api": "paddle.Tensor.tril_"
     },
     "torch.Tensor.triu": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "args_list": [
             "diagonal"
         ],
         "min_input_args": 0,
-        "paddle_api": "paddle.triu"
+        "paddle_api": "paddle.Tensor.triu"
     },
     "torch.Tensor.triu_": {
-        "Matcher": "TensorFunc2PaddleFunc",
+        "Matcher": "GenericMatcher",
         "args_list": [
             "diagonal"
         ],
         "min_input_args": 0,
-        "paddle_api": "paddle.triu_"
+        "paddle_api": "paddle.Tensor.triu_"
     },
     "torch.Tensor.true_divide": {
         "Matcher": "Num2TensorBinaryMatcher",
         "args_list": [
             "other"
         ],
         "kwargs_change": {
@@ -2978,14 +3527,15 @@
         "Matcher": "Num2TensorBinaryMatcher",
         "args_list": [
             "other"
         ],
         "kwargs_change": {
             "other": "y"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.Tensor.divide_"
     },
     "torch.Tensor.trunc": {
         "Matcher": "UnchangeMatcher",
         "min_input_args": 0
     },
     "torch.Tensor.trunc_": {
@@ -2993,23 +3543,24 @@
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.trunc_"
     },
     "torch.Tensor.type": {
         "Matcher": "TensorTypeMatcher",
         "args_list": [
             "dtype",
-            "non_blocking"
+            "non_blocking",
+            "dst_type"
         ],
         "min_input_args": 0,
         "paddle_api": "paddle.Tensor.astype"
     },
     "torch.Tensor.type_as": {
         "Matcher": "TensorTypeAsMatcher",
         "args_list": [
-            "tensor"
+            "other"
         ],
         "min_input_args": 1
     },
     "torch.Tensor.unbind": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "dim"
@@ -3029,15 +3580,27 @@
         "kwargs_change": {
             "dim": "axis",
             "sizes": "shape"
         },
         "min_input_args": 2,
         "paddle_api": "paddle.Tensor.unflatten"
     },
-    "torch.Tensor.unfold": {},
+    "torch.Tensor.unfold": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "dimension",
+            "size",
+            "step"
+        ],
+        "kwargs_change": {
+            "dimension": "axis"
+        },
+        "min_input_args": 3,
+        "paddle_api": "paddle.Tensor.unfold"
+    },
     "torch.Tensor.uniform_": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "from",
             "to"
         ],
         "kwargs_change": {
@@ -3096,15 +3659,16 @@
         "kwargs_change": {
             "dim": "axis"
         },
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.unsqueeze_"
     },
     "torch.Tensor.values": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "min_input_args": 0
     },
     "torch.Tensor.var": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "dim",
             "unbiased",
             "keepdim",
@@ -3125,16 +3689,31 @@
         ],
         "kwargs_change": {
             "other": "y"
         },
         "min_input_args": 1,
         "paddle_api": "paddle.Tensor.dot"
     },
-    "torch.Tensor.view": {},
-    "torch.Tensor.view_as": {},
+    "torch.Tensor.view": {
+        "Matcher": "TensorViewMatcher",
+        "args_list": [
+            "*size",
+            "dtype"
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.Tensor.view"
+    },
+    "torch.Tensor.view_as": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "other"
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.Tensor.view_as"
+    },
     "torch.Tensor.vsplit": {},
     "torch.Tensor.where": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "condition",
             "y"
         ],
@@ -3147,20 +3726,17 @@
             "other"
         ],
         "min_input_args": 1
     },
     "torch.Tensor.xlogy_": {},
     "torch.Tensor.zero_": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.Tensor.zero_"
     },
-    "torch.__version__": {
-        "Matcher": "GenericMatcher",
-        "paddle_api": "paddle.__version__"
-    },
     "torch.abs": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
@@ -3213,15 +3789,15 @@
             "input",
             "tensor1",
             "tensor2",
             "*",
             "value",
             "out"
         ],
-        "min_input_args": 2
+        "min_input_args": 3
     },
     "torch.addcmul": {
         "Matcher": "AddCMulMatcher",
         "args_list": [
             "input",
             "tensor1",
             "tensor2",
@@ -3567,14 +4143,30 @@
         ],
         "kwargs_change": {
             "input": "x"
         },
         "min_input_args": 1,
         "paddle_api": "paddle.nonzero"
     },
+    "torch.as_strided": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "input",
+            "size",
+            "stride",
+            "storage_offset"
+        ],
+        "kwargs_change": {
+            "input": "x",
+            "size": "shape",
+            "storage_offset": "offset"
+        },
+        "min_input_args": 3,
+        "paddle_api": "paddle.as_strided"
+    },
     "torch.as_tensor": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "data",
             "*",
             "dtype",
             "device"
@@ -3601,14 +4193,38 @@
             "device": "place",
             "dtype": "dtype",
             "obj": "data"
         },
         "min_input_args": 1,
         "paddle_api": "paddle.to_tensor"
     },
+    "torch.atleast_1d": {
+        "Matcher": "AtleastMatcher",
+        "args_list": [
+            "*tensors"
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.atleast_1d"
+    },
+    "torch.atleast_2d": {
+        "Matcher": "AtleastMatcher",
+        "args_list": [
+            "*tensors"
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.atleast_2d"
+    },
+    "torch.atleast_3d": {
+        "Matcher": "AtleastMatcher",
+        "args_list": [
+            "*tensors"
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.atleast_3d"
+    },
     "torch.autocast": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "device_type",
             "dtype",
             "enabled",
             "cache_enabled"
@@ -3620,18 +4236,26 @@
             "enabled": "enable"
         },
         "min_input_args": 1,
         "paddle_api": "paddle.amp.auto_cast"
     },
     "torch.autograd.Function": {
         "Matcher": "GenericMatcher",
+        "abstract": true,
+        "min_input_args": 0,
         "paddle_api": "paddle.autograd.PyLayer"
     },
-    "torch.autograd.Function.backward": {},
-    "torch.autograd.Function.forward": {},
+    "torch.autograd.Function.backward": {
+        "abstract": true,
+        "min_input_args": 1
+    },
+    "torch.autograd.Function.forward": {
+        "abstract": true,
+        "min_input_args": 1
+    },
     "torch.autograd.backward": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "tensors",
             "grad_tensors",
             "retain_graph",
             "create_graph",
@@ -3642,27 +4266,47 @@
         "paddle_api": "paddle.autograd.backward",
         "unsupport_args": [
             "create_graph",
             "grad_variables",
             "inputs"
         ]
     },
+    "torch.autograd.enable_grad": {
+        "Matcher": "GenericMatcher",
+        "min_input_args": 0,
+        "paddle_api": "paddle.enable_grad"
+    },
     "torch.autograd.function.FunctionCtx": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.autograd.PyLayerContext"
     },
-    "torch.autograd.function.FunctionCtx.mark_dirty": {},
+    "torch.autograd.function.FunctionCtx.mark_dirty": {
+        "min_input_args": 0
+    },
     "torch.autograd.function.FunctionCtx.mark_non_differentiable": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "args_list": [
+            "*args"
+        ],
+        "min_input_args": 1
+    },
+    "torch.autograd.function.FunctionCtx.mark_shared_storage": {
+        "min_input_args": 0
     },
-    "torch.autograd.function.FunctionCtx.mark_shared_storage": {},
     "torch.autograd.function.FunctionCtx.save_for_backward": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "args_list": [
+            "*tensors"
+        ],
+        "min_input_args": 1
+    },
+    "torch.autograd.function.FunctionCtx.save_for_forward": {
+        "min_input_args": 0
     },
-    "torch.autograd.function.FunctionCtx.save_for_forward": {},
     "torch.autograd.function.FunctionCtx.set_materialize_grads": {
         "Matcher": "UnchangeMatcher",
         "args_list": [
             "value"
         ],
         "min_input_args": 1
     },
@@ -3780,52 +4424,63 @@
         "args_list": [
             "pack_hook",
             "unpack_hook"
         ],
         "min_input_args": 2,
         "paddle_api": "paddle.autograd.saved_tensors_hooks"
     },
-    "torch.autograd.profiler.profile": {},
-    "torch.autograd.profiler.profile.config": {},
+    "torch.autograd.profiler.profile": {
+        "min_input_args": 0
+    },
+    "torch.autograd.profiler.profile.config": {
+        "min_input_args": 0
+    },
     "torch.autograd.profiler.profile.export_chrome_trace": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "path"
         ],
         "kwargs_change": {
             "path": "dir_name"
         },
         "min_input_args": 1,
         "paddle_api": "paddle.profiler.export_chrome_tracing"
     },
-    "torch.autograd.profiler.profile.export_stacks": {},
-    "torch.autograd.profiler.profile.key_averages": {},
-    "torch.autograd.profiler.profile.table": {},
-    "torch.autograd.profiler.profile.total_average": {},
-    "torch.backends.cuda.is_built": {
-        "Matcher": "GenericMatcher",
-        "paddle_api": "paddle.device.is_compiled_with_cuda"
+    "torch.autograd.profiler.profile.export_stacks": {
+        "min_input_args": 1
     },
-    "torch.backends.cudnn.allow_tf32": {
-        "Matcher": "SetTrueMatcher"
+    "torch.autograd.profiler.profile.key_averages": {
+        "min_input_args": 0
     },
-    "torch.backends.cudnn.benchmark": {
-        "Matcher": "SetFalseMatcher"
+    "torch.autograd.profiler.profile.table": {
+        "min_input_args": 0
     },
-    "torch.backends.cudnn.deterministic": {
-        "Matcher": "SetFalseMatcher"
+    "torch.autograd.profiler.profile.total_average": {
+        "min_input_args": 0
     },
-    "torch.backends.cudnn.enabled": {
-        "Matcher": "SetTrueMatcher"
+    "torch.autograd.set_grad_enabled": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "mode"
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.set_grad_enabled"
+    },
+    "torch.backends.cuda.is_built": {
+        "Matcher": "GenericMatcher",
+        "min_input_args": 0,
+        "paddle_api": "paddle.device.is_compiled_with_cuda"
     },
     "torch.backends.cudnn.is_available": {
-        "Matcher": "CudnnIsAvailableMatcher"
+        "Matcher": "CudnnIsAvailableMatcher",
+        "min_input_args": 0
     },
     "torch.backends.cudnn.version": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.device.get_cudnn_version"
     },
     "torch.baddbmm": {
         "Matcher": "AddMRMatcher",
         "args_list": [
             "input",
             "batch1",
@@ -3852,113 +4507,128 @@
             "input": "x"
         },
         "paddle_api": "paddle.bernoulli",
         "unsupport_args": [
             "p"
         ]
     },
-    "torch.bfloat16": {
-        "Matcher": "GenericMatcher",
-        "paddle_api": "'bfloat16'"
-    },
     "torch.binary_cross_entropy_with_logits": {},
     "torch.bincount": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "weights",
             "minlength"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.bincount"
     },
     "torch.bitwise_and": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.bitwise_and"
     },
     "torch.bitwise_not": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.bitwise_not"
     },
     "torch.bitwise_or": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.bitwise_or"
     },
     "torch.bitwise_xor": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.bitwise_xor"
     },
     "torch.bmm": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "mat2",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "mat2": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.bmm"
     },
-    "torch.bool": {
-        "Matcher": "GenericMatcher",
-        "paddle_api": "'bool'"
+    "torch.broadcast_shapes": {
+        "Matcher": "BroadcastShapesMatcher",
+        "args_list": [
+            "*shapes"
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.broadcast_shape"
+    },
+    "torch.broadcast_tensors": {
+        "Matcher": "BroadcastTensorsMatcher",
+        "args_list": [
+            "*tensors"
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.broadcast_tensors"
     },
     "torch.broadcast_to": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "size"
         ],
         "kwargs_change": {
             "input": "x",
             "size": "shape"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.broadcast_to"
     },
     "torch.bucketize": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "boundaries",
@@ -3967,251 +4637,276 @@
             "right",
             "out"
         ],
         "kwargs_change": {
             "boundaries": "sorted_sequence",
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.bucketize"
     },
     "torch.cat": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "tensors",
             "dim",
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "tensors": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.concat"
     },
     "torch.cdist": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "x1",
             "x2",
             "p",
             "compute_mode"
         ],
         "kwargs_change": {
             "x1": "x",
             "x2": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.cdist"
     },
-    "torch.cdouble": {
-        "Matcher": "GenericMatcher",
-        "paddle_api": "'complex128'"
-    },
     "torch.ceil": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.ceil"
     },
     "torch.celu": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "alpha"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.celu"
     },
-    "torch.cfloat": {
-        "Matcher": "GenericMatcher",
-        "paddle_api": "'complex64'"
-    },
     "torch.chain_matmul": {
-        "Matcher": "Chain_MatmulMatcher"
+        "Matcher": "Chain_MatmulMatcher",
+        "args_list": [
+            "*matrices",
+            "out"
+        ],
+        "min_input_args": 1
     },
     "torch.cholesky": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "upper",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.linalg.cholesky"
     },
     "torch.cholesky_inverse": {
         "Matcher": "CholeskyInverseMatcher",
         "args_list": [
             "input",
             "upper",
             "*",
             "out"
-        ]
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.linalg.inv"
     },
     "torch.cholesky_solve": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "input2",
             "upper",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "input2": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.linalg.cholesky_solve"
     },
     "torch.chunk": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "chunks",
             "dim"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.chunk"
     },
     "torch.clamp": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "min",
             "max",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.clip"
     },
-    "torch.clamp_min": {
+    "torch.clamp_max": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
-            "min",
+            "max",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.clip"
     },
-    "torch.clip": {
+    "torch.clamp_min": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "min",
-            "max",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.clip"
     },
     "torch.clone": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "memory_format"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.clone"
     },
     "torch.column_stack": {
-        "Matcher": "ColumnStackMatcher",
+        "Matcher": "GenericMatcher",
         "args_list": [
             "tensors",
             "*",
             "out"
-        ]
+        ],
+        "kwargs_change": {
+            "tensors": "x"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.column_stack"
+    },
+    "torch.combinations": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "input",
+            "r",
+            "with_replacement"
+        ],
+        "kwargs_change": {
+            "input": "x"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.combinations"
     },
     "torch.complex": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "real",
             "imag",
             "*",
             "out"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.complex"
     },
-    "torch.complex128": {
-        "Matcher": "GenericMatcher",
-        "paddle_api": "'complex128'"
-    },
-    "torch.complex64": {
-        "Matcher": "GenericMatcher",
-        "paddle_api": "'complex64'"
-    },
     "torch.concat": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "tensors",
             "dim",
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "tensors": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.concat"
     },
     "torch.conj": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.conj"
     },
     "torch.conj_physical": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.conj"
     },
     "torch.corrcoef": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.linalg.corrcoef",
         "paddle_default_kwargs": {
             "rowvar": "True"
         }
     },
     "torch.cos": {
         "Matcher": "GenericMatcher",
@@ -4219,39 +4914,42 @@
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.cos"
     },
     "torch.cosh": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.cosh"
     },
     "torch.cosine_embedding_loss": {},
     "torch.count_nonzero": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dim"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.count_nonzero"
     },
     "torch.cov": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
@@ -4259,28 +4957,30 @@
             "fweights",
             "aweights"
         ],
         "kwargs_change": {
             "correction": "ddof",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.linalg.cov"
     },
     "torch.cpu.amp.autocast": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "enabled",
             "dtype",
             "cache_enabled"
         ],
         "kwargs_change": {
             "cache_enabled": "",
             "dtype": "dtype",
             "enabled": "enable"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.amp.auto_cast"
     },
     "torch.cross": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "other",
@@ -4289,67 +4989,70 @@
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.cross"
     },
     "torch.ctc_loss": {},
     "torch.cuda.BoolTensor": {
         "Matcher": "TensorMatcher",
-        "paddle_api": "paddle.Tensor"
+        "paddle_api": "paddle.bool"
     },
     "torch.cuda.ByteTensor": {
         "Matcher": "TensorMatcher",
-        "paddle_api": "paddle.Tensor"
+        "paddle_api": "paddle.uint8"
     },
     "torch.cuda.DoubleTensor": {
         "Matcher": "TensorMatcher",
-        "paddle_api": "paddle.Tensor"
+        "paddle_api": "paddle.float64"
     },
     "torch.cuda.Event": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "enable_timing",
             "blocking",
             "interprocess"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.device.cuda.Event"
     },
     "torch.cuda.FloatTensor": {
         "Matcher": "TensorMatcher",
-        "paddle_api": "paddle.Tensor"
+        "paddle_api": "paddle.float32"
     },
     "torch.cuda.HalfTensor": {
         "Matcher": "TensorMatcher",
-        "paddle_api": "paddle.Tensor"
+        "paddle_api": "paddle.float16"
     },
     "torch.cuda.IntTensor": {
         "Matcher": "TensorMatcher",
-        "paddle_api": "paddle.Tensor"
+        "paddle_api": "paddle.int32"
     },
     "torch.cuda.LongTensor": {
         "Matcher": "TensorMatcher",
-        "paddle_api": "paddle.Tensor"
+        "paddle_api": "paddle.int64"
     },
     "torch.cuda.ShortTensor": {
         "Matcher": "TensorMatcher",
-        "paddle_api": "paddle.Tensor"
+        "paddle_api": "paddle.int16"
     },
     "torch.cuda.Stream": {
         "Matcher": "CudaStreamMatcher",
         "args_list": [
             "device",
             "priority"
         ],
         "kwargs_change": {
             "device": "device"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.device.cuda.Stream"
     },
     "torch.cuda.amp.GradScaler": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "init_scale",
             "growth_factor",
@@ -4360,14 +5063,15 @@
         "kwargs_change": {
             "backoff_factor": "decr_ratio",
             "enabled": "enable",
             "growth_factor": "incr_ratio",
             "growth_interval": "incr_every_n_steps",
             "init_scale": "init_loss_scaling"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.amp.GradScaler",
         "paddle_default_kwargs": {
             "incr_every_n_steps": 2000,
             "init_loss_scaling": 65536.0
         }
     },
     "torch.cuda.amp.autocast": {
@@ -4378,180 +5082,237 @@
             "cache_enabled"
         ],
         "kwargs_change": {
             "cache_enabled": "",
             "dtype": "dtype",
             "enabled": "enable"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.amp.auto_cast"
     },
     "torch.cuda.current_device": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.framework._current_expected_place"
     },
     "torch.cuda.current_stream": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "device"
         ],
         "kwargs_change": {
             "device": "device"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.device.cuda.current_stream"
     },
     "torch.cuda.device_count": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.device.cuda.device_count"
     },
     "torch.cuda.empty_cache": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.device.cuda.empty_cache"
     },
     "torch.cuda.get_device_capability": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "device"
         ],
         "kwargs_change": {
             "device": "device"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.device.cuda.get_device_capability"
     },
+    "torch.cuda.get_device_name": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "device"
+        ],
+        "kwargs_change": {
+            "device": "device"
+        },
+        "min_input_args": 0,
+        "paddle_api": "paddle.device.cuda.get_device_name"
+    },
     "torch.cuda.get_device_properties": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "device"
         ],
         "kwargs_change": {
             "device": "device"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.device.cuda.get_device_properties"
     },
     "torch.cuda.get_rng_state_all": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.get_rng_state"
     },
     "torch.cuda.initial_seed": {
-        "Matcher": "CudaSeedMatcher"
+        "Matcher": "CudaSeedMatcher",
+        "min_input_args": 0
     },
     "torch.cuda.is_available": {
         "Matcher": "CudaIsAvailableMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.device.cuda.device_count"
     },
     "torch.cuda.manual_seed": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "seed"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.seed"
     },
     "torch.cuda.manual_seed_all": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "seed"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.seed"
     },
     "torch.cuda.max_memory_allocated": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "device"
         ],
         "kwargs_change": {
             "device": "device"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.device.cuda.max_memory_allocated"
     },
     "torch.cuda.max_memory_reserved": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "device"
         ],
         "kwargs_change": {
             "device": "device"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.device.cuda.max_memory_reserved"
     },
     "torch.cuda.memory_allocated": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "device"
         ],
         "kwargs_change": {
             "device": "device"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.device.cuda.memory_allocated"
     },
     "torch.cuda.memory_reserved": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "device"
         ],
         "kwargs_change": {
             "device": "device"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.device.cuda.memory_reserved"
     },
     "torch.cuda.nvtx.range_pop": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.framework.core.nvprof_nvtx_pop"
     },
     "torch.cuda.nvtx.range_push": {
         "Matcher": "CudaNvtxRangePushMatcher",
         "args_list": [
             "msg"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.framework.core.nvprof_nvtx_push"
     },
     "torch.cuda.set_device": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "device"
         ],
         "kwargs_change": {
             "device": "device"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.device.set_device"
     },
     "torch.cuda.set_rng_state_all": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "new_states"
         ],
         "kwargs_change": {
             "new_states": "state_list"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.set_rng_state"
     },
     "torch.cuda.set_stream": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "stream"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.device.set_stream"
     },
+    "torch.cuda.stream": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "stream"
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.device.cuda.stream_guard"
+    },
     "torch.cuda.synchronize": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "device"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.device.cuda.synchronize"
     },
+    "torch.cummax": {
+        "Matcher": "DoubleAssignMatcher",
+        "args_list": [
+            "input",
+            "dim",
+            "*",
+            "out"
+        ],
+        "kwargs_change": {
+            "dim": "axis",
+            "input": "x"
+        },
+        "min_input_args": 2,
+        "paddle_api": "paddle.cummax"
+    },
     "torch.cummin": {
         "Matcher": "DoubleAssignMatcher",
         "args_list": [
             "input",
             "dim",
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.cummin"
     },
     "torch.cumprod": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dim",
@@ -4559,14 +5320,15 @@
             "dtype",
             "out"
         ],
         "kwargs_change": {
             "dtype": "dtype",
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.cumprod"
     },
     "torch.cumsum": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dim",
@@ -4575,92 +5337,101 @@
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "dtype": "dtype",
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.cumsum"
     },
     "torch.cumulative_trapezoid": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "y",
             "x",
             "*",
             "dx",
             "dim"
         ],
         "kwargs_change": {
             "dim": "axis"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.cumulative_trapezoid"
     },
     "torch.deg2rad": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.deg2rad"
     },
     "torch.det": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.linalg.det"
     },
     "torch.device": {
         "Matcher": "DeviceMatcher",
         "args_list": [
             "type",
             "index"
         ],
+        "min_input_args": 1,
         "paddle_api": "str"
     },
     "torch.diag": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "diagonal",
+            "*",
             "out"
         ],
         "kwargs_change": {
             "diagonal": "offset",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.diag"
     },
     "torch.diag_embed": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "offset",
             "dim1",
             "dim2"
         ],
-        "paddle_api": "paddle.nn.functional.diag_embed"
+        "min_input_args": 1,
+        "paddle_api": "paddle.diag_embed"
     },
     "torch.diagflat": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "offset"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.diagflat"
     },
     "torch.diagonal": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "offset",
@@ -4668,16 +5439,35 @@
             "dim2"
         ],
         "kwargs_change": {
             "dim1": "axis1",
             "dim2": "axis2",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.diagonal"
     },
+    "torch.diagonal_scatter": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "input",
+            "src",
+            "offset",
+            "dim1",
+            "dim2"
+        ],
+        "kwargs_change": {
+            "dim1": "axis1",
+            "dim2": "axis2",
+            "input": "x",
+            "src": "y"
+        },
+        "min_input_args": 2,
+        "paddle_api": "paddle.diagonal_scatter"
+    },
     "torch.diff": {
         "Matcher": "DiffMatcher",
         "args_list": [
             "input",
             "n",
             "dim",
             "prepend",
@@ -4698,59 +5488,128 @@
             "other",
             "p"
         ],
         "kwargs_change": {
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.dist"
     },
     "torch.distributed.ReduceOp": {
         "Matcher": "Func2Attribute",
         "paddle_api": "paddle.distributed.ReduceOp"
     },
+    "torch.distributed.all_gather": {
+        "Matcher": "ScatterMatcher",
+        "args_list": [
+            "tensor_list",
+            "tensor",
+            "group",
+            "async_op"
+        ],
+        "min_input_args": 2,
+        "paddle_api": "paddle.distributed.all_gather"
+    },
     "torch.distributed.all_gather_object": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "object_list",
             "obj",
             "group"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.distributed.all_gather_object"
     },
+    "torch.distributed.all_reduce": {
+        "Matcher": "ScatterMatcher",
+        "args_list": [
+            "tensor",
+            "op",
+            "group",
+            "async_op"
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.distributed.all_reduce"
+    },
     "torch.distributed.all_to_all": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "output_tensor_list",
             "input_tensor_list",
             "group",
             "async_op"
         ],
         "kwargs_change": {
             "async_op": "",
             "input_tensor_list": "in_tensor_list",
             "output_tensor_list": "out_tensor_list"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.distributed.alltoall"
     },
+    "torch.distributed.barrier": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "group"
+        ],
+        "min_input_args": 0,
+        "paddle_api": "paddle.distributed.barrier"
+    },
     "torch.distributed.broadcast": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "tensor",
             "src",
             "group",
             "async_op"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.distributed.broadcast",
         "unsupport_args": [
             "async_op"
         ]
     },
+    "torch.distributed.broadcast_object_list": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "object_list",
+            "src",
+            "group",
+            "device"
+        ],
+        "kwargs_change": {
+            "device": ""
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.distributed.broadcast_object_list"
+    },
+    "torch.distributed.gather": {
+        "Matcher": "ScatterMatcher",
+        "args_list": [
+            "tensor",
+            "gather_list",
+            "dst",
+            "group",
+            "async_op"
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.distributed.gather"
+    },
+    "torch.distributed.get_backend": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "group"
+        ],
+        "min_input_args": 0,
+        "paddle_api": "paddle.distributed.get_backend"
+    },
     "torch.distributed.get_rank": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.distributed.get_rank"
     },
     "torch.distributed.init_process_group": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "backend",
             "init_method",
@@ -4767,139 +5626,245 @@
             "init_method": "",
             "pg_options": "",
             "rank": "",
             "store": "",
             "timeout": "",
             "world_size": ""
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.distributed.init_parallel_env"
     },
+    "torch.distributed.irecv": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "tensor",
+            "src",
+            "group",
+            "tag"
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.distributed.irecv",
+        "unsupport_args": [
+            "tag"
+        ]
+    },
+    "torch.distributed.isend": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "tensor",
+            "dst",
+            "group",
+            "tag"
+        ],
+        "min_input_args": 2,
+        "paddle_api": "paddle.distributed.isend",
+        "unsupport_args": [
+            "tag"
+        ]
+    },
     "torch.distributed.new_group": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "ranks",
             "timeout",
             "backend",
             "pg_options"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.distributed.new_group",
         "unsupport_args": [
             "timeout",
             "pg_options"
         ]
     },
+    "torch.distributed.recv": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "tensor",
+            "src",
+            "group",
+            "tag"
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.distributed.recv",
+        "unsupport_args": [
+            "tag"
+        ]
+    },
+    "torch.distributed.reduce": {
+        "Matcher": "ScatterMatcher",
+        "args_list": [
+            "tensor",
+            "dst",
+            "op",
+            "group",
+            "async_op"
+        ],
+        "min_input_args": 2,
+        "paddle_api": "paddle.distributed.reduce"
+    },
     "torch.distributed.reduce_scatter": {
         "Matcher": "ScatterMatcher",
         "args_list": [
             "output",
             "input_list",
             "op",
             "group",
             "async_op"
         ],
         "kwargs_change": {
             "input_list": "tensor_list",
             "output": "tensor"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.distributed.reduce_scatter"
     },
     "torch.distributed.rpc.get_worker_info": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "worker_name"
         ],
         "kwargs_change": {
             "worker_name": "name"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.distributed.rpc.get_worker_info"
     },
     "torch.distributed.rpc.init_rpc": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "name",
             "backend",
             "rank",
             "world_size",
             "rpc_backend_options"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.distributed.rpc.init_rpc",
         "unsupport_args": [
             "rpc_backend_options"
         ]
     },
     "torch.distributed.rpc.shutdown": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.distributed.rpc.shutdown"
     },
     "torch.distributed.scatter": {
         "Matcher": "ScatterMatcher",
         "args_list": [
             "tensor",
             "scatter_list",
             "src",
             "group",
             "async_op"
         ],
         "kwargs_change": {
             "scatter_list": "tensor_list"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.distributed.scatter"
     },
     "torch.distributed.scatter_object_list": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "scatter_object_output_list",
             "scatter_object_input_list",
             "src",
             "group"
         ],
         "kwargs_change": {
             "scatter_object_input_list": "in_object_list",
             "scatter_object_output_list": "out_object_list"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.distributed.scatter_object_list"
     },
+    "torch.distributed.send": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "tensor",
+            "dst",
+            "group",
+            "tag"
+        ],
+        "min_input_args": 2,
+        "paddle_api": "paddle.distributed.send",
+        "unsupport_args": [
+            "tag"
+        ]
+    },
+    "torch.distributions.AbsTransform": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "cache_size"
+        ],
+        "kwargs_change": {
+            "cache_size": ""
+        },
+        "min_input_args": 0,
+        "paddle_api": "paddle.distribution.AbsTransform"
+    },
+    "torch.distributions.AffineTransform": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "loc",
+            "scale",
+            "event_dim",
+            "cache_size"
+        ],
+        "kwargs_change": {
+            "cache_size": "",
+            "event_dim": ""
+        },
+        "min_input_args": 2,
+        "paddle_api": "paddle.distribution.AffineTransform"
+    },
     "torch.distributions.Bernoulli": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "probs",
             "logits",
             "validate_args"
         ],
         "kwargs_change": {
             "validate_args": ""
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.distribution.Bernoulli",
         "unsupport_args": [
             "logits"
         ]
     },
     "torch.distributions.Beta": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "concentration1",
             "concentration0",
             "validate_args"
         ],
         "kwargs_change": {
             "concentration0": "beta",
-            "concentration1": "alpha"
+            "concentration1": "alpha",
+            "validate_args": ""
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.distribution.Beta"
     },
     "torch.distributions.Categorical": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "probs",
             "logits",
             "validate_args"
         ],
         "kwargs_change": {
             "validate_args": ""
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.distribution.Categorical",
         "unsupport_args": [
             "probs"
         ]
     },
     "torch.distributions.Cauchy": {
         "Matcher": "GenericMatcher",
@@ -4907,109 +5872,140 @@
             "loc",
             "scale",
             "validate_args"
         ],
         "kwargs_change": {
             "validate_args": ""
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.distribution.Cauchy"
     },
     "torch.distributions.ComposeTransform": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "parts",
             "cache_size"
         ],
         "kwargs_change": {
             "cache_size": "",
             "parts": "transforms"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.distribution.ChainTransform"
     },
     "torch.distributions.Dirichlet": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "concentration",
             "validate_args"
         ],
         "kwargs_change": {
             "validate_args": ""
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.distribution.Dirichlet"
     },
     "torch.distributions.Distribution": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "batch_shape",
             "event_shape",
             "validate_args"
         ],
         "kwargs_change": {
             "validate_args": ""
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.distribution.Distribution"
     },
-    "torch.distributions.Distribution.cdf": {},
+    "torch.distributions.Distribution.cdf": {
+        "min_input_args": 1
+    },
     "torch.distributions.Distribution.concentration0": {},
     "torch.distributions.Distribution.concentration1": {},
-    "torch.distributions.Distribution.entropy": {},
-    "torch.distributions.Distribution.enumerate_support": {},
-    "torch.distributions.Distribution.expand": {},
-    "torch.distributions.Distribution.icdf": {},
+    "torch.distributions.Distribution.entropy": {
+        "min_input_args": 0
+    },
+    "torch.distributions.Distribution.enumerate_support": {
+        "min_input_args": 0
+    },
+    "torch.distributions.Distribution.expand": {
+        "min_input_args": 1
+    },
+    "torch.distributions.Distribution.icdf": {
+        "min_input_args": 1
+    },
     "torch.distributions.Distribution.log_prob": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "min_input_args": 1
     },
     "torch.distributions.Distribution.logits": {},
     "torch.distributions.Distribution.param_shape": {},
-    "torch.distributions.Distribution.perplexity": {},
+    "torch.distributions.Distribution.perplexity": {
+        "min_input_args": 0
+    },
     "torch.distributions.Distribution.probs": {},
     "torch.distributions.Distribution.rsample": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "sample_shape"
         ],
         "kwargs_change": {
             "sample_shape": "shape"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.distribution.Distribution.rsample"
     },
     "torch.distributions.Distribution.sample": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "sample_shape"
         ],
         "kwargs_change": {
             "sample_shape": "shape"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.distribution.Distribution.sample"
     },
-    "torch.distributions.Distribution.sample_n": {},
-    "torch.distributions.Distribution.set_default_validate_args": {},
+    "torch.distributions.Distribution.sample_n": {
+        "min_input_args": 1
+    },
+    "torch.distributions.Distribution.set_default_validate_args": {
+        "min_input_args": 1
+    },
+    "torch.distributions.ExpTransform": {
+        "Matcher": "GenericMatcher",
+        "args_list": [],
+        "min_input_args": 0,
+        "paddle_api": "paddle.distribution.ExpTransform"
+    },
     "torch.distributions.ExponentialFamily": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "batch_shape",
             "event_shape",
             "validate_args"
         ],
         "kwargs_change": {
             "validate_args": ""
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.distribution.ExponentialFamily"
     },
     "torch.distributions.Geometric": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "probs",
             "logits",
             "validate_args"
         ],
         "kwargs_change": {
             "validate_args": ""
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.distribution.Geometric",
         "unsupport_args": [
             "logits"
         ]
     },
     "torch.distributions.Gumbel": {
         "Matcher": "GenericMatcher",
@@ -5017,65 +6013,83 @@
             "loc",
             "scale",
             "validate_args"
         ],
         "kwargs_change": {
             "validate_args": ""
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.distribution.Gumbel"
     },
     "torch.distributions.Independent": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "base_distribution",
             "reinterpreted_batch_ndims",
             "validate_args"
         ],
         "kwargs_change": {
             "base_distribution": "base",
             "reinterpreted_batch_ndims": "reinterpreted_batch_rank",
             "validate_args": ""
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.distribution.Independent"
     },
+    "torch.distributions.IndependentTransform": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "base_transform",
+            "reinterpreted_batch_ndims"
+        ],
+        "kwargs_change": {
+            "base_transform": "base",
+            "reinterpreted_batch_ndims": "reinterpreted_batch_rank"
+        },
+        "min_input_args": 2,
+        "paddle_api": "paddle.distribution.IndependentTransform"
+    },
     "torch.distributions.Laplace": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "loc",
             "scale",
             "validate_args"
         ],
         "kwargs_change": {
             "validate_args": ""
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.distribution.Laplace"
     },
     "torch.distributions.LogNormal": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "loc",
             "scale",
             "validate_args"
         ],
         "kwargs_change": {
             "validate_args": ""
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.distribution.LogNormal"
     },
     "torch.distributions.Multinomial": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "total_count",
             "probs",
             "logits",
             "validate_args"
         ],
         "kwargs_change": {
             "validate_args": ""
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.distribution.Multinomial",
         "unsupport_args": [
             "logits"
         ]
     },
     "torch.distributions.Normal": {
         "Matcher": "GenericMatcher",
@@ -5083,173 +6097,230 @@
             "loc",
             "scale",
             "validate_args"
         ],
         "kwargs_change": {
             "validate_args": ""
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.distribution.Normal"
     },
+    "torch.distributions.PowerTransform": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "exponent",
+            "cache_size"
+        ],
+        "kwargs_change": {
+            "cache_size": "",
+            "exponent": "power"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.distribution.PowerTransform"
+    },
+    "torch.distributions.ReshapeTransform": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "in_shape",
+            "out_shape"
+        ],
+        "kwargs_change": {
+            "in_shape": "in_event_shape",
+            "out_shape": "out_event_shape"
+        },
+        "min_input_args": 2,
+        "paddle_api": "paddle.distribution.ReshapeTransform"
+    },
     "torch.distributions.SigmoidTransform": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "cache_size"
         ],
         "kwargs_change": {
             "cache_size": ""
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.distribution.SigmoidTransform"
     },
     "torch.distributions.SoftmaxTransform": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "cache_size"
         ],
         "kwargs_change": {
             "cache_size": ""
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.distribution.SoftmaxTransform"
     },
     "torch.distributions.StackTransform": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "tseq",
             "dim",
             "cache_size"
         ],
         "kwargs_change": {
             "cache_size": "",
             "dim": "axis",
             "tseq": "transforms"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.distribution.StackTransform"
     },
     "torch.distributions.StickBreakingTransform": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "cache_size"
         ],
         "kwargs_change": {
             "cache_size": ""
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.distribution.StickBreakingTransform"
     },
+    "torch.distributions.TanhTransform": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "cache_size"
+        ],
+        "kwargs_change": {
+            "cache_size": ""
+        },
+        "min_input_args": 0,
+        "paddle_api": "paddle.distribution.TanhTransform"
+    },
     "torch.distributions.Transform": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "cache_size"
         ],
         "kwargs_change": {
             "cache_size": ""
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.distribution.Transform"
     },
     "torch.distributions.TransformedDistribution": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "base_distribution",
             "transforms",
             "validate_args"
         ],
         "kwargs_change": {
             "base_distribution": "base",
             "validate_args": ""
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.distribution.TransformedDistribution"
     },
     "torch.distributions.Uniform": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "low",
             "high",
             "validate_args"
         ],
         "kwargs_change": {
             "validate_args": ""
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.distribution.Uniform"
     },
     "torch.distributions.kl.kl_divergence": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "p",
             "q"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.distribution.kl_divergence"
     },
     "torch.distributions.kl.register_kl": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "type_p",
             "type_q"
         ],
         "kwargs_change": {
             "type_p": "cls_p",
             "type_q": "cls_q"
         },
-        "paddle_api": "paddle.distribution.kl.register_kl"
+        "min_input_args": 2,
+        "paddle_api": "paddle.distribution.register_kl"
     },
     "torch.divide": {
         "Matcher": "DivideMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "rounding_mode",
             "out"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.divide"
     },
     "torch.dot": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "tensor",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "tensor": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.dot"
     },
-    "torch.double": {
-        "Matcher": "GenericMatcher",
-        "paddle_api": "'float64'"
-    },
     "torch.dropout": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "p",
             "train"
         ],
         "kwargs_change": {
             "input": "x",
             "train": "training"
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.nn.functional.dropout"
     },
-    "torch.dtype": {
-        "Matcher": "GenericMatcher",
-        "paddle_api": "paddle.dtype"
+    "torch.eig": {
+        "min_input_args": 0
     },
-    "torch.eig": {},
     "torch.einsum": {
         "Matcher": "UnchangeMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.einsum"
     },
     "torch.embedding": {},
     "torch.embedding_bag": {},
     "torch.empty": {
         "Matcher": "CreateMatcher",
+        "args_list": [
+            "*size",
+            "*",
+            "out",
+            "dtype",
+            "layout",
+            "device",
+            "requires_grad",
+            "pin_memory",
+            "memory_format"
+        ],
         "kwargs_change": {
             "dtype": "dtype"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.empty"
     },
     "torch.empty_like": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
@@ -5259,56 +6330,61 @@
             "requires_grad",
             "memory_format"
         ],
         "kwargs_change": {
             "dtype": "dtype",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.empty_like"
     },
     "torch.enable_grad": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.enable_grad"
     },
     "torch.eq": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.equal"
     },
     "torch.equal": {
         "Matcher": "EqualMatcher",
         "args_list": [
             "input",
             "other"
         ],
         "kwargs_change": {
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.equal_all"
     },
     "torch.exp": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.exp"
     },
     "torch.eye": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "n",
             "m",
@@ -5320,14 +6396,15 @@
             "requires_grad"
         ],
         "kwargs_change": {
             "dtype": "dtype",
             "m": "num_columns",
             "n": "num_rows"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.eye"
     },
     "torch.feature_alpha_dropout": {},
     "torch.fft.fft": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
@@ -5337,14 +6414,15 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.fft.fft"
     },
     "torch.fft.fft2": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "s",
@@ -5353,14 +6431,15 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axes",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.fft.fft2"
     },
     "torch.fft.fftfreq": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "n",
             "d",
@@ -5370,14 +6449,15 @@
             "layout",
             "device",
             "requires_grad"
         ],
         "kwargs_change": {
             "dtype": "dtype"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.fft.fftfreq"
     },
     "torch.fft.fftn": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "s",
@@ -5386,26 +6466,28 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axes",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.fft.fftn"
     },
     "torch.fft.fftshift": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dim"
         ],
         "kwargs_change": {
             "dim": "axes",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.fft.fftshift"
     },
     "torch.fft.hfft": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "n",
@@ -5414,14 +6496,15 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.fft.hfft"
     },
     "torch.fft.hfft2": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "s",
@@ -5430,14 +6513,15 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axes",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.fft.hfft2"
     },
     "torch.fft.hfftn": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "s",
@@ -5446,14 +6530,15 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axes",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.fft.hfftn"
     },
     "torch.fft.ifft": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "n",
@@ -5462,14 +6547,15 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.fft.ifft"
     },
     "torch.fft.ifft2": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "s",
@@ -5478,14 +6564,15 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axes",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.fft.ifft2"
     },
     "torch.fft.ifftn": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "s",
@@ -5494,26 +6581,28 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axes",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.fft.ifftn"
     },
     "torch.fft.ifftshift": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dim"
         ],
         "kwargs_change": {
             "dim": "axes",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.fft.ifftshift"
     },
     "torch.fft.ihfft": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "n",
@@ -5522,14 +6611,15 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.fft.ihfft"
     },
     "torch.fft.ihfft2": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "s",
@@ -5538,14 +6628,15 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axes",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.fft.ihfft2"
     },
     "torch.fft.ihfftn": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "s",
@@ -5554,14 +6645,15 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axes",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.fft.ihfftn"
     },
     "torch.fft.irfft": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "n",
@@ -5570,14 +6662,15 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.fft.irfft"
     },
     "torch.fft.irfft2": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "s",
@@ -5586,14 +6679,15 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axes",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.fft.irfft2"
     },
     "torch.fft.irfftn": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "s",
@@ -5602,14 +6696,15 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axes",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.fft.irfftn"
     },
     "torch.fft.rfft": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "n",
@@ -5618,14 +6713,15 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.fft.rfft"
     },
     "torch.fft.rfft2": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "s",
@@ -5634,14 +6730,15 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axes",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.fft.rfft2"
     },
     "torch.fft.rfftfreq": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "n",
             "d",
@@ -5651,14 +6748,15 @@
             "layout",
             "device",
             "requires_grad"
         ],
         "kwargs_change": {
             "dtype": "dtype"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.fft.rfftfreq"
     },
     "torch.fft.rfftn": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "s",
@@ -5667,161 +6765,171 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axes",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.fft.rfftn"
     },
+    "torch.finfo": {
+        "Matcher": "IInfoMatcher",
+        "args_list": [
+            "type"
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.finfo"
+    },
     "torch.fix": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.trunc"
     },
     "torch.flatten": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "start_dim",
             "end_dim"
         ],
         "kwargs_change": {
             "end_dim": "stop_axis",
             "input": "x",
             "start_dim": "start_axis"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.flatten"
     },
     "torch.flip": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dims"
         ],
         "kwargs_change": {
             "dims": "axis",
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.flip"
     },
     "torch.fliplr": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.flip",
         "paddle_default_kwargs": {
             "axis": 1
         }
     },
     "torch.flipud": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.flip",
         "paddle_default_kwargs": {
             "axis": 0
         }
     },
-    "torch.float": {
-        "Matcher": "GenericMatcher",
-        "paddle_api": "'float32'"
-    },
-    "torch.float16": {
-        "Matcher": "GenericMatcher",
-        "paddle_api": "'float16'"
-    },
-    "torch.float32": {
-        "Matcher": "GenericMatcher",
-        "paddle_api": "'float32'"
-    },
-    "torch.float64": {
-        "Matcher": "GenericMatcher",
-        "paddle_api": "'float64'"
-    },
     "torch.floor": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.floor"
     },
     "torch.floor_divide": {
         "Matcher": "Num2TensorBinaryMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.floor_divide"
     },
     "torch.fmax": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.fmax"
     },
     "torch.fmin": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.fmin"
     },
     "torch.fmod": {
-        "Matcher": "FModMatcher",
+        "Matcher": "Num2TensorBinaryConvertTypeMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
-        ]
+        ],
+        "kwargs_change": {
+            "input": "x",
+            "other": "y"
+        },
+        "min_input_args": 2,
+        "paddle_api": "paddle.mod"
     },
     "torch.frac": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
+            "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.frac"
     },
     "torch.frexp": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
@@ -5836,24 +6944,26 @@
         "Matcher": "GenericMatcher",
         "args_list": [
             "ext_tensor"
         ],
         "kwargs_change": {
             "ext_tensor": "dlpack"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.utils.dlpack.from_dlpack"
     },
     "torch.from_numpy": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "ndarray"
         ],
         "kwargs_change": {
             "ndarray": "data"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.to_tensor"
     },
     "torch.full": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "size",
             "fill_value",
@@ -5864,14 +6974,15 @@
             "device",
             "requires_grad"
         ],
         "kwargs_change": {
             "dtype": "dtype",
             "size": "shape"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.full"
     },
     "torch.full_like": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "fill_value",
@@ -5882,14 +6993,15 @@
             "requires_grad",
             "memory_format"
         ],
         "kwargs_change": {
             "dtype": "dtype",
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.full_like"
     },
     "torch.gather": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dim",
@@ -5900,144 +7012,174 @@
         ],
         "kwargs_change": {
             "dim": "axis",
             "index": "indices",
             "input": "arr",
             "sparse_grad": ""
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.take_along_axis"
     },
     "torch.gcd": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.gcd"
     },
     "torch.ge": {
         "Matcher": "Num2TensorBinaryMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.greater_equal"
     },
     "torch.ger": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "vec2",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "vec2": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.outer"
     },
     "torch.get_default_dtype": {
         "Matcher": "GenericMatcher",
         "paddle_api": "paddle.get_default_dtype"
     },
     "torch.get_rng_state": {
         "Matcher": "GenericMatcher",
-        "paddle_api": "paddle.get_cuda_rng_state"
+        "min_input_args": 0,
+        "paddle_api": "paddle.get_rng_state"
     },
     "torch.greater": {
         "Matcher": "Num2TensorBinaryMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.greater_than"
     },
     "torch.greater_equal": {
         "Matcher": "Num2TensorBinaryMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.greater_equal"
     },
     "torch.gt": {
         "Matcher": "Num2TensorBinaryMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.greater_than"
     },
-    "torch.half": {
-        "Matcher": "GenericMatcher",
-        "paddle_api": "'float16'"
-    },
     "torch.heaviside": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "values",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "values": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.heaviside"
     },
     "torch.hinge_embedding_loss": {},
     "torch.histc": {
         "Matcher": "HistcMatcher",
         "args_list": [
             "input",
             "bins",
             "min",
             "max",
             "*",
             "out"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.histogram"
     },
+    "torch.histogramdd": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "input",
+            "bins",
+            "*",
+            "range",
+            "weight",
+            "density"
+        ],
+        "kwargs_change": {
+            "input": "x",
+            "range": "ranges",
+            "weight": "weights"
+        },
+        "min_input_args": 2,
+        "paddle_api": "paddle.histogramdd"
+    },
     "torch.hstack": {
-        "Matcher": "HStackMatcher",
+        "Matcher": "GenericMatcher",
         "args_list": [
             "tensors",
             "*",
             "out"
-        ]
+        ],
+        "kwargs_change": {
+            "tensors": "x"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.hstack"
     },
     "torch.hub.download_url_to_file": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "url",
             "dst",
             "hash_prefix",
             "progress"
         ],
         "kwargs_change": {
             "dst": "",
             "hash_prefix": "",
             "progress": ""
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.utils.download.get_weights_path_from_url"
     },
     "torch.hub.help": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "github",
             "model",
@@ -6046,14 +7188,15 @@
             "trust_repo"
         ],
         "kwargs_change": {
             "github": "repo_dir",
             "skip_validation": "",
             "trust_repo": ""
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.hub.help"
     },
     "torch.hub.list": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "github",
             "force_reload",
@@ -6061,169 +7204,216 @@
             "trust_repo"
         ],
         "kwargs_change": {
             "github": "repo_dir",
             "skip_validation": "",
             "trust_repo": ""
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.hub.list"
     },
     "torch.hub.load": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "repo_or_dir",
             "model",
+            "*args",
             "source",
             "trust_repo",
             "force_reload",
             "verbose",
-            "skip_validation"
+            "skip_validation",
+            "**kwargs"
         ],
         "kwargs_change": {
             "repo_or_dir": "repo_dir",
             "skip_validation": "",
             "trust_repo": "",
             "verbose": ""
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.hub.load"
     },
     "torch.hypot": {
-        "Matcher": "HypotMatcher",
+        "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
-        ]
+        ],
+        "kwargs_change": {
+            "input": "x",
+            "other": "y"
+        },
+        "min_input_args": 2,
+        "paddle_api": "paddle.hypot"
+    },
+    "torch.iinfo": {
+        "Matcher": "IInfoMatcher",
+        "args_list": [
+            "type"
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.iinfo"
     },
     "torch.imag": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.imag"
     },
     "torch.index_add": {
         "Matcher": "IndexAddMatcher",
         "args_list": [
             "input",
             "dim",
             "index",
             "source",
             "*",
             "alpha",
             "out"
         ],
+        "kwargs_change": {
+            "dim": "axis",
+            "input": "x"
+        },
+        "min_input_args": 4,
         "paddle_api": "paddle.index_add"
     },
     "torch.index_copy": {
         "Matcher": "IndexCopyMatcher",
         "args_list": [
             "input",
             "dim",
             "index",
             "source",
             "*",
             "out"
-        ]
+        ],
+        "min_input_args": 4
+    },
+    "torch.index_fill": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "input",
+            "dim",
+            "index",
+            "value"
+        ],
+        "kwargs_change": {
+            "dim": "axis",
+            "input": "x"
+        },
+        "min_input_args": 4,
+        "paddle_api": "paddle.index_fill"
     },
     "torch.index_select": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dim",
             "index",
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.index_select"
     },
+    "torch.inference_mode": {
+        "Matcher": "InferenceModeMatcher",
+        "args_list": [
+            "mode"
+        ]
+    },
     "torch.initial_seed": {
-        "Matcher": "SeedMatcher"
+        "Matcher": "SeedMatcher",
+        "min_input_args": 0
     },
     "torch.inner": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.inner"
     },
     "torch.instance_norm": {},
-    "torch.int": {
-        "Matcher": "GenericMatcher",
-        "paddle_api": "'int32'"
-    },
-    "torch.int16": {
-        "Matcher": "GenericMatcher",
-        "paddle_api": "'int16'"
-    },
-    "torch.int32": {
-        "Matcher": "GenericMatcher",
-        "paddle_api": "'int32'"
-    },
-    "torch.int64": {
-        "Matcher": "GenericMatcher",
-        "paddle_api": "'int64'"
-    },
-    "torch.int8": {
+    "torch.inverse": {
         "Matcher": "GenericMatcher",
-        "paddle_api": "'int8'"
+        "args_list": [
+            "input",
+            "*",
+            "out"
+        ],
+        "kwargs_change": {
+            "input": "x"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.linalg.inv"
     },
     "torch.is_complex": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.is_complex"
     },
     "torch.is_floating_point": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.is_floating_point"
     },
     "torch.is_grad_enabled": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.is_grad_enabled"
     },
     "torch.is_nonzero": {
         "Matcher": "IsNonzeroMatcher",
         "args_list": [
             "input"
-        ]
+        ],
+        "min_input_args": 1
     },
     "torch.is_tensor": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "obj"
         ],
         "kwargs_change": {
             "obj": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.is_tensor"
     },
     "torch.isclose": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "other",
@@ -6231,44 +7421,48 @@
             "atol",
             "equal_nan"
         ],
         "kwargs_change": {
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.isclose"
     },
     "torch.isfinite": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.isfinite"
     },
     "torch.isinf": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.isinf"
     },
     "torch.isnan": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.isnan"
     },
     "torch.istft": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "n_fft",
@@ -6280,14 +7474,15 @@
             "onesided",
             "length",
             "return_complex"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.signal.istft"
     },
     "torch.kl_div": {},
     "torch.kron": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
@@ -6295,14 +7490,15 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.kron"
     },
     "torch.kthvalue": {
         "Matcher": "DoubleAssignMatcher",
         "args_list": [
             "input",
             "k",
@@ -6311,47 +7507,51 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.kthvalue"
     },
     "torch.lcm": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.lcm"
     },
     "torch.ldexp": {
         "Matcher": "LdExpMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
-        ]
+        ],
+        "min_input_args": 2
     },
     "torch.le": {
         "Matcher": "Num2TensorBinaryMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.less_equal"
     },
     "torch.lerp": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "end",
@@ -6359,73 +7559,79 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "end": "y",
             "input": "x"
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.lerp"
     },
     "torch.less": {
         "Matcher": "Num2TensorBinaryMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.less_than"
     },
     "torch.less_equal": {
         "Matcher": "Num2TensorBinaryMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.less_equal"
     },
     "torch.lgamma": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.lgamma"
     },
     "torch.linalg.cholesky": {
         "Matcher": "GenericMatcher",
         "args_list": [
-            "A",
+            "input",
             "*",
             "upper",
             "out"
         ],
         "kwargs_change": {
-            "A": "x"
+            "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.linalg.cholesky"
     },
     "torch.linalg.cholesky_ex": {},
     "torch.linalg.cond": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "p",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.linalg.cond"
     },
     "torch.linalg.cross": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "other",
@@ -6434,14 +7640,15 @@
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.cross",
         "paddle_default_kwargs": {
             "axis": -1
         }
     },
     "torch.linalg.det": {
         "Matcher": "GenericMatcher",
@@ -6449,14 +7656,15 @@
             "A",
             "*",
             "out"
         ],
         "kwargs_change": {
             "A": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.linalg.det"
     },
     "torch.linalg.diagonal": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "A",
             "*",
@@ -6465,101 +7673,148 @@
             "dim2"
         ],
         "kwargs_change": {
             "A": "x",
             "dim1": "axis1",
             "dim2": "axis2"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.diagonal",
         "paddle_default_kwargs": {
             "axis1": -2,
             "axis2": -1
         }
     },
     "torch.linalg.eig": {
-        "Matcher": "GenericMatcher",
+        "Matcher": "DoubleAssignMatcher",
         "args_list": [
-            "A",
+            "input",
             "*",
             "out"
         ],
         "kwargs_change": {
-            "A": "x"
+            "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.linalg.eig"
     },
-    "torch.linalg.eigh": {},
+    "torch.linalg.eigh": {
+        "Matcher": "DoubleAssignMatcher",
+        "args_list": [
+            "input",
+            "UPLO",
+            "*",
+            "out"
+        ],
+        "kwargs_change": {
+            "input": "x"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.linalg.eigh"
+    },
     "torch.linalg.eigvals": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.linalg.eigvals"
     },
-    "torch.linalg.eigvalsh": {},
-    "torch.linalg.householder_product": {},
+    "torch.linalg.eigvalsh": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "input",
+            "UPLO",
+            "*",
+            "out"
+        ],
+        "kwargs_change": {
+            "input": "x"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.linalg.eigvalsh"
+    },
+    "torch.linalg.householder_product": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "input",
+            "tau",
+            "*",
+            "out"
+        ],
+        "kwargs_change": {
+            "input": "x"
+        },
+        "min_input_args": 2,
+        "paddle_api": "paddle.linalg.householder_product"
+    },
     "torch.linalg.inv": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "A",
             "*",
             "out"
         ],
         "kwargs_change": {
             "A": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.linalg.inv"
     },
     "torch.linalg.inv_ex": {},
     "torch.linalg.ldl_factor": {},
     "torch.linalg.ldl_factor_ex": {},
     "torch.linalg.ldl_solve": {},
     "torch.linalg.lstsq": {
         "Matcher": "GenericMatcher",
         "args_list": [
-            "A",
-            "B",
+            "input",
+            "b",
             "rcond",
             "*",
             "driver"
         ],
         "kwargs_change": {
-            "A": "x",
-            "B": "y"
+            "b": "y",
+            "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.linalg.lstsq"
     },
     "torch.linalg.lu": {
         "Matcher": "LinalgLuMatcher",
         "args_list": [
             "A",
             "*",
             "pivot",
             "out"
         ],
         "kwargs_change": {
             "A": "x"
-        }
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.linalg.lu"
     },
     "torch.linalg.lu_factor": {
         "Matcher": "DoubleAssignMatcher",
         "args_list": [
             "A",
             "*",
             "pivot",
             "out"
         ],
         "kwargs_change": {
             "A": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.linalg.lu"
     },
     "torch.linalg.lu_factor_ex": {
         "Matcher": "TripleAssignMatcher",
         "args_list": [
             "A",
             "*",
@@ -6567,14 +7822,15 @@
             "check_errors",
             "out"
         ],
         "kwargs_change": {
             "A": "x",
             "check_errors": ""
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.linalg.lu",
         "paddle_default_kwargs": {
             "get_infos": "True"
         }
     },
     "torch.linalg.lu_solve": {},
     "torch.linalg.matmul": {
@@ -6585,29 +7841,49 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.matmul"
     },
     "torch.linalg.matrix_exp": {},
-    "torch.linalg.matrix_norm": {},
+    "torch.linalg.matrix_norm": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "input",
+            "ord",
+            "dim",
+            "keepdim",
+            "*",
+            "dtype",
+            "out"
+        ],
+        "kwargs_change": {
+            "dim": "axis",
+            "input": "x",
+            "ord": "p"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.linalg.matrix_norm"
+    },
     "torch.linalg.matrix_power": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "n",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.linalg.matrix_power"
     },
     "torch.linalg.matrix_rank": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "A",
             "tol",
@@ -6619,26 +7895,28 @@
             "out"
         ],
         "kwargs_change": {
             "A": "x",
             "atol": "tol",
             "rtol": ""
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.linalg.matrix_rank"
     },
     "torch.linalg.multi_dot": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "tensors",
             "*",
             "out"
         ],
         "kwargs_change": {
             "tensors": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.linalg.multi_dot"
     },
     "torch.linalg.norm": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "ord",
@@ -6649,40 +7927,78 @@
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x",
             "ord": "p"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.linalg.norm"
     },
-    "torch.linalg.pinv": {},
+    "torch.linalg.pinv": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "input",
+            "*",
+            "atol",
+            "rtol",
+            "hermitian",
+            "out"
+        ],
+        "kwargs_change": {
+            "atol": "",
+            "input": "x",
+            "rtol": "rcond"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.linalg.pinv"
+    },
     "torch.linalg.qr": {
         "Matcher": "DoubleAssignMatcher",
         "args_list": [
             "A",
             "mode",
             "*",
             "out"
         ],
         "kwargs_change": {
             "A": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.linalg.qr"
     },
     "torch.linalg.slogdet": {
         "Matcher": "SLogDetMatcher",
         "args_list": [
             "A",
             "*",
             "out"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.linalg.slogdet"
     },
-    "torch.linalg.solve": {},
+    "torch.linalg.solve": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "A",
+            "B",
+            "*",
+            "left",
+            "out"
+        ],
+        "kwargs_change": {
+            "A": "x",
+            "B": "y"
+        },
+        "min_input_args": 2,
+        "paddle_api": "paddle.linalg.solve",
+        "unsupport_args": [
+            "left"
+        ]
+    },
     "torch.linalg.solve_ex": {},
     "torch.linalg.solve_triangular": {
         "Matcher": "LinalgSolveTriangularMatcher",
         "args_list": [
             "input",
             "B",
             "*",
@@ -6692,49 +8008,88 @@
             "out"
         ],
         "kwargs_change": {
             "B": "y",
             "input": "x",
             "left": "transpose"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.linalg.triangular_solve"
     },
-    "torch.linalg.svd": {},
+    "torch.linalg.svd": {
+        "Matcher": "TripleAssignMatcher",
+        "args_list": [
+            "A",
+            "full_matrices",
+            "*",
+            "driver",
+            "out"
+        ],
+        "kwargs_change": {
+            "A": "x",
+            "driver": ""
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.linalg.svd",
+        "paddle_default_kwargs": {
+            "full_matrices": "True"
+        }
+    },
     "torch.linalg.svdvals": {
         "Matcher": "LinalgSvdvalsMatcher",
         "args_list": [
             "A",
             "*",
             "driver",
             "out"
         ],
         "kwargs_change": {
             "A": "x",
             "driver": ""
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.linalg.svd"
     },
     "torch.linalg.tensorinv": {},
     "torch.linalg.tensorsolve": {},
     "torch.linalg.vander": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "x",
+            "*",
             "N"
         ],
         "kwargs_change": {
             "N": "n"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.vander",
         "paddle_default_kwargs": {
             "increasing": "True"
         }
     },
     "torch.linalg.vecdot": {},
-    "torch.linalg.vector_norm": {},
+    "torch.linalg.vector_norm": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "x",
+            "ord",
+            "dim",
+            "keepdim",
+            "*",
+            "dtype",
+            "out"
+        ],
+        "kwargs_change": {
+            "dim": "axis",
+            "ord": "p"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.linalg.vector_norm"
+    },
     "torch.linspace": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "start",
             "end",
             "steps",
             "*",
@@ -6745,172 +8100,191 @@
             "requires_grad"
         ],
         "kwargs_change": {
             "dtype": "dtype",
             "end": "stop",
             "steps": "num"
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.linspace"
     },
     "torch.load": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "f",
             "map_location",
             "pickle_module",
             "*",
-            "weights_only"
+            "weights_only",
+            "mmap",
+            "**pickle_load_args"
         ],
         "kwargs_change": {
             "f": "path",
             "map_location": "",
             "pickle_module": "",
             "weights_only": ""
         },
-        "paddle_api": "paddle.load"
+        "min_input_args": 1,
+        "paddle_api": "paddle.load",
+        "unsupport_args": [
+            "mmap"
+        ]
     },
     "torch.log": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.log"
     },
     "torch.log10": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.log10"
     },
     "torch.log1p": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.log1p"
     },
     "torch.log2": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.log2"
     },
     "torch.log_softmax": {},
     "torch.logaddexp": {
         "Matcher": "LogAddExpMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
-        ]
+        ],
+        "min_input_args": 2
     },
     "torch.logaddexp2": {
         "Matcher": "LogAddExp2Matcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
-        ]
+        ],
+        "min_input_args": 2
     },
     "torch.logcumsumexp": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dim",
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.logcumsumexp"
     },
     "torch.logdet": {
         "Matcher": "LogDetMatcher",
         "args_list": [
             "input"
-        ]
+        ],
+        "min_input_args": 1
     },
     "torch.logical_and": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.logical_and"
     },
     "torch.logical_not": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.logical_not"
     },
     "torch.logical_or": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.logical_or"
     },
     "torch.logical_xor": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.logical_xor"
     },
     "torch.logspace": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "start",
             "end",
@@ -6924,42 +8298,43 @@
             "requires_grad"
         ],
         "kwargs_change": {
             "dtype": "dtype",
             "end": "stop",
             "steps": "num"
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.logspace"
     },
-    "torch.long": {
-        "Matcher": "GenericMatcher",
-        "paddle_api": "'int64'"
+    "torch.lstsq": {
+        "min_input_args": 2
     },
-    "torch.lstsq": {},
     "torch.lt": {
         "Matcher": "Num2TensorBinaryMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.less_than"
     },
     "torch.lu": {
         "Matcher": "LuMatcher",
         "args_list": [
             "A",
             "pivot",
             "get_infos",
             "out"
         ],
         "kwargs_change": {
             "A": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.linalg.lu"
     },
     "torch.lu_solve": {},
     "torch.lu_unpack": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "LU_data",
@@ -6970,38 +8345,56 @@
             "out"
         ],
         "kwargs_change": {
             "LU_data": "x",
             "LU_pivots": "y",
             "unpack_data": "unpack_ludata"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.linalg.lu_unpack"
     },
     "torch.manual_seed": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "seed"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.seed"
     },
     "torch.margin_ranking_loss": {},
+    "torch.masked_fill": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "input",
+            "mask",
+            "value"
+        ],
+        "kwargs_change": {
+            "input": "x"
+        },
+        "min_input_args": 3,
+        "paddle_api": "paddle.masked_fill"
+    },
     "torch.masked_select": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "mask",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.masked_select"
     },
-    "torch.matrix_rank": {},
+    "torch.matrix_rank": {
+        "min_input_args": 1
+    },
     "torch.max": {
         "Matcher": "MaxMinMatcher",
         "args_list": [
             "input",
             "dim",
             "keepdim",
             "*",
@@ -7022,14 +8415,15 @@
             "padding",
             "dilation",
             "ceil_mode"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.max_pool1d",
         "unsupport_args": [
             "dilation"
         ]
     },
     "torch.max_pool2d": {
         "Matcher": "GenericMatcher",
@@ -7075,14 +8469,15 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.maximum"
     },
     "torch.mean": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dim",
@@ -7091,36 +8486,42 @@
             "dtype",
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.mean"
     },
     "torch.median": {
-        "Matcher": "GenericMatcher",
+        "Matcher": "DoubleAssignMatcher",
         "args_list": [
             "input",
             "dim",
             "keepdim",
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
         "paddle_api": "paddle.median",
-        "unsupport_args": [
-            "dim"
-        ]
+        "paddle_default_kwargs": {
+            "mode": "'min'"
+        }
     },
     "torch.meshgrid": {
         "Matcher": "MeshgridMatcher",
+        "args_list": [
+            "*tensors",
+            "indexing"
+        ],
+        "min_input_args": 2,
         "paddle_api": "paddle.meshgrid"
     },
     "torch.min": {
         "Matcher": "MaxMinMatcher",
         "args_list": [
             "input",
             "dim",
@@ -7142,24 +8543,26 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.minimum"
     },
     "torch.mm": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "mat2",
             "*",
             "out"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.mm"
     },
     "torch.mode": {
         "Matcher": "DoubleAssignMatcher",
         "args_list": [
             "input",
             "dim",
@@ -7167,71 +8570,84 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.mode"
     },
     "torch.moveaxis": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "source",
             "destination"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.moveaxis"
     },
     "torch.movedim": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "source",
             "destination"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.moveaxis"
     },
     "torch.msort": {
-        "Matcher": "MSortMatcher",
+        "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
-        ]
+        ],
+        "kwargs_change": {
+            "input": "x"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.sort",
+        "paddle_default_kwargs": {
+            "axis": 0
+        }
     },
     "torch.multinomial": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "num_samples",
             "replacement",
             "*",
             "generator",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.multinomial"
     },
     "torch.multiply": {
         "Matcher": "Num2TensorBinaryMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.multiply"
     },
     "torch.multiprocessing.spawn": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "fn",
             "args",
@@ -7240,14 +8656,15 @@
             "daemon",
             "start_method"
         ],
         "kwargs_change": {
             "fn": "func",
             "start_method": ""
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.distributed.spawn",
         "paddle_default_kwargs": {
             "nprocs": "1"
         }
     },
     "torch.mv": {
         "Matcher": "GenericMatcher",
@@ -7256,14 +8673,15 @@
             "vec",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.mv"
     },
     "torch.nan_to_num": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "nan",
@@ -7271,14 +8689,15 @@
             "neginf",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nan_to_num"
     },
     "torch.nanmean": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dim",
@@ -7287,33 +8706,51 @@
             "dtype",
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nanmean"
     },
     "torch.nanmedian": {
-        "Matcher": "GenericMatcher",
+        "Matcher": "DoubleAssignMatcher",
         "args_list": [
             "input",
             "dim",
             "keepdim",
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
         "paddle_api": "paddle.nanmedian",
-        "unsupport_args": [
-            "dim"
-        ]
+        "paddle_default_kwargs": {
+            "mode": "'min'"
+        }
+    },
+    "torch.nanquantile": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "input",
+            "q",
+            "dim",
+            "keepdim",
+            "*",
+            "interpolation",
+            "out"
+        ],
+        "kwargs_change": {
+            "dim": "axis",
+            "input": "x"
+        },
+        "paddle_api": "paddle.nanquantile"
     },
     "torch.nansum": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dim",
             "keepdim",
@@ -7322,258 +8759,296 @@
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "dtype": "dtype",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nansum"
     },
     "torch.narrow": {
         "Matcher": "NarrowMatcher",
         "args_list": [
             "input",
             "dim",
             "start",
             "length"
-        ]
+        ],
+        "min_input_args": 4,
+        "paddle_api": "paddle.slice"
     },
     "torch.narrow_copy": {
         "Matcher": "NarrowCopyMatcher",
         "args_list": [
             "input",
             "dim",
             "start",
             "length",
             "*",
             "out"
-        ]
+        ],
+        "min_input_args": 4
     },
     "torch.ne": {
         "Matcher": "Num2TensorBinaryMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.not_equal"
     },
     "torch.neg": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.neg"
     },
     "torch.negative": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.neg"
     },
     "torch.nextafter": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nextafter"
     },
     "torch.nn.AdaptiveAvgPool1d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "output_size"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.AdaptiveAvgPool1D"
     },
     "torch.nn.AdaptiveAvgPool2d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "output_size"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.AdaptiveAvgPool2D"
     },
     "torch.nn.AdaptiveAvgPool3d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "output_size"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.AdaptiveAvgPool3D"
     },
     "torch.nn.AdaptiveMaxPool1d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "output_size",
             "return_indices"
         ],
         "kwargs_change": {
             "return_indices": "return_mask"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.AdaptiveMaxPool1D"
     },
     "torch.nn.AdaptiveMaxPool2d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "output_size",
             "return_indices"
         ],
         "kwargs_change": {
             "return_indices": "return_mask"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.AdaptiveMaxPool2D"
     },
     "torch.nn.AdaptiveMaxPool3d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "output_size",
             "return_indices"
         ],
         "kwargs_change": {
             "return_indices": "return_mask"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.AdaptiveMaxPool3D"
     },
     "torch.nn.AlphaDropout": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "p",
             "inplace"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.AlphaDropout"
     },
     "torch.nn.AvgPool1d": {
         "Matcher": "AvgPoolMatcher",
         "args_list": [
             "kernel_size",
             "stride",
             "padding",
             "ceil_mode",
             "count_include_pad"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.AvgPool1D"
     },
     "torch.nn.AvgPool2d": {
         "Matcher": "AvgPoolMatcher",
         "args_list": [
             "kernel_size",
             "stride",
             "padding",
             "ceil_mode",
             "count_include_pad",
             "divisor_override"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.AvgPool2D"
     },
     "torch.nn.AvgPool3d": {
         "Matcher": "AvgPoolMatcher",
         "args_list": [
             "kernel_size",
             "stride",
             "padding",
             "ceil_mode",
             "count_include_pad",
             "divisor_override"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.AvgPool3D"
     },
     "torch.nn.BCELoss": {
         "Matcher": "SizeAverageMatcher",
         "args_list": [
             "weight",
             "size_average",
             "reduce",
             "reduction"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.BCELoss"
     },
     "torch.nn.BCEWithLogitsLoss": {
         "Matcher": "SizeAverageMatcher",
         "args_list": [
             "weight",
             "size_average",
             "reduce",
             "reduction",
             "pos_weight"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.BCEWithLogitsLoss"
     },
     "torch.nn.BatchNorm1d": {
-        "Matcher": "BatchNormMatcher",
+        "Matcher": "ReverseMomentumMatcher",
         "args_list": [
             "num_features",
             "eps",
             "momentum",
             "affine",
             "track_running_stats",
             "device",
             "dtype"
         ],
         "kwargs_change": {
+            "affine": [
+                "weight_attr",
+                "bias_attr"
+            ],
             "device": "",
             "dtype": "",
-            "eps": "epsilon"
+            "eps": "epsilon",
+            "track_running_stats": ""
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.BatchNorm1D"
     },
     "torch.nn.BatchNorm2d": {
-        "Matcher": "BatchNormMatcher",
+        "Matcher": "ReverseMomentumMatcher",
         "args_list": [
             "num_features",
             "eps",
             "momentum",
             "affine",
             "track_running_stats",
             "device",
             "dtype"
         ],
         "kwargs_change": {
+            "affine": [
+                "weight_attr",
+                "bias_attr"
+            ],
             "device": "",
             "dtype": "",
-            "eps": "epsilon"
+            "eps": "epsilon",
+            "track_running_stats": ""
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.BatchNorm2D"
     },
     "torch.nn.BatchNorm3d": {
-        "Matcher": "BatchNormMatcher",
+        "Matcher": "ReverseMomentumMatcher",
         "args_list": [
             "num_features",
             "eps",
             "momentum",
             "affine",
             "track_running_stats",
             "device",
             "dtype"
         ],
         "kwargs_change": {
+            "affine": [
+                "weight_attr",
+                "bias_attr"
+            ],
             "device": "",
             "dtype": "",
-            "eps": "epsilon"
+            "eps": "epsilon",
+            "track_running_stats": ""
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.BatchNorm3D"
     },
     "torch.nn.Bilinear": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "in1_features",
             "in2_features",
@@ -7583,53 +9058,59 @@
             "dtype"
         ],
         "kwargs_change": {
             "bias": "bias_attr",
             "device": "",
             "dtype": ""
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.nn.Bilinear"
     },
     "torch.nn.CELU": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "alpha",
             "inplace"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.CELU"
     },
     "torch.nn.ChannelShuffle": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "groups"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.ChannelShuffle"
     },
     "torch.nn.ConstantPad1d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "padding",
             "value"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.Pad1D"
     },
     "torch.nn.ConstantPad2d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "padding",
             "value"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.Pad2D"
     },
     "torch.nn.ConstantPad3d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "padding",
             "value"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.Pad3D"
     },
     "torch.nn.Conv1d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "in_channels",
             "out_channels",
@@ -7644,14 +9125,15 @@
             "dtype"
         ],
         "kwargs_change": {
             "bias": "bias_attr",
             "device": "",
             "dtype": ""
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.nn.Conv1D"
     },
     "torch.nn.Conv2d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "in_channels",
             "out_channels",
@@ -7666,14 +9148,15 @@
             "dtype"
         ],
         "kwargs_change": {
             "bias": "bias_attr",
             "device": "",
             "dtype": ""
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.nn.Conv2D"
     },
     "torch.nn.Conv3d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "in_channels",
             "out_channels",
@@ -7688,14 +9171,15 @@
             "dtype"
         ],
         "kwargs_change": {
             "bias": "bias_attr",
             "device": "",
             "dtype": ""
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.nn.Conv3D"
     },
     "torch.nn.ConvTranspose1d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "in_channels",
             "out_channels",
@@ -7711,14 +9195,15 @@
             "dtype"
         ],
         "kwargs_change": {
             "bias": "bias_attr",
             "device": "",
             "dtype": ""
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.nn.Conv1DTranspose",
         "unsupport_args": [
             "padding_mode"
         ]
     },
     "torch.nn.ConvTranspose2d": {
         "Matcher": "GenericMatcher",
@@ -7737,14 +9222,15 @@
             "dtype"
         ],
         "kwargs_change": {
             "bias": "bias_attr",
             "device": "",
             "dtype": ""
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.nn.Conv2DTranspose",
         "unsupport_args": [
             "padding_mode"
         ]
     },
     "torch.nn.ConvTranspose3d": {
         "Matcher": "GenericMatcher",
@@ -7763,106 +9249,135 @@
             "dtype"
         ],
         "kwargs_change": {
             "bias": "bias_attr",
             "device": "",
             "dtype": ""
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.nn.Conv3DTranspose",
         "unsupport_args": [
             "padding_mode"
         ]
     },
     "torch.nn.CosineEmbeddingLoss": {
         "Matcher": "SizeAverageMatcher",
         "args_list": [
             "margin",
             "size_average",
             "reduce",
             "reduction"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.CosineEmbeddingLoss"
     },
     "torch.nn.CosineSimilarity": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "dim",
             "eps"
         ],
         "kwargs_change": {
             "dim": "axis"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.CosineSimilarity"
     },
     "torch.nn.CrossEntropyLoss": {
         "Matcher": "SizeAverageMatcher",
         "args_list": [
             "weight",
             "size_average",
             "ignore_index",
             "reduce",
             "reduction",
             "label_smoothing"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.CrossEntropyLoss",
         "unsupport_args": [
             "label_smoothing"
         ]
     },
+    "torch.nn.DataParallel": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "module",
+            "device_ids",
+            "output_device",
+            "dim"
+        ],
+        "kwargs_change": {
+            "device_ids": "",
+            "module": "layers",
+            "output_device": ""
+        },
+        "min_input_args": 0,
+        "paddle_api": "paddle.DataParallel",
+        "unsupport_args": [
+            "dim"
+        ]
+    },
     "torch.nn.Dropout": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "p",
             "inplace"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Dropout"
     },
     "torch.nn.Dropout1d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "p",
             "inplace"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Dropout"
     },
     "torch.nn.Dropout2d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "p",
             "inplace"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Dropout2D"
     },
     "torch.nn.Dropout3d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "p",
             "inplace"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Dropout3D"
     },
     "torch.nn.ELU": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "alpha",
             "inplace"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.ELU"
     },
     "torch.nn.Embedding": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "num_embeddings",
             "embedding_dim",
             "padding_idx",
             "max_norm",
             "norm_type",
             "scale_grad_by_freq",
             "sparse"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.Embedding",
         "unsupport_args": [
             "max_norm",
             "norm_type",
             "scale_grad_by_freq"
         ]
     },
@@ -7872,14 +9387,15 @@
             "start_dim",
             "end_dim"
         ],
         "kwargs_change": {
             "end_dim": "stop_axis",
             "start_dim": "start_axis"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Flatten"
     },
     "torch.nn.Fold": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "output_size",
             "kernel_size",
@@ -7890,44 +9406,48 @@
         "kwargs_change": {
             "dilation": "dilations",
             "kernel_size": "kernel_sizes",
             "output_size": "output_sizes",
             "padding": "paddings",
             "stride": "strides"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.Fold"
     },
     "torch.nn.GELU": {
         "Matcher": "GeluMatcher",
         "args_list": [
             "approximate"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.GELU"
     },
     "torch.nn.GRU": {
         "Matcher": "RNNMatcher",
         "args_list": [
             "input_size",
             "hidden_size",
             "num_layers",
             "bias",
             "batch_first",
             "dropout",
-            "bidirectional"
+            "bidirectional",
+            "device",
+            "dtype"
         ],
         "kwargs_change": {
             "bias": [
                 "bias_ih_attr",
                 "bias_hh_attr"
-            ]
+            ],
+            "device": "",
+            "dtype": ""
         },
-        "paddle_api": "paddle.nn.GRU",
-        "unsupport_args": [
-            "proj_size"
-        ]
+        "min_input_args": 0,
+        "paddle_api": "paddle.nn.GRU"
     },
     "torch.nn.GRUCell": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input_size",
             "hidden_size",
             "bias",
@@ -7938,16 +9458,31 @@
             "bias": [
                 "bias_ih_attr",
                 "bias_hh_attr"
             ],
             "device": "",
             "dtype": ""
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.GRUCell"
     },
+    "torch.nn.GaussianNLLLoss": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "*",
+            "full",
+            "eps",
+            "reduction"
+        ],
+        "kwargs_change": {
+            "eps": "epsilon"
+        },
+        "min_input_args": 0,
+        "paddle_api": "paddle.nn.GaussianNLLLoss"
+    },
     "torch.nn.GroupNorm": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "num_groups",
             "num_channels",
             "eps",
             "affine",
@@ -7959,77 +9494,89 @@
                 "weight_attr",
                 "bias_attr"
             ],
             "device": "",
             "dtype": "",
             "eps": "epsilon"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.GroupNorm"
     },
     "torch.nn.Hardshrink": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "lambd"
         ],
         "kwargs_change": {
             "lambd": "threshold"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.Hardshrink"
     },
     "torch.nn.Hardsigmoid": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "inplace"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Hardsigmoid"
     },
     "torch.nn.Hardswish": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "inplace"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Hardswish"
     },
     "torch.nn.Hardtanh": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "min_val",
             "max_val",
             "inplace"
         ],
         "kwargs_change": {
             "max_val": "max",
             "min_val": "min"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Hardtanh"
     },
     "torch.nn.HingeEmbeddingLoss": {
         "Matcher": "SizeAverageMatcher",
         "args_list": [
             "margin",
             "size_average",
             "reduce",
             "reduction"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.HingeEmbeddingLoss"
     },
     "torch.nn.HuberLoss": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "reduction",
             "delta"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.SmoothL1Loss"
     },
     "torch.nn.Identity": {
         "Matcher": "UnchangeMatcher",
+        "args_list": [
+            "*args",
+            "**kwargs"
+        ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Identity"
     },
     "torch.nn.InstanceNorm1d": {
-        "Matcher": "InstanceNormMatcher",
+        "Matcher": "ReverseMomentumMatcher",
         "args_list": [
             "num_features",
             "eps",
             "momentum",
             "affine",
             "track_running_stats",
             "device",
@@ -8038,20 +9585,22 @@
         "kwargs_change": {
             "affine": [
                 "weight_attr",
                 "bias_attr"
             ],
             "device": "",
             "dtype": "",
-            "eps": "epsilon"
+            "eps": "epsilon",
+            "track_running_stats": ""
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.InstanceNorm1D"
     },
     "torch.nn.InstanceNorm2d": {
-        "Matcher": "InstanceNormMatcher",
+        "Matcher": "ReverseMomentumMatcher",
         "args_list": [
             "num_features",
             "eps",
             "momentum",
             "affine",
             "track_running_stats",
             "device",
@@ -8060,20 +9609,22 @@
         "kwargs_change": {
             "affine": [
                 "weight_attr",
                 "bias_attr"
             ],
             "device": "",
             "dtype": "",
-            "eps": "epsilon"
+            "eps": "epsilon",
+            "track_running_stats": ""
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.InstanceNorm2D"
     },
     "torch.nn.InstanceNorm3d": {
-        "Matcher": "InstanceNormMatcher",
+        "Matcher": "ReverseMomentumMatcher",
         "args_list": [
             "num_features",
             "eps",
             "momentum",
             "affine",
             "track_running_stats",
             "device",
@@ -8082,59 +9633,67 @@
         "kwargs_change": {
             "affine": [
                 "weight_attr",
                 "bias_attr"
             ],
             "device": "",
             "dtype": "",
-            "eps": "epsilon"
+            "eps": "epsilon",
+            "track_running_stats": ""
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.InstanceNorm3D"
     },
     "torch.nn.KLDivLoss": {
         "Matcher": "SizeAverageMatcher",
         "args_list": [
             "size_average",
             "reduce",
             "reduction",
             "log_target"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.KLDivLoss",
         "unsupport_args": [
             "log_target"
         ]
     },
     "torch.nn.L1Loss": {
         "Matcher": "SizeAverageMatcher",
         "args_list": [
             "size_average",
             "reduce",
             "reduction"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.L1Loss"
     },
     "torch.nn.LSTM": {
         "Matcher": "RNNMatcher",
         "args_list": [
             "input_size",
             "hidden_size",
             "num_layers",
             "bias",
             "batch_first",
             "dropout",
             "bidirectional",
-            "proj_size"
+            "proj_size",
+            "device",
+            "dtype"
         ],
         "kwargs_change": {
             "bias": [
                 "bias_ih_attr",
                 "bias_hh_attr"
             ],
-            "nonlinearity": "activation"
+            "device": "",
+            "dtype": ""
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.LSTM",
         "unsupport_args": [
             "proj_size"
         ]
     },
     "torch.nn.LSTMCell": {
         "Matcher": "GenericMatcher",
@@ -8149,14 +9708,15 @@
             "bias": [
                 "bias_ih_attr",
                 "bias_hh_attr"
             ],
             "device": "",
             "dtype": ""
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.LSTMCell"
     },
     "torch.nn.LayerNorm": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "normalized_shape",
             "eps",
@@ -8169,22 +9729,24 @@
             "dtype": "",
             "elementwise_affine": [
                 "weight_attr",
                 "bias_attr"
             ],
             "eps": "epsilon"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.LayerNorm"
     },
     "torch.nn.LeakyReLU": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "negative_slope",
             "inplace"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.LeakyReLU"
     },
     "torch.nn.Linear": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "in_features",
             "out_features",
@@ -8193,57 +9755,63 @@
             "dtype"
         ],
         "kwargs_change": {
             "bias": "bias_attr",
             "device": "",
             "dtype": ""
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.Linear"
     },
     "torch.nn.LocalResponseNorm": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "size",
             "alpha",
             "beta",
             "k"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.LocalResponseNorm"
     },
     "torch.nn.LogSigmoid": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.LogSigmoid"
     },
     "torch.nn.LogSoftmax": {
         "Matcher": "SoftmaxMatcher",
         "args_list": [
             "dim"
         ],
         "kwargs_change": {
             "dim": "axis"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.LogSoftmax"
     },
     "torch.nn.MSELoss": {
         "Matcher": "SizeAverageMatcher",
         "args_list": [
             "size_average",
             "reduce",
             "reduction"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.MSELoss"
     },
     "torch.nn.MarginRankingLoss": {
         "Matcher": "SizeAverageMatcher",
         "args_list": [
             "margin",
             "size_average",
             "reduce",
             "reduction"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.MarginRankingLoss"
     },
     "torch.nn.MaxPool1d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "kernel_size",
             "stride",
@@ -8251,14 +9819,15 @@
             "dilation",
             "return_indices",
             "ceil_mode"
         ],
         "kwargs_change": {
             "return_indices": "return_mask"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.MaxPool1D",
         "unsupport_args": [
             "dilation"
         ]
     },
     "torch.nn.MaxPool2d": {
         "Matcher": "GenericMatcher",
@@ -8269,14 +9838,15 @@
             "dilation",
             "return_indices",
             "ceil_mode"
         ],
         "kwargs_change": {
             "return_indices": "return_mask"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.MaxPool2D",
         "unsupport_args": [
             "dilation"
         ]
     },
     "torch.nn.MaxPool3d": {
         "Matcher": "GenericMatcher",
@@ -8287,150 +9857,192 @@
             "dilation",
             "return_indices",
             "ceil_mode"
         ],
         "kwargs_change": {
             "return_indices": "return_mask"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.MaxPool3D",
         "unsupport_args": [
             "dilation"
         ]
     },
     "torch.nn.MaxUnpool1d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "kernel_size",
             "stride",
             "padding"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.MaxUnPool1D"
     },
     "torch.nn.MaxUnpool2d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "kernel_size",
             "stride",
             "padding"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.MaxUnPool2D"
     },
     "torch.nn.MaxUnpool3d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "kernel_size",
             "stride",
             "padding"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.MaxUnPool3D"
     },
     "torch.nn.Mish": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "inplace"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Mish"
     },
     "torch.nn.Module": {
         "Matcher": "GenericMatcher",
+        "abstract": true,
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Layer"
     },
     "torch.nn.Module.add_module": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "name",
             "module"
         ],
         "kwargs_change": {
             "module": "sublayer"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.Layer.add_sublayer"
     },
-    "torch.nn.Module.bfloat16": {},
+    "torch.nn.Module.apply": {
+        "Matcher": "UnchangeMatcher",
+        "args_list": [
+            "fn"
+        ],
+        "min_input_args": 1
+    },
+    "torch.nn.Module.bfloat16": {
+        "min_input_args": 0
+    },
     "torch.nn.Module.buffers": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "recurse"
         ],
         "kwargs_change": {
             "recurse": "include_sublayers"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Layer.buffers"
     },
     "torch.nn.Module.children": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Layer.children"
     },
-    "torch.nn.Module.cpu": {},
-    "torch.nn.Module.cuda": {},
-    "torch.nn.Module.double": {},
+    "torch.nn.Module.cpu": {
+        "min_input_args": 0
+    },
+    "torch.nn.Module.cuda": {
+        "min_input_args": 0
+    },
+    "torch.nn.Module.double": {
+        "min_input_args": 0
+    },
     "torch.nn.Module.eval": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "min_input_args": 0
+    },
+    "torch.nn.Module.float": {
+        "min_input_args": 0
     },
-    "torch.nn.Module.float": {},
     "torch.nn.Module.get_buffer": {
         "Matcher": "ModuleGetSubMatcher",
         "args_list": [
             "target"
-        ]
+        ],
+        "min_input_args": 1
+    },
+    "torch.nn.Module.get_extra_state": {
+        "min_input_args": 0
     },
-    "torch.nn.Module.get_extra_state": {},
     "torch.nn.Module.get_parameter": {
         "Matcher": "ModuleGetSubMatcher",
         "args_list": [
             "target"
-        ]
+        ],
+        "min_input_args": 1
     },
     "torch.nn.Module.get_submodule": {
         "Matcher": "ModuleGetSubMatcher",
         "args_list": [
             "target"
-        ]
+        ],
+        "min_input_args": 1
+    },
+    "torch.nn.Module.half": {
+        "min_input_args": 0
+    },
+    "torch.nn.Module.ipu": {
+        "min_input_args": 0
     },
-    "torch.nn.Module.half": {},
-    "torch.nn.Module.ipu": {},
     "torch.nn.Module.load_state_dict": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "state_dict",
             "strict"
         ],
         "kwargs_change": {
             "strict": "use_structured_name"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.Layer.set_state_dict"
     },
     "torch.nn.Module.modules": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Layer.sublayers"
     },
     "torch.nn.Module.named_buffers": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "prefix",
             "recurse",
             "remove_duplicate"
         ],
         "kwargs_change": {
             "recurse": "include_sublayers",
             "remove_duplicate": ""
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Layer.named_buffers"
     },
     "torch.nn.Module.named_children": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Layer.named_children"
     },
     "torch.nn.Module.named_modules": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "memo",
             "prefix",
             "remove_duplicate"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Layer.named_sublayers",
         "unsupport_args": [
             "memo",
             "remove_duplicate"
         ]
     },
     "torch.nn.Module.named_parameters": {
@@ -8440,139 +10052,208 @@
             "recurse",
             "remove_duplicate"
         ],
         "kwargs_change": {
             "recurse": "include_sublayers",
             "remove_duplicate": ""
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Layer.named_parameters"
     },
     "torch.nn.Module.parameters": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "recurse"
         ],
         "kwargs_change": {
             "recurse": "include_sublayers"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Layer.parameters"
     },
-    "torch.nn.Module.register_backward_hook": {},
+    "torch.nn.Module.register_backward_hook": {
+        "min_input_args": 1
+    },
     "torch.nn.Module.register_buffer": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "name",
             "tensor",
             "persistent"
         ],
         "kwargs_change": {
             "persistent": "persistable"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.Layer.register_buffer"
     },
     "torch.nn.Module.register_forward_hook": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "hook",
             "*",
             "prepend",
-            "with_kwargs"
+            "with_kwargs",
+            "always_call"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.Layer.register_forward_post_hook",
         "unsupport_args": [
             "prepend",
-            "with_kwargs"
+            "with_kwargs",
+            "always_call"
         ]
     },
     "torch.nn.Module.register_forward_pre_hook": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "hook",
             "*",
             "prepend",
             "with_kwargs"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.Layer.register_forward_pre_hook",
         "unsupport_args": [
             "prepend",
             "with_kwargs"
         ]
     },
-    "torch.nn.Module.register_full_backward_hook": {},
-    "torch.nn.Module.register_full_backward_pre_hook": {},
-    "torch.nn.Module.register_load_state_dict_post_hook": {},
+    "torch.nn.Module.register_full_backward_hook": {
+        "min_input_args": 1
+    },
+    "torch.nn.Module.register_full_backward_pre_hook": {
+        "min_input_args": 1
+    },
+    "torch.nn.Module.register_load_state_dict_post_hook": {
+        "min_input_args": 1
+    },
     "torch.nn.Module.register_module": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "name",
             "module"
         ],
         "kwargs_change": {
             "module": "sublayer"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.Layer.add_sublayer"
     },
     "torch.nn.Module.register_parameter": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "name",
             "param"
         ],
         "kwargs_change": {
             "param": "parameter"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.Layer.add_parameter"
     },
-    "torch.nn.Module.requires_grad_": {},
-    "torch.nn.Module.set_extra_state": {},
-    "torch.nn.Module.share_memory": {},
+    "torch.nn.Module.requires_grad_": {
+        "min_input_args": 0
+    },
+    "torch.nn.Module.set_extra_state": {
+        "min_input_args": 1
+    },
+    "torch.nn.Module.share_memory": {
+        "min_input_args": 0
+    },
     "torch.nn.Module.state_dict": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "*",
             "destination",
             "prefix",
             "keep_vars"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Layer.state_dict",
         "unsupport_args": [
             "destination",
             "prefix",
             "keep_vars"
         ]
     },
-    "torch.nn.Module.to": {},
-    "torch.nn.Module.to_empty": {},
+    "torch.nn.Module.to": {
+        "min_input_args": 0
+    },
+    "torch.nn.Module.to_empty": {
+        "min_input_args": 0
+    },
     "torch.nn.Module.train": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Layer.train"
     },
-    "torch.nn.Module.type": {},
-    "torch.nn.Module.xpu": {},
-    "torch.nn.Module.zero_grad": {},
+    "torch.nn.Module.type": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "dst_type"
+        ],
+        "kwargs_change": {
+            "dst_type": "dtype"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.nn.Layer.astype"
+    },
+    "torch.nn.Module.xpu": {
+        "min_input_args": 0
+    },
+    "torch.nn.Module.zero_grad": {
+        "min_input_args": 0
+    },
     "torch.nn.ModuleDict": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "modules"
         ],
         "kwargs_change": {
             "modules": "sublayers"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.LayerDict"
     },
     "torch.nn.ModuleList": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "modules"
         ],
         "kwargs_change": {
             "modules": "sublayers"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.LayerList"
     },
+    "torch.nn.MultiLabelSoftMarginLoss": {
+        "Matcher": "SizeAverageMatcher",
+        "args_list": [
+            "weight",
+            "size_average",
+            "reduce",
+            "reduction"
+        ],
+        "min_input_args": 0,
+        "paddle_api": "paddle.nn.MultiLabelSoftMarginLoss"
+    },
+    "torch.nn.MultiMarginLoss": {
+        "Matcher": "SizeAverageMatcher",
+        "args_list": [
+            "p",
+            "margin",
+            "weight",
+            "size_average",
+            "reduce",
+            "reduction"
+        ],
+        "min_input_args": 0,
+        "paddle_api": "paddle.nn.MultiMarginLoss"
+    },
     "torch.nn.MultiheadAttention": {
         "args_list": [
             "embed_dim",
             "num_heads",
             "dropout",
             "bias",
             "add_bias_kv",
@@ -8584,14 +10265,15 @@
             "dtype"
         ],
         "kwargs_change": {
             "bias": "bias_attr",
             "device": "",
             "dtype": ""
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.MultiHeadAttention",
         "paddle_default_kwargs": {
             "need_weights": "True"
         },
         "unsupport_args": [
             "add_bias_kv",
             "add_zero_attn",
@@ -8603,96 +10285,121 @@
         "args_list": [
             "weight",
             "size_average",
             "ignore_index",
             "reduce",
             "reduction"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.NLLLoss"
     },
     "torch.nn.PReLU": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "num_parameters",
             "init",
             "device",
             "dtype"
         ],
         "kwargs_change": {
             "device": "",
             "dtype": ""
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.PReLU"
     },
     "torch.nn.PairwiseDistance": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "p",
             "eps",
             "keepdim"
         ],
         "kwargs_change": {
             "eps": "epsilon"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.PairwiseDistance"
     },
     "torch.nn.Parameter": {
         "Matcher": "ParameterMatcher",
         "args_list": [
             "data",
             "requires_grad"
-        ]
+        ],
+        "min_input_args": 1
     },
     "torch.nn.ParameterList": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "values"
         ],
         "kwargs_change": {
             "values": "parameters"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.ParameterList"
     },
     "torch.nn.PixelShuffle": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "upscale_factor"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.PixelShuffle"
     },
     "torch.nn.PixelUnshuffle": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "downscale_factor"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.PixelUnshuffle"
     },
+    "torch.nn.PoissonNLLLoss": {
+        "Matcher": "SizeAverageMatcher",
+        "args_list": [
+            "log_input",
+            "full",
+            "size_average",
+            "eps",
+            "reduce",
+            "reduction"
+        ],
+        "kwargs_change": {
+            "eps": "epsilon"
+        },
+        "min_input_args": 0,
+        "paddle_api": "paddle.nn.PoissonNLLLoss"
+    },
     "torch.nn.RNN": {
         "Matcher": "RNNMatcher",
         "args_list": [
             "input_size",
             "hidden_size",
             "num_layers",
             "nonlinearity",
             "bias",
             "batch_first",
             "dropout",
-            "bidirectional"
+            "bidirectional",
+            "device",
+            "dtype"
         ],
         "kwargs_change": {
             "bias": [
                 "bias_ih_attr",
                 "bias_hh_attr"
             ],
+            "device": "",
+            "dtype": "",
             "nonlinearity": "activation"
         },
-        "paddle_api": "paddle.nn.SimpleRNN",
-        "unsupport_args": [
-            "proj_size"
-        ]
+        "min_input_args": 0,
+        "paddle_api": "paddle.nn.SimpleRNN"
     },
     "torch.nn.RNNBase": {
         "Matcher": "RNNBaseMatcher",
         "args_list": [
             "mode",
             "input_size",
             "hidden_size",
@@ -8707,14 +10414,15 @@
         ],
         "kwargs_change": {
             "bias": [
                 "bias_ih_attr",
                 "bias_hh_attr"
             ]
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.nn.layer.rnn.RNNBase",
         "unsupport_args": [
             "proj_size"
         ]
     },
     "torch.nn.RNNCell": {
         "Matcher": "GenericMatcher",
@@ -8731,218 +10439,295 @@
                 "bias_ih_attr",
                 "bias_hh_attr"
             ],
             "device": "",
             "dtype": "",
             "nonlinearity": "activation"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.SimpleRNNCell"
     },
     "torch.nn.RReLU": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "lower",
             "upper",
             "inplace"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.RReLU"
     },
     "torch.nn.ReLU": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "inplace"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.ReLU"
     },
     "torch.nn.ReLU6": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "inplace"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.ReLU6"
     },
     "torch.nn.ReflectionPad1d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "padding"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.Pad1D",
         "paddle_default_kwargs": {
             "mode": "'reflect'"
         }
     },
     "torch.nn.ReflectionPad2d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "padding"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.Pad2D",
         "paddle_default_kwargs": {
             "mode": "'reflect'"
         }
     },
     "torch.nn.ReflectionPad3d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "padding"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.Pad3D",
         "paddle_default_kwargs": {
             "mode": "'reflect'"
         }
     },
     "torch.nn.ReplicationPad1d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "padding"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.Pad1D",
         "paddle_default_kwargs": {
             "mode": "'replicate'"
         }
     },
     "torch.nn.ReplicationPad2d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "padding"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.Pad2D",
         "paddle_default_kwargs": {
             "mode": "'replicate'"
         }
     },
     "torch.nn.ReplicationPad3d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "padding"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.Pad3D",
         "paddle_default_kwargs": {
             "mode": "'replicate'"
         }
     },
     "torch.nn.SELU": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "inplace"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.SELU"
     },
     "torch.nn.Sequential": {
         "Matcher": "SequentialMatcher",
+        "args_list": [
+            "*args"
+        ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.Sequential"
     },
     "torch.nn.SiLU": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "inplace"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Silu"
     },
     "torch.nn.Sigmoid": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Sigmoid"
     },
+    "torch.nn.SmoothL1Loss": {
+        "Matcher": "SmoothL1LossMatcher",
+        "args_list": [
+            "size_average",
+            "reduce",
+            "reduction",
+            "beta"
+        ],
+        "kwargs_change": {
+            "beta": "delta"
+        },
+        "min_input_args": 0,
+        "paddle_api": "paddle.nn.SmoothL1Loss"
+    },
     "torch.nn.SoftMarginLoss": {
         "Matcher": "SizeAverageMatcher",
         "args_list": [
             "size_average",
             "reduce",
             "reduction"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.SoftMarginLoss"
     },
     "torch.nn.Softmax": {
         "Matcher": "SoftmaxMatcher",
         "args_list": [
             "dim"
         ],
         "kwargs_change": {
             "dim": "axis"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Softmax"
     },
     "torch.nn.Softmax2d": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Softmax",
         "paddle_default_kwargs": {
             "axis": -3
         }
     },
     "torch.nn.Softplus": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "beta",
             "threshold"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Softplus"
     },
     "torch.nn.Softshrink": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "lambd"
         ],
         "kwargs_change": {
             "lambd": "threshold"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Softshrink"
     },
     "torch.nn.Softsign": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Softsign"
     },
     "torch.nn.SyncBatchNorm": {
-        "Matcher": "BatchNormMatcher",
+        "Matcher": "ReverseMomentumMatcher",
         "args_list": [
             "num_features",
             "eps",
             "momentum",
             "affine",
             "track_running_stats",
             "process_group",
             "device",
             "dtype"
         ],
         "kwargs_change": {
+            "affine": [
+                "weight_attr",
+                "bias_attr"
+            ],
             "device": "",
             "dtype": "",
             "eps": "epsilon",
-            "process_group": ""
+            "process_group": "",
+            "track_running_stats": ""
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.SyncBatchNorm"
     },
     "torch.nn.SyncBatchNorm.convert_sync_batchnorm": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "module",
             "process_group"
         ],
         "kwargs_change": {
             "module": "layer"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.SyncBatchNorm.convert_sync_batchnorm",
         "unsupport_args": [
             "process_group"
         ]
     },
     "torch.nn.Tanh": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Tanh"
     },
     "torch.nn.Tanhshrink": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Tanhshrink"
     },
+    "torch.nn.Transformer": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "d_model",
+            "nhead",
+            "num_encoder_layers",
+            "num_decoder_layers",
+            "dim_feedforward",
+            "dropout",
+            "activation",
+            "custom_encoder",
+            "custom_decoder",
+            "layer_norm_eps",
+            "batch_first",
+            "norm_first",
+            "device",
+            "dtype"
+        ],
+        "kwargs_change": {
+            "device": "",
+            "dtype": "",
+            "norm_first": "normalize_before"
+        },
+        "min_input_args": 0,
+        "paddle_api": "paddle.nn.Transformer",
+        "unsupport_args": [
+            "layer_norm_eps",
+            "batch_first"
+        ]
+    },
     "torch.nn.TransformerDecoder": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "decoder_layer",
             "num_layers",
             "norm"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.TransformerDecoder"
     },
     "torch.nn.TransformerDecoderLayer": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "d_model",
             "nhead",
@@ -8956,20 +10741,64 @@
             "dtype"
         ],
         "kwargs_change": {
             "device": "",
             "dtype": "",
             "norm_first": "normalize_before"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.TransformerDecoderLayer",
         "paddle_default_kwargs": {
             "dim_feedforward": 2048
         },
         "unsupport_args": [
+            "batch_first"
+        ]
+    },
+    "torch.nn.TransformerEncoder": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "encoder_layer",
+            "num_layers",
+            "norm",
+            "enable_nested_tensor",
+            "mask_check"
+        ],
+        "kwargs_change": {
+            "enable_nested_tensor": "",
+            "mask_check": ""
+        },
+        "min_input_args": 2,
+        "paddle_api": "paddle.nn.TransformerEncoder"
+    },
+    "torch.nn.TransformerEncoderLayer": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "d_model",
+            "nhead",
+            "dim_feedforward",
+            "dropout",
+            "activation",
             "layer_norm_eps",
+            "batch_first",
+            "norm_first",
+            "device",
+            "dtype"
+        ],
+        "kwargs_change": {
+            "device": "",
+            "dtype": "",
+            "norm_first": "normalize_before"
+        },
+        "min_input_args": 2,
+        "paddle_api": "paddle.nn.TransformerEncoderLayer",
+        "paddle_default_kwargs": {
+            "dim_feedforward": 2048
+        },
+        "unsupport_args": [
             "batch_first"
         ]
     },
     "torch.nn.TripletMarginLoss": {
         "Matcher": "SizeAverageMatcher",
         "args_list": [
             "margin",
@@ -8979,35 +10808,40 @@
             "size_average",
             "reduce",
             "reduction"
         ],
         "kwargs_change": {
             "eps": "epsilon"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.TripletMarginLoss"
     },
     "torch.nn.TripletMarginWithDistanceLoss": {
         "Matcher": "GenericMatcher",
         "args_list": [
+            "*",
+            "distance_function",
             "margin",
             "swap",
             "reduction"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.TripletMarginWithDistanceLoss"
     },
     "torch.nn.Unflatten": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "dim",
             "unflattened_size"
         ],
         "kwargs_change": {
             "dim": "axis",
             "unflattened_size": "shape"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.Unflatten"
     },
     "torch.nn.Unfold": {
         "Matcher": "Tuple2ListMatcher",
         "args_list": [
             "kernel_size",
             "dilation",
@@ -9016,219 +10850,242 @@
         ],
         "kwargs_change": {
             "dilation": "dilations",
             "kernel_size": "kernel_sizes",
             "padding": "paddings",
             "stride": "strides"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.Unfold"
     },
     "torch.nn.Upsample": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "size",
             "scale_factor",
             "mode",
             "align_corners"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.Upsample",
         "unsupport_args": [
             "recompute_scale_factor"
         ]
     },
     "torch.nn.UpsamplingBilinear2d": {
         "Matcher": "UpsampleMatcher",
         "args_list": [
             "size",
             "scale_factor"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.UpsamplingBilinear2D"
     },
     "torch.nn.UpsamplingNearest2d": {
         "Matcher": "UpsampleMatcher",
         "args_list": [
             "size",
             "scale_factor"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.UpsamplingNearest2D"
     },
     "torch.nn.ZeroPad2d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "padding"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.ZeroPad2D"
     },
     "torch.nn.functional._Reduction.get_enum": {
         "Matcher": "Get_EnumMatcher",
         "args_list": [
             "reduction"
-        ]
+        ],
+        "min_input_args": 1
     },
     "torch.nn.functional.adaptive_avg_pool1d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "output_size"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.adaptive_avg_pool1d"
     },
     "torch.nn.functional.adaptive_avg_pool2d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "output_size"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.adaptive_avg_pool2d"
     },
     "torch.nn.functional.adaptive_avg_pool3d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "output_size"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.adaptive_avg_pool3d"
     },
     "torch.nn.functional.adaptive_max_pool1d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "output_size",
             "return_indices"
         ],
         "kwargs_change": {
             "input": "x",
             "return_indices": "return_mask"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.adaptive_max_pool1d"
     },
     "torch.nn.functional.adaptive_max_pool2d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "output_size",
             "return_indices"
         ],
         "kwargs_change": {
             "input": "x",
             "return_indices": "return_mask"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.adaptive_max_pool2d"
     },
     "torch.nn.functional.adaptive_max_pool3d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "output_size",
             "return_indices"
         ],
         "kwargs_change": {
             "input": "x",
             "return_indices": "return_mask"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.adaptive_max_pool3d"
     },
     "torch.nn.functional.affine_grid": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "theta",
             "size",
             "align_corners"
         ],
         "kwargs_change": {
             "size": "out_shape"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.affine_grid"
     },
     "torch.nn.functional.alpha_dropout": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "p",
             "training",
             "inplace"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.alpha_dropout"
     },
     "torch.nn.functional.avg_pool1d": {
         "Matcher": "AvgPoolMatcher",
         "args_list": [
             "input",
             "kernel_size",
             "stride",
             "padding",
             "ceil_mode",
             "count_include_pad"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.avg_pool1d"
     },
     "torch.nn.functional.avg_pool2d": {
         "Matcher": "AvgPoolMatcher",
         "args_list": [
             "input",
             "kernel_size",
             "stride",
             "padding",
             "ceil_mode",
             "count_include_pad",
             "divisor_override"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.avg_pool2d"
     },
     "torch.nn.functional.avg_pool3d": {
         "Matcher": "AvgPoolMatcher",
         "args_list": [
             "input",
             "kernel_size",
             "stride",
             "padding",
             "ceil_mode",
             "count_include_pad",
             "divisor_override"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.avg_pool3d"
     },
     "torch.nn.functional.batch_norm": {
-        "Matcher": "FBatchNormMatcher",
+        "Matcher": "ReverseMomentumMatcher",
         "args_list": [
             "input",
             "running_mean",
             "running_var",
             "weight",
             "bias",
             "training",
             "momentum",
             "eps"
         ],
+        "kwargs_change": {
+            "eps": "epsilon",
+            "input": "x"
+        },
+        "min_input_args": 3,
         "paddle_api": "paddle.nn.functional.batch_norm"
     },
     "torch.nn.functional.bilinear": {
         "Matcher": "FunctionalBilinearMatcher",
         "args_list": [
             "input1",
             "input2",
             "weight",
             "bias"
         ],
         "kwargs_change": {
             "input1": "x1",
             "input2": "x2"
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.nn.functional.bilinear"
     },
     "torch.nn.functional.binary_cross_entropy": {
         "Matcher": "SizeAverageMatcher",
         "args_list": [
             "input",
             "target",
@@ -9236,14 +11093,15 @@
             "size_average",
             "reduce",
             "reduction"
         ],
         "kwargs_change": {
             "target": "label"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.binary_cross_entropy"
     },
     "torch.nn.functional.binary_cross_entropy_with_logits": {
         "Matcher": "SizeAverageMatcher",
         "args_list": [
             "input",
             "target",
@@ -9253,26 +11111,28 @@
             "reduction",
             "pos_weight"
         ],
         "kwargs_change": {
             "input": "logit",
             "target": "label"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.binary_cross_entropy_with_logits"
     },
     "torch.nn.functional.celu": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "alpha",
             "inplace"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.celu"
     },
     "torch.nn.functional.conv1d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "weight",
@@ -9281,14 +11141,15 @@
             "padding",
             "dilation",
             "groups"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.conv1d"
     },
     "torch.nn.functional.conv2d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "weight",
@@ -9297,14 +11158,15 @@
             "padding",
             "dilation",
             "groups"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.conv2d"
     },
     "torch.nn.functional.conv3d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "weight",
@@ -9313,65 +11175,69 @@
             "padding",
             "dilation",
             "groups"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.conv3d"
     },
     "torch.nn.functional.conv_transpose1d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "weight",
             "bias",
             "stride",
             "padding",
             "output_padding",
-            "dilation",
-            "groups"
+            "groups",
+            "dilation"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.conv1d_transpose"
     },
     "torch.nn.functional.conv_transpose2d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "weight",
             "bias",
             "stride",
             "padding",
             "output_padding",
-            "dilation",
-            "groups"
+            "groups",
+            "dilation"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.conv2d_transpose"
     },
     "torch.nn.functional.conv_transpose3d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "weight",
             "bias",
             "stride",
             "padding",
             "output_padding",
-            "dilation",
-            "groups"
+            "groups",
+            "dilation"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.conv3d_transpose"
     },
     "torch.nn.functional.cosine_embedding_loss": {
         "Matcher": "SizeAverageMatcher",
         "args_list": [
             "input1",
             "input2",
@@ -9380,119 +11246,129 @@
             "size_average",
             "reduce",
             "reduction"
         ],
         "kwargs_change": {
             "target": "label"
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.nn.functional.cosine_embedding_loss"
     },
     "torch.nn.functional.cosine_similarity": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "x1",
             "x2",
             "dim",
             "eps"
         ],
         "kwargs_change": {
             "dim": "axis"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.cosine_similarity"
     },
     "torch.nn.functional.cross_entropy": {
         "Matcher": "SizeAverageMatcher",
         "args_list": [
             "input",
-            "label",
+            "target",
             "weight",
             "size_average",
             "ignore_index",
             "reduce",
             "reduction",
             "label_smoothing"
         ],
         "kwargs_change": {
-            "label_smoothing": "soft_label"
+            "label_smoothing": "soft_label",
+            "target": "label"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.cross_entropy"
     },
     "torch.nn.functional.dropout": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "p",
             "training",
             "inplace"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.dropout"
     },
     "torch.nn.functional.dropout1d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "p",
             "training",
             "inplace"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.dropout"
     },
     "torch.nn.functional.dropout2d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "p",
             "training",
             "inplace"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.dropout2d"
     },
     "torch.nn.functional.dropout3d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "p",
             "training",
             "inplace"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.dropout3d"
     },
     "torch.nn.functional.elu": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "alpha",
             "inplace"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.elu"
     },
     "torch.nn.functional.elu_": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "alpha"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.elu_"
     },
     "torch.nn.functional.embedding": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "weight",
@@ -9501,14 +11377,15 @@
             "norm_type",
             "scale_grad_by_freq",
             "sparse"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.embedding",
         "unsupport_args": [
             "max_norm",
             "norm_type",
             "scale_grad_by_freq"
         ]
     },
@@ -9526,14 +11403,15 @@
             "dilation": "dilations",
             "input": "x",
             "kernel_size": "kernel_sizes",
             "output_size": "output_sizes",
             "padding": "paddings",
             "stride": "strides"
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.nn.functional.fold"
     },
     "torch.nn.functional.gaussian_nll_loss": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "target",
@@ -9543,50 +11421,71 @@
             "reduction"
         ],
         "kwargs_change": {
             "eps": "epsilon",
             "target": "label",
             "var": "variance"
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.nn.functional.gaussian_nll_loss"
     },
     "torch.nn.functional.gelu": {
         "Matcher": "GeluMatcher",
         "args_list": [
             "input",
+            "*",
             "approximate"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.gelu"
     },
     "torch.nn.functional.glu": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dim"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.glu"
     },
     "torch.nn.functional.grid_sample": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "grid",
             "mode",
             "align_corners",
             "padding_mode"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.grid_sample"
     },
+    "torch.nn.functional.group_norm": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "input",
+            "num_groups",
+            "weight",
+            "bias",
+            "eps"
+        ],
+        "kwargs_change": {
+            "eps": "epsilon",
+            "input": "x"
+        },
+        "min_input_args": 2,
+        "paddle_api": "paddle.nn.functional.group_norm"
+    },
     "torch.nn.functional.gumbel_softmax": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "logits",
             "tau",
             "hard",
             "eps",
@@ -9594,48 +11493,52 @@
         ],
         "kwargs_change": {
             "dim": "axis",
             "eps": "",
             "logits": "x",
             "tau": "temperature"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.gumbel_softmax"
     },
     "torch.nn.functional.hardshrink": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "lambd"
         ],
         "kwargs_change": {
             "input": "x",
             "lambd": "threshold"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.hardshrink"
     },
     "torch.nn.functional.hardsigmoid": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "inplace"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.hardsigmoid"
     },
     "torch.nn.functional.hardswish": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "inplace"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.hardswish"
     },
     "torch.nn.functional.hardtanh": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "min_val",
@@ -9643,28 +11546,30 @@
             "inplace"
         ],
         "kwargs_change": {
             "input": "x",
             "max_val": "max",
             "min_val": "min"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.hardtanh"
     },
     "torch.nn.functional.hardtanh_": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "min_val",
             "max_val"
         ],
         "kwargs_change": {
             "input": "x",
             "max_val": "max",
             "min_val": "min"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.hardtanh_"
     },
     "torch.nn.functional.hinge_embedding_loss": {
         "Matcher": "SizeAverageMatcher",
         "args_list": [
             "input",
             "target",
@@ -9672,41 +11577,47 @@
             "size_average",
             "reduce",
             "reduction"
         ],
         "kwargs_change": {
             "target": "label"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.hinge_embedding_loss"
     },
     "torch.nn.functional.huber_loss": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "target",
             "reduction",
             "delta"
         ],
         "kwargs_change": {
             "target": "label"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.smooth_l1_loss"
     },
     "torch.nn.functional.instance_norm": {
-        "Matcher": "FInstanceNormMatcher",
+        "Matcher": "ReverseMomentumMatcher",
         "args_list": [
             "input",
             "running_mean",
             "running_var",
             "weight",
             "bias",
             "use_input_stats",
             "momentum",
             "eps"
         ],
+        "kwargs_change": {
+            "input": "x"
+        },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.instance_norm"
     },
     "torch.nn.functional.interpolate": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "size",
@@ -9715,14 +11626,15 @@
             "align_corners",
             "recompute_scale_factor",
             "antialias"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.interpolate",
         "unsupport_args": [
             "recompute_scale_factor",
             "antialias"
         ]
     },
     "torch.nn.functional.kl_div": {
@@ -9731,28 +11643,33 @@
             "input",
             "target",
             "size_average",
             "reduce",
             "reduction",
             "log_target"
         ],
-        "paddle_api": "paddle.nn.functional.kl_div"
+        "min_input_args": 2,
+        "paddle_api": "paddle.nn.functional.kl_div",
+        "unsupport_args": [
+            "log_target"
+        ]
     },
     "torch.nn.functional.l1_loss": {
         "Matcher": "SizeAverageMatcher",
         "args_list": [
             "input",
             "target",
             "size_average",
             "reduce",
             "reduction"
         ],
         "kwargs_change": {
             "target": "label"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.l1_loss"
     },
     "torch.nn.functional.layer_norm": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "normalized_shape",
@@ -9760,60 +11677,65 @@
             "bias",
             "eps"
         ],
         "kwargs_change": {
             "eps": "epsilon",
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.layer_norm"
     },
     "torch.nn.functional.leaky_relu": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "negative_slope",
             "inplace"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.leaky_relu"
     },
     "torch.nn.functional.leaky_relu_": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "negative_slope"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.leaky_relu_"
     },
     "torch.nn.functional.linear": {
         "Matcher": "FunctionalLinearMatcher",
         "args_list": [
             "input",
             "weight",
             "bias"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.linear"
     },
     "torch.nn.functional.local_response_norm": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "size",
             "alpha",
             "beta",
             "k"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.local_response_norm"
     },
     "torch.nn.functional.log_softmax": {
         "Matcher": "RequireDimMatcher",
         "args_list": [
             "input",
             "dim",
@@ -9822,24 +11744,26 @@
         ],
         "kwargs_change": {
             "_stacklevel": "",
             "dim": "axis",
             "dtype": "dtype",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.log_softmax"
     },
     "torch.nn.functional.logsigmoid": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.log_sigmoid"
     },
     "torch.nn.functional.margin_ranking_loss": {
         "Matcher": "SizeAverageMatcher",
         "args_list": [
             "input1",
             "input2",
@@ -9850,14 +11774,15 @@
             "reduction"
         ],
         "kwargs_change": {
             "input1": "input",
             "input2": "other",
             "target": "label"
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.nn.functional.margin_ranking_loss"
     },
     "torch.nn.functional.max_pool1d": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "kernel_size",
@@ -9867,14 +11792,15 @@
             "ceil_mode",
             "return_indices"
         ],
         "kwargs_change": {
             "input": "x",
             "return_indices": "return_mask"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.functional.max_pool1d",
         "unsupport_args": [
             "dilation"
         ]
     },
     "torch.nn.functional.max_pool2d": {
         "Matcher": "GenericMatcher",
@@ -9887,14 +11813,15 @@
             "ceil_mode",
             "return_indices"
         ],
         "kwargs_change": {
             "input": "x",
             "return_indices": "return_mask"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.functional.max_pool2d",
         "unsupport_args": [
             "dilation"
         ]
     },
     "torch.nn.functional.max_pool3d": {
         "Matcher": "GenericMatcher",
@@ -9907,14 +11834,15 @@
             "ceil_mode",
             "return_indices"
         ],
         "kwargs_change": {
             "input": "x",
             "return_indices": "return_mask"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.nn.functional.max_pool3d",
         "unsupport_args": [
             "dilation"
         ]
     },
     "torch.nn.functional.max_unpool1d": {
         "Matcher": "UnpoolMatcher",
@@ -9925,14 +11853,15 @@
             "stride",
             "padding",
             "output_size"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.nn.functional.max_unpool1d",
         "unsupport_args": [
             "output_size"
         ]
     },
     "torch.nn.functional.max_unpool2d": {
         "Matcher": "UnpoolMatcher",
@@ -9943,14 +11872,15 @@
             "stride",
             "padding",
             "output_size"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.nn.functional.max_unpool2d"
     },
     "torch.nn.functional.max_unpool3d": {
         "Matcher": "UnpoolMatcher",
         "args_list": [
             "input",
             "indices",
@@ -9958,39 +11888,42 @@
             "stride",
             "padding",
             "output_size"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.nn.functional.max_unpool3d"
     },
     "torch.nn.functional.mish": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "inplace"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.mish"
     },
     "torch.nn.functional.mse_loss": {
         "Matcher": "SizeAverageMatcher",
         "args_list": [
             "input",
             "target",
             "size_average",
             "reduce",
             "reduction"
         ],
         "kwargs_change": {
             "target": "label"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.mse_loss"
     },
     "torch.nn.functional.multi_margin_loss": {
         "Matcher": "SizeAverageMatcher",
         "args_list": [
             "input",
             "target",
@@ -10000,14 +11933,15 @@
             "size_average",
             "reduce",
             "reduction"
         ],
         "kwargs_change": {
             "target": "label"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.multi_margin_loss"
     },
     "torch.nn.functional.multilabel_soft_margin_loss": {
         "Matcher": "SizeAverageMatcher",
         "args_list": [
             "input",
             "target",
@@ -10015,14 +11949,15 @@
             "size_average",
             "reduce",
             "reduction"
         ],
         "kwargs_change": {
             "target": "label"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.multi_label_soft_margin_loss"
     },
     "torch.nn.functional.nll_loss": {
         "Matcher": "SizeAverageMatcher",
         "args_list": [
             "input",
             "target",
@@ -10031,14 +11966,15 @@
             "ignore_index",
             "reduce",
             "reduction"
         ],
         "kwargs_change": {
             "target": "label"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.nll_loss"
     },
     "torch.nn.functional.normalize": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "p",
@@ -10047,63 +11983,91 @@
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "eps": "epsilon",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.normalize"
     },
     "torch.nn.functional.one_hot": {
         "Matcher": "FunctionalOneHotMatcher",
         "args_list": [
             "input",
             "num_classes"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.one_hot"
     },
+    "torch.nn.functional.pad": {
+        "Matcher": "FunctionalPadMatcher",
+        "args_list": [
+            "input",
+            "pad",
+            "mode",
+            "value"
+        ],
+        "min_input_args": 2,
+        "paddle_api": "paddle.nn.functional.pad"
+    },
     "torch.nn.functional.pairwise_distance": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "x1",
             "x2",
             "p",
             "eps",
             "keepdim"
         ],
         "kwargs_change": {
             "eps": "epsilon",
             "x1": "x",
             "x2": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.pairwise_distance"
     },
+    "torch.nn.functional.pdist": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "input",
+            "p"
+        ],
+        "kwargs_change": {
+            "input": "x"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.nn.functional.pdist"
+    },
     "torch.nn.functional.pixel_shuffle": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "upscale_factor"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.pixel_shuffle"
     },
     "torch.nn.functional.pixel_unshuffle": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "downscale_factor"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.pixel_unshuffle"
     },
     "torch.nn.functional.poisson_nll_loss": {
         "Matcher": "SizeAverageMatcher",
         "args_list": [
             "input",
             "target",
@@ -10114,116 +12078,126 @@
             "reduce",
             "reduction"
         ],
         "kwargs_change": {
             "eps": "epsilon",
             "target": "label"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.poisson_nll_loss"
     },
     "torch.nn.functional.prelu": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "weight"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.prelu"
     },
     "torch.nn.functional.relu": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "inplace"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.relu"
     },
     "torch.nn.functional.relu6": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "inplace"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.relu6"
     },
     "torch.nn.functional.relu_": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.relu_"
     },
     "torch.nn.functional.rrelu": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "lower",
             "upper",
             "training",
             "inplace"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.rrelu"
     },
     "torch.nn.functional.rrelu_": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "lower",
             "upper",
             "training"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.rrelu"
     },
     "torch.nn.functional.selu": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "inplace"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.selu"
     },
     "torch.nn.functional.sigmoid": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.sigmoid"
     },
     "torch.nn.functional.silu": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "inplace"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.silu"
     },
     "torch.nn.functional.smooth_l1_loss": {
         "Matcher": "FunctionalSmoothL1LossMatcher",
         "args_list": [
             "input",
             "target",
@@ -10231,28 +12205,30 @@
             "reduce",
             "reduction",
             "beta"
         ],
         "kwargs_change": {
             "target": "label"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.smooth_l1_loss"
     },
     "torch.nn.functional.soft_margin_loss": {
         "Matcher": "SizeAverageMatcher",
         "args_list": [
             "input",
             "target",
             "size_average",
             "reduce",
             "reduction"
         ],
         "kwargs_change": {
             "target": "label"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.soft_margin_loss"
     },
     "torch.nn.functional.softmax": {
         "Matcher": "RequireDimMatcher",
         "args_list": [
             "input",
             "dim",
@@ -10261,14 +12237,15 @@
         ],
         "kwargs_change": {
             "_stacklevel": "",
             "dim": "axis",
             "dtype": "dtype",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.softmax"
     },
     "torch.nn.functional.softmin": {
         "Matcher": "FSoftMinMatcher",
         "args_list": [
             "input",
             "dim",
@@ -10277,84 +12254,113 @@
         ],
         "kwargs_change": {
             "_stacklevel": "",
             "dim": "axis",
             "dtype": "dtype",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.softmax"
     },
     "torch.nn.functional.softplus": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "beta",
             "threshold"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.softplus"
     },
     "torch.nn.functional.softshrink": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "lambd"
         ],
         "kwargs_change": {
             "input": "x",
             "lambd": "threshold"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.softshrink"
     },
     "torch.nn.functional.softsign": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.softsign"
     },
     "torch.nn.functional.tanh": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.tanh"
     },
     "torch.nn.functional.tanhshrink": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.tanhshrink"
     },
+    "torch.nn.functional.triplet_margin_loss": {
+        "Matcher": "SizeAverageMatcher",
+        "args_list": [
+            "anchor",
+            "positive",
+            "negative",
+            "margin",
+            "p",
+            "eps",
+            "swap",
+            "size_average",
+            "reduce",
+            "reduction"
+        ],
+        "kwargs_change": {
+            "anchor": "input",
+            "eps": "epsilon"
+        },
+        "min_input_args": 3,
+        "paddle_api": "paddle.nn.functional.triplet_margin_loss"
+    },
     "torch.nn.functional.triplet_margin_with_distance_loss": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "anchor",
             "positive",
             "negative",
+            "*",
             "distance_function",
             "margin",
             "swap",
             "reduction"
         ],
         "kwargs_change": {
             "anchor": "input"
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.nn.functional.triplet_margin_with_distance_loss"
     },
     "torch.nn.functional.unfold": {
         "Matcher": "Tuple2ListMatcher",
         "args_list": [
             "input",
             "kernel_size",
@@ -10365,40 +12371,46 @@
         "kwargs_change": {
             "dilation": "dilations",
             "input": "x",
             "kernel_size": "kernel_sizes",
             "padding": "paddings",
             "stride": "strides"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.unfold"
     },
     "torch.nn.functional.upsample": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "size",
             "scale_factor",
             "mode",
             "align_corners"
         ],
         "kwargs_change": {
             "input": "x"
         },
-        "paddle_api": "paddle.nn.functional.upsample"
+        "min_input_args": 1,
+        "paddle_api": "paddle.nn.functional.upsample",
+        "unsupport_args": [
+            "align_corners"
+        ]
     },
     "torch.nn.functional.upsample_bilinear": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "size",
             "scale_factor"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.upsample",
         "paddle_default_kwargs": {
             "align_corners": "True",
             "mode": "'bilinear'"
         }
     },
     "torch.nn.functional.upsample_nearest": {
@@ -10407,61 +12419,67 @@
             "input",
             "size",
             "scale_factor"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.upsample"
     },
     "torch.nn.init.calculate_gain": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "nonlinearity",
             "param"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.initializer.calculate_gain"
     },
     "torch.nn.init.constant_": {
         "Matcher": "InitMatcher",
         "args_list": [
             "tensor",
             "val"
         ],
         "kwargs_change": {
             "val": "value"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.initializer.Constant"
     },
     "torch.nn.init.dirac_": {
         "Matcher": "InitMatcher",
         "args_list": [
             "tensor",
             "groups"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.initializer.Dirac"
     },
     "torch.nn.init.eye_": {
         "Matcher": "InitEyeMatcher",
         "args_list": [
             "tensor"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.initializer.Assign"
     },
     "torch.nn.init.kaiming_normal_": {
         "Matcher": "InitKaimingMatcher",
         "args_list": [
             "tensor",
             "a",
             "mode",
             "nonlinearity"
         ],
         "kwargs_change": {
             "a": "negative_slope"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.initializer.KaimingNormal",
         "paddle_default_kwargs": {
             "nonlinearity": "'leaky_relu'"
         }
     },
     "torch.nn.init.kaiming_uniform_": {
         "Matcher": "InitKaimingMatcher",
@@ -10470,124 +12488,140 @@
             "a",
             "mode",
             "nonlinearity"
         ],
         "kwargs_change": {
             "a": "negative_slope"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.initializer.KaimingUniform",
         "paddle_default_kwargs": {
             "nonlinearity": "'leaky_relu'"
         }
     },
     "torch.nn.init.normal_": {
         "Matcher": "InitMatcher",
         "args_list": [
             "tensor",
             "mean",
             "std"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.initializer.Normal"
     },
     "torch.nn.init.ones_": {
         "Matcher": "InitMatcher",
         "args_list": [
             "tensor"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.initializer.Constant",
         "paddle_default_kwargs": {
             "value": "1.0"
         }
     },
     "torch.nn.init.orthogonal_": {
         "Matcher": "InitMatcher",
         "args_list": [
             "tensor",
             "gain"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.initializer.Orthogonal"
     },
     "torch.nn.init.uniform_": {
         "Matcher": "InitMatcher",
         "args_list": [
             "tensor",
             "a",
             "b"
         ],
         "kwargs_change": {
             "a": "low",
             "b": "high"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.initializer.Uniform",
         "paddle_default_kwargs": {
             "low": "0.0"
         }
     },
     "torch.nn.init.xavier_normal_": {
         "Matcher": "InitMatcher",
         "args_list": [
             "tensor",
             "gain"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.initializer.XavierNormal",
         "unsupport_args": [
             "gain"
         ]
     },
     "torch.nn.init.xavier_uniform_": {
         "Matcher": "InitMatcher",
         "args_list": [
             "tensor",
             "gain"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.initializer.XavierUniform",
         "unsupport_args": [
             "gain"
         ]
     },
     "torch.nn.init.zeros_": {
         "Matcher": "InitMatcher",
         "args_list": [
             "tensor"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.initializer.Constant",
         "paddle_default_kwargs": {
             "value": "0.0"
         }
     },
     "torch.nn.modules.batchnorm._BatchNorm": {
-        "Matcher": "Modules_BatchNormBaseMatcher",
+        "Matcher": "ReverseMomentumMatcher",
         "args_list": [
             "num_features",
             "eps",
             "momentum",
             "affine",
             "track_running_stats",
             "device",
             "dtype"
         ],
         "kwargs_change": {
+            "affine": [
+                "weight_attr",
+                "bias_attr"
+            ],
             "device": "",
             "dtype": "",
-            "eps": "epsilon"
+            "eps": "epsilon",
+            "track_running_stats": ""
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.layer.norm._BatchNormBase"
     },
     "torch.nn.modules.utils._ntuple": {
         "Matcher": "NTupleMatcher",
         "args_list": [
             "n",
             "name"
-        ]
+        ],
+        "min_input_args": 1
     },
     "torch.nn.modules.utils._pair": {
         "Matcher": "NTupleMatcher",
         "args_list": [
             "x"
         ],
+        "min_input_args": 1,
         "paddle_default_kwargs": {
             "n": 2
         }
     },
     "torch.nn.parallel.DistributedDataParallel": {
         "Matcher": "GenericMatcher",
         "args_list": [
@@ -10605,14 +12639,15 @@
         ],
         "kwargs_change": {
             "bucket_cap_mb": "comm_buffer_size",
             "check_reduction": "",
             "device_ids": "",
             "module": "layers"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.DataParallel",
         "unsupport_args": [
             "output_device",
             "dim",
             "broadcast_buffers",
             "process_group",
             "gradient_as_bucket_view",
@@ -10627,96 +12662,105 @@
             "norm_type",
             "error_if_nonfinite",
             "foreach"
         ],
         "kwargs_change": {
             "foreach": ""
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.utils.clip_grad_norm_"
     },
     "torch.nn.utils.clip_grad_value_": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "parameters",
             "clip_value",
             "foreach"
         ],
         "kwargs_change": {
             "foreach": ""
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.utils.clip_grad_value_"
     },
     "torch.nn.utils.parameters_to_vector": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "parameters"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.utils.parameters_to_vector"
     },
     "torch.nn.utils.parametrizations.spectral_norm": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "module",
             "name",
             "n_power_iterations",
             "eps",
             "dim"
         ],
         "kwargs_change": {
             "module": "layer"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.utils.spectral_norm"
     },
     "torch.nn.utils.remove_weight_norm": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "module",
             "name"
         ],
         "kwargs_change": {
             "module": "layer"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.utils.remove_weight_norm"
     },
     "torch.nn.utils.spectral_norm": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "module",
             "name",
             "n_power_iterations",
             "eps",
             "dim"
         ],
         "kwargs_change": {
             "module": "layer"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.utils.spectral_norm"
     },
     "torch.nn.utils.vector_to_parameters": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "vec",
             "parameters"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.utils.vector_to_parameters"
     },
     "torch.nn.utils.weight_norm": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "module",
             "name",
             "dim"
         ],
         "kwargs_change": {
             "module": "layer"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.utils.weight_norm"
     },
     "torch.no_grad": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.no_grad"
     },
     "torch.nonzero": {
         "Matcher": "NonzeroMatcher",
         "args_list": [
             "input",
             "*",
@@ -10738,14 +12782,15 @@
             "out",
             "dtype"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.linalg.norm"
     },
     "torch.normal": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "mean",
             "std",
@@ -10758,41 +12803,55 @@
             "device",
             "pin_memory",
             "requires_grad"
         ],
         "kwargs_change": {
             "size": "shape"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.normal"
     },
     "torch.not_equal": {
         "Matcher": "Num2TensorBinaryMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.not_equal"
     },
     "torch.numel": {
         "Matcher": "NumelMatcher",
         "args_list": [
             "input"
-        ]
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.Tensor.size"
     },
     "torch.ones": {
         "Matcher": "CreateMatcher",
+        "args_list": [
+            "*size",
+            "out",
+            "dtype",
+            "layout",
+            "device",
+            "requires_grad",
+            "pin_memory"
+        ],
         "kwargs_change": {
             "dtype": "dtype"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.ones"
     },
     "torch.ones_like": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
@@ -10802,14 +12861,15 @@
             "requires_grad",
             "memory_format"
         ],
         "kwargs_change": {
             "dtype": "dtype",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.ones_like"
     },
     "torch.optim.Adadelta": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "params",
             "lr",
@@ -10822,14 +12882,15 @@
             "differentiable"
         ],
         "kwargs_change": {
             "eps": "epsilon",
             "lr": "learning_rate",
             "params": "parameters"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.optimizer.Adadelta",
         "paddle_default_kwargs": {
             "learning_rate": 1.0,
             "rho": 0.9,
             "weight_decay": 0.0
         },
         "unsupport_args": [
@@ -10853,14 +12914,15 @@
             "differentiable"
         ],
         "kwargs_change": {
             "eps": "epsilon",
             "lr": "learning_rate",
             "params": "parameters"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.optimizer.Adagrad",
         "paddle_default_kwargs": {
             "epsilon": 1e-10,
             "learning_rate": 0.01,
             "weight_decay": 0.0
         },
         "unsupport_args": [
@@ -10887,14 +12949,15 @@
             "fused"
         ],
         "kwargs_change": {
             "eps": "epsilon",
             "lr": "learning_rate",
             "params": "parameters"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.optimizer.Adam",
         "paddle_default_kwargs": {
             "weight_decay": 0.0
         },
         "unsupport_args": [
             "amsgrad",
             "foreach",
@@ -10921,14 +12984,15 @@
             "fused"
         ],
         "kwargs_change": {
             "eps": "epsilon",
             "lr": "learning_rate",
             "params": "parameters"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.optimizer.AdamW",
         "paddle_default_kwargs": {
             "weight_decay": 0.0
         },
         "unsupport_args": [
             "amsgrad",
             "maximize",
@@ -10952,14 +13016,15 @@
             "differentiable"
         ],
         "kwargs_change": {
             "eps": "epsilon",
             "lr": "learning_rate",
             "params": "parameters"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.optimizer.Adamax",
         "unsupport_args": [
             "foreach",
             "maximize",
             "differentiable"
         ]
     },
@@ -10975,67 +13040,79 @@
             "history_size",
             "line_search_fn"
         ],
         "kwargs_change": {
             "lr": "learning_rate",
             "params": "parameters"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.optimizer.LBFGS"
     },
     "torch.optim.Optimizer": {
         "Matcher": "OptimOptimizerMatcher",
         "args_list": [
             "params",
             "defaults"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.optimizer.Optimizer"
     },
     "torch.optim.Optimizer.add_param_group": {
+        "min_input_args": 1,
         "paddle_api": "paddle.optimizer.Optimizer._add_param_group"
     },
     "torch.optim.Optimizer.load_state_dict": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "state_dict"
         ],
-        "paddle_api": "paddle.optimizer.Optimizer.set_state_dict"
-    },
-    "torch.optim.Optimizer.state_dict": {
-        "Matcher": "UnchangeMatcher"
+        "min_input_args": 1,
+        "paddle_api": "paddle.optimizer.Optimizer.load_state_dict"
     },
     "torch.optim.Optimizer.step": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "UnchangeMatcher",
+        "abstract": true,
+        "min_input_args": 0
+    },
+    "torch.optim.Optimizer.zero_grad": {
+        "min_input_args": 0
     },
-    "torch.optim.Optimizer.zero_grad": {},
     "torch.optim.RMSprop": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "params",
             "lr",
             "alpha",
             "eps",
             "weight_decay",
             "momentum",
             "centered",
+            "foreach",
             "maximize",
             "differentiable"
         ],
         "kwargs_change": {
             "alpha": "rho",
             "eps": "epsilon",
             "lr": "learning_rate",
             "params": "parameters"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.optimizer.RMSProp",
         "paddle_default_kwargs": {
             "epsilon": 1e-08,
             "learning_rate": 0.01,
             "rho": 0.99,
             "weight_decay": 0.0
-        }
+        },
+        "unsupport_args": [
+            "foreach",
+            "maximize",
+            "differentiable"
+        ]
     },
     "torch.optim.SGD": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "params",
             "lr",
             "momentum",
@@ -11047,48 +13124,65 @@
             "foreach",
             "differentiable"
         ],
         "kwargs_change": {
             "lr": "learning_rate",
             "params": "parameters"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.optimizer.SGD",
         "paddle_default_kwargs": {
             "weight_decay": 0.0
         },
         "unsupport_args": [
             "momentum",
             "dampening",
             "nesterov",
             "maximize",
+            "foreach",
             "differentiable"
         ]
     },
     "torch.optim.lr_scheduler.ConstantLR": {
         "Matcher": "ConstantLRMatcher",
         "args_list": [
             "optimizer",
             "factor",
             "total_iters",
             "last_epoch",
             "verbose"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.optimizer.lr.PiecewiseDecay"
     },
     "torch.optim.lr_scheduler.CosineAnnealingLR": {
         "Matcher": "Optim2LrSchedulerMatcher",
         "args_list": [
             "optimizer",
             "T_max",
             "eta_min",
             "last_epoch",
             "verbose"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.optimizer.lr.CosineAnnealingDecay"
     },
+    "torch.optim.lr_scheduler.CosineAnnealingWarmRestarts": {
+        "Matcher": "Optim2LrSchedulerMatcher",
+        "args_list": [
+            "optimizer",
+            "T_0",
+            "T_mult",
+            "eta_min",
+            "last_epoch",
+            "verbose"
+        ],
+        "min_input_args": 2,
+        "paddle_api": "paddle.optimizer.lr.CosineAnnealingWarmRestarts"
+    },
     "torch.optim.lr_scheduler.CyclicLR": {
         "Matcher": "LRSchedulerMatcher",
         "args_list": [
             "optimizer",
             "base_lr",
             "max_lr",
             "step_size_up",
@@ -11104,14 +13198,15 @@
             "verbose"
         ],
         "kwargs_change": {
             "base_lr": "base_learning_rate",
             "gamma": "exp_gamma",
             "max_lr": "max_learning_rate"
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.optimizer.lr.CyclicLR",
         "paddle_default_kwargs": {
             "step_size_up": "2000"
         },
         "unsupport_args": [
             "cycle_momentum",
             "base_momentum",
@@ -11122,45 +13217,68 @@
         "Matcher": "Optim2LrSchedulerMatcher",
         "args_list": [
             "optimizer",
             "gamma",
             "last_epoch",
             "verbose"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.optimizer.lr.ExponentialDecay"
     },
     "torch.optim.lr_scheduler.LambdaLR": {
         "Matcher": "Optim2LrSchedulerMatcher",
         "args_list": [
             "optimizer",
             "lr_lambda",
             "last_epoch",
             "verbose"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.optimizer.lr.LambdaDecay"
     },
+    "torch.optim.lr_scheduler.LinearLR": {
+        "Matcher": "Optim2LrSchedulerMatcher",
+        "args_list": [
+            "optimizer",
+            "start_factor",
+            "end_factor",
+            "total_iters",
+            "last_epoch",
+            "verbose"
+        ],
+        "kwargs_change": {
+            "total_iters": "total_steps"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.optimizer.lr.LinearLR",
+        "paddle_default_kwargs": {
+            "total_steps": "5"
+        }
+    },
     "torch.optim.lr_scheduler.MultiStepLR": {
         "Matcher": "Optim2LrSchedulerMatcher",
         "args_list": [
             "optimizer",
             "milestones",
             "gamma",
             "last_epoch",
             "verbose"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.optimizer.lr.MultiStepDecay"
     },
     "torch.optim.lr_scheduler.MultiplicativeLR": {
         "Matcher": "Optim2LrSchedulerMatcher",
         "args_list": [
             "optimizer",
             "lr_lambda",
             "last_epoch",
             "verbose"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.optimizer.lr.MultiplicativeDecay"
     },
     "torch.optim.lr_scheduler.OneCycleLR": {
         "Matcher": "OneCycleLRMatcher",
         "args_list": [
             "optimizer",
             "max_lr",
@@ -11179,14 +13297,15 @@
             "verbose"
         ],
         "kwargs_change": {
             "div_factor": "divide_factor",
             "max_lr": "max_learning_rate",
             "pct_start": "phase_pct"
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.optimizer.lr.OneCycleLR",
         "unsupport_args": [
             "cycle_momentum",
             "base_momentum",
             "max_momentum"
         ]
     },
@@ -11203,97 +13322,119 @@
             "min_lr",
             "eps",
             "verbose"
         ],
         "kwargs_change": {
             "eps": "epsilon"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.optimizer.lr.ReduceOnPlateau"
     },
     "torch.optim.lr_scheduler.StepLR": {
         "Matcher": "Optim2LrSchedulerMatcher",
         "args_list": [
             "optimizer",
             "step_size",
             "gamma",
             "last_epoch",
             "verbose"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.optimizer.lr.StepDecay"
     },
     "torch.outer": {
-        "Matcher": "GenericMatcher",
+        "Matcher": "OuterMatcher",
         "args_list": [
             "input",
             "vec2",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "vec2": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.outer"
     },
+    "torch.pca_lowrank": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "A",
+            "q",
+            "center",
+            "niter"
+        ],
+        "kwargs_change": {
+            "A": "x"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.linalg.pca_lowrank"
+    },
     "torch.permute": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dims"
         ],
         "kwargs_change": {
             "dims": "perm",
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.transpose"
     },
     "torch.pinverse": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "rcond"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.linalg.pinv"
     },
     "torch.poisson": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "generator"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.poisson"
     },
     "torch.poisson_nll_loss": {},
     "torch.polar": {
         "Matcher": "PolarMatcher",
         "args_list": [
             "abs",
             "angle",
             "*",
             "out"
-        ]
+        ],
+        "min_input_args": 2
     },
     "torch.pow": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "exponent",
             "*",
             "out"
         ],
         "kwargs_change": {
             "exponent": "y",
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.pow"
     },
     "torch.prod": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dim",
@@ -11303,20 +13444,29 @@
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "dtype": "dtype",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.prod"
     },
-    "torch.profiler.profile": {},
-    "torch.profiler.profile.start": {},
-    "torch.profiler.profile.step": {},
-    "torch.profiler.profile.stop": {},
+    "torch.profiler.profile": {
+        "min_input_args": 0
+    },
+    "torch.profiler.profile.start": {
+        "min_input_args": 0
+    },
+    "torch.profiler.profile.step": {
+        "min_input_args": 0
+    },
+    "torch.profiler.profile.stop": {
+        "min_input_args": 0
+    },
     "torch.profiler.schedule": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "*",
             "wait",
             "warmup",
             "active",
@@ -11324,27 +13474,29 @@
             "skip_first"
         ],
         "kwargs_change": {
             "active": "record",
             "wait": "closed",
             "warmup": "ready"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.profiler.make_scheduler"
     },
     "torch.qr": {
         "Matcher": "QrMatcher",
         "args_list": [
             "input",
             "some",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.linalg.qr"
     },
     "torch.quantile": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "q",
@@ -11354,49 +13506,59 @@
             "interpolation",
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
-        "paddle_api": "paddle.quantile",
-        "unsupport_args": [
-            "interpolation "
-        ]
+        "paddle_api": "paddle.quantile"
     },
     "torch.rad2deg": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.rad2deg"
     },
     "torch.rand": {
         "Matcher": "CreateMatcher",
+        "args_list": [
+            "*size",
+            "generator",
+            "out",
+            "dtype",
+            "layout",
+            "device",
+            "requires_grad",
+            "pin_memory"
+        ],
         "kwargs_change": {
             "dtype": "dtype"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.rand"
     },
     "torch.rand_like": {
         "Matcher": "RandLikeMatcher",
         "args_list": [
             "input",
             "*",
             "dtype",
             "layout",
             "device",
             "requires_grad",
             "memory_format"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.rand"
     },
     "torch.randint": {
         "Matcher": "RandintMatcher",
         "args_list": [
             "low",
             "high",
@@ -11410,14 +13572,15 @@
             "pin_memory",
             "requires_grad"
         ],
         "kwargs_change": {
             "dtype": "dtype",
             "size": "shape"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.randint"
     },
     "torch.randint_like": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "low",
@@ -11429,34 +13592,47 @@
             "requires_grad",
             "memory_format"
         ],
         "kwargs_change": {
             "dtype": "dtype",
             "input": "x"
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.randint_like"
     },
     "torch.randn": {
         "Matcher": "CreateMatcher",
+        "args_list": [
+            "*size",
+            "generator",
+            "out",
+            "dtype",
+            "layout",
+            "device",
+            "requires_grad",
+            "pin_memory"
+        ],
         "kwargs_change": {
             "dtype": "dtype"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.randn"
     },
     "torch.randn_like": {
         "Matcher": "RandLikeMatcher",
         "args_list": [
             "input",
             "*",
             "dtype",
             "layout",
             "device",
             "requires_grad",
             "memory_format"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.randn"
     },
     "torch.randperm": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "n",
             "*",
@@ -11467,14 +13643,15 @@
             "device",
             "pin_memory",
             "requires_grad"
         ],
         "kwargs_change": {
             "dtype": "dtype"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.randperm"
     },
     "torch.range": {
         "Matcher": "RangeMatcher",
         "args_list": [
             "start",
             "end",
@@ -11482,66 +13659,72 @@
             "*",
             "out",
             "dtype",
             "layout",
             "device",
             "requires_grad"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.arange"
     },
     "torch.ravel": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.flatten"
     },
     "torch.real": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.real"
     },
     "torch.reciprocal": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.reciprocal"
     },
     "torch.relu": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.relu"
     },
     "torch.remainder": {
         "Matcher": "Num2TensorBinaryMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.remainder"
     },
     "torch.renorm": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "p",
@@ -11551,108 +13734,123 @@
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x",
             "maxnorm": "max_norm"
         },
+        "min_input_args": 4,
         "paddle_api": "paddle.renorm"
     },
     "torch.repeat_interleave": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "repeats",
             "dim",
             "*",
             "output_size"
         ],
         "kwargs_change": {
             "dim": "axis",
-            "input": "x"
+            "input": "x",
+            "output_size": ""
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.repeat_interleave"
     },
     "torch.reshape": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "shape"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.reshape"
     },
     "torch.roll": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "shifts",
             "dims"
         ],
         "kwargs_change": {
             "dims": "axis",
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.roll"
     },
     "torch.rot90": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "k",
             "dims"
         ],
         "kwargs_change": {
             "dims": "axes",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.rot90"
     },
     "torch.round": {
         "Matcher": "RoundMatcher",
         "args_list": [
             "input",
             "*",
             "decimals",
             "out"
-        ]
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.round"
     },
     "torch.row_stack": {
-        "Matcher": "VStackMatcher",
+        "Matcher": "GenericMatcher",
         "args_list": [
             "tensors",
             "*",
             "out"
-        ]
+        ],
+        "kwargs_change": {
+            "tensors": "x"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.row_stack"
     },
     "torch.rrelu": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "lower",
             "upper",
             "training"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.rrelu"
     },
     "torch.rsqrt": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.rsqrt"
     },
     "torch.save": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "obj",
             "f",
@@ -11662,14 +13860,15 @@
         ],
         "kwargs_change": {
             "_use_new_zipfile_serialization": "",
             "f": "path",
             "pickle_module": "",
             "pickle_protocol": "protocol"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.save"
     },
     "torch.scalar_tensor": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "s",
             "*",
@@ -11680,14 +13879,15 @@
             "pin_memory"
         ],
         "kwargs_change": {
             "device": "place",
             "dtype": "dtype",
             "s": "data"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.to_tensor",
         "paddle_default_kwargs": {
             "dtype": "paddle.float32"
         }
     },
     "torch.scatter": {
         "Matcher": "GenericMatcher",
@@ -11704,14 +13904,15 @@
         "kwargs_change": {
             "dim": "axis",
             "index": "indices",
             "input": "arr",
             "src": "values",
             "value": "values"
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.put_along_axis"
     },
     "torch.scatter_add": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dim",
@@ -11720,150 +13921,201 @@
         ],
         "kwargs_change": {
             "dim": "axis",
             "index": "indices",
             "input": "arr",
             "src": "values"
         },
-        "paddle_api": "paddle.Tensor.put_along_axis",
+        "min_input_args": 4,
+        "paddle_api": "paddle.put_along_axis",
         "paddle_default_kwargs": {
             "reduce": "'add'"
         }
     },
     "torch.searchsorted": {
         "Matcher": "SearchsortedMatcher",
         "args_list": [
             "sorted_sequence",
-            "values",
+            "input",
             "*",
             "out_int32",
             "right",
             "side",
-            "out",
-            "sorter"
-        ]
+            "sorter",
+            "out"
+        ],
+        "kwargs_change": {
+            "input": "values"
+        },
+        "min_input_args": 2,
+        "paddle_api": "paddle.searchsorted"
     },
     "torch.seed": {
-        "Matcher": "SeedMatcher"
+        "Matcher": "SeedMatcher",
+        "min_input_args": 0
     },
     "torch.select": {
         "Matcher": "SelectMatcher",
         "args_list": [
             "input",
             "dim",
             "index"
-        ]
+        ],
+        "min_input_args": 3
+    },
+    "torch.select_scatter": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "input",
+            "src",
+            "dim",
+            "index"
+        ],
+        "kwargs_change": {
+            "dim": "axis",
+            "input": "x",
+            "src": "values"
+        },
+        "min_input_args": 4,
+        "paddle_api": "paddle.select_scatter"
     },
     "torch.selu": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.nn.functional.selu"
     },
     "torch.set_default_dtype": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "d"
         ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.set_default_dtype"
+    },
+    "torch.set_default_tensor_type": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "d"
+        ],
         "paddle_api": "paddle.set_default_dtype"
     },
     "torch.set_grad_enabled": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "mode"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.set_grad_enabled"
     },
     "torch.set_printoptions": {
         "Matcher": "SetPrintOptionsMatcher",
         "args_list": [
             "precision",
             "threshold",
             "edgeitems",
             "linewidth",
             "profile",
             "sci_mode"
         ],
+        "min_input_args": 0,
+        "paddle_api": "paddle.set_printoptions",
         "paddle_default_kwargs": {
             "precision": 4
         }
     },
     "torch.set_rng_state": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "new_state"
         ],
         "kwargs_change": {
             "new_state": "state_list"
         },
-        "paddle_api": "paddle.set_cuda_rng_state"
+        "min_input_args": 1,
+        "paddle_api": "paddle.set_rng_state"
     },
     "torch.sgn": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.sgn"
     },
-    "torch.short": {
-        "Matcher": "GenericMatcher",
-        "paddle_api": "'int16'"
-    },
     "torch.sign": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.sign"
     },
+    "torch.signbit": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "input",
+            "*",
+            "out"
+        ],
+        "kwargs_change": {
+            "input": "x"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.signbit"
+    },
     "torch.sin": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.sin"
     },
     "torch.sinh": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.sinh"
     },
     "torch.slogdet": {
         "Matcher": "SLogDetMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.linalg.slogdet"
     },
     "torch.softmax": {
         "Matcher": "RequireDimMatcher",
         "args_list": [
             "input",
             "dim",
@@ -11872,17 +14124,20 @@
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "dtype": "dtype",
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.softmax"
     },
-    "torch.solve": {},
+    "torch.solve": {
+        "min_input_args": 2
+    },
     "torch.sort": {
         "Matcher": "SortMatcher",
         "args_list": [
             "input",
             "dim",
             "descending",
             "*",
@@ -11909,53 +14164,57 @@
             "beta",
             "alpha"
         ],
         "kwargs_change": {
             "mat1": "x",
             "mat2": "y"
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.sparse.addmm"
     },
     "torch.sparse.mm": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "sparse",
             "dense"
         ],
         "kwargs_change": {
             "dense": "y",
             "sparse": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.sparse.matmul"
     },
     "torch.sparse.softmax": {
         "Matcher": "SparseSoftmaxMatcher",
         "args_list": [
             "input",
             "dim",
             "*",
             "dtype"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.sparse.nn.functional.softmax"
     },
     "torch.sparse.sum": {
         "Matcher": "RequireDimMatcher",
         "args_list": [
             "input",
             "dim",
             "dtype"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.sparse.sum",
         "unsupport_args": [
             "dtype"
         ]
     },
     "torch.sparse_coo_tensor": {
         "Matcher": "GenericMatcher",
@@ -11971,14 +14230,15 @@
         ],
         "kwargs_change": {
             "check_invariants": "",
             "device": "place",
             "dtype": "dtype",
             "size": "shape"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.sparse.sparse_coo_tensor"
     },
     "torch.sparse_csr_tensor": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "crow_indices",
             "col_indices",
@@ -11997,14 +14257,15 @@
             "col_indices": "cols",
             "crow_indices": "crows",
             "device": "place",
             "dtype": "dtype",
             "pin_memory": "",
             "size": "shape"
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.sparse.sparse_csr_tensor"
     },
     "torch.special.airy_ai": {},
     "torch.special.bessel_j0": {},
     "torch.special.bessel_j1": {},
     "torch.special.bessel_y0": {},
     "torch.special.bessel_y1": {},
@@ -12014,160 +14275,174 @@
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.digamma"
     },
     "torch.special.entr": {},
     "torch.special.erf": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.erf"
     },
     "torch.special.erfc": {
         "Matcher": "ErfCMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
-        }
+        },
+        "min_input_args": 1
     },
     "torch.special.erfcx": {
         "Matcher": "SpecialErfcxMatcher",
         "args_list": [
             "input",
             "*",
             "out"
-        ]
+        ],
+        "min_input_args": 1
     },
     "torch.special.erfinv": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.erfinv"
     },
     "torch.special.exp2": {
         "Matcher": "Exp2Matcher",
         "args_list": [
             "input",
             "*",
             "out"
-        ]
+        ],
+        "min_input_args": 1
     },
     "torch.special.expit": {
         "Matcher": "ExpitMatcher",
         "args_list": [
             "input",
             "*",
             "out"
-        ]
+        ],
+        "min_input_args": 1
     },
     "torch.special.expm1": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.expm1"
     },
     "torch.special.gammainc": {},
     "torch.special.gammaincc": {},
     "torch.special.gammaln": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.lgamma"
     },
     "torch.special.i0": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.i0"
     },
     "torch.special.i0e": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.i0e"
     },
     "torch.special.i1": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.i1"
     },
     "torch.special.i1e": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.i1e"
     },
     "torch.special.log1p": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.log1p"
     },
     "torch.special.log_ndtr": {},
     "torch.special.log_softmax": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
@@ -12176,27 +14451,29 @@
             "dtype"
         ],
         "kwargs_change": {
             "dim": "axis",
             "dtype": "dtype",
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.log_softmax"
     },
     "torch.special.logit": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "eps",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.logit"
     },
     "torch.special.logsumexp": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dim",
@@ -12204,166 +14481,195 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.logsumexp"
     },
-    "torch.special.multigammaln": {},
+    "torch.special.multigammaln": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "input",
+            "p",
+            "*",
+            "out"
+        ],
+        "kwargs_change": {
+            "input": "x"
+        },
+        "min_input_args": 2,
+        "paddle_api": "paddle.multigammaln"
+    },
     "torch.special.ndtr": {},
     "torch.special.ndtri": {
         "Matcher": "SpecialNdtriMatcher",
         "args_list": [
             "input",
             "*",
             "out"
-        ]
+        ],
+        "min_input_args": 1
     },
     "torch.special.polygamma": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "n",
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.polygamma"
     },
     "torch.special.psi": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.digamma"
     },
     "torch.special.round": {
         "Matcher": "RoundMatcher",
         "args_list": [
             "input",
+            "*",
             "decimals",
             "out"
-        ]
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.round"
     },
     "torch.special.scaled_modified_bessel_k0": {},
     "torch.special.scaled_modified_bessel_k1": {},
     "torch.special.sinc": {
         "Matcher": "SincMatcher",
         "args_list": [
             "input",
             "*",
             "out"
-        ]
+        ],
+        "min_input_args": 1
     },
     "torch.special.softmax": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dim",
             "*",
             "dtype"
         ],
         "kwargs_change": {
             "dim": "axis",
             "dtype": "dtype",
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.nn.functional.softmax"
     },
     "torch.special.spherical_bessel_j0": {},
     "torch.special.xlog1py": {
         "Matcher": "SpecialXLog1pYMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
-        ]
+        ],
+        "min_input_args": 2
     },
     "torch.special.xlogy": {
         "Matcher": "XLogYMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
-        ]
+        ],
+        "min_input_args": 2
     },
     "torch.special.zeta": {},
     "torch.split": {
         "Matcher": "SplitMatcher",
         "args_list": [
             "tensor",
             "split_size_or_sections",
             "dim"
         ],
         "kwargs_change": {
             "dim": "axis",
             "split_size_or_sections": "num_or_sections",
             "tensor": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.split"
     },
     "torch.sqrt": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.sqrt"
     },
     "torch.square": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.square"
     },
     "torch.squeeze": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dim"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.squeeze"
     },
     "torch.stack": {
         "Matcher": "GenericMatcher",
         "args_list": [
-            "tensor",
+            "tensors",
             "dim",
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
-            "tensor": "x"
+            "tensors": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.stack"
     },
     "torch.std": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dim",
@@ -12375,14 +14681,15 @@
             "out"
         ],
         "kwargs_change": {
             "correction": "unbiased",
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.std"
     },
     "torch.std_mean": {
         "Matcher": "StdMeanMatcher",
         "args_list": [
             "input",
             "dim",
@@ -12392,25 +14699,27 @@
             "correction",
             "keepdim"
         ],
         "kwargs_change": {
             "correction": "unbiased",
             "dim": "axis",
             "input": "x"
-        }
+        },
+        "min_input_args": 1
     },
     "torch.subtract": {
         "Matcher": "Num2TensorBinaryWithAlphaMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "alpha",
             "out"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.subtract"
     },
     "torch.sum": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dim",
@@ -12420,14 +14729,15 @@
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "dtype": "dtype",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.sum"
     },
     "torch.svd": {
         "Matcher": "SvdMatcher",
         "args_list": [
             "input",
             "some",
@@ -12445,40 +14755,61 @@
     },
     "torch.swapaxes": {
         "Matcher": "SwapAxesMatcher",
         "args_list": [
             "input",
             "axis0",
             "axis1"
-        ]
+        ],
+        "min_input_args": 3,
+        "paddle_api": "paddle.transpose"
     },
     "torch.swapdims": {
         "Matcher": "TransposeMatcher",
         "args_list": [
             "input",
             "dim0",
             "dim1"
-        ]
+        ],
+        "min_input_args": 3,
+        "paddle_api": "paddle.transpose"
+    },
+    "torch.symeig": {
+        "Matcher": "SymeigMatcher",
+        "args_list": [
+            "input",
+            "eigenvectors",
+            "upper",
+            "*",
+            "out"
+        ],
+        "kwargs_change": {
+            "input": "x"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.linalg.eigh"
     },
     "torch.t": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.t"
     },
     "torch.take": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "index"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.take"
     },
     "torch.take_along_dim": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "indices",
@@ -12486,37 +14817,41 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "arr"
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.take_along_axis"
     },
     "torch.tan": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.tan"
     },
     "torch.tensor": {
         "Matcher": "TorchTensorMatcher",
         "args_list": [
             "data",
+            "*",
             "dtype",
             "device",
             "requires_grad",
             "pin_memory"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.to_tensor"
     },
     "torch.tensordot": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "a",
             "b",
@@ -12524,14 +14859,15 @@
             "out"
         ],
         "kwargs_change": {
             "a": "x",
             "b": "y",
             "dims": "axes"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.tensordot"
     },
     "torch.testing.assert_allclose": {
         "Matcher": "Assert_AllcloseMatcher",
         "args_list": [
             "actual",
             "expected",
@@ -12540,52 +14876,56 @@
             "equal_nan",
             "msg"
         ],
         "kwargs_change": {
             "acltual": "x",
             "expected": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.allclose"
     },
     "torch.testing.assert_close": {
         "Matcher": "Assert_AllcloseMatcher",
         "args_list": [
             "actual",
             "expected",
+            "*",
+            "allow_subclasses",
             "rtol",
             "atol",
             "equal_nan",
-            "msg",
-            "allow_subclasses",
             "check_device",
             "check_dtype",
             "check_layout",
-            "check_stride"
+            "check_stride",
+            "msg"
         ],
         "kwargs_change": {
             "actual": "x",
             "allow_subclasses": "",
             "check_device": "",
             "check_dtype": "",
             "check_layout": "",
             "check_stride": "",
             "expected": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.allclose"
     },
     "torch.tile": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dims"
         ],
         "kwargs_change": {
             "dims": "repeat_times",
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.tile"
     },
     "torch.topk": {
         "Matcher": "DoubleAssignMatcher",
         "args_list": [
             "input",
             "k",
@@ -12595,33 +14935,37 @@
             "*",
             "out"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.topk"
     },
     "torch.trace": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.trace"
     },
     "torch.transpose": {
         "Matcher": "TransposeMatcher",
         "args_list": [
             "input",
             "dim0",
             "dim1"
-        ]
+        ],
+        "min_input_args": 3,
+        "paddle_api": "paddle.transpose"
     },
     "torch.trapezoid": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "y",
             "x",
             "dx",
@@ -12631,39 +14975,41 @@
             "dim": "axis"
         },
         "paddle_api": "paddle.trapezoid"
     },
     "torch.triangular_solve": {
         "Matcher": "TriangularSolveMatcher",
         "args_list": [
-            "b",
+            "input",
             "A",
             "upper",
             "transpose",
             "unitriangular",
             "*",
             "out"
         ],
         "kwargs_change": {
             "A": "x",
-            "b": "y"
+            "input": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.linalg.triangular_solve"
     },
     "torch.tril": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "diagonal",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.tril"
     },
     "torch.tril_indices": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "row",
             "col",
@@ -12672,28 +15018,30 @@
             "dtype",
             "device",
             "layout"
         ],
         "kwargs_change": {
             "dtype": "dtype"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.tril_indices"
     },
     "torch.triplet_margin_loss": {},
     "torch.triu": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "diagonal",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.triu"
     },
     "torch.triu_indices": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "row",
             "col",
@@ -12702,66 +15050,67 @@
             "dtype",
             "device",
             "layout"
         ],
         "kwargs_change": {
             "dtype": "dtype"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.triu_indices"
     },
     "torch.true_divide": {
         "Matcher": "Num2TensorBinaryMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.divide"
     },
     "torch.trunc": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
             "out"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.trunc"
     },
-    "torch.uint8": {
-        "Matcher": "GenericMatcher",
-        "paddle_api": "'uint8'"
-    },
     "torch.unbind": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dim"
         ],
         "kwargs_change": {
             "dim": "axis"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.unbind"
     },
     "torch.unflatten": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dim",
             "sizes"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x",
             "sizes": "shape"
         },
+        "min_input_args": 3,
         "paddle_api": "paddle.unflatten"
     },
     "torch.unique": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "sorted",
@@ -12769,14 +15118,15 @@
             "return_counts",
             "dim"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.unique",
         "unsupport_args": [
             "sorted"
         ]
     },
     "torch.unique_consecutive": {
         "Matcher": "GenericMatcher",
@@ -12786,39 +15136,38 @@
             "return_counts",
             "dim"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 0,
         "paddle_api": "paddle.unique_consecutive"
     },
     "torch.unsqueeze": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dim"
         ],
         "kwargs_change": {
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.unsqueeze"
     },
     "torch.utils.cpp_extension.BuildExtension": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "dist"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.utils.cpp_extension.BuildExtension"
     },
-    "torch.utils.cpp_extension.BuildExtension.with_options": {
-        "Matcher": "GenericMatcher",
-        "paddle_api": "paddle.utils.cpp_extension.BuildExtension.with_options"
-    },
     "torch.utils.cpp_extension.CUDAExtension": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "name",
             "sources",
             "*",
             "include_dirs",
@@ -12836,20 +15185,17 @@
             "language",
             "optional",
             "py_limited_api"
         ],
         "kwargs_change": {
             "name": ""
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.utils.cpp_extension.CUDAExtension"
     },
-    "torch.utils.cpp_extension.CUDA_HOME": {
-        "Matcher": "GenericMatcher",
-        "paddle_api": "paddle.utils.cpp_extension.cpp_extension.CUDA_HOME"
-    },
     "torch.utils.cpp_extension.CppExtension": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "name",
             "sources",
             "*",
             "include_dirs",
@@ -12867,14 +15213,15 @@
             "language",
             "optional",
             "py_limited_api"
         ],
         "kwargs_change": {
             "name": ""
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.utils.cpp_extension.CppExtension"
     },
     "torch.utils.cpp_extension.load": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "name",
             "sources",
@@ -12890,38 +15237,85 @@
             "keep_intermediates"
         ],
         "kwargs_change": {
             "extra_cflags": "extra_cxx_cflags",
             "keep_intermediates": "",
             "with_cuda": ""
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.utils.cpp_extension.load",
         "unsupport_args": [
             "is_python_module",
             "is_standalone"
         ]
     },
     "torch.utils.data.BatchSampler": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "sampler",
             "batch_size",
             "drop_last"
         ],
+        "min_input_args": 3,
         "paddle_api": "paddle.io.BatchSampler"
     },
     "torch.utils.data.ChainDataset": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "datasets"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.io.ChainDataset"
     },
+    "torch.utils.data.ConcatDataset": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "datasets"
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.io.ConcatDataset"
+    },
+    "torch.utils.data.DataLoader": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "dataset",
+            "batch_size",
+            "shuffle",
+            "sampler",
+            "batch_sampler",
+            "num_workers",
+            "collate_fn",
+            "pin_memory",
+            "drop_last",
+            "timeout",
+            "worker_init_fn",
+            "multiprocessing_context",
+            "generator",
+            "prefetch_factor",
+            "persistent_workers",
+            "pin_memory_device"
+        ],
+        "kwargs_change": {
+            "generator": "",
+            "multiprocessing_context": "",
+            "persistent_workers": "",
+            "pin_memory": "",
+            "pin_memory_device": ""
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.io.DataLoader",
+        "unsupport_args": [
+            "sampler",
+            "prefetch_factor"
+        ]
+    },
     "torch.utils.data.Dataset": {
         "Matcher": "GenericMatcher",
+        "abstract": true,
+        "min_input_args": 0,
         "paddle_api": "paddle.io.Dataset"
     },
     "torch.utils.data.DistributedSampler": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "dataset",
             "num_replicas",
@@ -12929,97 +15323,123 @@
             "shuffle",
             "seed",
             "drop_last"
         ],
         "kwargs_change": {
             "seed": ""
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.io.DistributedBatchSampler",
         "paddle_default_kwargs": {
             "batch_size": "1",
             "shuffle": "True"
         }
     },
     "torch.utils.data.IterableDataset": {
         "Matcher": "GenericMatcher",
+        "abstract": true,
+        "min_input_args": 0,
         "paddle_api": "paddle.io.IterableDataset"
     },
     "torch.utils.data.RandomSampler": {
         "Matcher": "RandomSamplerMatcher",
         "args_list": [
             "data_source",
             "replacement",
             "num_samples",
             "generator"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.io.RandomSampler"
     },
     "torch.utils.data.Sampler": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "data_source"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.io.Sampler"
     },
     "torch.utils.data.SequentialSampler": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "data_source"
         ],
+        "min_input_args": 0,
         "paddle_api": "paddle.io.SequenceSampler"
     },
     "torch.utils.data.Subset": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "dataset",
             "indices"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.io.Subset"
     },
+    "torch.utils.data.SubsetRandomSampler": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "indices",
+            "generator"
+        ],
+        "min_input_args": 1,
+        "paddle_api": "paddle.io.SubsetRandomSampler"
+    },
     "torch.utils.data.TensorDataset": {
         "Matcher": "TensorDatasetMatcher",
+        "args_list": [
+            "*tensors"
+        ],
+        "min_input_args": 1,
         "paddle_api": "paddle.io.TensorDataset"
     },
     "torch.utils.data.WeightedRandomSampler": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "weights",
             "num_samples",
-            "replacement"
+            "replacement",
+            "generator"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.io.WeightedRandomSampler"
     },
     "torch.utils.data.default_collate": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "batch"
         ],
+        "min_input_args": 1,
         "paddle_api": "paddle.io.dataloader.collate.default_collate_fn"
     },
     "torch.utils.data.get_worker_info": {
         "Matcher": "GenericMatcher",
+        "min_input_args": 0,
         "paddle_api": "paddle.io.get_worker_info"
     },
     "torch.utils.data.random_split": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "dataset",
             "lengths",
             "generator"
         ],
+        "min_input_args": 2,
         "paddle_api": "paddle.io.random_split"
     },
     "torch.utils.dlpack.from_dlpack": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "ext_tensor"
         ],
         "kwargs_change": {
             "ext_tensor": "dlpack"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.utils.dlpack.from_dlpack"
     },
     "torch.utils.dlpack.to_dlpack": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "tensor"
         ],
@@ -13034,14 +15454,15 @@
             "x",
             "N",
             "increasing"
         ],
         "kwargs_change": {
             "N": "n"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.vander"
     },
     "torch.var": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "dim",
@@ -13053,14 +15474,15 @@
             "out"
         ],
         "kwargs_change": {
             "correction": "unbiased",
             "dim": "axis",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.var"
     },
     "torch.var_mean": {
         "Matcher": "VarMeanMatcher",
         "args_list": [
             "input",
             "dim",
@@ -13070,72 +15492,98 @@
             "correction",
             "keepdim"
         ],
         "kwargs_change": {
             "correction": "unbiased",
             "dim": "axis",
             "input": "x"
-        }
+        },
+        "min_input_args": 1
     },
     "torch.vdot": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "other",
             "*",
             "out"
         ],
         "kwargs_change": {
             "input": "x",
             "other": "y"
         },
+        "min_input_args": 2,
         "paddle_api": "paddle.dot"
     },
     "torch.view_as_complex": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.as_complex"
     },
     "torch.view_as_real": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input"
         ],
         "kwargs_change": {
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.as_real"
     },
     "torch.vstack": {
-        "Matcher": "VStackMatcher",
+        "Matcher": "GenericMatcher",
         "args_list": [
             "tensors",
             "*",
             "out"
-        ]
+        ],
+        "kwargs_change": {
+            "tensors": "x"
+        },
+        "min_input_args": 1,
+        "paddle_api": "paddle.vstack"
     },
     "torch.where": {
         "Matcher": "WhereMatcher",
         "args_list": [
             "condition",
-            "x",
-            "y"
+            "input",
+            "other",
+            "*",
+            "out"
         ],
+        "kwargs_change": {
+            "input": "x",
+            "other": "y"
+        },
+        "min_input_args": 3,
         "paddle_api": "paddle.where"
     },
     "torch.zeros": {
         "Matcher": "CreateMatcher",
+        "args_list": [
+            "*size",
+            "out",
+            "dtype",
+            "layout",
+            "device",
+            "requires_grad",
+            "pin_memory"
+        ],
         "kwargs_change": {
             "dtype": "dtype"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.zeros"
     },
     "torch.zeros_like": {
         "Matcher": "GenericMatcher",
         "args_list": [
             "input",
             "*",
@@ -13145,10 +15593,136 @@
             "requires_grad",
             "memory_format"
         ],
         "kwargs_change": {
             "dtype": "dtype",
             "input": "x"
         },
+        "min_input_args": 1,
         "paddle_api": "paddle.zeros_like"
+    },
+    "transformers.AddedToken": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "content",
+            "single_word",
+            "lstrip",
+            "rstrip",
+            "normalized"
+        ],
+        "paddle_api": "paddlenlp.transformers.AddedToken"
+    },
+    "transformers.GenerationConfig": {
+        "Matcher": "TRFMGenerationConfigMatcher",
+        "args_list": [
+            "*",
+            "max_length",
+            "max_new_tokens",
+            "min_length",
+            "min_new_tokens",
+            "early_stopping",
+            "max_time",
+            "do_sample",
+            "num_beams",
+            "num_beam_groups",
+            "penalty_alpha",
+            "use_cache",
+            "temperature",
+            "top_k",
+            "top_p",
+            "typical_p",
+            "epsilon_cutoff",
+            "eta_cutoff",
+            "diversity_penalty",
+            "repetition_penalty",
+            "encoder_repetition_penalty",
+            "length_penalty",
+            "no_repeat_ngram_size",
+            "bad_words_ids",
+            "force_words_ids",
+            "renormalize_logits",
+            "constraints",
+            "forced_bos_token_id",
+            "forced_eos_token_id",
+            "remove_invalid_values",
+            "exponential_decay_length_penalty",
+            "suppress_tokens",
+            "begin_suppress_tokens",
+            "forced_decoder_ids",
+            "sequence_bias ",
+            "guidance_scale",
+            "low_memory",
+            "num_return_sequences",
+            "output_attentions",
+            "output_hidden_states",
+            "output_scores",
+            "return_dict_in_generate",
+            "pad_token_id",
+            "bos_token_id",
+            "eos_token_id",
+            "encoder_no_repeat_ngram_size",
+            "decoder_start_token_id",
+            "num_assistant_tokens",
+            "num_assistant_tokens_schedule"
+        ],
+        "paddle_api": "paddlenlp.generation.GenerationConfig",
+        "unsupport_args": [
+            "max_new_tokens",
+            "min_new_tokens",
+            "max_time",
+            "penalty_alpha",
+            "typical_p",
+            "epsilon_cutoff",
+            "eta_cutoff",
+            "diversity_penalty",
+            "encoder_repetition_penalty",
+            "no_repeat_ngram_size",
+            "bad_words_ids",
+            "force_words_ids",
+            "renormalize_logits",
+            "constraints",
+            "remove_invalid_values",
+            "exponential_decay_length_penalty",
+            "suppress_tokens",
+            "begin_suppress_tokens",
+            "forced_decoder_ids",
+            "sequence_bias ",
+            "guidance_scale",
+            "low_memory",
+            "num_return_sequences",
+            "output_attentions",
+            "output_hidden_states",
+            "output_scores",
+            "return_dict_in_generate",
+            "encoder_no_repeat_ngram_size",
+            "num_assistant_tokens",
+            "num_assistant_tokens_schedule"
+        ]
+    },
+    "transformers.logging.get_logger": {
+        "Matcher": "TRFMGetLoggerMatcher",
+        "args_list": [
+            "name"
+        ]
+    },
+    "transformers.modeling_outputs.BaseModelOutputWithPast": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "last_hidden_state",
+            "past_key_values",
+            "hidden_states",
+            "attentions"
+        ],
+        "paddle_api": "paddlenlp.transformers.model_outputs.BaseModelOutputWithPast"
+    },
+    "transformers.modeling_outputs.CausalLMOutputWithPast": {
+        "Matcher": "GenericMatcher",
+        "args_list": [
+            "loss",
+            "logits",
+            "past_key_values",
+            "hidden_states",
+            "attentions"
+        ],
+        "paddle_api": "paddlenlp.transformers.model_outputs.CausalLMOutputWithPast"
     }
 }
```

## paconvert/api_matcher.py

```diff
@@ -21,14 +21,40 @@
 
 import astor
 
 from paconvert.base import BaseMatcher
 from paconvert.transformer.custom_op_transformer import CPP_EXTENSION_LIST  # noqa: F401
 from paconvert.utils import get_unique_name, process_reduce_and_size_average
 
+TypePromoteFunc = textwrap.dedent(
+    """
+    def TypePromote(x, y):
+        TYPE_PROMOTE_DICT ={
+            'INT16FP16':'float16',
+            'INT16FP32':'float32',
+            'INT16FP64':'float64',
+
+            'INT32FP16':'float32',
+            'INT32FP32':'float32',
+            'INT32FP64':'float64',
+
+            'INT64FP16':'float64',
+            'INT64FP32':'float64',
+            'INT64FP64':'float64',
+        }
+        if x.dtype.name + y.dtype.name in TYPE_PROMOTE_DICT:
+            promote_type = TYPE_PROMOTE_DICT[x.dtype.name + y.dtype.name]
+        elif y.dtype.name + x.dtype.name in TYPE_PROMOTE_DICT:
+            promote_type = TYPE_PROMOTE_DICT[y.dtype.name + x.dtype.name]
+        else:
+            return x,y
+        return x.astype(promote_type),y.astype(promote_type)
+    """
+)
+
 
 class GenericMatcher(BaseMatcher):
     def get_paddle_api(self):
         assert "paddle_api" in self.api_mapping
         if self.paddle_api:
             return self.paddle_api
         return self.api_mapping["paddle_api"]
@@ -165,14 +191,112 @@
     def get_paddle_nodes(self, args, kwargs):
         return "delete"
 
     def get_paddle_class_nodes(self, func, args, kwargs):
         return "delete"
 
 
+class FSInitializeModelParallelMatcher(BaseMatcher):
+    def generate_code(self, kwargs):
+        if "pipeline_length" not in kwargs:
+            kwargs["pipeline_length"] = 1
+
+        model_parallel_size = get_unique_name("model_parallel_size")
+        data_parallel_size = get_unique_name("data_parallel_size")
+        strategy = get_unique_name("strategy")
+
+        API_TEMPLATE = textwrap.dedent(
+            """
+            {} = int(min(paddle.distributed.get_world_size(),{}))
+            {} = int(paddle.distributed.get_world_size()/ ({} * {}))
+            {} = paddle.distributed.fleet.DistributedStrategy()
+            {}.hybrid_configs = dict(dp_degree={}, mp_degree={}, pp_degree={})
+            paddle.distributed.fleet.init(is_collective=True, strategy={})
+            """
+        )
+        code = API_TEMPLATE.format(
+            model_parallel_size,
+            kwargs["model_parallel_size_"],
+            data_parallel_size,
+            model_parallel_size,
+            kwargs["pipeline_length"],
+            strategy,
+            strategy,
+            data_parallel_size,
+            model_parallel_size,
+            kwargs["pipeline_length"],
+            strategy,
+        )
+        return code
+
+
+class FSModelParallelIsInitializedMatcher(BaseMatcher):
+    def generate_code(self, kwargs):
+        code = (
+            "paddle.distributed.fleet.base.topology._HYBRID_PARALLEL_GROUP is not None"
+        )
+        return code
+
+
+# TODO: why use Constant(0) ？When using constant initialization,
+# regardless of whether it is initialized to 0, 0.01, or 1,
+# there is no difference in the generated results. But when using
+# random initialization, the generation effect of the model is
+# semantically inferior. The reasons behind this phenomenon
+# require further analysis.
+
+# NOTE: The difference between ParallelEmbedding and VocaParallelEmbedding
+# is the direction of segmentation. This mapping is not equivalent and
+# requires additional consideration when converting its parameters.
+class FSParallelEmbeddingMatcher(BaseMatcher):
+    def generate_code(self, kwargs):
+        code = "paddle.distributed.fleet.meta_parallel.\
+                VocabParallelEmbedding(num_embeddings={},\
+                embedding_dim={},weight_attr=paddle.nn.initializer.Constant(0))".format(
+            kwargs["num_embeddings"], kwargs["embedding_dim"]
+        )
+        return code
+
+
+class InferenceModeMatcher(BaseMatcher):
+    def generate_aux_code(self):
+        CODE_TEMPLATE = textwrap.dedent(
+            """
+            def empty_decorator(func):
+                return func
+            """
+        )
+        return CODE_TEMPLATE
+
+    def generate_code(self, kwargs):
+        if "mode" in kwargs:
+            if kwargs["mode"] == "(False)":
+                self.write_aux_code()
+                code = "paddle_aux.empty_decorator"
+            else:
+                code = "paddle.no_grad()"
+        else:
+            code = "paddle.no_grad()"
+        return code
+
+
+class AtleastMatcher(BaseMatcher):
+    def get_paddle_nodes(self, args, kwargs):
+        new_args = self.parse_args(args)
+        if new_args[0][0] == "(" and new_args[0][-1] == ")":
+            new_args[0] = new_args[0][1:-1]
+        if new_args[0][0] == "[" and new_args[0][-1] == "]":
+            new_args[0] = new_args[0][1:-1]
+        new_kwargs = self.parse_kwargs(kwargs)
+        code = "{}({})".format(
+            self.get_paddle_api(), self.args_and_kwargs_to_str(new_args, new_kwargs)
+        )
+        return ast.parse(code).body
+
+
 class UnchangeMatcher(BaseMatcher):
     def get_paddle_class_attribute_nodes(self, node):
         return "unchange"
 
     def get_paddle_nodes(self, args, kwargs):
         new_args = self.parse_args(args)
         new_kwargs = self.parse_kwargs(kwargs)
@@ -312,14 +436,34 @@
         return CODE_TEMPLATE
 
     def generate_code(self, kwargs):
         self.write_aux_code()
         return "unchange"
 
 
+class FunctionalPadMatcher(BaseMatcher):
+    def generate_aux_code(self):
+        CODE_TEMPLATE = textwrap.dedent(
+            """
+            def _FUNCTIONAL_PAD(x, pad, mode='constant', value=0.0, data_format='NCHW'):
+                if len(x.shape) * 2 == len(pad) and mode == "constant":
+                    pad = paddle.to_tensor(pad, dtype="int32").reshape((-1, 2)).flip([0]).flatten().tolist()
+                return paddle.nn.functional.pad(x, pad, mode, value, data_format)
+            """
+        )
+        return CODE_TEMPLATE
+
+    def generate_code(self, kwargs):
+        self.write_aux_code()
+        if "input" in kwargs:
+            kwargs["x"] = kwargs.pop("input")
+        code = "paddle_aux._FUNCTIONAL_PAD({})".format(self.kwargs_to_str(kwargs))
+        return code
+
+
 class TensorSubtractMatcher(BaseMatcher):
     def generate_aux_code(self):
         CODE_TEMPLATE = textwrap.dedent(
             """
             def sub(self, *args, **kwargs):
                 if 'other' in kwargs:
                     y = kwargs['other']
@@ -421,32 +565,102 @@
     def generate_code(self, kwargs):
         API_TEMPLATE = textwrap.dedent(
             """
             x = {}
             {} = list(range(x.ndim))
             {}[{}] = {}
             {}[{}] = {}
-            paddle.transpose(x=x, perm={})
+            {}(x=x, perm={})
             """
         )
         perm = get_unique_name("perm")
         code = API_TEMPLATE.format(
             kwargs["input"],
             perm,
             perm,
             kwargs["dim0"],
             kwargs["dim1"],
             perm,
             kwargs["dim1"],
             kwargs["dim0"],
+            self.get_paddle_api(),
             perm,
         )
         return code
 
 
+class BroadcastTensorsMatcher(BaseMatcher):
+    def get_paddle_nodes(self, args, kwargs):
+        if len(args) == 1 and isinstance(args[0], ast.Starred):
+            star_var = astor.to_source(args[0].value).strip("\n")
+            code = "{}({})".format(self.get_paddle_api(), star_var)
+        else:
+            new_args = self.parse_args(args)
+            code = "{}([{}])".format(self.get_paddle_api(), ",".join(new_args))
+        return ast.parse(code).body
+
+
+class BroadcastShapesMatcher(BaseMatcher):
+    def get_paddle_nodes(self, args, kwargs):
+        if len(args) == 1 and isinstance(args[0], ast.Starred):
+            return None
+        new_args = self.parse_args(args)
+        code = new_args[0]
+        # Call the paddle.broadcast_shape multiple times
+        for i in range(1, len(new_args)):
+            code = "{}({}, {})".format(self.get_paddle_api(), code, new_args[i])
+        return ast.parse(code).body
+
+
+class IInfoMatcher(BaseMatcher):
+    def generate_aux_code(self):
+        CODE_TEMPLATE = textwrap.dedent(
+            """
+            def _STR_2_PADDLE_DTYPE(type):
+                type_map = {
+                        "int32": paddle.int32,
+                        "uint8": paddle.uint8,
+                        "int8": paddle.int8,
+                        "int16": paddle.int16,
+                        "int32": paddle.int32,
+                        "int64": paddle.int64,
+                        "float16": paddle.float16,
+                        "float32": paddle.float32,
+                        "float64": paddle.float64,
+                        "bfloat16": paddle.bfloat16,
+                        }
+                return type_map.get(type)
+            """
+        )
+        return CODE_TEMPLATE
+
+    def generate_code(self, kwargs):
+        self.write_aux_code()
+        type = kwargs.pop("type")
+        return "{}(paddle_aux._STR_2_PADDLE_DTYPE({}))".format(
+            self.get_paddle_api(), type
+        )
+
+
+class SmoothL1LossMatcher(BaseMatcher):
+    def get_paddle_nodes(self, args, kwargs):
+        kwargs = self.parse_kwargs(kwargs)
+        beta = kwargs.get("beta", None)
+        if beta is not None:
+            beta = beta.replace("(", "").replace(")", "")
+            try:
+                beta = float(beta)
+                if float(beta) != 1.0:
+                    return None
+            except:
+                return None
+        code = SizeAverageMatcher.generate_code(self, kwargs)
+        return ast.parse(code).body
+
+
 class SwapAxesMatcher(BaseMatcher):
     def generate_code(self, kwargs):
         if "input" not in kwargs:
             kwargs["input"] = self.paddleClass
 
         if "dim0" in kwargs:
             kwargs["axis0"] = kwargs.pop("dim0")
@@ -794,15 +1008,71 @@
 
         code = API_TEMPLATE.format(
             self.get_paddle_api(), self.kwargs_to_str(new_kwargs)
         )
         return code.strip("\n")
 
 
+class FAFlashAttnFuncMatcher(BaseMatcher):
+    def generate_code(self, kwargs):
+        API_TEMPLATE = textwrap.dedent(
+            """
+            {}({})
+            """
+        )
+        if "softmax_scale" in kwargs:
+            Assert_TEMPLATE = textwrap.dedent(
+                """
+            paddle.utils.try_import("math")
+            assert {} is None or {} is math.sqrt({}.shape[-1]),"Fault: Not support parameter scale"
+            """
+            )
+            return Assert_TEMPLATE.format(
+                kwargs["softmax_scale"],
+                kwargs.pop("softmax_scale"),
+                kwargs["query"],
+            ) + API_TEMPLATE.format(self.get_paddle_api(), self.kwargs_to_str(kwargs))
+        return API_TEMPLATE.format(self.get_paddle_api(), self.kwargs_to_str(kwargs))
+
+
+class TRFMGetLoggerMatcher(BaseMatcher):
+    def generate_code(self, kwargs):
+        API_TEMPLATE = textwrap.dedent(
+            """
+            paddle.utils.try_import("logging")
+            logging.getLogger({})
+            """
+        )
+        return API_TEMPLATE.format(self.kwargs_to_str(kwargs))
+
+
+class TRFMGenerationConfigMatcher(BaseMatcher):
+    def generate_code(self, kwargs):
+        greedy_search_flag = False
+        num_beans_value = 1
+        if "do_sample" in kwargs:
+            do_sample_value = kwargs["do_sample"]
+            if do_sample_value != '"""False"""':
+                greedy_search_flag = True
+        if greedy_search_flag and "num_beans" in kwargs:
+            num_beans_value = kwargs["num_beans"]
+        if greedy_search_flag:
+            greedy_search = f'"greedy_search" if {do_sample_value} else "sampling" if {num_beans_value} == 1 else "beam_search"'
+            kwargs["greedy_search"] = greedy_search
+        return f"{self.get_paddle_api()}({self.kwargs_to_str(kwargs)})"
+
+
 class TensorMatcher(BaseMatcher):
+    def get_paddle_api(self):
+        if isinstance(
+            self.transformer.parent_node, (ast.Tuple, ast.arg, ast.Subscript)
+        ):
+            return "paddle.Tensor"
+        return super().get_paddle_api()
+
     def get_paddle_nodes(self, args, kwargs):
         kwargs = self.parse_kwargs(kwargs)
         if kwargs is None:
             return None
 
         if "size" in kwargs:
             shape = kwargs.pop("size")
@@ -967,15 +1237,15 @@
 
 
 class TensorSizeMatcher(BaseMatcher):
     def generate_code(self, kwargs):
         if "dim" in kwargs:
             code = "{}.shape[{}]".format(self.paddleClass, kwargs["dim"])
         else:
-            code = "{}.shape".format(self.paddleClass)
+            code = "tuple({}.shape)".format(self.paddleClass)
         return code
 
 
 class TensorPermuteMatcher(BaseMatcher):
     def get_paddle_class_nodes(self, func, args, kwargs):
         self.parse_func(func)
         kwargs = self.parse_kwargs(kwargs)
@@ -1113,18 +1383,41 @@
     def generate_code(self, kwargs):
         code = "{}.astype(dtype='complex128')".format(self.paddleClass)
         return code
 
 
 class TensorTypeAsMatcher(BaseMatcher):
     def generate_code(self, kwargs):
-        code = f"{self.paddleClass}.astype(dtype={kwargs['tensor']}.dtype)"
+        code = f"{self.paddleClass}.astype(dtype={kwargs['other']}.dtype)"
         return code
 
 
+class TensorTileMatcher(BaseMatcher):
+    def get_paddle_class_nodes(self, func, args, kwargs):
+        self.parse_func(func)
+        kwargs = self.parse_kwargs(kwargs)
+        if kwargs is None:
+            return None
+
+        if "dims" in kwargs:
+            kwargs = {"repeat_times": kwargs.pop("dims")}
+        else:
+            if len(args) > 1 or (len(args) == 1 and isinstance(args[0], ast.Constant)):
+                perm = self.parse_args(args)
+            elif isinstance(args[0], ast.Starred):
+                perm = astor.to_source(args[0].value).strip("\n")
+            else:
+                perm = self.parse_args(args)[0]
+
+            kwargs = {"repeat_times": str(perm).replace("'", "")}
+
+        code = "{}.tile({})".format(self.paddleClass, self.kwargs_to_str(kwargs))
+        return ast.parse(code).body
+
+
 class TensorNew_Matcher(BaseMatcher):
     def get_paddle_class_nodes(self, func, args, kwargs):
         self.parse_func(func)
         kwargs = self.parse_kwargs(kwargs)
         if kwargs is None:
             return None
         if "size" in kwargs:
@@ -1241,15 +1534,16 @@
 
 
 class TorchTensorMatcher(BaseMatcher):
     def generate_code(self, kwargs):
 
         if "device" in kwargs:
             kwargs["place"] = kwargs.pop("device")
-
+            if kwargs["place"] == '"""cuda"""':
+                kwargs["place"] = '"""gpu"""'
         if "requires_grad" in kwargs:
             kwargs["stop_gradient"] = "not " + kwargs.pop("requires_grad").strip("()")
 
         if "pin_memory" in kwargs and kwargs.pop("pin_memory") == "(True)":
             kwargs["place"] = "paddle.CUDAPinnedPlace()"
 
         code = "{}({})".format(self.get_paddle_api(), self.kwargs_to_str(kwargs))
@@ -1265,30 +1559,14 @@
 
 class CudnnIsAvailableMatcher(BaseMatcher):
     def generate_code(self, kwargs):
         code = "bool(paddle.device.get_cudnn_version())"
         return code
 
 
-class BatchNormMatcher(BaseMatcher):
-    def generate_code(self, kwargs):
-        if "momentum" in kwargs:
-            kwargs["momentum"] = f"1 - {kwargs.pop('momentum')}"
-
-        if "affine" in kwargs:
-            kwargs["weight_attr"] = f"None if {kwargs['affine']} else False"
-            kwargs["bias_attr"] = f"None if {kwargs.pop('affine')} else False"
-
-        if "track_running_stats" in kwargs:
-            kwargs["use_global_stats"] = f"not {kwargs.pop('track_running_stats')}"
-
-        code = GenericMatcher.generate_code(self, kwargs)
-        return code
-
-
 class SplitMatcher(BaseMatcher):
     def generate_aux_code(self):
         CODE_TEMPLATE = textwrap.dedent(
             """
             def split(x, num_or_sections, axis=0):
                 if isinstance(num_or_sections, int):
                     return paddle.split(x, x.shape[axis]//num_or_sections, axis)
@@ -1376,18 +1654,20 @@
         return ast.parse(code).body
 
 
 class TensorCopy_Matcher(BaseMatcher):
     def generate_code(self, kwargs):
         API_TEMPLATE = textwrap.dedent(
             """
-            paddle.assign({}, output={})
+            {}({}, output={})
             """
         )
-        code = API_TEMPLATE.format(kwargs["src"], self.paddleClass)
+        code = API_TEMPLATE.format(
+            self.get_paddle_api(), kwargs["other"], self.paddleClass
+        )
         return code
 
 
 class TensorMaskedFillMatcher(BaseMatcher):
     def generate_code(self, kwargs):
         API_TEMPLATE = textwrap.dedent(
             """
@@ -1468,15 +1748,19 @@
 
 
 class TensorTypeMatcher(BaseMatcher):
     def generate_code(self, kwargs):
         if len(kwargs) == 0:
             code = f"str({self.paddleClass}.dtype)"
         else:
-            code = f"{self.paddleClass}.astype({kwargs['dtype']})"
+            # For torch.nn.Module.type, torch.nn.Module.type use torch.Tensor.type
+            if "dst_type" in kwargs:
+                code = f"{self.paddleClass}.astype({kwargs['dst_type']})"
+            else:
+                code = f"{self.paddleClass}.astype({kwargs['dtype']})"
         return code
 
 
 class TensorIsCudaMatcher(BaseMatcher):
     def get_paddle_class_attribute_nodes(self, node):
         self.parse_func(node)
         code = "'gpu' in str({}.place)".format(self.paddleClass)
@@ -1525,22 +1809,15 @@
 
             for k in pro_kwargs.keys():
                 if k not in kwargs.keys():
                     kwargs[k] = pro_kwargs[k]
 
             kwargs.pop("profile")
 
-        kwargs = self.set_paddle_default_kwargs(kwargs)
-        API_TEMPLATE = textwrap.dedent(
-            """
-            paddle.set_printoptions({})
-            """
-        )
-        code = API_TEMPLATE.format(self.kwargs_to_str(kwargs))
-        return code
+        return GenericMatcher.generate_code(self, kwargs)
 
 
 class RandLikeMatcher(BaseMatcher):
     def generate_code(self, kwargs):
         stop_gradient_v = None
         if "requires_grad" in kwargs:
             stop_gradient_v = "not " + kwargs["requires_grad"]
@@ -1635,25 +1912,26 @@
     def generate_code(self, kwargs):
         if "input" not in kwargs:
             kwargs["input"] = self.paddleClass
 
         API_TEMPLATE = textwrap.dedent(
             """
             {} = ({}.shape[{}] + {}) if {} < 0 else {}
-            paddle.slice({}, [{}], [{}], [{} + {}])
+            {}({}, [{}], [{}], [{} + {}])
             """
         )
         start = get_unique_name("start")
         code = API_TEMPLATE.format(
             start,
             kwargs["input"],
             kwargs["dim"],
             kwargs["start"],
             kwargs["start"],
             kwargs["start"],
+            self.get_paddle_api(),
             kwargs["input"],
             kwargs["dim"],
             start,
             start,
             kwargs["length"],
         )
         return code
@@ -1767,127 +2045,21 @@
             """
         )
         code = API_TEMPLATE.format(kwargs["input"])
 
         return code
 
 
-class VStackMatcher(BaseMatcher):
-    def generate_code(self, kwargs):
-        if "out" in kwargs and kwargs["out"] != "None":
-            API_TEMPLATE = textwrap.dedent(
-                """
-                if {}[0].ndim == 1:
-                    {} = paddle.stack({})
-                else:
-                    {} = paddle.concat({})
-                paddle.assign({}, output={})
-                """
-            )
-            out = get_unique_name("out")
-            code = API_TEMPLATE.format(
-                kwargs["tensors"],
-                out,
-                kwargs["tensors"],
-                out,
-                kwargs["tensors"],
-                out,
-                kwargs["out"],
-            )
-        else:
-            API_TEMPLATE = textwrap.dedent(
-                """
-                if {}[0].ndim == 1:
-                    {} = paddle.stack({})
-                else:
-                    {} = paddle.concat({})
-                {}
-                """
-            )
-            out = get_unique_name("out")
-            code = API_TEMPLATE.format(
-                kwargs["tensors"], out, kwargs["tensors"], out, kwargs["tensors"], out
-            )
-
-        return code
-
-
-class HStackMatcher(BaseMatcher):
-    def generate_code(self, kwargs):
-        if "out" in kwargs and kwargs["out"] != "None":
-            API_TEMPLATE = textwrap.dedent(
-                """
-                {} = 0 if {}[0].ndim == 1 else 1
-                paddle.assign(paddle.concat({}, axis={}), output={})
-                """
-            )
-            axis = get_unique_name("axis")
-            code = API_TEMPLATE.format(
-                axis, kwargs["tensors"], kwargs["tensors"], axis, kwargs["out"]
-            )
-        else:
-            API_TEMPLATE = textwrap.dedent(
-                """
-                {} = 0 if {}[0].ndim == 1 else 1
-                paddle.concat({}, axis={})
-                """
-            )
-            axis = get_unique_name("axis")
-            code = API_TEMPLATE.format(axis, kwargs["tensors"], kwargs["tensors"], axis)
-
-        return code
-
-
-class ColumnStackMatcher(BaseMatcher):
-    def generate_code(self, kwargs):
-        if "out" in kwargs and kwargs["out"] != "None":
-            API_TEMPLATE = textwrap.dedent(
-                """
-                if {}[0].ndim == 1:
-                    {} = paddle.stack({}, axis=1)
-                else:
-                    {} = paddle.concat({}, axis=1)
-                paddle.assign({}, output={})
-                """
-            )
-            out = get_unique_name("out")
-            code = API_TEMPLATE.format(
-                kwargs["tensors"],
-                out,
-                kwargs["tensors"],
-                out,
-                kwargs["tensors"],
-                out,
-                kwargs["out"],
-            )
-        else:
-            API_TEMPLATE = textwrap.dedent(
-                """
-                if {}[0].ndim == 1:
-                    {} = paddle.stack({}, axis=1)
-                else:
-                    {} = paddle.concat({}, axis=1)
-                {}
-                """
-            )
-            out = get_unique_name("out")
-            code = API_TEMPLATE.format(
-                kwargs["tensors"], out, kwargs["tensors"], out, kwargs["tensors"], out
-            )
-
-        return code
-
-
 # will implenment by aux_code
 class TensorIndexCopyMatcher(BaseMatcher):
     def generate_code(self, kwargs):
 
         if kwargs["dim"][1:-1].isdigit() and int(kwargs["dim"][1:-1]) == 0:
             code = "{}.scatter_({}, {})".format(
-                self.paddleClass, kwargs["index"], kwargs["tensor"]
+                self.paddleClass, kwargs["index"], kwargs["source"]
             )
             return code
 
         API_TEMPLATE = textwrap.dedent(
             """
             times, temp_shape, temp_index = paddle.prod(paddle.to_tensor({}.shape[:{}])), {}.shape, {}
             {}, new_t = {}.reshape([-1] + temp_shape[{}+1:]), {}.reshape([-1] + temp_shape[{}+1:])
@@ -1901,15 +2073,15 @@
             self.paddleClass,
             kwargs["dim"],
             self.paddleClass,
             kwargs["index"],
             self.paddleClass,
             self.paddleClass,
             kwargs["dim"],
-            kwargs["tensor"],
+            kwargs["source"],
             kwargs["dim"],
             self.paddleClass,
         )
 
         return code
 
 
@@ -1978,21 +2150,19 @@
                 kwargs["dim"],
                 kwargs["input"],
             )
 
         return code
 
 
-class InstanceNormMatcher(BaseMatcher):
+class ReverseMomentumMatcher(BaseMatcher):
     def generate_code(self, kwargs):
         if "momentum" in kwargs:
-            momentum = kwargs["momentum"]
-        else:
-            momentum = 0.1
-        kwargs["momentum"] = f"1-{momentum}"
+            kwargs["momentum"] = f"1 - {kwargs.pop('momentum')}"
+
         return GenericMatcher.generate_code(self, kwargs)
 
 
 class GeneratorMatcher(BaseMatcher):
     def generate_code(self, kwargs):
 
         if not kwargs:
@@ -2024,77 +2194,37 @@
             return None
         return GenericMatcher.generate_code(self, kwargs)
 
 
 class SizeMatcher(BaseMatcher):
     def get_paddle_nodes(self, args, kwargs):
         if len(args) == 0:
-            code = "list([])"
+            code = "()"
         else:
-            code = "list({})".format(astor.to_source(args[0]).strip("\n"))
+            code = "tuple({})".format(astor.to_source(args[0]).strip("\n"))
 
         return ast.parse(code).body
 
 
 class TensorToMatcher(BaseMatcher):
-    def generate_aux_code(self):
-        CODE_TEMPLATE = textwrap.dedent(
-            """
-            def to(self, *args, **kwargs):
-                args_list = ["x", "y", "non_blocking", "copy", "memory_format"]
-                new_kwargs = {}
-                for i, node in enumerate(args):
-                    k = args_list[i]
-                    new_kwargs[k] = node
-                for node in kwargs:
-                    v = kwargs[node]
-                    new_kwargs[node] = v
-                kwargs = new_kwargs
-                if not kwargs:
-                    return self
-                elif "tensor" in kwargs:
-                    return paddle.cast(self, "{}.dtype".format(kwargs["tensor"]))
-                elif "dtype" in kwargs:
-                    return paddle.cast(self, "{}".format(kwargs["dtype"]))
-                elif "device" in kwargs and "dtype" not in kwargs:
-                    return self
-                elif kwargs:
-                    if "y" not in kwargs and "x" in kwargs:
-                        if isinstance(kwargs["x"], paddle.dtype):
-                            dtype = kwargs["x"]
-                        elif isinstance(kwargs["x"], str) and kwargs["x"] not in ['cpu', 'cuda', 'ipu', 'xpu']:
-                            dtype = kwargs["x"]
-                        elif isinstance(kwargs["x"], paddle.Tensor):
-                            dtype = kwargs["x"].dtype
-                        else:
-                            dtype = self.dtype
-                        return paddle.cast(self, dtype)
-
-                    elif "y" in kwargs and "x" in kwargs:
-                        if isinstance(kwargs["x"], paddle.dtype):
-                            dtype = kwargs["x"]
-                        elif isinstance(kwargs["x"], str):
-                            if x not in ['cpu', 'cuda', 'ipu', 'xpu']:
-                                dtype = kwargs["x"]
-                            else:
-                                dtype = kwargs["y"] if isinstance(kwargs["y"], str) else self.dtype
-                        else:
-                            dtype = kwargs["x"]
-                        return paddle.cast(self, dtype)
-                    else:
-                        return self
-
-            setattr(paddle.Tensor, 'to', to)
-            """
+    def get_paddle_nodes(self, args, kwargs):
+        new_args = self.parse_args(args)
+        new_kwargs = self.parse_kwargs(kwargs)
+        if new_kwargs is None:
+            return None
+        if "copy" in new_kwargs:
+            new_kwargs.pop("copy")
+        if "memory_format" in new_kwargs:
+            new_kwargs.pop("memory_format")
+        if "non_blocking" in new_kwargs:
+            new_kwargs["blocking"] = "not " + new_kwargs.pop("non_blocking").strip("()")
+        code = "{}.to({})".format(
+            self.paddleClass, self.args_and_kwargs_to_str(new_args, new_kwargs)
         )
-        return CODE_TEMPLATE
-
-    def get_paddle_class_nodes(self, func, args, kwargs):
-        self.write_aux_code()
-        return "unchange"
+        return ast.parse(code).body
 
 
 class TensorRequiresGradMatcher(BaseMatcher):
     def get_paddle_class_attribute_nodes(self, node):
         self.parse_func(node)
         code = "not {}.stop_gradient".format(self.paddleClass)
         return ast.parse(code).body
@@ -2215,36 +2345,22 @@
                 """
             )
             code = API_TEMPLATE.format(exp_v, kwargs["input"], exp_v, exp_v)
 
         return code
 
 
-class FModMatcher(BaseMatcher):
+class Num2TensorBinaryConvertTypeMatcher(BaseMatcher):
     def generate_code(self, kwargs):
-        if "out" in kwargs and kwargs["out"] != "None":
-            API_TEMPLATE = textwrap.dedent(
-                """
-                paddle.assign(paddle.mod({}, paddle.to_tensor({}, dtype={}.dtype)), output={})
-                """
-            )
-            code = API_TEMPLATE.format(
-                kwargs["input"], kwargs["other"], kwargs["input"], kwargs["out"]
-            )
-        else:
-            API_TEMPLATE = textwrap.dedent(
-                """
-                paddle.mod({}, paddle.to_tensor({}, dtype={}.dtype))
-                """
-            )
-            code = API_TEMPLATE.format(
-                kwargs["input"], kwargs["other"], kwargs["input"]
-            )
+        if "other" in kwargs:
+            kwargs[
+                "y"
+            ] = f"paddle.to_tensor({kwargs.pop('other')}, dtype={kwargs['input']}.dtype)"
 
-        return code
+        return GenericMatcher.generate_code(self, kwargs)
 
 
 class LdExpMatcher(BaseMatcher):
     def generate_code(self, kwargs):
         if "input" not in kwargs:
             kwargs["input"] = self.paddleClass
 
@@ -2606,15 +2722,15 @@
 
 class AvgPoolMatcher(BaseMatcher):
     def generate_code(self, kwargs):
         if "input" in kwargs:
             kwargs["x"] = kwargs.pop("input")
 
         if "count_include_pad" in kwargs:
-            kwargs["exclusive"] = "not" + kwargs.pop("count_include_pad")
+            kwargs["exclusive"] = "not " + kwargs.pop("count_include_pad")
         else:
             kwargs["exclusive"] = "False"
         API_TEMPLATE = textwrap.dedent(
             """
             {}({})
             """
         )
@@ -2629,48 +2745,14 @@
             return None
 
         kwargs["input"] = f"-{kwargs['input']}"
 
         return GenericMatcher.generate_code(self, kwargs)
 
 
-class FBatchNormMatcher(BaseMatcher):
-    def generate_code(self, kwargs):
-        kwargs["x"] = kwargs.pop("input")
-        if "eps" in kwargs:
-            kwargs["epsilon"] = kwargs.pop("eps")
-        if "momentum" in kwargs:
-            kwargs["momentum"] = "1 - " + kwargs["momentum"]
-
-        API_TEMPLATE = textwrap.dedent(
-            """
-            {}({})
-            """
-        )
-        code = API_TEMPLATE.format(self.get_paddle_api(), self.kwargs_to_str(kwargs))
-
-        return code
-
-
-class FInstanceNormMatcher(BaseMatcher):
-    def generate_code(self, kwargs):
-        kwargs["x"] = kwargs.pop("input")
-        if "momentum" in kwargs:
-            kwargs["momentum"] = "1 - " + kwargs["momentum"]
-
-        API_TEMPLATE = textwrap.dedent(
-            """
-            {}({})
-            """
-        )
-        code = API_TEMPLATE.format(self.get_paddle_api(), self.kwargs_to_str(kwargs))
-
-        return code
-
-
 class MSortMatcher(BaseMatcher):
     def generate_code(self, kwargs):
         if "input" not in kwargs:
             kwargs["input"] = self.paddleClass
 
         if "out" in kwargs and kwargs["out"] != "None":
             API_TEMPLATE = textwrap.dedent(
@@ -2697,15 +2779,15 @@
 
 
 class TriangularSolveMatcher(BaseMatcher):
     def generate_code(self, kwargs):
         out_v = kwargs.pop("out") if "out" in kwargs else None
         new_kwargs = {}
         new_kwargs["x"] = kwargs.pop("A")
-        new_kwargs["y"] = kwargs.pop("b")
+        new_kwargs["y"] = kwargs.pop("input")
         new_kwargs.update(kwargs)
 
         if out_v:
             API_TEMPLATE = textwrap.dedent(
                 """
                 paddle.assign(paddle.linalg.triangular_solve({}), {}[0]), paddle.assign({}, {}[1])
                 """
@@ -2720,39 +2802,30 @@
                 """
             )
             code = API_TEMPLATE.format(self.kwargs_to_str(new_kwargs), new_kwargs["x"])
 
         return code
 
 
-class IndexAddMatcher(BaseMatcher):
+class TensorTriangularSolveMatcher(BaseMatcher):
     def generate_code(self, kwargs):
-        if "input" not in kwargs:
-            kwargs["input"] = self.paddleClass
+        kwargs["input"] = self.paddleClass
+        return TriangularSolveMatcher.generate_code(self, kwargs)
 
-        if "alpha" not in kwargs:
-            kwargs["alpha"] = 1.0
 
-        API_TEMPLATE = textwrap.dedent(
-            """
-            {}({}, index={}, axis={}, value={} * {})
-            """
-        )
-        code = API_TEMPLATE.format(
-            self.get_paddle_api(),
-            kwargs["input"],
-            kwargs["index"],
-            kwargs["dim"],
-            kwargs["alpha"],
-            kwargs["source"],
-        )
+class IndexAddMatcher(BaseMatcher):
+    def generate_code(self, kwargs):
+        if "alpha" not in kwargs:
+            kwargs["value"] = kwargs.pop("source")
+        else:
+            kwargs["value"] = "{} * {}".format(
+                kwargs.pop("source"), kwargs.pop("alpha")
+            )
 
-        if "out" in kwargs and kwargs["out"] != "None":
-            code = "paddle.assign({}, output={})".format(code, kwargs["out"])
-        return code
+        return GenericMatcher.generate_code(self, kwargs)
 
 
 class AMinMaxMatcher(BaseMatcher):
     def generate_code(self, kwargs):
         if "input" not in kwargs:
             kwargs["input"] = self.paddleClass
 
@@ -2913,30 +2986,19 @@
             code = code + " @ {}".format(arg)
         if "out" in new_kwargs and new_kwargs["out"] != "None":
             code = "paddle.assign({}, output={})".format(code, new_kwargs["out"])
 
         return ast.parse(code).body
 
 
-class HypotMatcher(BaseMatcher):
-    def generate_code(self, kwargs):
-        if "input" not in kwargs:
-            kwargs["input"] = self.paddleClass
-
-        API_TEMPLATE = textwrap.dedent(
-            """
-            paddle.pow({}**2 + {}**2, 1/2)
-            """
-        )
-        code = API_TEMPLATE.format(kwargs["input"], kwargs["other"])
-
-        if "out" in kwargs and kwargs["out"] != "None":
-            code = "paddle.assign({}, output={})".format(code, kwargs["out"])
-
-        return code
+class TensorShapeMatcher(BaseMatcher):
+    def get_paddle_class_attribute_nodes(self, node):
+        self.parse_func(node)
+        code = "tuple({}.shape)".format(self.paddleClass)
+        return ast.parse(code).body
 
 
 class TensorReshapeMatcher(BaseMatcher):
     def generate_aux_code(self):
         CODE_TEMPLATE = textwrap.dedent(
             """
             def reshape(self, *args, **kwargs):
@@ -3019,22 +3081,15 @@
             kwargs["right"] = f"{kwargs.pop('side')} == 'right'"
 
         if "sorter" in kwargs and kwargs["sorter"] != "None":
             kwargs[
                 "sorted_sequence"
             ] = f"{kwargs['sorted_sequence']}.take_along_axis(axis=-1, indices={kwargs.pop('sorter')})"
 
-        code = "paddle.searchsorted({})".format(self.kwargs_to_str(kwargs))
-        if "out" in kwargs and kwargs["out"] != "None":
-            out_v = kwargs.pop("out")
-            code = "paddle.assign(paddle.searchsorted({}), output={})".format(
-                self.kwargs_to_str(kwargs), out_v
-            )
-
-        return code
+        return GenericMatcher.generate_code(self, kwargs)
 
 
 class SincMatcher(BaseMatcher):
     def generate_code(self, kwargs):
         if "input" not in kwargs:
             kwargs["input"] = self.paddleClass
 
@@ -3245,21 +3300,23 @@
 
         code = API_TEMPLATE.format(self.kwargs_to_str(kwargs))
         return code
 
 
 class DoubleAssignMatcher(BaseMatcher):
     def generate_code(self, kwargs):
-        kwargs_change = {}
-        if "kwargs_change" in self.api_mapping:
-            kwargs_change = self.api_mapping["kwargs_change"]
+        kwargs = self.set_paddle_default_kwargs(kwargs)
+        kwargs_change = self.api_mapping.get("kwargs_change", {})
 
         for k in kwargs_change:
             if k in kwargs:
-                kwargs[kwargs_change[k]] = kwargs.pop(k)
+                if kwargs[k]:
+                    kwargs[kwargs_change[k]] = kwargs.pop(k)
+                else:
+                    kwargs.pop(k)
 
         if "out" in kwargs:
             out_v = kwargs.pop("out")
             API_TEMPLATE = textwrap.dedent(
                 """
                 out1, out2 = {}({})
                 paddle.assign(out1, {}[0]), paddle.assign(out2, {}[1])
@@ -3273,17 +3330,15 @@
 
         return code
 
 
 class TripleAssignMatcher(BaseMatcher):
     def generate_code(self, kwargs):
         kwargs = self.set_paddle_default_kwargs(kwargs)
-        kwargs_change = {}
-        if "kwargs_change" in self.api_mapping:
-            kwargs_change = self.api_mapping["kwargs_change"]
+        kwargs_change = self.api_mapping.get("kwargs_change", {})
 
         for k in kwargs_change:
             if k in kwargs:
                 if kwargs_change[k]:
                     kwargs[kwargs_change[k]] = kwargs.pop(k)
                 else:
                     kwargs.pop(k)
@@ -3309,27 +3364,31 @@
     def generate_code(self, kwargs):
         if "input" not in kwargs:
             kwargs["input"] = self.paddleClass
 
         if "decimals" in kwargs:
             API_TEMPLATE = textwrap.dedent(
                 """
-                paddle.round((10**{}) * {}) / (10**{})
+                {}((10**{}) * {}) / (10**{})
                 """
             )
             code = API_TEMPLATE.format(
-                kwargs["decimals"], kwargs["input"], kwargs["decimals"]
+                self.get_paddle_api(),
+                kwargs["decimals"],
+                kwargs["input"],
+                kwargs["decimals"],
             )
         else:
             API_TEMPLATE = textwrap.dedent(
                 """
-                paddle.round({})
+                {}({})
                 """
             )
-            code = API_TEMPLATE.format(kwargs["input"])
+            code = API_TEMPLATE.format(self.get_paddle_api(), kwargs["input"])
+
         if "out" in kwargs and kwargs["out"] != "None":
             code = "paddle.assign({}, output={})".format(code, kwargs["out"])
 
         return code
 
 
 class RNNMatcher(BaseMatcher):
@@ -3447,39 +3506,14 @@
             out,
             requires_grad_v,
             out,
         )
         return code
 
 
-class Modules_BatchNormBaseMatcher(BaseMatcher):
-    def generate_code(self, kwargs):
-        if "momentum" in kwargs:
-            momentum = kwargs["momentum"]
-        else:
-            momentum = 0.1
-        kwargs["momentum"] = f"1-{momentum}"
-
-        if "affine" not in kwargs:
-            kwargs["weight_attr"] = None
-            kwargs["bias_attr"] = None
-        else:
-            kwargs[
-                "weight_attr"
-            ] = f"None if ({kwargs['affine']} is None or {kwargs['affine']}) else False"
-            kwargs[
-                "bias_attr"
-            ] = f"None if ({kwargs['affine']} is None or {kwargs['affine']}) else False"
-
-        if "track_running_stats" in kwargs:
-            kwargs["use_global_stats"] = kwargs.pop("track_running_stats")
-
-        return GenericMatcher.generate_code(self, kwargs)
-
-
 class TensorTakeMatcher(BaseMatcher):
     def generate_aux_code(self):
         CODE_TEMPLATE = textwrap.dedent(
             """
             def take(self, *args, **kwargs):
                 if args:
                     return paddle.take(self, *args)
@@ -3605,16 +3639,17 @@
 
 
 class WhereMatcher(BaseMatcher):
     def generate_code(self, kwargs):
         if len(kwargs) == 1:
             return None
         else:
-            code = "{}({})".format(self.get_paddle_api(), self.kwargs_to_str(kwargs))
-        return code
+            if "self" in kwargs:
+                kwargs["input"] = kwargs.pop("self")
+            return GenericMatcher.generate_code(self, kwargs)
 
 
 class UpsampleMatcher(BaseMatcher):
     def generate_code(self, kwargs):
         if "size" in kwargs and "," not in kwargs["size"]:
             return None
         return GenericMatcher.generate_code(self, kwargs)
@@ -4025,14 +4060,56 @@
                 self.get_paddle_api(),
                 self.kwargs_to_str(kwargs),
             )
 
         return code
 
 
+class SymeigMatcher(BaseMatcher):
+    def generate_aux_code(self):
+        CODE_TEMPLATE = textwrap.dedent(
+            """
+            def _CONVERT_SYMEIG(**kwargs):
+                out_v = kwargs.pop("out", None)
+                upper = kwargs.pop("upper", True)
+                UPLO = "U" if upper else "L"
+                eigenvectors = kwargs.pop("eigenvectors", False)
+                if not eigenvectors:
+                    result = (paddle.linalg.eigvalsh(kwargs["input"], UPLO=UPLO),
+                              paddle.to_tensor([], dtype=paddle.complex64))
+                else:
+                    result = paddle.linalg.eigh(kwargs["input"], UPLO=UPLO)
+                if out_v:
+                    result = paddle.assign(result[0], out_v[0]), paddle.assign(result[1], out_v[1])
+                return result
+            """
+        )
+        return CODE_TEMPLATE
+
+    def generate_code(self, kwargs):
+        self.write_aux_code()
+        if "input" not in kwargs:
+            kwargs["input"] = self.paddleClass
+        return "paddle_aux._CONVERT_SYMEIG({})".format(self.kwargs_to_str(kwargs))
+
+
+class FloatPowerMatcher(BaseMatcher):
+    def generate_code(self, kwargs):
+        return "{}.cast(paddle.float64).pow({})".format(
+            self.paddleClass, kwargs["exponent"]
+        )
+
+
+class FloatPowerInplaceMatcher(BaseMatcher):
+    def generate_code(self, kwargs):
+        return "{}.cast_(paddle.float64).pow_({})".format(
+            self.paddleClass, kwargs["exponent"]
+        )
+
+
 class ModuleGetSubMatcher(BaseMatcher):
     def generate_code(self, kwargs):
         code = 'getattr({}, "{}")'.format(
             self.paddleClass,
             kwargs["target"].strip('"'),
         )
         return code
@@ -4111,7 +4188,150 @@
 
         kwargs.pop("cmdclass")
         global CPP_EXTENSION_LIST
         CPP_EXTENSION_LIST.append(kwargs["name"].strip('"'))
         return ast.parse(
             "paddle.utils.cpp_extension.setup({})".format(self.kwargs_to_str(kwargs))
         )
+
+
+class Is_PinnedMatcher(BaseMatcher):
+    def generate_code(self, kwargs):
+
+        code = f"'pinned' in str({self.paddleClass}.place)"
+
+        return code
+
+
+class TensorCudaMatcher(BaseMatcher):
+    def generate_code(self, kwargs):
+        new_kwargs = {}
+        if "non_blocking" in kwargs:
+            new_kwargs["blocking"] = f"not {kwargs.pop('non_blocking')}"
+        else:
+            new_kwargs["blocking"] = "True"
+        new_kwargs.update(kwargs)
+        return GenericMatcher.generate_code(self, new_kwargs)
+
+
+class TensorViewMatcher(BaseMatcher):
+
+    # def generate_aux_code(self):
+    #     CODE_TEMPLATE = textwrap.dedent(
+    #         """
+    #         def view(self, *args, **kwargs):
+    #             if args:
+    #                 if len(args)==1 and isinstance(args[0], (tuple, list, str)):
+    #                     return paddle.view(self, args[0])
+    #                 else:
+    #                     return paddle.view(self, list(args))
+    #             elif kwargs:
+    #                 key = [k for k in kwargs.keys()]
+    #                 return paddle.view(self, shape_or_dtype = kwargs[key[0]])
+
+    #         setattr(paddle.Tensor, 'view', view)
+    #         """
+    #     )
+    #     return CODE_TEMPLATE
+    # def get_paddle_class_nodes(self, func, args, kwargs):
+    #     if kwargs:
+    #         if len(kwargs) == 1:
+    #             self.write_aux_code()
+    #             return "unchange"
+
+    #     if args:
+    #         if len(args) == 1:
+    #             if isinstance(args[0], (ast.Tuple, ast.List)):
+    #                 return "unchange"
+    #             if isinstance(args[0], (ast.Constant)) and isinstance(
+    #                 args[0].value, str
+    #             ):
+    #                 return "unchange"
+
+    #         self.write_aux_code()
+    #         return "unchange"
+
+    #     return "misidentify"
+
+    # TODO: After fixing the Infermeta mechanism of the view operator,
+    # remove the code below and uncomment the code above
+    def generate_aux_code(self):
+        CODE_TEMPLATE = textwrap.dedent(
+            """
+            def view(self, *args, **kwargs):
+                if args:
+                    if len(args)==1:
+                        if isinstance(args[0], (tuple, list)):
+                            return paddle.reshape(self, args[0]) # To change reshape => view
+                        elif isinstance(args[0], str):
+                            return paddle.view(self, args[0])
+                        else:
+                            return paddle.reshape(self, list(args)) # To change reshape => view
+                    else:
+                        return paddle.reshape(self, list(args)) # To change reshape => view
+                elif kwargs:
+                    key = [k for k in kwargs.keys()]
+                    if 'dtype' in kwargs:
+                        return paddle.view(self, shape_or_dtype = kwargs[key[0]])
+                    else:
+                        return paddle.reshape(self, shape = kwargs[key[0]]) # To change reshape => view
+
+            setattr(paddle.Tensor, 'view', view)
+            """
+        )
+        return CODE_TEMPLATE
+
+    def get_paddle_class_nodes(self, func, args, kwargs):
+        if kwargs:
+            if len(kwargs) == 1:
+                self.write_aux_code()
+                return "unchange"
+
+        if args:
+            if len(args) == 1:
+                if isinstance(args[0], (ast.Tuple, ast.List)):
+                    self.write_aux_code()  # To remove
+                    return "unchange"
+                if isinstance(args[0], (ast.Constant)) and isinstance(
+                    args[0].value, str
+                ):
+                    self.write_aux_code()  # To remove
+                    return "unchange"
+
+            self.write_aux_code()
+            return "unchange"
+
+        return "misidentify"
+
+
+class OuterMatcher(BaseMatcher):
+    def generate_aux_code(self):
+        CODE_TEMPLATE = TypePromoteFunc
+        return CODE_TEMPLATE
+
+    def generate_code(self, kwargs):
+        self.write_aux_code()
+        API_TEMPLATE = textwrap.dedent(
+            """
+                {},{}=paddle_aux.TypePromote({},{})
+                paddle.outer(x={},y={})
+            """
+        )
+        input = get_unique_name("input")
+        vec2 = get_unique_name("vec2")
+        return API_TEMPLATE.format(
+            input, vec2, kwargs["input"], kwargs["vec2"], input, vec2
+        )
+
+
+class OsEnvironGetMatcher(BaseMatcher):
+    def generate_code(self, kwargs):
+        if "key" in kwargs:
+            if kwargs["key"] == '"""WORLD_SIZE"""':
+                code = "paddle.distributed.get_world_size()"
+            elif kwargs["key"] == '"""LOCAL_RANK"""':
+                code = "padlde.distributed.get_rank()"
+            else:
+                code = "misidentify"
+        else:
+            code = "misidentify"
+        return code
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## paconvert/attribute_mapping.json

### Pretty-printed

 * *Similarity: 0.4364406779661017%*

 * *Differences: {"'torch.Tensor.shape'": "{'Matcher': 'TensorShapeMatcher'}",*

 * * "'torch.__version__'": "OrderedDict([('Matcher', 'GenericMatcher'), ('paddle_api', "*

 * *                        "'paddle.__version__')])",*

 * * "'torch.backends.cudnn.allow_tf32'": "OrderedDict([('Matcher', 'SetTrueMatcher')])",*

 * * "'torch.backends.cudnn.benchmark'": "OrderedDict([('Matcher', 'SetFalseMatcher')])",*

 * * "'torch.backends.cudnn.deterministic'": "OrderedDict([('Matcher', 'SetFalseMatcher')])",*

 * * "'torch.backends.cudnn.enabled'": "OrderedDict([(' […]*

```diff
@@ -46,18 +46,145 @@
         "paddle_api": "paddle.Tensor.real"
     },
     "torch.Tensor.requires_grad": {
         "Matcher": "TensorRequiresGradMatcher",
         "paddle_api": "paddle.Tensor.stop_gradient"
     },
     "torch.Tensor.shape": {
-        "Matcher": "UnchangeMatcher"
+        "Matcher": "TensorShapeMatcher"
+    },
+    "torch.__version__": {
+        "Matcher": "GenericMatcher",
+        "paddle_api": "paddle.__version__"
     },
     "torch.autograd.function.FunctionCtx.saved_tensors": {},
     "torch.autograd.profiler.profile.self_cpu_time_total": {},
+    "torch.backends.cudnn.allow_tf32": {
+        "Matcher": "SetTrueMatcher"
+    },
+    "torch.backends.cudnn.benchmark": {
+        "Matcher": "SetFalseMatcher"
+    },
+    "torch.backends.cudnn.deterministic": {
+        "Matcher": "SetFalseMatcher"
+    },
+    "torch.backends.cudnn.enabled": {
+        "Matcher": "SetTrueMatcher"
+    },
+    "torch.bfloat16": {
+        "Matcher": "GenericMatcher",
+        "paddle_api": "'bfloat16'"
+    },
+    "torch.bool": {
+        "Matcher": "GenericMatcher",
+        "paddle_api": "'bool'"
+    },
+    "torch.cdouble": {
+        "Matcher": "GenericMatcher",
+        "paddle_api": "'complex128'"
+    },
+    "torch.cfloat": {
+        "Matcher": "GenericMatcher",
+        "paddle_api": "'complex64'"
+    },
+    "torch.complex128": {
+        "Matcher": "GenericMatcher",
+        "paddle_api": "'complex128'"
+    },
+    "torch.complex64": {
+        "Matcher": "GenericMatcher",
+        "paddle_api": "'complex64'"
+    },
+    "torch.distributed.ReduceOp.MAX": {
+        "Matcher": "UnchangeMatcher",
+        "paddle_api": "paddle.distributed.ReduceOp.MAX"
+    },
+    "torch.distributed.ReduceOp.MIN": {
+        "Matcher": "UnchangeMatcher",
+        "paddle_api": "paddle.distributed.ReduceOp.MIN"
+    },
+    "torch.distributed.ReduceOp.PRODUCT": {
+        "Matcher": "UnchangeMatcher",
+        "paddle_api": "paddle.distributed.ReduceOp.PROD"
+    },
+    "torch.distributed.ReduceOp.SUM": {
+        "Matcher": "UnchangeMatcher",
+        "paddle_api": "paddle.distributed.ReduceOp.SUM"
+    },
     "torch.distributions.Distribution.batch_shape": {},
     "torch.distributions.Distribution.event_shape": {},
     "torch.distributions.Distribution.mean": {},
     "torch.distributions.Distribution.mode": {},
     "torch.distributions.Distribution.stddev": {},
-    "torch.distributions.Distribution.variance": {}
+    "torch.distributions.Distribution.variance": {},
+    "torch.double": {
+        "Matcher": "GenericMatcher",
+        "paddle_api": "'float64'"
+    },
+    "torch.dtype": {
+        "Matcher": "GenericMatcher",
+        "paddle_api": "paddle.dtype"
+    },
+    "torch.float": {
+        "Matcher": "GenericMatcher",
+        "paddle_api": "'float32'"
+    },
+    "torch.float16": {
+        "Matcher": "GenericMatcher",
+        "paddle_api": "'float16'"
+    },
+    "torch.float32": {
+        "Matcher": "GenericMatcher",
+        "paddle_api": "'float32'"
+    },
+    "torch.float64": {
+        "Matcher": "GenericMatcher",
+        "paddle_api": "'float64'"
+    },
+    "torch.half": {
+        "Matcher": "GenericMatcher",
+        "paddle_api": "'float16'"
+    },
+    "torch.int": {
+        "Matcher": "GenericMatcher",
+        "paddle_api": "'int32'"
+    },
+    "torch.int16": {
+        "Matcher": "GenericMatcher",
+        "paddle_api": "'int16'"
+    },
+    "torch.int32": {
+        "Matcher": "GenericMatcher",
+        "paddle_api": "'int32'"
+    },
+    "torch.int64": {
+        "Matcher": "GenericMatcher",
+        "paddle_api": "'int64'"
+    },
+    "torch.int8": {
+        "Matcher": "GenericMatcher",
+        "paddle_api": "'int8'"
+    },
+    "torch.long": {
+        "Matcher": "GenericMatcher",
+        "paddle_api": "'int64'"
+    },
+    "torch.optim.Optimizer.state_dict": {
+        "Matcher": "UnchangeMatcher"
+    },
+    "torch.short": {
+        "Matcher": "GenericMatcher",
+        "paddle_api": "'int16'"
+    },
+    "torch.uint8": {
+        "Matcher": "GenericMatcher",
+        "paddle_api": "'uint8'"
+    },
+    "torch.utils.cpp_extension.BuildExtension.with_options": {
+        "Matcher": "GenericMatcher",
+        "paddle_api": "paddle.utils.cpp_extension.BuildExtension.with_options"
+    },
+    "torch.utils.cpp_extension.CUDA_HOME": {
+        "Matcher": "GenericMatcher",
+        "paddle_api": "paddle.utils.cpp_extension.cpp_extension.CUDA_HOME"
+    }
 }
```

## paconvert/base.py

```diff
@@ -32,35 +32,42 @@
 with open(json_file, "r") as file:
     ATTRIBUTE_MAPPING = json.load(file)
 
 json_file = os.path.dirname(__file__) + "/api_alias_mapping.json"
 with open(json_file, "r") as file:
     ALIAS_MAPPING = json.load(file)
 
+# Abbreviation after annotation as the prefix for corresponding matcher
 TORCH_PACKAGE_LIST = [
     "torch",
     "mmseg",
     "mmcv",
     "mmdet",
     "mmdet3d",
     "mmengine",
     "detectron",
     "timm",
     "torchvision",
     "kornia",
     "fasttext",
     "pytorch_lightning",
     "jieba",
-    "sentencepiece",
     "NLTK",
     "scikit-learn",
-    "fairscale",
-    "transformers",
+    "fairscale",  # FS
+    "transformers",  # TRFM
     "datasets",
+    "accelerate",
+    "diffusers",
     "torch_xla",
+    "flash_attn",  # FA
+]
+MAY_TORCH_PACKAGE_LIST = [
+    "setuptools",
+    "os",
 ]
 
 
 class BaseTransformer(ast.NodeTransformer):
     def __init__(self, root, file, imports_map, logger, unsupport_map=None):
         self.root = root
         self.file = file
@@ -384,17 +391,19 @@
 
     def parse_func(self, func):
         new_func = astor.to_source(func).replace("\n", "")
         self.paddleClass = new_func[0 : new_func.rfind(".")]
         if self.get_paddle_api():
             new_paddle_api = re.sub(
                 "paddle.Tensor|paddle.nn.Layer|paddle.optimizer.Optimizer|paddle.distribution.Distribution|paddle.autograd.PyLayerContext|paddle.profiler.Profiler",
-                self.paddleClass,
+                re.escape(self.paddleClass),
                 self.get_paddle_api(),
             )
+            # reverse escape
+            new_paddle_api = re.sub(r"\\(.)", r"\1", new_paddle_api)
             self.set_paddle_api(new_paddle_api)
 
         return new_func
 
     def args_to_str(self, args):
         str_list = []
         for ele in args:
```

## paconvert/converter.py

```diff
@@ -126,15 +126,15 @@
         )
         if self.torch_api_count > 0:
             self.convert_rate = self.success_api_count / self.torch_api_count
         log_info(self.logger, " Convert Rate is: {:.3%}".format(self.convert_rate))
         if faild_api_count > 0:
             log_info(
                 self.logger,
-                "\nFor these {} Pytorch APIs that do not support to Convert now, which have been marked by >>> before the line, \nplease refer to "
+                "\nFor these {} Pytorch APIs that currently do not support to convert, which have been marked by >>> before the line, \nplease refer to "
                 "https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/guides/model_convert/convert_from_pytorch/pytorch_api_mapping_cn.html"
                 " \nand convert it by yourself manually. In addition, these APIs will be supported in future.".format(
                     faild_api_count
                 ),
             )
         log_info(
             self.logger,
@@ -243,41 +243,63 @@
             self.torch_api_count += trans.torch_api_count
             self.success_api_count += trans.success_api_count
 
     def mark_unsupport(self, code, file):
         lines = code.split("\n")
         mark_next_line = False
         in_str = False
+        bracket_num = 0
         for i, line in enumerate(lines):
-            # torch.* in __doc__
-            # torch.* in str
-            if line.count('"""') % 2 != 0:
-                in_str = not in_str
-
-            tmp_line = re.sub(r"[\'\"]{1}[^\'\"]+[\'\"]{1}", "", line)
-            if in_str:
-                continue
-
             if (
                 "Class Method:" in line
                 or "Class Attribute:" in line
                 or "C++ Custom OP" in line
             ):
                 mark_next_line = True
                 continue
             else:
                 # func decorator_list: @
                 if mark_next_line and line != "@":
                     lines[i] = ">>>>>>" + line
                     mark_next_line = False
                     continue
 
-            # model_torch.npy
+            # """ torch.* """
+            # " torch.* "
+            # ' torch.* '
+            # " (torch "
+            # " torch) "
+            # just remove the str, avoid str influence the torch api recognize
+            rm_str_line = re.sub(r"[\"]{3}[^\"]+[\"]{3}", "", line)
+            rm_str_line = re.sub(r"[\"]{1}[^\"]+[\"]{1}", "", rm_str_line)
+            rm_str_line = re.sub(r"[\']{1}[^\']+[\']{1}", "", rm_str_line)
+
+            # """
+            # torch.*
+            # """
+            pre_in_str = in_str
+            if rm_str_line.count('"""') % 2 != 0:
+                in_str = not in_str
+            if pre_in_str or in_str:
+                continue
+
+            # paddle.add(paddlenlp.
+            #   transformers.BertTokenizer
+            pre_bracket_num = bracket_num
+            bracket_num += rm_str_line.count("(")
+            bracket_num -= rm_str_line.count(")")
+            if pre_bracket_num > 0:
+                continue
+
             for torch_package in self.imports_map[file]["torch_packages"]:
-                if tmp_line.startswith("%s." % torch_package):
+                if rm_str_line.startswith("%s." % torch_package):
                     lines[i] = ">>>>>>" + line
                     break
 
-                if re.match(r".*[^A-Za-z_]{1}%s\." % torch_package, tmp_line):
+                # model_torch.npy
+                # modeltorch.npy
+                # 1torch.npy
+                # paddlenlp.transformers.*
+                if re.match(r".*[^\w\.]{1}%s\." % torch_package, rm_str_line):
                     lines[i] = ">>>>>>" + line
 
         return "\n".join(lines)
```

## paconvert/main.py

```diff
@@ -28,15 +28,15 @@
         )
 
     parser = argparse.ArgumentParser(
         prog="paconvert", description="PaConverter tool entry point"
     )
     parser.add_argument(
         "--in_dir",
-        default="./tests/test_transpose.py",
+        default=None,
         type=str,
         help="the input PyTorch file or directory.",
     )
     parser.add_argument(
         "--out_dir", default=None, type=str, help="the output Paddle directory."
     )
     parser.add_argument(
```

## paconvert/utils.py

```diff
@@ -53,19 +53,19 @@
             )
             if not os.path.exists(os.path.dirname(self.fileName)):
                 os.makedirs(os.path.dirname(self.fileName))
 
             with open(self.fileName, "w") as file:
                 file.write(CODE_CONTENT)
 
-        if self.ids[torch_api] == 0:
+        if self.ids[code] == 0:
             with open(self.fileName, "a") as file:
                 file.write(code)
 
-        self.ids[torch_api] += 1
+        self.ids[code] += 1
 
     def __new__(cls, fileName=None, *args, **kwargs):
         if cls._instance is None:
             cls._instance = super().__new__(cls)
         return cls._instance
```

## paconvert/transformer/basic_transformer.py

```diff
@@ -21,14 +21,15 @@
 
 from paconvert.api_matcher import *
 from paconvert.base import (
     API_MAPPING,
     ATTRIBUTE_MAPPING,
     ALIAS_MAPPING,
     BaseTransformer,
+    MAY_TORCH_PACKAGE_LIST,
 )
 from paconvert.utils import log_debug, log_info
 
 
 def iter_fields(node):
     """
     Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields``
@@ -48,14 +49,19 @@
         )
         # use to identify tensor method/attribute
         self.black_list = self.imports_map[self.file]["other_packages"] + [
             "ndarray",
             "args",
             "arg",
         ]
+        self.MAY_TORCH_METHOD_LIST = [
+            key
+            for key in API_MAPPING.keys()
+            if any(key.startswith("%s." % item) for item in MAY_TORCH_PACKAGE_LIST)
+        ]
 
     def visit_Attribute(self, node):
         """
         torch api is not used by function call, so only match api name and not need to handle params.
         """
         # 1. torch.abs(x).transpose(1, 0)
         # 2. (x == y).transpose(1, 0)
@@ -91,15 +97,20 @@
                 self.torch_api_count += 1
                 log_debug(
                     self.logger,
                     "Start convert {} to Paddle --> ".format(torch_api),
                     self.file_name,
                     node.lineno,
                 )
+
                 matcher = self.get_api_mather(torch_api)
+                # fallback to attribute matcher
+                if matcher is None:
+                    matcher = self.get_attribute_mather(torch_api)
+
                 if matcher:
                     paddle_api = matcher.get_paddle_api()
                     if paddle_api == "delete":
                         if isinstance(self.parent_node, ast.Expr):
                             self.success_api_count += 1
                             log_info(
                                 self.logger,
@@ -365,15 +376,15 @@
         full_attr = self.get_full_attr(node.func)
 
         # Torch Package Call, include torch third_party
         #   such as : torch.add(x, y) / torch.add(torch.abs(x), y)
         for torch_package in self.imports_map[self.file]["torch_packages"]:
             if (
                 full_attr.startswith("%s." % torch_package)
-                or "setuptools.setup" == full_attr
+                or full_attr in self.MAY_TORCH_METHOD_LIST
             ):
                 torch_api = full_attr
                 self.torch_api_count += 1
                 log_debug(
                     self.logger,
                     "Start convert {} to Paddle --> ".format(torch_api),
                     self.file_name,
@@ -386,15 +397,14 @@
                     support = False
                 # such as torch.max(*args, **kwargs)
                 if isinstance(node.args, ast.Starred):
                     support = False
                 for k_node in node.keywords:
                     if k_node.arg is None:
                         support = False
-
                 if support:
                     node_list = matcher.get_paddle_nodes(node.args, node.keywords)
                     if node_list == "delete":
                         if isinstance(self.parent_node, ast.Expr):
                             self.success_api_count += 1
                             log_info(
                                 self.logger,
@@ -574,14 +584,15 @@
                         torch_api
                     ),
                     self.file_name,
                     node.lineno,
                 )
                 return node
             elif node_list == "misidentify":
+                self.torch_api_count -= 1
                 # This API usage indicate that it is not this class method
                 log_debug(
                     self.logger,
                     " Misidentify Class Method: {}".format(torch_api),
                     self.file_name,
                     node.lineno,
                 )
@@ -657,14 +668,25 @@
                 return None
 
             if "Matcher" in api_mapping:
                 matcher = api_mapping["Matcher"]
                 return eval(matcher)(self, torch_api, api_mapping, self.logger)
         return None
 
+    def get_attribute_mather(self, torch_api):
+        if torch_api in ATTRIBUTE_MAPPING:
+            attr_mapping = ATTRIBUTE_MAPPING[torch_api]
+            if "disable" in attr_mapping and eval(attr_mapping["disable"]):
+                return None
+
+            if "Matcher" in attr_mapping:
+                matcher = attr_mapping["Matcher"]
+                return eval(matcher)(self, torch_api, attr_mapping, self.logger)
+        return None
+
     def visit_Expr(self, node):
         for field, old_value in iter_fields(node):
             new_node = self.visit(old_value)
             if new_node is None:
                 return None
             else:
                 setattr(node, field, new_node)
```

## paconvert/transformer/import_transformer.py

```diff
@@ -11,67 +11,82 @@
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 import ast
 import os
 
-from paconvert.base import ALIAS_MAPPING, TORCH_PACKAGE_LIST, BaseTransformer
+from paconvert.base import ALIAS_MAPPING, BaseTransformer
 from paconvert.utils import log_info
 
+from ..base import MAY_TORCH_PACKAGE_LIST, TORCH_PACKAGE_LIST
+
 
 class ImportTransformer(BaseTransformer):
     """
     Record import information
     """
 
     def __init__(self, root, file, imports_map, logger, unsupport_map=None):
         super(ImportTransformer, self).__init__(
             root, file, imports_map, logger, unsupport_map
         )
         self.imports_map[self.file]["other_packages"] = []
         self.imports_map[self.file]["torch_packages"] = []
         self.import_paddle = False
-        self.import_setuptools = False
+        self.import_paddlenlp = False
+        self.import_MAY_TORCH_PACKAGE_LIST = []
 
     def visit_Import(self, node):
         """
         1. remove import torch.nn
         2. remove import torch.nn as nn
         3. record whether to import paddle
         """
         new_node_names = []
         for alias_node in node.names:
             has_done = False
 
             # import from current project
             dir_name = os.path.dirname(self.file)
+            """
             while (
                 len(dir_name) > 1 and dir_name[-2] != ":"
             ):  # the case of dir_name = 'E:/' will happen with windows
                 import_path = os.path.join(dir_name, alias_node.name.replace(".", "/"))
 
                 if os.path.exists(import_path) or os.path.exists(import_path + ".py"):
                     self.insert_other_packages(self.imports_map, alias_node)
                     new_node_names.append(alias_node)
                     has_done = True
                     break
 
                 dir_name = os.path.dirname(dir_name)
+            """
+            import_path = os.path.join(dir_name, alias_node.name.replace(".", "/"))
+            if os.path.exists(import_path) or os.path.exists(import_path + ".py"):
+                self.insert_other_packages(self.imports_map, alias_node)
+                new_node_names.append(alias_node)
+                has_done = True
+                break
+
             if has_done:
                 continue
 
             # import from torch
-            for pkg_name in TORCH_PACKAGE_LIST + ["setuptools"]:
+            for pkg_name in TORCH_PACKAGE_LIST + MAY_TORCH_PACKAGE_LIST:
                 if f"{pkg_name}." in alias_node.name or pkg_name == alias_node.name:
-                    if pkg_name == "setuptools":
-                        self.import_setuptools = True
+                    if pkg_name in MAY_TORCH_PACKAGE_LIST:
+                        if pkg_name not in self.import_MAY_TORCH_PACKAGE_LIST:
+                            self.import_MAY_TORCH_PACKAGE_LIST.append(pkg_name)
                     else:
                         self.imports_map[self.file]["torch_packages"].append(pkg_name)
                         self.import_paddle = True
+                        if pkg_name == "transformers":
+                            self.import_paddlenlp = True
                     if alias_node.asname:
                         log_info(
                             self.logger,
                             "remove 'import {} as {}' ".format(
                                 alias_node.name, alias_node.asname
                             ),
                             self.file_name,
@@ -84,14 +99,15 @@
                             "remove 'import {}' ".format(alias_node.name),
                             self.file_name,
                             node.lineno,
                         )
                         self.imports_map[self.file][alias_node.name] = alias_node.name
                     has_done = True
                     break
+
             if has_done:
                 continue
 
             # other_packages
             self.insert_other_packages(self.imports_map, alias_node)
             new_node_names.append(alias_node)
 
@@ -120,33 +136,42 @@
             """
             self.insert_other_packages(self.imports_map, node)
             return node
         else:
             # from yolov3.datasets import xxx
             # from datasets import xxx
             dir_name = os.path.dirname(self.file)
+            """
             while (
                 len(dir_name) > 1 and dir_name[-2] != ":"
             ):  # the case of dir_name = 'E:/' will happen with windows
                 import_path = os.path.join(dir_name, node.module.replace(".", "/"))
 
                 if os.path.exists(import_path) or os.path.exists(import_path + ".py"):
                     self.insert_other_packages(self.imports_map, node)
                     return node
 
                 dir_name = os.path.dirname(dir_name)
+            """
+            import_path = os.path.join(dir_name, node.module.replace(".", "/"))
+            if os.path.exists(import_path) or os.path.exists(import_path + ".py"):
+                self.insert_other_packages(self.imports_map, node)
+                return node
 
         # import from TORCH_PACKAGE_LIST
-        for pkg_name in TORCH_PACKAGE_LIST + ["setuptools"]:
+        for pkg_name in TORCH_PACKAGE_LIST + MAY_TORCH_PACKAGE_LIST:
             if f"{pkg_name}." in node.module or pkg_name == node.module:
-                if pkg_name == "setuptools":
-                    self.import_setuptools = True
-                else:
+                if pkg_name in TORCH_PACKAGE_LIST:
                     self.imports_map[self.file]["torch_packages"].append(pkg_name)
                     self.import_paddle = True
+                    if pkg_name == "transformers":
+                        self.import_paddlenlp = True
+                else:
+                    if pkg_name not in self.import_MAY_TORCH_PACKAGE_LIST:
+                        self.import_MAY_TORCH_PACKAGE_LIST.append(pkg_name)
                 for alias_node in node.names:
                     if alias_node.asname:
                         log_info(
                             self.logger,
                             "remove 'from {} import {} as {}' ".format(
                                 node.module, alias_node.name, alias_node.asname
                             ),
@@ -214,23 +239,28 @@
     def visit_Name(self, node):
         """
         change torch api name to full api according to import info.
         eg.
             from torch.nn import Module
             from torch import Tensor
             from torch import float32
+            import torch.add as TorchAdd
 
             1. class A(Module):
             2. def func() -> Tensor:
             3. def func(x: Tensor):
             4. def func(dtype=float32):
             5. Tensor(2, 3)
             6. isinstance(x, Tensor)
             7. setattr(Tensor, 'add', func)
             8. {'build_ext': BuildExtension}
+            9. inputs: Optional[Tensor] = None
+            10. Union[GenerateOutput, torch.LongTensor]
+            11. my_add = TorchAdd
+            12. Union[List[str], List[AddedToken]],
         """
         is_torch = False
         if isinstance(
             self.parent_node,
             (
                 ast.ClassDef,  # 1. ast.ClassDef(bases=[ast.Name])
                 ast.FunctionDef,  # 2. ast.FunctionDef(returns=ast.Name)
@@ -243,33 +273,64 @@
         elif isinstance(self.parent_node, ast.Call) and isinstance(
             self.parent_node.func, ast.Name
         ):
             if self.parent_node.func == node:  # 5
                 is_torch = True
             elif self.parent_node.func.id in ["isinstance", "setattr"]:  # 6/7
                 is_torch = True
+        elif (
+            isinstance(self.parent_node, ast.Subscript)
+            and self.parent_node.slice == node
+        ):
+            is_torch = True  # 9. Optional[Tensor] = None
+        elif (
+            isinstance(self.parent_node, ast.Tuple)
+            and len(self.node_stack) >= 3
+            and isinstance(self.node_stack[-3], ast.Subscript)
+        ):
+            is_torch = True  # 10. Union[GenerateOutput, torch.LongTensor]
+        elif (
+            isinstance(self.parent_node, ast.Assign) and node == self.parent_node.value
+        ):
+            is_torch = True  # 11. my_add = TorchAdd
+        elif isinstance(self.parent_node, ast.Index) and self.parent_node.value == node:
+            is_torch = True  # 12. Union[List[str], List[AddedToken]]
 
         if is_torch:
             torch_api = self.get_full_api_from_node(node)
             if torch_api:
                 if torch_api in ALIAS_MAPPING:
                     torch_api = ALIAS_MAPPING[torch_api]
                 return ast.parse(torch_api).body[0].value
         return node
 
     def visit_Module(self, node):
         """
         add import paddle
         """
         super(ImportTransformer, self).generic_visit(node)
-
+        line_NO = 1
         if self.import_paddle:
-            log_info(self.logger, "add 'import paddle' in first line", self.file_name)
+            log_info(
+                self.logger, f"add 'import paddle' in line {line_NO}", self.file_name
+            )
             self.record_scope((self.root, "body", 0), ast.parse("import paddle").body)
-
-        if self.import_setuptools:
+            line_NO += 1
+        if self.import_paddlenlp:
             log_info(
-                self.logger, "add 'import setuptools' in second line", self.file_name
+                self.logger, f"add 'import paddlenlp' in line {line_NO}", self.file_name
             )
             self.record_scope(
-                (self.root, "body", 1), ast.parse("import setuptools").body
+                (self.root, "body", 0), ast.parse("import paddlenlp").body
             )
+            line_NO += 1
+        if len(self.import_MAY_TORCH_PACKAGE_LIST) > 0:
+            for package in self.import_MAY_TORCH_PACKAGE_LIST:
+                log_info(
+                    self.logger,
+                    f"add 'import {package}' in line {line_NO}",
+                    self.file_name,
+                )
+                self.record_scope(
+                    (self.root, "body", 0), ast.parse(f"import {package}").body
+                )
+                line_NO += 1
```

## Comparing `paconvert-0.3.0.dist-info/LICENSE` & `paconvert-1.0.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `paconvert-0.3.0.dist-info/METADATA` & `paconvert-1.0.0.dist-info/METADATA`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: paconvert
-Version: 0.3.0
+Version: 1.0.0
 Summary: PaddlePaddle Code Convert Toolkits
 Home-page: https://github.com/PaddlePaddle/PaConvert
 Author-email: Paddle-better@baidu.com
 Maintainer: PaddlePaddle
 Maintainer-email: Paddle-better@baidu.com
 License: Apache Software License
 Download-URL: https://github.com/PaddlePaddle/PaConvert
@@ -14,16 +14,17 @@
 Requires-Dist: astor
 
 # PaConvert ![](https://img.shields.io/badge/version-v0.2.0-brightgreen) ![](https://img.shields.io/badge/docs-latest-brightgreen) ![](https://img.shields.io/badge/PRs-welcome-brightgreen) ![](https://img.shields.io/badge/pre--commit-Yes-brightgreen)
 
 **Pa**ddlePaddle Code **Convert** Toolkits
 
 # 重要
-- 当前共支持约1200个Pytorch API的一键转换，我们通过285个Pytorch 模型代码测试，代码行数平均转换率约为 **85+%**
-- 当前PaConvert转换工具还在内测中，欢迎下载试用，欢迎通过issue方式向我们报Bug与提建议
+- 本工具由Paddle团队官方维护与建设，所有转换代码均已经过测试，欢迎大家使用与反馈
+- 当前共支持约1300+个Pytorch API的一键转换，我们通过300+个Pytorch模型测试，代码行数平均转换率约为 **90+%**
+- 本工具基于 [PyTorch 最新 release 与 Paddle develop API 映射表](https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/guides/model_convert/convert_from_pytorch/pytorch_api_mapping_cn.html) 实现，表中API均经过详细对比分析，欢迎查阅
 
 # 概述
 PaConvert全称是 **代码转换工具**，能自动将其它深度学习框架训练或推理的**代码**，转换为PaddlePaddle的**代码**，方便快速自动地 **模型代码迁移**。
 
 目前支持自动转换Pytorch代码，其它深度学习框架的支持后续新增中，其原理是通过Python AST语法树分析，将输入代码生成为抽象语法树，对其进行解析、遍历、匹配、编辑、替换、插入等各种操作，然后得到基于PaddlePaddle的抽象语法树，最后生成Paddle的代码。
 
 转换会尽量保持原代码的风格与结构，将代码中其它深度学习框架的接口转换为调用PaddlePaddle的接口。
@@ -164,15 +165,15 @@
 Convert Summary:
 ========================================
 There are 10 Pytorch APIs in this Project:
  8  Pytorch APIs have been converted to Paddle successfully!
  2  Pytorch APIs are not supported to convert to Paddle currently!
  Convert Rate is: 80.000%
 
-For these 2 Pytorch APIs that do not support to Convert now, which have been marked by >>>>>> before the line,
+For these 2 Pytorch APIs that currently do not support to convert, which have been marked by >>>>>> before the line,
 please refer to https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/guides/model_convert/convert_from_pytorch/pytorch_api_mapping_cn.html
 and convert it by yourself manually. In addition, these APIs will be supported in future.
 
 Thank you to use Paddle Code Convert Tool. You can make any suggestions to us.
 
 ```
```

