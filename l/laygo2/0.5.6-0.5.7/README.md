# Comparing `tmp/laygo2-0.5.6.tar.gz` & `tmp/laygo2-0.5.7.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist/laygo2-0.5.6.tar", last modified: Sat Nov 18 07:36:53 2023, max compression
+gzip compressed data, was "laygo2-0.5.7.tar", last modified: Wed Apr 24 18:42:07 2024, max compression
```

## Comparing `laygo2-0.5.6.tar` & `laygo2-0.5.7.tar`

### file list

```diff
@@ -1,58 +1,60 @@
-drwxrwxr-x   0 jdhan     (1001) jdhan     (1001)        0 2023-11-18 07:36:53.000000 laygo2-0.5.6/
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)       94 2023-11-18 07:35:57.000000 laygo2-0.5.6/requirements.txt
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)     3001 2023-11-18 07:36:53.000000 laygo2-0.5.6/PKG-INFO
-drwxrwxr-x   0 jdhan     (1001) jdhan     (1001)        0 2023-11-18 07:36:53.000000 laygo2-0.5.6/examples/
-drwxrwxr-x   0 jdhan     (1001) jdhan     (1001)        0 2023-11-18 07:36:53.000000 laygo2-0.5.6/examples/laygo2_tech/
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)    11174 2023-11-18 07:35:57.000000 laygo2-0.5.6/examples/laygo2_tech/laygo2_tech_templates.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)     2309 2023-11-18 07:35:57.000000 laygo2-0.5.6/examples/laygo2_tech/__init__.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)     4864 2023-11-18 07:35:57.000000 laygo2-0.5.6/examples/laygo2_tech/laygo2_tech_grids.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)        0 2023-11-18 07:35:57.000000 laygo2-0.5.6/examples/__init__.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)       58 2022-10-16 07:12:32.000000 laygo2-0.5.6/MANIFEST.in
-drwxrwxr-x   0 jdhan     (1001) jdhan     (1001)        0 2023-11-18 07:36:53.000000 laygo2-0.5.6/laygo2.egg-info/
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)     1239 2023-11-18 07:36:52.000000 laygo2-0.5.6/laygo2.egg-info/SOURCES.txt
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)     3001 2023-11-18 07:36:52.000000 laygo2-0.5.6/laygo2.egg-info/PKG-INFO
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)        1 2023-11-18 07:36:52.000000 laygo2-0.5.6/laygo2.egg-info/dependency_links.txt
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)       16 2023-11-18 07:36:52.000000 laygo2-0.5.6/laygo2.egg-info/top_level.txt
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)     1170 2023-11-18 07:36:38.000000 laygo2-0.5.6/setup.py
-drwxrwxr-x   0 jdhan     (1001) jdhan     (1001)        0 2023-11-18 07:36:53.000000 laygo2-0.5.6/laygo2_tech_quick_start/
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)    21135 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2_tech_quick_start/laygo2_tech_templates.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)     2287 2022-11-02 13:42:09.000000 laygo2-0.5.6/laygo2_tech_quick_start/__init__.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)     4904 2022-11-02 13:42:09.000000 laygo2-0.5.6/laygo2_tech_quick_start/laygo2_tech_grids.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)       38 2023-11-18 07:36:53.000000 laygo2-0.5.6/setup.cfg
-drwxrwxr-x   0 jdhan     (1001) jdhan     (1001)        0 2023-11-18 07:36:53.000000 laygo2-0.5.6/laygo2/
-drwxrwxr-x   0 jdhan     (1001) jdhan     (1001)        0 2023-11-18 07:36:53.000000 laygo2-0.5.6/laygo2/util/
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)     5437 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2/util/transform.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)     1748 2022-10-16 07:12:32.000000 laygo2-0.5.6/laygo2/util/__init__.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)      204 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2/_typing.py
-drwxrwxr-x   0 jdhan     (1001) jdhan     (1001)        0 2023-11-18 07:36:53.000000 laygo2-0.5.6/laygo2/object/
-drwxrwxr-x   0 jdhan     (1001) jdhan     (1001)        0 2023-11-18 07:36:53.000000 laygo2-0.5.6/laygo2/object/technology/
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)     1790 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2/object/technology/__init__.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)    42831 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2/object/technology/nifty.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)     8053 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2/object/technology/core.py
--rwxrwxr-x   0 jdhan     (1001) jdhan     (1001)    74484 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2/object/database.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)     3035 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2/object/__init__.py
-drwxrwxr-x   0 jdhan     (1001) jdhan     (1001)        0 2023-11-18 07:36:53.000000 laygo2-0.5.6/laygo2/object/template/
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)    32608 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2/object/template/tile.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)     1807 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2/object/template/__init__.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)    58385 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2/object/template/core.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)    11335 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2/object/template/routing.py
--rwxrwxr-x   0 jdhan     (1001) jdhan     (1001)    88777 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2/object/physical.py
-drwxrwxr-x   0 jdhan     (1001) jdhan     (1001)        0 2023-11-18 07:36:53.000000 laygo2-0.5.6/laygo2/object/grid/
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)     9178 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2/object/grid/uniformrouting.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)     2147 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2/object/grid/__init__.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)   101577 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2/object/grid/core.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)     3915 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2/object/grid/placement.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)    71518 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2/object/grid/routing.py
-drwxrwxr-x   0 jdhan     (1001) jdhan     (1001)        0 2023-11-18 07:36:53.000000 laygo2-0.5.6/laygo2/interface/
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)     4499 2022-10-16 07:12:32.000000 laygo2-0.5.6/laygo2/interface/skillbridge.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)    11332 2022-10-16 07:12:32.000000 laygo2-0.5.6/laygo2/interface/gdspy.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)    12770 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2/interface/magic.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)     2574 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2/interface/__init__.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)    19586 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2/interface/mpl.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)     6864 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2/interface/bag.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)     6736 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2/interface/yaml.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)    15262 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2/interface/skill.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)     9945 2022-10-16 07:12:32.000000 laygo2-0.5.6/laygo2/interface/gds.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)     2175 2023-11-18 07:35:57.000000 laygo2-0.5.6/laygo2/__init__.py
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)      924 2023-11-18 07:35:57.000000 laygo2-0.5.6/README.md
--rw-rw-r--   0 jdhan     (1001) jdhan     (1001)     1513 2022-10-16 07:12:32.000000 laygo2-0.5.6/LICENSE
+drwxrwxrwx   0        0        0        0 2024-04-24 18:42:07.732374 laygo2-0.5.7/
+-rw-rw-rw-   0        0        0     1542 2024-04-24 18:33:50.000000 laygo2-0.5.7/LICENSE
+-rw-rw-rw-   0        0        0       60 2024-04-24 18:33:50.000000 laygo2-0.5.7/MANIFEST.in
+-rw-rw-rw-   0        0        0     3047 2024-04-24 18:42:07.728697 laygo2-0.5.7/PKG-INFO
+-rw-rw-rw-   0        0        0      955 2024-04-24 18:33:50.000000 laygo2-0.5.7/README.md
+drwxrwxrwx   0        0        0        0 2024-04-24 18:42:07.582539 laygo2-0.5.7/examples/
+-rw-rw-rw-   0        0        0        0 2024-04-24 18:33:51.000000 laygo2-0.5.7/examples/__init__.py
+drwxrwxrwx   0        0        0        0 2024-04-24 18:42:07.594183 laygo2-0.5.7/examples/laygo2_tech/
+-rw-rw-rw-   0        0        0     2358 2024-04-24 18:33:51.000000 laygo2-0.5.7/examples/laygo2_tech/__init__.py
+-rw-rw-rw-   0        0        0     4947 2024-04-24 18:33:51.000000 laygo2-0.5.7/examples/laygo2_tech/laygo2_tech_grids.py
+-rw-rw-rw-   0        0        0    11439 2024-04-24 18:33:51.000000 laygo2-0.5.7/examples/laygo2_tech/laygo2_tech_templates.py
+drwxrwxrwx   0        0        0        0 2024-04-24 18:42:07.598938 laygo2-0.5.7/laygo2/
+-rw-rw-rw-   0        0        0     2226 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/__init__.py
+-rw-rw-rw-   0        0        0      215 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/_typing.py
+drwxrwxrwx   0        0        0        0 2024-04-24 18:42:07.655753 laygo2-0.5.7/laygo2/interface/
+-rw-rw-rw-   0        0        0     2618 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/interface/__init__.py
+-rw-rw-rw-   0        0        0     7011 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/interface/bag.py
+-rw-rw-rw-   0        0        0    10184 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/interface/gds.py
+-rw-rw-rw-   0        0        0      220 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/interface/gds_default.layermap
+-rw-rw-rw-   0        0        0    11645 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/interface/gdspy.py
+-rw-rw-rw-   0        0        0    13040 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/interface/magic.py
+-rw-rw-rw-   0        0        0    10891 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/interface/magic_export.tcl
+-rw-rw-rw-   0        0        0    20088 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/interface/mpl.py
+-rw-rw-rw-   0        0        0    15646 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/interface/skill.py
+-rw-rw-rw-   0        0        0     6814 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/interface/skill_export.il
+-rw-rw-rw-   0        0        0     4607 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/interface/skillbridge.py
+-rw-rw-rw-   0        0        0     6903 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/interface/yaml.py
+drwxrwxrwx   0        0        0        0 2024-04-24 18:42:07.665320 laygo2-0.5.7/laygo2/object/
+-rw-rw-rw-   0        0        0     3093 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/object/__init__.py
+-rw-rw-rw-   0        0        0    76416 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/object/database.py
+drwxrwxrwx   0        0        0        0 2024-04-24 18:42:07.686253 laygo2-0.5.7/laygo2/object/grid/
+-rw-rw-rw-   0        0        0     2188 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/object/grid/__init__.py
+-rw-rw-rw-   0        0        0   104734 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/object/grid/core.py
+-rw-rw-rw-   0        0        0     4009 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/object/grid/placement.py
+-rw-rw-rw-   0        0        0    73096 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/object/grid/routing.py
+-rw-rw-rw-   0        0        0     9392 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/object/grid/uniformrouting.py
+-rw-rw-rw-   0        0        0    91514 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/object/physical.py
+drwxrwxrwx   0        0        0        0 2024-04-24 18:42:07.696012 laygo2-0.5.7/laygo2/object/technology/
+-rw-rw-rw-   0        0        0     1822 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/object/technology/__init__.py
+-rw-rw-rw-   0        0        0     8212 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/object/technology/core.py
+-rw-rw-rw-   0        0        0    43773 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/object/technology/nifty.py
+drwxrwxrwx   0        0        0        0 2024-04-24 18:42:07.709569 laygo2-0.5.7/laygo2/object/template/
+-rw-rw-rw-   0        0        0     1839 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/object/template/__init__.py
+-rw-rw-rw-   0        0        0    59867 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/object/template/core.py
+-rw-rw-rw-   0        0        0    11602 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/object/template/routing.py
+-rw-rw-rw-   0        0        0    33493 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/object/template/tile.py
+drwxrwxrwx   0        0        0        0 2024-04-24 18:42:07.716354 laygo2-0.5.7/laygo2/util/
+-rw-rw-rw-   0        0        0     1776 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/util/__init__.py
+-rw-rw-rw-   0        0        0     5584 2024-04-24 18:33:51.000000 laygo2-0.5.7/laygo2/util/transform.py
+drwxrwxrwx   0        0        0        0 2024-04-24 18:42:07.612804 laygo2-0.5.7/laygo2.egg-info/
+-rw-rw-rw-   0        0        0     3047 2024-04-24 18:42:06.000000 laygo2-0.5.7/laygo2.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0     1256 2024-04-24 18:42:07.000000 laygo2-0.5.7/laygo2.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2024-04-24 18:42:06.000000 laygo2-0.5.7/laygo2.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0       16 2024-04-24 18:42:06.000000 laygo2-0.5.7/laygo2.egg-info/top_level.txt
+-rw-rw-rw-   0        0        0      102 2024-04-24 18:33:51.000000 laygo2-0.5.7/requirements.txt
+-rw-rw-rw-   0        0        0       42 2024-04-24 18:42:07.732950 laygo2-0.5.7/setup.cfg
+-rw-rw-rw-   0        0        0     1211 2024-04-24 18:36:45.000000 laygo2-0.5.7/setup.py
+drwxrwxrwx   0        0        0        0 2024-04-24 18:42:07.723382 laygo2-0.5.7/tests/
+-rw-rw-rw-   0        0        0    32512 2024-04-24 18:33:51.000000 laygo2-0.5.7/tests/test_manual.py
+-rw-rw-rw-   0        0        0    29365 2024-04-24 18:33:51.000000 laygo2-0.5.7/tests/test_object.py
```

### filetype from file(1)

```diff
@@ -1 +1 @@
-POSIX tar archive (GNU)
+POSIX tar archive
```

### Comparing `laygo2-0.5.6/PKG-INFO` & `laygo2-0.5.7/PKG-INFO`

 * *Files 17% similar despite different names*

```diff
@@ -1,71 +1,71 @@
-Metadata-Version: 2.1
-Name: laygo2
-Version: 0.5.6
-Summary: LAYout with Gridded Object 2 - A Python Package for Scripted IC Layout Generation Flow
-Home-page: https://github.com/niftylab/laygo2
-Author: Jaeduk Han
-License: BSD 3-Clause License
-
-Copyright (c) 2019, jdhan
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-1. Redistributions of source code must retain the above copyright notice, this
-   list of conditions and the following disclaimer.
-
-2. Redistributions in binary form must reproduce the above copyright notice,
-   this list of conditions and the following disclaimer in the documentation
-   and/or other materials provided with the distribution.
-
-3. Neither the name of the copyright holder nor the names of its
-   contributors may be used to endorse or promote products derived from
-   this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-Description: # laygo2
-        
-        [![PyPI version](https://badge.fury.io/py/laygo2.svg?)](https://pypi.org/project/laygo2/)
-        
-        (The commit history is cleaned up on 6-27-2022)
-        
-        The LAYout with Gridded Object 2 (laygo2) is an automated layout generation framework
-        for custom integrated circuits. 
-        [\[Source code\]](https://github.com/niftylab/laygo2) 
-        [\[Documentation\]](https://laygo2.github.io/) 
-        [\[Colab tutorial\]](https://colab.research.google.com/drive/1tpuUvqb6BujzZI6RBf2cFdAfMqBsxpep?usp=sharing) 
-        
-        LAYGO2 provides a rich and productive layout design environment for designers
-        with several advanced concepts such templates and grids.
-        
-        For further documentation, see [https://laygo2.github.io/](https://laygo2.github.io/).
-        
-        List of developers and contributors:
-        - Jaeduk Han
-        - Taeho Shin
-        - Dongjun Lee
-        - Dongwhee Kim
-        - Gaeryun Sung
-        - Wookjin Shin
-        - Yunseong Jo
-        - Hyungjoo Park
-        - Seonghyun Park
-        - Youngmin Oh
-        - Taeseung Kang
-        - Curtis Mayberry
-        
-        
-Platform: UNKNOWN
-Requires-Python: >=3.5
-Description-Content-Type: text/markdown
+Metadata-Version: 2.1
+Name: laygo2
+Version: 0.5.7
+Summary: LAYout with Gridded Object 2 - A Python Package for Scripted IC Layout Generation Flow
+Home-page: https://github.com/niftylab/laygo2
+Author: Jaeduk Han
+License: BSD 3-Clause License
+        
+        Copyright (c) 2019, jdhan
+        All rights reserved.
+        
+        Redistribution and use in source and binary forms, with or without
+        modification, are permitted provided that the following conditions are met:
+        
+        1. Redistributions of source code must retain the above copyright notice, this
+           list of conditions and the following disclaimer.
+        
+        2. Redistributions in binary form must reproduce the above copyright notice,
+           this list of conditions and the following disclaimer in the documentation
+           and/or other materials provided with the distribution.
+        
+        3. Neither the name of the copyright holder nor the names of its
+           contributors may be used to endorse or promote products derived from
+           this software without specific prior written permission.
+        
+        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+        AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+        IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+        DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+        FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+        DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+        SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+        CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+        OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+        OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+        
+Requires-Python: >=3.5
+Description-Content-Type: text/markdown
+License-File: LICENSE
+
+# laygo2
+
+[![PyPI version](https://badge.fury.io/py/laygo2.svg?)](https://pypi.org/project/laygo2/)
+
+(The commit history is cleaned up on 6-27-2022)
+
+The LAYout with Gridded Object 2 (laygo2) is an automated layout generation framework
+for custom integrated circuits. 
+[\[Source code\]](https://github.com/niftylab/laygo2) 
+[\[Documentation\]](https://laygo2.github.io/) 
+[\[Colab tutorial\]](https://colab.research.google.com/drive/1tpuUvqb6BujzZI6RBf2cFdAfMqBsxpep?usp=sharing) 
+
+LAYGO2 provides a rich and productive layout design environment for designers
+with several advanced concepts such templates and grids.
+
+For further documentation, see [https://laygo2.github.io/](https://laygo2.github.io/).
+
+List of developers and contributors:
+- Jaeduk Han
+- Taeho Shin
+- Dongjun Lee
+- Dongwhee Kim
+- Gaeryun Sung
+- Wookjin Shin
+- Yunseong Jo
+- Hyungjoo Park
+- Seonghyun Park
+- Youngmin Oh
+- Taeseung Kang
+- Curtis Mayberry
+
```

### Comparing `laygo2-0.5.6/examples/laygo2_tech/laygo2_tech_templates.py` & `laygo2-0.5.7/examples/laygo2_tech/laygo2_tech_templates.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,265 +1,265 @@
-# -*- coding: utf-8 -*-
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-"""Template library for the advanced example technology. (advtech)"""
-
-import numpy as np
-
-import laygo2.object.template
-import laygo2.object.physical
-import laygo2.object.database
-
-# Should be `import laygo2_tech as tech` for actual use.
-import laygo2.examples.laygo2_tech as tech
-
-# import laygo2_tech as tech
-
-
-tech_params = tech.tech_params
-
-# Primitive devices
-def mos_bbox_func(devtype, params):
-    """Computes x and y coordinate values from params."""
-    unit_size = tech_params["templates"]["mos"][devtype]["unit_size"]
-    xy0 = [0, 0]
-    xy1 = [unit_size[0] * params["nf"], unit_size[1]]
-    return np.array([xy0, xy1])
-
-
-def pmos_bbox_func(params):
-    return mos_bbox_func(devtype="pmos", params=params)
-
-
-def nmos_bbox_func(params):
-    return mos_bbox_func(devtype="nmos", params=params)
-
-
-def mos_pins_func(devtype, params):
-    """Generate a pin dictionary from params."""
-    unit_size = tech_params["templates"]["mos"][devtype]["unit_size"]
-    base_params = tech_params["templates"]["mos"][devtype]["pins"]
-    nf = params["nf"]
-    sd_swap = params["sd_swap"] if "sd_swap" in params.keys() else False
-    pins = dict()
-    lpin_default = "S"
-    rpin_default = "D"
-    if sd_swap:
-        lpin = rpin_default
-        rpin = lpin_default
-    else:
-        lpin = lpin_default
-        rpin = rpin_default
-    # pins starting from the left-most diffusion. Source if sd_swap=False, else Drain.
-    _elem = []
-    for fidx in range(nf // 2 + 1):
-        l_xy = base_params[lpin_default]["xy"] + np.array([fidx, 0]) * unit_size * 2
-        l_layer = base_params[lpin_default]["layer"]
-        _elem.append(laygo2.object.Pin(xy=l_xy, layer=l_layer, netname=lpin))
-    pins[lpin] = laygo2.object.Pin(
-        xy=base_params[lpin_default]["xy"], layer=l_layer, netname=lpin, elements=np.array(_elem)
-    )
-    # pins starting from the the other side of diffusion. Drain if sd_swap=False, else Source.
-    _elem = []
-    for fidx in range(((nf + 1) // 2)):
-        r_xy = base_params[rpin_default]["xy"] + np.array([fidx, 0]) * unit_size * 2
-        r_layer = base_params[rpin_default]["layer"]
-        _elem.append(laygo2.object.Pin(xy=r_xy, layer=r_layer, netname=rpin))
-    pins[rpin] = laygo2.object.Pin(
-        xy=base_params[rpin_default]["xy"], layer=r_layer, netname=rpin, elements=np.array(_elem)
-    )
-    # gate
-    g_xy = np.array([base_params["G"]["xy"][0], base_params["G"]["xy"][1] + np.array([nf - 1, 0]) * unit_size])
-    g_layer = base_params["G"]["layer"]
-    pins["G"] = laygo2.object.Pin(xy=g_xy, layer=g_layer, netname="G")
-    # g_xy = base_params['G']['xy'] + np.array([nf, 0]) * unit_size
-    # _elem = []
-    # for fidx in range(nf):
-    #    g_xy = base_params['G']['xy'] + np.array([fidx, 0]) * unit_size
-    #    g_layer = base_params['G']['layer']
-    #    _elem.append(laygo2.object.Pin(xy=g_xy, layer=g_layer, netname='G'))
-    # pins['G'] = laygo2.object.Pin(xy=base_params['G']['xy'], layer=g_layer, netname='G', elements=np.array(_elem))
-    return pins
-
-
-def pmos_pins_func(params):
-    return mos_pins_func(devtype="pmos", params=params)
-
-
-def nmos_pins_func(params):
-    return mos_pins_func(devtype="nmos", params=params)
-
-
-def mos_generate_func(devtype, name=None, shape=None, pitch=np.array([0, 0]), transform="R0", params=None):
-    """Generates an instance from the input parameters."""
-    # Compute parameters
-    nf = params["nf"] if "nf" in params.keys() else 1
-    unit_size = np.array(tech_params["templates"]["mos"][devtype]["unit_size"])
-
-    # Create the base mosfet structure.
-    nelements = dict()
-    for rn, rpar in tech_params["templates"]["mos"][devtype]["rects"].items():
-        # Computing loop index
-        idx_start = 0 if "idx_start" not in rpar else rpar["idx_start"]
-        idx_end = 0 if "idx_end" not in rpar else rpar["idx_end"]
-        idx_step = 1 if "idx_step" not in rpar else rpar["idx_step"]
-        for i in range(idx_start, nf + idx_end, idx_step):
-            rxy = rpar["xy"] + np.array([i, 0]) * unit_size
-            nelements[rn + str(i)] = laygo2.object.Rect(xy=rxy, layer=rpar["layer"], name=rn + str(i))
-    # if 'rects_merged' in tech_params['templates']['mos'][devtype]:
-    #    for rn, rpar in tech_params['templates']['mos'][devtype]['rects_merged'].items():
-    #        rxy = np.array([[rpar['xy'][0][0], rpar['xy'][0][1]], [rpar['xy'][1][0] + unit_size[0] * (nf - 1), rpar['xy'][1][1]]])
-    #        nelements[rn] = laygo2.object.Rect(xy=rxy, layer=rpar['layer'], name=rn)
-
-    # Create pins
-    pins = mos_pins_func(devtype=devtype, params=params)
-    nelements.update(pins)  # Add physical pin structures to the virtual object.
-
-    inst_unit_size = unit_size * np.array([nf, 1])
-    # Generate and return the final instance
-    inst = laygo2.object.VirtualInstance(
-        name=name,
-        xy=np.array([0, 0]),
-        libname="mylib",
-        cellname="myvcell_" + devtype,
-        native_elements=nelements,
-        shape=shape,
-        pitch=pitch,
-        transform=transform,
-        unit_size=inst_unit_size,
-        pins=pins,
-    )
-    return inst
-
-
-def pmos_generate_func(name=None, shape=None, pitch=np.array([0, 0]), transform="R0", params=None):
-    return mos_generate_func(devtype="pmos", name=name, shape=shape, pitch=pitch, transform=transform, params=params)
-
-
-def nmos_generate_func(name=None, shape=None, pitch=np.array([0, 0]), transform="R0", params=None):
-    return mos_generate_func(devtype="nmos", name=name, shape=shape, pitch=pitch, transform=transform, params=params)
-
-
-# Routing vias
-def via_generate_func(devtype, name=None, shape=None, pitch=np.array([0, 0]), transform="R0", params=None):
-    """Generates an instance from the input parameters."""
-    # Create the via structure.
-    nelements = dict()
-    for rn, rpar in tech_params["templates"]["via"][devtype]["rects"].items():
-        nelements[rn] = laygo2.object.Rect(xy=rpar["xy"], layer=rpar["layer"], name=rn)
-
-    # Generate and return the final instance
-    inst = laygo2.object.VirtualInstance(
-        name=name,
-        xy=np.array([0, 0]),
-        libname="mylib",
-        cellname="myvcell_devtype",
-        native_elements=nelements,
-        shape=shape,
-        pitch=pitch,
-        transform=transform,
-        unit_size=np.array([0, 0]),
-        pins=None,
-    )
-    return inst
-
-
-def via_r12_default_generate_func(name=None, shape=None, pitch=np.array([0, 0]), transform="R0", params=None):
-    return via_generate_func(
-        devtype="via_r12_default", name=name, shape=shape, pitch=pitch, transform=transform, params=params
-    )
-
-
-def via_r12_bottomplug_generate_func(name=None, shape=None, pitch=np.array([0, 0]), transform="R0", params=None):
-    return via_generate_func(
-        devtype="via_r12_bottomplug", name=name, shape=shape, pitch=pitch, transform=transform, params=params
-    )
-
-
-def via_r12_topplug_generate_func(name=None, shape=None, pitch=np.array([0, 0]), transform="R0", params=None):
-    return via_generate_func(
-        devtype="via_r12_topplug", name=name, shape=shape, pitch=pitch, transform=transform, params=params
-    )
-
-
-def via_r23_default_generate_func(name=None, shape=None, pitch=np.array([0, 0]), transform="R0", params=None):
-    return via_generate_func(
-        devtype="via_r23_default", name=name, shape=shape, pitch=pitch, transform=transform, params=params
-    )
-
-
-# Template library
-def load_templates():
-    """Load template to a template library object"""
-    tlib = laygo2.object.database.TemplateLibrary(name="advtech_templates")
-    # Transistors
-    # Transistor layouts are created in laygo and stored as a virtual instance.
-    tnmos = laygo2.object.template.UserDefinedTemplate(
-        name="nmos", bbox_func=nmos_bbox_func, pins_func=nmos_pins_func, generate_func=nmos_generate_func
-    )
-    tpmos = laygo2.object.template.UserDefinedTemplate(
-        name="pmos", bbox_func=pmos_bbox_func, pins_func=pmos_pins_func, generate_func=pmos_generate_func
-    )
-    tlib.append([tpmos, tnmos])
-    # Vias
-    # Via layouts are created in laygo and stored as a virtual instance.
-    # tvia_r12_0 = laygo2.object.template.NativeInstanceTemplate(libname='advtech_templates', cellname='via_r12_0')
-    # tlib.append([tvia_r12_0])
-    tvia_r12_default = laygo2.object.template.UserDefinedTemplate(
-        name="via_r12_default",
-        bbox_func=lambda params: np.array([0, 0]),
-        pins_func=lambda params: None,
-        generate_func=via_r12_default_generate_func,
-    )
-    tlib.append([tvia_r12_default])
-    tvia_r12_topplug = laygo2.object.template.UserDefinedTemplate(
-        name="via_r12_topplug",
-        bbox_func=lambda params: np.array([0, 0]),
-        pins_func=lambda params: None,
-        generate_func=via_r12_topplug_generate_func,
-    )
-    tlib.append([tvia_r12_topplug])
-    tvia_r12_bottomplug = laygo2.object.template.UserDefinedTemplate(
-        name="via_r12_bottomplug",
-        bbox_func=lambda params: np.array([0, 0]),
-        pins_func=lambda params: None,
-        generate_func=via_r12_bottomplug_generate_func,
-    )
-    tlib.append([tvia_r12_bottomplug])
-    tvia_r23_default = laygo2.object.template.UserDefinedTemplate(
-        name="via_r23_default",
-        bbox_func=lambda params: np.array([0, 0]),
-        pins_func=lambda params: None,
-        generate_func=via_r23_default_generate_func,
-    )
-    tlib.append([tvia_r23_default])
-    return tlib
-
-
-# Tests
-if __name__ == "__main__":
-    # Create templates.
-    print("Create templates")
-    templates = load_templates()
-    print(templates["nmos"])
-    print(templates["pmos"])
+# -*- coding: utf-8 -*-
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+"""Template library for the advanced example technology. (advtech)"""
+
+import numpy as np
+
+import laygo2.object.template
+import laygo2.object.physical
+import laygo2.object.database
+
+# Should be `import laygo2_tech as tech` for actual use.
+import laygo2.examples.laygo2_tech as tech
+
+# import laygo2_tech as tech
+
+
+tech_params = tech.tech_params
+
+# Primitive devices
+def mos_bbox_func(devtype, params):
+    """Computes x and y coordinate values from params."""
+    unit_size = tech_params["templates"]["mos"][devtype]["unit_size"]
+    xy0 = [0, 0]
+    xy1 = [unit_size[0] * params["nf"], unit_size[1]]
+    return np.array([xy0, xy1])
+
+
+def pmos_bbox_func(params):
+    return mos_bbox_func(devtype="pmos", params=params)
+
+
+def nmos_bbox_func(params):
+    return mos_bbox_func(devtype="nmos", params=params)
+
+
+def mos_pins_func(devtype, params):
+    """Generate a pin dictionary from params."""
+    unit_size = tech_params["templates"]["mos"][devtype]["unit_size"]
+    base_params = tech_params["templates"]["mos"][devtype]["pins"]
+    nf = params["nf"]
+    sd_swap = params["sd_swap"] if "sd_swap" in params.keys() else False
+    pins = dict()
+    lpin_default = "S"
+    rpin_default = "D"
+    if sd_swap:
+        lpin = rpin_default
+        rpin = lpin_default
+    else:
+        lpin = lpin_default
+        rpin = rpin_default
+    # pins starting from the left-most diffusion. Source if sd_swap=False, else Drain.
+    _elem = []
+    for fidx in range(nf // 2 + 1):
+        l_xy = base_params[lpin_default]["xy"] + np.array([fidx, 0]) * unit_size * 2
+        l_layer = base_params[lpin_default]["layer"]
+        _elem.append(laygo2.object.Pin(xy=l_xy, layer=l_layer, netname=lpin))
+    pins[lpin] = laygo2.object.Pin(
+        xy=base_params[lpin_default]["xy"], layer=l_layer, netname=lpin, elements=np.array(_elem)
+    )
+    # pins starting from the the other side of diffusion. Drain if sd_swap=False, else Source.
+    _elem = []
+    for fidx in range(((nf + 1) // 2)):
+        r_xy = base_params[rpin_default]["xy"] + np.array([fidx, 0]) * unit_size * 2
+        r_layer = base_params[rpin_default]["layer"]
+        _elem.append(laygo2.object.Pin(xy=r_xy, layer=r_layer, netname=rpin))
+    pins[rpin] = laygo2.object.Pin(
+        xy=base_params[rpin_default]["xy"], layer=r_layer, netname=rpin, elements=np.array(_elem)
+    )
+    # gate
+    g_xy = np.array([base_params["G"]["xy"][0], base_params["G"]["xy"][1] + np.array([nf - 1, 0]) * unit_size])
+    g_layer = base_params["G"]["layer"]
+    pins["G"] = laygo2.object.Pin(xy=g_xy, layer=g_layer, netname="G")
+    # g_xy = base_params['G']['xy'] + np.array([nf, 0]) * unit_size
+    # _elem = []
+    # for fidx in range(nf):
+    #    g_xy = base_params['G']['xy'] + np.array([fidx, 0]) * unit_size
+    #    g_layer = base_params['G']['layer']
+    #    _elem.append(laygo2.object.Pin(xy=g_xy, layer=g_layer, netname='G'))
+    # pins['G'] = laygo2.object.Pin(xy=base_params['G']['xy'], layer=g_layer, netname='G', elements=np.array(_elem))
+    return pins
+
+
+def pmos_pins_func(params):
+    return mos_pins_func(devtype="pmos", params=params)
+
+
+def nmos_pins_func(params):
+    return mos_pins_func(devtype="nmos", params=params)
+
+
+def mos_generate_func(devtype, name=None, shape=None, pitch=np.array([0, 0]), transform="R0", params=None):
+    """Generates an instance from the input parameters."""
+    # Compute parameters
+    nf = params["nf"] if "nf" in params.keys() else 1
+    unit_size = np.array(tech_params["templates"]["mos"][devtype]["unit_size"])
+
+    # Create the base mosfet structure.
+    nelements = dict()
+    for rn, rpar in tech_params["templates"]["mos"][devtype]["rects"].items():
+        # Computing loop index
+        idx_start = 0 if "idx_start" not in rpar else rpar["idx_start"]
+        idx_end = 0 if "idx_end" not in rpar else rpar["idx_end"]
+        idx_step = 1 if "idx_step" not in rpar else rpar["idx_step"]
+        for i in range(idx_start, nf + idx_end, idx_step):
+            rxy = rpar["xy"] + np.array([i, 0]) * unit_size
+            nelements[rn + str(i)] = laygo2.object.Rect(xy=rxy, layer=rpar["layer"], name=rn + str(i))
+    # if 'rects_merged' in tech_params['templates']['mos'][devtype]:
+    #    for rn, rpar in tech_params['templates']['mos'][devtype]['rects_merged'].items():
+    #        rxy = np.array([[rpar['xy'][0][0], rpar['xy'][0][1]], [rpar['xy'][1][0] + unit_size[0] * (nf - 1), rpar['xy'][1][1]]])
+    #        nelements[rn] = laygo2.object.Rect(xy=rxy, layer=rpar['layer'], name=rn)
+
+    # Create pins
+    pins = mos_pins_func(devtype=devtype, params=params)
+    nelements.update(pins)  # Add physical pin structures to the virtual object.
+
+    inst_unit_size = unit_size * np.array([nf, 1])
+    # Generate and return the final instance
+    inst = laygo2.object.VirtualInstance(
+        name=name,
+        xy=np.array([0, 0]),
+        libname="mylib",
+        cellname="myvcell_" + devtype,
+        native_elements=nelements,
+        shape=shape,
+        pitch=pitch,
+        transform=transform,
+        unit_size=inst_unit_size,
+        pins=pins,
+    )
+    return inst
+
+
+def pmos_generate_func(name=None, shape=None, pitch=np.array([0, 0]), transform="R0", params=None):
+    return mos_generate_func(devtype="pmos", name=name, shape=shape, pitch=pitch, transform=transform, params=params)
+
+
+def nmos_generate_func(name=None, shape=None, pitch=np.array([0, 0]), transform="R0", params=None):
+    return mos_generate_func(devtype="nmos", name=name, shape=shape, pitch=pitch, transform=transform, params=params)
+
+
+# Routing vias
+def via_generate_func(devtype, name=None, shape=None, pitch=np.array([0, 0]), transform="R0", params=None):
+    """Generates an instance from the input parameters."""
+    # Create the via structure.
+    nelements = dict()
+    for rn, rpar in tech_params["templates"]["via"][devtype]["rects"].items():
+        nelements[rn] = laygo2.object.Rect(xy=rpar["xy"], layer=rpar["layer"], name=rn)
+
+    # Generate and return the final instance
+    inst = laygo2.object.VirtualInstance(
+        name=name,
+        xy=np.array([0, 0]),
+        libname="mylib",
+        cellname="myvcell_devtype",
+        native_elements=nelements,
+        shape=shape,
+        pitch=pitch,
+        transform=transform,
+        unit_size=np.array([0, 0]),
+        pins=None,
+    )
+    return inst
+
+
+def via_r12_default_generate_func(name=None, shape=None, pitch=np.array([0, 0]), transform="R0", params=None):
+    return via_generate_func(
+        devtype="via_r12_default", name=name, shape=shape, pitch=pitch, transform=transform, params=params
+    )
+
+
+def via_r12_bottomplug_generate_func(name=None, shape=None, pitch=np.array([0, 0]), transform="R0", params=None):
+    return via_generate_func(
+        devtype="via_r12_bottomplug", name=name, shape=shape, pitch=pitch, transform=transform, params=params
+    )
+
+
+def via_r12_topplug_generate_func(name=None, shape=None, pitch=np.array([0, 0]), transform="R0", params=None):
+    return via_generate_func(
+        devtype="via_r12_topplug", name=name, shape=shape, pitch=pitch, transform=transform, params=params
+    )
+
+
+def via_r23_default_generate_func(name=None, shape=None, pitch=np.array([0, 0]), transform="R0", params=None):
+    return via_generate_func(
+        devtype="via_r23_default", name=name, shape=shape, pitch=pitch, transform=transform, params=params
+    )
+
+
+# Template library
+def load_templates():
+    """Load template to a template library object"""
+    tlib = laygo2.object.database.TemplateLibrary(name="advtech_templates")
+    # Transistors
+    # Transistor layouts are created in laygo and stored as a virtual instance.
+    tnmos = laygo2.object.template.UserDefinedTemplate(
+        name="nmos", bbox_func=nmos_bbox_func, pins_func=nmos_pins_func, generate_func=nmos_generate_func
+    )
+    tpmos = laygo2.object.template.UserDefinedTemplate(
+        name="pmos", bbox_func=pmos_bbox_func, pins_func=pmos_pins_func, generate_func=pmos_generate_func
+    )
+    tlib.append([tpmos, tnmos])
+    # Vias
+    # Via layouts are created in laygo and stored as a virtual instance.
+    # tvia_r12_0 = laygo2.object.template.NativeInstanceTemplate(libname='advtech_templates', cellname='via_r12_0')
+    # tlib.append([tvia_r12_0])
+    tvia_r12_default = laygo2.object.template.UserDefinedTemplate(
+        name="via_r12_default",
+        bbox_func=lambda params: np.array([0, 0]),
+        pins_func=lambda params: None,
+        generate_func=via_r12_default_generate_func,
+    )
+    tlib.append([tvia_r12_default])
+    tvia_r12_topplug = laygo2.object.template.UserDefinedTemplate(
+        name="via_r12_topplug",
+        bbox_func=lambda params: np.array([0, 0]),
+        pins_func=lambda params: None,
+        generate_func=via_r12_topplug_generate_func,
+    )
+    tlib.append([tvia_r12_topplug])
+    tvia_r12_bottomplug = laygo2.object.template.UserDefinedTemplate(
+        name="via_r12_bottomplug",
+        bbox_func=lambda params: np.array([0, 0]),
+        pins_func=lambda params: None,
+        generate_func=via_r12_bottomplug_generate_func,
+    )
+    tlib.append([tvia_r12_bottomplug])
+    tvia_r23_default = laygo2.object.template.UserDefinedTemplate(
+        name="via_r23_default",
+        bbox_func=lambda params: np.array([0, 0]),
+        pins_func=lambda params: None,
+        generate_func=via_r23_default_generate_func,
+    )
+    tlib.append([tvia_r23_default])
+    return tlib
+
+
+# Tests
+if __name__ == "__main__":
+    # Create templates.
+    print("Create templates")
+    templates = load_templates()
+    print(templates["nmos"])
+    print(templates["pmos"])
```

### Comparing `laygo2-0.5.6/examples/laygo2_tech/__init__.py` & `laygo2-0.5.7/examples/laygo2_tech/__init__.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,49 +1,49 @@
-# -*- coding: utf-8 -*-
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-"""Advanced example technology module.
-
-WARNING: This technology module is outdated. Use laygo2_tech_quick_start instead.
-"""
-
-import yaml
-import os
-
-# Technology parameters
-# should be tech_param_path = "laygo2_tech/laygo2_tech.yaml" for actual use
-tech_param_path = "laygo2/examples/laygo2_tech/laygo2_tech.yaml"
-"""
-path = os.path.abspath(__file__)
-dir_path = os.path.dirname(path)
-tech_param_path = dir_path+"/laygo2_tech.yaml"
-"""
-
-with open(tech_param_path, "r") as stream:
-    try:
-        tech_params = yaml.safe_load(stream)
-    except yaml.YAMLError as exc:
-        print(exc)
-
-from .laygo2_tech_templates import load_templates
-from .laygo2_tech_grids import load_grids
+# -*- coding: utf-8 -*-
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+"""Advanced example technology module.
+
+WARNING: This technology module is outdated. Use laygo2_tech_quick_start instead.
+"""
+
+import yaml
+import os
+
+# Technology parameters
+# should be tech_param_path = "laygo2_tech/laygo2_tech.yaml" for actual use
+tech_param_path = "laygo2/examples/laygo2_tech/laygo2_tech.yaml"
+"""
+path = os.path.abspath(__file__)
+dir_path = os.path.dirname(path)
+tech_param_path = dir_path+"/laygo2_tech.yaml"
+"""
+
+with open(tech_param_path, "r") as stream:
+    try:
+        tech_params = yaml.safe_load(stream)
+    except yaml.YAMLError as exc:
+        print(exc)
+
+from .laygo2_tech_templates import load_templates
+from .laygo2_tech_grids import load_grids
```

### Comparing `laygo2-0.5.6/examples/laygo2_tech/laygo2_tech_grids.py` & `laygo2-0.5.7/examples/laygo2_tech/laygo2_tech_grids.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,83 +1,83 @@
-# -*- coding: utf-8 -*-
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-"""Grid library for the advanced example technology (advtech)."""
-
-import laygo2.object.database
-import laygo2.object.grid
-#Should be `import laygo2_tech as tech` for actual use.
-import laygo2.examples.laygo2_tech as tech
-#import laygo2_tech as tech
-
-
-tech_params = tech.tech_params
-
-# Grid library
-def load_grids(templates):
-    """
-    Load grids to a grid library object.
-
-    Parameters
-    ----------
-    templates: laygo2.object.database.TemplateLibrary
-        The template library object that contains via templates.
-    """
-    glib = laygo2.object.database.GridLibrary(name='advtech_grids')
-    for gname, grid in tech_params['grids'].items():
-        gv = laygo2.object.grid.OneDimGrid(name=gname + '_v', scope=grid['vertical']['scope'],
-                                           elements=grid['vertical']['elements'])
-        gh = laygo2.object.grid.OneDimGrid(name=gname + '_h', scope=grid['horizontal']['scope'],
-                                           elements=grid['horizontal']['elements'])
-        if grid['type'] == 'placement':  # placement grid
-            g = laygo2.object.grid.PlacementGrid(name=gname, vgrid=gv, hgrid=gh)
-            glib.append(g)
-        elif grid['type'] == 'routing':  # routing grid
-            vwidth = laygo2.object.grid.CircularMapping(elements=grid['vertical']['width'])
-            hwidth = laygo2.object.grid.CircularMapping(elements=grid['horizontal']['width'])
-            vextension = laygo2.object.grid.CircularMapping(elements=grid['vertical']['extension'])
-            hextension = laygo2.object.grid.CircularMapping(elements=grid['horizontal']['extension'])
-            vlayer = laygo2.object.grid.CircularMapping(elements=grid['vertical']['layer'], dtype=object)
-            hlayer = laygo2.object.grid.CircularMapping(elements=grid['horizontal']['layer'], dtype=object)
-            pin_vlayer = laygo2.object.grid.CircularMapping(elements=grid['vertical']['pin_layer'], dtype=object)
-            pin_hlayer = laygo2.object.grid.CircularMapping(elements=grid['horizontal']['pin_layer'], dtype=object)
-            primary_grid = grid['primary_grid']
-            # Create the via map defined by the yaml file.
-            vmap_original = grid['via']['map']  # viamap defined in the yaml file.
-            vmap_mapped = list()  # map template objects to the via map.
-            for vmap_org_row in vmap_original:
-                vmap_mapped_row = []
-                for vmap_org_elem in vmap_org_row:
-                    vmap_mapped_row.append(templates[vmap_org_elem])
-                vmap_mapped.append(vmap_mapped_row)
-            viamap = laygo2.object.grid.CircularMappingArray(elements=vmap_mapped, dtype=object)
-
-            g = laygo2.object.grid.RoutingGrid(name=gname, vgrid=gv, hgrid=gh,
-                                               vwidth=vwidth, hwidth=hwidth,
-                                               vextension=vextension, hextension=hextension,
-                                               vlayer=vlayer, hlayer=hlayer,
-                                               pin_vlayer=pin_vlayer, pin_hlayer=pin_hlayer,
-                                               viamap=viamap, primary_grid=primary_grid)
-            glib.append(g)
-    return glib
-
+# -*- coding: utf-8 -*-
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+"""Grid library for the advanced example technology (advtech)."""
+
+import laygo2.object.database
+import laygo2.object.grid
+#Should be `import laygo2_tech as tech` for actual use.
+import laygo2.examples.laygo2_tech as tech
+#import laygo2_tech as tech
+
+
+tech_params = tech.tech_params
+
+# Grid library
+def load_grids(templates):
+    """
+    Load grids to a grid library object.
+
+    Parameters
+    ----------
+    templates: laygo2.object.database.TemplateLibrary
+        The template library object that contains via templates.
+    """
+    glib = laygo2.object.database.GridLibrary(name='advtech_grids')
+    for gname, grid in tech_params['grids'].items():
+        gv = laygo2.object.grid.OneDimGrid(name=gname + '_v', scope=grid['vertical']['scope'],
+                                           elements=grid['vertical']['elements'])
+        gh = laygo2.object.grid.OneDimGrid(name=gname + '_h', scope=grid['horizontal']['scope'],
+                                           elements=grid['horizontal']['elements'])
+        if grid['type'] == 'placement':  # placement grid
+            g = laygo2.object.grid.PlacementGrid(name=gname, vgrid=gv, hgrid=gh)
+            glib.append(g)
+        elif grid['type'] == 'routing':  # routing grid
+            vwidth = laygo2.object.grid.CircularMapping(elements=grid['vertical']['width'])
+            hwidth = laygo2.object.grid.CircularMapping(elements=grid['horizontal']['width'])
+            vextension = laygo2.object.grid.CircularMapping(elements=grid['vertical']['extension'])
+            hextension = laygo2.object.grid.CircularMapping(elements=grid['horizontal']['extension'])
+            vlayer = laygo2.object.grid.CircularMapping(elements=grid['vertical']['layer'], dtype=object)
+            hlayer = laygo2.object.grid.CircularMapping(elements=grid['horizontal']['layer'], dtype=object)
+            pin_vlayer = laygo2.object.grid.CircularMapping(elements=grid['vertical']['pin_layer'], dtype=object)
+            pin_hlayer = laygo2.object.grid.CircularMapping(elements=grid['horizontal']['pin_layer'], dtype=object)
+            primary_grid = grid['primary_grid']
+            # Create the via map defined by the yaml file.
+            vmap_original = grid['via']['map']  # viamap defined in the yaml file.
+            vmap_mapped = list()  # map template objects to the via map.
+            for vmap_org_row in vmap_original:
+                vmap_mapped_row = []
+                for vmap_org_elem in vmap_org_row:
+                    vmap_mapped_row.append(templates[vmap_org_elem])
+                vmap_mapped.append(vmap_mapped_row)
+            viamap = laygo2.object.grid.CircularMappingArray(elements=vmap_mapped, dtype=object)
+
+            g = laygo2.object.grid.RoutingGrid(name=gname, vgrid=gv, hgrid=gh,
+                                               vwidth=vwidth, hwidth=hwidth,
+                                               vextension=vextension, hextension=hextension,
+                                               vlayer=vlayer, hlayer=hlayer,
+                                               pin_vlayer=pin_vlayer, pin_hlayer=pin_hlayer,
+                                               viamap=viamap, primary_grid=primary_grid)
+            glib.append(g)
+    return glib
+
```

### Comparing `laygo2-0.5.6/laygo2.egg-info/SOURCES.txt` & `laygo2-0.5.7/laygo2.egg-info/SOURCES.txt`

 * *Files 14% similar despite different names*

```diff
@@ -12,18 +12,21 @@
 laygo2.egg-info/PKG-INFO
 laygo2.egg-info/SOURCES.txt
 laygo2.egg-info/dependency_links.txt
 laygo2.egg-info/top_level.txt
 laygo2/interface/__init__.py
 laygo2/interface/bag.py
 laygo2/interface/gds.py
+laygo2/interface/gds_default.layermap
 laygo2/interface/gdspy.py
 laygo2/interface/magic.py
+laygo2/interface/magic_export.tcl
 laygo2/interface/mpl.py
 laygo2/interface/skill.py
+laygo2/interface/skill_export.il
 laygo2/interface/skillbridge.py
 laygo2/interface/yaml.py
 laygo2/object/__init__.py
 laygo2/object/database.py
 laygo2/object/physical.py
 laygo2/object/grid/__init__.py
 laygo2/object/grid/core.py
@@ -35,10 +38,9 @@
 laygo2/object/technology/nifty.py
 laygo2/object/template/__init__.py
 laygo2/object/template/core.py
 laygo2/object/template/routing.py
 laygo2/object/template/tile.py
 laygo2/util/__init__.py
 laygo2/util/transform.py
-laygo2_tech_quick_start/__init__.py
-laygo2_tech_quick_start/laygo2_tech_grids.py
-laygo2_tech_quick_start/laygo2_tech_templates.py
+tests/test_manual.py
+tests/test_object.py
```

### Comparing `laygo2-0.5.6/laygo2.egg-info/PKG-INFO` & `laygo2-0.5.7/laygo2.egg-info/PKG-INFO`

 * *Files 17% similar despite different names*

```diff
@@ -1,71 +1,71 @@
-Metadata-Version: 2.1
-Name: laygo2
-Version: 0.5.6
-Summary: LAYout with Gridded Object 2 - A Python Package for Scripted IC Layout Generation Flow
-Home-page: https://github.com/niftylab/laygo2
-Author: Jaeduk Han
-License: BSD 3-Clause License
-
-Copyright (c) 2019, jdhan
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-1. Redistributions of source code must retain the above copyright notice, this
-   list of conditions and the following disclaimer.
-
-2. Redistributions in binary form must reproduce the above copyright notice,
-   this list of conditions and the following disclaimer in the documentation
-   and/or other materials provided with the distribution.
-
-3. Neither the name of the copyright holder nor the names of its
-   contributors may be used to endorse or promote products derived from
-   this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-Description: # laygo2
-        
-        [![PyPI version](https://badge.fury.io/py/laygo2.svg?)](https://pypi.org/project/laygo2/)
-        
-        (The commit history is cleaned up on 6-27-2022)
-        
-        The LAYout with Gridded Object 2 (laygo2) is an automated layout generation framework
-        for custom integrated circuits. 
-        [\[Source code\]](https://github.com/niftylab/laygo2) 
-        [\[Documentation\]](https://laygo2.github.io/) 
-        [\[Colab tutorial\]](https://colab.research.google.com/drive/1tpuUvqb6BujzZI6RBf2cFdAfMqBsxpep?usp=sharing) 
-        
-        LAYGO2 provides a rich and productive layout design environment for designers
-        with several advanced concepts such templates and grids.
-        
-        For further documentation, see [https://laygo2.github.io/](https://laygo2.github.io/).
-        
-        List of developers and contributors:
-        - Jaeduk Han
-        - Taeho Shin
-        - Dongjun Lee
-        - Dongwhee Kim
-        - Gaeryun Sung
-        - Wookjin Shin
-        - Yunseong Jo
-        - Hyungjoo Park
-        - Seonghyun Park
-        - Youngmin Oh
-        - Taeseung Kang
-        - Curtis Mayberry
-        
-        
-Platform: UNKNOWN
-Requires-Python: >=3.5
-Description-Content-Type: text/markdown
+Metadata-Version: 2.1
+Name: laygo2
+Version: 0.5.7
+Summary: LAYout with Gridded Object 2 - A Python Package for Scripted IC Layout Generation Flow
+Home-page: https://github.com/niftylab/laygo2
+Author: Jaeduk Han
+License: BSD 3-Clause License
+        
+        Copyright (c) 2019, jdhan
+        All rights reserved.
+        
+        Redistribution and use in source and binary forms, with or without
+        modification, are permitted provided that the following conditions are met:
+        
+        1. Redistributions of source code must retain the above copyright notice, this
+           list of conditions and the following disclaimer.
+        
+        2. Redistributions in binary form must reproduce the above copyright notice,
+           this list of conditions and the following disclaimer in the documentation
+           and/or other materials provided with the distribution.
+        
+        3. Neither the name of the copyright holder nor the names of its
+           contributors may be used to endorse or promote products derived from
+           this software without specific prior written permission.
+        
+        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+        AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+        IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+        DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+        FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+        DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+        SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+        CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+        OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+        OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+        
+Requires-Python: >=3.5
+Description-Content-Type: text/markdown
+License-File: LICENSE
+
+# laygo2
+
+[![PyPI version](https://badge.fury.io/py/laygo2.svg?)](https://pypi.org/project/laygo2/)
+
+(The commit history is cleaned up on 6-27-2022)
+
+The LAYout with Gridded Object 2 (laygo2) is an automated layout generation framework
+for custom integrated circuits. 
+[\[Source code\]](https://github.com/niftylab/laygo2) 
+[\[Documentation\]](https://laygo2.github.io/) 
+[\[Colab tutorial\]](https://colab.research.google.com/drive/1tpuUvqb6BujzZI6RBf2cFdAfMqBsxpep?usp=sharing) 
+
+LAYGO2 provides a rich and productive layout design environment for designers
+with several advanced concepts such templates and grids.
+
+For further documentation, see [https://laygo2.github.io/](https://laygo2.github.io/).
+
+List of developers and contributors:
+- Jaeduk Han
+- Taeho Shin
+- Dongjun Lee
+- Dongwhee Kim
+- Gaeryun Sung
+- Wookjin Shin
+- Yunseong Jo
+- Hyungjoo Park
+- Seonghyun Park
+- Youngmin Oh
+- Taeseung Kang
+- Curtis Mayberry
+
```

### Comparing `laygo2-0.5.6/setup.py` & `laygo2-0.5.7/setup.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,41 +1,41 @@
-# -*- coding: utf-8 -*-
-
-"""
-Pypi update instruction:
-1) update the version number in setup.py.
-2) run 'python setup.py sdist bdist_wheel' to build whl.
-3) run 'python -m twine upload dist/*'.
-4) type username and password.
-
-"""
-
-from setuptools import setup, find_packages
-
-with open("README.md") as f:
-    readme = f.read()
-
-with open("LICENSE") as f:
-    license = f.read()
-
-setup(
-    name="laygo2",
-    version="0.5.6",
-    author="Jaeduk Han",
-    description="LAYout with Gridded Object 2 - A Python Package for Scripted IC Layout Generation Flow",
-    long_description=readme,
-    long_description_content_type="text/markdown",
-    url="https://github.com/niftylab/laygo2",  # project address
-    license=license,
-    packages=find_packages(exclude=("tests", "docs", "laygo2_tech_quick_start", "laygo2_tech")),
-    package_data={
-        "": [
-            "interface/skill_export.il",
-            "interface/magic_export.tcl",
-            "interface/gds_default.layermap",
-            "examples/laygo2_tech/laygo2_tech.yaml",
-            "examples/laygo2_tech/laygo2_tech.layermap",
-        ]
-    },
-    include_package_data=True,
-    python_requires=">=3.5",
-)
+# -*- coding: utf-8 -*-
+
+"""
+Pypi update instruction:
+1) update the version number in setup.py.
+2) run 'python setup.py sdist bdist_wheel' to build whl.
+3) run 'python -m twine upload dist/*'.
+4) type username and password.
+
+"""
+
+from setuptools import setup, find_packages
+
+with open("README.md") as f:
+    readme = f.read()
+
+with open("LICENSE") as f:
+    license = f.read()
+
+setup(
+    name="laygo2",
+    version="0.5.7",
+    author="Jaeduk Han",
+    description="LAYout with Gridded Object 2 - A Python Package for Scripted IC Layout Generation Flow",
+    long_description=readme,
+    long_description_content_type="text/markdown",
+    url="https://github.com/niftylab/laygo2",  # project address
+    license=license,
+    packages=find_packages(exclude=("tests", "docs", "laygo2_tech_quick_start", "laygo2_tech")),
+    package_data={
+        "": [
+            "interface/skill_export.il",
+            "interface/magic_export.tcl",
+            "interface/gds_default.layermap",
+            "examples/laygo2_tech/laygo2_tech.yaml",
+            "examples/laygo2_tech/laygo2_tech.layermap",
+        ]
+    },
+    include_package_data=True,
+    python_requires=">=3.5",
+)
```

### Comparing `laygo2-0.5.6/laygo2_tech_quick_start/__init__.py` & `laygo2-0.5.7/laygo2/object/technology/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,47 +1,32 @@
-# -*- coding: utf-8 -*-
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-"""Advanced example technology module"""
-
-import yaml
-import os
-
-# Technology parameters
-# should be tech_param_path = "laygo2_tech/laygo2_tech.yaml" for actual use
-# tech_param_path = "laygo2/examples/laygo2_tech/laygo2_tech.yaml"
-tech_param_path = "laygo2_tech_quick_start/laygo2_tech.yaml"
-"""
-path = os.path.abspath(__file__)
-dir_path = os.path.dirname(path)
-tech_param_path = dir_path+"/laygo2_tech.yaml"
-"""
-
-with open(tech_param_path, "r") as stream:
-    try:
-        tech_params = yaml.safe_load(stream)
-    except yaml.YAMLError as exc:
-        print(exc)
-
-from .laygo2_tech_templates import load_templates
-from .laygo2_tech_grids import load_grids
+# -*- coding: utf-8 -*-
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+"""
+**laygo2.object.technology** module implements classes for technology parameters and objects.
+"""
+
+from . import *
+from .core import *
+from .nifty import *
+
```

### Comparing `laygo2-0.5.6/laygo2/util/__init__.py` & `laygo2-0.5.7/laygo2/util/__init__.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,28 +1,28 @@
-# -*- coding: utf-8 -*-
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-"""laygo2 utility package implements various useful functions for layout manipulations."""
-
-from laygo2.util import *
-
+# -*- coding: utf-8 -*-
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+"""laygo2 utility package implements various useful functions for layout manipulations."""
+
+from laygo2.util import *
+
```

### Comparing `laygo2-0.5.6/laygo2/object/technology/__init__.py` & `laygo2-0.5.7/laygo2/object/template/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,32 +1,32 @@
-# -*- coding: utf-8 -*-
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-"""
-**laygo2.object.technology** module implements classes for technology parameters and objects.
-"""
-
-from . import *
-from .core import *
-from .nifty import *
-
+# -*- coding: utf-8 -*-
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+"""
+**laygo2.object.template** module implements classes for various layout template objects.
+"""
+
+from . import *
+from .core import *
+from .tile import *
+from .routing import *
```

### Comparing `laygo2-0.5.6/laygo2/object/technology/nifty.py` & `laygo2-0.5.7/laygo2/object/technology/nifty.py`

 * *Ordering differences only*

 * *Files 9% similar despite different names*

```diff
@@ -1,942 +1,942 @@
-#!/usr/bin/python
-########################################################################################################################
-#
-# Copyright (c) 2014, Regents of the University of California
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-from laygo2.object import *
-from laygo2.object.technology import BaseTechnology
-from laygo2.object.template.tile import TileMOSTemplate, TileTapTemplate, TileSpaceTemplate
-
-class NiftyTechnology(BaseTechnology):
-    """
-    Class for defining technology parameters and objects in "Niftylab-style".
-    This greatly streamlines the setup of templates and grids for new technologies,
-    and generators constructed based-on the "Niftylab-style" templates cna be reused 
-    with minimal modifications.
-
-    However, this comes at the expense of supporting diverse layout styles, particularly 
-    those with unique polygon shapes.
-    """
-    
-    def load_tech_templates(self, libname=None):
-        """
-        Load templates and construct a template library object.
-
-        Parameters
-        ----------
-            libname: optional, str
-                The name of library to be loaded. 
-                By default, the first library in tech_params['templates'] is used.
-        """
-        # Library name
-        if libname is None:
-            ln = list(self.tech_params['templates'].keys())[0]
-        else:
-            ln = libname
-
-        # Native templates and grids
-        ntemplates = self.tech_params['templates'][ln]
-        ngrids     = self.tech_params['grids'][ln]
-         
-        # Template library
-        tlib    = laygo2.object.database.TemplateLibrary(name = ln)
-    
-        # 1. Load native templates
-        for tn, tdict in ntemplates.items():
-            # bounding box
-            bbox = np.array(tdict['xy'])
-            # pins
-            pins = None
-            if 'pins' in tdict:
-                pins = dict()
-                for pn, _pdict in tdict['pins'].items():
-                    pins[pn] = laygo2.object.Pin(xy=_pdict['xy'], layer=_pdict['layer'], netname=pn)
-        
-            t = laygo2.object.NativeInstanceTemplate(libname=libname, cellname=tn, bbox=bbox, pins=pins)
-            tlib.append(t)
-    
-
-        # 2. Construct UserDefinedTemplate objects derived from native templates
-        glib = self.load_tech_grids(templates=tlib)
-
-        # Mapping parameters for tile templates
-        placement_pattern = ["gbndl", "bndl", "dmyl",  "core", "dmyr", "bndr", "gbndr"]
-        transform_pattern = dict( gbndl = "R0", dmyl = "R0", bndl  = "R0", core  = "R0",
-                                  dmyr = "MY", bndr  = "R0", gbndr = "R0" )
-        routing_map       = dict( G = 3, S = 1, D = 2, G_extension0_x = [None,None], 
-                                  S_extension0_m = [None, None], D_extension0_m = [None, None])
-    
-        nmos_fast = dict(
-            core  = 'nmos4_fast_center_nf2',
-            dmyr  = 'nmos4_fast_dmy_nf2',
-            dmyl  = 'nmos4_fast_dmy_nf2',
-            bndr  = 'nmos4_fast_boundary',
-            bndl  = 'nmos4_fast_boundary',
-            gbndr = 'nmos4_fast_boundary',
-            gbndl = 'nmos4_fast_boundary',
-            grid  = "routing_12_mos",
-        )
-
-        pmos_fast = dict(
-            core  = 'pmos4_fast_center_nf2',
-            dmyr  = 'pmos4_fast_dmy_nf2',
-            dmyl  = 'pmos4_fast_dmy_nf2',
-            bndr  = 'pmos4_fast_boundary',
-            bndl  = 'pmos4_fast_boundary',
-            gbndr = 'pmos4_fast_boundary',
-            gbndl = 'pmos4_fast_boundary',
-            grid  = "routing_12_mos",
-        )
-
-        ptap_fast = dict(
-            core  = 'ptap_fast_center_nf2_v2',
-            dmyr  = 'nmos4_fast_dmy_nf2',
-            dmyl  = 'nmos4_fast_dmy_nf2',
-            bndr  = 'ptap_fast_boundary',
-            bndl  = 'ptap_fast_boundary',
-            gbndr = 'ptap_fast_boundary',
-            gbndl = 'ptap_fast_boundary',
-            grid  = "routing_12_mos",
-        )
-
-        ntap_fast = dict(
-            core  = 'ntap_fast_center_nf2_v2',
-            dmyr  = 'pmos4_fast_dmy_nf2',
-            dmyl  = 'pmos4_fast_dmy_nf2',
-            bndr  = 'ntap_fast_boundary',
-            bndl  = 'ntap_fast_boundary',
-            gbndr = 'ntap_fast_boundary',
-            gbndl = 'ntap_fast_boundary',
-
-            grid  = "routing_12_mos",
-        )
-  
-        nspace_fast = dict(
-            core  = 'nmos4_fast_space_2x',
-            dmyr  = 'nmos4_fast_space_1x',
-            dmyl  = 'nmos4_fast_space_1x',
-            bndr  = 'nmos4_fast_boundary',
-            bndl  = 'nmos4_fast_boundary',
-            gbndr = 'nmos4_fast_boundary',
-            gbndl = 'nmos4_fast_boundary',
-            grid  = "routing_12_mos",
-        )
-
-        pspace_fast = dict(
-            core  = 'pmos4_fast_space_2x',
-            dmyr  = 'pmos4_fast_space_1x',
-            dmyl  = 'pmos4_fast_space_1x',
-            bndr  = 'pmos4_fast_boundary',
-            bndl  = 'pmos4_fast_boundary',
-            gbndr = 'pmos4_fast_boundary',
-            gbndl = 'pmos4_fast_boundary',
-            grid  = "routing_12_mos",
-        )
-
-        # Generate tile templates 
-        gen_list = [["nmos", nmos_fast], ["pmos", pmos_fast]]
-        for name, placement_map in gen_list:
-            grid_name  = placement_map["grid"]
-
-            temp = TileMOSTemplate( tlib, glib, grid_name, routing_map, placement_map, placement_pattern, transform_pattern, name)
-            tlib.append(temp)
-    
-        gen_list = [["ptap", ptap_fast], ["ntap", ntap_fast] ]
-        for name, placement_map in gen_list:
-            grid_name  = placement_map["grid"]
-        
-            temp       = TileTapTemplate( tlib, glib, grid_name, routing_map, placement_map, placement_pattern, transform_pattern, name)
-            tlib.append(temp)
-
-    
-        gen_list = [["nspace", nspace_fast], ["pspace", pspace_fast] ]
-        for name, placement_map in gen_list:
-            grid_name  = placement_map["grid"]
-        
-            temp       = TileSpaceTemplate( tlib, glib, grid_name, routing_map, placement_map, placement_pattern, transform_pattern, name)
-            tlib.append(temp)
-        return tlib
-
-    # Helper functions. To be customized for target technologies
-    def _iterate_for_generate_tap(iter_num, type_iter):
-        """ Internal function for generate_tap()."""
-        ltap_list = []
-        rtap_list = []
-        ltapbnd_list = []
-        rtapbnd_list = []
-        for idx in range(iter_num): # number of iteration
-            i=0
-            for celltype in type_iter: # in each iteration
-                ltap_list.append(templates[celltype+'mos4_fast_tap'].generate(name='LTAP'+str(idx)+str(i), transform='R0' if transform_iter[i]=='0' else 'MX'))
-                rtap_list.append(templates[celltype+'mos4_fast_tap'].generate(name='RTAP'+str(idx)+str(i), transform='R0' if transform_iter[i]=='0' else 'MX'))
-                ltapbnd_name = 'ptap_fast_left' if celltype == 'n' else 'ntap_fast_left'
-                rtapbnd_name = 'ptap_fast_right' if celltype == 'n' else 'ntap_fast_right'
-                ltapbnd_list.append(templates[ltapbnd_name].generate(name='LTAPBND'+str(idx)+str(i), transform='R0' if transform_iter[i]=='0' else 'MX'))
-                rtapbnd_list.append(templates[rtapbnd_name].generate(name='RTAPBND'+str(idx)+str(i), transform='R0' if transform_iter[i]=='0' else 'MX'))
-                i+=1
-        return ltap_list, rtap_list, ltapbnd_list, rtapbnd_list
-
-    def generate_tap(self, dsn, grids, tlib, templates, type_iter='nppn', type_extra=None, transform_iter='0X0X', transform_extra=None, side='both'): 
-        """ 
-        Generates vertical tap stack(s) on the left and/or right sides of the design.
-
-        Parameters
-        ----------
-        dsn: laygo2.object.database.Design
-            The design object to generate tap(s).
-        grids: laygo2.object.database.GridLibrary
-            The library that contains grid information.
-        type_iter : str
-            list of transistor types for main taps, which is iterated over the entire row.
-            For example, for two NMOS rows and one PMOS row, its value should be ['n', 'n', 'p'].
-            ptaps will be placed for NMOS rows, and ntaps will be placed for PMOS row.
-            It should have the identical dimension (length) with transform_iter. 
-        type_extra : str
-            list of transistor types for residual taps, for the leftover rows after iterations.
-        transform_iter : str
-            list of transform types for main taps.
-        transform_extra : str
-            list of transform types of residual taps.
-        side: str
-            The boundary side of layout to generate taps. The value should be one of the following: both, left, right.
-
-        """
-        pg         = grids["placement_basic"]           # Load basic placement grid for placing taps.
-        height_tap = grids["routing_23_cmos"].height//2 # Calculate the height of tap which is generally the half of the CMOS height.
-    
-        bbox             = dsn.bbox                         # The bbox of the design.
-        height_dsn       = bbox[1][1]                       # The height of the design.
-        total_num_of_tap = int(height_dsn // height_tap) # Total number of taps. 8 taps are needed if there are 4 CMOS grids in the design. 5 taps if 2 CMOS grids and 1 half-CMOS.
-        iter_len         = len(type_iter)                   # length of iteration
-        print('======== TAP GENERATION START ========')
-        print('Total number of taps on each side: ' + str(total_num_of_tap))
-        print('Iteration tap type: {0}. Transform: {1}'.format(type_iter, transform_iter))
-        print('Extra tap type: {0}. Transform: {1}'.format(type_extra, transform_extra))
- 
-        if total_num_of_tap%iter_len == 0: # full iteration
-            ltap_list, rtap_list, ltapbnd_list, rtapbnd_list = _iterate_for_generate_tap(iter_num = total_num_of_tap//iter_len, type_iter = type_iter)
- 
-        else: # iteration + extra taps
-            ltap_list, rtap_list, ltapbnd_list, rtapbnd_list = _iterate_for_generate_tap(iter_num = (total_num_of_tap-len(type_extra))//iter_len, type_iter = type_iter) # Iteration
-            i=0
-            for celltype in type_extra: # Extra taps
-                ltap_list.append(templates[celltype+'mos4_fast_tap'].generate(name='LTAPEND'+celltype+str(i), transform='R0' if transform_extra[i]=='0' else 'MX'))
-                rtap_list.append(templates[celltype+'mos4_fast_tap'].generate(name='RTAPEND'+celltype+str(i), transform='R0' if transform_extra[i]=='0' else 'MX'))
-                ltapbnd_name = 'ptap_fast_left' if celltype == 'n' else 'ntap_fast_left'
-                rtapbnd_name = 'ptap_fast_right' if celltype == 'n' else 'ntap_fast_right'
-                ltapbnd_list.append(templates[ltapbnd_name].generate(name='LTAPBND'+celltype+str(i), transform='R0' if transform_iter[i]=='0' else 'MX'))
-                rtapbnd_list.append(templates[rtapbnd_name].generate(name='RTAPBND'+celltype+str(i), transform='R0' if transform_iter[i]=='0' else 'MX'))
-                i+=1
-        
-        # Place TAPs on the design.
-        if side == 'both':
-            dsn.place(grid=pg, inst=np.array(rtap_list   ).reshape(len(rtap_list   ),1), mn=pg.mn.bottom_right(bbox))
-            dsn.place(grid=pg, inst=np.array(rtapbnd_list).reshape(len(rtapbnd_list),1), mn=pg.mn.bottom_right(rtap_list[0]))
-            dsn.place(grid=pg, inst=np.array(ltap_list   ).reshape(len(ltap_list   ),1), mn=pg.mn.bottom_left(bbox)         - pg.mn.width_vec(ltap_list[0]))
-            dsn.place(grid=pg, inst=np.array(ltapbnd_list).reshape(len(ltapbnd_list),1), mn=pg.mn.bottom_left(ltap_list[0]) - pg.mn.width_vec(ltapbnd_list[0]))
-        elif side == 'left':
-            dsn.place(grid=pg, inst=np.array(ltap_list   ).reshape(len(ltap_list   ),1), mn=pg.mn.bottom_left(bbox)         - pg.mn.width_vec(ltap_list[0]))
-            dsn.place(grid=pg, inst=np.array(ltapbnd_list).reshape(len(ltapbnd_list),1), mn=pg.mn.bottom_left(ltap_list[0]) - pg.mn.width_vec(ltapbnd_list[0]))
-        elif side == 'right':
-            dsn.place(grid=pg, inst=np.array(rtap_list   ).reshape(len(rtap_list   ),1), mn=pg.mn.bottom_right(bbox))
-            dsn.place(grid=pg, inst=np.array(rtapbnd_list).reshape(len(rtapbnd_list),1), mn=pg.mn.bottom_right(rtap_list[0])) 
- 
-        bbox = dsn.bbox
- 
-        if bbox[0][0] != 0:
-            for _dsn in dsn:
-                dsn.elements[_dsn].xy -= [bbox[0][0],0]
-        print('========= TAP GENERATION END =========')
-
-    def generate_gbnd(self, dsn, grids, templates):
-        """ 
-        Generates global boundary structures around the design.
-        (Check the name of gbnd cells since those are different by each template library)
-        """
- 
-        # Call placement grid and calculate the bounding box of the design.
-        pg = grids["placement_basic"]
-        bbox_xy = dsn.bbox
-        bbox_mn = pg.mn(dsn.bbox)
-        
-        # Call each dummy GBND cell from template library to calculate the height and width of each cell.
-        gbnd_vertical_dmy   = templates["boundary_topleft"].generate(name="gbnd_vertical_dmy"  )
-        gbnd_horizontal_dmy = templates["boundary_top"    ].generate(name="gbnd_horizontal_dmy")
-        gbnd_corner_dmy     = templates["boundary_topleft"].generate(name="gbnd_corner_dmy"    )
-        
-        # Calculate the number of mosaic and generate GBND cells to be placed. 
-        num_horizontal = bbox_mn[1][0]-bbox_mn[0][0]
-        itop_gb   = templates["boundary_top"].generate( name="gbnd_top", transform='MX', shape=[num_horizontal, 1] )
-        ibot_gb   = templates["boundary_top"].generate( name="gbnd_bot", transform='R0', shape=[num_horizontal, 1] ) 
- 
-        num_vertical = bbox_mn[1][1]//pg.mn.height(gbnd_vertical_dmy)
-        ileft_gb  = templates["boundary_topleft"].generate( name="gbnd_left",  transform='R0', shape=[1, num_vertical] )
-        iright_gb = templates["boundary_topleft"].generate( name="gbnd_right", transform='MY', shape=[1, num_vertical] )  
- 
-        ibl_gb    = templates["boundary_topleft"].generate( name="gbnd_bl", transform='R0'   )  
-        ibr_gb    = templates["boundary_topleft"].generate( name="gbnd_br", transform='MY'   )  
-        itr_gb    = templates["boundary_topleft"].generate( name="gbnd_tr", transform='R180' )  
-        itl_gb    = templates["boundary_topleft"].generate( name="gbnd_tl", transform='MX'   )  
- 
-        # Place GBND cells on the design.    
-        dsn.place(grid=pg, inst=itop_gb,   mn=pg.mn.top_left(    bbox_xy) + pg.mn.height_vec(gbnd_horizontal_dmy)) # TOP
-        dsn.place(grid=pg, inst=ibot_gb,   mn=pg.mn.bottom_left( bbox_xy) - pg.mn.height_vec(gbnd_horizontal_dmy)) # BOTTOM
- 
-        dsn.place(grid=pg, inst=ileft_gb,  mn=pg.mn.bottom_left( bbox_xy) - pg.mn.width_vec( gbnd_vertical_dmy  )) # LEFT
-        dsn.place(grid=pg, inst=iright_gb, mn=pg.mn.bottom_right(bbox_xy) + pg.mn.width_vec( gbnd_vertical_dmy  )) # RIGHT
-  
-        dsn.place(grid=pg, inst=ibl_gb,    mn=pg.mn.bottom_left( ibot_gb) - pg.mn.width_vec( gbnd_corner_dmy    )) # BOTTOM LEFT CORNER
-        dsn.place(grid=pg, inst=ibr_gb,    mn=pg.mn.bottom_right(ibot_gb) + pg.mn.width_vec( gbnd_corner_dmy    )) # BOTTOM RIGHT CORNER
-        dsn.place(grid=pg, inst=itl_gb,    mn=pg.mn.top_left(   ileft_gb) + pg.mn.height_vec(gbnd_corner_dmy    )) # TOP LEFT CORNER
-        dsn.place(grid=pg, inst=itr_gb,    mn=pg.mn.top_right( iright_gb) + pg.mn.height_vec(gbnd_corner_dmy    )) # TOP RIGHT CORNER
- 
-        bbox_xy = dsn.bbox
- 
-        if bbox_xy[0][0] != 0:
-            for _dsn in dsn:
-                dsn.elements[_dsn].xy -= [bbox_xy[0][0],0]
-
-    def generate_pwr_rail(self, dsn, grids, tlib=None, templates=None, route_type='cmos', netname=None, vss_name='VSS', vdd_name='VDD', rail_swap=False, vertical=False, pin_num=0, pin_pitch=0):
-        """ 
-        Generates thick wire rails for supplies (VDD, VSS)
-            
-        Parameters
-        ----------
-        route_type : str
-            The type of routing style ('cmos', 'mos', 'cmos_flipped')
-        netname : str or list
-            The name of nets
-            ex) 'VDD', ['VDD', 'VSS'], ['VDD', 'VSS', ['VDD', -1]]
-        vss_name : str
-            The name of GROUND net (will be deprecated)
-        vdd_name : str
-            the name of POWER net (will be deprecated)
-        rail_swap : boolean
-            Determine the bottom rail is GND or POWER net. 0 for GND 1 for POWER (will be deprecated).
-        vertical : boolean
-            whether generate vertical wires for connecting each horizontal rail
-        pin_num : int
-            the number of pins
-        pin_pitch : int
-            the pitch between pins in the abstract coordinate
-        """
- 
-        print('=========== SUPPLY RAIL GENERATION START ===========')
-        # 1. Load grids
-        r23 = grids['routing_23_{0}'.format(route_type)]                                        # "CMOS grid" to calculate the number of power rails
-        if route_type != 'mos': r23t = grids['routing_23_{0}_thick'.format(route_type)]         # "CMOS grid" to make M3 vertical rails.
-        else: r23t = grids['routing_23_{0}'.format(route_type)]                                 # "MOS grid" to calculate the number of power rails
-        
- 
-        # 2. Calculate the number of power rails in the design
-        bbox = dsn.bbox
-        grid_cnt = bbox[1,1] // r23.height
-        bottom_rail = [r23.mn.bottom_left(bbox), r23.mn.bottom_right(bbox)]                     # bbox for M2 bottom rail
- 
-        if netname == None:
-            """
-                This block is for old-version users.
-                It will be removed later. :D
-            """
- 
-            print("\n[WARNING] generate_pwr_rail with vss_name/vdd_name arguments will be deprecated.\n")
-            if grid_cnt%2 == 0:
-                iter_vdd = grid_cnt//2
-                iter_vss = grid_cnt//2 + 1
- 
-            else:
-                iter_vdd = (grid_cnt+1)//2
-                iter_vss = (grid_cnt+1)//2
- 
-            pw_len = 2
- 
-            rvss = []
-            rvdd = []
-            vss_set = [iter_vss, rvss, vss_name]
-            vdd_set = [iter_vdd, rvdd, vdd_name]
- 
-            pw_set = np.array([vss_set, vdd_set])
- 
-            if rail_swap: 
-                pw_set[0][2] = vdd_name
-                pw_set[1][2] = vss_name
-            
-            pw_iter = grid_cnt + 1 
-            rail_count = {}
-            rail_change = {}
-        
-        else:
-            # 3. Generate a power rail list.
-            pw_iter = grid_cnt + 1 
- 
-            # Check the type of netname.
-            if type(netname) == str:
-                netname = netname.split()
-                rail_change = {}
- 
-            else:
-                rail_change = {}
-                for _name in netname:
-                    if type(_name) == list:
-                        try: 
-                            if _name[1] < 0: _name[1] += pw_iter
-                            rail_change[_name[0]].append(_name[1])
-                        except: 
-                            rail_change[_name[0]]= [_name[1]]
-            
-            # Create a power rail list.
-            netname = list(filter(lambda x: type(x)==str, netname))
-            pw_len = len(netname)
-            pw_set = np.empty(shape=(pw_len, 3), dtype=object)
- 
-            # Calculate the number of iterations of each power net.      
-            pw_set[:pw_len,0] = pw_iter // pw_len
-            pw_set[0:(pw_iter % pw_len), 0] += 1
- 
-            for i in range(pw_len): 
-                pw_set[i, 1] = []
-                pw_set[i, 2] = netname[i]
-            
-            # Rail swap for Iterated rails (Optional).
-            if rail_swap: pw_set[:pw_len,2] = np.flip(pw_set[:pw_len,2])
- 
-            # Revise the list.
-            for _name, _num in rail_change.items():
-                for idx in _num:
-                    pw_set[(idx%pw_len), 0] -= 1
-                
-                if _name in netname:
-                    pin_ex = pw_set[:,2].tolist().index(_name)
-                    pw_set[pin_ex, 0] += len(_num)
-                
-                else:
-                    pw_extra = [len(_num), [], _name]
-                    pw_set = np.append(pw_set, [pw_extra], axis=0)
- 
-            # Count the number of each rail.
-            rail_count = {}
-            for _name, _num in rail_change.items():
-                for idx in _num:
-                    rail_count[idx] = _name
-            
-            # Remove zero-rails.
-            zero_list = list(np.where(pw_set[:,0]==0))[0]
-            pw_set = np.delete(pw_set, zero_list, 0)
-            pw_len -= len(zero_list)
- 
-        # 4. Generate iterated power rails
-        pin_name = []
- 
-        for idx in range(pw_iter):
-            pin = idx % pw_len
-            iter = idx // pw_len
- 
-            # Generate a horizontal rail
-            _mn = bottom_rail
-            _mn[0][1] = r23.n(r23.height) * (pw_len*iter+pin)
-            _mn[1][1] = r23.n(r23.height) * (pw_len*iter+pin)
- 
-            route = dsn.route(grid=r23, mn=_mn)
-            
-            # Check the netname.
-            if idx in rail_count.keys():
-                _netname = rail_count[idx]
-                pin = pw_set[:,2].tolist().index(_netname)
-                pw_set[pin][1].append(route)
-                pin_name.append("{0}:".format(_netname))
-            
-            else: 
-                pw_set[pin][1].append(route)
-                pin_name.append(pw_set[pin][2]+':')
- 
-            # Generate the vertical vias (Optional).
-            if vertical & (pw_set[pin][0] != 1):
-                if pin % 2 == 0: dsn.via(grid=r23t, mn=r23t.mn.bottom_left(pw_set[pin][1][-1])-[pin,0])
-                else: dsn.via(grid=r23t, mn=r23t.mn.bottom_right(pw_set[pin][1][-1])+[pin-1,0])
-        
-        bbox = dsn.bbox
- 
-        for idx in range(len(pw_set)):
-            # Generate the vertical rails (Optional).
-            if vertical & (pw_set[idx][0] != 1) :
-                if idx % 2 == 0:
-                    _mn = [r23t.mn.bottom_left(pw_set[idx][1][0])-[idx,0], r23t.mn.bottom_left(pw_set[idx][1][-1])-[idx,0]]
-                else:
-                    _mn = [r23t.mn.bottom_right(pw_set[idx][1][0])+[(idx-1),0], r23t.mn.bottom_right(pw_set[idx][1][-1])+[(idx-1),0]]
-                dsn.route(grid=r23t, mn=_mn)
-            
-        
-            # Rail extension (Optional).
-            if vertical & any(1 < i for i in pw_set[:,0]):
-                for x in range(len(pw_set[idx][1])):
-                    pw_set[idx][1][x].xy[0][0] = bbox[0][0]
-                    pw_set[idx][1][x].xy[1][0] = bbox[1][0]
- 
-        # 5. Check whether two variables (pin_num and pin_pitch) are entered properly.
-        bottom_rail = [r23.mn.bottom_left(bbox), r23.mn.bottom_right(bbox)]
- 
-        if (pin_num == 0) & (pin_pitch == 0) : pin_num = 1 
-        elif (pin_num < 0) | (pin_pitch < 0) :
-            pin_num = 1
-            pin_pitch = 0
-            print('\n[WARNING] You entered negative number.\n')
-        elif (pin_num != 0) & (pin_pitch != 0) : 
-            pin_pitch = 0
-            print('\n[WARNING] You have to choose between pin_num or pin_pitch.\nLAYGO2 follows <pin_num> this time.\n')
- 
-        pwidth = bottom_rail[1][0] - bottom_rail[0][0]
- 
-        # 6. Compare between pwidth and (pin_num / pin_pitch).
-        if pin_num != 0: 
-            if pin_num > pwidth:
-                pin_num = pwidth
-                pin_pitch = 1
-                print('"You want too many pins. x_x')
-                print('The maximum number of pins : {0}"\n'.format(pwidth))
-            else: pin_pitch = pwidth//pin_num
-        elif pin_pitch != 0: 
-            if pin_pitch > pwidth: 
-                pin_pitch = pwidth
-                print('"You want too wide pitch. x_x')
-                print("The minimum number of pin : 1")
-                print('Thus, one pin is generated each."\n')
-            pin_num = pwidth // pin_pitch
- 
-        # 7. Generate iterated power rails.
-        for idx in range(pw_iter):
-            pin = idx % pw_len
-            iter = idx // pw_len
- 
-            _mn = bottom_rail
-            _mn[0][1] = r23.n(r23.height) * (pw_len*iter+pin)
-            _mn[1][1] = r23.n(r23.height) * (pw_len*iter+pin)
- 
-            pmin = _mn[0]
-            pmax = _mn[1]
-            pp = np.array([pmin, pmin]) + np.array([[(pwidth%pin_num)//2, 0], [(pwidth%pin_num)//2, 0]])
- 
-            for pn in range(0, pin_num):
-                pp[1] += [pin_pitch, 0]
-                dsn.pin(name="net{0}_{1}".format(idx, pn), grid=r23, mn=pp, netname=pin_name[idx])
-                pp[0] += [pin_pitch, 0]
- 
-        # 8. Set X coordinate as zero.
-        if bbox[0][0] != 0:
-            for _dsn in dsn:
-                dsn.elements[_dsn].xy -= [bbox[0][0],0]
- 
-        # 9. Print messages about the results.
-        print('\nThe number of rails of your design is {0}.\n'.format(grid_cnt) + "The number of pins of your design is {0}.\n".format(len(pw_set)) + '\nName of Iterated net:')
- 
-        for i in range(pw_len): print('{0}. "{1}"'.format(i, pw_set[i][2]))
-        if rail_change:
-            print('\nName of Changed net:')
-            for _num, _name in sorted(rail_count.items()): print('Rail #{0} :  "{1}"'.format(_num, _name))    
-        print('\n============ SUPPLY RAIL GENERATION END ============')
-
-    def extend_wire(self, dsn, layer='M4', target=500):
-        """
-        Extend routing wires to meet the design rules about area or width of wires. This function is executed as follows:
-        1. Find matched rects with the given layer in design.
-        2. Check the direction of rect (horizontal or vertical). Do nothing if the rect is zero sized.
-        3. Calculate total width/height of the rect and check whether the rect violates the design rule.
-        4. Calculate delta (amount of extension) and create rect with new extension but maintaining bbox.
-        5. Append new rects to the design and delete old rects.
-        
-        Parameters
-        ----------
-        dsn : laygo2.object.database.Design
-            Design to be implemented.
-        layer : str
-            Name of layer for extension.
-        target : int
-            Target width/height of wires to be extended.
-        """
- 
-        rect_list = dsn.get_matchedrects_by_layer([layer, 'drawing'])    
-        for rect in rect_list:
-            if rect.height == 0 and rect.width == 0:
-                direction = 'horizontal' if layer in ['M2','M4','M6'] else 'vertical'
-                check = rect.width + 2*rect.hextension if direction == 'horizontal' else rect.height + 2*rect.vextension
-                
-                if check < target:
-                    delta = (target - check)//2
-                    if direction == 'horizontal':
-                        p = laygo2.object.physical.Rect(xy=rect.bbox, layer=rect.layer, hextension=rect.hextension0+delta, 
-                        vextension=rect.vextension0, color=rect.color)
-                    else:
-                        p = laygo2.object.physical.Rect(xy=rect.bbox, layer=rect.layer, hextension=rect.hextension0, 
-                        vextension=rect.vextension0+delta, color=rect.color)
- 
-                    dsn.append(p)
- 
-                    for key, value in list(dsn.items()):
-                        if value == rect:
-                            del dsn.elements[key]
-                        else:
-                            pass
-                else:
-                    pass
- 
-            else:
-                direction = 'horizontal' if rect.height == 0 else 'vertical'
-                check = rect.width + 2*rect.hextension if direction == 'horizontal' else rect.height + 2*rect.vextension
- 
-                if check < target:
-                    delta = (target - check)//2
-                    if direction == 'horizontal':
-                        hextension = round(rect.hextension+delta, -1)
-                        p = laygo2.object.physical.Rect(xy=rect.bbox, layer=rect.layer, hextension=hextension, 
-                        vextension=rect.vextension, color=rect.color)
-                    else:
-                        vextension = round(rect.vextension+delta, -1)
-                        p = laygo2.object.physical.Rect(xy=rect.bbox, layer=rect.layer, hextension=rect.hextension, 
-                        vextension=vextension, color=rect.color)
- 
-                    dsn.append(p)
- 
-                    for key, value in list(dsn.items()):
-                        if value == rect:
-                            del dsn.elements[key]
-                        else:
-                            pass
-                else:
-                    pass
-
-    def fill_by_instance(self, dsn, grids, tlib, templates, inst_name:tuple, canvas_area="full", shape=[1,1], iter_type=("R0","MX"), pattern_direction='v', fill_sort='filler'):
-        """ Fill empty layout space by given instances.
-            
-            Parameters
-            ----------
-            inst_name : tuple
-                the name of the instance to fill empty layout space.
-            canvas_area : "full" or list
-                the range of the space to be filled.
-            shape : list
-                the shape of the given instances.
-            iter_type : tuple
-                Transform types of iterating instances.
-            pattern_direction : str
-                Determine the direction of iterating instances. ('v' : vertical, 'h' : horizontal)
-            fill_sort : str
-                the name of the created iterating instances.
-        """
- 
-        print('\n=========== FILLING EMPTY LAYOUT SPACE START ===========')
- 
-        pg = grids["placement_basic"]
- 
-        # 1. Check the canvas.
-        dsnbbox = pg.mn(dsn.bbox)
- 
-        offset  = dsnbbox[0]
-        width   = dsnbbox[1][0] - 0
-        height  = dsnbbox[1][1] - dsnbbox[0][1]
- 
-        canvas = np.zeros((height, width), dtype=int)
- 
-        def check_occupied(canvas, physical, index):
-            bbox = pg.mn(physical.bbox)
-            x0 = bbox[0][0]
-            x1 = bbox[1][0]
-            y0 = bbox[0][1]
-            y1 = bbox[1][1]
-            if x0 == x1 and y0 == y1:
-                return
-            canvas[y0:y1, x0:x1] = index
- 
-        index = 1
- 
-        for n, inst in dsn.instances.items():
-            check_occupied(canvas, inst, index)
-            index = index + 1
-        for n, vinst in dsn.virtual_instances.items():
-            check_occupied(canvas, vinst, index)
-            index = index + 1
- 
-        if canvas_area != "full":
-            bbox_l0 = pg.mn.bottom_left(canvas_area[0])
-            bbox_l1 = pg.mn.bottom_right(canvas_area[0])
-            bbox_r0 = pg.mn.top_left(canvas_area[1])
-            bbox_r1 = pg.mn.top_right(canvas_area[1])
- 
-            width   = abs(bbox_r1[0] - bbox_l0[0])
-            height  = abs(bbox_r1[1] - bbox_l0[1])
-            offset  = bbox_l0
- 
-            canvas = canvas[bbox_l0[1]:bbox_r1[1],bbox_l0[0]:bbox_r1[0]]
-        else:
-            bbox_l0 = dsnbbox[0]
-            bbox_l1 = dsnbbox[0] + [dsnbbox[1][0],0]
-            bbox_r0 = dsnbbox[1] - [dsnbbox[1][0],0]
-            bbox_r1 = dsnbbox[1]
- 
-        def check_name(inst_name, boundary_name):
-            if type(inst_name) == str:
-                inst_name = inst_name.split()
-            else:
-                for _name in inst_name:
-                    if type(_name) == list:
-                        try:
-                            boundary_name[_name[0]].append(_name[1])
-                        except:
-                            boundary_name[_name[0]] = [_name[1]]
- 
-            inst_name = list(filter(lambda x: type(x)==str, inst_name))
-            return inst_name, boundary_name
- 
-        # 2. Fill the empty space.
-        boundary_name = {}
-        inst_name, boundary_name = check_name(inst_name, boundary_name)
- 
-        filler   = templates[inst_name[0]].generate(name=fill_sort, transform="R0", shape=shape)
- 
-        f_height = pg.mn(filler)[1][1]
-        f_width  = pg.mn(filler)[1][0]
-        n_mod    = int(height / f_height)
-        print(boundary_name)
-        for _name, _num in boundary_name.items():
-            for i in range(len(_num)):
-                if _num[i] < 0: 
-                    if pattern_direction == 'v': boundary_name[_name][i] += ((bbox_r0[1]-bbox_l1[1]) // f_height)
-                    elif pattern_direction == 'h': boundary_name[_name][i] += ((bbox_r0[0]-bbox_l1[0]) // f_width)
- 
-        boundary_count = {}
-        for _name, _num in boundary_name.items():
-            for idx in _num:
-                boundary_count[idx] = _name
- 
-        pattern_name = 0
-        for y in range(n_mod):
-            buffers = []
- 
-            if pattern_direction == 'v':
-                if y in boundary_count.keys(): it = boundary_count[y]
-                else: 
-                    it = inst_name[pattern_name]
-                    pattern_name = (pattern_name + 1) % len(inst_name)
-            elif pattern_direction == 'h': pattern_name = 0
- 
-            for x in range(width):
-                if canvas[f_height * y, x] == 0:
-                    buffers.append(True)
- 
-                    if np.array_equal(buffers, [True] * f_width):
-                        if pattern_direction == 'h':
-                            h_num = int((x - (bbox_l1[0] - bbox_l0[0])) / f_width)
-                            if h_num in boundary_count.keys(): 
-                                it = boundary_count[h_num]
-                            else: 
-                                it = inst_name[pattern_name]
-                                if h_num != 0: pattern_name = (pattern_name + 1) % len(inst_name)
-                            
-                        tf = iter_type[int(y % len(iter_type))]
-                        _mn = np.asarray([x-f_width+1, y * f_height])+offset
-                        if tf == "MX": _mn = _mn + [0, f_height]
-                        dsn.place(grid=pg, inst=templates[it].generate(name=fill_sort + f"{x}_{y * f_height}", transform=tf, shape=shape), mn=_mn)
-                        buffers = []
-                else:
-                    buffers = []
-        print('============ FILLING EMPTY LAYOUT SPACE END ============')
-        return canvas
-
-    def generate_cut_layer(self, dsn, grid, grid_cut, layer: str, space_min: float, flip=0 ):
-        """ place the instance(cut-via) when layer space violation occurs """
-        from collections import defaultdict
-        rects  = dsn.rects
-        insts  = dsn.instances
-        vinsts = dsn.virtual_instances
-        xy     = dsn.bbox
-        pins   = dsn.pins
- 
-        def get_ebbox(obj):
-            """ refine and get bbox from the object  """
-            ebbox = np.zeros( (5,2), dtype=np.int64 )
- 
-            if isinstance(obj, laygo2.object.physical.Rect): # apply hextensions
-                ebbox[0] = obj.bbox[0] - np.array([obj.hextension, 0])
-                ebbox[1] = obj.bbox[1] + np.array([obj.hextension, 0])
-                ebbox[2] = ebbox[2] + np.array([ obj.hextension, 0 ])
-                ebbox[3] = ebbox[3] + np.array([ 0, obj.vextension])
-            else:
-                ebbox[0:2] = obj.bbox
- 
-            if obj.bbox[0][1] != obj.bbox[1][1]: # obj has no-zero height
-                h_avr = int( 0.5 * ( obj.bbox[1][1] +  obj.bbox[0][1] ) )
-                ebbox[0][1] = h_avr
-                ebbox[1][1] = h_avr
- 
- 
-            return ebbox
- 
-        def place( xy_w, xy_e, obj_w, obj_e, grid_cut ):
-            """ place the cut-via """
- 
-            mn_w = grid_cut.mn(xy_w)
-            mn_e = grid_cut.mn(xy_e)
-            #print("convert")
-            #print(grid_cut.name)
-            #print( grid_cut.range )
-            #print(mn_w)
-            #print(mn_e)
-            mn_w = mn_w.astype(int)
-            mn_e = mn_e.astype(int)
-            #print(mn_w)
-            #print(mn_e)
-            mn_c = ( 0.5*(mn_w + mn_e) ).astype(int)
-            dsn.via( grid=grid_cut, mn= mn_c )
- 
-        def check_space_ok( xw:float, xe:float, space:float ):
-            """ check space is enough  """
-            delta = xe - xw
-            print("check space", end=" ")
-            print(f"{xw}, {xe}, delta:{delta}, space:{space}")
- 
-            if 0 < delta < space: # error
-                print("##cut")
-                return False
-            else:               # pass  or overlap
-                #print("no cut")
-                return True
- 
-        space_min_edge = space_min  ## for space at edge,
- 
-        objs_to_check = dsn.get_matched_rects_by_layer( [layer, "drawing"]   )
-        objs_to_check.extend( dsn.get_matched_rects_by_layer( [layer, "pin"] ))
- 
-        objs_toppin = []
-        for rname, rect in rects.items():
-            if np.array_equal(rect.layer, [layer,"pin" ] ):
-                objs_toppin.append(rect)
- 
-        for rname, pin in pins.items():
-            if np.array_equal(pin.layer, [layer,"pin" ] ):
-                objs_toppin.append(pin)
- 
-        ebboxs_to_check= []
-        ebboxs_toppin  = []
- 
-        objset=( objs_to_check,  objs_toppin   )
-        bboxs =( ebboxs_to_check, ebboxs_toppin  )
-        for n, objs in enumerate( objset):
-            _bboxs = bboxs[n]
-            for i, obj in enumerate(objs):
-                ebbox = get_ebbox(obj) # bl, tr ,hextension, vextension
-                ebbox[4,:] = [ i,i ]   # object index
-                _bboxs.append( ebbox )
-        
-        ebboxs_to_check = np.unique(ebboxs_to_check, axis=0)  ## sort by bottom-left-x and remove duplicated-xy
-        
-        y_box     = defaultdict(list)
-        y_box_pin = defaultdict(list)
-        for ebbox in ebboxs_to_check: # packed by y-axis , assuming rect has 0 height
-            y_box[ ebbox[0][1] ].append( ebbox )
-        
-        for ebbox in ebboxs_toppin: # packed by y-axis , assuming rect has 0 height
-            y_box_pin[ ebbox[0][1] ].append( ebbox )
- 
-        y_keys = y_box.keys()
- 
-        for key in y_keys: # scan start
-            ebbox_list  = y_box[key]
-            ebboxs_pin  = y_box_pin.get(key, 0 )
-            i_last      = len(ebbox_list) - 1
- 
-            i_edges= (0, i_last)
-            #print("##i_edge###")
-            #print(i_edges)
-            #print(key)
-            
-            ## check edge, pin-layer is on edge of design
-            for n, i in enumerate( i_edges ):
-                ebbox_edge = ebbox_list[i]
-                flag_skip  = 0
-                #print(ebbox_edge)
-            
-                if ebboxs_pin == 0 :
-                    flag_skip  = 0
-                else:
- 
-                    for ebbox_pin in ebboxs_toppin:
-                        bl_pin, tr_pin   = ebbox_pin[0], ebbox_pin[1]
-                        bl_edge, tr_edge = ebbox_edge[0], ebbox_edge[1]
-                        tol = 0.1
-                        # edge pin   e p e p
-                        # pin edge   p e p e
-                        #            e e p p
-                        #            p p e e  
-                        if  ( (bl_pin[0] <= tr_edge[0]) and ( tr_pin[0] >= bl_edge[0] )   or ( ( tr_pin[0]  >= tr_edge[0]  ) and bl_pin[0] <= tr_edge[0] )):
-                            flag_skip  = 1
-                            break
-                        ## the route on the edge is a pin! skip
-                
-                if flag_skip ==1:
-                    continue
-                else:
-                    #print( f" there is no pin on edge {n}")
-                    if n == 0:
-                    #     print("left")
-                         flag = check_space_ok( xy[0][0], ebbox_edge[0][0], space_min_edge) # check left
-                    else:
-                    #    print("right")
-                        flag = check_space_ok( ebbox_edge[1][0], xy[1][0], space_min_edge) # check right
-                    if flag == False: # not ok
-                        _xy = np.array([xy[n][0], ebbox_edge[0][1]]) # edge-xy of design
-                        place( _xy, _xy, dsn, objs_to_check[ebbox_edge[4][0]], grid_cut)
-                 
-            #print("check middle")
-            ## check middle
-            if i_last != 0:
-                iw_ebbox = ebbox_list[0]    # checkking bottom-right
-                for i in range(i_last + 1): # from leftmost-right to rightmost-left
-                    # ie : reference
-                    # iw : target
-                    new_ebbox = ebbox_list[i]
-                    if new_ebbox[1][0] <= iw_ebbox[1][0] : # bottom-right vs bottom-right
-                        continue # skip, it is overlapped
-                    else: # evaluation
-                        ie_ebbox = new_ebbox
-                        flag     = check_space_ok( iw_ebbox[1][0],  ie_ebbox[0][0], space_min )
-                        if flag == False :
-                            print("###################### compensation")
-                            _xy_w =  iw_ebbox[1] - iw_ebbox[2] # compensate extensions for mn converting
-                            _xy_e =  ie_ebbox[0] + ie_ebbox[2] # compensate extensions for mn converting
- 
-                            place( _xy_w, _xy_e , objs_to_check[ iw_ebbox[4][0]], objs_to_check[ie_ebbox[4][0]], grid_cut )
-                        iw_ebbox = ie_ebbox # update
-
-
-
-
-
-
-    def post_process(self, dsn, grids, tlib, templates ):
-        pass
-        #generate_cut_layer(dsn, grids, tlib, templates)  
-
-# Tests
-if __name__ == '__main__':
-    # Create templates.
-    print("Create templates")
-    _templates = load_templates()
-    for tn, t in _templates.items():
-        print(t)
+#!/usr/bin/python
+########################################################################################################################
+#
+# Copyright (c) 2014, Regents of the University of California
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+from laygo2.object import *
+from laygo2.object.technology import BaseTechnology
+from laygo2.object.template.tile import TileMOSTemplate, TileTapTemplate, TileSpaceTemplate
+
+class NiftyTechnology(BaseTechnology):
+    """
+    Class for defining technology parameters and objects in "Niftylab-style".
+    This greatly streamlines the setup of templates and grids for new technologies,
+    and generators constructed based-on the "Niftylab-style" templates cna be reused 
+    with minimal modifications.
+
+    However, this comes at the expense of supporting diverse layout styles, particularly 
+    those with unique polygon shapes.
+    """
+    
+    def load_tech_templates(self, libname=None):
+        """
+        Load templates and construct a template library object.
+
+        Parameters
+        ----------
+            libname: optional, str
+                The name of library to be loaded. 
+                By default, the first library in tech_params['templates'] is used.
+        """
+        # Library name
+        if libname is None:
+            ln = list(self.tech_params['templates'].keys())[0]
+        else:
+            ln = libname
+
+        # Native templates and grids
+        ntemplates = self.tech_params['templates'][ln]
+        ngrids     = self.tech_params['grids'][ln]
+         
+        # Template library
+        tlib    = laygo2.object.database.TemplateLibrary(name = ln)
+    
+        # 1. Load native templates
+        for tn, tdict in ntemplates.items():
+            # bounding box
+            bbox = np.array(tdict['xy'])
+            # pins
+            pins = None
+            if 'pins' in tdict:
+                pins = dict()
+                for pn, _pdict in tdict['pins'].items():
+                    pins[pn] = laygo2.object.Pin(xy=_pdict['xy'], layer=_pdict['layer'], netname=pn)
+        
+            t = laygo2.object.NativeInstanceTemplate(libname=libname, cellname=tn, bbox=bbox, pins=pins)
+            tlib.append(t)
+    
+
+        # 2. Construct UserDefinedTemplate objects derived from native templates
+        glib = self.load_tech_grids(templates=tlib)
+
+        # Mapping parameters for tile templates
+        placement_pattern = ["gbndl", "bndl", "dmyl",  "core", "dmyr", "bndr", "gbndr"]
+        transform_pattern = dict( gbndl = "R0", dmyl = "R0", bndl  = "R0", core  = "R0",
+                                  dmyr = "MY", bndr  = "R0", gbndr = "R0" )
+        routing_map       = dict( G = 3, S = 1, D = 2, G_extension0_x = [None,None], 
+                                  S_extension0_m = [None, None], D_extension0_m = [None, None])
+    
+        nmos_fast = dict(
+            core  = 'nmos4_fast_center_nf2',
+            dmyr  = 'nmos4_fast_dmy_nf2',
+            dmyl  = 'nmos4_fast_dmy_nf2',
+            bndr  = 'nmos4_fast_boundary',
+            bndl  = 'nmos4_fast_boundary',
+            gbndr = 'nmos4_fast_boundary',
+            gbndl = 'nmos4_fast_boundary',
+            grid  = "routing_12_mos",
+        )
+
+        pmos_fast = dict(
+            core  = 'pmos4_fast_center_nf2',
+            dmyr  = 'pmos4_fast_dmy_nf2',
+            dmyl  = 'pmos4_fast_dmy_nf2',
+            bndr  = 'pmos4_fast_boundary',
+            bndl  = 'pmos4_fast_boundary',
+            gbndr = 'pmos4_fast_boundary',
+            gbndl = 'pmos4_fast_boundary',
+            grid  = "routing_12_mos",
+        )
+
+        ptap_fast = dict(
+            core  = 'ptap_fast_center_nf2_v2',
+            dmyr  = 'nmos4_fast_dmy_nf2',
+            dmyl  = 'nmos4_fast_dmy_nf2',
+            bndr  = 'ptap_fast_boundary',
+            bndl  = 'ptap_fast_boundary',
+            gbndr = 'ptap_fast_boundary',
+            gbndl = 'ptap_fast_boundary',
+            grid  = "routing_12_mos",
+        )
+
+        ntap_fast = dict(
+            core  = 'ntap_fast_center_nf2_v2',
+            dmyr  = 'pmos4_fast_dmy_nf2',
+            dmyl  = 'pmos4_fast_dmy_nf2',
+            bndr  = 'ntap_fast_boundary',
+            bndl  = 'ntap_fast_boundary',
+            gbndr = 'ntap_fast_boundary',
+            gbndl = 'ntap_fast_boundary',
+
+            grid  = "routing_12_mos",
+        )
+  
+        nspace_fast = dict(
+            core  = 'nmos4_fast_space_2x',
+            dmyr  = 'nmos4_fast_space_1x',
+            dmyl  = 'nmos4_fast_space_1x',
+            bndr  = 'nmos4_fast_boundary',
+            bndl  = 'nmos4_fast_boundary',
+            gbndr = 'nmos4_fast_boundary',
+            gbndl = 'nmos4_fast_boundary',
+            grid  = "routing_12_mos",
+        )
+
+        pspace_fast = dict(
+            core  = 'pmos4_fast_space_2x',
+            dmyr  = 'pmos4_fast_space_1x',
+            dmyl  = 'pmos4_fast_space_1x',
+            bndr  = 'pmos4_fast_boundary',
+            bndl  = 'pmos4_fast_boundary',
+            gbndr = 'pmos4_fast_boundary',
+            gbndl = 'pmos4_fast_boundary',
+            grid  = "routing_12_mos",
+        )
+
+        # Generate tile templates 
+        gen_list = [["nmos", nmos_fast], ["pmos", pmos_fast]]
+        for name, placement_map in gen_list:
+            grid_name  = placement_map["grid"]
+
+            temp = TileMOSTemplate( tlib, glib, grid_name, routing_map, placement_map, placement_pattern, transform_pattern, name)
+            tlib.append(temp)
+    
+        gen_list = [["ptap", ptap_fast], ["ntap", ntap_fast] ]
+        for name, placement_map in gen_list:
+            grid_name  = placement_map["grid"]
+        
+            temp       = TileTapTemplate( tlib, glib, grid_name, routing_map, placement_map, placement_pattern, transform_pattern, name)
+            tlib.append(temp)
+
+    
+        gen_list = [["nspace", nspace_fast], ["pspace", pspace_fast] ]
+        for name, placement_map in gen_list:
+            grid_name  = placement_map["grid"]
+        
+            temp       = TileSpaceTemplate( tlib, glib, grid_name, routing_map, placement_map, placement_pattern, transform_pattern, name)
+            tlib.append(temp)
+        return tlib
+
+    # Helper functions. To be customized for target technologies
+    def _iterate_for_generate_tap(iter_num, type_iter):
+        """ Internal function for generate_tap()."""
+        ltap_list = []
+        rtap_list = []
+        ltapbnd_list = []
+        rtapbnd_list = []
+        for idx in range(iter_num): # number of iteration
+            i=0
+            for celltype in type_iter: # in each iteration
+                ltap_list.append(templates[celltype+'mos4_fast_tap'].generate(name='LTAP'+str(idx)+str(i), transform='R0' if transform_iter[i]=='0' else 'MX'))
+                rtap_list.append(templates[celltype+'mos4_fast_tap'].generate(name='RTAP'+str(idx)+str(i), transform='R0' if transform_iter[i]=='0' else 'MX'))
+                ltapbnd_name = 'ptap_fast_left' if celltype == 'n' else 'ntap_fast_left'
+                rtapbnd_name = 'ptap_fast_right' if celltype == 'n' else 'ntap_fast_right'
+                ltapbnd_list.append(templates[ltapbnd_name].generate(name='LTAPBND'+str(idx)+str(i), transform='R0' if transform_iter[i]=='0' else 'MX'))
+                rtapbnd_list.append(templates[rtapbnd_name].generate(name='RTAPBND'+str(idx)+str(i), transform='R0' if transform_iter[i]=='0' else 'MX'))
+                i+=1
+        return ltap_list, rtap_list, ltapbnd_list, rtapbnd_list
+
+    def generate_tap(self, dsn, grids, tlib, templates, type_iter='nppn', type_extra=None, transform_iter='0X0X', transform_extra=None, side='both'): 
+        """ 
+        Generates vertical tap stack(s) on the left and/or right sides of the design.
+
+        Parameters
+        ----------
+        dsn: laygo2.object.database.Design
+            The design object to generate tap(s).
+        grids: laygo2.object.database.GridLibrary
+            The library that contains grid information.
+        type_iter : str
+            list of transistor types for main taps, which is iterated over the entire row.
+            For example, for two NMOS rows and one PMOS row, its value should be ['n', 'n', 'p'].
+            ptaps will be placed for NMOS rows, and ntaps will be placed for PMOS row.
+            It should have the identical dimension (length) with transform_iter. 
+        type_extra : str
+            list of transistor types for residual taps, for the leftover rows after iterations.
+        transform_iter : str
+            list of transform types for main taps.
+        transform_extra : str
+            list of transform types of residual taps.
+        side: str
+            The boundary side of layout to generate taps. The value should be one of the following: both, left, right.
+
+        """
+        pg         = grids["placement_basic"]           # Load basic placement grid for placing taps.
+        height_tap = grids["routing_23_cmos"].height//2 # Calculate the height of tap which is generally the half of the CMOS height.
+    
+        bbox             = dsn.bbox                         # The bbox of the design.
+        height_dsn       = bbox[1][1]                       # The height of the design.
+        total_num_of_tap = int(height_dsn // height_tap) # Total number of taps. 8 taps are needed if there are 4 CMOS grids in the design. 5 taps if 2 CMOS grids and 1 half-CMOS.
+        iter_len         = len(type_iter)                   # length of iteration
+        print('======== TAP GENERATION START ========')
+        print('Total number of taps on each side: ' + str(total_num_of_tap))
+        print('Iteration tap type: {0}. Transform: {1}'.format(type_iter, transform_iter))
+        print('Extra tap type: {0}. Transform: {1}'.format(type_extra, transform_extra))
+ 
+        if total_num_of_tap%iter_len == 0: # full iteration
+            ltap_list, rtap_list, ltapbnd_list, rtapbnd_list = _iterate_for_generate_tap(iter_num = total_num_of_tap//iter_len, type_iter = type_iter)
+ 
+        else: # iteration + extra taps
+            ltap_list, rtap_list, ltapbnd_list, rtapbnd_list = _iterate_for_generate_tap(iter_num = (total_num_of_tap-len(type_extra))//iter_len, type_iter = type_iter) # Iteration
+            i=0
+            for celltype in type_extra: # Extra taps
+                ltap_list.append(templates[celltype+'mos4_fast_tap'].generate(name='LTAPEND'+celltype+str(i), transform='R0' if transform_extra[i]=='0' else 'MX'))
+                rtap_list.append(templates[celltype+'mos4_fast_tap'].generate(name='RTAPEND'+celltype+str(i), transform='R0' if transform_extra[i]=='0' else 'MX'))
+                ltapbnd_name = 'ptap_fast_left' if celltype == 'n' else 'ntap_fast_left'
+                rtapbnd_name = 'ptap_fast_right' if celltype == 'n' else 'ntap_fast_right'
+                ltapbnd_list.append(templates[ltapbnd_name].generate(name='LTAPBND'+celltype+str(i), transform='R0' if transform_iter[i]=='0' else 'MX'))
+                rtapbnd_list.append(templates[rtapbnd_name].generate(name='RTAPBND'+celltype+str(i), transform='R0' if transform_iter[i]=='0' else 'MX'))
+                i+=1
+        
+        # Place TAPs on the design.
+        if side == 'both':
+            dsn.place(grid=pg, inst=np.array(rtap_list   ).reshape(len(rtap_list   ),1), mn=pg.mn.bottom_right(bbox))
+            dsn.place(grid=pg, inst=np.array(rtapbnd_list).reshape(len(rtapbnd_list),1), mn=pg.mn.bottom_right(rtap_list[0]))
+            dsn.place(grid=pg, inst=np.array(ltap_list   ).reshape(len(ltap_list   ),1), mn=pg.mn.bottom_left(bbox)         - pg.mn.width_vec(ltap_list[0]))
+            dsn.place(grid=pg, inst=np.array(ltapbnd_list).reshape(len(ltapbnd_list),1), mn=pg.mn.bottom_left(ltap_list[0]) - pg.mn.width_vec(ltapbnd_list[0]))
+        elif side == 'left':
+            dsn.place(grid=pg, inst=np.array(ltap_list   ).reshape(len(ltap_list   ),1), mn=pg.mn.bottom_left(bbox)         - pg.mn.width_vec(ltap_list[0]))
+            dsn.place(grid=pg, inst=np.array(ltapbnd_list).reshape(len(ltapbnd_list),1), mn=pg.mn.bottom_left(ltap_list[0]) - pg.mn.width_vec(ltapbnd_list[0]))
+        elif side == 'right':
+            dsn.place(grid=pg, inst=np.array(rtap_list   ).reshape(len(rtap_list   ),1), mn=pg.mn.bottom_right(bbox))
+            dsn.place(grid=pg, inst=np.array(rtapbnd_list).reshape(len(rtapbnd_list),1), mn=pg.mn.bottom_right(rtap_list[0])) 
+ 
+        bbox = dsn.bbox
+ 
+        if bbox[0][0] != 0:
+            for _dsn in dsn:
+                dsn.elements[_dsn].xy -= [bbox[0][0],0]
+        print('========= TAP GENERATION END =========')
+
+    def generate_gbnd(self, dsn, grids, templates):
+        """ 
+        Generates global boundary structures around the design.
+        (Check the name of gbnd cells since those are different by each template library)
+        """
+ 
+        # Call placement grid and calculate the bounding box of the design.
+        pg = grids["placement_basic"]
+        bbox_xy = dsn.bbox
+        bbox_mn = pg.mn(dsn.bbox)
+        
+        # Call each dummy GBND cell from template library to calculate the height and width of each cell.
+        gbnd_vertical_dmy   = templates["boundary_topleft"].generate(name="gbnd_vertical_dmy"  )
+        gbnd_horizontal_dmy = templates["boundary_top"    ].generate(name="gbnd_horizontal_dmy")
+        gbnd_corner_dmy     = templates["boundary_topleft"].generate(name="gbnd_corner_dmy"    )
+        
+        # Calculate the number of mosaic and generate GBND cells to be placed. 
+        num_horizontal = bbox_mn[1][0]-bbox_mn[0][0]
+        itop_gb   = templates["boundary_top"].generate( name="gbnd_top", transform='MX', shape=[num_horizontal, 1] )
+        ibot_gb   = templates["boundary_top"].generate( name="gbnd_bot", transform='R0', shape=[num_horizontal, 1] ) 
+ 
+        num_vertical = bbox_mn[1][1]//pg.mn.height(gbnd_vertical_dmy)
+        ileft_gb  = templates["boundary_topleft"].generate( name="gbnd_left",  transform='R0', shape=[1, num_vertical] )
+        iright_gb = templates["boundary_topleft"].generate( name="gbnd_right", transform='MY', shape=[1, num_vertical] )  
+ 
+        ibl_gb    = templates["boundary_topleft"].generate( name="gbnd_bl", transform='R0'   )  
+        ibr_gb    = templates["boundary_topleft"].generate( name="gbnd_br", transform='MY'   )  
+        itr_gb    = templates["boundary_topleft"].generate( name="gbnd_tr", transform='R180' )  
+        itl_gb    = templates["boundary_topleft"].generate( name="gbnd_tl", transform='MX'   )  
+ 
+        # Place GBND cells on the design.    
+        dsn.place(grid=pg, inst=itop_gb,   mn=pg.mn.top_left(    bbox_xy) + pg.mn.height_vec(gbnd_horizontal_dmy)) # TOP
+        dsn.place(grid=pg, inst=ibot_gb,   mn=pg.mn.bottom_left( bbox_xy) - pg.mn.height_vec(gbnd_horizontal_dmy)) # BOTTOM
+ 
+        dsn.place(grid=pg, inst=ileft_gb,  mn=pg.mn.bottom_left( bbox_xy) - pg.mn.width_vec( gbnd_vertical_dmy  )) # LEFT
+        dsn.place(grid=pg, inst=iright_gb, mn=pg.mn.bottom_right(bbox_xy) + pg.mn.width_vec( gbnd_vertical_dmy  )) # RIGHT
+  
+        dsn.place(grid=pg, inst=ibl_gb,    mn=pg.mn.bottom_left( ibot_gb) - pg.mn.width_vec( gbnd_corner_dmy    )) # BOTTOM LEFT CORNER
+        dsn.place(grid=pg, inst=ibr_gb,    mn=pg.mn.bottom_right(ibot_gb) + pg.mn.width_vec( gbnd_corner_dmy    )) # BOTTOM RIGHT CORNER
+        dsn.place(grid=pg, inst=itl_gb,    mn=pg.mn.top_left(   ileft_gb) + pg.mn.height_vec(gbnd_corner_dmy    )) # TOP LEFT CORNER
+        dsn.place(grid=pg, inst=itr_gb,    mn=pg.mn.top_right( iright_gb) + pg.mn.height_vec(gbnd_corner_dmy    )) # TOP RIGHT CORNER
+ 
+        bbox_xy = dsn.bbox
+ 
+        if bbox_xy[0][0] != 0:
+            for _dsn in dsn:
+                dsn.elements[_dsn].xy -= [bbox_xy[0][0],0]
+
+    def generate_pwr_rail(self, dsn, grids, tlib=None, templates=None, route_type='cmos', netname=None, vss_name='VSS', vdd_name='VDD', rail_swap=False, vertical=False, pin_num=0, pin_pitch=0):
+        """ 
+        Generates thick wire rails for supplies (VDD, VSS)
+            
+        Parameters
+        ----------
+        route_type : str
+            The type of routing style ('cmos', 'mos', 'cmos_flipped')
+        netname : str or list
+            The name of nets
+            ex) 'VDD', ['VDD', 'VSS'], ['VDD', 'VSS', ['VDD', -1]]
+        vss_name : str
+            The name of GROUND net (will be deprecated)
+        vdd_name : str
+            the name of POWER net (will be deprecated)
+        rail_swap : boolean
+            Determine the bottom rail is GND or POWER net. 0 for GND 1 for POWER (will be deprecated).
+        vertical : boolean
+            whether generate vertical wires for connecting each horizontal rail
+        pin_num : int
+            the number of pins
+        pin_pitch : int
+            the pitch between pins in the abstract coordinate
+        """
+ 
+        print('=========== SUPPLY RAIL GENERATION START ===========')
+        # 1. Load grids
+        r23 = grids['routing_23_{0}'.format(route_type)]                                        # "CMOS grid" to calculate the number of power rails
+        if route_type != 'mos': r23t = grids['routing_23_{0}_thick'.format(route_type)]         # "CMOS grid" to make M3 vertical rails.
+        else: r23t = grids['routing_23_{0}'.format(route_type)]                                 # "MOS grid" to calculate the number of power rails
+        
+ 
+        # 2. Calculate the number of power rails in the design
+        bbox = dsn.bbox
+        grid_cnt = bbox[1,1] // r23.height
+        bottom_rail = [r23.mn.bottom_left(bbox), r23.mn.bottom_right(bbox)]                     # bbox for M2 bottom rail
+ 
+        if netname == None:
+            """
+                This block is for old-version users.
+                It will be removed later. :D
+            """
+ 
+            print("\n[WARNING] generate_pwr_rail with vss_name/vdd_name arguments will be deprecated.\n")
+            if grid_cnt%2 == 0:
+                iter_vdd = grid_cnt//2
+                iter_vss = grid_cnt//2 + 1
+ 
+            else:
+                iter_vdd = (grid_cnt+1)//2
+                iter_vss = (grid_cnt+1)//2
+ 
+            pw_len = 2
+ 
+            rvss = []
+            rvdd = []
+            vss_set = [iter_vss, rvss, vss_name]
+            vdd_set = [iter_vdd, rvdd, vdd_name]
+ 
+            pw_set = np.array([vss_set, vdd_set])
+ 
+            if rail_swap: 
+                pw_set[0][2] = vdd_name
+                pw_set[1][2] = vss_name
+            
+            pw_iter = grid_cnt + 1 
+            rail_count = {}
+            rail_change = {}
+        
+        else:
+            # 3. Generate a power rail list.
+            pw_iter = grid_cnt + 1 
+ 
+            # Check the type of netname.
+            if type(netname) == str:
+                netname = netname.split()
+                rail_change = {}
+ 
+            else:
+                rail_change = {}
+                for _name in netname:
+                    if type(_name) == list:
+                        try: 
+                            if _name[1] < 0: _name[1] += pw_iter
+                            rail_change[_name[0]].append(_name[1])
+                        except: 
+                            rail_change[_name[0]]= [_name[1]]
+            
+            # Create a power rail list.
+            netname = list(filter(lambda x: type(x)==str, netname))
+            pw_len = len(netname)
+            pw_set = np.empty(shape=(pw_len, 3), dtype=object)
+ 
+            # Calculate the number of iterations of each power net.      
+            pw_set[:pw_len,0] = pw_iter // pw_len
+            pw_set[0:(pw_iter % pw_len), 0] += 1
+ 
+            for i in range(pw_len): 
+                pw_set[i, 1] = []
+                pw_set[i, 2] = netname[i]
+            
+            # Rail swap for Iterated rails (Optional).
+            if rail_swap: pw_set[:pw_len,2] = np.flip(pw_set[:pw_len,2])
+ 
+            # Revise the list.
+            for _name, _num in rail_change.items():
+                for idx in _num:
+                    pw_set[(idx%pw_len), 0] -= 1
+                
+                if _name in netname:
+                    pin_ex = pw_set[:,2].tolist().index(_name)
+                    pw_set[pin_ex, 0] += len(_num)
+                
+                else:
+                    pw_extra = [len(_num), [], _name]
+                    pw_set = np.append(pw_set, [pw_extra], axis=0)
+ 
+            # Count the number of each rail.
+            rail_count = {}
+            for _name, _num in rail_change.items():
+                for idx in _num:
+                    rail_count[idx] = _name
+            
+            # Remove zero-rails.
+            zero_list = list(np.where(pw_set[:,0]==0))[0]
+            pw_set = np.delete(pw_set, zero_list, 0)
+            pw_len -= len(zero_list)
+ 
+        # 4. Generate iterated power rails
+        pin_name = []
+ 
+        for idx in range(pw_iter):
+            pin = idx % pw_len
+            iter = idx // pw_len
+ 
+            # Generate a horizontal rail
+            _mn = bottom_rail
+            _mn[0][1] = r23.n(r23.height) * (pw_len*iter+pin)
+            _mn[1][1] = r23.n(r23.height) * (pw_len*iter+pin)
+ 
+            route = dsn.route(grid=r23, mn=_mn)
+            
+            # Check the netname.
+            if idx in rail_count.keys():
+                _netname = rail_count[idx]
+                pin = pw_set[:,2].tolist().index(_netname)
+                pw_set[pin][1].append(route)
+                pin_name.append("{0}:".format(_netname))
+            
+            else: 
+                pw_set[pin][1].append(route)
+                pin_name.append(pw_set[pin][2]+':')
+ 
+            # Generate the vertical vias (Optional).
+            if vertical & (pw_set[pin][0] != 1):
+                if pin % 2 == 0: dsn.via(grid=r23t, mn=r23t.mn.bottom_left(pw_set[pin][1][-1])-[pin,0])
+                else: dsn.via(grid=r23t, mn=r23t.mn.bottom_right(pw_set[pin][1][-1])+[pin-1,0])
+        
+        bbox = dsn.bbox
+ 
+        for idx in range(len(pw_set)):
+            # Generate the vertical rails (Optional).
+            if vertical & (pw_set[idx][0] != 1) :
+                if idx % 2 == 0:
+                    _mn = [r23t.mn.bottom_left(pw_set[idx][1][0])-[idx,0], r23t.mn.bottom_left(pw_set[idx][1][-1])-[idx,0]]
+                else:
+                    _mn = [r23t.mn.bottom_right(pw_set[idx][1][0])+[(idx-1),0], r23t.mn.bottom_right(pw_set[idx][1][-1])+[(idx-1),0]]
+                dsn.route(grid=r23t, mn=_mn)
+            
+        
+            # Rail extension (Optional).
+            if vertical & any(1 < i for i in pw_set[:,0]):
+                for x in range(len(pw_set[idx][1])):
+                    pw_set[idx][1][x].xy[0][0] = bbox[0][0]
+                    pw_set[idx][1][x].xy[1][0] = bbox[1][0]
+ 
+        # 5. Check whether two variables (pin_num and pin_pitch) are entered properly.
+        bottom_rail = [r23.mn.bottom_left(bbox), r23.mn.bottom_right(bbox)]
+ 
+        if (pin_num == 0) & (pin_pitch == 0) : pin_num = 1 
+        elif (pin_num < 0) | (pin_pitch < 0) :
+            pin_num = 1
+            pin_pitch = 0
+            print('\n[WARNING] You entered negative number.\n')
+        elif (pin_num != 0) & (pin_pitch != 0) : 
+            pin_pitch = 0
+            print('\n[WARNING] You have to choose between pin_num or pin_pitch.\nLAYGO2 follows <pin_num> this time.\n')
+ 
+        pwidth = bottom_rail[1][0] - bottom_rail[0][0]
+ 
+        # 6. Compare between pwidth and (pin_num / pin_pitch).
+        if pin_num != 0: 
+            if pin_num > pwidth:
+                pin_num = pwidth
+                pin_pitch = 1
+                print('"You want too many pins. x_x')
+                print('The maximum number of pins : {0}"\n'.format(pwidth))
+            else: pin_pitch = pwidth//pin_num
+        elif pin_pitch != 0: 
+            if pin_pitch > pwidth: 
+                pin_pitch = pwidth
+                print('"You want too wide pitch. x_x')
+                print("The minimum number of pin : 1")
+                print('Thus, one pin is generated each."\n')
+            pin_num = pwidth // pin_pitch
+ 
+        # 7. Generate iterated power rails.
+        for idx in range(pw_iter):
+            pin = idx % pw_len
+            iter = idx // pw_len
+ 
+            _mn = bottom_rail
+            _mn[0][1] = r23.n(r23.height) * (pw_len*iter+pin)
+            _mn[1][1] = r23.n(r23.height) * (pw_len*iter+pin)
+ 
+            pmin = _mn[0]
+            pmax = _mn[1]
+            pp = np.array([pmin, pmin]) + np.array([[(pwidth%pin_num)//2, 0], [(pwidth%pin_num)//2, 0]])
+ 
+            for pn in range(0, pin_num):
+                pp[1] += [pin_pitch, 0]
+                dsn.pin(name="net{0}_{1}".format(idx, pn), grid=r23, mn=pp, netname=pin_name[idx])
+                pp[0] += [pin_pitch, 0]
+ 
+        # 8. Set X coordinate as zero.
+        if bbox[0][0] != 0:
+            for _dsn in dsn:
+                dsn.elements[_dsn].xy -= [bbox[0][0],0]
+ 
+        # 9. Print messages about the results.
+        print('\nThe number of rails of your design is {0}.\n'.format(grid_cnt) + "The number of pins of your design is {0}.\n".format(len(pw_set)) + '\nName of Iterated net:')
+ 
+        for i in range(pw_len): print('{0}. "{1}"'.format(i, pw_set[i][2]))
+        if rail_change:
+            print('\nName of Changed net:')
+            for _num, _name in sorted(rail_count.items()): print('Rail #{0} :  "{1}"'.format(_num, _name))    
+        print('\n============ SUPPLY RAIL GENERATION END ============')
+
+    def extend_wire(self, dsn, layer='M4', target=500):
+        """
+        Extend routing wires to meet the design rules about area or width of wires. This function is executed as follows:
+        1. Find matched rects with the given layer in design.
+        2. Check the direction of rect (horizontal or vertical). Do nothing if the rect is zero sized.
+        3. Calculate total width/height of the rect and check whether the rect violates the design rule.
+        4. Calculate delta (amount of extension) and create rect with new extension but maintaining bbox.
+        5. Append new rects to the design and delete old rects.
+        
+        Parameters
+        ----------
+        dsn : laygo2.object.database.Design
+            Design to be implemented.
+        layer : str
+            Name of layer for extension.
+        target : int
+            Target width/height of wires to be extended.
+        """
+ 
+        rect_list = dsn.get_matchedrects_by_layer([layer, 'drawing'])    
+        for rect in rect_list:
+            if rect.height == 0 and rect.width == 0:
+                direction = 'horizontal' if layer in ['M2','M4','M6'] else 'vertical'
+                check = rect.width + 2*rect.hextension if direction == 'horizontal' else rect.height + 2*rect.vextension
+                
+                if check < target:
+                    delta = (target - check)//2
+                    if direction == 'horizontal':
+                        p = laygo2.object.physical.Rect(xy=rect.bbox, layer=rect.layer, hextension=rect.hextension0+delta, 
+                        vextension=rect.vextension0, color=rect.color)
+                    else:
+                        p = laygo2.object.physical.Rect(xy=rect.bbox, layer=rect.layer, hextension=rect.hextension0, 
+                        vextension=rect.vextension0+delta, color=rect.color)
+ 
+                    dsn.append(p)
+ 
+                    for key, value in list(dsn.items()):
+                        if value == rect:
+                            del dsn.elements[key]
+                        else:
+                            pass
+                else:
+                    pass
+ 
+            else:
+                direction = 'horizontal' if rect.height == 0 else 'vertical'
+                check = rect.width + 2*rect.hextension if direction == 'horizontal' else rect.height + 2*rect.vextension
+ 
+                if check < target:
+                    delta = (target - check)//2
+                    if direction == 'horizontal':
+                        hextension = round(rect.hextension+delta, -1)
+                        p = laygo2.object.physical.Rect(xy=rect.bbox, layer=rect.layer, hextension=hextension, 
+                        vextension=rect.vextension, color=rect.color)
+                    else:
+                        vextension = round(rect.vextension+delta, -1)
+                        p = laygo2.object.physical.Rect(xy=rect.bbox, layer=rect.layer, hextension=rect.hextension, 
+                        vextension=vextension, color=rect.color)
+ 
+                    dsn.append(p)
+ 
+                    for key, value in list(dsn.items()):
+                        if value == rect:
+                            del dsn.elements[key]
+                        else:
+                            pass
+                else:
+                    pass
+
+    def fill_by_instance(self, dsn, grids, tlib, templates, inst_name:tuple, canvas_area="full", shape=[1,1], iter_type=("R0","MX"), pattern_direction='v', fill_sort='filler'):
+        """ Fill empty layout space by given instances.
+            
+            Parameters
+            ----------
+            inst_name : tuple
+                the name of the instance to fill empty layout space.
+            canvas_area : "full" or list
+                the range of the space to be filled.
+            shape : list
+                the shape of the given instances.
+            iter_type : tuple
+                Transform types of iterating instances.
+            pattern_direction : str
+                Determine the direction of iterating instances. ('v' : vertical, 'h' : horizontal)
+            fill_sort : str
+                the name of the created iterating instances.
+        """
+ 
+        print('\n=========== FILLING EMPTY LAYOUT SPACE START ===========')
+ 
+        pg = grids["placement_basic"]
+ 
+        # 1. Check the canvas.
+        dsnbbox = pg.mn(dsn.bbox)
+ 
+        offset  = dsnbbox[0]
+        width   = dsnbbox[1][0] - 0
+        height  = dsnbbox[1][1] - dsnbbox[0][1]
+ 
+        canvas = np.zeros((height, width), dtype=int)
+ 
+        def check_occupied(canvas, physical, index):
+            bbox = pg.mn(physical.bbox)
+            x0 = bbox[0][0]
+            x1 = bbox[1][0]
+            y0 = bbox[0][1]
+            y1 = bbox[1][1]
+            if x0 == x1 and y0 == y1:
+                return
+            canvas[y0:y1, x0:x1] = index
+ 
+        index = 1
+ 
+        for n, inst in dsn.instances.items():
+            check_occupied(canvas, inst, index)
+            index = index + 1
+        for n, vinst in dsn.virtual_instances.items():
+            check_occupied(canvas, vinst, index)
+            index = index + 1
+ 
+        if canvas_area != "full":
+            bbox_l0 = pg.mn.bottom_left(canvas_area[0])
+            bbox_l1 = pg.mn.bottom_right(canvas_area[0])
+            bbox_r0 = pg.mn.top_left(canvas_area[1])
+            bbox_r1 = pg.mn.top_right(canvas_area[1])
+ 
+            width   = abs(bbox_r1[0] - bbox_l0[0])
+            height  = abs(bbox_r1[1] - bbox_l0[1])
+            offset  = bbox_l0
+ 
+            canvas = canvas[bbox_l0[1]:bbox_r1[1],bbox_l0[0]:bbox_r1[0]]
+        else:
+            bbox_l0 = dsnbbox[0]
+            bbox_l1 = dsnbbox[0] + [dsnbbox[1][0],0]
+            bbox_r0 = dsnbbox[1] - [dsnbbox[1][0],0]
+            bbox_r1 = dsnbbox[1]
+ 
+        def check_name(inst_name, boundary_name):
+            if type(inst_name) == str:
+                inst_name = inst_name.split()
+            else:
+                for _name in inst_name:
+                    if type(_name) == list:
+                        try:
+                            boundary_name[_name[0]].append(_name[1])
+                        except:
+                            boundary_name[_name[0]] = [_name[1]]
+ 
+            inst_name = list(filter(lambda x: type(x)==str, inst_name))
+            return inst_name, boundary_name
+ 
+        # 2. Fill the empty space.
+        boundary_name = {}
+        inst_name, boundary_name = check_name(inst_name, boundary_name)
+ 
+        filler   = templates[inst_name[0]].generate(name=fill_sort, transform="R0", shape=shape)
+ 
+        f_height = pg.mn(filler)[1][1]
+        f_width  = pg.mn(filler)[1][0]
+        n_mod    = int(height / f_height)
+        print(boundary_name)
+        for _name, _num in boundary_name.items():
+            for i in range(len(_num)):
+                if _num[i] < 0: 
+                    if pattern_direction == 'v': boundary_name[_name][i] += ((bbox_r0[1]-bbox_l1[1]) // f_height)
+                    elif pattern_direction == 'h': boundary_name[_name][i] += ((bbox_r0[0]-bbox_l1[0]) // f_width)
+ 
+        boundary_count = {}
+        for _name, _num in boundary_name.items():
+            for idx in _num:
+                boundary_count[idx] = _name
+ 
+        pattern_name = 0
+        for y in range(n_mod):
+            buffers = []
+ 
+            if pattern_direction == 'v':
+                if y in boundary_count.keys(): it = boundary_count[y]
+                else: 
+                    it = inst_name[pattern_name]
+                    pattern_name = (pattern_name + 1) % len(inst_name)
+            elif pattern_direction == 'h': pattern_name = 0
+ 
+            for x in range(width):
+                if canvas[f_height * y, x] == 0:
+                    buffers.append(True)
+ 
+                    if np.array_equal(buffers, [True] * f_width):
+                        if pattern_direction == 'h':
+                            h_num = int((x - (bbox_l1[0] - bbox_l0[0])) / f_width)
+                            if h_num in boundary_count.keys(): 
+                                it = boundary_count[h_num]
+                            else: 
+                                it = inst_name[pattern_name]
+                                if h_num != 0: pattern_name = (pattern_name + 1) % len(inst_name)
+                            
+                        tf = iter_type[int(y % len(iter_type))]
+                        _mn = np.asarray([x-f_width+1, y * f_height])+offset
+                        if tf == "MX": _mn = _mn + [0, f_height]
+                        dsn.place(grid=pg, inst=templates[it].generate(name=fill_sort + f"{x}_{y * f_height}", transform=tf, shape=shape), mn=_mn)
+                        buffers = []
+                else:
+                    buffers = []
+        print('============ FILLING EMPTY LAYOUT SPACE END ============')
+        return canvas
+
+    def generate_cut_layer(self, dsn, grid, grid_cut, layer: str, space_min: float, flip=0 ):
+        """ place the instance(cut-via) when layer space violation occurs """
+        from collections import defaultdict
+        rects  = dsn.rects
+        insts  = dsn.instances
+        vinsts = dsn.virtual_instances
+        xy     = dsn.bbox
+        pins   = dsn.pins
+ 
+        def get_ebbox(obj):
+            """ refine and get bbox from the object  """
+            ebbox = np.zeros( (5,2), dtype=np.int64 )
+ 
+            if isinstance(obj, laygo2.object.physical.Rect): # apply hextensions
+                ebbox[0] = obj.bbox[0] - np.array([obj.hextension, 0])
+                ebbox[1] = obj.bbox[1] + np.array([obj.hextension, 0])
+                ebbox[2] = ebbox[2] + np.array([ obj.hextension, 0 ])
+                ebbox[3] = ebbox[3] + np.array([ 0, obj.vextension])
+            else:
+                ebbox[0:2] = obj.bbox
+ 
+            if obj.bbox[0][1] != obj.bbox[1][1]: # obj has no-zero height
+                h_avr = int( 0.5 * ( obj.bbox[1][1] +  obj.bbox[0][1] ) )
+                ebbox[0][1] = h_avr
+                ebbox[1][1] = h_avr
+ 
+ 
+            return ebbox
+ 
+        def place( xy_w, xy_e, obj_w, obj_e, grid_cut ):
+            """ place the cut-via """
+ 
+            mn_w = grid_cut.mn(xy_w)
+            mn_e = grid_cut.mn(xy_e)
+            #print("convert")
+            #print(grid_cut.name)
+            #print( grid_cut.range )
+            #print(mn_w)
+            #print(mn_e)
+            mn_w = mn_w.astype(int)
+            mn_e = mn_e.astype(int)
+            #print(mn_w)
+            #print(mn_e)
+            mn_c = ( 0.5*(mn_w + mn_e) ).astype(int)
+            dsn.via( grid=grid_cut, mn= mn_c )
+ 
+        def check_space_ok( xw:float, xe:float, space:float ):
+            """ check space is enough  """
+            delta = xe - xw
+            print("check space", end=" ")
+            print(f"{xw}, {xe}, delta:{delta}, space:{space}")
+ 
+            if 0 < delta < space: # error
+                print("##cut")
+                return False
+            else:               # pass  or overlap
+                #print("no cut")
+                return True
+ 
+        space_min_edge = space_min  ## for space at edge,
+ 
+        objs_to_check = dsn.get_matched_rects_by_layer( [layer, "drawing"]   )
+        objs_to_check.extend( dsn.get_matched_rects_by_layer( [layer, "pin"] ))
+ 
+        objs_toppin = []
+        for rname, rect in rects.items():
+            if np.array_equal(rect.layer, [layer,"pin" ] ):
+                objs_toppin.append(rect)
+ 
+        for rname, pin in pins.items():
+            if np.array_equal(pin.layer, [layer,"pin" ] ):
+                objs_toppin.append(pin)
+ 
+        ebboxs_to_check= []
+        ebboxs_toppin  = []
+ 
+        objset=( objs_to_check,  objs_toppin   )
+        bboxs =( ebboxs_to_check, ebboxs_toppin  )
+        for n, objs in enumerate( objset):
+            _bboxs = bboxs[n]
+            for i, obj in enumerate(objs):
+                ebbox = get_ebbox(obj) # bl, tr ,hextension, vextension
+                ebbox[4,:] = [ i,i ]   # object index
+                _bboxs.append( ebbox )
+        
+        ebboxs_to_check = np.unique(ebboxs_to_check, axis=0)  ## sort by bottom-left-x and remove duplicated-xy
+        
+        y_box     = defaultdict(list)
+        y_box_pin = defaultdict(list)
+        for ebbox in ebboxs_to_check: # packed by y-axis , assuming rect has 0 height
+            y_box[ ebbox[0][1] ].append( ebbox )
+        
+        for ebbox in ebboxs_toppin: # packed by y-axis , assuming rect has 0 height
+            y_box_pin[ ebbox[0][1] ].append( ebbox )
+ 
+        y_keys = y_box.keys()
+ 
+        for key in y_keys: # scan start
+            ebbox_list  = y_box[key]
+            ebboxs_pin  = y_box_pin.get(key, 0 )
+            i_last      = len(ebbox_list) - 1
+ 
+            i_edges= (0, i_last)
+            #print("##i_edge###")
+            #print(i_edges)
+            #print(key)
+            
+            ## check edge, pin-layer is on edge of design
+            for n, i in enumerate( i_edges ):
+                ebbox_edge = ebbox_list[i]
+                flag_skip  = 0
+                #print(ebbox_edge)
+            
+                if ebboxs_pin == 0 :
+                    flag_skip  = 0
+                else:
+ 
+                    for ebbox_pin in ebboxs_toppin:
+                        bl_pin, tr_pin   = ebbox_pin[0], ebbox_pin[1]
+                        bl_edge, tr_edge = ebbox_edge[0], ebbox_edge[1]
+                        tol = 0.1
+                        # edge pin   e p e p
+                        # pin edge   p e p e
+                        #            e e p p
+                        #            p p e e  
+                        if  ( (bl_pin[0] <= tr_edge[0]) and ( tr_pin[0] >= bl_edge[0] )   or ( ( tr_pin[0]  >= tr_edge[0]  ) and bl_pin[0] <= tr_edge[0] )):
+                            flag_skip  = 1
+                            break
+                        ## the route on the edge is a pin! skip
+                
+                if flag_skip ==1:
+                    continue
+                else:
+                    #print( f" there is no pin on edge {n}")
+                    if n == 0:
+                    #     print("left")
+                         flag = check_space_ok( xy[0][0], ebbox_edge[0][0], space_min_edge) # check left
+                    else:
+                    #    print("right")
+                        flag = check_space_ok( ebbox_edge[1][0], xy[1][0], space_min_edge) # check right
+                    if flag == False: # not ok
+                        _xy = np.array([xy[n][0], ebbox_edge[0][1]]) # edge-xy of design
+                        place( _xy, _xy, dsn, objs_to_check[ebbox_edge[4][0]], grid_cut)
+                 
+            #print("check middle")
+            ## check middle
+            if i_last != 0:
+                iw_ebbox = ebbox_list[0]    # checkking bottom-right
+                for i in range(i_last + 1): # from leftmost-right to rightmost-left
+                    # ie : reference
+                    # iw : target
+                    new_ebbox = ebbox_list[i]
+                    if new_ebbox[1][0] <= iw_ebbox[1][0] : # bottom-right vs bottom-right
+                        continue # skip, it is overlapped
+                    else: # evaluation
+                        ie_ebbox = new_ebbox
+                        flag     = check_space_ok( iw_ebbox[1][0],  ie_ebbox[0][0], space_min )
+                        if flag == False :
+                            print("###################### compensation")
+                            _xy_w =  iw_ebbox[1] - iw_ebbox[2] # compensate extensions for mn converting
+                            _xy_e =  ie_ebbox[0] + ie_ebbox[2] # compensate extensions for mn converting
+ 
+                            place( _xy_w, _xy_e , objs_to_check[ iw_ebbox[4][0]], objs_to_check[ie_ebbox[4][0]], grid_cut )
+                        iw_ebbox = ie_ebbox # update
+
+
+
+
+
+
+    def post_process(self, dsn, grids, tlib, templates ):
+        pass
+        #generate_cut_layer(dsn, grids, tlib, templates)  
+
+# Tests
+if __name__ == '__main__':
+    # Create templates.
+    print("Create templates")
+    _templates = load_templates()
+    for tn, t in _templates.items():
+        print(t)
```

### Comparing `laygo2-0.5.6/laygo2/object/technology/core.py` & `laygo2-0.5.7/laygo2/object/technology/core.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,159 +1,159 @@
-#!/usr/bin/python
-########################################################################################################################
-#
-# Copyright (c) 2014, Regents of the University of California
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-from laygo2.object import *
-#import laygo2.object.database
-#import laygo2.object.grid
-
-import numpy as np
-
-# Base technology object
-class BaseTechnology:
-    """
-    A base class that implements basic functions for 
-    technology parameters and objects, such as TemplateLibrary and 
-    GridLibrary objects.
-    """
-
-    tech_params = None
-    """dict: Dictionary contains technology parameters"""
-
-    tech_templates = None
-    """laygo2.object.database.TemplateLibrary: The template library 
-    object that contains primitive templates
-    """
-    tech_grids = None
-    """laygo2.object.database.GridLibrary: The template library 
-    object that contains primitive grids
-    """
-
-    def __init__(self, tech_params, libname=None):
-        """Constructor"""
-        # Library name
-        if libname is None:
-            ln = list(tech_params['templates'].keys())[0]
-        else:
-            ln = libname
-        self.tech_params = tech_params
-        self.tech_templates = self.load_tech_templates(libname=libname)
-        self.tech_grids = self.load_tech_grids(templates = self.tech_templates,
-                                               libname=libname)
-
-    def load_tech_templates(self, libname=None):
-        """Load templates and construct a template library object.
-            libname: optional, str
-                The name of library to be loaded. 
-                By default, the first library in tech_params['templates'] is used.
-        """
-        
-        # Library name
-        if libname is None:
-            ln = list(self.tech_params['templates'].keys())[0]
-        else:
-            ln = libname
-        # Template library
-        tlib    = laygo2.object.database.TemplateLibrary(name = ln)
-        # Include templates as needed, as follows:
-        '''
-        t1 = laygo2.object.NativeInstanceTemplate()
-        tlib.append(t1)
-        t2 = laygo2.object.NativeInstanceTemplate()
-        tlib.append(t2)
-        '''
-        # Bind to self.tech_templates
-        self.tech_templates = tlib
-        return tlib
-     
-    def load_tech_grids(self, templates, libname=None, params=None):
-        """
-        Load technology grids to a grid library object.
-
-        Parameters
-        ----------
-        libname: optional, str
-            The name of library to be loaded. 
-            By default, the first library in tech_params['grids'] is used.
-        params: optional, dict
-            The dictionary that contains optional parameters for update() function.
-        """
-        # Library name
-        if libname is None:
-            ln = list(self.tech_params['grids'].keys())[0]
-        else:
-            ln = libname
-        # Grid library
-        glib = laygo2.object.database.GridLibrary(name=ln)
-
-        for gn, gdict in self.tech_params['grids'][ln].items():
-            gv = laygo2.object.grid.OneDimGrid(name=gn + '_v', scope=gdict['vertical']['scope'],
-                                               elements=gdict['vertical']['elements'])
-            gh = laygo2.object.grid.OneDimGrid(name=gn + '_h', scope=gdict['horizontal']['scope'],
-                                               elements=gdict['horizontal']['elements'])
-            if gdict['type'] == 'placement':  # placement grid
-                g = laygo2.object.grid.PlacementGrid(name=gn, vgrid=gv, hgrid=gh)
-                glib.append(g)
-            elif gdict['type'] == 'routing':  # routing grid
-                vwidth = laygo2.object.grid.CircularMapping(elements=gdict['vertical']['width'])
-                hwidth = laygo2.object.grid.CircularMapping(elements=gdict['horizontal']['width'])
-                vextension = laygo2.object.grid.CircularMapping(elements=gdict['vertical']['extension'])
-                hextension = laygo2.object.grid.CircularMapping(elements=gdict['horizontal']['extension'])
-                vextension0 = laygo2.object.grid.CircularMapping(elements=gdict['vertical']['extension0'])
-                hextension0 = laygo2.object.grid.CircularMapping(elements=gdict['horizontal']['extension0'])
-                vlayer = laygo2.object.grid.CircularMapping(elements=gdict['vertical']['layer'], dtype=object)
-                hlayer = laygo2.object.grid.CircularMapping(elements=gdict['horizontal']['layer'], dtype=object)
-                pin_vlayer = laygo2.object.grid.CircularMapping(elements=gdict['vertical']['pin_layer'], dtype=object)
-                pin_hlayer = laygo2.object.grid.CircularMapping(elements=gdict['horizontal']['pin_layer'], dtype=object)
-                xcolor = laygo2.object.grid.CircularMapping(elements=gdict['vertical']['xcolor'], dtype=object)
-                ycolor = laygo2.object.grid.CircularMapping(elements=gdict['horizontal']['ycolor'], dtype=object)
-                primary_grid = gdict['primary_grid']
-                # Create the via map defined by the yaml file.
-                vmap_original = gdict['via']['map']  # viamap defined in the yaml file.
-                vmap_mapped = list()  # map template objects to the via map.
-                for vmap_org_row in vmap_original:
-                    vmap_mapped_row = []
-                    for vmap_org_elem in vmap_org_row:
-                        vmap_mapped_row.append(templates[vmap_org_elem])
-                    vmap_mapped.append(vmap_mapped_row)
-                viamap = laygo2.object.grid.CircularMappingArray(elements=vmap_mapped, dtype=object)
-                g = laygo2.object.grid.RoutingGrid(name=gn, vgrid=gv, hgrid=gh,
-                                                   vwidth=vwidth, hwidth=hwidth,
-                                                   vextension=vextension, hextension=hextension,
-                                                   vlayer=vlayer, hlayer=hlayer,
-                                                   pin_vlayer=pin_vlayer, pin_hlayer=pin_hlayer,
-                                                   viamap=viamap, primary_grid=primary_grid,
-                                                   xcolor=xcolor, ycolor=ycolor,
-                                                   vextension0=vextension0, hextension0=hextension0)
-                glib.append(g)
-
-        # Update grid based on input parameters.
-        if params is not None:
-            glib = self.update(glib, params=params)
-
-        # Bind to self.tech_grid
-        self.tech_grid = glib
-        return glib
-
-    def update(self, grid_lib, params):
-        return grid_lib  # do nothing for base class
-
+#!/usr/bin/python
+########################################################################################################################
+#
+# Copyright (c) 2014, Regents of the University of California
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+from laygo2.object import *
+#import laygo2.object.database
+#import laygo2.object.grid
+
+import numpy as np
+
+# Base technology object
+class BaseTechnology:
+    """
+    A base class that implements basic functions for 
+    technology parameters and objects, such as TemplateLibrary and 
+    GridLibrary objects.
+    """
+
+    tech_params = None
+    """dict: Dictionary contains technology parameters"""
+
+    tech_templates = None
+    """laygo2.object.database.TemplateLibrary: The template library 
+    object that contains primitive templates
+    """
+    tech_grids = None
+    """laygo2.object.database.GridLibrary: The template library 
+    object that contains primitive grids
+    """
+
+    def __init__(self, tech_params, libname=None):
+        """Constructor"""
+        # Library name
+        if libname is None:
+            ln = list(tech_params['templates'].keys())[0]
+        else:
+            ln = libname
+        self.tech_params = tech_params
+        self.tech_templates = self.load_tech_templates(libname=libname)
+        self.tech_grids = self.load_tech_grids(templates = self.tech_templates,
+                                               libname=libname)
+
+    def load_tech_templates(self, libname=None):
+        """Load templates and construct a template library object.
+            libname: optional, str
+                The name of library to be loaded. 
+                By default, the first library in tech_params['templates'] is used.
+        """
+        
+        # Library name
+        if libname is None:
+            ln = list(self.tech_params['templates'].keys())[0]
+        else:
+            ln = libname
+        # Template library
+        tlib    = laygo2.object.database.TemplateLibrary(name = ln)
+        # Include templates as needed, as follows:
+        '''
+        t1 = laygo2.object.NativeInstanceTemplate()
+        tlib.append(t1)
+        t2 = laygo2.object.NativeInstanceTemplate()
+        tlib.append(t2)
+        '''
+        # Bind to self.tech_templates
+        self.tech_templates = tlib
+        return tlib
+     
+    def load_tech_grids(self, templates, libname=None, params=None):
+        """
+        Load technology grids to a grid library object.
+
+        Parameters
+        ----------
+        libname: optional, str
+            The name of library to be loaded. 
+            By default, the first library in tech_params['grids'] is used.
+        params: optional, dict
+            The dictionary that contains optional parameters for update() function.
+        """
+        # Library name
+        if libname is None:
+            ln = list(self.tech_params['grids'].keys())[0]
+        else:
+            ln = libname
+        # Grid library
+        glib = laygo2.object.database.GridLibrary(name=ln)
+
+        for gn, gdict in self.tech_params['grids'][ln].items():
+            gv = laygo2.object.grid.OneDimGrid(name=gn + '_v', scope=gdict['vertical']['scope'],
+                                               elements=gdict['vertical']['elements'])
+            gh = laygo2.object.grid.OneDimGrid(name=gn + '_h', scope=gdict['horizontal']['scope'],
+                                               elements=gdict['horizontal']['elements'])
+            if gdict['type'] == 'placement':  # placement grid
+                g = laygo2.object.grid.PlacementGrid(name=gn, vgrid=gv, hgrid=gh)
+                glib.append(g)
+            elif gdict['type'] == 'routing':  # routing grid
+                vwidth = laygo2.object.grid.CircularMapping(elements=gdict['vertical']['width'])
+                hwidth = laygo2.object.grid.CircularMapping(elements=gdict['horizontal']['width'])
+                vextension = laygo2.object.grid.CircularMapping(elements=gdict['vertical']['extension'])
+                hextension = laygo2.object.grid.CircularMapping(elements=gdict['horizontal']['extension'])
+                vextension0 = laygo2.object.grid.CircularMapping(elements=gdict['vertical']['extension0'])
+                hextension0 = laygo2.object.grid.CircularMapping(elements=gdict['horizontal']['extension0'])
+                vlayer = laygo2.object.grid.CircularMapping(elements=gdict['vertical']['layer'], dtype=object)
+                hlayer = laygo2.object.grid.CircularMapping(elements=gdict['horizontal']['layer'], dtype=object)
+                pin_vlayer = laygo2.object.grid.CircularMapping(elements=gdict['vertical']['pin_layer'], dtype=object)
+                pin_hlayer = laygo2.object.grid.CircularMapping(elements=gdict['horizontal']['pin_layer'], dtype=object)
+                xcolor = laygo2.object.grid.CircularMapping(elements=gdict['vertical']['xcolor'], dtype=object)
+                ycolor = laygo2.object.grid.CircularMapping(elements=gdict['horizontal']['ycolor'], dtype=object)
+                primary_grid = gdict['primary_grid']
+                # Create the via map defined by the yaml file.
+                vmap_original = gdict['via']['map']  # viamap defined in the yaml file.
+                vmap_mapped = list()  # map template objects to the via map.
+                for vmap_org_row in vmap_original:
+                    vmap_mapped_row = []
+                    for vmap_org_elem in vmap_org_row:
+                        vmap_mapped_row.append(templates[vmap_org_elem])
+                    vmap_mapped.append(vmap_mapped_row)
+                viamap = laygo2.object.grid.CircularMappingArray(elements=vmap_mapped, dtype=object)
+                g = laygo2.object.grid.RoutingGrid(name=gn, vgrid=gv, hgrid=gh,
+                                                   vwidth=vwidth, hwidth=hwidth,
+                                                   vextension=vextension, hextension=hextension,
+                                                   vlayer=vlayer, hlayer=hlayer,
+                                                   pin_vlayer=pin_vlayer, pin_hlayer=pin_hlayer,
+                                                   viamap=viamap, primary_grid=primary_grid,
+                                                   xcolor=xcolor, ycolor=ycolor,
+                                                   vextension0=vextension0, hextension0=hextension0)
+                glib.append(g)
+
+        # Update grid based on input parameters.
+        if params is not None:
+            glib = self.update(glib, params=params)
+
+        # Bind to self.tech_grid
+        self.tech_grid = glib
+        return glib
+
+    def update(self, grid_lib, params):
+        return grid_lib  # do nothing for base class
+
```

### Comparing `laygo2-0.5.6/laygo2/object/database.py` & `laygo2-0.5.7/laygo2/object/database.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,1932 +1,1932 @@
-#!/usr/bin/python
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-"""
-**laygo2.object.database** module consists of the classes implementing a hierarchical structure database that manages design and library.
-"""
-
-__author__ = "Jaeduk Han"
-__maintainer__ = "Jaeduk Han"
-__status__ = "Prototype"
-
-import laygo2.object
-import numpy as np
-
-from laygo2.object.physical import PhysicalObject
-from laygo2.object.grid import Grid
-from laygo2.object.template import Template
-
-from laygo2._typing import T
-from typing import overload, Generic, Dict, Type, Union
-
-class BaseDatabase(Generic[T]):
-    """
-    A base class that implements basic functions for 
-    various database objects, such as libraries and designs.
-
-    Notes
-    -----
-    **(Korean)** BaseDatabase는 데이터베이스 객체들의 기본 기능을 구현하는 클래스.
-    """
-
-    name = None
-    """str: Name of BaseDatabase object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> base = laygo2.object.database.BaseDatabase(name="mycell") 
-    >>> base.name 
-    "mycell"
-
-    Notes
-    -----
-    **(Korean)** BaseDatabase 이름.
-    """
-
-    params = None
-    """dict or None: BaseDatabase object's parameter dictionary.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> base = laygo2.object.database.BaseDatabase(name="mycell",
-                   params={'ivdd': 0.001}) 
-    >>> base.params 
-    {'ivdd': 0.001}
-
-    Notes
-    -----
-    **(Korean)** BaseDatabase의 속성.
-    """
-
-    elements: Dict[str, Type[Union[PhysicalObject, T]]] = None
-    """dict: Element object dictionary.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.database import BaseDatabase
-    >>> from laygo2.object.physical import Rect, Pin, Instance, Text
-    >>> # Create a design.
-    >>> dsn = BaseDatabase(name="mycell")
-    >>> # Create layout objects.
-    >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
-    >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
-    >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
-    >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
-    >>> # Add layout objects to the design.
-    >>> dsn.append(r0)
-    >>> dsn.append(p0)
-    >>> dsn.append(i0)
-    >>> dsn.append(t0)
-    >>> # 
-    >>> # Display elements of the design.
-    >>> print(dsn.elements) 
-    {'NoName_0': <laygo2.object.physical.Rect object at 0x0000024C6C230F40>, 
-    'P': <laygo2.object.physical.Pin object at 0x0000024C6C2EFF40>, 
-    'I0': <laygo2.object.physical.Instance object at 0x0000024C6C2EFDC0>, 
-    'NoName_1': <laygo2.object.physical.Text object at 0x0000024C6C2EF8B0>}
-
-    Notes
-    -----
-    **(Korean)** BaseDatabase 객체의 구성 요소를 담고 있는 Dictionary.
-    """
-
-    noname_index = 0
-    """
-    int: Unique identifier index for unnamed objects.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.database import BaseDatabase
-    >>> from laygo2.object.physical import Rect, Pin, Instance, Text
-    >>> # Create a design
-    >>> dsn = BaseDatabase(name="mycell")
-    >>> # Create layout objects
-    >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
-    >>> dsn.append(r0)
-    >>> print(base.noname_index) 
-    0 
-    >>> r1 = Rect(xy=[[100, 100], [200, 200]], layer=["M1", "drawing"])
-    >>> dsn.append(r1)
-    >>> print(base.noname_index) 
-    1
-
-    Notes
-    -----
-    **(Korean)** BaseDatabase의 소속 객체들 중 이름이 정해지지 않은 객체의 
-    이름을 정할 때 부여되는 고유 번호.
-    """
-
-    # @property
-    def keys(self):
-        """Keys of elements.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> from laygo2.object.database import BaseDatabase
-        >>> from laygo2.object.physical import Rect, Pin, Instance, Text
-        >>> # Create a design
-        >>> dsn = BaseDatabase(name="mycell")
-        >>> # Create layout objects
-        >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
-        >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
-        >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
-        >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
-        >>> dsn.append(r0)
-        >>> dsn.append(p0)
-        >>> dsn.append(i0)
-        >>> dsn.append(t0)
-        >>> print(dsn.keys())
-        dict_keys(['NoName_0', 'P', 'I0', 'NoName_1'])
-
-        Notes
-        -----
-        **(Korean)** BaseDatabase 객체의 구성 요소를 담고 있는 Dictionary.
-        """
-        return self.elements.keys()
-
-    def items(self):
-        """
-        Key-object pairs of elements.
-
-        Parameters
-        ----------
-        None
-
-        Returns
-        -------
-        dict_items
-
-        Example
-        -------
-        >>> import laygo2
-        >>> from laygo2.object.database import BaseDatabase
-        >>> from laygo2.object.physical import Rect, Pin, Instance, Text
-        >>> # Create a design
-        >>> dsn = BaseDatabase(name="mycell")
-        >>> # Create layout objects
-        >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
-        >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
-        >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
-        >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
-        >>> dsn.append(r0)
-        >>> dsn.append(p0)
-        >>> dsn.append(i0)
-        >>> dsn.append(t0)
-        >>> print(dsn.items())
-        dict_items([('NoName_0', <laygo2.object.physical.Rect object at 0x0000024C6C230F40>),
-                    ('P', <laygo2.object.physical.Pin object at 0x0000024C6C2EFF40>),
-                    ('I0', <laygo2.object.physical.Instance object at 0x0000024C6C2EFDC0>),
-                    ('NoName_1', <laygo2.object.physical.Text object at 0x0000024C6C2EF8B0>)])
-
-        Notes
-        -----
-        **(Korean)** elements의 key/object 짝 출력.
-        """
-        return self.elements.items()
-
-    @overload
-    def __getitem__(self: "BaseDatabase[T]", pos) -> Type[T]: ...
-    @overload
-    def __getitem__(self: "BaseDatabase[None]", pos) -> Type[PhysicalObject]: ...
-
-    def __getitem__(self, pos):
-        """
-        Return the object corresponding to pos.
-
-        Parameters
-        ----------
-        pos : str
-            Name of object.
-
-        Returns
-        -------
-        laygo2.object.physical : corresponding object.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> from laygo2.object.database import BaseDatabase
-        >>> from laygo2.object.physical import Rect, Pin, Instance, Text
-        >>> # Create a design
-        >>> dsn = BaseDatabase(name="mycell")
-        >>> # Create layout objects
-        >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
-        >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
-        >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
-        >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
-        >>> dsn.append(r0)
-        >>> dsn.append(p0)
-        >>> dsn.append(i0)
-        >>> dsn.append(t0)
-        >>> print(dsn["I0"])
-        <laygo2.object.physical.Instance object at 0x0000024C6C2EFDC0>
-        name: I0,
-        class: Instance,
-        xy: [0, 0],
-        params: None,
-        size: [0, 0]
-        shape: None
-        pitch: [0, 0]
-        transform: R0
-        pins: {}
-
-        Notes
-        -----
-        **(Korean)** key에 해당하는 object 반환.
-        """
-        return self.elements[pos]
-
-    def __setitem__(self, key, item):
-        """
-        Add key/object pair.
-
-        Parameters
-        ----------
-        key : str
-            Object key (name).
-
-        Example
-        -------
-        >>> import laygo2
-        >>> from laygo2.object.database import BaseDatabase
-        >>> from laygo2.object.physical import Rect, Pin, Instance, Text
-        >>> # Create a design
-        >>> dsn = BaseDatabase(name="mycell")
-        >>> # Create layout objects
-        >>> r1 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
-        >>> dsn.append(r1)
-        >>> r2 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
-        >>> dsn["R2"] = r2
-        >>> print(dsn["R2"])
-        <laygo2.object.physical.Rect object at 0x0000024C6C107C40>
-        name: R2,
-        class: Rect,
-        xy: [[0, 0], [100, 100]],
-        params: None, , layer: ['M1', 'drawing'], netname: None
-
-        Notes
-        -----
-        **(Korean)** 요소 추가 함수.
-        """
-        item.name = key
-        self.append(item)
-
-    def append(self, item):
-        """Add physical object to BaseDatabase without taking any further actions.
-
-        Parameters
-        ----------
-        item : laygo2.object.physical.PhysicalObject
-            Physical object to be added.
-
-        Returns
-        -------
-        list :
-            List of item name and item ([item.name, item]).
-
-        Example
-        -------
-        >>> import laygo2
-        >>> from laygo2.object.database import BaseDatabase
-        >>> from laygo2.object.physical import Rect, Pin, Instance, Text
-        >>> # Create a design
-        >>> dsn = Design(name="mycell", libname="genlib")
-        >>> # Create layout objects
-        >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
-        >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
-        >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
-        >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
-        >>> dsn.append(r0)
-        >>> dsn.append(p0)
-        >>> dsn.append(i0)
-        >>> dsn.append(t0)
-        >>> print(dsn)
-        <laygo2.object.database.BaseDatabase object at 0x0000024C6C2EF010>
-            name: mycell, params: None
-            elements: {
-                'NoName_0': <laygo2.object.physical.Rect object at 0x0000024C6C230F40>,
-                'P': <laygo2.object.physical.Pin object at 0x0000024C6C2EFF40>,
-                'I0': <laygo2.object.physical.Instance object at 0x0000024C6C2EFDC0>,
-                'NoName_1': <laygo2.object.physical.Text object at 0x0000024C6C2EF8B0>}
-
-        See Also
-        --------
-            laygo2.object.database.Library.append
-            laygo2.object.database.Design.append
-        """
-        if isinstance(item, list) or isinstance(item, np.ndarray):
-            item_name_list = []
-            item_list = []
-            for i in item:
-                _item_name, _item = self.append(i)
-                item_name_list.append(_item_name)
-                item_list.append(_item)
-            return item_name_list, item_list
-            # return [i[0] for i in item_list], [i[1] for i in item_list]
-        else:
-            item_name = item.name
-            if item_name is None:  # NoName object. Put a name on it.
-                while "NoName_" + str(self.noname_index) in self.elements.keys():
-                    self.noname_index += 1
-                item_name = "NoName_" + str(self.noname_index)
-                self.noname_index += 1
-            errstr = item_name + " cannot be added to " + self.name + ", as a child object with the same name exists."
-            if item_name in self.elements.keys():
-                raise KeyError(errstr)
-            else:
-                if item_name in self.elements.keys():
-                    raise KeyError(errstr)
-                else:
-                    self.elements[item_name] = item
-            return item_name, item
-
-    def __iter__(self):
-        """Element-mapped direct iterator function.
-        
-        Example
-        -------
-        >>> import laygo2
-        >>> from laygo2.object.database import BaseDatabase
-        >>> from laygo2.object.physical import Rect, Pin, Instance, Text
-        >>> # Create a design
-        >>> dsn = BaseDatabase(name="mycell")
-        >>> # Create layout objects
-        >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
-        >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
-        >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
-        >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
-        >>> dsn.append(r0)
-        >>> dsn.append(p0)
-        >>> dsn.append(i0)
-        >>> for o in dsn.items():
-        >>>     print(o)
-        ('NoName_0', <laygo2.object.physical.Rect object at 0x0000024C6C230F40>)
-        ('P', <laygo2.object.physical.Pin object at 0x0000024C6C2EFF40>)
-        ('I0', <laygo2.object.physical.Instance object at 0x0000024C6C2EFDC0>)
-        ('NoName_1', <laygo2.object.physical.Text object at 0x0000024C6C2EF8B0>)
-
-        Notes
-        -----
-        **(Korean)** BaseDatabase의 Iterable 함수.
-        """
-        return self.elements.__iter__()
-
-    def __str__(self):
-        return self.summarize()
-
-    def summarize(self):
-        """Get object information summary."""
-        return (
-            self.__repr__() + " " + "name: " + self.name + ", " + "params: " + str(self.params) + " \n"
-            "    elements: " + str(self.elements) + ""
-        )
-
-    def __init__(self, name, params=None, elements=None):
-        """
-        BaseDatabase class constructor function.
-
-        Parameters
-        ----------
-        name : str
-            BaseDatabase object name.
-        params : dict, optional
-            parameters of BaseDatabase.
-        elements : dict, optional
-            dictionary having the elements of BaseDatabase.
-
-        Returns
-        -------
-        laygo2.object.BaseDatabase
-
-        Example
-        -------
-        >>> import laygo2
-        >>> base = laygo2.object.database.BaseDatabase(name='mycell')
-        >>> print(base)
-        <laygo2.object.database.BaseDatabase object>
-        name: mycell, params: None elements: {}>
-
-        Notes
-        -----
-        **(Korean)** BaseDatabase 클래스 생성자 함수.
-
-        파라미터
-            - name(str): BaseDatabase 객체의 이름
-            - params(dict): BaseDatabase의 parameters [optional]
-            - elements(dict): BaseDatabase의 elements를 갖고 있는 dict [optional]
-        반환값
-            - laygo2.object.BaseDatabase
-        """
-        self.name = name
-        self.params = params
-
-        self.elements = dict()
-        if elements is not None:
-            for e in elements:
-                self.elements[e] = elements[e]
-
-
-class LibraryWrapper(BaseDatabase[T]):
-    def get_libname(self):
-        """getter function of libname property."""
-        return self.name
-
-    def set_libname(self, val):
-        """setter function of libname property."""
-        self.name = val
-
-    libname = property(get_libname, set_libname)
-    """str: The name of library.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> lib = laygo2.object.database.Library(name='mylib') 
-    >>> print(lib.name) 
-    "mylib"
-
-    Notes
-    -----
-    **(Korean)** Library 객체의 이름.
-    """
-
-    def append(self, item: T):
-        """Add physical object to Library without taking any further actions.
-        """
-        if isinstance(item, list) or isinstance(item, np.ndarray):
-            item_name_list = []
-            item_list = []
-            for i in item:
-                _item_name, _item = self.append(i)
-                item_name_list.append(_item_name)
-                item_list.append(_item)
-            return item_name_list, item_list
-        else:
-            item_name, item = BaseDatabase.append(self, item)
-            item.libname = self.name  # update library name
-            return item_name, item
-
-    def __init__(self, name, params=None, elements=None):
-        """Constructor function of Library class.
-
-        Parameters
-        ----------
-        name : str
-            Library object name.
-        params : dict, optional
-            Library parameters.
-        elements : dict, optional
-            Dictionary having the elements of Library.
-
-        Returns
-        -------
-        laygo2.object.Library
-
-        Example
-        -------
-        >>> import laygo2
-        >>> lib = laygo2.object.database.Library(name='mylib')
-        >>> print(lib)
-        <laygo2.object.database.Library > name: mylib, params: None elements: {} >
-
-        Notes
-        -----
-        **(Korean)** Library 클래스의 생성자 함수.
-        파라미터
-            - name(str): Library 객체의 이름
-            - params(dict): Library의 parameters [optional]
-            - elements(dict): Library의 elements를 갖고 있는 dict [optional]
-        반환값
-            - laygo2.object.Library
-        """
-        BaseDatabase.__init__(self, name=name, params=params, elements=elements)
-
-    def summarize(self):
-        """Get object information summary."""
-        return BaseDatabase.summarize(self)
-
-class Library(LibraryWrapper["Design"]):
-    """
-    Class for library management function implementation.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> lib = laygo2.object.database.Library(name="mylib")
-    >>> dsn0 = laygo2.object.database.Design(name="mycell0")
-    >>> dsn1 = laygo2.object.database.Design(name="mycell1")
-    >>> lib.append(dsn0)
-    >>> lib.append(dsn1)
-    >>> print(lib)
-    <laygo2.object.database.Library object at 0x0000025F2D25B8B0>
-    name: mylib, params: None
-    elements: {
-        'mycell0': <laygo2.object.database.Design object at 0x0000025F2D25B010>,
-        'mycell1': <laygo2.object.database.Design object at 0x0000025F2D25BF70>}
-
-    See Also
-    --------
-    laygo2.object.databse.Design: Check for more comprehensive Example.
-
-    Notes
-    -----
-    **(Korean)** Library 클래스는 라이브러리 관리 기능을 구현한다.
-
-    """
-
-    pass
-
-class TemplateLibrary(LibraryWrapper[Template]):
-    """Class implementing template libraries with templates as child objects."""
-
-    # TODO: implement this.
-    pass
-
-
-class GridLibrary(LibraryWrapper[Grid]):
-    """Class implementing grid libraries with grids as child objects."""
-
-    # TODO: implement this.
-    pass
-
-
-class Design(BaseDatabase):
-    """
-    Class for design management function implementation.
-
-    Example
-    -------
-    A physical (non-abstract) grid example:
-
-    >>> import laygo2
-    >>> from laygo2.object.database import Design
-    >>> from laygo2.object.physical import Rect, Pin, Instance, Text
-    >>> # Create a design.
-    >>> dsn = Design(name="mycell", libname="genlib")
-    >>> # Create layout objects.
-    >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
-    >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
-    >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
-    >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
-    >>> # Add the layout objects to the design object.
-    >>> dsn.append(r0)
-    >>> dsn.append(p0)
-    >>> dsn.append(i0)
-    >>> dsn.append(t0)
-    >>> print(dsn)
-    <laygo2.object.database.Design object at 0x0000024C6C2EF010>
-        name: mycell, params: None
-        elements: {
-            'NoName_0': <laygo2.object.physical.Rect object at 0x0000024C6C230F40>,
-            'P': <laygo2.object.physical.Pin object at 0x0000024C6C2EFF40>,
-            'I0': <laygo2.object.physical.Instance object at 0x0000024C6C2EFDC0>,
-            'NoName_1': <laygo2.object.physical.Text object at 0x0000024C6C2EF8B0>}
-        libname:genlib
-        rects:{
-            'NoName_0': <laygo2.object.physical.Rect object at 0x0000024C6C230F40>}
-        paths:{}
-        pins:{
-            'P': <laygo2.object.physical.Pin object at 0x0000024C6C2EFF40>}
-        texts:{
-            'NoName_1': <laygo2.object.physical.Text object at 0x0000024C6C2EF8B0>}
-        instances:{
-            'I0': <laygo2.object.physical.Instance object at 0x0000024C6C2EFDC0>}
-        virtual instances:{}
-    >>> #
-    >>> # Export to a NativeInstanceTemplate for reuse in higher levels.
-    >>> nt0 = dsn.export_to_template()
-    >>> nt0.dsn.export_to_template()
-    >>> print(nt0)
-        <laygo2.object.template.NativeInstanceTemplate object at 0x000001CB5A9CE380>
-        name: mycell,
-        class: NativeInstanceTemplate,
-         bbox: [[0, 0], [0, 0]],
-         pins: {'P': <laygo2.object.physical.Pin object at 0x000001CB5A9CFF40>},
-    >>> #
-    >>> # Export to a skill script.
-    >>> lib = laygo2.object.database.Library(name="mylib")
-    >>> lib.append(dsn)
-    >>> scr = laygo2.interface.skill.export(lib, filename="myscript.il")
-    >>> print(scr)
-    ; (definitions of laygo2 skill functions)
-    ; exporting mylib__mycell
-    cv = _laygo2_open_layout("mylib" "mycell" "layout")
-    _laygo2_generate_rect(cv, list( "M1" "drawing" ), list( list( 0.0000  0.0000  ) list( 0.1000  0.1000  ) ), "None")
-    _laygo2_generate_pin(cv, "P", list( "M1" "pin" ), list( list( 0.0000  0.0000  ) list( 0.0500  0.0500  ) ) )
-    _laygo2_generate_instance(cv, "I0", "tlib", "t0", "layout", list( 0.0000  0.0000  ), "R0", 1, 1, 0, 0, nil, nil)
-    _laygo2_save_and_close_layout(cv)
-
-    An abstract grid example:
-
-    >>> import laygo2
-    >>> from laygo2.object.grid import CircularMapping as CM
-    >>> from laygo2.object.grid import CircularMappingArray as CMA
-    >>> from laygo2.object.grid import OneDimGrid, PlacementGrid, RoutingGrid
-    >>> from laygo2.object.template import NativeInstanceTemplate
-    >>> from laygo2.object.database import Design
-    >>> from laygo2.object.physical import Instance
-    >>> # Placement grid construction (not needed if laygo2_tech is set up).
-    >>> gx  = OneDimGrid(name="gx", scope=[0, 20], elements=[0])
-    >>> gy  = OneDimGrid(name="gy", scope=[0, 100], elements=[0])
-    >>> gp  = PlacementGrid(name="test", vgrid=gx, hgrid=gy)
-    >>> # Routing grid construction (not needed if laygo2_tech is set up).
-    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
-    >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
-    >>> wv = CM([10])           # vertical (xgrid) width
-    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
-    >>> ev = CM([10])           # vertical (xgrid) extension
-    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
-    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
-    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
-    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
-    >>> lh = CM([['M2', 'drawing']]*3, dtype=object)
-    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
-    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
-    >>> xcolor = CM([None], dtype=object)  # not multipatterned
-    >>> ycolor = CM([None]*3, dtype=object)
-    >>> primary_grid = 'horizontal'
-    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via
-    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
-    >>> gr = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
-                                            vwidth=wv, hwidth=wh,
-                                            vextension=ev, hextension=eh,
-                                            vlayer=lv, hlayer=lh,
-                                            pin_vlayer=plv, pin_hlayer=plh,
-                                            viamap=viamap, primary_grid=primary_grid,
-                                            xcolor=xcolor, ycolor=ycolor,
-                                            vextension0=e0v, hextension0=e0h)
-    >>> # Create a design
-    >>> dsn = Design(name="mycell", libname="genlib")
-    >>> # Create an instance
-    >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
-    >>> print(inst0.xy)
-    [100, 100]
-    >>> # Place the instance
-    >>> dsn.place(inst=i0, grid=gp, mn=[10,10])
-    >>> # Routing on grid
-    >>> mn_list = [[0, -2], [0, 1], [2, 1], [5,1] ]
-    >>> route = dsn.route(grid=gr, mn=mn_list,
-                          via_tag=[True, None, True, True])
-    >>> #
-    >>> # Display generated design.
-    >>> print(dsn)
-    <laygo2.object.database.Design object at 0x000001C71AE3A110>
-        ...
-    >>> #
-    >>> # Export to a NativeInstanceTemplate for reuse in higher levels.
-    >>> nt0 = dsn.export_to_template()
-    >>> nt0.dsn.export_to_template()
-    >>> print(nt0)
-        ...
-    >>> #
-    >>> # Export to a skill script.
-    >>> lib = laygo2.object.database.Library(name="mylib")
-    >>> lib.append(dsn)
-    >>> scr = laygo2.interface.skill.export(lib, filename="myscript.il")
-    >>> print(scr)
-        ...
-
-    An abstract template/grid example with technology setup (laygo2_tech):
-
-    >>> import laygo2
-    >>> import laygo2.interface
-    >>> import laygo2_tech_quick_start as tech  # target tech's laygo2_tech
-    >>> from laygo2.object.database import Design
-    >>> templates = tech.load_templates()
-    >>> mytemplate = templates['nmos']
-    >>> grids = tech.load_grids(templates=templates)
-    >>> gp = grids['placement_basic']
-    >>> gr = grids['routing_23_cmos']
-    >>> # Create a design
-    >>> dsn = Design(name="mycell", libname="genlib")
-    >>> # Create an instance
-    >>> i0 = tnmos.generate(name='MN0', params={'nf': 4})
-    >>> # Place the instance
-    >>> dsn.place(inst=i0, grid=gp, mn=[10,10])
-    >>> # Routing on grid
-    >>> mn_list = [[0, -2], [0, 1], [2, 1], [5,1] ]
-    >>> route = dsn.route(grid=gr, mn=mn_list,
-                          via_tag=[True, None, True, True])
-    >>> #
-    >>> # Display generated design.
-    >>> print(dsn)
-    <laygo2.object.database.Design object at 0x000001C71AE3A110>
-        ...
-    >>> #
-    >>> # Export to a NativeInstanceTemplate for reuse in higher levels.
-    >>> nt0 = dsn.export_to_template()
-    >>> nt0.dsn.export_to_template()
-    >>> print(nt0)
-        ...
-    >>> #
-    >>> # Export to a skill script.
-    >>> lib = laygo2.object.database.Library(name="mylib")
-    >>> lib.append(dsn)
-    >>> scr = laygo2.interface.skill.export(lib, filename="myscript.il")
-    >>> print(scr)
-        ...
-
-
-    Notes
-    -----
-    **(Korean)**
-    Design 클래스는 디자인 관리 기능을 구현한다.
-    """
-
-    @property
-    def bbox(self):
-        """Get design bounding box by taking union of instances' bounding boxes."""
-        libname = self.libname
-        cellname = self.cellname
-        # Compute boundaries
-        xy = [None, None]
-        for n, i in self.instances.items():
-            if xy[0] is None:
-                xy[0] = i.bbox[0]  # bl
-                xy[1] = i.bbox[1]  # tr
-            else:
-                #xy = np.minimum(xy, i.bbox)
-                xy[0][0] = min(xy[0][0], i.bbox[0, 0])
-                xy[0][1] = min(xy[0][1], i.bbox[0, 1])
-                xy[1][0] = max(xy[1][0], i.bbox[1, 0])
-                xy[1][1] = max(xy[1][1], i.bbox[1, 1])
-        for n, i in self.virtual_instances.items():
-            if xy[0] is None:
-                xy[0] = i.bbox[0]
-                xy[1] = i.bbox[1]
-            else:
-                #y = np.minimum(xy, i.bbox)
-                xy[0][0] = min(xy[0][0], i.bbox[0, 0])
-                xy[0][1] = min(xy[0][1], i.bbox[0, 1])
-                xy[1][0] = max(xy[1][0], i.bbox[1, 0])
-                xy[1][1] = max(xy[1][1], i.bbox[1, 1])
-        xy = np.array(xy)
-        return xy
-
-    def get_libname(self):
-        return self._libname
-
-    def set_libname(self, val):
-        self._libname = val
-
-    libname = property(get_libname, set_libname)
-    """str: Design object's library name.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> dsn = laygo2.object.database.Design(name="dsn", libname="testlib") 
-    >>> print(dsn.libname) 
-    “testlib”
-
-    Notes
-    -----
-    **(Korean)** Design 객체의 라이브러리 이름.
-    """
-
-    def get_cellname(self):
-        return self.name
-
-    def set_cellname(self, val):
-        self.name = val
-
-    cellname = property(get_cellname, set_cellname)
-    """str: Design object's cell name.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> dsn = laygo2.object.database.Design(name="dsn", libname="testlib") 
-    >>> print(dsn.cellname) 
-    “dsn”
-
-    Notes
-    -----
-    **(Korean)** Design 객체의 셀 이름.
-    """
-
-    rects = None
-    """dict: Dictionary containing Rectangle object affiliated with the 
-    Design object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.database import Design
-    >>> from laygo2.object.physical import Rect, Pin, Instance, Text
-    >>> dsn = Design(name="dsn", libname="testlib") 
-    >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
-    >>> dsn.append(r0) 
-    >>> print(dsn.rects) 
-    {'R0': <laygo2.object.physical.Rect object>}
-
-    Notes
-    -----
-    **(Korean)** Design 객체에 소속된 Rect 객체들을 갖고 있는 dictionary.
-    """
-
-    def get_r(self):
-        return self.rects
-
-    def set_r(self, val):
-        self.rects = val
-
-    r = property(get_r, set_r)
-    """str: Alias of rects."""
-
-    paths = None
-
-    pins = None
-    """dict: Dictionary having the collection of Pin objects affiliated 
-    with the Design object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.database import Design
-    >>> from laygo2.object.physical import Rect, Pin, Instance, Text
-    >>> dsn = Design(name="dsn", libname="testlib") 
-    >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
-    >>> dsn.append(p0) 
-    >>> print(dsn.pins) 
-    {'NoName_0': <laygo2.object.physical.Pin object>}
-    
-    Notes
-    -----
-    **(Korean)** Design 객체에 소속된 Pin 객체들을 갖고 있는 dictionary.
-    """
-    
-    def get_p(self):
-        return self.pins
-
-    def set_p(self, val):
-        self.pins = val
-
-    p = property(get_p, set_p)
-    """str: Alias of pins."""
-    
-    texts = None
-    """dict: Dictionary containing Text objects affiliated with Design object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.database import Design
-    >>> from laygo2.object.physical import Rect, Pin, Instance, Text
-    >>> dsn = Design(name="dsn", libname="testlib") 
-    >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
-    >>> dsn.append(t0) 
-    >>> print(dsn.texts) 
-    {'NoName_1': <laygo2.object.physical.Text object>}
-    
-    Notes
-    -----
-    **(Korean)** Design 객체에 소속된 Text 객체들을 갖고 있는 dictionary.
-    """
-
-    instances = None
-    """dict: Dictionary containing Instance objects affiliated with Design object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.database import Design
-    >>> from laygo2.object.physical import Rect, Pin, Instance, Text
-    >>> dsn = Design(name="dsn", libname="testlib") 
-    >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
-    >>> dsn.append(i0) 
-    >>> print(dsn.instances) 
-    {'I0': <laygo2.object.physical.Instance object>}
-    
-    Notes
-    -----
-    **(Korean)** Design 객체에 소속된 Instance 객체들을 갖고 있는 dictionary.
-    """
-
-    def get_i(self):
-        return self.instances
-
-    def set_i(self, val):
-        self.instances = val
-
-    i = property(get_i, set_i)
-    """str: Alias of instances."""
-    
-    virtual_instances = None
-    """dict: Dictionary containing VirtualInstance objects affiliated with 
-    Design object.
-
-    See Also
-    --------
-    instances
-
-    Notes
-    -----
-    **(Korean)** Design 객체에 소속된 VirtualInstance 객체들을 갖고 있는 dictionary.
-    """
-
-    def get_vi(self):
-        return self.virtual_instances
-
-    def set_vi(self, val):
-        self.virtual_instances = val
-
-    vi = property(get_vi, set_vi)
-    """str: Alias of virtual_instances."""
-
-    def __iter__(self):
-        """Element-mapped direct iterator function.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> from laygo2.object.database import Design
-        >>> from laygo2.object.physical import Rect, Pin, Instance, Text
-        >>> # Create a design
-        >>> dsn = Design(name="mycell", libname="genlib")
-        >>> # Create layout objects
-        >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
-        >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
-        >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
-        >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
-        >>> dsn.append(r0)
-        >>> dsn.append(p0)
-        >>> dsn.append(i0)
-        >>> for o in dsn.items():
-        >>>     print(o)
-        ('NoName_0', <laygo2.object.physical.Rect object at 0x0000024C6C230F40>)
-        ('P', <laygo2.object.physical.Pin object at 0x0000024C6C2EFF40>)
-        ('I0', <laygo2.object.physical.Instance object at 0x0000024C6C2EFDC0>)
-        ('NoName_1', <laygo2.object.physical.Text object at 0x0000024C6C2EF8B0>)
-        """
-        return self.elements.__iter__()
-
-    def __init__(self, name, params=None, elements=None, libname=None):
-        """
-        Design class constructor function.
-
-        Parameters
-        ----------
-        name : str
-            Design object name.
-        params : dict, optional
-            Design object parameters.
-        elements : dict, optional
-            Design object elements.
-
-        Returns
-        -------
-        laygo2.object.BaseDatabase
-
-        Example
-        -------
-        >>> import laygo2
-        >>> dsn = laygo2.object.database.Design(name='dsn', libname="testlib")
-        >>> print(dsn)
-        <laygo2.object.database.Design object>  name: dsn, params: None
-            elements: {}
-            libname:testlib
-            rects:{}
-            paths:{}
-            pins:{}
-            texts:{}
-            instances:{}
-            virtual instances:{}
-
-        Notes
-        -----
-        **(Korean)** Design 클래스의 생성자 함수.
-
-        파라미터
-            - name(str): Design 객체의 이름
-            - params(dict): Design 객체의 parameters [optional]
-            - elements(dict): Design 객체의 elements [optional]
-        반환값
-            - laygo2.object.BaseDatabase
-        """
-        self.libname = libname
-        self.rects = dict()
-        self.paths = dict()
-        self.pins = dict()
-        self.texts = dict()
-        self.instances = dict()
-        self.virtual_instances = dict()
-        BaseDatabase.__init__(self, name=name, params=params, elements=elements)
-
-    def append(self, item):
-        """Add physical object to Design without taking any further actions.
-
-        Parameters
-        ----------
-        item : laygo2.object.physical.PhysicalObject
-            The physical object to be added.
-
-        Returns
-        -------
-        list :
-            A list containing the name of item and the item itself ([item.name, item]).
-
-        Example
-        -------
-        >>> import laygo2
-        >>> from laygo2.object.database import Design
-        >>> from laygo2.object.physical import Rect, Pin, Instance, Text
-        >>> # Create a design
-        >>> dsn = Design(name="mycell", libname="genlib")
-        >>> # Create layout objects
-        >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
-        >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
-        >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
-        >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
-        >>> dsn.append(r0)
-        >>> dsn.append(p0)
-        >>> dsn.append(i0)
-        >>> dsn.append(t0)
-        >>> print(dsn)
-        <laygo2.object.database.Design object at 0x0000024C6C2EF010>
-            name: mycell, params: None
-            elements: {
-                'NoName_0': <laygo2.object.physical.Rect object at 0x0000024C6C230F40>,
-                'P': <laygo2.object.physical.Pin object at 0x0000024C6C2EFF40>,
-                'I0': <laygo2.object.physical.Instance object at 0x0000024C6C2EFDC0>,
-                'NoName_1': <laygo2.object.physical.Text object at 0x0000024C6C2EF8B0>}
-            libname:genlib
-            rects:{
-                'NoName_0': <laygo2.object.physical.Rect object at 0x0000024C6C230F40>}
-            paths:{}
-            pins:{
-                'P': <laygo2.object.physical.Pin object at 0x0000024C6C2EFF40>}
-            texts:{
-                'NoName_1': <laygo2.object.physical.Text object at 0x0000024C6C2EF8B0>}
-            instances:{
-                'I0': <laygo2.object.physical.Instance object at 0x0000024C6C2EFDC0>}
-            virtual instances:{}
-
-        See Also
-        --------
-            laygo2.object.database.Design.place : Place a (virtual) instance
-            on a grid and append to the design.
-            laygo2.object.database.Design.route : Route on a grid and append
-            to the design.
-            laygo2.object.database.Design.route_via_track : Route on a track
-            on a grid and append.
-            laygo2.object.database.Design.pin : Place a pin on a grid and
-            append to the design.
-        """
-        if isinstance(item, list) or isinstance(item, np.ndarray):
-            return [self.append(i) for i in item]
-        else:
-            if item is None:
-                return None, None  # don't do anything
-            item_name, _item = BaseDatabase.append(self, item)
-            if item.__class__ == laygo2.object.Rect:
-                self.rects[item_name] = item
-            elif item.__class__ == laygo2.object.Path:
-                self.paths[item_name] = item
-            elif item.__class__ == laygo2.object.Pin:
-                self.pins[item_name] = item
-            elif item.__class__ == laygo2.object.Text:
-                self.texts[item_name] = item
-            elif item.__class__ == laygo2.object.Instance:
-                self.instances[item_name] = item
-            elif item.__class__ == laygo2.object.VirtualInstance:
-                self.virtual_instances[item_name] = item
-            return item_name, item
-
-    def summarize(self):
-        """Get object information summary."""
-        return (
-            BaseDatabase.summarize(self)
-            + " \n"
-            + "    libname:"
-            + str(self.libname)
-            + " \n"
-            + "    rects:"
-            + str(self.rects)
-            + " \n"
-            + "    paths:"
-            + str(self.paths)
-            + " \n"
-            + "    pins:"
-            + str(self.pins)
-            + " \n"
-            + "    texts:"
-            + str(self.texts)
-            + " \n"
-            + "    instances:"
-            + str(self.instances)
-            + "\n"
-            + "    virtual instances:"
-            + str(self.virtual_instances)
-            + ""
-        )
-
-    # Object creation and manipulation functions.
-    def place(self, inst, grid, mn=[0, 0], anchor_xy=None):
-        """
-        Place instance at abstract coordinate mn on abstract grid.
-
-        Parameters
-        ----------
-        inst : laygo2.object.physical.Instance or laygo2.object.physical.VirtualInstance or list
-            Instance(s) to be placed (when list, placed in order).
-        grid : laygo2.object.grid.PlacementGrid
-            Placement grid for instance placement.
-        mn : numpy.ndarray or list
-            Abstract coordinate value [m, n] for instance placement.
-        anchor_xy : list
-            A list that contains two overlap coordinates for placement 
-            (1st for absolute physical grid, 2nd for relative instance position).
-
-        Returns
-        -------
-        laygo2.object.physical.Instance or laygo2.object.physical.VirtualInstance or list(laygo2.object.physical.Instance):
-            Placed instance(s) (list if multiple).
-
-        Example
-        -------
-        >>> import laygo2
-        >>> from laygo2.object.grid import OneDimGrid, PlacementGrid
-        >>> from laygo2.object.database import Design
-        >>> from laygo2.object.physical import Instance
-        >>> # Create a grid (not needed if laygo2_tech is set up).
-        >>> gx  = OneDimGrid(name="gx", scope=[0, 20], elements=[0])
-        >>> gy  = OneDimGrid(name="gy", scope=[0, 100], elements=[0])
-        >>> g   = PlacementGrid(name="test", vgrid=gx, hgrid=gy)
-        >>> # Create a design
-        >>> dsn = Design(name="mycell", libname="genlib")
-        >>> # Create an instance
-        >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
-        >>> print(inst0.xy)
-        [100, 100]
-        >>> ######################
-        >>> # Place the instance #
-        >>> ######################
-        >>> dsn.place(inst=i0, grid=g, mn=[10,10])
-        >>> # Print parameters of the placed instance.
-        >>> print(i0.xy)
-        [200, 1000]
-        >>> print(dsn)
-        <laygo2.object.database.Design object at 0x000002803D4C0F40>
-            name: mycell
-            params: None
-            elements:
-                {'I0': <laygo2.object.physical.Instance object at
-                        0x000002803D57F010>}
-            libname:genlib
-            rects:{}
-            paths:{}
-            pins:{}
-            texts:{}
-            instances:
-                {'I0': <laygo2.object.physical.Instance object at 0x000002803D57F010>}
-            virtual instances:{}
-        >>> # When placing multiple instances by wrapping them with a list:
-        >>> i1 = Instance(libname="tlib", cellname="t1", name="I1", xy=[0, 0])
-        >>> i2 = Instance(libname="tlib", cellname="t2", name="I2", xy=[0, 0])
-        >>> i3 = Instance(libname="tlib", cellname="t3", name="I3", xy=[0, 0])
-        >>> dsn.place(inst= [i1, i2, i3], grid=g, mn=[10,10])
-        >>> print(dsn)
-        <laygo2.object.database.Design object at 0x000002803D4C0F40>
-            name: mycell
-            params: None
-            elements:
-                {'I0': <laygo2.object.physical.Instance object at
-                        0x000002803D57F010>,
-                 'I1': <laygo2.object.physical.Instance object at
-                        0x000002803D57F011>,
-                 'I2': <laygo2.object.physical.Instance object at
-                        0x000002803D57F012>,
-                 'I3': <laygo2.object.physical.Instance object at
-                        0x000002803D57F013>
-                        }
-            libname:genlib
-            rects:{}
-            paths:{}
-            pins:{}
-            texts:{}
-            instances:
-                {'I0': <laygo2.object.physical.Instance object at 0x000002803D57F010>,
-                 'I1': <laygo2.object.physical.Instance object at 0x000002803D57F011>,
-                 'I2': <laygo2.object.physical.Instance object at 0x000002803D57F012>,
-                 'I3': <laygo2.object.physical.Instance object at 0x000002803D57F013>
-                }
-            virtual instances:{}
-
-        See Also
-        --------
-        laygo2.object.grid.PlacementGrid.place : place a (virtual) instance
-            on the grid.
-
-        Notes
-        -----
-        **(Korean)** 인스턴스를 grid위 추상 좌표 mn에 배치하는 함수.
-
-        파라미터
-            - inst(laygo2.physical.instance or list(laygo2.object.physical.Instance)): 배치할 인스턴스 또는 배치할 인스턴스 들을 갖는 리스트.
-            - mn(numpy.ndarray or list): 인스턴스를 배치할 추상좌표.
-
-        반환값
-            - laygo2.physical.instance or list(laygo2.object.physical.Instance) : 좌표가 수정된 인스턴스 또는 좌표가 수정된 인스턴스 들을 갖는 리스트.
-        """
-        if isinstance(inst, (laygo2.object.Instance, laygo2.object.VirtualInstance)):
-            # single instance
-            if anchor_xy is None:
-                _mn = mn
-            else:
-                _xy = anchor_xy[0] - anchor_xy[1]
-                _mn = mn + grid.mn(_xy)
-            inst = grid.place(inst, _mn)
-            self.append(inst)
-            return inst
-        else:
-            # multiple instances (anchor_xy is not supported yet)
-            matrix = np.asarray(inst)
-            size = matrix.shape
-
-            if len(size) == 2:
-                m, n = size
-            else:  # when 1-dimentional array
-                m, n = 1, size[0]
-                matrix = [matrix]
-
-            mn_ref = np.array(mn)
-            for index in range(m):
-                row = matrix[index]
-                if index != 0:
-                    ns = 0
-                    ms = index - 1
-                    while row[ns] == None:  # Right search
-                        ns = ns + 1
-                    while matrix[ms][ns] == None:  # Down search
-                        ms = ms - 1
-                    mn_ref = grid.mn.top_left(matrix[ms][ns])
-
-                for element in row:
-                    if isinstance(element, (laygo2.object.Instance, laygo2.object.VirtualInstance)):
-                        mn_bl = grid.mn.bottom_left(element)
-                        mn_comp = mn_ref - mn_bl
-                        inst_sub = grid.place(element, mn_comp)
-                        self.append(inst_sub)
-                        mn_ref = grid.mn.bottom_right(element)
-                    else:
-                        if element == None:
-                            pass
-                        elif isinstance(element, int):
-                            mn_ref = mn_ref + [element, 0]  # offset
-            return inst
-
-    def route(self, grid, mn, direction=None, via_tag=None):
-        """
-        Create wire object(s) for routing at abstract coordinate **mn**.
-
-        Parameters
-        ----------
-        grid : laygo2.object.grid.RoutingGrid
-            Placement grid for wire placement.
-        mn : list(numpy.ndarray)
-            List containing two or more **mn** coordinates to be connected.
-        direction : str, optional.
-            None or “vertical” or "horizontal". The direction of the routing
-            object.
-        via_tag : list(Boolean), optional.
-            The list containing switches deciding whether to place via at
-            the edges.
-
-        Returns
-        -------
-        laygo2.object.physical.Rect or list :
-            The generated routing object(s).
-            Check the example code in laygo2.object.grid.RoutingGrid.route
-            for details.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> from laygo2.object.grid import CircularMapping as CM
-        >>> from laygo2.object.grid import CircularMappingArray as CMA
-        >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
-        >>> from laygo2.object.template import NativeInstanceTemplate
-        >>> from laygo2.object.database import Design
-        >>> from laygo2.object.physical import Instance
-        >>> # Routing grid construction (not needed if laygo2_tech is set up).
-        >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
-        >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
-        >>> wv = CM([10])           # vertical (xgrid) width
-        >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
-        >>> ev = CM([10])           # vertical (xgrid) extension
-        >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
-        >>> e0v = CM([15])          # vert. extension (for zero-length wires)
-        >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
-        >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
-        >>> lh = CM([['M2', 'drawing']]*3, dtype=object)
-        >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
-        >>> plh = CM([['M2', 'pin']]*3, dtype=object)
-        >>> xcolor = CM([None], dtype=object)  # not multipatterned
-        >>> ycolor = CM([None]*3, dtype=object)
-        >>> primary_grid = 'horizontal'
-        >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via
-        >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
-        >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
-                                               vwidth=wv, hwidth=wh,
-                                               vextension=ev, hextension=eh,
-                                               vlayer=lv, hlayer=lh,
-                                               pin_vlayer=plv, pin_hlayer=plh,
-                                               viamap=viamap, primary_grid=primary_grid,
-                                               xcolor=xcolor, ycolor=ycolor,
-                                               vextension0=e0v, hextension0=e0h)
-        >>> # Create a design
-        >>> dsn = Design(name="mycell", libname="genlib")
-        >>> #################
-        >>> # Route on grid #
-        >>> #################
-        >>> mn_list = [[0, -2], [0, 1], [2, 1], [5,1] ]
-        >>> route = dsn.route(grid=g, mn=mn_list,
-                              via_tag=[True, None, True, True])
-        >>> # Display generated design.
-        >>> print(dsn)
-        <laygo2.object.database.Design object at 0x000001C71AE3A110>
-            name: mycell, params: None
-            elements: {
-            'NoName_0': <laygo2.object.physical.Instance object at 0x000001C71AE3BA90>,
-            'NoName_1': <laygo2.object.physical.Rect object at 0x000001C71AE3B820>,
-            'NoName_2': <laygo2.object.physical.Rect object at 0x000001C71AE3ABF0>,
-            'NoName_3': <laygo2.object.physical.Instance object at 0x000001C71AE3A140>,
-            'NoName_4': <laygo2.object.physical.Rect object at 0x000001C71AE39DB0>,
-            'NoName_5': <laygo2.object.physical.Instance object at 0x000001C71AE3AB60>}
-            libname:genlib
-            rects: {  # wires
-            'NoName_1': <laygo2.object.physical.Rect object at 0x000001C71AE3B820>,
-            'NoName_2': <laygo2.object.physical.Rect object at 0x000001C71AE3ABF0>,
-            'NoName_4': <laygo2.object.physical.Rect object at 0x000001C71AE39DB0>}
-            paths:{}
-            pins:{}
-            texts:{}
-            instances:{  # vias
-            'NoName_0': <laygo2.object.physical.Instance object at 0x000001C71AE3BA90>,
-            'NoName_3': <laygo2.object.physical.Instance object at 0x000001C71AE3A140>,
-            'NoName_5': <laygo2.object.physical.Instance object at 0x000001C71AE3AB60>}
-            virtual instances:{}
-
-        .. image:: ../assets/img/object_grid_RoutingGrid_route.png
-           :height: 250
-
-        See Also
-        --------
-        laygo2.object.grid.RoutingGrid.route : route wire(s) on the grid.
-
-        Notes
-        -----
-        **(Korean)** 추상 좌표 위에 라우팅을 수행 하는 함수.
-
-        파라미터
-            - mn(list(numpy.ndarray)): 배선을 수행할 2개 이상의 mn 좌표를 담고 있는 list.
-            - direction(str): None or “vertical”; path의 방향을 결정 (수평 or 수직) [optional].
-            - via_tag(list(Boolean)): Path에 via를 형성 할지를 결정하는 switch들을 담고 있는 list [optional].
-
-        반환값
-            - list: 생성된 routing object들을 담고 있는 list.
-        """
-        r = grid.route(mn=mn, direction=direction, via_tag=via_tag)
-        self.append(r)
-        return r
-
-    def via(self, grid, mn, params=None):
-        """
-        Create Via object(s) on abstract grid.
-
-        Parameters
-        ----------
-        mn : list(numpy.ndarray)
-            Abstract coordinate(s) that specify location(s) to insert via(s).
-
-        Returns
-        -------
-        list(physical.PhysicalObject):
-            The list containing the generated via objects.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> from laygo2.object.grid import CircularMapping as CM
-        >>> from laygo2.object.grid import CircularMappingArray as CMA
-        >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
-        >>> from laygo2.object.template import NativeInstanceTemplate
-        >>> from laygo2.object.database import Design
-        >>> from laygo2.object.physical import Instance
-        >>> # Routing grid construction (not needed if laygo2_tech is set up).
-        >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
-        >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
-        >>> wv = CM([10])           # vertical (xgrid) width
-        >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
-        >>> ev = CM([10])           # vertical (xgrid) extension
-        >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
-        >>> e0v = CM([15])          # vert. extension (for zero-length wires)
-        >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
-        >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
-        >>> lh = CM([['M2', 'drawing']]*3, dtype=object)
-        >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
-        >>> plh = CM([['M2', 'pin']]*3, dtype=object)
-        >>> xcolor = CM([None], dtype=object)  # Not multipatterned
-        >>> ycolor = CM([None]*3, dtype=object)
-        >>> primary_grid = 'horizontal'
-        >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')
-        >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
-        >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
-                                               vwidth=wv, hwidth=wh,
-                                               vextension=ev, hextension=eh,
-                                               vlayer=lv, hlayer=lh,
-                                               pin_vlayer=plv, pin_hlayer=plh,
-                                               viamap=viamap, primary_grid=primary_grid,
-                                               xcolor=xcolor, ycolor=ycolor,
-                                               vextension0=e0v, hextension0=e0h)
-        >>> # Create a design
-        >>> dsn = Design(name="mycell", libname="genlib")
-        >>> ##############
-        >>> # Place vias #
-        >>> ##############
-        >>> mn_list = [[0, -2], [1, 0], [2, 5]]
-        >>> via = dsn.via(grid=g, mn=mn_list)
-        >>> # Display generated design.
-        >>> print(dsn)
-        <laygo2.object.database.Design object at 0x0000015A77C6A110>
-        name: mycell, params: None,
-        elements: {
-        'NoName_0': <laygo2.object.physical.Instance object at 0x0000015A77C6AC20>,
-        'NoName_1': <laygo2.object.physical.Instance object at 0x0000015A77C6AD10>,
-        'NoName_2': <laygo2.object.physical.Instance object at 0x0000015A77C6AD40>}
-        libname:genlib
-        rects:{}
-        paths:{}
-        pins:{}
-        texts:{}
-        instances:{
-        'NoName_0': <laygo2.object.physical.Instance object at 0x0000015A77C6AC20>,
-        'NoName_1': <laygo2.object.physical.Instance object at 0x0000015A77C6AD10>,
-        'NoName_2': <laygo2.object.physical.Instance object at 0x0000015A77C6AD40>}
-        virtual instances:{}
-
-        .. image:: ../assets/img/object_grid_RoutingGrid_via.png
-           :height: 250
-
-        See Also
-        --------
-        laygo2.object.grid.RoutingGrid.via
-
-        Notes
-        -----
-        **(Korean)** via 생성함수.
-        파라미터
-            - mn(list(numpy.ndarray)): via를 생성할 mn좌표. 복수 개 입력 가능.
-        반환값
-            - list(physical.PhysicalObject)): 생성된 via object들을 담고 있는 list.
-        """
-        v = grid.via(mn=mn, params=params)
-        self.append(v)
-        return v
-
-    def route_via_track(self, grid, mn, track, via_tag=[None, True]):
-        """
-        Perform routing on the specified track with accessing wires to mn.
-
-        Parameters
-        ----------
-        grid : laygo2.object.grid.RoutingGrid
-            The placement grid where the wire is placed on.
-        mn : list(numpy.ndarray)
-            list containing coordinates of the points being connected through a track
-        track : numpy.ndarray
-            list containing coordinate values and direction of a track.
-            Vertical tracks have [v, None] format, while horizontal tracks have [None, v] format
-            (v is the coordinates of the track).
-        via_tag : list(Boolean), optional.
-            The list containing switches deciding whether to place via at
-            the edges of individual stubs.
-
-        Returns
-        -------
-        list:
-            The list containing the generated routing objects;
-            The last object corresponds to the routing object on the track.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> from laygo2.object.grid import CircularMapping as CM
-        >>> from laygo2.object.grid import CircularMappingArray as CMA
-        >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
-        >>> from laygo2.object.template import NativeInstanceTemplate
-        >>> from laygo2.object.database import Design
-        >>> from laygo2.object.physical import Instance
-        >>> # Routing grid construction (not needed if laygo2_tech is set up).
-        >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
-        >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
-        >>> wv = CM([10])           # vertical (xgrid) width
-        >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
-        >>> ev = CM([10])           # vertical (xgrid) extension
-        >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
-        >>> e0v = CM([15])          # vert. extension (for zero-length wires)
-        >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
-        >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
-        >>> lh = CM([['M2', 'drawing']]*3, dtype=object)
-        >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
-        >>> plh = CM([['M2', 'pin']]*3, dtype=object)
-        >>> xcolor = CM([None], dtype=object)  # not multipatterned
-        >>> ycolor = CM([None]*3, dtype=object)
-        >>> primary_grid = 'horizontal'
-        >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via
-        >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
-        >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
-                                               vwidth=wv, hwidth=wh,
-                                               vextension=ev, hextension=eh,
-                                               vlayer=lv, hlayer=lh,
-                                               pin_vlayer=plv, pin_hlayer=plh,
-                                               viamap=viamap, primary_grid=primary_grid,
-                                               xcolor=xcolor, ycolor=ycolor,
-                                               vextension0=e0v, hextension0=e0h)
-        >>> # Create a design
-        >>> dsn = Design(name="mycell", libname="genlib")
-        >>> # Do routing
-        >>> mn_list = [[0, -2], [1, 0], [2, 5], [3, 4], [4, 5], [5, 5]]
-        >>> track = dsn.route_via_track(grid=g, mn=mn_list, track=[None,0])
-        >>> # Display design
-        >>> print(dsn)
-            <laygo2.object.database.Design object at 0x0000015A77C6BA60>
-            name: mycell, params: None
-            elements: {
-            'NoName_0': <laygo2.object.physical.Rect object at 0x0000015A77C6B790>,
-            'NoName_1': <laygo2.object.physical.Instance object at 0x0000015A77C6B820>,
-            'NoName_2': <laygo2.object.physical.Instance object at 0x0000015A77C6B7C0>,
-            'NoName_3': <laygo2.object.physical.Rect object at 0x0000015A77C6B760>,
-            'NoName_4': <laygo2.object.physical.Instance object at 0x0000015A77C6A2F0>,
-            'NoName_5': <laygo2.object.physical.Rect object at 0x0000015A77C6BA90>}
-            libname:genlib
-            rects:{
-            'NoName_0': <laygo2.object.physical.Rect object at 0x0000015A77C6B790>,
-            'NoName_3': <laygo2.object.physical.Rect object at 0x0000015A77C6B760>,
-            'NoName_5': <laygo2.object.physical.Rect object at 0x0000015A77C6BA90>}
-            paths:{}
-            pins:{}
-            texts:{}
-            instances:{
-            'NoName_1': <laygo2.object.physical.Instance object at 0x0000015A77C6B820>,
-            'NoName_2': <laygo2.object.physical.Instance object at 0x0000015A77C6B7C0>,
-            'NoName_4': <laygo2.object.physical.Instance object at 0x0000015A77C6A2F0>}
-            virtual instances:{}
-        >>> print(track[-1])
-            <laygo2.object.physical.Rect object at 0x0000015A77C6BA90>
-            name: None,
-            class: Rect,
-            xy: [[0, 0], [100, 0]],
-            params: None, , layer: ['M2' 'drawing'], netname: None
-
-        .. image:: ../assets/img/object_grid_RoutingGrid_route_via_track.png
-           :height: 250
-
-        See Also
-        --------
-        laygo2.object.grid.RoutingGrid.route_via_track
-
-        Notes
-        -----
-        **(Korean)** wire 라우팅 함수, track을 기준점으로 routing을 진행한다.
-
-        파라미터
-            - track(numpy.ndarray): track의 좌표값과 방향을 담고 있는 list.
-            수직 트랙일 경우 [v, None], 수평 트랙일 경우 [None, v]의 형태를
-            가지고 있다 (v는 track의 좌표값).
-            - mn(list(numpy.ndarray)): track을 통해 연결될 지점들의 좌표를
-            담고 있는 list.
-        반환값
-            - list: 생성된 routing object들을 담고 있는 list.
-            마지막 object가 track위의 routing object에 해당.
-        """
-        r = grid.route_via_track(mn=mn, track=track, via_tag=via_tag)
-        self.append(r)
-        return r
-
-    def pin(self, name, grid, mn, direction=None, netname=None, params=None):
-        """
-        Create a Pin object over the abstract coordinates specified by mn,
-        on the specified routing grid.
-
-        Parameters
-        ----------
-        name : str
-            Pin name.
-        mn : numpy.ndarray
-            Abstract coordinates for generating Pin.
-        direction : str, optional.
-            Direction.
-        netname : str, optional.
-            Net name of Pin.
-        params : dict, optional
-            Pin attributes.
-
-        Returns
-        -------
-        laygo2.physical.Pin: The generated pin object.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> from laygo2.object.grid import CircularMapping as CM
-        >>> from laygo2.object.grid import CircularMappingArray as CMA
-        >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
-        >>> from laygo2.object.template import NativeInstanceTemplate
-        >>> from laygo2.object.database import Design
-        >>> from laygo2.object.physical import Instance
-        >>> # Routing grid construction (not needed if laygo2_tech is set up).
-        >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
-        >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
-        >>> wv = CM([10])           # vertical (xgrid) width
-        >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
-        >>> ev = CM([10])           # vertical (xgrid) extension
-        >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
-        >>> e0v = CM([15])          # vert. extension (for zero-length wires)
-        >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
-        >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
-        >>> lh = CM([['M2', 'drawing']]*3, dtype=object)
-        >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
-        >>> plh = CM([['M2', 'pin']]*3, dtype=object)
-        >>> xcolor = CM([None], dtype=object)  # Not multipatterned
-        >>> ycolor = CM([None]*3, dtype=object)
-        >>> primary_grid = 'horizontal'
-        >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via
-        >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
-        >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
-                                               vwidth=wv, hwidth=wh,
-                                               vextension=ev, hextension=eh,
-                                               vlayer=lv, hlayer=lh,
-                                               pin_vlayer=plv, pin_hlayer=plh,
-                                               viamap=viamap, primary_grid=primary_grid,
-                                               xcolor=xcolor, ycolor=ycolor,
-                                               vextension0=e0v, hextension0=e0h)
-        >>> # Create a design
-        >>> dsn = Design(name="mycell", libname="genlib")
-        >>> ###############
-        >>> # Place a pin #
-        >>> ###############
-        >>> mn = [[0, 0], [10, 10]]
-        >>> pin = dsn.pin(name="pin", grid=g, mn=mn)
-        >>> print(pin)
-        <laygo2.object.physical.Pin object at 0x0000028DABE3AB90>
-            name: pin,
-            class: Pin,
-            xy: [[0, -10], [500, 350]],
-            params: None, , layer: ['M2' 'pin'], netname: pin, shape: None,
-            master: None
-        >>> print(dsn)
-        <laygo2.object.database.Design object at 0x0000028DABE3A110> name: mycell, params: None
-            elements: {'pin': <laygo2.object.physical.Pin object at
-            0x0000028DABE3AB90>}
-            libname:genlib
-            rects:{}
-            paths:{}
-            pins:{'pin': <laygo2.object.physical.Pin object at 0x0000028DABE3AB90>}
-            texts:{}
-            instances:{}
-            virtual instances:{}
-
-        Notes
-        -----
-        **(Korean)**
-        pin 생성함수.
-
-        파라미터
-            - name(str): Pin 이름.
-            - mn(numpy.ndarray): Pin을 생성할 abstract 좌표.
-            - direction(str): 방향 [optional].
-            - netname(str): Pin의 net이름 [optional].
-            - params(dict): Pin 속성 [optional].
-        반환값
-            - laygo2.physical.Pin: Pin object.
-
-        """
-        p = grid.pin(name=name, mn=mn, direction=direction, netname=netname, params=params)
-        self.append(p)
-        return p
-
-    # I/O functions
-    def export_to_template(self, libname=None, cellname=None):
-        """
-        Generate a NativeInstanceTemplate object corresponding to Design object.
-
-        Parameters
-        ----------
-        libname: str
-            The library name.
-        cellname: str
-            The cell name.
-
-        Returns
-        -------
-        laygo2.NativeInstanceTemplate: The generated template object.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> from laygo2.object.database import Design
-        >>> from laygo2.object.physical import Rect, Pin, Instance, Text
-        >>> # Create a design
-        >>> dsn = Design(name="mycell", libname="genlib")
-        >>> # Create layout objects
-        >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
-        >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
-        >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
-        >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
-        >>> dsn.append(r0)
-        >>> dsn.append(p0)
-        >>> dsn.append(i0)
-        >>> dsn.append(t0)
-        >>> # Export the design to a template.
-        >>> nt0 = dsn.export_to_template()
-        >>> print(nt0)
-        <laygo2.object.template.NativeInstanceTemplate object at XXXX>
-            name: mycell, class: NativeInstanceTemplate,
-            bbox: [[0, 0], [0, 0]],
-            pins: {'P': <laygo2.object.physical.Pin object at YYYY>},
-        >>> # Save the template into a yaml file.
-        >>> laygo2.interface.yaml.export_template(nt0, filename='mytemp.yaml')
-
-        See Also
-        --------
-            laygo2.interface.yaml.export_template : Export a template to
-            a yaml file.
-
-        Notes
-        -----
-        **(Korean)** Design 객체에 해당하는 NativeInstanceTemplate 객체 생성.
-
-        반환값
-            - laygo2.NativeInstanceTemplate
-        """
-        if libname is None:
-            libname = self.libname
-        if cellname is None:
-            cellname = self.cellname
-
-        xy = self.bbox
-        pins = self.pins
-        return laygo2.object.NativeInstanceTemplate(libname=libname, cellname=cellname, bbox=xy, pins=pins)
-
-    def get_matched_rects_by_layer(self, layer):
-        """
-        Return a list containing physical objects matched with the layer input in Design object.
-
-        Parameters
-        ----------
-        layer : list
-            The layer information. Format is [name, purpose].
-
-        Returns
-        -------
-        list: The list containing the matched Physical objects.
-
-        Example
-        -------
-        >>> dsn    = laygo2.object.Design(name='dsn', libname="testlib")
-        >>> rect0  = laygo2.object.Rect(xy=[[0, 0], [100, 100]], layer=[‘M1’, ‘drawing’]……)
-        >>> pin0   = laygo2.object.Pin(xy=[[0, 0], [100, 100]], layer=[‘M1’, ‘pin’]……)
-        >>> inst0  = laygo2.object.Instance(name=‘I0’, xy=[100, 100]……)
-        >>> vinst0_pins[‘in’]  = laygo2.object.physical.Pin(xy=[[0, 0], [10, 10]], layer=[‘M1’,’drawing’]……)
-        >>> vinst0_pins[‘out’] = laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]], layer=[‘M1’, drawing’] ……)
-        >>> vinst0 = laygo2.object.physical.VirtualInstance(name=‘VI0’, ……)
-        >>> text0  = laygo2.object.physical.Text(xy=[[ 0, 0], [100,100 ]], layer=[‘text’, ‘drawing’]……)
-        >>> dsn.append(rect0)
-        >>> dsn.append(pin0)
-        >>> dsn.append(inst0)
-        >>> dsn.append(vinst0)
-        >>> dsn.append(text0)
-        >>> print( dsn.get_matchedrects_by_layer( [“M1”, “drawing”] )
-        [<laygo2.object.physical.Rect object>,
-         <laygo2.object.physical.Pin object>,
-         <laygo2.object.physical.Pin object>,
-         <laygo2.object.physical.Rect object>]
-
-        Notes
-        -----
-        **(Korean)**
-        주어진 layer와 일치되는 Physical object 갖는 list 반환.
-        파라미터
-        layer purpose pair(list): 레이어 정보
-        반환값
-        list: 매치되는 Physical object를 담고 있는 list
-        참조
-        없음
-        """
-        rects = self.rects
-        insts = self.instances
-        vinsts = self.virtual_instances
-
-        obj_check = []
-
-        for rname, rect in rects.items():
-            if np.array_equal(rect.layer, layer):
-                obj_check.append(rect)
-
-        for iname, inst in insts.items():
-            for pname, pin in inst.pins.items():
-                if np.array_equal(pin.layer, layer):
-                    obj_check.append(pin)
-
-        for iname, vinst in vinsts.items():
-            for name, inst in vinst.native_elements.items():
-                if isinstance(inst, laygo2.object.physical.Rect):
-                    if np.array_equal(inst.layer, layer):
-                        _xy = vinst.get_element_position(inst)
-                        ninst = laygo2.object.physical.Rect(
-                            xy=_xy,
-                            layer=layer,
-                            hextension=inst.hextension,
-                            vextension=inst.vextension,
-                            color=inst.color,
-                        )
-                        obj_check.append(ninst)  ## ninst is for sort, inst should be frozen for implement to layout
-        return obj_check
-
-
-if __name__ == "__main__":
-    from laygo2.object.physical import *
-
-    # Test
-    lib = Library(name="mylib")
-    dsn = Design(name="mycell")
-    lib.append(dsn)
-    rect0 = Rect(
-        xy=[[0, 0], [100, 100]],
-        layer=["M1", "drawing"],
-        name="R0",
-        netname="net0",
-        params={"maxI": 0.005},
-    )
-    dsn.append(rect0)
-    rect1 = Rect(
-        xy=[[200, 0], [300, 100]],
-        layer=["M1", "drawing"],
-        netname="net0",
-        params={"maxI": 0.005},
-    )
-    dsn.append(rect1)
-    path0 = Path(
-        xy=[[0, 0], [0, 100]],
-        width=10,
-        extension=5,
-        layer=["M1", "drawing"],
-        netname="net0",
-        params={"maxI": 0.005},
-    )
-    dsn.append(path0)
-    pin0 = Pin(
-        xy=[[0, 0], [100, 100]],
-        layer=["M1", "pin"],
-        netname="n0",
-        master=rect0,
-        params={"direction": "input"},
-    )
-    dsn.append(pin0)
-    # text0 = Text(xy=[0, 0], layer=['text', 'drawing'], text='test', params=None)
-    # dsn.append(text0)
-    inst0_pins = dict()
-    inst0_pins["in"] = Pin(xy=[[0, 0], [10, 10]], layer=["M1", "drawing"], netname="in")
-    inst0_pins["out"] = Pin(xy=[[90, 90], [100, 100]], layer=["M1", "drawing"], netname="out")
-    inst0 = Instance(
-        name="I0",
-        xy=[100, 100],
-        libname="mylib",
-        cellname="mycell",
-        shape=[3, 2],
-        pitch=[100, 100],
-        unit_size=[100, 100],
-        pins=inst0_pins,
-        transform="R0",
-    )
-    dsn.append(inst0)
-    print(lib)
-    print(dsn)
+#!/usr/bin/python
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+"""
+**laygo2.object.database** module consists of the classes implementing a hierarchical structure database that manages design and library.
+"""
+
+__author__ = "Jaeduk Han"
+__maintainer__ = "Jaeduk Han"
+__status__ = "Prototype"
+
+import laygo2.object
+import numpy as np
+
+from laygo2.object.physical import PhysicalObject
+from laygo2.object.grid import Grid
+from laygo2.object.template import Template
+
+from laygo2._typing import T
+from typing import overload, Generic, Dict, Type, Union
+
+class BaseDatabase(Generic[T]):
+    """
+    A base class that implements basic functions for 
+    various database objects, such as libraries and designs.
+
+    Notes
+    -----
+    **(Korean)** BaseDatabase는 데이터베이스 객체들의 기본 기능을 구현하는 클래스.
+    """
+
+    name = None
+    """str: Name of BaseDatabase object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> base = laygo2.object.database.BaseDatabase(name="mycell") 
+    >>> base.name 
+    "mycell"
+
+    Notes
+    -----
+    **(Korean)** BaseDatabase 이름.
+    """
+
+    params = None
+    """dict or None: BaseDatabase object's parameter dictionary.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> base = laygo2.object.database.BaseDatabase(name="mycell",
+                   params={'ivdd': 0.001}) 
+    >>> base.params 
+    {'ivdd': 0.001}
+
+    Notes
+    -----
+    **(Korean)** BaseDatabase의 속성.
+    """
+
+    elements: Dict[str, Type[Union[PhysicalObject, T]]] = None
+    """dict: Element object dictionary.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.database import BaseDatabase
+    >>> from laygo2.object.physical import Rect, Pin, Instance, Text
+    >>> # Create a design.
+    >>> dsn = BaseDatabase(name="mycell")
+    >>> # Create layout objects.
+    >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
+    >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
+    >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
+    >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
+    >>> # Add layout objects to the design.
+    >>> dsn.append(r0)
+    >>> dsn.append(p0)
+    >>> dsn.append(i0)
+    >>> dsn.append(t0)
+    >>> # 
+    >>> # Display elements of the design.
+    >>> print(dsn.elements) 
+    {'NoName_0': <laygo2.object.physical.Rect object at 0x0000024C6C230F40>, 
+    'P': <laygo2.object.physical.Pin object at 0x0000024C6C2EFF40>, 
+    'I0': <laygo2.object.physical.Instance object at 0x0000024C6C2EFDC0>, 
+    'NoName_1': <laygo2.object.physical.Text object at 0x0000024C6C2EF8B0>}
+
+    Notes
+    -----
+    **(Korean)** BaseDatabase 객체의 구성 요소를 담고 있는 Dictionary.
+    """
+
+    noname_index = 0
+    """
+    int: Unique identifier index for unnamed objects.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.database import BaseDatabase
+    >>> from laygo2.object.physical import Rect, Pin, Instance, Text
+    >>> # Create a design
+    >>> dsn = BaseDatabase(name="mycell")
+    >>> # Create layout objects
+    >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
+    >>> dsn.append(r0)
+    >>> print(base.noname_index) 
+    0 
+    >>> r1 = Rect(xy=[[100, 100], [200, 200]], layer=["M1", "drawing"])
+    >>> dsn.append(r1)
+    >>> print(base.noname_index) 
+    1
+
+    Notes
+    -----
+    **(Korean)** BaseDatabase의 소속 객체들 중 이름이 정해지지 않은 객체의 
+    이름을 정할 때 부여되는 고유 번호.
+    """
+
+    # @property
+    def keys(self):
+        """Keys of elements.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> from laygo2.object.database import BaseDatabase
+        >>> from laygo2.object.physical import Rect, Pin, Instance, Text
+        >>> # Create a design
+        >>> dsn = BaseDatabase(name="mycell")
+        >>> # Create layout objects
+        >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
+        >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
+        >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
+        >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
+        >>> dsn.append(r0)
+        >>> dsn.append(p0)
+        >>> dsn.append(i0)
+        >>> dsn.append(t0)
+        >>> print(dsn.keys())
+        dict_keys(['NoName_0', 'P', 'I0', 'NoName_1'])
+
+        Notes
+        -----
+        **(Korean)** BaseDatabase 객체의 구성 요소를 담고 있는 Dictionary.
+        """
+        return self.elements.keys()
+
+    def items(self):
+        """
+        Key-object pairs of elements.
+
+        Parameters
+        ----------
+        None
+
+        Returns
+        -------
+        dict_items
+
+        Example
+        -------
+        >>> import laygo2
+        >>> from laygo2.object.database import BaseDatabase
+        >>> from laygo2.object.physical import Rect, Pin, Instance, Text
+        >>> # Create a design
+        >>> dsn = BaseDatabase(name="mycell")
+        >>> # Create layout objects
+        >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
+        >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
+        >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
+        >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
+        >>> dsn.append(r0)
+        >>> dsn.append(p0)
+        >>> dsn.append(i0)
+        >>> dsn.append(t0)
+        >>> print(dsn.items())
+        dict_items([('NoName_0', <laygo2.object.physical.Rect object at 0x0000024C6C230F40>),
+                    ('P', <laygo2.object.physical.Pin object at 0x0000024C6C2EFF40>),
+                    ('I0', <laygo2.object.physical.Instance object at 0x0000024C6C2EFDC0>),
+                    ('NoName_1', <laygo2.object.physical.Text object at 0x0000024C6C2EF8B0>)])
+
+        Notes
+        -----
+        **(Korean)** elements의 key/object 짝 출력.
+        """
+        return self.elements.items()
+
+    @overload
+    def __getitem__(self: "BaseDatabase[T]", pos) -> Type[T]: ...
+    @overload
+    def __getitem__(self: "BaseDatabase[None]", pos) -> Type[PhysicalObject]: ...
+
+    def __getitem__(self, pos):
+        """
+        Return the object corresponding to pos.
+
+        Parameters
+        ----------
+        pos : str
+            Name of object.
+
+        Returns
+        -------
+        laygo2.object.physical : corresponding object.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> from laygo2.object.database import BaseDatabase
+        >>> from laygo2.object.physical import Rect, Pin, Instance, Text
+        >>> # Create a design
+        >>> dsn = BaseDatabase(name="mycell")
+        >>> # Create layout objects
+        >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
+        >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
+        >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
+        >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
+        >>> dsn.append(r0)
+        >>> dsn.append(p0)
+        >>> dsn.append(i0)
+        >>> dsn.append(t0)
+        >>> print(dsn["I0"])
+        <laygo2.object.physical.Instance object at 0x0000024C6C2EFDC0>
+        name: I0,
+        class: Instance,
+        xy: [0, 0],
+        params: None,
+        size: [0, 0]
+        shape: None
+        pitch: [0, 0]
+        transform: R0
+        pins: {}
+
+        Notes
+        -----
+        **(Korean)** key에 해당하는 object 반환.
+        """
+        return self.elements[pos]
+
+    def __setitem__(self, key, item):
+        """
+        Add key/object pair.
+
+        Parameters
+        ----------
+        key : str
+            Object key (name).
+
+        Example
+        -------
+        >>> import laygo2
+        >>> from laygo2.object.database import BaseDatabase
+        >>> from laygo2.object.physical import Rect, Pin, Instance, Text
+        >>> # Create a design
+        >>> dsn = BaseDatabase(name="mycell")
+        >>> # Create layout objects
+        >>> r1 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
+        >>> dsn.append(r1)
+        >>> r2 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
+        >>> dsn["R2"] = r2
+        >>> print(dsn["R2"])
+        <laygo2.object.physical.Rect object at 0x0000024C6C107C40>
+        name: R2,
+        class: Rect,
+        xy: [[0, 0], [100, 100]],
+        params: None, , layer: ['M1', 'drawing'], netname: None
+
+        Notes
+        -----
+        **(Korean)** 요소 추가 함수.
+        """
+        item.name = key
+        self.append(item)
+
+    def append(self, item):
+        """Add physical object to BaseDatabase without taking any further actions.
+
+        Parameters
+        ----------
+        item : laygo2.object.physical.PhysicalObject
+            Physical object to be added.
+
+        Returns
+        -------
+        list :
+            List of item name and item ([item.name, item]).
+
+        Example
+        -------
+        >>> import laygo2
+        >>> from laygo2.object.database import BaseDatabase
+        >>> from laygo2.object.physical import Rect, Pin, Instance, Text
+        >>> # Create a design
+        >>> dsn = Design(name="mycell", libname="genlib")
+        >>> # Create layout objects
+        >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
+        >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
+        >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
+        >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
+        >>> dsn.append(r0)
+        >>> dsn.append(p0)
+        >>> dsn.append(i0)
+        >>> dsn.append(t0)
+        >>> print(dsn)
+        <laygo2.object.database.BaseDatabase object at 0x0000024C6C2EF010>
+            name: mycell, params: None
+            elements: {
+                'NoName_0': <laygo2.object.physical.Rect object at 0x0000024C6C230F40>,
+                'P': <laygo2.object.physical.Pin object at 0x0000024C6C2EFF40>,
+                'I0': <laygo2.object.physical.Instance object at 0x0000024C6C2EFDC0>,
+                'NoName_1': <laygo2.object.physical.Text object at 0x0000024C6C2EF8B0>}
+
+        See Also
+        --------
+            laygo2.object.database.Library.append
+            laygo2.object.database.Design.append
+        """
+        if isinstance(item, list) or isinstance(item, np.ndarray):
+            item_name_list = []
+            item_list = []
+            for i in item:
+                _item_name, _item = self.append(i)
+                item_name_list.append(_item_name)
+                item_list.append(_item)
+            return item_name_list, item_list
+            # return [i[0] for i in item_list], [i[1] for i in item_list]
+        else:
+            item_name = item.name
+            if item_name is None:  # NoName object. Put a name on it.
+                while "NoName_" + str(self.noname_index) in self.elements.keys():
+                    self.noname_index += 1
+                item_name = "NoName_" + str(self.noname_index)
+                self.noname_index += 1
+            errstr = item_name + " cannot be added to " + self.name + ", as a child object with the same name exists."
+            if item_name in self.elements.keys():
+                raise KeyError(errstr)
+            else:
+                if item_name in self.elements.keys():
+                    raise KeyError(errstr)
+                else:
+                    self.elements[item_name] = item
+            return item_name, item
+
+    def __iter__(self):
+        """Element-mapped direct iterator function.
+        
+        Example
+        -------
+        >>> import laygo2
+        >>> from laygo2.object.database import BaseDatabase
+        >>> from laygo2.object.physical import Rect, Pin, Instance, Text
+        >>> # Create a design
+        >>> dsn = BaseDatabase(name="mycell")
+        >>> # Create layout objects
+        >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
+        >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
+        >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
+        >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
+        >>> dsn.append(r0)
+        >>> dsn.append(p0)
+        >>> dsn.append(i0)
+        >>> for o in dsn.items():
+        >>>     print(o)
+        ('NoName_0', <laygo2.object.physical.Rect object at 0x0000024C6C230F40>)
+        ('P', <laygo2.object.physical.Pin object at 0x0000024C6C2EFF40>)
+        ('I0', <laygo2.object.physical.Instance object at 0x0000024C6C2EFDC0>)
+        ('NoName_1', <laygo2.object.physical.Text object at 0x0000024C6C2EF8B0>)
+
+        Notes
+        -----
+        **(Korean)** BaseDatabase의 Iterable 함수.
+        """
+        return self.elements.__iter__()
+
+    def __str__(self):
+        return self.summarize()
+
+    def summarize(self):
+        """Get object information summary."""
+        return (
+            self.__repr__() + " " + "name: " + self.name + ", " + "params: " + str(self.params) + " \n"
+            "    elements: " + str(self.elements) + ""
+        )
+
+    def __init__(self, name, params=None, elements=None):
+        """
+        BaseDatabase class constructor function.
+
+        Parameters
+        ----------
+        name : str
+            BaseDatabase object name.
+        params : dict, optional
+            parameters of BaseDatabase.
+        elements : dict, optional
+            dictionary having the elements of BaseDatabase.
+
+        Returns
+        -------
+        laygo2.object.BaseDatabase
+
+        Example
+        -------
+        >>> import laygo2
+        >>> base = laygo2.object.database.BaseDatabase(name='mycell')
+        >>> print(base)
+        <laygo2.object.database.BaseDatabase object>
+        name: mycell, params: None elements: {}>
+
+        Notes
+        -----
+        **(Korean)** BaseDatabase 클래스 생성자 함수.
+
+        파라미터
+            - name(str): BaseDatabase 객체의 이름
+            - params(dict): BaseDatabase의 parameters [optional]
+            - elements(dict): BaseDatabase의 elements를 갖고 있는 dict [optional]
+        반환값
+            - laygo2.object.BaseDatabase
+        """
+        self.name = name
+        self.params = params
+
+        self.elements = dict()
+        if elements is not None:
+            for e in elements:
+                self.elements[e] = elements[e]
+
+
+class LibraryWrapper(BaseDatabase[T]):
+    def get_libname(self):
+        """getter function of libname property."""
+        return self.name
+
+    def set_libname(self, val):
+        """setter function of libname property."""
+        self.name = val
+
+    libname = property(get_libname, set_libname)
+    """str: The name of library.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> lib = laygo2.object.database.Library(name='mylib') 
+    >>> print(lib.name) 
+    "mylib"
+
+    Notes
+    -----
+    **(Korean)** Library 객체의 이름.
+    """
+
+    def append(self, item: T):
+        """Add physical object to Library without taking any further actions.
+        """
+        if isinstance(item, list) or isinstance(item, np.ndarray):
+            item_name_list = []
+            item_list = []
+            for i in item:
+                _item_name, _item = self.append(i)
+                item_name_list.append(_item_name)
+                item_list.append(_item)
+            return item_name_list, item_list
+        else:
+            item_name, item = BaseDatabase.append(self, item)
+            item.libname = self.name  # update library name
+            return item_name, item
+
+    def __init__(self, name, params=None, elements=None):
+        """Constructor function of Library class.
+
+        Parameters
+        ----------
+        name : str
+            Library object name.
+        params : dict, optional
+            Library parameters.
+        elements : dict, optional
+            Dictionary having the elements of Library.
+
+        Returns
+        -------
+        laygo2.object.Library
+
+        Example
+        -------
+        >>> import laygo2
+        >>> lib = laygo2.object.database.Library(name='mylib')
+        >>> print(lib)
+        <laygo2.object.database.Library > name: mylib, params: None elements: {} >
+
+        Notes
+        -----
+        **(Korean)** Library 클래스의 생성자 함수.
+        파라미터
+            - name(str): Library 객체의 이름
+            - params(dict): Library의 parameters [optional]
+            - elements(dict): Library의 elements를 갖고 있는 dict [optional]
+        반환값
+            - laygo2.object.Library
+        """
+        BaseDatabase.__init__(self, name=name, params=params, elements=elements)
+
+    def summarize(self):
+        """Get object information summary."""
+        return BaseDatabase.summarize(self)
+
+class Library(LibraryWrapper["Design"]):
+    """
+    Class for library management function implementation.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> lib = laygo2.object.database.Library(name="mylib")
+    >>> dsn0 = laygo2.object.database.Design(name="mycell0")
+    >>> dsn1 = laygo2.object.database.Design(name="mycell1")
+    >>> lib.append(dsn0)
+    >>> lib.append(dsn1)
+    >>> print(lib)
+    <laygo2.object.database.Library object at 0x0000025F2D25B8B0>
+    name: mylib, params: None
+    elements: {
+        'mycell0': <laygo2.object.database.Design object at 0x0000025F2D25B010>,
+        'mycell1': <laygo2.object.database.Design object at 0x0000025F2D25BF70>}
+
+    See Also
+    --------
+    laygo2.object.databse.Design: Check for more comprehensive Example.
+
+    Notes
+    -----
+    **(Korean)** Library 클래스는 라이브러리 관리 기능을 구현한다.
+
+    """
+
+    pass
+
+class TemplateLibrary(LibraryWrapper[Template]):
+    """Class implementing template libraries with templates as child objects."""
+
+    # TODO: implement this.
+    pass
+
+
+class GridLibrary(LibraryWrapper[Grid]):
+    """Class implementing grid libraries with grids as child objects."""
+
+    # TODO: implement this.
+    pass
+
+
+class Design(BaseDatabase):
+    """
+    Class for design management function implementation.
+
+    Example
+    -------
+    A physical (non-abstract) grid example:
+
+    >>> import laygo2
+    >>> from laygo2.object.database import Design
+    >>> from laygo2.object.physical import Rect, Pin, Instance, Text
+    >>> # Create a design.
+    >>> dsn = Design(name="mycell", libname="genlib")
+    >>> # Create layout objects.
+    >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
+    >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
+    >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
+    >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
+    >>> # Add the layout objects to the design object.
+    >>> dsn.append(r0)
+    >>> dsn.append(p0)
+    >>> dsn.append(i0)
+    >>> dsn.append(t0)
+    >>> print(dsn)
+    <laygo2.object.database.Design object at 0x0000024C6C2EF010>
+        name: mycell, params: None
+        elements: {
+            'NoName_0': <laygo2.object.physical.Rect object at 0x0000024C6C230F40>,
+            'P': <laygo2.object.physical.Pin object at 0x0000024C6C2EFF40>,
+            'I0': <laygo2.object.physical.Instance object at 0x0000024C6C2EFDC0>,
+            'NoName_1': <laygo2.object.physical.Text object at 0x0000024C6C2EF8B0>}
+        libname:genlib
+        rects:{
+            'NoName_0': <laygo2.object.physical.Rect object at 0x0000024C6C230F40>}
+        paths:{}
+        pins:{
+            'P': <laygo2.object.physical.Pin object at 0x0000024C6C2EFF40>}
+        texts:{
+            'NoName_1': <laygo2.object.physical.Text object at 0x0000024C6C2EF8B0>}
+        instances:{
+            'I0': <laygo2.object.physical.Instance object at 0x0000024C6C2EFDC0>}
+        virtual instances:{}
+    >>> #
+    >>> # Export to a NativeInstanceTemplate for reuse in higher levels.
+    >>> nt0 = dsn.export_to_template()
+    >>> nt0.dsn.export_to_template()
+    >>> print(nt0)
+        <laygo2.object.template.NativeInstanceTemplate object at 0x000001CB5A9CE380>
+        name: mycell,
+        class: NativeInstanceTemplate,
+         bbox: [[0, 0], [0, 0]],
+         pins: {'P': <laygo2.object.physical.Pin object at 0x000001CB5A9CFF40>},
+    >>> #
+    >>> # Export to a skill script.
+    >>> lib = laygo2.object.database.Library(name="mylib")
+    >>> lib.append(dsn)
+    >>> scr = laygo2.interface.skill.export(lib, filename="myscript.il")
+    >>> print(scr)
+    ; (definitions of laygo2 skill functions)
+    ; exporting mylib__mycell
+    cv = _laygo2_open_layout("mylib" "mycell" "layout")
+    _laygo2_generate_rect(cv, list( "M1" "drawing" ), list( list( 0.0000  0.0000  ) list( 0.1000  0.1000  ) ), "None")
+    _laygo2_generate_pin(cv, "P", list( "M1" "pin" ), list( list( 0.0000  0.0000  ) list( 0.0500  0.0500  ) ) )
+    _laygo2_generate_instance(cv, "I0", "tlib", "t0", "layout", list( 0.0000  0.0000  ), "R0", 1, 1, 0, 0, nil, nil)
+    _laygo2_save_and_close_layout(cv)
+
+    An abstract grid example:
+
+    >>> import laygo2
+    >>> from laygo2.object.grid import CircularMapping as CM
+    >>> from laygo2.object.grid import CircularMappingArray as CMA
+    >>> from laygo2.object.grid import OneDimGrid, PlacementGrid, RoutingGrid
+    >>> from laygo2.object.template import NativeInstanceTemplate
+    >>> from laygo2.object.database import Design
+    >>> from laygo2.object.physical import Instance
+    >>> # Placement grid construction (not needed if laygo2_tech is set up).
+    >>> gx  = OneDimGrid(name="gx", scope=[0, 20], elements=[0])
+    >>> gy  = OneDimGrid(name="gy", scope=[0, 100], elements=[0])
+    >>> gp  = PlacementGrid(name="test", vgrid=gx, hgrid=gy)
+    >>> # Routing grid construction (not needed if laygo2_tech is set up).
+    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
+    >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
+    >>> wv = CM([10])           # vertical (xgrid) width
+    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
+    >>> ev = CM([10])           # vertical (xgrid) extension
+    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
+    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
+    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
+    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
+    >>> lh = CM([['M2', 'drawing']]*3, dtype=object)
+    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
+    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
+    >>> xcolor = CM([None], dtype=object)  # not multipatterned
+    >>> ycolor = CM([None]*3, dtype=object)
+    >>> primary_grid = 'horizontal'
+    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via
+    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
+    >>> gr = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
+                                            vwidth=wv, hwidth=wh,
+                                            vextension=ev, hextension=eh,
+                                            vlayer=lv, hlayer=lh,
+                                            pin_vlayer=plv, pin_hlayer=plh,
+                                            viamap=viamap, primary_grid=primary_grid,
+                                            xcolor=xcolor, ycolor=ycolor,
+                                            vextension0=e0v, hextension0=e0h)
+    >>> # Create a design
+    >>> dsn = Design(name="mycell", libname="genlib")
+    >>> # Create an instance
+    >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
+    >>> print(inst0.xy)
+    [100, 100]
+    >>> # Place the instance
+    >>> dsn.place(inst=i0, grid=gp, mn=[10,10])
+    >>> # Routing on grid
+    >>> mn_list = [[0, -2], [0, 1], [2, 1], [5,1] ]
+    >>> route = dsn.route(grid=gr, mn=mn_list,
+                          via_tag=[True, None, True, True])
+    >>> #
+    >>> # Display generated design.
+    >>> print(dsn)
+    <laygo2.object.database.Design object at 0x000001C71AE3A110>
+        ...
+    >>> #
+    >>> # Export to a NativeInstanceTemplate for reuse in higher levels.
+    >>> nt0 = dsn.export_to_template()
+    >>> nt0.dsn.export_to_template()
+    >>> print(nt0)
+        ...
+    >>> #
+    >>> # Export to a skill script.
+    >>> lib = laygo2.object.database.Library(name="mylib")
+    >>> lib.append(dsn)
+    >>> scr = laygo2.interface.skill.export(lib, filename="myscript.il")
+    >>> print(scr)
+        ...
+
+    An abstract template/grid example with technology setup (laygo2_tech):
+
+    >>> import laygo2
+    >>> import laygo2.interface
+    >>> import laygo2_tech_quick_start as tech  # target tech's laygo2_tech
+    >>> from laygo2.object.database import Design
+    >>> templates = tech.load_templates()
+    >>> mytemplate = templates['nmos']
+    >>> grids = tech.load_grids(templates=templates)
+    >>> gp = grids['placement_basic']
+    >>> gr = grids['routing_23_cmos']
+    >>> # Create a design
+    >>> dsn = Design(name="mycell", libname="genlib")
+    >>> # Create an instance
+    >>> i0 = tnmos.generate(name='MN0', params={'nf': 4})
+    >>> # Place the instance
+    >>> dsn.place(inst=i0, grid=gp, mn=[10,10])
+    >>> # Routing on grid
+    >>> mn_list = [[0, -2], [0, 1], [2, 1], [5,1] ]
+    >>> route = dsn.route(grid=gr, mn=mn_list,
+                          via_tag=[True, None, True, True])
+    >>> #
+    >>> # Display generated design.
+    >>> print(dsn)
+    <laygo2.object.database.Design object at 0x000001C71AE3A110>
+        ...
+    >>> #
+    >>> # Export to a NativeInstanceTemplate for reuse in higher levels.
+    >>> nt0 = dsn.export_to_template()
+    >>> nt0.dsn.export_to_template()
+    >>> print(nt0)
+        ...
+    >>> #
+    >>> # Export to a skill script.
+    >>> lib = laygo2.object.database.Library(name="mylib")
+    >>> lib.append(dsn)
+    >>> scr = laygo2.interface.skill.export(lib, filename="myscript.il")
+    >>> print(scr)
+        ...
+
+
+    Notes
+    -----
+    **(Korean)**
+    Design 클래스는 디자인 관리 기능을 구현한다.
+    """
+
+    @property
+    def bbox(self):
+        """Get design bounding box by taking union of instances' bounding boxes."""
+        libname = self.libname
+        cellname = self.cellname
+        # Compute boundaries
+        xy = [None, None]
+        for n, i in self.instances.items():
+            if xy[0] is None:
+                xy[0] = i.bbox[0]  # bl
+                xy[1] = i.bbox[1]  # tr
+            else:
+                #xy = np.minimum(xy, i.bbox)
+                xy[0][0] = min(xy[0][0], i.bbox[0, 0])
+                xy[0][1] = min(xy[0][1], i.bbox[0, 1])
+                xy[1][0] = max(xy[1][0], i.bbox[1, 0])
+                xy[1][1] = max(xy[1][1], i.bbox[1, 1])
+        for n, i in self.virtual_instances.items():
+            if xy[0] is None:
+                xy[0] = i.bbox[0]
+                xy[1] = i.bbox[1]
+            else:
+                #y = np.minimum(xy, i.bbox)
+                xy[0][0] = min(xy[0][0], i.bbox[0, 0])
+                xy[0][1] = min(xy[0][1], i.bbox[0, 1])
+                xy[1][0] = max(xy[1][0], i.bbox[1, 0])
+                xy[1][1] = max(xy[1][1], i.bbox[1, 1])
+        xy = np.array(xy)
+        return xy
+
+    def get_libname(self):
+        return self._libname
+
+    def set_libname(self, val):
+        self._libname = val
+
+    libname = property(get_libname, set_libname)
+    """str: Design object's library name.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> dsn = laygo2.object.database.Design(name="dsn", libname="testlib") 
+    >>> print(dsn.libname) 
+    “testlib”
+
+    Notes
+    -----
+    **(Korean)** Design 객체의 라이브러리 이름.
+    """
+
+    def get_cellname(self):
+        return self.name
+
+    def set_cellname(self, val):
+        self.name = val
+
+    cellname = property(get_cellname, set_cellname)
+    """str: Design object's cell name.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> dsn = laygo2.object.database.Design(name="dsn", libname="testlib") 
+    >>> print(dsn.cellname) 
+    “dsn”
+
+    Notes
+    -----
+    **(Korean)** Design 객체의 셀 이름.
+    """
+
+    rects = None
+    """dict: Dictionary containing Rectangle object affiliated with the 
+    Design object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.database import Design
+    >>> from laygo2.object.physical import Rect, Pin, Instance, Text
+    >>> dsn = Design(name="dsn", libname="testlib") 
+    >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
+    >>> dsn.append(r0) 
+    >>> print(dsn.rects) 
+    {'R0': <laygo2.object.physical.Rect object>}
+
+    Notes
+    -----
+    **(Korean)** Design 객체에 소속된 Rect 객체들을 갖고 있는 dictionary.
+    """
+
+    def get_r(self):
+        return self.rects
+
+    def set_r(self, val):
+        self.rects = val
+
+    r = property(get_r, set_r)
+    """str: Alias of rects."""
+
+    paths = None
+
+    pins = None
+    """dict: Dictionary having the collection of Pin objects affiliated 
+    with the Design object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.database import Design
+    >>> from laygo2.object.physical import Rect, Pin, Instance, Text
+    >>> dsn = Design(name="dsn", libname="testlib") 
+    >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
+    >>> dsn.append(p0) 
+    >>> print(dsn.pins) 
+    {'NoName_0': <laygo2.object.physical.Pin object>}
+    
+    Notes
+    -----
+    **(Korean)** Design 객체에 소속된 Pin 객체들을 갖고 있는 dictionary.
+    """
+    
+    def get_p(self):
+        return self.pins
+
+    def set_p(self, val):
+        self.pins = val
+
+    p = property(get_p, set_p)
+    """str: Alias of pins."""
+    
+    texts = None
+    """dict: Dictionary containing Text objects affiliated with Design object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.database import Design
+    >>> from laygo2.object.physical import Rect, Pin, Instance, Text
+    >>> dsn = Design(name="dsn", libname="testlib") 
+    >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
+    >>> dsn.append(t0) 
+    >>> print(dsn.texts) 
+    {'NoName_1': <laygo2.object.physical.Text object>}
+    
+    Notes
+    -----
+    **(Korean)** Design 객체에 소속된 Text 객체들을 갖고 있는 dictionary.
+    """
+
+    instances = None
+    """dict: Dictionary containing Instance objects affiliated with Design object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.database import Design
+    >>> from laygo2.object.physical import Rect, Pin, Instance, Text
+    >>> dsn = Design(name="dsn", libname="testlib") 
+    >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
+    >>> dsn.append(i0) 
+    >>> print(dsn.instances) 
+    {'I0': <laygo2.object.physical.Instance object>}
+    
+    Notes
+    -----
+    **(Korean)** Design 객체에 소속된 Instance 객체들을 갖고 있는 dictionary.
+    """
+
+    def get_i(self):
+        return self.instances
+
+    def set_i(self, val):
+        self.instances = val
+
+    i = property(get_i, set_i)
+    """str: Alias of instances."""
+    
+    virtual_instances = None
+    """dict: Dictionary containing VirtualInstance objects affiliated with 
+    Design object.
+
+    See Also
+    --------
+    instances
+
+    Notes
+    -----
+    **(Korean)** Design 객체에 소속된 VirtualInstance 객체들을 갖고 있는 dictionary.
+    """
+
+    def get_vi(self):
+        return self.virtual_instances
+
+    def set_vi(self, val):
+        self.virtual_instances = val
+
+    vi = property(get_vi, set_vi)
+    """str: Alias of virtual_instances."""
+
+    def __iter__(self):
+        """Element-mapped direct iterator function.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> from laygo2.object.database import Design
+        >>> from laygo2.object.physical import Rect, Pin, Instance, Text
+        >>> # Create a design
+        >>> dsn = Design(name="mycell", libname="genlib")
+        >>> # Create layout objects
+        >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
+        >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
+        >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
+        >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
+        >>> dsn.append(r0)
+        >>> dsn.append(p0)
+        >>> dsn.append(i0)
+        >>> for o in dsn.items():
+        >>>     print(o)
+        ('NoName_0', <laygo2.object.physical.Rect object at 0x0000024C6C230F40>)
+        ('P', <laygo2.object.physical.Pin object at 0x0000024C6C2EFF40>)
+        ('I0', <laygo2.object.physical.Instance object at 0x0000024C6C2EFDC0>)
+        ('NoName_1', <laygo2.object.physical.Text object at 0x0000024C6C2EF8B0>)
+        """
+        return self.elements.__iter__()
+
+    def __init__(self, name, params=None, elements=None, libname=None):
+        """
+        Design class constructor function.
+
+        Parameters
+        ----------
+        name : str
+            Design object name.
+        params : dict, optional
+            Design object parameters.
+        elements : dict, optional
+            Design object elements.
+
+        Returns
+        -------
+        laygo2.object.BaseDatabase
+
+        Example
+        -------
+        >>> import laygo2
+        >>> dsn = laygo2.object.database.Design(name='dsn', libname="testlib")
+        >>> print(dsn)
+        <laygo2.object.database.Design object>  name: dsn, params: None
+            elements: {}
+            libname:testlib
+            rects:{}
+            paths:{}
+            pins:{}
+            texts:{}
+            instances:{}
+            virtual instances:{}
+
+        Notes
+        -----
+        **(Korean)** Design 클래스의 생성자 함수.
+
+        파라미터
+            - name(str): Design 객체의 이름
+            - params(dict): Design 객체의 parameters [optional]
+            - elements(dict): Design 객체의 elements [optional]
+        반환값
+            - laygo2.object.BaseDatabase
+        """
+        self.libname = libname
+        self.rects = dict()
+        self.paths = dict()
+        self.pins = dict()
+        self.texts = dict()
+        self.instances = dict()
+        self.virtual_instances = dict()
+        BaseDatabase.__init__(self, name=name, params=params, elements=elements)
+
+    def append(self, item):
+        """Add physical object to Design without taking any further actions.
+
+        Parameters
+        ----------
+        item : laygo2.object.physical.PhysicalObject
+            The physical object to be added.
+
+        Returns
+        -------
+        list :
+            A list containing the name of item and the item itself ([item.name, item]).
+
+        Example
+        -------
+        >>> import laygo2
+        >>> from laygo2.object.database import Design
+        >>> from laygo2.object.physical import Rect, Pin, Instance, Text
+        >>> # Create a design
+        >>> dsn = Design(name="mycell", libname="genlib")
+        >>> # Create layout objects
+        >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
+        >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
+        >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
+        >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
+        >>> dsn.append(r0)
+        >>> dsn.append(p0)
+        >>> dsn.append(i0)
+        >>> dsn.append(t0)
+        >>> print(dsn)
+        <laygo2.object.database.Design object at 0x0000024C6C2EF010>
+            name: mycell, params: None
+            elements: {
+                'NoName_0': <laygo2.object.physical.Rect object at 0x0000024C6C230F40>,
+                'P': <laygo2.object.physical.Pin object at 0x0000024C6C2EFF40>,
+                'I0': <laygo2.object.physical.Instance object at 0x0000024C6C2EFDC0>,
+                'NoName_1': <laygo2.object.physical.Text object at 0x0000024C6C2EF8B0>}
+            libname:genlib
+            rects:{
+                'NoName_0': <laygo2.object.physical.Rect object at 0x0000024C6C230F40>}
+            paths:{}
+            pins:{
+                'P': <laygo2.object.physical.Pin object at 0x0000024C6C2EFF40>}
+            texts:{
+                'NoName_1': <laygo2.object.physical.Text object at 0x0000024C6C2EF8B0>}
+            instances:{
+                'I0': <laygo2.object.physical.Instance object at 0x0000024C6C2EFDC0>}
+            virtual instances:{}
+
+        See Also
+        --------
+            laygo2.object.database.Design.place : Place a (virtual) instance
+            on a grid and append to the design.
+            laygo2.object.database.Design.route : Route on a grid and append
+            to the design.
+            laygo2.object.database.Design.route_via_track : Route on a track
+            on a grid and append.
+            laygo2.object.database.Design.pin : Place a pin on a grid and
+            append to the design.
+        """
+        if isinstance(item, list) or isinstance(item, np.ndarray):
+            return [self.append(i) for i in item]
+        else:
+            if item is None:
+                return None, None  # don't do anything
+            item_name, _item = BaseDatabase.append(self, item)
+            if item.__class__ == laygo2.object.Rect:
+                self.rects[item_name] = item
+            elif item.__class__ == laygo2.object.Path:
+                self.paths[item_name] = item
+            elif item.__class__ == laygo2.object.Pin:
+                self.pins[item_name] = item
+            elif item.__class__ == laygo2.object.Text:
+                self.texts[item_name] = item
+            elif item.__class__ == laygo2.object.Instance:
+                self.instances[item_name] = item
+            elif item.__class__ == laygo2.object.VirtualInstance:
+                self.virtual_instances[item_name] = item
+            return item_name, item
+
+    def summarize(self):
+        """Get object information summary."""
+        return (
+            BaseDatabase.summarize(self)
+            + " \n"
+            + "    libname:"
+            + str(self.libname)
+            + " \n"
+            + "    rects:"
+            + str(self.rects)
+            + " \n"
+            + "    paths:"
+            + str(self.paths)
+            + " \n"
+            + "    pins:"
+            + str(self.pins)
+            + " \n"
+            + "    texts:"
+            + str(self.texts)
+            + " \n"
+            + "    instances:"
+            + str(self.instances)
+            + "\n"
+            + "    virtual instances:"
+            + str(self.virtual_instances)
+            + ""
+        )
+
+    # Object creation and manipulation functions.
+    def place(self, inst, grid, mn=[0, 0], anchor_xy=None):
+        """
+        Place instance at abstract coordinate mn on abstract grid.
+
+        Parameters
+        ----------
+        inst : laygo2.object.physical.Instance or laygo2.object.physical.VirtualInstance or list
+            Instance(s) to be placed (when list, placed in order).
+        grid : laygo2.object.grid.PlacementGrid
+            Placement grid for instance placement.
+        mn : numpy.ndarray or list
+            Abstract coordinate value [m, n] for instance placement.
+        anchor_xy : list
+            A list that contains two overlap coordinates for placement 
+            (1st for absolute physical grid, 2nd for relative instance position).
+
+        Returns
+        -------
+        laygo2.object.physical.Instance or laygo2.object.physical.VirtualInstance or list(laygo2.object.physical.Instance):
+            Placed instance(s) (list if multiple).
+
+        Example
+        -------
+        >>> import laygo2
+        >>> from laygo2.object.grid import OneDimGrid, PlacementGrid
+        >>> from laygo2.object.database import Design
+        >>> from laygo2.object.physical import Instance
+        >>> # Create a grid (not needed if laygo2_tech is set up).
+        >>> gx  = OneDimGrid(name="gx", scope=[0, 20], elements=[0])
+        >>> gy  = OneDimGrid(name="gy", scope=[0, 100], elements=[0])
+        >>> g   = PlacementGrid(name="test", vgrid=gx, hgrid=gy)
+        >>> # Create a design
+        >>> dsn = Design(name="mycell", libname="genlib")
+        >>> # Create an instance
+        >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
+        >>> print(inst0.xy)
+        [100, 100]
+        >>> ######################
+        >>> # Place the instance #
+        >>> ######################
+        >>> dsn.place(inst=i0, grid=g, mn=[10,10])
+        >>> # Print parameters of the placed instance.
+        >>> print(i0.xy)
+        [200, 1000]
+        >>> print(dsn)
+        <laygo2.object.database.Design object at 0x000002803D4C0F40>
+            name: mycell
+            params: None
+            elements:
+                {'I0': <laygo2.object.physical.Instance object at
+                        0x000002803D57F010>}
+            libname:genlib
+            rects:{}
+            paths:{}
+            pins:{}
+            texts:{}
+            instances:
+                {'I0': <laygo2.object.physical.Instance object at 0x000002803D57F010>}
+            virtual instances:{}
+        >>> # When placing multiple instances by wrapping them with a list:
+        >>> i1 = Instance(libname="tlib", cellname="t1", name="I1", xy=[0, 0])
+        >>> i2 = Instance(libname="tlib", cellname="t2", name="I2", xy=[0, 0])
+        >>> i3 = Instance(libname="tlib", cellname="t3", name="I3", xy=[0, 0])
+        >>> dsn.place(inst= [i1, i2, i3], grid=g, mn=[10,10])
+        >>> print(dsn)
+        <laygo2.object.database.Design object at 0x000002803D4C0F40>
+            name: mycell
+            params: None
+            elements:
+                {'I0': <laygo2.object.physical.Instance object at
+                        0x000002803D57F010>,
+                 'I1': <laygo2.object.physical.Instance object at
+                        0x000002803D57F011>,
+                 'I2': <laygo2.object.physical.Instance object at
+                        0x000002803D57F012>,
+                 'I3': <laygo2.object.physical.Instance object at
+                        0x000002803D57F013>
+                        }
+            libname:genlib
+            rects:{}
+            paths:{}
+            pins:{}
+            texts:{}
+            instances:
+                {'I0': <laygo2.object.physical.Instance object at 0x000002803D57F010>,
+                 'I1': <laygo2.object.physical.Instance object at 0x000002803D57F011>,
+                 'I2': <laygo2.object.physical.Instance object at 0x000002803D57F012>,
+                 'I3': <laygo2.object.physical.Instance object at 0x000002803D57F013>
+                }
+            virtual instances:{}
+
+        See Also
+        --------
+        laygo2.object.grid.PlacementGrid.place : place a (virtual) instance
+            on the grid.
+
+        Notes
+        -----
+        **(Korean)** 인스턴스를 grid위 추상 좌표 mn에 배치하는 함수.
+
+        파라미터
+            - inst(laygo2.physical.instance or list(laygo2.object.physical.Instance)): 배치할 인스턴스 또는 배치할 인스턴스 들을 갖는 리스트.
+            - mn(numpy.ndarray or list): 인스턴스를 배치할 추상좌표.
+
+        반환값
+            - laygo2.physical.instance or list(laygo2.object.physical.Instance) : 좌표가 수정된 인스턴스 또는 좌표가 수정된 인스턴스 들을 갖는 리스트.
+        """
+        if isinstance(inst, (laygo2.object.Instance, laygo2.object.VirtualInstance)):
+            # single instance
+            if anchor_xy is None:
+                _mn = mn
+            else:
+                _xy = anchor_xy[0] - anchor_xy[1]
+                _mn = mn + grid.mn(_xy)
+            inst = grid.place(inst, _mn)
+            self.append(inst)
+            return inst
+        else:
+            # multiple instances (anchor_xy is not supported yet)
+            matrix = np.asarray(inst)
+            size = matrix.shape
+
+            if len(size) == 2:
+                m, n = size
+            else:  # when 1-dimentional array
+                m, n = 1, size[0]
+                matrix = [matrix]
+
+            mn_ref = np.array(mn)
+            for index in range(m):
+                row = matrix[index]
+                if index != 0:
+                    ns = 0
+                    ms = index - 1
+                    while row[ns] == None:  # Right search
+                        ns = ns + 1
+                    while matrix[ms][ns] == None:  # Down search
+                        ms = ms - 1
+                    mn_ref = grid.mn.top_left(matrix[ms][ns])
+
+                for element in row:
+                    if isinstance(element, (laygo2.object.Instance, laygo2.object.VirtualInstance)):
+                        mn_bl = grid.mn.bottom_left(element)
+                        mn_comp = mn_ref - mn_bl
+                        inst_sub = grid.place(element, mn_comp)
+                        self.append(inst_sub)
+                        mn_ref = grid.mn.bottom_right(element)
+                    else:
+                        if element == None:
+                            pass
+                        elif isinstance(element, int):
+                            mn_ref = mn_ref + [element, 0]  # offset
+            return inst
+
+    def route(self, grid, mn, direction=None, via_tag=None):
+        """
+        Create wire object(s) for routing at abstract coordinate **mn**.
+
+        Parameters
+        ----------
+        grid : laygo2.object.grid.RoutingGrid
+            Placement grid for wire placement.
+        mn : list(numpy.ndarray)
+            List containing two or more **mn** coordinates to be connected.
+        direction : str, optional.
+            None or “vertical” or "horizontal". The direction of the routing
+            object.
+        via_tag : list(Boolean), optional.
+            The list containing switches deciding whether to place via at
+            the edges.
+
+        Returns
+        -------
+        laygo2.object.physical.Rect or list :
+            The generated routing object(s).
+            Check the example code in laygo2.object.grid.RoutingGrid.route
+            for details.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> from laygo2.object.grid import CircularMapping as CM
+        >>> from laygo2.object.grid import CircularMappingArray as CMA
+        >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
+        >>> from laygo2.object.template import NativeInstanceTemplate
+        >>> from laygo2.object.database import Design
+        >>> from laygo2.object.physical import Instance
+        >>> # Routing grid construction (not needed if laygo2_tech is set up).
+        >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
+        >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
+        >>> wv = CM([10])           # vertical (xgrid) width
+        >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
+        >>> ev = CM([10])           # vertical (xgrid) extension
+        >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
+        >>> e0v = CM([15])          # vert. extension (for zero-length wires)
+        >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
+        >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
+        >>> lh = CM([['M2', 'drawing']]*3, dtype=object)
+        >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
+        >>> plh = CM([['M2', 'pin']]*3, dtype=object)
+        >>> xcolor = CM([None], dtype=object)  # not multipatterned
+        >>> ycolor = CM([None]*3, dtype=object)
+        >>> primary_grid = 'horizontal'
+        >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via
+        >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
+        >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
+                                               vwidth=wv, hwidth=wh,
+                                               vextension=ev, hextension=eh,
+                                               vlayer=lv, hlayer=lh,
+                                               pin_vlayer=plv, pin_hlayer=plh,
+                                               viamap=viamap, primary_grid=primary_grid,
+                                               xcolor=xcolor, ycolor=ycolor,
+                                               vextension0=e0v, hextension0=e0h)
+        >>> # Create a design
+        >>> dsn = Design(name="mycell", libname="genlib")
+        >>> #################
+        >>> # Route on grid #
+        >>> #################
+        >>> mn_list = [[0, -2], [0, 1], [2, 1], [5,1] ]
+        >>> route = dsn.route(grid=g, mn=mn_list,
+                              via_tag=[True, None, True, True])
+        >>> # Display generated design.
+        >>> print(dsn)
+        <laygo2.object.database.Design object at 0x000001C71AE3A110>
+            name: mycell, params: None
+            elements: {
+            'NoName_0': <laygo2.object.physical.Instance object at 0x000001C71AE3BA90>,
+            'NoName_1': <laygo2.object.physical.Rect object at 0x000001C71AE3B820>,
+            'NoName_2': <laygo2.object.physical.Rect object at 0x000001C71AE3ABF0>,
+            'NoName_3': <laygo2.object.physical.Instance object at 0x000001C71AE3A140>,
+            'NoName_4': <laygo2.object.physical.Rect object at 0x000001C71AE39DB0>,
+            'NoName_5': <laygo2.object.physical.Instance object at 0x000001C71AE3AB60>}
+            libname:genlib
+            rects: {  # wires
+            'NoName_1': <laygo2.object.physical.Rect object at 0x000001C71AE3B820>,
+            'NoName_2': <laygo2.object.physical.Rect object at 0x000001C71AE3ABF0>,
+            'NoName_4': <laygo2.object.physical.Rect object at 0x000001C71AE39DB0>}
+            paths:{}
+            pins:{}
+            texts:{}
+            instances:{  # vias
+            'NoName_0': <laygo2.object.physical.Instance object at 0x000001C71AE3BA90>,
+            'NoName_3': <laygo2.object.physical.Instance object at 0x000001C71AE3A140>,
+            'NoName_5': <laygo2.object.physical.Instance object at 0x000001C71AE3AB60>}
+            virtual instances:{}
+
+        .. image:: ../assets/img/object_grid_RoutingGrid_route.png
+           :height: 250
+
+        See Also
+        --------
+        laygo2.object.grid.RoutingGrid.route : route wire(s) on the grid.
+
+        Notes
+        -----
+        **(Korean)** 추상 좌표 위에 라우팅을 수행 하는 함수.
+
+        파라미터
+            - mn(list(numpy.ndarray)): 배선을 수행할 2개 이상의 mn 좌표를 담고 있는 list.
+            - direction(str): None or “vertical”; path의 방향을 결정 (수평 or 수직) [optional].
+            - via_tag(list(Boolean)): Path에 via를 형성 할지를 결정하는 switch들을 담고 있는 list [optional].
+
+        반환값
+            - list: 생성된 routing object들을 담고 있는 list.
+        """
+        r = grid.route(mn=mn, direction=direction, via_tag=via_tag)
+        self.append(r)
+        return r
+
+    def via(self, grid, mn, params=None):
+        """
+        Create Via object(s) on abstract grid.
+
+        Parameters
+        ----------
+        mn : list(numpy.ndarray)
+            Abstract coordinate(s) that specify location(s) to insert via(s).
+
+        Returns
+        -------
+        list(physical.PhysicalObject):
+            The list containing the generated via objects.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> from laygo2.object.grid import CircularMapping as CM
+        >>> from laygo2.object.grid import CircularMappingArray as CMA
+        >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
+        >>> from laygo2.object.template import NativeInstanceTemplate
+        >>> from laygo2.object.database import Design
+        >>> from laygo2.object.physical import Instance
+        >>> # Routing grid construction (not needed if laygo2_tech is set up).
+        >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
+        >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
+        >>> wv = CM([10])           # vertical (xgrid) width
+        >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
+        >>> ev = CM([10])           # vertical (xgrid) extension
+        >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
+        >>> e0v = CM([15])          # vert. extension (for zero-length wires)
+        >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
+        >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
+        >>> lh = CM([['M2', 'drawing']]*3, dtype=object)
+        >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
+        >>> plh = CM([['M2', 'pin']]*3, dtype=object)
+        >>> xcolor = CM([None], dtype=object)  # Not multipatterned
+        >>> ycolor = CM([None]*3, dtype=object)
+        >>> primary_grid = 'horizontal'
+        >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')
+        >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
+        >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
+                                               vwidth=wv, hwidth=wh,
+                                               vextension=ev, hextension=eh,
+                                               vlayer=lv, hlayer=lh,
+                                               pin_vlayer=plv, pin_hlayer=plh,
+                                               viamap=viamap, primary_grid=primary_grid,
+                                               xcolor=xcolor, ycolor=ycolor,
+                                               vextension0=e0v, hextension0=e0h)
+        >>> # Create a design
+        >>> dsn = Design(name="mycell", libname="genlib")
+        >>> ##############
+        >>> # Place vias #
+        >>> ##############
+        >>> mn_list = [[0, -2], [1, 0], [2, 5]]
+        >>> via = dsn.via(grid=g, mn=mn_list)
+        >>> # Display generated design.
+        >>> print(dsn)
+        <laygo2.object.database.Design object at 0x0000015A77C6A110>
+        name: mycell, params: None,
+        elements: {
+        'NoName_0': <laygo2.object.physical.Instance object at 0x0000015A77C6AC20>,
+        'NoName_1': <laygo2.object.physical.Instance object at 0x0000015A77C6AD10>,
+        'NoName_2': <laygo2.object.physical.Instance object at 0x0000015A77C6AD40>}
+        libname:genlib
+        rects:{}
+        paths:{}
+        pins:{}
+        texts:{}
+        instances:{
+        'NoName_0': <laygo2.object.physical.Instance object at 0x0000015A77C6AC20>,
+        'NoName_1': <laygo2.object.physical.Instance object at 0x0000015A77C6AD10>,
+        'NoName_2': <laygo2.object.physical.Instance object at 0x0000015A77C6AD40>}
+        virtual instances:{}
+
+        .. image:: ../assets/img/object_grid_RoutingGrid_via.png
+           :height: 250
+
+        See Also
+        --------
+        laygo2.object.grid.RoutingGrid.via
+
+        Notes
+        -----
+        **(Korean)** via 생성함수.
+        파라미터
+            - mn(list(numpy.ndarray)): via를 생성할 mn좌표. 복수 개 입력 가능.
+        반환값
+            - list(physical.PhysicalObject)): 생성된 via object들을 담고 있는 list.
+        """
+        v = grid.via(mn=mn, params=params)
+        self.append(v)
+        return v
+
+    def route_via_track(self, grid, mn, track, via_tag=[None, True]):
+        """
+        Perform routing on the specified track with accessing wires to mn.
+
+        Parameters
+        ----------
+        grid : laygo2.object.grid.RoutingGrid
+            The placement grid where the wire is placed on.
+        mn : list(numpy.ndarray)
+            list containing coordinates of the points being connected through a track
+        track : numpy.ndarray
+            list containing coordinate values and direction of a track.
+            Vertical tracks have [v, None] format, while horizontal tracks have [None, v] format
+            (v is the coordinates of the track).
+        via_tag : list(Boolean), optional.
+            The list containing switches deciding whether to place via at
+            the edges of individual stubs.
+
+        Returns
+        -------
+        list:
+            The list containing the generated routing objects;
+            The last object corresponds to the routing object on the track.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> from laygo2.object.grid import CircularMapping as CM
+        >>> from laygo2.object.grid import CircularMappingArray as CMA
+        >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
+        >>> from laygo2.object.template import NativeInstanceTemplate
+        >>> from laygo2.object.database import Design
+        >>> from laygo2.object.physical import Instance
+        >>> # Routing grid construction (not needed if laygo2_tech is set up).
+        >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
+        >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
+        >>> wv = CM([10])           # vertical (xgrid) width
+        >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
+        >>> ev = CM([10])           # vertical (xgrid) extension
+        >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
+        >>> e0v = CM([15])          # vert. extension (for zero-length wires)
+        >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
+        >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
+        >>> lh = CM([['M2', 'drawing']]*3, dtype=object)
+        >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
+        >>> plh = CM([['M2', 'pin']]*3, dtype=object)
+        >>> xcolor = CM([None], dtype=object)  # not multipatterned
+        >>> ycolor = CM([None]*3, dtype=object)
+        >>> primary_grid = 'horizontal'
+        >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via
+        >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
+        >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
+                                               vwidth=wv, hwidth=wh,
+                                               vextension=ev, hextension=eh,
+                                               vlayer=lv, hlayer=lh,
+                                               pin_vlayer=plv, pin_hlayer=plh,
+                                               viamap=viamap, primary_grid=primary_grid,
+                                               xcolor=xcolor, ycolor=ycolor,
+                                               vextension0=e0v, hextension0=e0h)
+        >>> # Create a design
+        >>> dsn = Design(name="mycell", libname="genlib")
+        >>> # Do routing
+        >>> mn_list = [[0, -2], [1, 0], [2, 5], [3, 4], [4, 5], [5, 5]]
+        >>> track = dsn.route_via_track(grid=g, mn=mn_list, track=[None,0])
+        >>> # Display design
+        >>> print(dsn)
+            <laygo2.object.database.Design object at 0x0000015A77C6BA60>
+            name: mycell, params: None
+            elements: {
+            'NoName_0': <laygo2.object.physical.Rect object at 0x0000015A77C6B790>,
+            'NoName_1': <laygo2.object.physical.Instance object at 0x0000015A77C6B820>,
+            'NoName_2': <laygo2.object.physical.Instance object at 0x0000015A77C6B7C0>,
+            'NoName_3': <laygo2.object.physical.Rect object at 0x0000015A77C6B760>,
+            'NoName_4': <laygo2.object.physical.Instance object at 0x0000015A77C6A2F0>,
+            'NoName_5': <laygo2.object.physical.Rect object at 0x0000015A77C6BA90>}
+            libname:genlib
+            rects:{
+            'NoName_0': <laygo2.object.physical.Rect object at 0x0000015A77C6B790>,
+            'NoName_3': <laygo2.object.physical.Rect object at 0x0000015A77C6B760>,
+            'NoName_5': <laygo2.object.physical.Rect object at 0x0000015A77C6BA90>}
+            paths:{}
+            pins:{}
+            texts:{}
+            instances:{
+            'NoName_1': <laygo2.object.physical.Instance object at 0x0000015A77C6B820>,
+            'NoName_2': <laygo2.object.physical.Instance object at 0x0000015A77C6B7C0>,
+            'NoName_4': <laygo2.object.physical.Instance object at 0x0000015A77C6A2F0>}
+            virtual instances:{}
+        >>> print(track[-1])
+            <laygo2.object.physical.Rect object at 0x0000015A77C6BA90>
+            name: None,
+            class: Rect,
+            xy: [[0, 0], [100, 0]],
+            params: None, , layer: ['M2' 'drawing'], netname: None
+
+        .. image:: ../assets/img/object_grid_RoutingGrid_route_via_track.png
+           :height: 250
+
+        See Also
+        --------
+        laygo2.object.grid.RoutingGrid.route_via_track
+
+        Notes
+        -----
+        **(Korean)** wire 라우팅 함수, track을 기준점으로 routing을 진행한다.
+
+        파라미터
+            - track(numpy.ndarray): track의 좌표값과 방향을 담고 있는 list.
+            수직 트랙일 경우 [v, None], 수평 트랙일 경우 [None, v]의 형태를
+            가지고 있다 (v는 track의 좌표값).
+            - mn(list(numpy.ndarray)): track을 통해 연결될 지점들의 좌표를
+            담고 있는 list.
+        반환값
+            - list: 생성된 routing object들을 담고 있는 list.
+            마지막 object가 track위의 routing object에 해당.
+        """
+        r = grid.route_via_track(mn=mn, track=track, via_tag=via_tag)
+        self.append(r)
+        return r
+
+    def pin(self, name, grid, mn, direction=None, netname=None, params=None):
+        """
+        Create a Pin object over the abstract coordinates specified by mn,
+        on the specified routing grid.
+
+        Parameters
+        ----------
+        name : str
+            Pin name.
+        mn : numpy.ndarray
+            Abstract coordinates for generating Pin.
+        direction : str, optional.
+            Direction.
+        netname : str, optional.
+            Net name of Pin.
+        params : dict, optional
+            Pin attributes.
+
+        Returns
+        -------
+        laygo2.physical.Pin: The generated pin object.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> from laygo2.object.grid import CircularMapping as CM
+        >>> from laygo2.object.grid import CircularMappingArray as CMA
+        >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
+        >>> from laygo2.object.template import NativeInstanceTemplate
+        >>> from laygo2.object.database import Design
+        >>> from laygo2.object.physical import Instance
+        >>> # Routing grid construction (not needed if laygo2_tech is set up).
+        >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
+        >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
+        >>> wv = CM([10])           # vertical (xgrid) width
+        >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
+        >>> ev = CM([10])           # vertical (xgrid) extension
+        >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
+        >>> e0v = CM([15])          # vert. extension (for zero-length wires)
+        >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
+        >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
+        >>> lh = CM([['M2', 'drawing']]*3, dtype=object)
+        >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
+        >>> plh = CM([['M2', 'pin']]*3, dtype=object)
+        >>> xcolor = CM([None], dtype=object)  # Not multipatterned
+        >>> ycolor = CM([None]*3, dtype=object)
+        >>> primary_grid = 'horizontal'
+        >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via
+        >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
+        >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
+                                               vwidth=wv, hwidth=wh,
+                                               vextension=ev, hextension=eh,
+                                               vlayer=lv, hlayer=lh,
+                                               pin_vlayer=plv, pin_hlayer=plh,
+                                               viamap=viamap, primary_grid=primary_grid,
+                                               xcolor=xcolor, ycolor=ycolor,
+                                               vextension0=e0v, hextension0=e0h)
+        >>> # Create a design
+        >>> dsn = Design(name="mycell", libname="genlib")
+        >>> ###############
+        >>> # Place a pin #
+        >>> ###############
+        >>> mn = [[0, 0], [10, 10]]
+        >>> pin = dsn.pin(name="pin", grid=g, mn=mn)
+        >>> print(pin)
+        <laygo2.object.physical.Pin object at 0x0000028DABE3AB90>
+            name: pin,
+            class: Pin,
+            xy: [[0, -10], [500, 350]],
+            params: None, , layer: ['M2' 'pin'], netname: pin, shape: None,
+            master: None
+        >>> print(dsn)
+        <laygo2.object.database.Design object at 0x0000028DABE3A110> name: mycell, params: None
+            elements: {'pin': <laygo2.object.physical.Pin object at
+            0x0000028DABE3AB90>}
+            libname:genlib
+            rects:{}
+            paths:{}
+            pins:{'pin': <laygo2.object.physical.Pin object at 0x0000028DABE3AB90>}
+            texts:{}
+            instances:{}
+            virtual instances:{}
+
+        Notes
+        -----
+        **(Korean)**
+        pin 생성함수.
+
+        파라미터
+            - name(str): Pin 이름.
+            - mn(numpy.ndarray): Pin을 생성할 abstract 좌표.
+            - direction(str): 방향 [optional].
+            - netname(str): Pin의 net이름 [optional].
+            - params(dict): Pin 속성 [optional].
+        반환값
+            - laygo2.physical.Pin: Pin object.
+
+        """
+        p = grid.pin(name=name, mn=mn, direction=direction, netname=netname, params=params)
+        self.append(p)
+        return p
+
+    # I/O functions
+    def export_to_template(self, libname=None, cellname=None):
+        """
+        Generate a NativeInstanceTemplate object corresponding to Design object.
+
+        Parameters
+        ----------
+        libname: str
+            The library name.
+        cellname: str
+            The cell name.
+
+        Returns
+        -------
+        laygo2.NativeInstanceTemplate: The generated template object.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> from laygo2.object.database import Design
+        >>> from laygo2.object.physical import Rect, Pin, Instance, Text
+        >>> # Create a design
+        >>> dsn = Design(name="mycell", libname="genlib")
+        >>> # Create layout objects
+        >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
+        >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
+        >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
+        >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
+        >>> dsn.append(r0)
+        >>> dsn.append(p0)
+        >>> dsn.append(i0)
+        >>> dsn.append(t0)
+        >>> # Export the design to a template.
+        >>> nt0 = dsn.export_to_template()
+        >>> print(nt0)
+        <laygo2.object.template.NativeInstanceTemplate object at XXXX>
+            name: mycell, class: NativeInstanceTemplate,
+            bbox: [[0, 0], [0, 0]],
+            pins: {'P': <laygo2.object.physical.Pin object at YYYY>},
+        >>> # Save the template into a yaml file.
+        >>> laygo2.interface.yaml.export_template(nt0, filename='mytemp.yaml')
+
+        See Also
+        --------
+            laygo2.interface.yaml.export_template : Export a template to
+            a yaml file.
+
+        Notes
+        -----
+        **(Korean)** Design 객체에 해당하는 NativeInstanceTemplate 객체 생성.
+
+        반환값
+            - laygo2.NativeInstanceTemplate
+        """
+        if libname is None:
+            libname = self.libname
+        if cellname is None:
+            cellname = self.cellname
+
+        xy = self.bbox
+        pins = self.pins
+        return laygo2.object.NativeInstanceTemplate(libname=libname, cellname=cellname, bbox=xy, pins=pins)
+
+    def get_matched_rects_by_layer(self, layer):
+        """
+        Return a list containing physical objects matched with the layer input in Design object.
+
+        Parameters
+        ----------
+        layer : list
+            The layer information. Format is [name, purpose].
+
+        Returns
+        -------
+        list: The list containing the matched Physical objects.
+
+        Example
+        -------
+        >>> dsn    = laygo2.object.Design(name='dsn', libname="testlib")
+        >>> rect0  = laygo2.object.Rect(xy=[[0, 0], [100, 100]], layer=[‘M1’, ‘drawing’]……)
+        >>> pin0   = laygo2.object.Pin(xy=[[0, 0], [100, 100]], layer=[‘M1’, ‘pin’]……)
+        >>> inst0  = laygo2.object.Instance(name=‘I0’, xy=[100, 100]……)
+        >>> vinst0_pins[‘in’]  = laygo2.object.physical.Pin(xy=[[0, 0], [10, 10]], layer=[‘M1’,’drawing’]……)
+        >>> vinst0_pins[‘out’] = laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]], layer=[‘M1’, drawing’] ……)
+        >>> vinst0 = laygo2.object.physical.VirtualInstance(name=‘VI0’, ……)
+        >>> text0  = laygo2.object.physical.Text(xy=[[ 0, 0], [100,100 ]], layer=[‘text’, ‘drawing’]……)
+        >>> dsn.append(rect0)
+        >>> dsn.append(pin0)
+        >>> dsn.append(inst0)
+        >>> dsn.append(vinst0)
+        >>> dsn.append(text0)
+        >>> print( dsn.get_matchedrects_by_layer( [“M1”, “drawing”] )
+        [<laygo2.object.physical.Rect object>,
+         <laygo2.object.physical.Pin object>,
+         <laygo2.object.physical.Pin object>,
+         <laygo2.object.physical.Rect object>]
+
+        Notes
+        -----
+        **(Korean)**
+        주어진 layer와 일치되는 Physical object 갖는 list 반환.
+        파라미터
+        layer purpose pair(list): 레이어 정보
+        반환값
+        list: 매치되는 Physical object를 담고 있는 list
+        참조
+        없음
+        """
+        rects = self.rects
+        insts = self.instances
+        vinsts = self.virtual_instances
+
+        obj_check = []
+
+        for rname, rect in rects.items():
+            if np.array_equal(rect.layer, layer):
+                obj_check.append(rect)
+
+        for iname, inst in insts.items():
+            for pname, pin in inst.pins.items():
+                if np.array_equal(pin.layer, layer):
+                    obj_check.append(pin)
+
+        for iname, vinst in vinsts.items():
+            for name, inst in vinst.native_elements.items():
+                if isinstance(inst, laygo2.object.physical.Rect):
+                    if np.array_equal(inst.layer, layer):
+                        _xy = vinst.get_element_position(inst)
+                        ninst = laygo2.object.physical.Rect(
+                            xy=_xy,
+                            layer=layer,
+                            hextension=inst.hextension,
+                            vextension=inst.vextension,
+                            color=inst.color,
+                        )
+                        obj_check.append(ninst)  ## ninst is for sort, inst should be frozen for implement to layout
+        return obj_check
+
+
+if __name__ == "__main__":
+    from laygo2.object.physical import *
+
+    # Test
+    lib = Library(name="mylib")
+    dsn = Design(name="mycell")
+    lib.append(dsn)
+    rect0 = Rect(
+        xy=[[0, 0], [100, 100]],
+        layer=["M1", "drawing"],
+        name="R0",
+        netname="net0",
+        params={"maxI": 0.005},
+    )
+    dsn.append(rect0)
+    rect1 = Rect(
+        xy=[[200, 0], [300, 100]],
+        layer=["M1", "drawing"],
+        netname="net0",
+        params={"maxI": 0.005},
+    )
+    dsn.append(rect1)
+    path0 = Path(
+        xy=[[0, 0], [0, 100]],
+        width=10,
+        extension=5,
+        layer=["M1", "drawing"],
+        netname="net0",
+        params={"maxI": 0.005},
+    )
+    dsn.append(path0)
+    pin0 = Pin(
+        xy=[[0, 0], [100, 100]],
+        layer=["M1", "pin"],
+        netname="n0",
+        master=rect0,
+        params={"direction": "input"},
+    )
+    dsn.append(pin0)
+    # text0 = Text(xy=[0, 0], layer=['text', 'drawing'], text='test', params=None)
+    # dsn.append(text0)
+    inst0_pins = dict()
+    inst0_pins["in"] = Pin(xy=[[0, 0], [10, 10]], layer=["M1", "drawing"], netname="in")
+    inst0_pins["out"] = Pin(xy=[[90, 90], [100, 100]], layer=["M1", "drawing"], netname="out")
+    inst0 = Instance(
+        name="I0",
+        xy=[100, 100],
+        libname="mylib",
+        cellname="mycell",
+        shape=[3, 2],
+        pitch=[100, 100],
+        unit_size=[100, 100],
+        pins=inst0_pins,
+        transform="R0",
+    )
+    dsn.append(inst0)
+    print(lib)
+    print(dsn)
```

### Comparing `laygo2-0.5.6/laygo2/object/__init__.py` & `laygo2-0.5.7/laygo2/object/__init__.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,58 +1,58 @@
-# -*- coding: utf-8 -*-
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-"""
-**laygo2.object** package is a collection of core object classes that 
-are used to represent physical layout structures and design hierarchies. 
-
-The package consists of four modules:
-
-- **laygo2.object.physical**: This module defines classes for physical objects, which composes the actual IC layout.
-
-- **laygo2.object.template**: This module describes classes for templates, which generate various instance objects based on the target technology and design parameters.
-
-- **laygo2.object.grid**: This module describes grid classes, which provide an abstract representation of placement and routing coordinates and parameters.
-
-- **laygo2.object.database**: This module implements classes for design hierarchy management, enabling users to manage and maintain the relationships between design elements.
-
-The following UML diagram of the object package provides a visual representation of the relationships between the four modules and their subclasses.
-
-.. image:: ../assets/img/user_guide_uml.png
-
-Check the following links for the details of the modules and their subclasses.
-"""
-
-#from laygo2.object import *
-from . import *
-from .database import *
-from .physical import *
-# template packages
-from .template import *
-from .template.core import *
-from .template.routing import *
-# grid packages
-from .grid import *
-from .grid.core import *
-from .grid.placement import *
-from .grid.routing import *
+# -*- coding: utf-8 -*-
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+"""
+**laygo2.object** package is a collection of core object classes that 
+are used to represent physical layout structures and design hierarchies. 
+
+The package consists of four modules:
+
+- **laygo2.object.physical**: This module defines classes for physical objects, which composes the actual IC layout.
+
+- **laygo2.object.template**: This module describes classes for templates, which generate various instance objects based on the target technology and design parameters.
+
+- **laygo2.object.grid**: This module describes grid classes, which provide an abstract representation of placement and routing coordinates and parameters.
+
+- **laygo2.object.database**: This module implements classes for design hierarchy management, enabling users to manage and maintain the relationships between design elements.
+
+The following UML diagram of the object package provides a visual representation of the relationships between the four modules and their subclasses.
+
+.. image:: ../assets/img/user_guide_uml.png
+
+Check the following links for the details of the modules and their subclasses.
+"""
+
+#from laygo2.object import *
+from . import *
+from .database import *
+from .physical import *
+# template packages
+from .template import *
+from .template.core import *
+from .template.routing import *
+# grid packages
+from .grid import *
+from .grid.core import *
+from .grid.placement import *
+from .grid.routing import *
```

### Comparing `laygo2-0.5.6/laygo2/object/template/tile.py` & `laygo2-0.5.7/laygo2/object/template/tile.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,885 +1,885 @@
-####################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-from typing import Set, Tuple, List, Dict
-from abc import *
-
-from laygo2.object.template import UserDefinedTemplate
-import laygo2.object.database
-
-import numpy as np
-
-
-class TileTemplate(UserDefinedTemplate, metaclass = ABCMeta):
-    """ 
-    The class for basic parametric cell. 
-    The sub-elements will be placed by placement_pattern.
-
-    generation flow:
-        1. insert parameters by __init__()
-        2. use self.generate_func, self.generete_pin, self.bbox for creating UserDefindTemplate
-    """
-
-    glib         = None  
-    """The main grid libarary for routing."""
-    
-    tlib         = None  
-    """The main template library for calling nativeTemplates."""
-    
-    placement_map: Dict[str, str]  = None  
-    """The mapping of the name of sub-elements and the name of native template.
-       the name of sub_elements = {"core", "bndr", "bndl", "gbndr", "gbndl"}.
-    """
-
-    placement_pattern: List[str] = None
-    """The sequence of sub-elements placement."""
-      
-    transform_pattern: List[str] = None            
-    """The sequencye of sub-elements transform: {"R0", "MX", "MY", R180"}."""
-    
-    routing_map: Dict[str, int]  = None  
-    """The mapping of Mosfet terminal and r2 vertical track and other options for tracks.
-       Mosfet terminal = {"G", "D", "S"},
-       
-    """
-    
-    routing_gname: str         = None  
-    """The name of main routing grid."""
-
-    nf_core: int               = None  
-    """The core template number of finger."""
-
-    libname:str                = None 
-    """The name of Native template library."""
-
-    def __init__(self, tlib, glib, routing_gname: str, routing_map: dict, placement_map: dict, placement_pattern: list, transform_pattern: list, name: str):
-        
-        self.tlib              = tlib
-        self.glib              = glib
-        self.routing_gname     = routing_gname     # mosfet grid name
-        self.routing_map       = routing_map       # gate, drain, source trakcs
-        self.placement_map     = placement_map     # native template name dictionary
-        self.placement_pattern = placement_pattern # placement pattern
-        self.transform_pattern = transform_pattern # transform pattern
-        
-        self.libname = tlib.libname
-        self.nf_core   = 2
-        
-        super().__init__(name = name, bbox_func = self.bbox_func, pins_func = self.pins_func, generate_func = self.generate_func)
-
-    def _route_pattern_via_track(self, grid, mn_list, n_track, name_via ) -> list:
-        """ Route with multi instance via
-
-        Parameters
-        ----------
-        mn_list: np.array 
-            sorted and unique array
-        n_track: int
-            track number of n
-        name_via: str
-            the name of via
-        """
-        len_via = mn_list.shape[0]
-        m_left  = mn_list[0][0] # left-most m
-        tvia    = grid.viamap[m_left, n_track]
-            
-        if len_via == 1:
-            via     = tvia.generate(name = name_via, shape = ( len_via, 1), pitch = [1, 1] )
-            track   = None
-        else:
-            m_left2   = mn_list[1][0]
-            pitch_m   = m_left2 - m_left
-            pitch_x   = grid.x(pitch_m)
-
-            via       = tvia.generate(name = name_via, shape = ( len_via, 1), pitch = [pitch_x, 0])
-            track     = grid.route( mn = ( [mn_list[0][0], n_track ] , [mn_list[-1][0], n_track ]   ) )
-            
-        via.xy = grid.xy( [m_left, n_track ])
-
-        return via, track
-
-    def _update_params(self, params_in) -> dict:
-        """ Update sub-elements parameters
-        """
-
-        params = {}
-
-        if "switch" in params_in:
-            nfs               = dict(core = "nf", dmyl = "nfdmyl", dmyr = "nfdmyr")
-            flags             = params_in["switch"]
-            sizes             = params_in["size"]
-            placement_pattern = self.placement_pattern
-
-            for i in len(flags):
-                tname = placement_pattern[i]
-                size  = sizes[i]
-                flag  = flags[i] 
-                if flag == True:
-                    params_in[tname] = True
-                    if tname in nfs:
-                        params_in[ nfs[tname] ] = size   
-                else:
-                    params_in[tname] = False
-
-        params["nf"]        = params_in.get("nf"     , self.nf_core )
-        params["nfdmyl"]    = params_in.get("nfdmyl" , False )
-        params["nfdmyr"]    = params_in.get("nfdmyr" , False )
-        
-        params["dmyl"] = True
-        params["dmyr"] = True
-
-        if params["nfdmyl"] == False:
-            params["dmyl"]      = False
-
-        if params["nfdmyr"] == False:
-            params["dmyr"]      = False
-
-        params["core"]      = params_in["nf"]
-
-        params["bndl" ]     = params_in.get("bndl"   , True )
-        params["bndr" ]     = params_in.get("bndr"   , True )
-        
-        params["gbndl" ]     = params_in.get("gbndl" , False)
-        params["gbndr" ]     = params_in.get("gbndr" , False)
-        
-        params = self._update_params_sub(params_in, params)
-        return params
-    
-    @abstractmethod
-    def _update_params_sub(self, params_in, params):
-        """ update custom flags """
-        pass
-
-    @abstractmethod
-    def _internal_route(self, params):
-        """ internal routing method """
-        pass
-
-    @abstractmethod
-    def pins_func(self, params):
-        """ pin generation method """
-        pass
-
-    def _generate_subinstance(self, params) -> dict:
-        """The method of generating native_elements.
-        """
-
-        tlib            = self.tlib
-        placement_map   = self.placement_map
-        params    = self._update_params(params)
-        nf_core   = self.nf_core
-        tfs       = self.transform_pattern
-        
-        iparams   = dict()  # mapping sub-elements and generated instance.
-        nf        = int( params["nf"] / nf_core) 
-        
-        if params["nfdmyl"] == False:
-            nfdmyl = 1
-        else:
-            nfdmyl = params["nfdmyl"]
-
-        if params["nfdmyr"] == False:
-            nfdmyr = 1
-        else:
-            nfdmyr = params["nfdmyr"]
-
-        tf_set = ("R0", "MY")
-
-        if nf_core == 1: # not used, source and drain swap continously
-            icore_sub = [0]* nf
-            nelements_core = {}
-            pins_core      = {}
-            for i in range( nf):
-                tf_core   = tf_set[ i%2]
-                icore_sub = tlib[ placement_map["core"] ].generate( name=f'IM{i}'   , shape = [1, 1], transform = tf_core )
-                nelements_core[f"IM{i}"] = icore_sub
-                pins_core[f"D{i}"]   = icore_sub.pins["D"]
-                pins_core[f"S{i}"]   = icore_sub.pins["S"]
-                pins_core[f"G{i}"]   = icore_sub.pins["G"]
-            icore  = laygo2.object.physical.VirtualInstance( xy = [0,0], libname = "dummy", cellname="dummy",
-                                                             pins = pins_core,
-                                                             name = "IM0", native_elements = nelements_core, transform = "R0"
-                                                            )
-        else:
-            icore  = tlib[ placement_map["core"] ].generate( name='ICORE0', shape = [nf, 1] , transform = tfs["core"] )
-        
-        ibndl  = tlib[ placement_map["bndl"] ].generate( name='IBNDL0', shape = [1, 1] , transform = tfs["bndl"] )
-        ibndr  = tlib[ placement_map["bndr"] ].generate( name='IBNDR0', shape = [1, 1] , transform = tfs["bndr"] )
-        
-        idmyl  = tlib[ placement_map["dmyl"] ].generate( name='IDMYL0',  shape = [max( int(0.5 * nfdmyl ),1)  , 1], transform = tfs["dmyl"] )
-        idmyr  = tlib[ placement_map["dmyr"] ].generate( name='IDMYR0',  shape = [max( int(0.5 * nfdmyr) ,1)  , 1], transform = tfs["dmyr"] )
-
-        igbndl = tlib[ placement_map["gbndl"] ].generate( name='IGDMYL0', shape = [1, 1], transform = tfs["gbndl"] )
-        igbndr = tlib[ placement_map["gbndr"] ].generate( name='IGDMYR0', shape = [1, 1], transform = tfs["gbndr"] )
-
-        iparams["gbndl"] = igbndl
-        iparams["gbndr"] = igbndr
-        
-        iparams["dmyl"]  = idmyl
-        iparams["dmyr"]  = idmyr
-
-        iparams["bndl"]  = ibndl
-        iparams["bndr"]  = ibndr
-        
-        iparams["core"]  = icore
-
-        return iparams
-
-    def _device_place(self, params) -> dict:
-        """ The method of placing native elements.
-            It will modify instances.xy
-        """
-
-        params        = self._update_params( params )
-        iparams       = self._generate_subinstance( params )
-        
-        placement_pattern = self.placement_pattern
-        tfs               = self.transform_pattern
-
-        # placement
-        cursor = [0, 0]
-        for i, t_inst in enumerate( placement_pattern ):
-            if params[t_inst] != False:
-                inst     = iparams[t_inst]
-            
-                if tfs[t_inst] == "MY":
-                    xy_bl    = inst.bbox[0]  # this is on the left side
-                    xy_tr    = inst.bbox[1]
-                    inst.xy  = np.asarray( cursor ) + [ -xy_bl[0], 0 ]
-                else:
-                    inst.xy  = cursor
-            
-                xy_bl    = inst.bbox[0]
-                xy_tr    = inst.bbox[1]
-                cursor   = [ xy_tr[0], xy_bl[1] ] 
-            else:
-                iparams.pop(t_inst) # remove from dictionary
-        
-        return iparams
-
-   
-    def bbox_func(self, params) -> np.ndarray:
-        params  = self._update_params(params)
-        
-        iparams = self._device_place( params )
-
-        xy_all = np.asarray([0,0])
-        for t_inst, inst in iparams.items():
-            xy = inst.bbox
-            xy_bl     = xy[0]
-            xy_tr     = xy[1]
-
-            xy_all[0] = max( xy_all[0], xy_tr[0])
-            xy_all[1] = max( xy_all[1], xy_tr[1])
-        
-        return xy_all
-    
-    def generate_func(self, name = None, shape = None, pitch = None, transform = 'R0', params = None):
-        """ generate Virtualinstances and with routing
-        """
-
-        nelements = dict()
-        params    = self._update_params( params )
-        placement_map   = self.placement_map
-        libname   = self.libname
-        iparams   = self._device_place( params )
-        nelements.update( iparams )            
-        
-        routes    = self._internal_route( params )
-        nelements.update( routes )            
-
-        pins      = self.pins_func(params)
-        nelements.update(pins)
-
-        bbox      = self.bbox_func(params)
-
-        # Generate and return the final instance
-        inst = laygo2.object.VirtualInstance( name = name, xy = np.array([0, 0]) , libname = libname, cellname = f'myvcell_{name}' ,
-                                              native_elements = nelements, shape = shape, pitch = pitch,
-                                              transform       = transform, unit_size = bbox, pins = pins)
-        
-        return inst
-
-class TileMOSTemplate(TileTemplate):
-
-    def _update_params_sub(self, params_in, params):
-        # about routing
-        params["sdswap"]    = params_in.get("sdswap"   , False)  
-        params["trackswap"] = params_in.get("trackswap", False)  
-        params["tie"      ] = params_in.get("tie"      , False)  
-        
-        # new function
-        params["ntrackswap"] = params_in.get("ntrackswap", False)  
-        params["sdswap"]     = params_in.get("sdswap"    , False)  
-        params["rail"     ]  = params_in.get("rail", True )  
-        
-        return params
-
-    def pins_func(self, params):
-        """The method of creating pin."""
-        params  = self._update_params(params)
-        pins    = dict()
-        
-        # generate a virtual routing structure for reference
-        route_obj = self._internal_route( params )
-
-        if 'RG0' in route_obj:  # gate
-            g_obj = route_obj['RG0']
-            pins['G'] = laygo2.object.Pin(xy=g_obj.xy, layer=g_obj.layer, netname='G')
-        if 'RD0' in route_obj:  # drain
-            d_obj = route_obj['RD0']
-            pins['D'] = laygo2.object.Pin(xy=d_obj.xy, layer=d_obj.layer, netname='D')
-        if 'RS0' in route_obj:  # source
-            s_obj = route_obj['RS0']
-            pins['S'] = laygo2.object.Pin(xy=s_obj.xy, layer=s_obj.layer, netname='S')
-        if 'RRAIL0' in route_obj:  # rail
-            r_obj = route_obj['RRAIL0']
-            pins['RAIL'] = laygo2.object.Pin(xy=r_obj.xy, layer=r_obj.layer, netname='RAIL')
-        return pins
-
-    def _internal_route(self, params) -> dict:
-        """The method of routing mosfet"""
-
-        params            = self._update_params(params)
-        glib              = self.glib
-        routing_gname     = self.routing_gname
-        routing_map       = self.routing_map
-        nf_core           = self.nf_core
-        iparams           = self._device_place(params)
-        placement_pattern = self.placement_pattern
-
-        r12 = glib[routing_gname]
-        n_g = routing_map["G"]
-        n_d = routing_map["D"]
-        n_s = routing_map["S"]
-        n_r = routing_map.get( "RAIL", 0 )
-
-        nelements = {}
-        nelements.update(iparams)
-        
-        icore   = iparams["core"]
-        nf      = params["nf"]
-
-        G, S, D = "G", "S", "D"
-        
-        if params["trackswap"]: #backward compatable
-            n_d, n_s = n_s, n_d
-            S, D     = D, S
-        
-        if params["ntrackswap"]: 
-            n_d, n_s = n_s, n_d
-        
-        if params["sdswap"]: 
-            S, D     = D, S
-
-        # Extrack mn from core mosfet
-        mn_list_g = [] 
-        mn_list_d = [] 
-        mn_list_s = []
-        i_iter = int( nf / nf_core) 
-
-        for i in range( i_iter ):
-            if i_iter == 1:
-                icore_sub =  icore
-            else:
-                icore_sub =  icore[i][0] # it is 2-dimensional array
-                
-            for pin_name in icore_sub.pins.keys():
-
-                if G in pin_name:
-                    mn_list_g.append( r12.mn.center( icore_sub.pins[pin_name] ) )
-                elif D in pin_name:
-                    mn_list_d.append( r12.mn.center( icore_sub.pins[pin_name] ) )
-                elif S in pin_name:
-                    mn_list_s.append( r12.mn.center( icore_sub.pins[pin_name] ) )
-        
-
-        mn_list_g = np.asarray( mn_list_g)
-        mn_list_g = mn_list_g[  mn_list_g[:,0].argsort()] # sort list by bottom_left
-        mn_list_g = np.unique(  mn_list_g, axis = 0 )
-
-        mn_list_d = np.asarray( mn_list_d)
-        mn_list_d = mn_list_d[  mn_list_d[:,0].argsort()] 
-        mn_list_d = np.unique(  mn_list_d, axis = 0 )
-        
-        mn_list_s = np.asarray( mn_list_s)
-        mn_list_s = mn_list_s[  mn_list_s[:,0].argsort()] 
-        mn_list_s = np.unique(  mn_list_s, axis = 0 )
-
-        # Create via and track
-        r_g = dict( via = 0 , track = 0) 
-        r_d = dict( via = 0 , track = 0) 
-        r_s = dict( via = 0 , track = 0) 
-
-        for mn_list, n_track, terminal, r_dict in zip( (mn_list_g, mn_list_d, mn_list_s), (n_g, n_d, n_s), (G, D, S), (r_g, r_d, r_s) ):
-            
-            via, track = self._route_pattern_via_track( r12, mn_list, n_track, terminal)
-            r_dict["via"]   = via
-            r_dict["track"] = track 
-
-        # Modify track
-        if r_g["track"] == None: 
-            mn_sub       = mn_list_g[0]
-            r_g["track"] = r12.route( mn = [ mn_sub + [0,0], mn_sub + [0,0] ], via_tag =[None, None] )  # new track
-            
-            x_extl        = routing_map["G_extension0_x"][0]
-            x_extr        = routing_map["G_extension0_x"][1]
-            if x_extl != None:
-                xy_sub     = r12.xy(mn_sub)
-                r_g["track"].xy = [ xy_sub + [ x_extl , 0], xy_sub + [x_extr, 0] ] # new track location
-
-        if r_d["track"] == None: 
-            mn_sub    = mn_list_d[0]
-            mn_sub[1] = n_d
-            
-            m_ext = routing_map["D_extension0_m"]
-            m_extl = 0
-            m_extr = 0
-            if m_ext[0] != None:
-                m_extl = m_ext[0]
-                m_extr = m_ext[1]
-
-            r_d["track"]   = r12.route( mn = [ mn_sub + [m_extl,0], mn_sub + [m_extr,0] ], via_tag =[None, None] )
-
-        if r_s["track"] == None: 
-            mn_sub    = mn_list_s[0]
-            mn_sub[1] = n_s
-            
-            m_ext = routing_map["S_extension0_m"]
-            m_extl = 0
-            m_extr = 0
-            if m_ext[0] != None:
-                m_extl = m_ext[0]
-                m_extr = m_ext[1]
-            r_s["track"]   = r12.route( mn = [ mn_sub + [m_extl,0], mn_sub + [m_extr,0] ], via_tag =[None, None] )
-
-        nelements["VIA_G"] = r_g["via"]
-        nelements["VIA_D"] = r_d["via"]
-        nelements["VIA_S"] = r_s["via"]
-
-        nelements["RG0"] = r_g["track"]
-        nelements["RD0"] = r_d["track"]
-        nelements["RS0"] = r_s["track"]
-
-        # Rail routing
-        if params["rail"]:
-
-            tinst_l = 0 # left most sub-element name
-            tinst_r = 0 # right most sub-element name
-
-            for i, tinst in enumerate(placement_pattern):
-                name = placement_pattern[i]
-                if name in iparams:
-                    if name != "gbndl":
-                        tinst_l = name
-                        break   
-            
-            for i, tinst in enumerate(placement_pattern):
-                name = placement_pattern[-1 - i]
-                if name in iparams:
-                    if name != "gbndr":
-                        tinst_r = name
-                        break   
-                    
-            inst_l = iparams[tinst_l]
-            inst_r = iparams[tinst_r]
-
-            xy_bl = inst_l.bbox[0]
-            xy_tr = inst_r.bbox[1]
-            xy_br = [xy_tr[0], xy_bl[1] ]
-
-            mn_bl = r12.xy >= xy_bl 
-            mn_br = r12.xy <= xy_br 
-
-            r_track = r12.route( mn = [mn_bl, mn_br], via_tag = [None, None] )
-            nelements["RRAIL0"] = r_track
-
-        # TIE
-        if params["tie"] != False:
-
-            if params["tie"] == "S" or params["tie"] == True:
-                del nelements["RS0"]
-                del nelements["VIA_S"]
-                
-                via, track = self._route_pattern_via_track(r12, mn_list_s, n_r, "VIA_TIE")
-                r_t        = r12.route_via_track( mn = mn_list_s, via_tag = [ False, False], track = [None, n_r])
-            
-            elif params["tie"] == "D":
-                del nelements["RD0"]
-                del nelements["VIA_D"]
-                
-                via, track = self._route_pattern_via_track(r12, mn_list_d, n_r, "VIA_TIE")
-                r_t        = r12.route_via_track( mn = mn_list_d, via_tag = [ False, False], track = [None, n_r])
-
-            else:
-                raise Exception(" Value error for tie")
-            
-            nelements["VIA_TIE"] = via
-            
-            if r_t[-1] == None:
-                del r_t[1]
-            for i, r in enumerate(r_t): # source or drain to rail
-                nelements[f"RECT_TIE{i}"] = r
-
-        # dmy routing
-
-        names_dmy = ["dmyl", "dmyr"]
-        for i, tdmy_nf in enumerate( ( "nfdmyl", "nfdmyr" )):
-            if params[tdmy_nf] == 0:
-                continue
-            name_dmy  = names_dmy[i]
-            icore     = iparams[ name_dmy ]
-            mn_list_g = [] 
-            mn_list_d = [] 
-            mn_list_s = []
-            i_iter = int( params[tdmy_nf] / nf_core) 
-
-            for i in range( i_iter ):
-                if i_iter == 1:
-                    icore_sub =  icore
-                else:
-                    icore_sub =  icore[i][0] # it is 2-dimensional array
-                
-                for pin_name in icore_sub.pins.keys():
-
-                    if G in pin_name:
-                        mn_list_g.append( r12.mn.center( icore_sub.pins[pin_name] ) )
-                    elif D in pin_name:
-                        mn_list_d.append( r12.mn.center( icore_sub.pins[pin_name] ) )
-                    elif S in pin_name:
-                        mn_list_s.append( r12.mn.center( icore_sub.pins[pin_name] ) )
-
-                mn_list_a = mn_list_g + mn_list_s + mn_list_d
-                mn_list_a = np.asarray( mn_list_a)
-                mn_list_a = mn_list_a[  mn_list_a[:,0].argsort()] # sort list by bottom_left
-                mn_list_a = np.unique(  mn_list_a, axis = 0 )
-
-                r_t        = r12.route_via_track( mn = mn_list_a, via_tag = [ False, False], track = [None, n_r])
-                
-                mn_list_a[:,1] = n_r
-                mn_list_a = np.unique(  mn_list_a, axis = 0 )
-                via, track = self._route_pattern_via_track(r12, mn_list_a, n_r, f"VIA_DUMMY_{icore.name}")
-                
-                nelements[f"VIA_TIE_{name_dmy}"] = via
-                
-                if r_t[-1] == None:
-                    del r_t[1]
-                for i, r in enumerate(r_t): # source or drain to rail
-                    nelements[f"RECT_DMY_TIE_{name_dmy}_{i}"] = r
-
-        return nelements
-  
-
-class TileTapTemplate(TileTemplate):
-    """The class of TileTap."""
-
-    def _update_params_sub(self, params_in, params):
-        # about routing
-        params["sdswap"]    = params_in.get("sdswap"   , False)  
-        params["trackswap"] = params_in.get("trackswap", False)  
-        params["tie"      ] = params_in.get("tie"      , False)  
-        
-        # new function
-        params["ntrackswap"] = params_in.get("ntrackswap", False)  
-        params["sdswap"]     = params_in.get("sdswap"    , False)  
-        params["rail"     ]  = params_in.get("rail", True )  
-        
-        return params
-
-    def pins_func(self, params):
-        """The method of creating pin."""
-        params  = self._update_params(params)
-        pins    = dict()
-        
-        # generate a virtual routing structure for reference
-        route_obj = self._internal_route( params )
-
-        if 'RG0' in route_obj:  # gate
-            g_obj = route_obj['RG0']
-            pins['G'] = laygo2.object.Pin(xy=g_obj.xy, layer=g_obj.layer, netname='G')
-        if 'RD0' in route_obj:  # drain
-            d_obj = route_obj['RD0']
-            pins['D'] = laygo2.object.Pin(xy=d_obj.xy, layer=d_obj.layer, netname='D')
-        if 'RS0' in route_obj:  # source
-            s_obj = route_obj['RS0']
-            pins['S'] = laygo2.object.Pin(xy=s_obj.xy, layer=s_obj.layer, netname='S')
-        if 'RRAIL0' in route_obj:  # rail
-            r_obj = route_obj['RRAIL0']
-            pins['RAIL'] = laygo2.object.Pin(xy=r_obj.xy, layer=r_obj.layer, netname='RAIL')
-        return pins
-
-
-    def _internal_route(self, params):
-        params    = self._update_params(params)
-        glib      = self.glib
-        routing_gname = self.routing_gname
-        routing_map = self.routing_map
-        nf_core   = self.nf_core
-        iparams   = self._device_place(params)
-        placement_pattern = self.placement_pattern
-
-        r12 = glib[routing_gname]
-        n_g = routing_map["G"]
-        n_d = routing_map["D"]
-        n_s = routing_map["S"]
-        n_r = routing_map.get( "RAIL", 0 )
-
-        nelements = {}
-        nelements.update(iparams)
-        
-        icore   = iparams["core"]
-        nf      = params["nf"]
-
-        G, S, D = "G", "S", "D"
-        
-        if params["trackswap"]: #backward compatable
-            n_d, n_s = n_s, n_d
-            S, D     = D, S
-        
-        if params["ntrackswap"]: 
-            n_d, n_s = n_s, n_d
-        
-        if params["sdswap"]: 
-            S, D     = D, S
-
-        mn_list_s = [] # TAP0
-        mn_list_d = [] # TAP1
-
-        i_iter = int( nf / nf_core) 
-        for i in range( i_iter ):
-            if i_iter == 1:
-                icore_sub =  icore
-            else:
-                icore_sub =  icore[i][0] # it is 2-dimensional array
-                
-            for pin_name in icore_sub.pins.keys():
-                if "TAP0" in pin_name:
-                    mn_list_s.append( r12.mn.center( icore_sub.pins[pin_name] ) )
-                elif "TAP1" in pin_name:
-                    mn_list_d.append( r12.mn.center( icore_sub.pins[pin_name] ) )
-        
-        mn_list_s = np.asarray( mn_list_s)
-        mn_list_s = mn_list_s[  mn_list_s[:,0].argsort()] 
-        mn_list_s = np.unique(  mn_list_s, axis = 0 )
-        
-        mn_list_d = np.asarray( mn_list_d)
-        mn_list_d = mn_list_s[  mn_list_d[:,0].argsort()] 
-        mn_list_d = np.unique(  mn_list_d, axis = 0 )
-
-        r_s = dict( via = 0 , track = 0) 
-        r_d = dict( via = 0 , track = 0) 
-
-        for mn_list, n_track, terminal, r_dict in zip( (mn_list_s,mn_list_d), (n_s, n_d), ( D, S), (r_d, r_s) ):
-            via, track = self._route_pattern_via_track( r12, mn_list, n_track, terminal)
-            r_dict["via"]   = via
-            r_dict["track"] = track 
-
-        # Modify track
-        if r_d["track"] == None: 
-            mn_sub    = mn_list_d[0]
-            mn_sub[1] = n_d
-            
-            m_ext = routing_map["D_extension0_m"]
-            m_extl = 0
-            m_extr = 0
-            if m_ext[0] != None:
-                m_extl = m_ext[0]
-                m_extr = m_ext[1]
-
-            r_d["track"]   = r12.route( mn = [ mn_sub + [m_extl,0], mn_sub + [m_extr,0] ], via_tag =[None, None] )
-
-        if r_s["track"] == None: 
-            mn_sub    = mn_list_s[0]
-            mn_sub[1] = n_s
-            
-            m_ext = routing_map["S_extension0_m"]
-            m_extl = 0
-            m_extr = 0
-            if m_ext[0] != None:
-                m_extl = m_ext[0]
-                m_extr = m_ext[1]
-            r_s["track"]   = r12.route( mn = [ mn_sub + [m_extl,0], mn_sub + [m_extr,0] ], via_tag =[None, None] )
-
-        nelements["VIA_D"] = r_d["via"]
-        nelements["VIA_S"] = r_s["via"]
-
-        nelements["RD0"] = r_d["track"]
-        nelements["RS0"] = r_s["track"]
-
-        # Rail routing
-        if params["rail"]:
-
-            tinst_l = 0 # left most sub-element name
-            tinst_r = 0 # right most sub-element name
-
-            for i, tinst in enumerate(placement_pattern):
-                name = placement_pattern[i]
-                if name in iparams:
-                    if name != "gbndl":
-                        tinst_l = name
-                        break   
-            
-            for i, tinst in enumerate(placement_pattern):
-                name = placement_pattern[-1 - i]
-                if name in iparams:
-                    if name != "gbndr":
-                        tinst_r = name
-                        break   
-                    
-            inst_l = iparams[tinst_l]
-            inst_r = iparams[tinst_r]
-
-            xy_bl = inst_l.bbox[0]
-            xy_tr = inst_r.bbox[1]
-            xy_br = [xy_tr[0], xy_bl[1] ]
-
-            mn_bl = r12.xy >= xy_bl 
-            mn_br = r12.xy <= xy_br 
-
-            r_track = r12.route( mn = [mn_bl, mn_br], via_tag = [None, None] )
-            nelements["RRAIL0"] = r_track
-            '''
-            xy    = icore.bbox
-            xy_bl = xy[0]
-            xy_tr = xy[1]
-            xy_br = [xy_tr[0], xy_bl[1] ]
-            mn_bl = r12.xy >= xy_bl 
-            mn_br = r12.xy <= xy_br 
-
-            r_track = r12.route( mn = [mn_bl, mn_br], via_tag = [None, None] )
-            nelements["RRAIL0"] = r_track
-            '''
-
-        # TIE
-        if params["tie"] != False:
-
-            if params["tie"] == "TAP0" or params["tie"] == True:
-                del nelements["RS0"]
-                del nelements["VIA_S"]
-                
-                via, track = self._route_pattern_via_track(r12, mn_list_s, n_r, "VIA_TIE")
-                r_t        = r12.route_via_track( mn = mn_list_s, via_tag = [ False, False], track = [None, n_r])
-            
-            elif params["tie"] == "TAP1":
-                del nelements["RD0"]
-                del nelements["VIA_D"]
-                
-                via, track = self._route_pattern_via_track(r12, mn_list_d, n_r, "VIA_TIE")
-                r_t        = r12.route_via_track( mn = mn_list_d, via_tag = [ False, False], track = [None, n_r])
-
-            else:
-                raise Exception(" Value error for tie")
-            
-            nelements["VIA_TIE"] = via
-
-            if r_t[-1] == None:
-                del r_t[1]
-            for i, r in enumerate(r_t):
-                nelements[f"RECT_TIE{i}"] = r
-
-        return nelements
-
-class TileSpaceTemplate(TileTemplate):
-    """The class for tile-based spacer template."""
-
-    def _update_params_sub(self, params_in, params):
-        params["rail"     ]  = params_in.get("rail", True )  
-        return params
-
-    def pins_func(self, params):
-        """The method of creating pin."""
-        params  = self._update_params(params)
-        pins    = dict()
-        
-        # generate a virtual routing structure for reference
-        route_obj = self._internal_route( params )
-
-        if 'RRAIL0' in route_obj:  # rail
-            r_obj = route_obj['RRAIL0']
-            pins['RAIL'] = laygo2.object.Pin(xy=r_obj.xy, layer=r_obj.layer, netname='RAIL')
-        return pins
-
-
-    def _internal_route(self, params):
-        params    = self._update_params(params)
-        glib      = self.glib
-        routing_gname = self.routing_gname
-        routing_map = self.routing_map
-        nf_core   = self.nf_core
-        iparams   = self._device_place(params)
-        placement_pattern = self.placement_pattern
-
-        r12 = glib[routing_gname]
-        n_r = routing_map.get( "RAIL", 0 )
-
-        nelements = {}
-        nelements.update(iparams)
-        
-        icore   = iparams["core"]
-        nf      = params["nf"]
-
-        # Rail routing
-        if params["rail"]:
-
-            tinst_l = 0 # left most sub-element name
-            tinst_r = 0 # right most sub-element name
-
-            for i, tinst in enumerate(placement_pattern):
-                name = placement_pattern[i]
-                if name in iparams:
-                    if name != "gbndl":
-                        tinst_l = name
-                        break   
-            
-            for i, tinst in enumerate(placement_pattern):
-                name = placement_pattern[-1 - i]
-                if name in iparams:
-                    if name != "gbndr":
-                        tinst_r = name
-                        break   
-                    
-            inst_l = iparams[tinst_l]
-            inst_r = iparams[tinst_r]
-
-            xy_bl = inst_l.bbox[0]
-            xy_tr = inst_r.bbox[1]
-            xy_br = [xy_tr[0], xy_bl[1] ]
-
-            mn_bl = r12.xy >= xy_bl 
-            mn_br = r12.xy <= xy_br 
-
-            r_track = r12.route( mn = [mn_bl, mn_br], via_tag = [None, None] )
-            nelements["RRAIL0"] = r_track
-            '''
-            xy    = icore.bbox
-            xy_bl = xy[0]
-            xy_tr = xy[1]
-            xy_br = [xy_tr[0], xy_bl[1] ]
-            mn_bl = r12.xy >= xy_bl 
-            mn_br = r12.xy <= xy_br 
-
-            r_track = r12.route( mn = [mn_bl, mn_br], via_tag = [None, None] )
-            nelements["RRAIL0"] = r_track
-            '''
-
-        return nelements
+####################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+from typing import Set, Tuple, List, Dict
+from abc import *
+
+from laygo2.object.template import UserDefinedTemplate
+import laygo2.object.database
+
+import numpy as np
+
+
+class TileTemplate(UserDefinedTemplate, metaclass = ABCMeta):
+    """ 
+    The class for basic parametric cell. 
+    The sub-elements will be placed by placement_pattern.
+
+    generation flow:
+        1. insert parameters by __init__()
+        2. use self.generate_func, self.generete_pin, self.bbox for creating UserDefindTemplate
+    """
+
+    glib         = None  
+    """The main grid libarary for routing."""
+    
+    tlib         = None  
+    """The main template library for calling nativeTemplates."""
+    
+    placement_map: Dict[str, str]  = None  
+    """The mapping of the name of sub-elements and the name of native template.
+       the name of sub_elements = {"core", "bndr", "bndl", "gbndr", "gbndl"}.
+    """
+
+    placement_pattern: List[str] = None
+    """The sequence of sub-elements placement."""
+      
+    transform_pattern: List[str] = None            
+    """The sequencye of sub-elements transform: {"R0", "MX", "MY", R180"}."""
+    
+    routing_map: Dict[str, int]  = None  
+    """The mapping of Mosfet terminal and r2 vertical track and other options for tracks.
+       Mosfet terminal = {"G", "D", "S"},
+       
+    """
+    
+    routing_gname: str         = None  
+    """The name of main routing grid."""
+
+    nf_core: int               = None  
+    """The core template number of finger."""
+
+    libname:str                = None 
+    """The name of Native template library."""
+
+    def __init__(self, tlib, glib, routing_gname: str, routing_map: dict, placement_map: dict, placement_pattern: list, transform_pattern: list, name: str):
+        
+        self.tlib              = tlib
+        self.glib              = glib
+        self.routing_gname     = routing_gname     # mosfet grid name
+        self.routing_map       = routing_map       # gate, drain, source trakcs
+        self.placement_map     = placement_map     # native template name dictionary
+        self.placement_pattern = placement_pattern # placement pattern
+        self.transform_pattern = transform_pattern # transform pattern
+        
+        self.libname = tlib.libname
+        self.nf_core   = 2
+        
+        super().__init__(name = name, bbox_func = self.bbox_func, pins_func = self.pins_func, generate_func = self.generate_func)
+
+    def _route_pattern_via_track(self, grid, mn_list, n_track, name_via ) -> list:
+        """ Route with multi instance via
+
+        Parameters
+        ----------
+        mn_list: np.array 
+            sorted and unique array
+        n_track: int
+            track number of n
+        name_via: str
+            the name of via
+        """
+        len_via = mn_list.shape[0]
+        m_left  = mn_list[0][0] # left-most m
+        tvia    = grid.viamap[m_left, n_track]
+            
+        if len_via == 1:
+            via     = tvia.generate(name = name_via, shape = ( len_via, 1), pitch = [1, 1] )
+            track   = None
+        else:
+            m_left2   = mn_list[1][0]
+            pitch_m   = m_left2 - m_left
+            pitch_x   = grid.x(pitch_m)
+
+            via       = tvia.generate(name = name_via, shape = ( len_via, 1), pitch = [pitch_x, 0])
+            track     = grid.route( mn = ( [mn_list[0][0], n_track ] , [mn_list[-1][0], n_track ]   ) )
+            
+        via.xy = grid.xy( [m_left, n_track ])
+
+        return via, track
+
+    def _update_params(self, params_in) -> dict:
+        """ Update sub-elements parameters
+        """
+
+        params = {}
+
+        if "switch" in params_in:
+            nfs               = dict(core = "nf", dmyl = "nfdmyl", dmyr = "nfdmyr")
+            flags             = params_in["switch"]
+            sizes             = params_in["size"]
+            placement_pattern = self.placement_pattern
+
+            for i in len(flags):
+                tname = placement_pattern[i]
+                size  = sizes[i]
+                flag  = flags[i] 
+                if flag == True:
+                    params_in[tname] = True
+                    if tname in nfs:
+                        params_in[ nfs[tname] ] = size   
+                else:
+                    params_in[tname] = False
+
+        params["nf"]        = params_in.get("nf"     , self.nf_core )
+        params["nfdmyl"]    = params_in.get("nfdmyl" , False )
+        params["nfdmyr"]    = params_in.get("nfdmyr" , False )
+        
+        params["dmyl"] = True
+        params["dmyr"] = True
+
+        if params["nfdmyl"] == False:
+            params["dmyl"]      = False
+
+        if params["nfdmyr"] == False:
+            params["dmyr"]      = False
+
+        params["core"]      = params_in["nf"]
+
+        params["bndl" ]     = params_in.get("bndl"   , True )
+        params["bndr" ]     = params_in.get("bndr"   , True )
+        
+        params["gbndl" ]     = params_in.get("gbndl" , False)
+        params["gbndr" ]     = params_in.get("gbndr" , False)
+        
+        params = self._update_params_sub(params_in, params)
+        return params
+    
+    @abstractmethod
+    def _update_params_sub(self, params_in, params):
+        """ update custom flags """
+        pass
+
+    @abstractmethod
+    def _internal_route(self, params):
+        """ internal routing method """
+        pass
+
+    @abstractmethod
+    def pins_func(self, params):
+        """ pin generation method """
+        pass
+
+    def _generate_subinstance(self, params) -> dict:
+        """The method of generating native_elements.
+        """
+
+        tlib            = self.tlib
+        placement_map   = self.placement_map
+        params    = self._update_params(params)
+        nf_core   = self.nf_core
+        tfs       = self.transform_pattern
+        
+        iparams   = dict()  # mapping sub-elements and generated instance.
+        nf        = int( params["nf"] / nf_core) 
+        
+        if params["nfdmyl"] == False:
+            nfdmyl = 1
+        else:
+            nfdmyl = params["nfdmyl"]
+
+        if params["nfdmyr"] == False:
+            nfdmyr = 1
+        else:
+            nfdmyr = params["nfdmyr"]
+
+        tf_set = ("R0", "MY")
+
+        if nf_core == 1: # not used, source and drain swap continously
+            icore_sub = [0]* nf
+            nelements_core = {}
+            pins_core      = {}
+            for i in range( nf):
+                tf_core   = tf_set[ i%2]
+                icore_sub = tlib[ placement_map["core"] ].generate( name=f'IM{i}'   , shape = [1, 1], transform = tf_core )
+                nelements_core[f"IM{i}"] = icore_sub
+                pins_core[f"D{i}"]   = icore_sub.pins["D"]
+                pins_core[f"S{i}"]   = icore_sub.pins["S"]
+                pins_core[f"G{i}"]   = icore_sub.pins["G"]
+            icore  = laygo2.object.physical.VirtualInstance( xy = [0,0], libname = "dummy", cellname="dummy",
+                                                             pins = pins_core,
+                                                             name = "IM0", native_elements = nelements_core, transform = "R0"
+                                                            )
+        else:
+            icore  = tlib[ placement_map["core"] ].generate( name='ICORE0', shape = [nf, 1] , transform = tfs["core"] )
+        
+        ibndl  = tlib[ placement_map["bndl"] ].generate( name='IBNDL0', shape = [1, 1] , transform = tfs["bndl"] )
+        ibndr  = tlib[ placement_map["bndr"] ].generate( name='IBNDR0', shape = [1, 1] , transform = tfs["bndr"] )
+        
+        idmyl  = tlib[ placement_map["dmyl"] ].generate( name='IDMYL0',  shape = [max( int(0.5 * nfdmyl ),1)  , 1], transform = tfs["dmyl"] )
+        idmyr  = tlib[ placement_map["dmyr"] ].generate( name='IDMYR0',  shape = [max( int(0.5 * nfdmyr) ,1)  , 1], transform = tfs["dmyr"] )
+
+        igbndl = tlib[ placement_map["gbndl"] ].generate( name='IGDMYL0', shape = [1, 1], transform = tfs["gbndl"] )
+        igbndr = tlib[ placement_map["gbndr"] ].generate( name='IGDMYR0', shape = [1, 1], transform = tfs["gbndr"] )
+
+        iparams["gbndl"] = igbndl
+        iparams["gbndr"] = igbndr
+        
+        iparams["dmyl"]  = idmyl
+        iparams["dmyr"]  = idmyr
+
+        iparams["bndl"]  = ibndl
+        iparams["bndr"]  = ibndr
+        
+        iparams["core"]  = icore
+
+        return iparams
+
+    def _device_place(self, params) -> dict:
+        """ The method of placing native elements.
+            It will modify instances.xy
+        """
+
+        params        = self._update_params( params )
+        iparams       = self._generate_subinstance( params )
+        
+        placement_pattern = self.placement_pattern
+        tfs               = self.transform_pattern
+
+        # placement
+        cursor = [0, 0]
+        for i, t_inst in enumerate( placement_pattern ):
+            if params[t_inst] != False:
+                inst     = iparams[t_inst]
+            
+                if tfs[t_inst] == "MY":
+                    xy_bl    = inst.bbox[0]  # this is on the left side
+                    xy_tr    = inst.bbox[1]
+                    inst.xy  = np.asarray( cursor ) + [ -xy_bl[0], 0 ]
+                else:
+                    inst.xy  = cursor
+            
+                xy_bl    = inst.bbox[0]
+                xy_tr    = inst.bbox[1]
+                cursor   = [ xy_tr[0], xy_bl[1] ] 
+            else:
+                iparams.pop(t_inst) # remove from dictionary
+        
+        return iparams
+
+   
+    def bbox_func(self, params) -> np.ndarray:
+        params  = self._update_params(params)
+        
+        iparams = self._device_place( params )
+
+        xy_all = np.asarray([0,0])
+        for t_inst, inst in iparams.items():
+            xy = inst.bbox
+            xy_bl     = xy[0]
+            xy_tr     = xy[1]
+
+            xy_all[0] = max( xy_all[0], xy_tr[0])
+            xy_all[1] = max( xy_all[1], xy_tr[1])
+        
+        return xy_all
+    
+    def generate_func(self, name = None, shape = None, pitch = None, transform = 'R0', params = None):
+        """ generate Virtualinstances and with routing
+        """
+
+        nelements = dict()
+        params    = self._update_params( params )
+        placement_map   = self.placement_map
+        libname   = self.libname
+        iparams   = self._device_place( params )
+        nelements.update( iparams )            
+        
+        routes    = self._internal_route( params )
+        nelements.update( routes )            
+
+        pins      = self.pins_func(params)
+        nelements.update(pins)
+
+        bbox      = self.bbox_func(params)
+
+        # Generate and return the final instance
+        inst = laygo2.object.VirtualInstance( name = name, xy = np.array([0, 0]) , libname = libname, cellname = f'myvcell_{name}' ,
+                                              native_elements = nelements, shape = shape, pitch = pitch,
+                                              transform       = transform, unit_size = bbox, pins = pins)
+        
+        return inst
+
+class TileMOSTemplate(TileTemplate):
+
+    def _update_params_sub(self, params_in, params):
+        # about routing
+        params["sdswap"]    = params_in.get("sdswap"   , False)  
+        params["trackswap"] = params_in.get("trackswap", False)  
+        params["tie"      ] = params_in.get("tie"      , False)  
+        
+        # new function
+        params["rtrackswap"] = params_in.get("rtrackswap", False)  
+        params["sdswap"]     = params_in.get("sdswap"    , False)  
+        params["rail"     ]  = params_in.get("rail", True )  
+        
+        return params
+
+    def pins_func(self, params):
+        """The method of creating pin."""
+        params  = self._update_params(params)
+        pins    = dict()
+        
+        # generate a virtual routing structure for reference
+        route_obj = self._internal_route( params )
+
+        if 'RG0' in route_obj:  # gate
+            g_obj = route_obj['RG0']
+            pins['G'] = laygo2.object.Pin(xy=g_obj.xy, layer=g_obj.layer, netname='G')
+        if 'RD0' in route_obj:  # drain
+            d_obj = route_obj['RD0']
+            pins['D'] = laygo2.object.Pin(xy=d_obj.xy, layer=d_obj.layer, netname='D')
+        if 'RS0' in route_obj:  # source
+            s_obj = route_obj['RS0']
+            pins['S'] = laygo2.object.Pin(xy=s_obj.xy, layer=s_obj.layer, netname='S')
+        if 'RRAIL0' in route_obj:  # rail
+            r_obj = route_obj['RRAIL0']
+            pins['RAIL'] = laygo2.object.Pin(xy=r_obj.xy, layer=r_obj.layer, netname='RAIL')
+        return pins
+
+    def _internal_route(self, params) -> dict:
+        """The method of routing mosfet"""
+
+        params            = self._update_params(params)
+        glib              = self.glib
+        routing_gname     = self.routing_gname
+        routing_map       = self.routing_map
+        nf_core           = self.nf_core
+        iparams           = self._device_place(params)
+        placement_pattern = self.placement_pattern
+
+        r12 = glib[routing_gname]
+        n_g = routing_map["G"]
+        n_d = routing_map["D"]
+        n_s = routing_map["S"]
+        n_r = routing_map.get( "RAIL", 0 )
+
+        nelements = {}
+        nelements.update(iparams)
+        
+        icore   = iparams["core"]
+        nf      = params["nf"]
+
+        G, S, D = "G", "S", "D"
+        
+        if params["trackswap"]: #backward compatable
+            n_d, n_s = n_s, n_d
+            S, D     = D, S
+        
+        if params["rtrackswap"]: 
+            n_d, n_s = n_s, n_d
+        
+        if params["sdswap"]: 
+            S, D     = D, S
+
+        # Extrack mn from core mosfet
+        mn_list_g = [] 
+        mn_list_d = [] 
+        mn_list_s = []
+        i_iter = int( nf / nf_core) 
+
+        for i in range( i_iter ):
+            if i_iter == 1:
+                icore_sub =  icore
+            else:
+                icore_sub =  icore[i][0] # it is 2-dimensional array
+                
+            for pin_name in icore_sub.pins.keys():
+
+                if G in pin_name:
+                    mn_list_g.append( r12.mn.center( icore_sub.pins[pin_name] ) )
+                elif D in pin_name:
+                    mn_list_d.append( r12.mn.center( icore_sub.pins[pin_name] ) )
+                elif S in pin_name:
+                    mn_list_s.append( r12.mn.center( icore_sub.pins[pin_name] ) )
+        
+
+        mn_list_g = np.asarray( mn_list_g)
+        mn_list_g = mn_list_g[  mn_list_g[:,0].argsort()] # sort list by bottom_left
+        mn_list_g = np.unique(  mn_list_g, axis = 0 )
+
+        mn_list_d = np.asarray( mn_list_d)
+        mn_list_d = mn_list_d[  mn_list_d[:,0].argsort()] 
+        mn_list_d = np.unique(  mn_list_d, axis = 0 )
+        
+        mn_list_s = np.asarray( mn_list_s)
+        mn_list_s = mn_list_s[  mn_list_s[:,0].argsort()] 
+        mn_list_s = np.unique(  mn_list_s, axis = 0 )
+
+        # Create via and track
+        r_g = dict( via = 0 , track = 0) 
+        r_d = dict( via = 0 , track = 0) 
+        r_s = dict( via = 0 , track = 0) 
+
+        for mn_list, n_track, terminal, r_dict in zip( (mn_list_g, mn_list_d, mn_list_s), (n_g, n_d, n_s), (G, D, S), (r_g, r_d, r_s) ):
+            
+            via, track = self._route_pattern_via_track( r12, mn_list, n_track, terminal)
+            r_dict["via"]   = via
+            r_dict["track"] = track 
+
+        # Modify track
+        if r_g["track"] == None: 
+            mn_sub       = mn_list_g[0]
+            r_g["track"] = r12.route( mn = [ mn_sub + [0,0], mn_sub + [0,0] ], via_tag =[None, None] )  # new track
+            
+            x_extl        = routing_map["G_extension0_x"][0]
+            x_extr        = routing_map["G_extension0_x"][1]
+            if x_extl != None:
+                xy_sub     = r12.xy(mn_sub)
+                r_g["track"].xy = [ xy_sub + [ x_extl , 0], xy_sub + [x_extr, 0] ] # new track location
+
+        if r_d["track"] == None: 
+            mn_sub    = mn_list_d[0]
+            mn_sub[1] = n_d
+            
+            m_ext = routing_map["D_extension0_m"]
+            m_extl = 0
+            m_extr = 0
+            if m_ext[0] != None:
+                m_extl = m_ext[0]
+                m_extr = m_ext[1]
+
+            r_d["track"]   = r12.route( mn = [ mn_sub + [m_extl,0], mn_sub + [m_extr,0] ], via_tag =[None, None] )
+
+        if r_s["track"] == None: 
+            mn_sub    = mn_list_s[0]
+            mn_sub[1] = n_s
+            
+            m_ext = routing_map["S_extension0_m"]
+            m_extl = 0
+            m_extr = 0
+            if m_ext[0] != None:
+                m_extl = m_ext[0]
+                m_extr = m_ext[1]
+            r_s["track"]   = r12.route( mn = [ mn_sub + [m_extl,0], mn_sub + [m_extr,0] ], via_tag =[None, None] )
+
+        nelements["VIA_G"] = r_g["via"]
+        nelements["VIA_D"] = r_d["via"]
+        nelements["VIA_S"] = r_s["via"]
+
+        nelements["RG0"] = r_g["track"]
+        nelements["RD0"] = r_d["track"]
+        nelements["RS0"] = r_s["track"]
+
+        # Rail routing
+        if params["rail"]:
+
+            tinst_l = 0 # left most sub-element name
+            tinst_r = 0 # right most sub-element name
+
+            for i, tinst in enumerate(placement_pattern):
+                name = placement_pattern[i]
+                if name in iparams:
+                    if name != "gbndl":
+                        tinst_l = name
+                        break   
+            
+            for i, tinst in enumerate(placement_pattern):
+                name = placement_pattern[-1 - i]
+                if name in iparams:
+                    if name != "gbndr":
+                        tinst_r = name
+                        break   
+                    
+            inst_l = iparams[tinst_l]
+            inst_r = iparams[tinst_r]
+
+            xy_bl = inst_l.bbox[0]
+            xy_tr = inst_r.bbox[1]
+            xy_br = [xy_tr[0], xy_bl[1] ]
+
+            mn_bl = r12.xy >= xy_bl 
+            mn_br = r12.xy <= xy_br 
+
+            r_track = r12.route( mn = [mn_bl, mn_br], via_tag = [None, None] )
+            nelements["RRAIL0"] = r_track
+
+        # TIE
+        if params["tie"] != False:
+
+            if params["tie"] == "S" or params["tie"] == True:
+                del nelements["RS0"]
+                del nelements["VIA_S"]
+                
+                via, track = self._route_pattern_via_track(r12, mn_list_s, n_r, "VIA_TIE")
+                r_t        = r12.route_via_track( mn = mn_list_s, via_tag = [ False, False], track = [None, n_r])
+            
+            elif params["tie"] == "D":
+                del nelements["RD0"]
+                del nelements["VIA_D"]
+                
+                via, track = self._route_pattern_via_track(r12, mn_list_d, n_r, "VIA_TIE")
+                r_t        = r12.route_via_track( mn = mn_list_d, via_tag = [ False, False], track = [None, n_r])
+
+            else:
+                raise Exception(" Value error for tie")
+            
+            nelements["VIA_TIE"] = via
+            
+            if r_t[-1] == None:
+                del r_t[1]
+            for i, r in enumerate(r_t): # source or drain to rail
+                nelements[f"RECT_TIE{i}"] = r
+
+        # dmy routing
+
+        names_dmy = ["dmyl", "dmyr"]
+        for i, tdmy_nf in enumerate( ( "nfdmyl", "nfdmyr" )):
+            if params[tdmy_nf] == 0:
+                continue
+            name_dmy  = names_dmy[i]
+            icore     = iparams[ name_dmy ]
+            mn_list_g = [] 
+            mn_list_d = [] 
+            mn_list_s = []
+            i_iter = int( params[tdmy_nf] / nf_core) 
+
+            for i in range( i_iter ):
+                if i_iter == 1:
+                    icore_sub =  icore
+                else:
+                    icore_sub =  icore[i][0] # it is 2-dimensional array
+                
+                for pin_name in icore_sub.pins.keys():
+
+                    if G in pin_name:
+                        mn_list_g.append( r12.mn.center( icore_sub.pins[pin_name] ) )
+                    elif D in pin_name:
+                        mn_list_d.append( r12.mn.center( icore_sub.pins[pin_name] ) )
+                    elif S in pin_name:
+                        mn_list_s.append( r12.mn.center( icore_sub.pins[pin_name] ) )
+
+                mn_list_a = mn_list_g + mn_list_s + mn_list_d
+                mn_list_a = np.asarray( mn_list_a)
+                mn_list_a = mn_list_a[  mn_list_a[:,0].argsort()] # sort list by bottom_left
+                mn_list_a = np.unique(  mn_list_a, axis = 0 )
+
+                r_t        = r12.route_via_track( mn = mn_list_a, via_tag = [ False, False], track = [None, n_r])
+                
+                mn_list_a[:,1] = n_r
+                mn_list_a = np.unique(  mn_list_a, axis = 0 )
+                via, track = self._route_pattern_via_track(r12, mn_list_a, n_r, f"VIA_DUMMY_{icore.name}")
+                
+                nelements[f"VIA_TIE_{name_dmy}"] = via
+                
+                if r_t[-1] == None:
+                    del r_t[1]
+                for i, r in enumerate(r_t): # source or drain to rail
+                    nelements[f"RECT_DMY_TIE_{name_dmy}_{i}"] = r
+
+        return nelements
+  
+
+class TileTapTemplate(TileTemplate):
+    """The class of TileTap."""
+
+    def _update_params_sub(self, params_in, params):
+        # about routing
+        params["sdswap"]    = params_in.get("sdswap"   , False)  
+        params["trackswap"] = params_in.get("trackswap", False)  
+        params["tie"      ] = params_in.get("tie"      , False)  
+        
+        # new function
+        params["rtrackswap"] = params_in.get("rtrackswap", False)  
+        params["sdswap"]     = params_in.get("sdswap"    , False)  
+        params["rail"     ]  = params_in.get("rail", True )  
+        
+        return params
+
+    def pins_func(self, params):
+        """The method of creating pin."""
+        params  = self._update_params(params)
+        pins    = dict()
+        
+        # generate a virtual routing structure for reference
+        route_obj = self._internal_route( params )
+
+        if 'RG0' in route_obj:  # gate
+            g_obj = route_obj['RG0']
+            pins['G'] = laygo2.object.Pin(xy=g_obj.xy, layer=g_obj.layer, netname='G')
+        if 'RD0' in route_obj:  # drain
+            d_obj = route_obj['RD0']
+            pins['D'] = laygo2.object.Pin(xy=d_obj.xy, layer=d_obj.layer, netname='D')
+        if 'RS0' in route_obj:  # source
+            s_obj = route_obj['RS0']
+            pins['S'] = laygo2.object.Pin(xy=s_obj.xy, layer=s_obj.layer, netname='S')
+        if 'RRAIL0' in route_obj:  # rail
+            r_obj = route_obj['RRAIL0']
+            pins['RAIL'] = laygo2.object.Pin(xy=r_obj.xy, layer=r_obj.layer, netname='RAIL')
+        return pins
+
+
+    def _internal_route(self, params):
+        params    = self._update_params(params)
+        glib      = self.glib
+        routing_gname = self.routing_gname
+        routing_map = self.routing_map
+        nf_core   = self.nf_core
+        iparams   = self._device_place(params)
+        placement_pattern = self.placement_pattern
+
+        r12 = glib[routing_gname]
+        n_g = routing_map["G"]
+        n_d = routing_map["D"]
+        n_s = routing_map["S"]
+        n_r = routing_map.get( "RAIL", 0 )
+
+        nelements = {}
+        nelements.update(iparams)
+        
+        icore   = iparams["core"]
+        nf      = params["nf"]
+
+        G, S, D = "G", "S", "D"
+        
+        if params["trackswap"]: #backward compatable
+            n_d, n_s = n_s, n_d
+            S, D     = D, S
+        
+        if params["rtrackswap"]: 
+            n_d, n_s = n_s, n_d
+        
+        if params["sdswap"]: 
+            S, D     = D, S
+
+        mn_list_s = [] # TAP0
+        mn_list_d = [] # TAP1
+
+        i_iter = int( nf / nf_core) 
+        for i in range( i_iter ):
+            if i_iter == 1:
+                icore_sub =  icore
+            else:
+                icore_sub =  icore[i][0] # it is 2-dimensional array
+                
+            for pin_name in icore_sub.pins.keys():
+                if "TAP0" in pin_name:
+                    mn_list_s.append( r12.mn.center( icore_sub.pins[pin_name] ) )
+                elif "TAP1" in pin_name:
+                    mn_list_d.append( r12.mn.center( icore_sub.pins[pin_name] ) )
+        
+        mn_list_s = np.asarray( mn_list_s)
+        mn_list_s = mn_list_s[  mn_list_s[:,0].argsort()] 
+        mn_list_s = np.unique(  mn_list_s, axis = 0 )
+        
+        mn_list_d = np.asarray( mn_list_d)
+        mn_list_d = mn_list_s[  mn_list_d[:,0].argsort()] 
+        mn_list_d = np.unique(  mn_list_d, axis = 0 )
+
+        r_s = dict( via = 0 , track = 0) 
+        r_d = dict( via = 0 , track = 0) 
+
+        for mn_list, n_track, terminal, r_dict in zip( (mn_list_s,mn_list_d), (n_s, n_d), ( D, S), (r_d, r_s) ):
+            via, track = self._route_pattern_via_track( r12, mn_list, n_track, terminal)
+            r_dict["via"]   = via
+            r_dict["track"] = track 
+
+        # Modify track
+        if r_d["track"] == None: 
+            mn_sub    = mn_list_d[0]
+            mn_sub[1] = n_d
+            
+            m_ext = routing_map["D_extension0_m"]
+            m_extl = 0
+            m_extr = 0
+            if m_ext[0] != None:
+                m_extl = m_ext[0]
+                m_extr = m_ext[1]
+
+            r_d["track"]   = r12.route( mn = [ mn_sub + [m_extl,0], mn_sub + [m_extr,0] ], via_tag =[None, None] )
+
+        if r_s["track"] == None: 
+            mn_sub    = mn_list_s[0]
+            mn_sub[1] = n_s
+            
+            m_ext = routing_map["S_extension0_m"]
+            m_extl = 0
+            m_extr = 0
+            if m_ext[0] != None:
+                m_extl = m_ext[0]
+                m_extr = m_ext[1]
+            r_s["track"]   = r12.route( mn = [ mn_sub + [m_extl,0], mn_sub + [m_extr,0] ], via_tag =[None, None] )
+
+        nelements["VIA_D"] = r_d["via"]
+        nelements["VIA_S"] = r_s["via"]
+
+        nelements["RD0"] = r_d["track"]
+        nelements["RS0"] = r_s["track"]
+
+        # Rail routing
+        if params["rail"]:
+
+            tinst_l = 0 # left most sub-element name
+            tinst_r = 0 # right most sub-element name
+
+            for i, tinst in enumerate(placement_pattern):
+                name = placement_pattern[i]
+                if name in iparams:
+                    if name != "gbndl":
+                        tinst_l = name
+                        break   
+            
+            for i, tinst in enumerate(placement_pattern):
+                name = placement_pattern[-1 - i]
+                if name in iparams:
+                    if name != "gbndr":
+                        tinst_r = name
+                        break   
+                    
+            inst_l = iparams[tinst_l]
+            inst_r = iparams[tinst_r]
+
+            xy_bl = inst_l.bbox[0]
+            xy_tr = inst_r.bbox[1]
+            xy_br = [xy_tr[0], xy_bl[1] ]
+
+            mn_bl = r12.xy >= xy_bl 
+            mn_br = r12.xy <= xy_br 
+
+            r_track = r12.route( mn = [mn_bl, mn_br], via_tag = [None, None] )
+            nelements["RRAIL0"] = r_track
+            '''
+            xy    = icore.bbox
+            xy_bl = xy[0]
+            xy_tr = xy[1]
+            xy_br = [xy_tr[0], xy_bl[1] ]
+            mn_bl = r12.xy >= xy_bl 
+            mn_br = r12.xy <= xy_br 
+
+            r_track = r12.route( mn = [mn_bl, mn_br], via_tag = [None, None] )
+            nelements["RRAIL0"] = r_track
+            '''
+
+        # TIE
+        if params["tie"] != False:
+
+            if params["tie"] == "TAP0" or params["tie"] == True:
+                del nelements["RS0"]
+                del nelements["VIA_S"]
+                
+                via, track = self._route_pattern_via_track(r12, mn_list_s, n_r, "VIA_TIE")
+                r_t        = r12.route_via_track( mn = mn_list_s, via_tag = [ False, False], track = [None, n_r])
+            
+            elif params["tie"] == "TAP1":
+                del nelements["RD0"]
+                del nelements["VIA_D"]
+                
+                via, track = self._route_pattern_via_track(r12, mn_list_d, n_r, "VIA_TIE")
+                r_t        = r12.route_via_track( mn = mn_list_d, via_tag = [ False, False], track = [None, n_r])
+
+            else:
+                raise Exception(" Value error for tie")
+            
+            nelements["VIA_TIE"] = via
+
+            if r_t[-1] == None:
+                del r_t[1]
+            for i, r in enumerate(r_t):
+                nelements[f"RECT_TIE{i}"] = r
+
+        return nelements
+
+class TileSpaceTemplate(TileTemplate):
+    """The class for tile-based spacer template."""
+
+    def _update_params_sub(self, params_in, params):
+        params["rail"     ]  = params_in.get("rail", True )  
+        return params
+
+    def pins_func(self, params):
+        """The method of creating pin."""
+        params  = self._update_params(params)
+        pins    = dict()
+        
+        # generate a virtual routing structure for reference
+        route_obj = self._internal_route( params )
+
+        if 'RRAIL0' in route_obj:  # rail
+            r_obj = route_obj['RRAIL0']
+            pins['RAIL'] = laygo2.object.Pin(xy=r_obj.xy, layer=r_obj.layer, netname='RAIL')
+        return pins
+
+
+    def _internal_route(self, params):
+        params    = self._update_params(params)
+        glib      = self.glib
+        routing_gname = self.routing_gname
+        routing_map = self.routing_map
+        nf_core   = self.nf_core
+        iparams   = self._device_place(params)
+        placement_pattern = self.placement_pattern
+
+        r12 = glib[routing_gname]
+        n_r = routing_map.get( "RAIL", 0 )
+
+        nelements = {}
+        nelements.update(iparams)
+        
+        icore   = iparams["core"]
+        nf      = params["nf"]
+
+        # Rail routing
+        if params["rail"]:
+
+            tinst_l = 0 # left most sub-element name
+            tinst_r = 0 # right most sub-element name
+
+            for i, tinst in enumerate(placement_pattern):
+                name = placement_pattern[i]
+                if name in iparams:
+                    if name != "gbndl":
+                        tinst_l = name
+                        break   
+            
+            for i, tinst in enumerate(placement_pattern):
+                name = placement_pattern[-1 - i]
+                if name in iparams:
+                    if name != "gbndr":
+                        tinst_r = name
+                        break   
+                    
+            inst_l = iparams[tinst_l]
+            inst_r = iparams[tinst_r]
+
+            xy_bl = inst_l.bbox[0]
+            xy_tr = inst_r.bbox[1]
+            xy_br = [xy_tr[0], xy_bl[1] ]
+
+            mn_bl = r12.xy >= xy_bl 
+            mn_br = r12.xy <= xy_br 
+
+            r_track = r12.route( mn = [mn_bl, mn_br], via_tag = [None, None] )
+            nelements["RRAIL0"] = r_track
+            '''
+            xy    = icore.bbox
+            xy_bl = xy[0]
+            xy_tr = xy[1]
+            xy_br = [xy_tr[0], xy_bl[1] ]
+            mn_bl = r12.xy >= xy_bl 
+            mn_br = r12.xy <= xy_br 
+
+            r_track = r12.route( mn = [mn_bl, mn_br], via_tag = [None, None] )
+            nelements["RRAIL0"] = r_track
+            '''
+
+        return nelements
```

### Comparing `laygo2-0.5.6/laygo2/object/template/__init__.py` & `laygo2-0.5.7/laygo2/object/grid/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,32 +1,41 @@
-# -*- coding: utf-8 -*-
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-"""
-**laygo2.object.template** module implements classes for various layout template objects.
-"""
-
-from . import *
-from .core import *
-from .tile import *
-from .routing import *
+# -*- coding: utf-8 -*-
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+"""
+**laygo2.object.grid** module contains classes that implement abstract coordinate systems that are interacting with technology-specific physical coordinate systems.
+
+laygo2 implements the layout designs based on the abstract coordinate system.
+
+.. image:: ../assets/img/user_guide_grid.png
+
+
+
+Check the following links for the details of component methods and classes.
+"""
+
+from .core import *
+from .routing import *
+from .placement import *
+from .uniformrouting import *
+#from laygo2.object.grid.routing import *
```

### Comparing `laygo2-0.5.6/laygo2/object/template/core.py` & `laygo2-0.5.7/laygo2/object/template/core.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,1482 +1,1482 @@
-#!/usr/bin/python
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-__author__ = "Jaeduk Han"
-__maintainer__ = "Jaeduk Han"
-__status__ = "Prototype"
-
-from abc import *
-import numpy as np
-import laygo2.object
-
-
-class Template(metaclass=ABCMeta):
-    """
-    The base class that defines the functions and attributes of the template.
-
-    Notes
-    -----
-    **(Korean)** Template의 기본동작과 속성을 정의한 기본 클래스.
-    """
-
-    name = None
-    """str: Template name."""
-
-    def __init__(self, name=None):
-        """
-        The constructor function.
-
-        Parameters
-        ----------
-        name : str or None, optional.
-            The name of this template.
-        """
-        self.name = name
-
-    def __str__(self):
-        """Return a string representation of this template's information. """
-        return self.summarize()
-
-    def summarize(self):
-        """Return the summary of the template information."""
-        return (
-            self.__repr__() + " "
-            "name: "
-            + self.name
-            + ", "
-            + "class: "
-            + self.__class__.__name__
-            + ", "
-            + ""
-        )
-
-    def height(self, params=None):
-        """int: Return the height of the template."""
-        return abs(self.bbox(params=params)[0, 1] - self.bbox(params=params)[1, 1])
-
-    def width(self, params=None):
-        """int: Return the width of the template."""
-        return abs(self.bbox(params=params)[0, 0] - self.bbox(params=params)[1, 0])
-
-    def size(self, params=None):
-        """int: Return the size of the template."""
-        return np.array([self.width(params=params), self.height(params=params)])
-
-    @abstractmethod
-    def bbox(self, params=None):
-        """numpy.ndarray: (Abstract method) the physical bounding box of the template."""
-        pass
-
-    @abstractmethod
-    def pins(self, params=None):
-        """dict: (Abstract method) Dictionary storing the pins of the template."""
-        pass
-
-    @abstractmethod
-    def generate(self, name=None, shape=None, pitch=None, transform="R0", netmap=None, params=None):
-        """instance: (Abstract method) Generate an instance from the template."""
-        pass
-        
-
-
-class NativeInstanceTemplate(Template):
-    """
-    NativeInstanceTemplate class implements the template that generate Instance.
-
-    Notes
-    -----
-    **(Korean)** NativeInstanceTemplate 클래스는 기본 Instance를 반환하는 템플릿을 구현한다.
-    """
-
-    libname = None
-    """str: Library name.
-
-    Example
-    -------
-    >>> from laygo2.object.physical import Pin
-    >>> from laygo2.object.template import NativeInstanceTemplate
-    >>> p = dict() 
-    >>> p['i'] = Pin(xy=[[0, 0], [10, 10]], layer=['M1', 'drawing'], 
-                     netname='i')
-    >>> p['o'] = Pin(xy=[[90, 90], [100, 100]], layer=['M1', 'drawing'], 
-                     netname='o')
-    >>> nt = NativeInstanceTemplate(libname='mylib', cellname='mytemp', 
-                                    bbox=[[0, 0], [100, 100]], pins=p)
-    >>> nt.libname 
-    'mylib'
-    
-    .. image:: ../assets/img/object_template_NativeInstanceTemplate_libname.png
-          :height: 250
-
-    Notes
-    -----
-    **(Korean)** NativeInstanceTemplate 객체의 library 이름.
-    """
-
-    cellname = None
-    """str: Cell name.
-
-    Example
-    -------
-    >>> from laygo2.object.physical import Pin
-    >>> from laygo2.object.template import NativeInstanceTemplate
-    >>> p = dict() 
-    >>> p['i'] = Pin(xy=[[0, 0], [10, 10]], layer=['M1', 'drawing'], 
-                     netname='i')
-    >>> p['o'] = Pin(xy=[[90, 90], [100, 100]], layer=['M1', 'drawing'], 
-                     netname='o')
-    >>> nt = NativeInstanceTemplate(libname='mylib', cellname='mytemp', 
-                                    bbox=[[0, 0], [100, 100]], pins=p)
-    >>> nt.cellname 
-    'mytemp'
-    
-    .. image:: ../assets/img/object_template_NativeInstanceTemplate_cellname.png
-          :height: 250
-
-    Notes
-    -----
-    **(Korean)** NativeInstanceTemplate 객체의 cellname.
-    """
-
-    _bbox = np.array([[0, 0], [0, 0]])
-
-    _pins = None
-
-    def __init__(self, libname, cellname, bbox=np.array([[0, 0], [0, 0]]), pins=None):
-        """
-        Constructor function.
-
-        Parameters
-        ----------
-        libname : str
-            Library name.
-        cellname : str
-            Cell name.
-        bbox : numpy.ndarray
-            Bounding box of the object.
-        pins : dict
-            Dictionary storing the template's pin objects.
-
-        Returns
-        -------
-        NativeInstanceTemplate
-
-        Example
-        -------
-        >>> from laygo2.object.physical import Pin
-        >>> from laygo2.object.template import NativeInstanceTemplate
-        >>> p = dict() 
-        >>> p['i'] = Pin(xy=[[0, 0], [10, 10]], layer=['M1', 'drawing'], 
-                         netname='i')
-        >>> p['o'] = Pin(xy=[[90, 90], [100, 100]], layer=['M1', 'drawing'], 
-                         netname='o')
-        >>> nt = NativeInstanceTemplate(libname='mylib', cellname='mytemp', 
-                                        bbox=[[0, 0], [100, 100]], pins=p)
-        <laygo2.object.template.NativeInstanceTemplate object>
-        >>> print(nt)
-        <laygo2.object.template.NativeInstanceTemplate object at 0x0000013C01..> 
-         name: mytemp, class: NativeInstanceTemplate, bbox: [[0, 0], [100, 100]], 
-         pins: {'i': <laygo2.object.physical.Pin object at 0x0000013C01CEFDC0>, 
-                'o': <laygo2.object.physical.Pin object at 0x0000013C01C30BE0>},
-
-        .. image:: ../assets/img/object_template_NativeInstanceTemplate_init.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)** NativeInstanceTemplate 클래스의 생성자함수.
-        """
-        self.libname = libname
-        self.cellname = cellname
-        self._bbox = None if bbox is None else np.asarray(bbox)
-        self._pins = pins
-        Template.__init__(self, name=cellname)
-
-    def summarize(self):
-        """Return the summary of the object information."""
-        return (
-            self.__repr__() + " "
-            "name: "
-            + self.name
-            + ", "
-            + "class: "
-            + self.__class__.__name__
-            + ", "
-            + "bbox: "
-            + str(self.bbox().tolist())
-            + ", "
-            + "pins: "
-            + str(self.pins())
-            + ", "
-            + ""
-        )
-
-    # Core template functions
-    def bbox(self, params=None):
-        """
-        Bounding box of the object.
-
-        Parameters
-        ----------
-        None
-
-        Returns
-        -------
-        numpy.ndarray
-
-        Example
-        -------
-        >>> from laygo2.object.physical import Pin
-        >>> from laygo2.object.template import NativeInstanceTemplate
-        >>> p = dict() 
-        >>> p['i'] = Pin(xy=[[0, 0], [10, 10]], layer=['M1', 'drawing'], 
-                         netname='i')
-        >>> p['o'] = Pin(xy=[[90, 90], [100, 100]], layer=['M1', 'drawing'], 
-                         netname='o')
-        >>> nt = NativeInstanceTemplate(libname='mylib', cellname='mytemp', 
-                                        bbox=[[0, 0], [100, 100]], pins=p)
-        >>> nt.bbox()
-        array([[  0,   0],
-               [100, 100]])
-
-        .. image:: ../assets/img/object_template_NativeInstanceTemplate_bbox.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)** NativeInstanceTemplate 객체의 bbox.
-        """
-        return self._bbox
-
-    def pins(self, params=None):
-        """
-        Dictionary storing pins of the object.
-
-        Parameters
-        ----------
-        None
-
-        Returns
-        -------
-        dict : Dictionary storing pin objects.
-
-        Example
-        -------
-        >>> from laygo2.object.physical import Pin
-        >>> from laygo2.object.template import NativeInstanceTemplate
-        >>> p = dict() 
-        >>> p['i'] = Pin(xy=[[0, 0], [10, 10]], layer=['M1', 'drawing'], 
-                         netname='i')
-        >>> p['o'] = Pin(xy=[[90, 90], [100, 100]], layer=['M1', 'drawing'], 
-                         netname='o')
-        >>> nt = NativeInstanceTemplate(libname='mylib', cellname='mytemp', 
-                                        bbox=[[0, 0], [100, 100]], pins=p)
-        >>> nt.pins()
-        >>> {'i': <laygo2.object.physical.Pin object at 0x000002578C762500>, 
-             'o': <laygo2.object.physical.Pin object at 0x00000257FBA87C40>}                   
-        >>> print(nt.pins()['i']) 
-            <laygo2.object.physical.Pin object at 0x000002578C762500> 
-                name: None,
-                class: Pin,
-                xy: [[0, 0], [10, 10]],
-                params: None, 
-                layer: ['M1' 'drawing'], 
-                netname: i, 
-                shape: None, 
-                master: None
-
-        .. image:: ../assets/img/object_template_ParameterizedInstanceTemplate_pins.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)** NativeInstanceTemplate 객체의 pin dictionary 반환.
-        """
-        return self._pins
-
-    def generate(self, name=None, shape=None, pitch=None, transform="R0", netmap=None, params=None):
-        """
-        Generate Instance object.
-
-        Parameters
-        ----------
-        name : str
-            Name of the instance to be generated.
-        shape : numpy.ndarray, optional.
-            Shape of the object to be generated.
-        pitch : numpy.ndarray, optional.
-            Element pitch of the array object to be generated.
-        transform : str
-            Transformation attribute of the object to be generated.
-        netmap : dict, optional.
-            Dictionary storing net-pin conversion mappings.
-        params : dict, optional.
-            Dictionary storing the parameters associated with the object.
-
-        Returns
-        -------
-        (laygo2.object.physical.Instance) generated Instance object
-
-        See Also
-        --------
-        Class Instance
-
-        Example
-        -------
-        >>> from laygo2.object.physical import Pin
-        >>> from laygo2.object.template import NativeInstanceTemplate
-        >>> p = dict() 
-        >>> p['i'] = Pin(xy=[[0, 0], [10, 10]], layer=['M1', 'drawing'], 
-                         netname='i')
-        >>> p['o'] = Pin(xy=[[90, 90], [100, 100]], layer=['M1', 'drawing'], 
-                         netname='o')
-        >>> nt = NativeInstanceTemplate(libname='mylib', cellname='mytemp', 
-                                        bbox=[[0, 0], [100, 100]], pins=p)
-        >>> i0 = nt.generate(name="I0")
-        >>> i1 = nt.generate(name="I1")
-        >>> print(i0)
-        <laygo2.object.physical.Instance object at 0x000002C3F717F850> 
-        name: I0,
-        class: Instance,
-        xy: [0, 0],
-        params: None,
-        size: [100, 100],
-        shape: None,
-        pitch: [100, 100],
-        transform: R0,
-        pins: {'i': <laygo2.object.physical.Pin object at 0x000002C3F717F820>, 
-               'o': <laygo2.object.physical.Pin object at 0x000002C3F717FD90>},
-        >>> print(i1)
-        <laygo2.object.physical.Instance object at 0x000002C3FF91C100> 
-        name: I1,
-        class: Instance,
-        xy: [0, 0],
-        params: None,
-        size: [100, 100],
-        shape: None,
-        pitch: [100, 100],
-        transform: R0,
-        pins: {'i': <laygo2.object.physical.Pin object at 0x000002C3FF91C0A0>, 
-               'o': <laygo2.object.physical.Pin object at 0x000002C3FF91C070>},
-        
-        .. image:: ../assets/img/object_template_ParameterizedInstanceTemplate_generate.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)** 템플릿으로부터 Instance 객체 생성.
-        """
-        inst = laygo2.object.physical.Instance(
-            libname=self.libname,
-            cellname=self.cellname,
-            xy=np.array([0, 0]),
-            shape=shape,
-            pitch=pitch,
-            unit_size=self.size(params),
-            pins=self.pins(params),
-            transform=transform,
-            name=name,
-            params=params,
-        )
-        # update netnames if netmap is provided.
-        if netmap is not None:
-            inst.update_netname(netmap=netmap)  
-        return inst 
-
-    # I/O functions
-    def export_to_dict(self):
-        """
-        Return a dictionary containing the template information.
-
-        Parameters
-        ----------
-        None
-
-        Returns
-        -------
-        dict
-
-        See Also
-        --------
-        Class Instance
-
-        Example
-        -------
-        >>> from laygo2.object.physical import Pin
-        >>> from laygo2.object.template import NativeInstanceTemplate
-        >>> p = dict() 
-        >>> p['i'] = Pin(xy=[[0, 0], [10, 10]], layer=['M1', 'drawing'], 
-                         netname='i')
-        >>> p['o'] = Pin(xy=[[90, 90], [100, 100]], layer=['M1', 'drawing'], 
-                         netname='o')
-        >>> nt = NativeInstanceTemplate(libname='mylib', cellname='mytemp', 
-                                        bbox=[[0, 0], [100, 100]], pins=p)
-        >>> nt.export_to_dict()
-            {'libname': 'mylib', 
-             'cellname': 'mytemp', 
-             'bbox': [[0, 0], [100, 100]], 
-             'pins': {'i': {'xy': [[0, 0], [10, 10]], 
-                            'layer': ['M1', 'drawing'], 
-                            'name': None, 
-                            'netname': 'i'}, 
-                      'o': {'xy': [[90, 90], [100, 100]], 
-                            'layer': ['M1', 'drawing'], 
-                            'name': None, 
-                            'netname': 'o'}
-                     }
-            }
-
-        .. image:: ../assets/img/object_template_NativeInstanceTemplate_export_to_dict.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)** NativeInstanceTemplate 의 정보가 담긴 Dictonary 반환.
-        """
-        db = dict()
-        db["libname"] = self.libname
-        db["cellname"] = self.cellname
-        db["bbox"] = self.bbox().tolist()
-        db["pins"] = dict()
-        for pn, p in self.pins().items():
-            db["pins"][pn] = p.export_to_dict()
-        return db
-
-
-class ParameterizedInstanceTemplate(Template):
-    """
-    The ParameterizedInstanceTemplate class implements a template for 
-    generating instances with varying size (bounding box) and pin 
-    configurations based on input parameters, such as instances mapped 
-    to Cadence Virtuoso's pcells or Pycells.
-
-    Notes
-    -----
-    **(Korean)** ParameterizedInstanceTemplate 클래스는 입력 파라미터에 따라 
-    크기와 pin 정보가 가변하는 인스턴스를 생성하는 템플릿을 구현한다. 
-    """
-
-    libname = None
-    """str: The libname of the instance to be generated."""
-
-    cellname = None
-    """str: The cellname of the instance to be generated."""
-
-    _bbox = None
-
-    _pins = None
-
-    def __init__(self, libname, cellname, bbox_func=None, pins_func=None):
-        """
-        Constructor of ParameterizedInstanceTemplate class.
-
-        Parameters
-        ----------
-        libname : str
-            The library name.
-        cellname : str
-            The cell name of the template.
-        bbox_func : callable
-            The function that computes the bounding box of the template from 
-            its input parameters.
-        pins_func : callable
-            The function that returns a dictionary that contains its pin 
-            objects for its input parameters.
-
-        Returns
-        -------
-        laygo2.object.template.ParameterizedInstanceTemplate
-
-        Example
-        -------
-        >>> import numpy as np
-        >>> from laygo2.object.template import ParameterizedInstanceTemplate
-        >>> from laygo2.object.physical import Pin
-        >>> # bbox computation function.
-        >>> def pcell_bbox_func(params):
-                return np.array([[0, 0], [100 * params["mult"], 100]])
-        >>> # pin generation function.
-        >>> def pcell_pins_func(params):
-        >>>     template_pins = dict()
-        >>>     for i in range(params["mult"]):
-        >>>         template_pins["in" + str(i)] = Pin(
-        >>>             xy=[[i * 100 + 0, 0], [i * 100 + 10, 10]],
-        >>>             layer=["M1", "drawing"],
-        >>>             netname="in" + str(i),
-        >>>         )
-        >>>         template_pins["out" + str(i)] = Pin(
-        >>>             xy=[[i * 100 + 90, 90], [i * 100 + 90, 100]],
-        >>>             layer=["M1", "drawing"],
-        >>>             netname="out" + str(i),
-        >>>         )
-        >>>     return template_pins
-        >>> # Create a template
-        >>> pcell_temp = ParameterizedInstanceTemplate(
-        >>>     libname="mylib",
-        >>>     cellname="mypcelltemplate",
-        >>>     bbox_func=pcell_bbox_func,
-        >>>     pins_func=pcell_pins_func,
-        >>> )
-        >>> # Generate an instance for input parameters.
-        >>> pcell_inst_params = {"mult": 4}
-        >>> pcell_inst = pcell_temp.generate(
-        >>>    name="mypcellinst",
-        >>>    transform="R0",
-        >>>    params=pcell_inst_params,
-        >>> )
-        >>> # display
-        >>> print(pcell_temp)
-            <laygo2.object.template.ParameterizedInstanceTemplate object at 0x000001B1BA91D9C0>
-            name: mypcelltemplate, 
-            class: ParameterizedInstanceTemplate,
-        >>> print(pcell_inst)
-            xy: [0, 0],
-            params: {'mult': 4},
-            size: [400, 100],
-            shape: None,
-            pitch: [400, 100],
-            transform: R0,
-            pins: {'in0': <laygo2.object.physical.Pin object at 0x000001B1BA91FCA0>, 
-                   'out0': <laygo2.object.physical.Pin object at 0x000001B1BA91FC70>, 
-                   'in1': <laygo2.object.physical.Pin object at 0x000001B1BA91FC10>, 
-                   'out1': <laygo2.object.physical.Pin object at 0x000001B1BA91E8C0>, 
-                   'in2': <laygo2.object.physical.Pin object at 0x000001B1BA91E890>, 
-                   'out2': <laygo2.object.physical.Pin object at 0x000001B1BA91FBE0>, 
-                   'in3': <laygo2.object.physical.Pin object at 0x000001B1BA91E7D0>, 
-                   'out3': <laygo2.object.physical.Pin object at 0x000001B1BA91E710>},
-
-        .. image:: ../assets/img/object_template_ParameterizedInstanceTemplate_init.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)** ParameterizedInstanceTemplate 클래스의 생성자함수.
-        """
-        self.libname = libname
-        self.cellname = cellname
-        self._bbox = bbox_func
-        self._pins = pins_func
-        Template.__init__(self, name=cellname)
-
-    # Core template functions
-    def bbox(self, params=None):
-        """
-        Bounding box of the template object.
-
-        Parameters
-        ----------
-        params: dict
-            A dictionary that contains input parameters corresponding to the 
-            bounding box to be computed.
-
-        Returns
-        -------
-        numpy.ndarray: A 2x2 numpy array that contains the bounding box 
-            coordinates corresponding to the input parameters.
-
-        Example
-        -------
-        >>> import numpy as np
-        >>> from laygo2.object.template import ParameterizedInstanceTemplate
-        >>> from laygo2.object.physical import Pin
-        >>> # bbox computation function.
-        >>> def pcell_bbox_func(params):
-                return np.array([[0, 0], [100 * params["mult"], 100]])
-        >>> # pin generation function.
-        >>> def pcell_pins_func(params):
-        >>>     template_pins = dict()
-        >>>     for i in range(params["mult"]):
-        >>>         template_pins["in" + str(i)] = Pin(
-        >>>             xy=[[i * 100 + 0, 0], [i * 100 + 10, 10]],
-        >>>             layer=["M1", "drawing"],
-        >>>             netname="in" + str(i),
-        >>>         )
-        >>>         template_pins["out" + str(i)] = Pin(
-        >>>             xy=[[i * 100 + 90, 90], [i * 100 + 90, 100]],
-        >>>             layer=["M1", "drawing"],
-        >>>             netname="out" + str(i),
-        >>>         )
-        >>>     return template_pins
-        >>> # Create a template
-        >>> pcell_temp = ParameterizedInstanceTemplate(
-        >>>     libname="mylib",
-        >>>     cellname="mypcelltemplate",
-        >>>     bbox_func=pcell_bbox_func,
-        >>>     pins_func=pcell_pins_func,
-        >>> )
-        >>> # Compute bbox for input parameters
-        >>> pcell_inst_params = {"mult": 4}
-        >>> pcell_temp.bbox(params=pcell_inst_params)
-        array([[  0,   0],
-               [400, 100]])
-
-        .. image:: ../assets/img/object_template_ParameterizedInstanceTemplate_bbox.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)** ParameterizedInstanceTemplate 객체의 bbox.
-        """
-        return self._bbox(params=params)
-
-    def pins(self, params=None):
-        """
-        Return pin dictionary of ParameterizedInstanceTemplate object.
-
-        Parameters
-        ----------
-        params: dict
-            A dictionary that contains input parameters corresponding to the 
-            pin objects to be produced.
-
-        Returns
-        -------
-        dict: A dictionary that contains pin object corresponding to the 
-            input parameters.
-
-        Example
-        -------
-        >>> import numpy as np
-        >>> from laygo2.object.template import ParameterizedInstanceTemplate
-        >>> from laygo2.object.physical import Pin
-        >>> # bbox computation function.
-        >>> def pcell_bbox_func(params):
-                return np.array([[0, 0], [100 * params["mult"], 100]])
-        >>> # pin generation function.
-        >>> def pcell_pins_func(params):
-        >>>     template_pins = dict()
-        >>>     for i in range(params["mult"]):
-        >>>         template_pins["in" + str(i)] = Pin(
-        >>>             xy=[[i * 100 + 0, 0], [i * 100 + 10, 10]],
-        >>>             layer=["M1", "drawing"],
-        >>>             netname="in" + str(i),
-        >>>         )
-        >>>         template_pins["out" + str(i)] = Pin(
-        >>>             xy=[[i * 100 + 90, 90], [i * 100 + 90, 100]],
-        >>>             layer=["M1", "drawing"],
-        >>>             netname="out" + str(i),
-        >>>         )
-        >>>     return template_pins
-        >>> # Create a template
-        >>> pcell_temp = ParameterizedInstanceTemplate(
-        >>>     libname="mylib",
-        >>>     cellname="mypcelltemplate",
-        >>>     bbox_func=pcell_bbox_func,
-        >>>     pins_func=pcell_pins_func,
-        >>> )
-        >>> # Compute bbox for input parameters
-        >>> pcell_inst_params = {"mult": 4}
-        >>> pcell_temp.pins(params=pcell_inst_params)
-            {'in0': <laygo2.object.physical.Pin object at 0x000001B1BA91F7C0>, 
-             'out0': <laygo2.object.physical.Pin object at 0x000001B1BA91E830>,
-             'in1': <laygo2.object.physical.Pin object at 0x000001B1BA91DAB0>, 
-             'out1': <laygo2.object.physical.Pin object at 0x000001B1BA91E860>, 
-             'in2': <laygo2.object.physical.Pin object at 0x000001B1BA91E560>, 
-             'out2': <laygo2.object.physical.Pin object at 0x000001B1BA91E800>, 
-             'in3': <laygo2.object.physical.Pin object at 0x000001B1BA91E770>, 
-             'out3': <laygo2.object.physical.Pin object at 0x000001B1BA91EA40>}
-
-        .. image:: ../assets/img/object_template_ParameterizedInstanceTemplate_pins.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)** ParameterizedInstanceTemplate 객체의 pin dictionary 반환.
-        """
-        return self._pins(params=params)
-
-    def generate(self, name=None, shape=None, pitch=None, transform="R0", netmap=None, params=None):
-        """
-        Generate an Instance object corresponding to the template and its 
-        input parameters.
-
-        Parameters
-        ----------
-        name : str
-            name of the instance to be generated.
-        shape : numpy.ndarray, optional.
-            shape of the object to be generated.
-        pitch : numpy.ndarray, optional.
-            pitch of the object to be generated.
-        transform : str, optional.
-            transformation attribute of the entity to be generated.
-        netmap : dict, optional.
-            dictionary containing netmap conversion information of pins.
-        params : dict, optional.
-            dictionary having the entity attributes.
-
-        Returns
-        -------
-        laygo2.object.physical.Instance: The generated Instance object
-
-        Example
-        -------
-        >>> import numpy as np
-        >>> from laygo2.object.template import ParameterizedInstanceTemplate
-        >>> from laygo2.object.physical import Pin
-        >>> # bbox computation function.
-        >>> def pcell_bbox_func(params):
-                return np.array([[0, 0], [100 * params["mult"], 100]])
-        >>> # pin generation function.
-        >>> def pcell_pins_func(params):
-        >>>     template_pins = dict()
-        >>>     for i in range(params["mult"]):
-        >>>         template_pins["in" + str(i)] = Pin(
-        >>>             xy=[[i * 100 + 0, 0], [i * 100 + 10, 10]],
-        >>>             layer=["M1", "drawing"],
-        >>>             netname="in" + str(i),
-        >>>         )
-        >>>         template_pins["out" + str(i)] = Pin(
-        >>>             xy=[[i * 100 + 90, 90], [i * 100 + 90, 100]],
-        >>>             layer=["M1", "drawing"],
-        >>>             netname="out" + str(i),
-        >>>         )
-        >>>     return template_pins
-        >>> # Create a template
-        >>> pcell_temp = ParameterizedInstanceTemplate(
-        >>>     libname="mylib",
-        >>>     cellname="mypcelltemplate",
-        >>>     bbox_func=pcell_bbox_func,
-        >>>     pins_func=pcell_pins_func,
-        >>> )
-        >>> # Generate an instance for input parameters.
-        >>> pcell_inst_params = {"mult": 4}
-        >>> pcell_inst = pcell_temp.generate(
-        >>>    name="mypcellinst",
-        >>>    transform="R0",
-        >>>    params=pcell_inst_params,
-        >>> )
-        >>> # display
-        >>> print(pcell_temp)
-            <laygo2.object.template.ParameterizedInstanceTemplate object at 0x000001B1BA91D9C0>
-            name: mypcelltemplate, 
-            class: ParameterizedInstanceTemplate,
-        >>> print(pcell_inst)
-            xy: [0, 0],
-            params: {'mult': 4},
-            size: [400, 100],
-            shape: None,
-            pitch: [400, 100],
-            transform: R0,
-            pins: {'in0': <laygo2.object.physical.Pin object at 0x000001B1BA91FCA0>, 
-                   'out0': <laygo2.object.physical.Pin object at 0x000001B1BA91FC70>, 
-                   'in1': <laygo2.object.physical.Pin object at 0x000001B1BA91FC10>, 
-                   'out1': <laygo2.object.physical.Pin object at 0x000001B1BA91E8C0>, 
-                   'in2': <laygo2.object.physical.Pin object at 0x000001B1BA91E890>, 
-                   'out2': <laygo2.object.physical.Pin object at 0x000001B1BA91FBE0>, 
-                   'in3': <laygo2.object.physical.Pin object at 0x000001B1BA91E7D0>, 
-                   'out3': <laygo2.object.physical.Pin object at 0x000001B1BA91E710>},
-
-        .. image:: ../assets/img/object_template_ParameterizedInstanceTemplate_generate.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)** 템플릿으로부터 입력 파라미터에 따른 Instance 객체 생성.
-
-        파라미터
-            - name(str): 생성할 인스턴스의 이름.
-            - shape(numpy.ndarray): (optional) 생성할 객체의 배열 shape.
-            - pitch(numpy.ndarray): (optional) 생성할 객체 간의 간격.
-            - params(dict) : 개체의 속성이 담긴 dictionary.
-            - transform(str): 생성할 개체의 변환 속성.
-        반환값
-            - laygo2.Instance: 생성된 객체
-        """
-        # xy = xy + np.dot(self.xy(params)[0], tf.Mt(transform).T)
-        inst = laygo2.object.physical.Instance(
-            libname=self.libname,
-            cellname=self.cellname,
-            xy=np.array([0, 0]),
-            shape=shape,
-            pitch=pitch,
-            unit_size=self.size(params),
-            pins=self.pins(params),
-            transform=transform,
-            name=name,
-            params=params,
-        )
-        # update netnames if netmap is provided.
-        if netmap is not None:
-            inst.update_netname(netmap=netmap)  
-        return inst
-
-
-class UserDefinedTemplate(Template):
-    """
-    UserDefinedTemplate class implements the template that generates 
-    a VirtualInstance object corresponding to the template and input 
-    parameters.
-
-    Notes
-    -----
-    **(Korean)** UserDefinedTemplate 클래스는 VirtualInstance를 반환하는 
-    템플릿을 구현한다.
-
-    """
-
-    _bbox = None
-    """The internal pointer to the bbox computing function."""
-
-    _pins = None
-    """The internal pointer to the pin creation function."""
-
-    _generate = None
-    """The internal pointer to the instance generation function."""
-
-    def __init__(self, bbox_func, pins_func, generate_func, name=None):
-        """
-        Constructor function of UserDefinedTemplate class.
-
-        Parameters
-        ----------
-        bbox_func: callable
-            The function that computes the bounding box of the template from 
-            its input parameters.
-        pins_func: callable
-            The function that returns a dictionary that contains its pin 
-            objects for its input parameters.
-        generate_func: callable
-            The function that returns a generated VirtualInstance object 
-            for its input parameters.
-        name : str
-            The name of the template.
-
-        Returns
-        -------
-        laygo2.object.template.UserDefinedTemplate
-
-        Example
-        -------
-        >>> import numpy as np
-        >>> from laygo2.object.template import UserDefinedTemplate
-        >>> from laygo2.object.physical import Pin, Rect, VirtualInstance
-        >>> # bbox computation function.
-        >>> def user_bbox_func(params):
-        >>>     return np.array([[0, 0], [100 * params["mult"], 100]])
-        >>> # pin generation function.
-        >>> def user_pins_func(params):
-        >>>     template_pins = dict()
-        >>>     for i in range(params["mult"]):
-        >>>         template_pins["in" + str(i)] = Pin(
-        >>>             xy=[[i * 100 + 0, 0], [i * 100 + 10, 10]],
-        >>>             layer=["M1", "drawing"],
-        >>>             netname="in" + str(i),
-        >>>         )
-        >>>         template_pins["out" + str(i)] = Pin(
-        >>>             xy=[[i * 100 + 90, 90], [i * 100 + 90, 100]],
-        >>>             layer=["M1", "drawing"],
-        >>>             netname="out" + str(i),
-        >>>         )
-        >>>     return template_pins
-        >>> # instance generation function.
-        >>> def user_generate_func(
-        >>>     name=None, shape=None, pitch=np.array([0, 0]), transform="R0", 
-        >>>     params=None):
-        >>>     m = params["mult"]
-        >>>     shape = np.array([1, 1]) if shape is None else np.asarray(shape)
-        >>>     inst_pins = user_pins_func(params)
-        >>>     inst_native_elements = dict()
-        >>>     for i in range(m):
-        >>>         ofst = i * 100
-        >>>         inst_native_elements["R0_" + str(i)] = Rect(
-        >>>             xy=[[ofst, 0], [ofst + 10, 10]], layer=["M1", "drawing"]
-        >>>         )
-        >>>         inst_native_elements["R1_" + str(i)] = Rect(
-        >>>             xy=[[ofst + 90, 90], [ofst + 100, 100]], layer=["M1", "drawing"]
-        >>>         )
-        >>>     inst_native_elements["R2"] = Rect(
-        >>>         xy=[[0, 0], [m * 100, 100]], layer=["prBoundary", "drawing"]
-        >>>     )
-        >>>     inst = VirtualInstance(
-        >>>         name=name,
-        >>>         libname="mylib",
-        >>>         cellname="myvinst",
-        >>>         xy=np.array([0, 0]),
-        >>>         native_elements=inst_native_elements,
-        >>>         shape=shape,
-        >>>         pitch=pitch,
-        >>>         unit_size=[m * 100, 100],
-        >>>         pins=inst_pins,
-        >>>         transform=transform,
-        >>>         params=params,
-        >>>     )
-        >>>     return inst
-        >>> # UserDefinedTemplate construction.
-        >>> user_temp = UserDefinedTemplate(
-        >>>     name="myusertemplate",
-        >>>     bbox_func=user_bbox_func,
-        >>>     pins_func=user_pins_func,
-        >>>     generate_func=user_generate_func,
-        >>> )
-        >>> # VirtualInstance generation.
-        >>> user_inst = user_temp.generate(name="myinst", params={"mult": 5})
-        >>> # Display
-        >>> print(user_temp)
-            <laygo2.object.template.UserDefinedTemplate object at 0x00000192BF990130> 
-            name: myusertemplate, class: UserDefinedTemplate,
-        >>> print(user_inst)
-            <laygo2.object.physical.VirtualInstance object at 0x00000192BF990280>
-                name: myinst,
-                class: VirtualInstance,
-                xy: [0, 0],
-                params: {'mult': 5},
-                size: [500, 100],
-                shape: [1, 1],
-                pitch: [500, 100],
-                transform: R0,
-                pins: {'in0': <laygo2.object.physical.Pin object at 0x00000192BF9930D0>, 
-                       'out0': <laygo2.object.physical.Pin object at 0x00000192BF9931C0>, 
-                       'in1': <laygo2.object.physical.Pin object at 0x00000192BF993760>, 
-                       'out1': <laygo2.object.physical.Pin object at 0x00000192BF9936A0>, 
-                       'in2': <laygo2.object.physical.Pin object at 0x00000192BF993610>, 
-                       'out2': <laygo2.object.physical.Pin object at 0x00000192BF9935B0>, 
-                       'in3': <laygo2.object.physical.Pin object at 0x00000192BF9932E0>, 
-                       'out3': <laygo2.object.physical.Pin object at 0x00000192BF9931F0>, 
-                       'in4': <laygo2.object.physical.Pin object at 0x00000192BF993130>, 
-                       'out4': <laygo2.object.physical.Pin object at 0x00000192BF9930A0>},
-                native elements: {'R0_0': <laygo2.object.physical.Rect object at 0x0...>, 
-                                  'R1_0': <laygo2.object.physical.Rect object at 0x0...>, 
-                                  'R0_1': <laygo2.object.physical.Rect object at 0x0...>, 
-                                  'R1_1': <laygo2.object.physical.Rect object at 0x0...>, 
-                                  'R0_2': <laygo2.object.physical.Rect object at 0x0...>, 
-                                  'R1_2': <laygo2.object.physical.Rect object at 0x0...>, 
-                                  'R0_3': <laygo2.object.physical.Rect object at 0x0...>, 
-                                  'R1_3': <laygo2.object.physical.Rect object at 0x0...>, 
-                                  'R0_4': <laygo2.object.physical.Rect object at 0x0...>, 
-                                  'R1_4': <laygo2.object.physical.Rect object at 0x0...>, 
-                                  'R2': <laygo2.object.physical.Rect object at 0x000...>}
-        >>> print(user_inst.bbox)
-            [[  0   0]
-             [500 100]]
-
-        .. image:: ../assets/img/object_template_UserDefinedTemplate_init.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)** UserDefinedTemplate 클래스의 생성자 함수.
-        
-        파라미터
-            - bbox_func(callable): bbox를 연산하는 함수.
-            - pins_func(callable): pins를 생성하는 함수.
-            - generate_func(callable): VirtualInstance를 생성하는 함수.
-            - name(str): 템플릿 이름
-        반환값
-            - laygo2.object.template.UserDefinedTemplate
-        """
-        self._bbox = bbox_func
-        self._pins = pins_func
-        self._generate = generate_func
-        Template.__init__(self, name=name)
-
-    # Core template functions
-    def bbox(self, params=None):
-        """
-        Return bbox of UserDefinedTemplate object.
-
-        Parameters
-        ----------
-        params: dict
-            A dictionary that contains input parameters corresponding to the 
-            bounding box to be computed.
-
-        Returns
-        -------
-        numpy.ndarray: A 2x2 numpy array that contains the bounding box 
-            coordinates corresponding to the input parameters.
-
-        Example
-        -------
-        >>> import numpy as np
-        >>> from laygo2.object.template import UserDefinedTemplate
-        >>> from laygo2.object.physical import Pin, Rect, VirtualInstance
-        >>> # bbox computation function.
-        >>> def user_bbox_func(params):
-        >>>     return np.array([[0, 0], [100 * params["mult"], 100]])
-        >>> # pin generation function.
-        >>> def user_pins_func(params):
-        >>>     template_pins = dict()
-        >>>     for i in range(params["mult"]):
-        >>>         template_pins["in" + str(i)] = Pin(
-        >>>             xy=[[i * 100 + 0, 0], [i * 100 + 10, 10]],
-        >>>             layer=["M1", "drawing"],
-        >>>             netname="in" + str(i),
-        >>>         )
-        >>>         template_pins["out" + str(i)] = Pin(
-        >>>             xy=[[i * 100 + 90, 90], [i * 100 + 90, 100]],
-        >>>             layer=["M1", "drawing"],
-        >>>             netname="out" + str(i),
-        >>>         )
-        >>>     return template_pins
-        >>> # instance generation function.
-        >>> def user_generate_func(
-        >>>     name=None, shape=None, pitch=np.array([0, 0]), transform="R0", 
-        >>>     params=None):
-        >>>     m = params["mult"]
-        >>>     shape = np.array([1, 1]) if shape is None else np.asarray(shape)
-        >>>     inst_pins = user_pins_func(params)
-        >>>     inst_native_elements = dict()
-        >>>     for i in range(m):
-        >>>         ofst = i * 100
-        >>>         inst_native_elements["R0_" + str(i)] = Rect(
-        >>>             xy=[[ofst, 0], [ofst + 10, 10]], layer=["M1", "drawing"]
-        >>>         )
-        >>>         inst_native_elements["R1_" + str(i)] = Rect(
-        >>>             xy=[[ofst + 90, 90], [ofst + 100, 100]], layer=["M1", "drawing"]
-        >>>         )
-        >>>     inst_native_elements["R2"] = Rect(
-        >>>         xy=[[0, 0], [m * 100, 100]], layer=["prBoundary", "drawing"]
-        >>>     )
-        >>>     inst = VirtualInstance(
-        >>>         name=name,
-        >>>         libname="mylib",
-        >>>         cellname="myvinst",
-        >>>         xy=np.array([0, 0]),
-        >>>         native_elements=inst_native_elements,
-        >>>         shape=shape,
-        >>>         pitch=pitch,
-        >>>         unit_size=[m * 100, 100],
-        >>>         pins=inst_pins,
-        >>>         transform=transform,
-        >>>         params=params,
-        >>>     )
-        >>>     return inst
-        >>> # UserDefinedTemplate construction.
-        >>> user_temp = UserDefinedTemplate(
-        >>>     name="myusertemplate",
-        >>>     bbox_func=user_bbox_func,
-        >>>     pins_func=user_pins_func,
-        >>>     generate_func=user_generate_func,
-        >>> )
-        >>> user_temp.bbox(params={"mult": 5})
-        array([[  0,   0],
-               [500, 100]])
-
-        .. image:: ../assets/img/object_template_UserDefinedTemplate_bbox.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)** UserDefinedTemplate 객체의 bbox 반환.
-        """
-        return self._bbox(params=params)
-
-    def pins(self, params=None):
-        """
-        Pins of UserDefinedTemplate object.
-
-        Parameters
-        ----------
-        params: dict
-            A dictionary that contains input parameters corresponding to the 
-            pin objects to be produced.
-
-        Returns
-        -------
-        dict: A dictionary that contains pin object corresponding to the 
-            input parameters.
-
-        Example
-        -------
-        >>> import numpy as np
-        >>> from laygo2.object.template import UserDefinedTemplate
-        >>> from laygo2.object.physical import Pin, Rect, VirtualInstance
-        >>> # bbox computation function.
-        >>> def user_bbox_func(params):
-        >>>     return np.array([[0, 0], [100 * params["mult"], 100]])
-        >>> # pin generation function.
-        >>> def user_pins_func(params):
-        >>>     template_pins = dict()
-        >>>     for i in range(params["mult"]):
-        >>>         template_pins["in" + str(i)] = Pin(
-        >>>             xy=[[i * 100 + 0, 0], [i * 100 + 10, 10]],
-        >>>             layer=["M1", "drawing"],
-        >>>             netname="in" + str(i),
-        >>>         )
-        >>>         template_pins["out" + str(i)] = Pin(
-        >>>             xy=[[i * 100 + 90, 90], [i * 100 + 90, 100]],
-        >>>             layer=["M1", "drawing"],
-        >>>             netname="out" + str(i),
-        >>>         )
-        >>>     return template_pins
-        >>> # instance generation function.
-        >>> def user_generate_func(
-        >>>     name=None, shape=None, pitch=np.array([0, 0]), transform="R0", 
-        >>>     params=None):
-        >>>     m = params["mult"]
-        >>>     shape = np.array([1, 1]) if shape is None else np.asarray(shape)
-        >>>     inst_pins = user_pins_func(params)
-        >>>     inst_native_elements = dict()
-        >>>     for i in range(m):
-        >>>         ofst = i * 100
-        >>>         inst_native_elements["R0_" + str(i)] = Rect(
-        >>>             xy=[[ofst, 0], [ofst + 10, 10]], layer=["M1", "drawing"]
-        >>>         )
-        >>>         inst_native_elements["R1_" + str(i)] = Rect(
-        >>>             xy=[[ofst + 90, 90], [ofst + 100, 100]], layer=["M1", "drawing"]
-        >>>         )
-        >>>     inst_native_elements["R2"] = Rect(
-        >>>         xy=[[0, 0], [m * 100, 100]], layer=["prBoundary", "drawing"]
-        >>>     )
-        >>>     inst = VirtualInstance(
-        >>>         name=name,
-        >>>         libname="mylib",
-        >>>         cellname="myvinst",
-        >>>         xy=np.array([0, 0]),
-        >>>         native_elements=inst_native_elements,
-        >>>         shape=shape,
-        >>>         pitch=pitch,
-        >>>         unit_size=[m * 100, 100],
-        >>>         pins=inst_pins,
-        >>>         transform=transform,
-        >>>         params=params,
-        >>>     )
-        >>>     return inst
-        >>> # UserDefinedTemplate construction.
-        >>> user_temp = UserDefinedTemplate(
-        >>>     name="myusertemplate",
-        >>>     bbox_func=user_bbox_func,
-        >>>     pins_func=user_pins_func,
-        >>>     generate_func=user_generate_func,
-        >>> )
-        >>> user_temp.pins(params={"mult": 5})
-        {'in0': <laygo2.object.physical.Pin object at 0x00000192BF990670>, 
-        'out0': <laygo2.object.physical.Pin object at 0x00000192BF990400>, 
-        'in1': <laygo2.object.physical.Pin object at 0x00000192BF993250>, 
-        'out1': <laygo2.object.physical.Pin object at 0x00000192BF9903D0>, 
-        'in2': <laygo2.object.physical.Pin object at 0x00000192BF9901F0>, 
-        'out2': <laygo2.object.physical.Pin object at 0x00000192BF9904F0>, 
-        'in3': <laygo2.object.physical.Pin object at 0x00000192BF993640>, 
-        'out3': <laygo2.object.physical.Pin object at 0x00000192BF990520>, 
-        'in4': <laygo2.object.physical.Pin object at 0x00000192BF9936D0>, 
-        'out4': <laygo2.object.physical.Pin object at 0x00000192BF993790>}
-
-        .. image:: ../assets/img/object_template_UserDefinedTemplate_pins.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)** UserDefinedTemplate 객체의 pin dictionary를 생성 및 반환하는 함수.
-        """
-        return self._pins(params=params)
-
-    def generate(self, name=None, shape=None, pitch=None, transform="R0", netmap=None, params=None):
-        """
-        Generate a VirtualInstance object by calling generate_func() bound to the template.
-
-        Parameters
-        ----------
-        name : str
-            name of the instance to be generated.
-        shape : numpy.ndarray, optional.
-            shape of the object to be generated.
-        pitch : numpy.ndarray, optional.
-            pitch of the object to be generated.
-        transform : str, optional.
-            transformation attribute of the entity to be generated.
-        netmap : dict, optional.
-            dictionary containing netmap conversion information of pins.
-        params : dict, optional.
-            dictionary having the entity attributes.
-
-        Returns
-        -------
-        laygo2.object.physical.VirtualInstance: The generated VirtualInstance object.
-
-        Example
-        -------
-        >>> import numpy as np
-        >>> from laygo2.object.template import UserDefinedTemplate
-        >>> from laygo2.object.physical import Pin, Rect, VirtualInstance
-        >>> # bbox computation function.
-        >>> def user_bbox_func(params):
-        >>>     return np.array([[0, 0], [100 * params["mult"], 100]])
-        >>> # pin generation function.
-        >>> def user_pins_func(params):
-        >>>     template_pins = dict()
-        >>>     for i in range(params["mult"]):
-        >>>         template_pins["in" + str(i)] = Pin(
-        >>>             xy=[[i * 100 + 0, 0], [i * 100 + 10, 10]],
-        >>>             layer=["M1", "drawing"],
-        >>>             netname="in" + str(i),
-        >>>         )
-        >>>         template_pins["out" + str(i)] = Pin(
-        >>>             xy=[[i * 100 + 90, 90], [i * 100 + 90, 100]],
-        >>>             layer=["M1", "drawing"],
-        >>>             netname="out" + str(i),
-        >>>         )
-        >>>     return template_pins
-        >>> # instance generation function.
-        >>> def user_generate_func(
-        >>>     name=None, shape=None, pitch=np.array([0, 0]), transform="R0", 
-        >>>     params=None):
-        >>>     m = params["mult"]
-        >>>     shape = np.array([1, 1]) if shape is None else np.asarray(shape)
-        >>>     inst_pins = user_pins_func(params)
-        >>>     inst_native_elements = dict()
-        >>>     for i in range(m):
-        >>>         ofst = i * 100
-        >>>         inst_native_elements["R0_" + str(i)] = Rect(
-        >>>             xy=[[ofst, 0], [ofst + 10, 10]], layer=["M1", "drawing"]
-        >>>         )
-        >>>         inst_native_elements["R1_" + str(i)] = Rect(
-        >>>             xy=[[ofst + 90, 90], [ofst + 100, 100]], layer=["M1", "drawing"]
-        >>>         )
-        >>>     inst_native_elements["R2"] = Rect(
-        >>>         xy=[[0, 0], [m * 100, 100]], layer=["prBoundary", "drawing"]
-        >>>     )
-        >>>     inst = VirtualInstance(
-        >>>         name=name,
-        >>>         libname="mylib",
-        >>>         cellname="myvinst",
-        >>>         xy=np.array([0, 0]),
-        >>>         native_elements=inst_native_elements,
-        >>>         shape=shape,
-        >>>         pitch=pitch,
-        >>>         unit_size=[m * 100, 100],
-        >>>         pins=inst_pins,
-        >>>         transform=transform,
-        >>>         params=params,
-        >>>     )
-        >>>     return inst
-        >>> # UserDefinedTemplate construction.
-        >>> user_temp = UserDefinedTemplate(
-        >>>     name="myusertemplate",
-        >>>     bbox_func=user_bbox_func,
-        >>>     pins_func=user_pins_func,
-        >>>     generate_func=user_generate_func,
-        >>> )
-        >>> # VirtualInstance generation.
-        >>> user_inst = user_temp.generate(name="myinst", params={"mult": 5})
-        >>> # Display
-        >>> print(user_temp)
-            <laygo2.object.template.UserDefinedTemplate object at 0x00000192BF990130> 
-            name: myusertemplate, class: UserDefinedTemplate,
-        >>> print(user_inst)
-            <laygo2.object.physical.VirtualInstance object at 0x00000192BF990280>
-                name: myinst,
-                class: VirtualInstance,
-                xy: [0, 0],
-                params: {'mult': 5},
-                size: [500, 100],
-                shape: [1, 1],
-                pitch: [500, 100],
-                transform: R0,
-                pins: {'in0': <laygo2.object.physical.Pin object at 0x00000192BF9930D0>, 
-                       'out0': <laygo2.object.physical.Pin object at 0x00000192BF9931C0>, 
-                       'in1': <laygo2.object.physical.Pin object at 0x00000192BF993760>, 
-                       'out1': <laygo2.object.physical.Pin object at 0x00000192BF9936A0>, 
-                       'in2': <laygo2.object.physical.Pin object at 0x00000192BF993610>, 
-                       'out2': <laygo2.object.physical.Pin object at 0x00000192BF9935B0>, 
-                       'in3': <laygo2.object.physical.Pin object at 0x00000192BF9932E0>, 
-                       'out3': <laygo2.object.physical.Pin object at 0x00000192BF9931F0>, 
-                       'in4': <laygo2.object.physical.Pin object at 0x00000192BF993130>, 
-                       'out4': <laygo2.object.physical.Pin object at 0x00000192BF9930A0>},
-                native elements: {'R0_0': <laygo2.object.physical.Rect object at 0x0...>, 
-                                  'R1_0': <laygo2.object.physical.Rect object at 0x0...>, 
-                                  'R0_1': <laygo2.object.physical.Rect object at 0x0...>, 
-                                  'R1_1': <laygo2.object.physical.Rect object at 0x0...>, 
-                                  'R0_2': <laygo2.object.physical.Rect object at 0x0...>, 
-                                  'R1_2': <laygo2.object.physical.Rect object at 0x0...>, 
-                                  'R0_3': <laygo2.object.physical.Rect object at 0x0...>, 
-                                  'R1_3': <laygo2.object.physical.Rect object at 0x0...>, 
-                                  'R0_4': <laygo2.object.physical.Rect object at 0x0...>, 
-                                  'R1_4': <laygo2.object.physical.Rect object at 0x0...>, 
-                                  'R2': <laygo2.object.physical.Rect object at 0x000...>}
-        >>> print(user_inst.bbox)
-            [[  0   0]
-             [500 100]]
-
-        .. image:: ../assets/img/object_template_UserDefinedTemplate_generate.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)** 템플릿으로부터 입력 파라미터에 따른 VirtualInstance 객체 생성.
-        파라미터
-            - name(str): 생성할 인스턴스의 이름.
-            - shape(numpy.ndarray): (optional) 생성할 객체의 배열 shape.
-            - pitch(numpy.ndarray): (optional) 생성할 객체 간의 간격.
-            - params(dict) : 개체의 속성이 담긴 dictionary.
-            - transform(str): 생성할 개체의 변환 속성.
-        반환값
-            - laygo2.VirtualInstance: 생성된 객체
-        """
-        inst = self._generate(
-            name=name, shape=shape, pitch=pitch, transform=transform, params=params
-        )
-        # update netnames if netmap is provided.
-        if netmap is not None:
-            inst.update_netname(netmap=netmap)  
-        return inst
-
-
-# Test
-if __name__ == "__main__":
-    test_native_template = True
-    test_pcell_template = True
-    test_user_template = True
-
-    import laygo2.object
-
-    if test_native_template:
-        print("NativeInstanceTemplate test")
-        # define pins
-        nat_temp_pins = dict()
-        nat_temp_pins["in"] = laygo2.object.Pin(
-            xy=[[0, 0], [10, 10]], layer=["M1", "drawing"], netname="in"
-        )
-        nat_temp_pins["out"] = laygo2.object.Pin(
-            xy=[[90, 90], [100, 100]], layer=["M1", "drawing"], netname="out"
-        )
-        # create a template
-        nat_temp = NativeInstanceTemplate(
-            libname="mylib",
-            cellname="mynattemplate",
-            bbox=[[0, 0], [100, 100]],
-            pins=nat_temp_pins,
-        )
-        # generate
-        nat_inst = nat_temp.generate(
-            name="mynatinst", shape=[2, 2], pitch=[100, 100], transform="R0"
-        )
-        # display
-        print(nat_temp)
-        print(nat_inst)
-
-    if test_pcell_template:
-        print("ParameterizedInstanceTemplate test")
-
-        # define the bbox computation function.
-        def pcell_bbox_func(params):
-            return np.array([[0, 0], [100 * params["mult"], 100]])
-
-        # define the pin generation function.
-        def pcell_pins_func(params):
-            template_pins = dict()
-            for i in range(params["mult"]):
-                template_pins["in" + str(i)] = laygo2.object.Pin(
-                    xy=[[i * 100 + 0, 0], [i * 100 + 10, 10]],
-                    layer=["M1", "drawing"],
-                    netname="in" + str(i),
-                )
-                template_pins["out" + str(i)] = laygo2.object.Pin(
-                    xy=[[i * 100 + 90, 90], [i * 100 + 90, 100]],
-                    layer=["M1", "drawing"],
-                    netname="out" + str(i),
-                )
-            return template_pins
-
-        # create a template.
-        pcell_temp = ParameterizedInstanceTemplate(
-            libname="mylib",
-            cellname="mypcelltemplate",
-            bbox_func=pcell_bbox_func,
-            pins_func=pcell_pins_func,
-        )
-        # generate based on the parameter assigned.
-        pcell_inst_params = {"mult": 4}
-        pcell_inst_size = pcell_temp.size(params=pcell_inst_params)
-        pcell_inst = pcell_temp.generate(
-            name="mypcellinst",
-            shape=[2, 2],
-            pitch=pcell_inst_size,
-            transform="R0",
-            params=pcell_inst_params,
-        )
-        # display
-        print(pcell_temp)
-        print(pcell_inst)
-
-    if test_user_template:
-        print("UserDefinedTemplate test")
-
-        # define the bbox computation function.
-        def user_bbox_func(params):
-            return np.array([[0, 0], [100 * params["mult"], 100]])
-
-        # define the pin generation function.
-        def user_pins_func(params):
-            template_pins = dict()
-            for i in range(params["mult"]):
-                template_pins["in" + str(i)] = laygo2.object.Pin(
-                    xy=[[i * 100 + 0, 0], [i * 100 + 10, 10]],
-                    layer=["M1", "drawing"],
-                    netname="in" + str(i),
-                )
-                template_pins["out" + str(i)] = laygo2.object.Pin(
-                    xy=[[i * 100 + 90, 90], [i * 100 + 90, 100]],
-                    layer=["M1", "drawing"],
-                    netname="out" + str(i),
-                )
-            return template_pins
-
-        # define the instance generation function.
-        def user_generate_func(
-            name=None, shape=None, pitch=np.array([0, 0]), transform="R0", params=None
-        ):
-            m = params["mult"]
-            shape = np.array([1, 1]) if shape is None else np.asarray(shape)
-
-            inst_pins = user_pins_func(params)
-            inst_native_elements = dict()
-            for i in range(m):
-                ofst = i * 100
-                inst_native_elements["R0_" + str(i)] = laygo2.object.Rect(
-                    xy=[[ofst, 0], [ofst + 10, 10]], layer=["M1", "drawing"]
-                )
-                inst_native_elements["R1_" + str(i)] = laygo2.object.Rect(
-                    xy=[[ofst + 90, 90], [ofst + 100, 100]], layer=["M1", "drawing"]
-                )
-            inst_native_elements["R2"] = laygo2.object.Rect(
-                xy=[[0, 0], [m * 100, 100]], layer=["prBoundary", "drawing"]
-            )
-            inst = laygo2.object.VirtualInstance(
-                name=name,
-                libname="mylib",
-                cellname="myvinst",
-                xy=np.array([0, 0]),
-                native_elements=inst_native_elements,
-                shape=shape,
-                pitch=pitch,
-                unit_size=[m * 100, 100],
-                pins=inst_pins,
-                transform=transform,
-                params=params,
-            )
-            return inst
-
-        user_temp = UserDefinedTemplate(
-            name="myusertemplate",
-            bbox_func=user_bbox_func,
-            pins_func=user_pins_func,
-            generate_func=user_generate_func,
-        )
-        user_inst = user_temp.generate(
-            name="myuserinst", shape=[2, 1], params={"mult": 5}
-        )
-        print(user_temp)
-        print(user_inst)
-        print(user_inst.bbox)
+#!/usr/bin/python
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+__author__ = "Jaeduk Han"
+__maintainer__ = "Jaeduk Han"
+__status__ = "Prototype"
+
+from abc import *
+import numpy as np
+import laygo2.object
+
+
+class Template(metaclass=ABCMeta):
+    """
+    The base class that defines the functions and attributes of the template.
+
+    Notes
+    -----
+    **(Korean)** Template의 기본동작과 속성을 정의한 기본 클래스.
+    """
+
+    name = None
+    """str: Template name."""
+
+    def __init__(self, name=None):
+        """
+        The constructor function.
+
+        Parameters
+        ----------
+        name : str or None, optional.
+            The name of this template.
+        """
+        self.name = name
+
+    def __str__(self):
+        """Return a string representation of this template's information. """
+        return self.summarize()
+
+    def summarize(self):
+        """Return the summary of the template information."""
+        return (
+            self.__repr__() + " "
+            "name: "
+            + self.name
+            + ", "
+            + "class: "
+            + self.__class__.__name__
+            + ", "
+            + ""
+        )
+
+    def height(self, params=None):
+        """int: Return the height of the template."""
+        return abs(self.bbox(params=params)[0, 1] - self.bbox(params=params)[1, 1])
+
+    def width(self, params=None):
+        """int: Return the width of the template."""
+        return abs(self.bbox(params=params)[0, 0] - self.bbox(params=params)[1, 0])
+
+    def size(self, params=None):
+        """int: Return the size of the template."""
+        return np.array([self.width(params=params), self.height(params=params)])
+
+    @abstractmethod
+    def bbox(self, params=None):
+        """numpy.ndarray: (Abstract method) the physical bounding box of the template."""
+        pass
+
+    @abstractmethod
+    def pins(self, params=None):
+        """dict: (Abstract method) Dictionary storing the pins of the template."""
+        pass
+
+    @abstractmethod
+    def generate(self, name=None, shape=None, pitch=None, transform="R0", netmap=None, params=None):
+        """instance: (Abstract method) Generate an instance from the template."""
+        pass
+        
+
+
+class NativeInstanceTemplate(Template):
+    """
+    NativeInstanceTemplate class implements the template that generate Instance.
+
+    Notes
+    -----
+    **(Korean)** NativeInstanceTemplate 클래스는 기본 Instance를 반환하는 템플릿을 구현한다.
+    """
+
+    libname = None
+    """str: Library name.
+
+    Example
+    -------
+    >>> from laygo2.object.physical import Pin
+    >>> from laygo2.object.template import NativeInstanceTemplate
+    >>> p = dict() 
+    >>> p['i'] = Pin(xy=[[0, 0], [10, 10]], layer=['M1', 'drawing'], 
+                     netname='i')
+    >>> p['o'] = Pin(xy=[[90, 90], [100, 100]], layer=['M1', 'drawing'], 
+                     netname='o')
+    >>> nt = NativeInstanceTemplate(libname='mylib', cellname='mytemp', 
+                                    bbox=[[0, 0], [100, 100]], pins=p)
+    >>> nt.libname 
+    'mylib'
+    
+    .. image:: ../assets/img/object_template_NativeInstanceTemplate_libname.png
+          :height: 250
+
+    Notes
+    -----
+    **(Korean)** NativeInstanceTemplate 객체의 library 이름.
+    """
+
+    cellname = None
+    """str: Cell name.
+
+    Example
+    -------
+    >>> from laygo2.object.physical import Pin
+    >>> from laygo2.object.template import NativeInstanceTemplate
+    >>> p = dict() 
+    >>> p['i'] = Pin(xy=[[0, 0], [10, 10]], layer=['M1', 'drawing'], 
+                     netname='i')
+    >>> p['o'] = Pin(xy=[[90, 90], [100, 100]], layer=['M1', 'drawing'], 
+                     netname='o')
+    >>> nt = NativeInstanceTemplate(libname='mylib', cellname='mytemp', 
+                                    bbox=[[0, 0], [100, 100]], pins=p)
+    >>> nt.cellname 
+    'mytemp'
+    
+    .. image:: ../assets/img/object_template_NativeInstanceTemplate_cellname.png
+          :height: 250
+
+    Notes
+    -----
+    **(Korean)** NativeInstanceTemplate 객체의 cellname.
+    """
+
+    _bbox = np.array([[0, 0], [0, 0]])
+
+    _pins = None
+
+    def __init__(self, libname, cellname, bbox=np.array([[0, 0], [0, 0]]), pins=None):
+        """
+        Constructor function.
+
+        Parameters
+        ----------
+        libname : str
+            Library name.
+        cellname : str
+            Cell name.
+        bbox : numpy.ndarray
+            Bounding box of the object.
+        pins : dict
+            Dictionary storing the template's pin objects.
+
+        Returns
+        -------
+        NativeInstanceTemplate
+
+        Example
+        -------
+        >>> from laygo2.object.physical import Pin
+        >>> from laygo2.object.template import NativeInstanceTemplate
+        >>> p = dict() 
+        >>> p['i'] = Pin(xy=[[0, 0], [10, 10]], layer=['M1', 'drawing'], 
+                         netname='i')
+        >>> p['o'] = Pin(xy=[[90, 90], [100, 100]], layer=['M1', 'drawing'], 
+                         netname='o')
+        >>> nt = NativeInstanceTemplate(libname='mylib', cellname='mytemp', 
+                                        bbox=[[0, 0], [100, 100]], pins=p)
+        <laygo2.object.template.NativeInstanceTemplate object>
+        >>> print(nt)
+        <laygo2.object.template.NativeInstanceTemplate object at 0x0000013C01..> 
+         name: mytemp, class: NativeInstanceTemplate, bbox: [[0, 0], [100, 100]], 
+         pins: {'i': <laygo2.object.physical.Pin object at 0x0000013C01CEFDC0>, 
+                'o': <laygo2.object.physical.Pin object at 0x0000013C01C30BE0>},
+
+        .. image:: ../assets/img/object_template_NativeInstanceTemplate_init.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)** NativeInstanceTemplate 클래스의 생성자함수.
+        """
+        self.libname = libname
+        self.cellname = cellname
+        self._bbox = None if bbox is None else np.asarray(bbox)
+        self._pins = pins
+        Template.__init__(self, name=cellname)
+
+    def summarize(self):
+        """Return the summary of the object information."""
+        return (
+            self.__repr__() + " "
+            "name: "
+            + self.name
+            + ", "
+            + "class: "
+            + self.__class__.__name__
+            + ", "
+            + "bbox: "
+            + str(self.bbox().tolist())
+            + ", "
+            + "pins: "
+            + str(self.pins())
+            + ", "
+            + ""
+        )
+
+    # Core template functions
+    def bbox(self, params=None):
+        """
+        Bounding box of the object.
+
+        Parameters
+        ----------
+        None
+
+        Returns
+        -------
+        numpy.ndarray
+
+        Example
+        -------
+        >>> from laygo2.object.physical import Pin
+        >>> from laygo2.object.template import NativeInstanceTemplate
+        >>> p = dict() 
+        >>> p['i'] = Pin(xy=[[0, 0], [10, 10]], layer=['M1', 'drawing'], 
+                         netname='i')
+        >>> p['o'] = Pin(xy=[[90, 90], [100, 100]], layer=['M1', 'drawing'], 
+                         netname='o')
+        >>> nt = NativeInstanceTemplate(libname='mylib', cellname='mytemp', 
+                                        bbox=[[0, 0], [100, 100]], pins=p)
+        >>> nt.bbox()
+        array([[  0,   0],
+               [100, 100]])
+
+        .. image:: ../assets/img/object_template_NativeInstanceTemplate_bbox.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)** NativeInstanceTemplate 객체의 bbox.
+        """
+        return self._bbox
+
+    def pins(self, params=None):
+        """
+        Dictionary storing pins of the object.
+
+        Parameters
+        ----------
+        None
+
+        Returns
+        -------
+        dict : Dictionary storing pin objects.
+
+        Example
+        -------
+        >>> from laygo2.object.physical import Pin
+        >>> from laygo2.object.template import NativeInstanceTemplate
+        >>> p = dict() 
+        >>> p['i'] = Pin(xy=[[0, 0], [10, 10]], layer=['M1', 'drawing'], 
+                         netname='i')
+        >>> p['o'] = Pin(xy=[[90, 90], [100, 100]], layer=['M1', 'drawing'], 
+                         netname='o')
+        >>> nt = NativeInstanceTemplate(libname='mylib', cellname='mytemp', 
+                                        bbox=[[0, 0], [100, 100]], pins=p)
+        >>> nt.pins()
+        >>> {'i': <laygo2.object.physical.Pin object at 0x000002578C762500>, 
+             'o': <laygo2.object.physical.Pin object at 0x00000257FBA87C40>}                   
+        >>> print(nt.pins()['i']) 
+            <laygo2.object.physical.Pin object at 0x000002578C762500> 
+                name: None,
+                class: Pin,
+                xy: [[0, 0], [10, 10]],
+                params: None, 
+                layer: ['M1' 'drawing'], 
+                netname: i, 
+                shape: None, 
+                master: None
+
+        .. image:: ../assets/img/object_template_ParameterizedInstanceTemplate_pins.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)** NativeInstanceTemplate 객체의 pin dictionary 반환.
+        """
+        return self._pins
+
+    def generate(self, name=None, shape=None, pitch=None, transform="R0", netmap=None, params=None):
+        """
+        Generate Instance object.
+
+        Parameters
+        ----------
+        name : str
+            Name of the instance to be generated.
+        shape : numpy.ndarray, optional.
+            Shape of the object to be generated.
+        pitch : numpy.ndarray, optional.
+            Element pitch of the array object to be generated.
+        transform : str
+            Transformation attribute of the object to be generated.
+        netmap : dict, optional.
+            Dictionary storing net-pin conversion mappings.
+        params : dict, optional.
+            Dictionary storing the parameters associated with the object.
+
+        Returns
+        -------
+        (laygo2.object.physical.Instance) generated Instance object
+
+        See Also
+        --------
+        Class Instance
+
+        Example
+        -------
+        >>> from laygo2.object.physical import Pin
+        >>> from laygo2.object.template import NativeInstanceTemplate
+        >>> p = dict() 
+        >>> p['i'] = Pin(xy=[[0, 0], [10, 10]], layer=['M1', 'drawing'], 
+                         netname='i')
+        >>> p['o'] = Pin(xy=[[90, 90], [100, 100]], layer=['M1', 'drawing'], 
+                         netname='o')
+        >>> nt = NativeInstanceTemplate(libname='mylib', cellname='mytemp', 
+                                        bbox=[[0, 0], [100, 100]], pins=p)
+        >>> i0 = nt.generate(name="I0")
+        >>> i1 = nt.generate(name="I1")
+        >>> print(i0)
+        <laygo2.object.physical.Instance object at 0x000002C3F717F850> 
+        name: I0,
+        class: Instance,
+        xy: [0, 0],
+        params: None,
+        size: [100, 100],
+        shape: None,
+        pitch: [100, 100],
+        transform: R0,
+        pins: {'i': <laygo2.object.physical.Pin object at 0x000002C3F717F820>, 
+               'o': <laygo2.object.physical.Pin object at 0x000002C3F717FD90>},
+        >>> print(i1)
+        <laygo2.object.physical.Instance object at 0x000002C3FF91C100> 
+        name: I1,
+        class: Instance,
+        xy: [0, 0],
+        params: None,
+        size: [100, 100],
+        shape: None,
+        pitch: [100, 100],
+        transform: R0,
+        pins: {'i': <laygo2.object.physical.Pin object at 0x000002C3FF91C0A0>, 
+               'o': <laygo2.object.physical.Pin object at 0x000002C3FF91C070>},
+        
+        .. image:: ../assets/img/object_template_ParameterizedInstanceTemplate_generate.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)** 템플릿으로부터 Instance 객체 생성.
+        """
+        inst = laygo2.object.physical.Instance(
+            libname=self.libname,
+            cellname=self.cellname,
+            xy=np.array([0, 0]),
+            shape=shape,
+            pitch=pitch,
+            unit_size=self.size(params),
+            pins=self.pins(params),
+            transform=transform,
+            name=name,
+            params=params,
+        )
+        # update netnames if netmap is provided.
+        if netmap is not None:
+            inst.update_netname(netmap=netmap)  
+        return inst 
+
+    # I/O functions
+    def export_to_dict(self):
+        """
+        Return a dictionary containing the template information.
+
+        Parameters
+        ----------
+        None
+
+        Returns
+        -------
+        dict
+
+        See Also
+        --------
+        Class Instance
+
+        Example
+        -------
+        >>> from laygo2.object.physical import Pin
+        >>> from laygo2.object.template import NativeInstanceTemplate
+        >>> p = dict() 
+        >>> p['i'] = Pin(xy=[[0, 0], [10, 10]], layer=['M1', 'drawing'], 
+                         netname='i')
+        >>> p['o'] = Pin(xy=[[90, 90], [100, 100]], layer=['M1', 'drawing'], 
+                         netname='o')
+        >>> nt = NativeInstanceTemplate(libname='mylib', cellname='mytemp', 
+                                        bbox=[[0, 0], [100, 100]], pins=p)
+        >>> nt.export_to_dict()
+            {'libname': 'mylib', 
+             'cellname': 'mytemp', 
+             'bbox': [[0, 0], [100, 100]], 
+             'pins': {'i': {'xy': [[0, 0], [10, 10]], 
+                            'layer': ['M1', 'drawing'], 
+                            'name': None, 
+                            'netname': 'i'}, 
+                      'o': {'xy': [[90, 90], [100, 100]], 
+                            'layer': ['M1', 'drawing'], 
+                            'name': None, 
+                            'netname': 'o'}
+                     }
+            }
+
+        .. image:: ../assets/img/object_template_NativeInstanceTemplate_export_to_dict.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)** NativeInstanceTemplate 의 정보가 담긴 Dictonary 반환.
+        """
+        db = dict()
+        db["libname"] = self.libname
+        db["cellname"] = self.cellname
+        db["bbox"] = self.bbox().tolist()
+        db["pins"] = dict()
+        for pn, p in self.pins().items():
+            db["pins"][pn] = p.export_to_dict()
+        return db
+
+
+class ParameterizedInstanceTemplate(Template):
+    """
+    The ParameterizedInstanceTemplate class implements a template for 
+    generating instances with varying size (bounding box) and pin 
+    configurations based on input parameters, such as instances mapped 
+    to Cadence Virtuoso's pcells or Pycells.
+
+    Notes
+    -----
+    **(Korean)** ParameterizedInstanceTemplate 클래스는 입력 파라미터에 따라 
+    크기와 pin 정보가 가변하는 인스턴스를 생성하는 템플릿을 구현한다. 
+    """
+
+    libname = None
+    """str: The libname of the instance to be generated."""
+
+    cellname = None
+    """str: The cellname of the instance to be generated."""
+
+    _bbox = None
+
+    _pins = None
+
+    def __init__(self, libname, cellname, bbox_func=None, pins_func=None):
+        """
+        Constructor of ParameterizedInstanceTemplate class.
+
+        Parameters
+        ----------
+        libname : str
+            The library name.
+        cellname : str
+            The cell name of the template.
+        bbox_func : callable
+            The function that computes the bounding box of the template from 
+            its input parameters.
+        pins_func : callable
+            The function that returns a dictionary that contains its pin 
+            objects for its input parameters.
+
+        Returns
+        -------
+        laygo2.object.template.ParameterizedInstanceTemplate
+
+        Example
+        -------
+        >>> import numpy as np
+        >>> from laygo2.object.template import ParameterizedInstanceTemplate
+        >>> from laygo2.object.physical import Pin
+        >>> # bbox computation function.
+        >>> def pcell_bbox_func(params):
+                return np.array([[0, 0], [100 * params["mult"], 100]])
+        >>> # pin generation function.
+        >>> def pcell_pins_func(params):
+        >>>     template_pins = dict()
+        >>>     for i in range(params["mult"]):
+        >>>         template_pins["in" + str(i)] = Pin(
+        >>>             xy=[[i * 100 + 0, 0], [i * 100 + 10, 10]],
+        >>>             layer=["M1", "drawing"],
+        >>>             netname="in" + str(i),
+        >>>         )
+        >>>         template_pins["out" + str(i)] = Pin(
+        >>>             xy=[[i * 100 + 90, 90], [i * 100 + 90, 100]],
+        >>>             layer=["M1", "drawing"],
+        >>>             netname="out" + str(i),
+        >>>         )
+        >>>     return template_pins
+        >>> # Create a template
+        >>> pcell_temp = ParameterizedInstanceTemplate(
+        >>>     libname="mylib",
+        >>>     cellname="mypcelltemplate",
+        >>>     bbox_func=pcell_bbox_func,
+        >>>     pins_func=pcell_pins_func,
+        >>> )
+        >>> # Generate an instance for input parameters.
+        >>> pcell_inst_params = {"mult": 4}
+        >>> pcell_inst = pcell_temp.generate(
+        >>>    name="mypcellinst",
+        >>>    transform="R0",
+        >>>    params=pcell_inst_params,
+        >>> )
+        >>> # display
+        >>> print(pcell_temp)
+            <laygo2.object.template.ParameterizedInstanceTemplate object at 0x000001B1BA91D9C0>
+            name: mypcelltemplate, 
+            class: ParameterizedInstanceTemplate,
+        >>> print(pcell_inst)
+            xy: [0, 0],
+            params: {'mult': 4},
+            size: [400, 100],
+            shape: None,
+            pitch: [400, 100],
+            transform: R0,
+            pins: {'in0': <laygo2.object.physical.Pin object at 0x000001B1BA91FCA0>, 
+                   'out0': <laygo2.object.physical.Pin object at 0x000001B1BA91FC70>, 
+                   'in1': <laygo2.object.physical.Pin object at 0x000001B1BA91FC10>, 
+                   'out1': <laygo2.object.physical.Pin object at 0x000001B1BA91E8C0>, 
+                   'in2': <laygo2.object.physical.Pin object at 0x000001B1BA91E890>, 
+                   'out2': <laygo2.object.physical.Pin object at 0x000001B1BA91FBE0>, 
+                   'in3': <laygo2.object.physical.Pin object at 0x000001B1BA91E7D0>, 
+                   'out3': <laygo2.object.physical.Pin object at 0x000001B1BA91E710>},
+
+        .. image:: ../assets/img/object_template_ParameterizedInstanceTemplate_init.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)** ParameterizedInstanceTemplate 클래스의 생성자함수.
+        """
+        self.libname = libname
+        self.cellname = cellname
+        self._bbox = bbox_func
+        self._pins = pins_func
+        Template.__init__(self, name=cellname)
+
+    # Core template functions
+    def bbox(self, params=None):
+        """
+        Bounding box of the template object.
+
+        Parameters
+        ----------
+        params: dict
+            A dictionary that contains input parameters corresponding to the 
+            bounding box to be computed.
+
+        Returns
+        -------
+        numpy.ndarray: A 2x2 numpy array that contains the bounding box 
+            coordinates corresponding to the input parameters.
+
+        Example
+        -------
+        >>> import numpy as np
+        >>> from laygo2.object.template import ParameterizedInstanceTemplate
+        >>> from laygo2.object.physical import Pin
+        >>> # bbox computation function.
+        >>> def pcell_bbox_func(params):
+                return np.array([[0, 0], [100 * params["mult"], 100]])
+        >>> # pin generation function.
+        >>> def pcell_pins_func(params):
+        >>>     template_pins = dict()
+        >>>     for i in range(params["mult"]):
+        >>>         template_pins["in" + str(i)] = Pin(
+        >>>             xy=[[i * 100 + 0, 0], [i * 100 + 10, 10]],
+        >>>             layer=["M1", "drawing"],
+        >>>             netname="in" + str(i),
+        >>>         )
+        >>>         template_pins["out" + str(i)] = Pin(
+        >>>             xy=[[i * 100 + 90, 90], [i * 100 + 90, 100]],
+        >>>             layer=["M1", "drawing"],
+        >>>             netname="out" + str(i),
+        >>>         )
+        >>>     return template_pins
+        >>> # Create a template
+        >>> pcell_temp = ParameterizedInstanceTemplate(
+        >>>     libname="mylib",
+        >>>     cellname="mypcelltemplate",
+        >>>     bbox_func=pcell_bbox_func,
+        >>>     pins_func=pcell_pins_func,
+        >>> )
+        >>> # Compute bbox for input parameters
+        >>> pcell_inst_params = {"mult": 4}
+        >>> pcell_temp.bbox(params=pcell_inst_params)
+        array([[  0,   0],
+               [400, 100]])
+
+        .. image:: ../assets/img/object_template_ParameterizedInstanceTemplate_bbox.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)** ParameterizedInstanceTemplate 객체의 bbox.
+        """
+        return self._bbox(params=params)
+
+    def pins(self, params=None):
+        """
+        Return pin dictionary of ParameterizedInstanceTemplate object.
+
+        Parameters
+        ----------
+        params: dict
+            A dictionary that contains input parameters corresponding to the 
+            pin objects to be produced.
+
+        Returns
+        -------
+        dict: A dictionary that contains pin object corresponding to the 
+            input parameters.
+
+        Example
+        -------
+        >>> import numpy as np
+        >>> from laygo2.object.template import ParameterizedInstanceTemplate
+        >>> from laygo2.object.physical import Pin
+        >>> # bbox computation function.
+        >>> def pcell_bbox_func(params):
+                return np.array([[0, 0], [100 * params["mult"], 100]])
+        >>> # pin generation function.
+        >>> def pcell_pins_func(params):
+        >>>     template_pins = dict()
+        >>>     for i in range(params["mult"]):
+        >>>         template_pins["in" + str(i)] = Pin(
+        >>>             xy=[[i * 100 + 0, 0], [i * 100 + 10, 10]],
+        >>>             layer=["M1", "drawing"],
+        >>>             netname="in" + str(i),
+        >>>         )
+        >>>         template_pins["out" + str(i)] = Pin(
+        >>>             xy=[[i * 100 + 90, 90], [i * 100 + 90, 100]],
+        >>>             layer=["M1", "drawing"],
+        >>>             netname="out" + str(i),
+        >>>         )
+        >>>     return template_pins
+        >>> # Create a template
+        >>> pcell_temp = ParameterizedInstanceTemplate(
+        >>>     libname="mylib",
+        >>>     cellname="mypcelltemplate",
+        >>>     bbox_func=pcell_bbox_func,
+        >>>     pins_func=pcell_pins_func,
+        >>> )
+        >>> # Compute bbox for input parameters
+        >>> pcell_inst_params = {"mult": 4}
+        >>> pcell_temp.pins(params=pcell_inst_params)
+            {'in0': <laygo2.object.physical.Pin object at 0x000001B1BA91F7C0>, 
+             'out0': <laygo2.object.physical.Pin object at 0x000001B1BA91E830>,
+             'in1': <laygo2.object.physical.Pin object at 0x000001B1BA91DAB0>, 
+             'out1': <laygo2.object.physical.Pin object at 0x000001B1BA91E860>, 
+             'in2': <laygo2.object.physical.Pin object at 0x000001B1BA91E560>, 
+             'out2': <laygo2.object.physical.Pin object at 0x000001B1BA91E800>, 
+             'in3': <laygo2.object.physical.Pin object at 0x000001B1BA91E770>, 
+             'out3': <laygo2.object.physical.Pin object at 0x000001B1BA91EA40>}
+
+        .. image:: ../assets/img/object_template_ParameterizedInstanceTemplate_pins.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)** ParameterizedInstanceTemplate 객체의 pin dictionary 반환.
+        """
+        return self._pins(params=params)
+
+    def generate(self, name=None, shape=None, pitch=None, transform="R0", netmap=None, params=None):
+        """
+        Generate an Instance object corresponding to the template and its 
+        input parameters.
+
+        Parameters
+        ----------
+        name : str
+            name of the instance to be generated.
+        shape : numpy.ndarray, optional.
+            shape of the object to be generated.
+        pitch : numpy.ndarray, optional.
+            pitch of the object to be generated.
+        transform : str, optional.
+            transformation attribute of the entity to be generated.
+        netmap : dict, optional.
+            dictionary containing netmap conversion information of pins.
+        params : dict, optional.
+            dictionary having the entity attributes.
+
+        Returns
+        -------
+        laygo2.object.physical.Instance: The generated Instance object
+
+        Example
+        -------
+        >>> import numpy as np
+        >>> from laygo2.object.template import ParameterizedInstanceTemplate
+        >>> from laygo2.object.physical import Pin
+        >>> # bbox computation function.
+        >>> def pcell_bbox_func(params):
+                return np.array([[0, 0], [100 * params["mult"], 100]])
+        >>> # pin generation function.
+        >>> def pcell_pins_func(params):
+        >>>     template_pins = dict()
+        >>>     for i in range(params["mult"]):
+        >>>         template_pins["in" + str(i)] = Pin(
+        >>>             xy=[[i * 100 + 0, 0], [i * 100 + 10, 10]],
+        >>>             layer=["M1", "drawing"],
+        >>>             netname="in" + str(i),
+        >>>         )
+        >>>         template_pins["out" + str(i)] = Pin(
+        >>>             xy=[[i * 100 + 90, 90], [i * 100 + 90, 100]],
+        >>>             layer=["M1", "drawing"],
+        >>>             netname="out" + str(i),
+        >>>         )
+        >>>     return template_pins
+        >>> # Create a template
+        >>> pcell_temp = ParameterizedInstanceTemplate(
+        >>>     libname="mylib",
+        >>>     cellname="mypcelltemplate",
+        >>>     bbox_func=pcell_bbox_func,
+        >>>     pins_func=pcell_pins_func,
+        >>> )
+        >>> # Generate an instance for input parameters.
+        >>> pcell_inst_params = {"mult": 4}
+        >>> pcell_inst = pcell_temp.generate(
+        >>>    name="mypcellinst",
+        >>>    transform="R0",
+        >>>    params=pcell_inst_params,
+        >>> )
+        >>> # display
+        >>> print(pcell_temp)
+            <laygo2.object.template.ParameterizedInstanceTemplate object at 0x000001B1BA91D9C0>
+            name: mypcelltemplate, 
+            class: ParameterizedInstanceTemplate,
+        >>> print(pcell_inst)
+            xy: [0, 0],
+            params: {'mult': 4},
+            size: [400, 100],
+            shape: None,
+            pitch: [400, 100],
+            transform: R0,
+            pins: {'in0': <laygo2.object.physical.Pin object at 0x000001B1BA91FCA0>, 
+                   'out0': <laygo2.object.physical.Pin object at 0x000001B1BA91FC70>, 
+                   'in1': <laygo2.object.physical.Pin object at 0x000001B1BA91FC10>, 
+                   'out1': <laygo2.object.physical.Pin object at 0x000001B1BA91E8C0>, 
+                   'in2': <laygo2.object.physical.Pin object at 0x000001B1BA91E890>, 
+                   'out2': <laygo2.object.physical.Pin object at 0x000001B1BA91FBE0>, 
+                   'in3': <laygo2.object.physical.Pin object at 0x000001B1BA91E7D0>, 
+                   'out3': <laygo2.object.physical.Pin object at 0x000001B1BA91E710>},
+
+        .. image:: ../assets/img/object_template_ParameterizedInstanceTemplate_generate.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)** 템플릿으로부터 입력 파라미터에 따른 Instance 객체 생성.
+
+        파라미터
+            - name(str): 생성할 인스턴스의 이름.
+            - shape(numpy.ndarray): (optional) 생성할 객체의 배열 shape.
+            - pitch(numpy.ndarray): (optional) 생성할 객체 간의 간격.
+            - params(dict) : 개체의 속성이 담긴 dictionary.
+            - transform(str): 생성할 개체의 변환 속성.
+        반환값
+            - laygo2.Instance: 생성된 객체
+        """
+        # xy = xy + np.dot(self.xy(params)[0], tf.Mt(transform).T)
+        inst = laygo2.object.physical.Instance(
+            libname=self.libname,
+            cellname=self.cellname,
+            xy=np.array([0, 0]),
+            shape=shape,
+            pitch=pitch,
+            unit_size=self.size(params),
+            pins=self.pins(params),
+            transform=transform,
+            name=name,
+            params=params,
+        )
+        # update netnames if netmap is provided.
+        if netmap is not None:
+            inst.update_netname(netmap=netmap)  
+        return inst
+
+
+class UserDefinedTemplate(Template):
+    """
+    UserDefinedTemplate class implements the template that generates 
+    a VirtualInstance object corresponding to the template and input 
+    parameters.
+
+    Notes
+    -----
+    **(Korean)** UserDefinedTemplate 클래스는 VirtualInstance를 반환하는 
+    템플릿을 구현한다.
+
+    """
+
+    _bbox = None
+    """The internal pointer to the bbox computing function."""
+
+    _pins = None
+    """The internal pointer to the pin creation function."""
+
+    _generate = None
+    """The internal pointer to the instance generation function."""
+
+    def __init__(self, bbox_func, pins_func, generate_func, name=None):
+        """
+        Constructor function of UserDefinedTemplate class.
+
+        Parameters
+        ----------
+        bbox_func: callable
+            The function that computes the bounding box of the template from 
+            its input parameters.
+        pins_func: callable
+            The function that returns a dictionary that contains its pin 
+            objects for its input parameters.
+        generate_func: callable
+            The function that returns a generated VirtualInstance object 
+            for its input parameters.
+        name : str
+            The name of the template.
+
+        Returns
+        -------
+        laygo2.object.template.UserDefinedTemplate
+
+        Example
+        -------
+        >>> import numpy as np
+        >>> from laygo2.object.template import UserDefinedTemplate
+        >>> from laygo2.object.physical import Pin, Rect, VirtualInstance
+        >>> # bbox computation function.
+        >>> def user_bbox_func(params):
+        >>>     return np.array([[0, 0], [100 * params["mult"], 100]])
+        >>> # pin generation function.
+        >>> def user_pins_func(params):
+        >>>     template_pins = dict()
+        >>>     for i in range(params["mult"]):
+        >>>         template_pins["in" + str(i)] = Pin(
+        >>>             xy=[[i * 100 + 0, 0], [i * 100 + 10, 10]],
+        >>>             layer=["M1", "drawing"],
+        >>>             netname="in" + str(i),
+        >>>         )
+        >>>         template_pins["out" + str(i)] = Pin(
+        >>>             xy=[[i * 100 + 90, 90], [i * 100 + 90, 100]],
+        >>>             layer=["M1", "drawing"],
+        >>>             netname="out" + str(i),
+        >>>         )
+        >>>     return template_pins
+        >>> # instance generation function.
+        >>> def user_generate_func(
+        >>>     name=None, shape=None, pitch=np.array([0, 0]), transform="R0", 
+        >>>     params=None):
+        >>>     m = params["mult"]
+        >>>     shape = np.array([1, 1]) if shape is None else np.asarray(shape)
+        >>>     inst_pins = user_pins_func(params)
+        >>>     inst_native_elements = dict()
+        >>>     for i in range(m):
+        >>>         ofst = i * 100
+        >>>         inst_native_elements["R0_" + str(i)] = Rect(
+        >>>             xy=[[ofst, 0], [ofst + 10, 10]], layer=["M1", "drawing"]
+        >>>         )
+        >>>         inst_native_elements["R1_" + str(i)] = Rect(
+        >>>             xy=[[ofst + 90, 90], [ofst + 100, 100]], layer=["M1", "drawing"]
+        >>>         )
+        >>>     inst_native_elements["R2"] = Rect(
+        >>>         xy=[[0, 0], [m * 100, 100]], layer=["prBoundary", "drawing"]
+        >>>     )
+        >>>     inst = VirtualInstance(
+        >>>         name=name,
+        >>>         libname="mylib",
+        >>>         cellname="myvinst",
+        >>>         xy=np.array([0, 0]),
+        >>>         native_elements=inst_native_elements,
+        >>>         shape=shape,
+        >>>         pitch=pitch,
+        >>>         unit_size=[m * 100, 100],
+        >>>         pins=inst_pins,
+        >>>         transform=transform,
+        >>>         params=params,
+        >>>     )
+        >>>     return inst
+        >>> # UserDefinedTemplate construction.
+        >>> user_temp = UserDefinedTemplate(
+        >>>     name="myusertemplate",
+        >>>     bbox_func=user_bbox_func,
+        >>>     pins_func=user_pins_func,
+        >>>     generate_func=user_generate_func,
+        >>> )
+        >>> # VirtualInstance generation.
+        >>> user_inst = user_temp.generate(name="myinst", params={"mult": 5})
+        >>> # Display
+        >>> print(user_temp)
+            <laygo2.object.template.UserDefinedTemplate object at 0x00000192BF990130> 
+            name: myusertemplate, class: UserDefinedTemplate,
+        >>> print(user_inst)
+            <laygo2.object.physical.VirtualInstance object at 0x00000192BF990280>
+                name: myinst,
+                class: VirtualInstance,
+                xy: [0, 0],
+                params: {'mult': 5},
+                size: [500, 100],
+                shape: [1, 1],
+                pitch: [500, 100],
+                transform: R0,
+                pins: {'in0': <laygo2.object.physical.Pin object at 0x00000192BF9930D0>, 
+                       'out0': <laygo2.object.physical.Pin object at 0x00000192BF9931C0>, 
+                       'in1': <laygo2.object.physical.Pin object at 0x00000192BF993760>, 
+                       'out1': <laygo2.object.physical.Pin object at 0x00000192BF9936A0>, 
+                       'in2': <laygo2.object.physical.Pin object at 0x00000192BF993610>, 
+                       'out2': <laygo2.object.physical.Pin object at 0x00000192BF9935B0>, 
+                       'in3': <laygo2.object.physical.Pin object at 0x00000192BF9932E0>, 
+                       'out3': <laygo2.object.physical.Pin object at 0x00000192BF9931F0>, 
+                       'in4': <laygo2.object.physical.Pin object at 0x00000192BF993130>, 
+                       'out4': <laygo2.object.physical.Pin object at 0x00000192BF9930A0>},
+                native elements: {'R0_0': <laygo2.object.physical.Rect object at 0x0...>, 
+                                  'R1_0': <laygo2.object.physical.Rect object at 0x0...>, 
+                                  'R0_1': <laygo2.object.physical.Rect object at 0x0...>, 
+                                  'R1_1': <laygo2.object.physical.Rect object at 0x0...>, 
+                                  'R0_2': <laygo2.object.physical.Rect object at 0x0...>, 
+                                  'R1_2': <laygo2.object.physical.Rect object at 0x0...>, 
+                                  'R0_3': <laygo2.object.physical.Rect object at 0x0...>, 
+                                  'R1_3': <laygo2.object.physical.Rect object at 0x0...>, 
+                                  'R0_4': <laygo2.object.physical.Rect object at 0x0...>, 
+                                  'R1_4': <laygo2.object.physical.Rect object at 0x0...>, 
+                                  'R2': <laygo2.object.physical.Rect object at 0x000...>}
+        >>> print(user_inst.bbox)
+            [[  0   0]
+             [500 100]]
+
+        .. image:: ../assets/img/object_template_UserDefinedTemplate_init.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)** UserDefinedTemplate 클래스의 생성자 함수.
+        
+        파라미터
+            - bbox_func(callable): bbox를 연산하는 함수.
+            - pins_func(callable): pins를 생성하는 함수.
+            - generate_func(callable): VirtualInstance를 생성하는 함수.
+            - name(str): 템플릿 이름
+        반환값
+            - laygo2.object.template.UserDefinedTemplate
+        """
+        self._bbox = bbox_func
+        self._pins = pins_func
+        self._generate = generate_func
+        Template.__init__(self, name=name)
+
+    # Core template functions
+    def bbox(self, params=None):
+        """
+        Return bbox of UserDefinedTemplate object.
+
+        Parameters
+        ----------
+        params: dict
+            A dictionary that contains input parameters corresponding to the 
+            bounding box to be computed.
+
+        Returns
+        -------
+        numpy.ndarray: A 2x2 numpy array that contains the bounding box 
+            coordinates corresponding to the input parameters.
+
+        Example
+        -------
+        >>> import numpy as np
+        >>> from laygo2.object.template import UserDefinedTemplate
+        >>> from laygo2.object.physical import Pin, Rect, VirtualInstance
+        >>> # bbox computation function.
+        >>> def user_bbox_func(params):
+        >>>     return np.array([[0, 0], [100 * params["mult"], 100]])
+        >>> # pin generation function.
+        >>> def user_pins_func(params):
+        >>>     template_pins = dict()
+        >>>     for i in range(params["mult"]):
+        >>>         template_pins["in" + str(i)] = Pin(
+        >>>             xy=[[i * 100 + 0, 0], [i * 100 + 10, 10]],
+        >>>             layer=["M1", "drawing"],
+        >>>             netname="in" + str(i),
+        >>>         )
+        >>>         template_pins["out" + str(i)] = Pin(
+        >>>             xy=[[i * 100 + 90, 90], [i * 100 + 90, 100]],
+        >>>             layer=["M1", "drawing"],
+        >>>             netname="out" + str(i),
+        >>>         )
+        >>>     return template_pins
+        >>> # instance generation function.
+        >>> def user_generate_func(
+        >>>     name=None, shape=None, pitch=np.array([0, 0]), transform="R0", 
+        >>>     params=None):
+        >>>     m = params["mult"]
+        >>>     shape = np.array([1, 1]) if shape is None else np.asarray(shape)
+        >>>     inst_pins = user_pins_func(params)
+        >>>     inst_native_elements = dict()
+        >>>     for i in range(m):
+        >>>         ofst = i * 100
+        >>>         inst_native_elements["R0_" + str(i)] = Rect(
+        >>>             xy=[[ofst, 0], [ofst + 10, 10]], layer=["M1", "drawing"]
+        >>>         )
+        >>>         inst_native_elements["R1_" + str(i)] = Rect(
+        >>>             xy=[[ofst + 90, 90], [ofst + 100, 100]], layer=["M1", "drawing"]
+        >>>         )
+        >>>     inst_native_elements["R2"] = Rect(
+        >>>         xy=[[0, 0], [m * 100, 100]], layer=["prBoundary", "drawing"]
+        >>>     )
+        >>>     inst = VirtualInstance(
+        >>>         name=name,
+        >>>         libname="mylib",
+        >>>         cellname="myvinst",
+        >>>         xy=np.array([0, 0]),
+        >>>         native_elements=inst_native_elements,
+        >>>         shape=shape,
+        >>>         pitch=pitch,
+        >>>         unit_size=[m * 100, 100],
+        >>>         pins=inst_pins,
+        >>>         transform=transform,
+        >>>         params=params,
+        >>>     )
+        >>>     return inst
+        >>> # UserDefinedTemplate construction.
+        >>> user_temp = UserDefinedTemplate(
+        >>>     name="myusertemplate",
+        >>>     bbox_func=user_bbox_func,
+        >>>     pins_func=user_pins_func,
+        >>>     generate_func=user_generate_func,
+        >>> )
+        >>> user_temp.bbox(params={"mult": 5})
+        array([[  0,   0],
+               [500, 100]])
+
+        .. image:: ../assets/img/object_template_UserDefinedTemplate_bbox.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)** UserDefinedTemplate 객체의 bbox 반환.
+        """
+        return self._bbox(params=params)
+
+    def pins(self, params=None):
+        """
+        Pins of UserDefinedTemplate object.
+
+        Parameters
+        ----------
+        params: dict
+            A dictionary that contains input parameters corresponding to the 
+            pin objects to be produced.
+
+        Returns
+        -------
+        dict: A dictionary that contains pin object corresponding to the 
+            input parameters.
+
+        Example
+        -------
+        >>> import numpy as np
+        >>> from laygo2.object.template import UserDefinedTemplate
+        >>> from laygo2.object.physical import Pin, Rect, VirtualInstance
+        >>> # bbox computation function.
+        >>> def user_bbox_func(params):
+        >>>     return np.array([[0, 0], [100 * params["mult"], 100]])
+        >>> # pin generation function.
+        >>> def user_pins_func(params):
+        >>>     template_pins = dict()
+        >>>     for i in range(params["mult"]):
+        >>>         template_pins["in" + str(i)] = Pin(
+        >>>             xy=[[i * 100 + 0, 0], [i * 100 + 10, 10]],
+        >>>             layer=["M1", "drawing"],
+        >>>             netname="in" + str(i),
+        >>>         )
+        >>>         template_pins["out" + str(i)] = Pin(
+        >>>             xy=[[i * 100 + 90, 90], [i * 100 + 90, 100]],
+        >>>             layer=["M1", "drawing"],
+        >>>             netname="out" + str(i),
+        >>>         )
+        >>>     return template_pins
+        >>> # instance generation function.
+        >>> def user_generate_func(
+        >>>     name=None, shape=None, pitch=np.array([0, 0]), transform="R0", 
+        >>>     params=None):
+        >>>     m = params["mult"]
+        >>>     shape = np.array([1, 1]) if shape is None else np.asarray(shape)
+        >>>     inst_pins = user_pins_func(params)
+        >>>     inst_native_elements = dict()
+        >>>     for i in range(m):
+        >>>         ofst = i * 100
+        >>>         inst_native_elements["R0_" + str(i)] = Rect(
+        >>>             xy=[[ofst, 0], [ofst + 10, 10]], layer=["M1", "drawing"]
+        >>>         )
+        >>>         inst_native_elements["R1_" + str(i)] = Rect(
+        >>>             xy=[[ofst + 90, 90], [ofst + 100, 100]], layer=["M1", "drawing"]
+        >>>         )
+        >>>     inst_native_elements["R2"] = Rect(
+        >>>         xy=[[0, 0], [m * 100, 100]], layer=["prBoundary", "drawing"]
+        >>>     )
+        >>>     inst = VirtualInstance(
+        >>>         name=name,
+        >>>         libname="mylib",
+        >>>         cellname="myvinst",
+        >>>         xy=np.array([0, 0]),
+        >>>         native_elements=inst_native_elements,
+        >>>         shape=shape,
+        >>>         pitch=pitch,
+        >>>         unit_size=[m * 100, 100],
+        >>>         pins=inst_pins,
+        >>>         transform=transform,
+        >>>         params=params,
+        >>>     )
+        >>>     return inst
+        >>> # UserDefinedTemplate construction.
+        >>> user_temp = UserDefinedTemplate(
+        >>>     name="myusertemplate",
+        >>>     bbox_func=user_bbox_func,
+        >>>     pins_func=user_pins_func,
+        >>>     generate_func=user_generate_func,
+        >>> )
+        >>> user_temp.pins(params={"mult": 5})
+        {'in0': <laygo2.object.physical.Pin object at 0x00000192BF990670>, 
+        'out0': <laygo2.object.physical.Pin object at 0x00000192BF990400>, 
+        'in1': <laygo2.object.physical.Pin object at 0x00000192BF993250>, 
+        'out1': <laygo2.object.physical.Pin object at 0x00000192BF9903D0>, 
+        'in2': <laygo2.object.physical.Pin object at 0x00000192BF9901F0>, 
+        'out2': <laygo2.object.physical.Pin object at 0x00000192BF9904F0>, 
+        'in3': <laygo2.object.physical.Pin object at 0x00000192BF993640>, 
+        'out3': <laygo2.object.physical.Pin object at 0x00000192BF990520>, 
+        'in4': <laygo2.object.physical.Pin object at 0x00000192BF9936D0>, 
+        'out4': <laygo2.object.physical.Pin object at 0x00000192BF993790>}
+
+        .. image:: ../assets/img/object_template_UserDefinedTemplate_pins.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)** UserDefinedTemplate 객체의 pin dictionary를 생성 및 반환하는 함수.
+        """
+        return self._pins(params=params)
+
+    def generate(self, name=None, shape=None, pitch=None, transform="R0", netmap=None, params=None):
+        """
+        Generate a VirtualInstance object by calling generate_func() bound to the template.
+
+        Parameters
+        ----------
+        name : str
+            name of the instance to be generated.
+        shape : numpy.ndarray, optional.
+            shape of the object to be generated.
+        pitch : numpy.ndarray, optional.
+            pitch of the object to be generated.
+        transform : str, optional.
+            transformation attribute of the entity to be generated.
+        netmap : dict, optional.
+            dictionary containing netmap conversion information of pins.
+        params : dict, optional.
+            dictionary having the entity attributes.
+
+        Returns
+        -------
+        laygo2.object.physical.VirtualInstance: The generated VirtualInstance object.
+
+        Example
+        -------
+        >>> import numpy as np
+        >>> from laygo2.object.template import UserDefinedTemplate
+        >>> from laygo2.object.physical import Pin, Rect, VirtualInstance
+        >>> # bbox computation function.
+        >>> def user_bbox_func(params):
+        >>>     return np.array([[0, 0], [100 * params["mult"], 100]])
+        >>> # pin generation function.
+        >>> def user_pins_func(params):
+        >>>     template_pins = dict()
+        >>>     for i in range(params["mult"]):
+        >>>         template_pins["in" + str(i)] = Pin(
+        >>>             xy=[[i * 100 + 0, 0], [i * 100 + 10, 10]],
+        >>>             layer=["M1", "drawing"],
+        >>>             netname="in" + str(i),
+        >>>         )
+        >>>         template_pins["out" + str(i)] = Pin(
+        >>>             xy=[[i * 100 + 90, 90], [i * 100 + 90, 100]],
+        >>>             layer=["M1", "drawing"],
+        >>>             netname="out" + str(i),
+        >>>         )
+        >>>     return template_pins
+        >>> # instance generation function.
+        >>> def user_generate_func(
+        >>>     name=None, shape=None, pitch=np.array([0, 0]), transform="R0", 
+        >>>     params=None):
+        >>>     m = params["mult"]
+        >>>     shape = np.array([1, 1]) if shape is None else np.asarray(shape)
+        >>>     inst_pins = user_pins_func(params)
+        >>>     inst_native_elements = dict()
+        >>>     for i in range(m):
+        >>>         ofst = i * 100
+        >>>         inst_native_elements["R0_" + str(i)] = Rect(
+        >>>             xy=[[ofst, 0], [ofst + 10, 10]], layer=["M1", "drawing"]
+        >>>         )
+        >>>         inst_native_elements["R1_" + str(i)] = Rect(
+        >>>             xy=[[ofst + 90, 90], [ofst + 100, 100]], layer=["M1", "drawing"]
+        >>>         )
+        >>>     inst_native_elements["R2"] = Rect(
+        >>>         xy=[[0, 0], [m * 100, 100]], layer=["prBoundary", "drawing"]
+        >>>     )
+        >>>     inst = VirtualInstance(
+        >>>         name=name,
+        >>>         libname="mylib",
+        >>>         cellname="myvinst",
+        >>>         xy=np.array([0, 0]),
+        >>>         native_elements=inst_native_elements,
+        >>>         shape=shape,
+        >>>         pitch=pitch,
+        >>>         unit_size=[m * 100, 100],
+        >>>         pins=inst_pins,
+        >>>         transform=transform,
+        >>>         params=params,
+        >>>     )
+        >>>     return inst
+        >>> # UserDefinedTemplate construction.
+        >>> user_temp = UserDefinedTemplate(
+        >>>     name="myusertemplate",
+        >>>     bbox_func=user_bbox_func,
+        >>>     pins_func=user_pins_func,
+        >>>     generate_func=user_generate_func,
+        >>> )
+        >>> # VirtualInstance generation.
+        >>> user_inst = user_temp.generate(name="myinst", params={"mult": 5})
+        >>> # Display
+        >>> print(user_temp)
+            <laygo2.object.template.UserDefinedTemplate object at 0x00000192BF990130> 
+            name: myusertemplate, class: UserDefinedTemplate,
+        >>> print(user_inst)
+            <laygo2.object.physical.VirtualInstance object at 0x00000192BF990280>
+                name: myinst,
+                class: VirtualInstance,
+                xy: [0, 0],
+                params: {'mult': 5},
+                size: [500, 100],
+                shape: [1, 1],
+                pitch: [500, 100],
+                transform: R0,
+                pins: {'in0': <laygo2.object.physical.Pin object at 0x00000192BF9930D0>, 
+                       'out0': <laygo2.object.physical.Pin object at 0x00000192BF9931C0>, 
+                       'in1': <laygo2.object.physical.Pin object at 0x00000192BF993760>, 
+                       'out1': <laygo2.object.physical.Pin object at 0x00000192BF9936A0>, 
+                       'in2': <laygo2.object.physical.Pin object at 0x00000192BF993610>, 
+                       'out2': <laygo2.object.physical.Pin object at 0x00000192BF9935B0>, 
+                       'in3': <laygo2.object.physical.Pin object at 0x00000192BF9932E0>, 
+                       'out3': <laygo2.object.physical.Pin object at 0x00000192BF9931F0>, 
+                       'in4': <laygo2.object.physical.Pin object at 0x00000192BF993130>, 
+                       'out4': <laygo2.object.physical.Pin object at 0x00000192BF9930A0>},
+                native elements: {'R0_0': <laygo2.object.physical.Rect object at 0x0...>, 
+                                  'R1_0': <laygo2.object.physical.Rect object at 0x0...>, 
+                                  'R0_1': <laygo2.object.physical.Rect object at 0x0...>, 
+                                  'R1_1': <laygo2.object.physical.Rect object at 0x0...>, 
+                                  'R0_2': <laygo2.object.physical.Rect object at 0x0...>, 
+                                  'R1_2': <laygo2.object.physical.Rect object at 0x0...>, 
+                                  'R0_3': <laygo2.object.physical.Rect object at 0x0...>, 
+                                  'R1_3': <laygo2.object.physical.Rect object at 0x0...>, 
+                                  'R0_4': <laygo2.object.physical.Rect object at 0x0...>, 
+                                  'R1_4': <laygo2.object.physical.Rect object at 0x0...>, 
+                                  'R2': <laygo2.object.physical.Rect object at 0x000...>}
+        >>> print(user_inst.bbox)
+            [[  0   0]
+             [500 100]]
+
+        .. image:: ../assets/img/object_template_UserDefinedTemplate_generate.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)** 템플릿으로부터 입력 파라미터에 따른 VirtualInstance 객체 생성.
+        파라미터
+            - name(str): 생성할 인스턴스의 이름.
+            - shape(numpy.ndarray): (optional) 생성할 객체의 배열 shape.
+            - pitch(numpy.ndarray): (optional) 생성할 객체 간의 간격.
+            - params(dict) : 개체의 속성이 담긴 dictionary.
+            - transform(str): 생성할 개체의 변환 속성.
+        반환값
+            - laygo2.VirtualInstance: 생성된 객체
+        """
+        inst = self._generate(
+            name=name, shape=shape, pitch=pitch, transform=transform, params=params
+        )
+        # update netnames if netmap is provided.
+        if netmap is not None:
+            inst.update_netname(netmap=netmap)  
+        return inst
+
+
+# Test
+if __name__ == "__main__":
+    test_native_template = True
+    test_pcell_template = True
+    test_user_template = True
+
+    import laygo2.object
+
+    if test_native_template:
+        print("NativeInstanceTemplate test")
+        # define pins
+        nat_temp_pins = dict()
+        nat_temp_pins["in"] = laygo2.object.Pin(
+            xy=[[0, 0], [10, 10]], layer=["M1", "drawing"], netname="in"
+        )
+        nat_temp_pins["out"] = laygo2.object.Pin(
+            xy=[[90, 90], [100, 100]], layer=["M1", "drawing"], netname="out"
+        )
+        # create a template
+        nat_temp = NativeInstanceTemplate(
+            libname="mylib",
+            cellname="mynattemplate",
+            bbox=[[0, 0], [100, 100]],
+            pins=nat_temp_pins,
+        )
+        # generate
+        nat_inst = nat_temp.generate(
+            name="mynatinst", shape=[2, 2], pitch=[100, 100], transform="R0"
+        )
+        # display
+        print(nat_temp)
+        print(nat_inst)
+
+    if test_pcell_template:
+        print("ParameterizedInstanceTemplate test")
+
+        # define the bbox computation function.
+        def pcell_bbox_func(params):
+            return np.array([[0, 0], [100 * params["mult"], 100]])
+
+        # define the pin generation function.
+        def pcell_pins_func(params):
+            template_pins = dict()
+            for i in range(params["mult"]):
+                template_pins["in" + str(i)] = laygo2.object.Pin(
+                    xy=[[i * 100 + 0, 0], [i * 100 + 10, 10]],
+                    layer=["M1", "drawing"],
+                    netname="in" + str(i),
+                )
+                template_pins["out" + str(i)] = laygo2.object.Pin(
+                    xy=[[i * 100 + 90, 90], [i * 100 + 90, 100]],
+                    layer=["M1", "drawing"],
+                    netname="out" + str(i),
+                )
+            return template_pins
+
+        # create a template.
+        pcell_temp = ParameterizedInstanceTemplate(
+            libname="mylib",
+            cellname="mypcelltemplate",
+            bbox_func=pcell_bbox_func,
+            pins_func=pcell_pins_func,
+        )
+        # generate based on the parameter assigned.
+        pcell_inst_params = {"mult": 4}
+        pcell_inst_size = pcell_temp.size(params=pcell_inst_params)
+        pcell_inst = pcell_temp.generate(
+            name="mypcellinst",
+            shape=[2, 2],
+            pitch=pcell_inst_size,
+            transform="R0",
+            params=pcell_inst_params,
+        )
+        # display
+        print(pcell_temp)
+        print(pcell_inst)
+
+    if test_user_template:
+        print("UserDefinedTemplate test")
+
+        # define the bbox computation function.
+        def user_bbox_func(params):
+            return np.array([[0, 0], [100 * params["mult"], 100]])
+
+        # define the pin generation function.
+        def user_pins_func(params):
+            template_pins = dict()
+            for i in range(params["mult"]):
+                template_pins["in" + str(i)] = laygo2.object.Pin(
+                    xy=[[i * 100 + 0, 0], [i * 100 + 10, 10]],
+                    layer=["M1", "drawing"],
+                    netname="in" + str(i),
+                )
+                template_pins["out" + str(i)] = laygo2.object.Pin(
+                    xy=[[i * 100 + 90, 90], [i * 100 + 90, 100]],
+                    layer=["M1", "drawing"],
+                    netname="out" + str(i),
+                )
+            return template_pins
+
+        # define the instance generation function.
+        def user_generate_func(
+            name=None, shape=None, pitch=np.array([0, 0]), transform="R0", params=None
+        ):
+            m = params["mult"]
+            shape = np.array([1, 1]) if shape is None else np.asarray(shape)
+
+            inst_pins = user_pins_func(params)
+            inst_native_elements = dict()
+            for i in range(m):
+                ofst = i * 100
+                inst_native_elements["R0_" + str(i)] = laygo2.object.Rect(
+                    xy=[[ofst, 0], [ofst + 10, 10]], layer=["M1", "drawing"]
+                )
+                inst_native_elements["R1_" + str(i)] = laygo2.object.Rect(
+                    xy=[[ofst + 90, 90], [ofst + 100, 100]], layer=["M1", "drawing"]
+                )
+            inst_native_elements["R2"] = laygo2.object.Rect(
+                xy=[[0, 0], [m * 100, 100]], layer=["prBoundary", "drawing"]
+            )
+            inst = laygo2.object.VirtualInstance(
+                name=name,
+                libname="mylib",
+                cellname="myvinst",
+                xy=np.array([0, 0]),
+                native_elements=inst_native_elements,
+                shape=shape,
+                pitch=pitch,
+                unit_size=[m * 100, 100],
+                pins=inst_pins,
+                transform=transform,
+                params=params,
+            )
+            return inst
+
+        user_temp = UserDefinedTemplate(
+            name="myusertemplate",
+            bbox_func=user_bbox_func,
+            pins_func=user_pins_func,
+            generate_func=user_generate_func,
+        )
+        user_inst = user_temp.generate(
+            name="myuserinst", shape=[2, 1], params={"mult": 5}
+        )
+        print(user_temp)
+        print(user_inst)
+        print(user_inst.bbox)
```

### Comparing `laygo2-0.5.6/laygo2/object/template/routing.py` & `laygo2-0.5.7/laygo2/object/template/routing.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,267 +1,267 @@
-#!/usr/bin/python
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-"""
-**laygo2.object.routing** module is defining functions and classes for basic routing.
-"""
-
-import numpy as np
-from laygo2.object.template import *
-from laygo2.object.physical import *
-
-class RoutingMeshTemplate(Template):
-    """RoutingMesh describes a two dimensional routing structure over a routing grid."""
-
-    grid = None
-    """laygo2.object.grid.RoutingGrid: A routing grid object that the RoutingMesh object refers to.
-    """
-
-    tracks = dict()
-    """dict: A dictionary that contains track information.
-    The format of its element is "track_name": [index, "net_name"].
-    """
-
-    nodes = []
-    """list: A list that contains layout objects to be connected through the routing channel.
-    The element could be either one of the following:
-        laygo2.object.physical.Instance, 
-        laygo2.object.physical.VirtualInstance, 
-        laygo2.object.physical.Rect.
-    
-    For Instance or VirtualInstance elements, the netname parameters of their pins need to be set to the 
-    name of net (netname) which the pins are connected to.
-    For Rect elements, their netname parameters should be set.       
-    """
-
-    # hrange = [None, None]
-    # """[int or None, int or None]: The minimum and maximum track indices covered by the
-    # horizontal routing channel, for automatic routing.
-    # """
-    #
-    # vrange = [None, None]
-    # """[int or None, int or None]: The minimum and maximum track indices covered by the
-    # vertical routing channel, for automatic routing.
-    # """
-
-    def bbox(self, params=None):
-        """numpy.ndarray: (Abstract method) Return the bounding box of a template."""
-        # TODO: implement this
-        pass
-
-    def pins(self, params=None):
-        """dict: (Abstract method) Return dict having the collection of pins of a template."""
-        # TODO: implement this
-        pass
-
-    def __init__(self, grid, tracks: dict = None, nodes: list = None):
-        """The constructor function.
-
-        Parameters
-        ----------
-        grid: laygo2.object.grid.RoutingGrid
-            The grid object that this object refers to for constructing routing wires.
-        tracks: dict
-            The dictionary that contains track information.
-            The format of its element is "track_name": [index, "net_name"].
-        nodes: list
-            The list that contains layout objects to be connected through the routing channel.
-            The element could be either one of the following:
-                laygo2.object.physical.Instance,
-                laygo2.object.physical.VirtualInstance,
-                laygo2.object.physical.Rect.
-            For Instance or VirtualInstance elements, the netname parameters of their pins need to be set to the
-            name of net (netname) which the pins are connected to.
-            For Rect elements, their netname parameters should be set.
-        """
-        # Assign parameters.
-        self.grid = grid
-        if tracks is not None:
-            self.tracks = tracks
-        else:
-            self.tracks = dict()
-        if nodes is not None:
-            self.nodes = nodes
-        else:
-            self.nodes = []
-
-    def add_track(self, name: str, index: int, netname: str = None):
-        """Add a track to the mesh.
-
-        Parameters
-        ----------
-        name: str
-            The name of the track to be added.
-        index: int
-            The index of the track.
-            For a horizontal track, it should be [None, i] where i is the
-            value of abstract coordinate to place the routing track.
-            For a vertical track, it should be [i, None].
-        netname: str
-            The net name of the track.
-        """
-        if netname is None:
-            netname = name
-        self.tracks[name] = [index, netname]
-
-    def add_node(self, obj):
-        """Add a node object to the mesh.
-
-        Parameters
-        ----------
-        obj: laygo2.object.physical.Instance or laygo2.object.physical.VirtualInstance or laygo2.object.pythiscl.Rect
-            The object to be added to the mesh as a node.
-        """
-
-        if isinstance(obj, list):
-            self.nodes += obj
-        else:
-            self.nodes.append(obj)
-
-    def generate(self):
-        """Generate a routing mesh.
-
-        Returns
-        -------
-        laygo2.object.physical.VirtualInstance: the generated routing object.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> from laygo2.object.grid import CircularMapping as CM
-        >>> from laygo2.object.grid import CircularMappingArray as CMA
-        >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
-        >>> from laygo2.object.template import NativeInstanceTemplate
-        >>> from laygo2.object.physical import Instance, Rect
-        >>> # Routing grid construction (not needed if laygo2_tech is set up).
-        >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
-        >>> gh = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
-        >>> wv = CM([10])           # vertical (xgrid) width
-        >>> wh = CM([10])   # horizontal (ygrid) width
-        >>> ev = CM([10])           # vertical (xgrid) extension
-        >>> eh = CM([10])   # horizontal (ygrid) extension
-        >>> e0v = CM([5])          # vert. extension (for zero-length wires)
-        >>> e0h = CM([5])  # hori. extension (for zero-length wires)
-        >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
-        >>> lh = CM([['M2', 'drawing']], dtype=object)
-        >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
-        >>> plh = CM([['M2', 'pin']], dtype=object)
-        >>> xcolor = CM([None], dtype=object)  # not multi-patterned
-        >>> ycolor = CM([None]*3, dtype=object)
-        >>> primary_grid = 'horizontal'
-        >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via
-        >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
-        >>> g = RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
-        >>>                 vwidth=wv, hwidth=wh,
-        >>>                 vextension=ev, hextension=eh,
-        >>>                 vlayer=lv, hlayer=lh,
-        >>>                 pin_vlayer=plv, pin_hlayer=plh,
-        >>>                 viamap=viamap, primary_grid=primary_grid,
-        >>>                 xcolor=xcolor, ycolor=ycolor,
-        >>>                 vextension0=e0v, hextension0=e0h)
-        >>> # Create node objects.
-        >>> r0 = Rect(xy=[[45, -5], [55, 5]], layer=['M1', 'drawing'], netname = "A")
-        >>> r1 = Rect(xy=[[95, -5], [105, 5]], layer=['M1', 'drawing'], netname = "A")
-        >>> i0_pins = dict()
-        >>> i0_pins['X'] = laygo2.object.physical.Pin(xy=[[45, 95], [55, 105]],
-        >>>     layer = ['M1', 'drawing'], netname = 'A')
-        >>> i0 = laygo2.object.physical.Instance(name="I0", xy=[150,0],
-        >>>     libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200],
-        >>>     unit_size=[100, 100], pins=i0_pins, transform='R0')
-        >>>
-        >>> # Create a routing mesh.
-        >>> rm = laygo2.object.routing.RoutingMesh(grid = g)
-        >>> rm.add_track(name = "A", index = [None, 5], netname = "A")
-        >>> rm.add_node(r0)
-        >>> rm.add_node(r1)
-        >>> rm.add_node(i0)
-        >>> rinst = rm.generate()
-        >>>
-        >>> # Print horizontal wire
-        >>> print(rinst.pins["A"].xy)
-        [[ 50 250]
-         [200 250]]
-        >>> # Vertical wire to r0
-        >>> print(rinst.native_elements["A_0_0"].xy)
-        [[ 50   0]
-         [ 50 250]]
-        >>> # Vertical wire to r1
-        >>> print(rinst.native_elements["A_1_0"].xy)
-        [[100   0]
-         [100 250]]
-        >>> # Vertical wire to i0
-        >>> print(rinst.native_elements["A_2_0"].xy)
-        [[200 100]
-         [200 250]]
-        """
-        g = self.grid
-        tr = self.tracks
-        nds = self.nodes
-
-        # Variables for VirtualInstance construction.
-        nelements = dict()
-        pins = dict()
-        for tn, t in tr.items():  # for each track
-            ti = t[0]  # track index
-            tnn = t[1]  # track netname
-            mn = []
-            for n in nds:
-                if isinstance(n, Instance) or isinstance(n, VirtualInstance):
-                    for pn, p in n.pins.items():
-                        if p.netname == tnn:
-                            _mn = (g.mn(p)[0] + g.mn(p)[1])/2
-                            mn.append(_mn)
-                elif isinstance(n, Rect):
-                    if n.netname == tnn:
-                        mn.append(g.mn(n)[0])
-                elif isinstance(n, Pin):
-                    if n.netname == tnn:
-                        mn.append(g.mn(n)[0])
-            # Do routing
-            # if ti[0] is None:  # horizontal track
-            #    _t = [None, ti[1]]
-            # else:
-            #    _t = [ti[0], None]
-            # r = g.route_via_track(mn=mn, track=_t)
-            r = g.route_via_track(mn=mn, track=ti)
-
-            # Wrap the generated routing structure into a VirtualInstance
-            for i, _r in enumerate(r):
-                if isinstance(_r, list):
-                    for j, __r in enumerate(_r):
-                        nelements[tn + "_" + str(i) + "_" + str(j)] = __r
-                else:
-                    nelements[tn + "_" + str(i)] = _r
-            pins[tn] = Pin(xy=r[-1].xy, layer=r[-1].layer, netname=tnn)
-
-        # Instantiate a VirtualInstance.
-        rinst = VirtualInstance(
-            name=tn,
-            xy=np.array([0, 0]),
-            libname="mylib",
-            cellname="rtrack_" + tn + "_" + tnn,
-            native_elements=nelements,
-            transform="R0",
-            pins=pins,
-        )
-        return rinst
+#!/usr/bin/python
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+"""
+**laygo2.object.routing** module is defining functions and classes for basic routing.
+"""
+
+import numpy as np
+from laygo2.object.template import *
+from laygo2.object.physical import *
+
+class RoutingMeshTemplate(Template):
+    """RoutingMesh describes a two dimensional routing structure over a routing grid."""
+
+    grid = None
+    """laygo2.object.grid.RoutingGrid: A routing grid object that the RoutingMesh object refers to.
+    """
+
+    tracks = dict()
+    """dict: A dictionary that contains track information.
+    The format of its element is "track_name": [index, "net_name"].
+    """
+
+    nodes = []
+    """list: A list that contains layout objects to be connected through the routing channel.
+    The element could be either one of the following:
+        laygo2.object.physical.Instance, 
+        laygo2.object.physical.VirtualInstance, 
+        laygo2.object.physical.Rect.
+    
+    For Instance or VirtualInstance elements, the netname parameters of their pins need to be set to the 
+    name of net (netname) which the pins are connected to.
+    For Rect elements, their netname parameters should be set.       
+    """
+
+    # hrange = [None, None]
+    # """[int or None, int or None]: The minimum and maximum track indices covered by the
+    # horizontal routing channel, for automatic routing.
+    # """
+    #
+    # vrange = [None, None]
+    # """[int or None, int or None]: The minimum and maximum track indices covered by the
+    # vertical routing channel, for automatic routing.
+    # """
+
+    def bbox(self, params=None):
+        """numpy.ndarray: (Abstract method) Return the bounding box of a template."""
+        # TODO: implement this
+        pass
+
+    def pins(self, params=None):
+        """dict: (Abstract method) Return dict having the collection of pins of a template."""
+        # TODO: implement this
+        pass
+
+    def __init__(self, grid, tracks: dict = None, nodes: list = None):
+        """The constructor function.
+
+        Parameters
+        ----------
+        grid: laygo2.object.grid.RoutingGrid
+            The grid object that this object refers to for constructing routing wires.
+        tracks: dict
+            The dictionary that contains track information.
+            The format of its element is "track_name": [index, "net_name"].
+        nodes: list
+            The list that contains layout objects to be connected through the routing channel.
+            The element could be either one of the following:
+                laygo2.object.physical.Instance,
+                laygo2.object.physical.VirtualInstance,
+                laygo2.object.physical.Rect.
+            For Instance or VirtualInstance elements, the netname parameters of their pins need to be set to the
+            name of net (netname) which the pins are connected to.
+            For Rect elements, their netname parameters should be set.
+        """
+        # Assign parameters.
+        self.grid = grid
+        if tracks is not None:
+            self.tracks = tracks
+        else:
+            self.tracks = dict()
+        if nodes is not None:
+            self.nodes = nodes
+        else:
+            self.nodes = []
+
+    def add_track(self, name: str, index: int, netname: str = None):
+        """Add a track to the mesh.
+
+        Parameters
+        ----------
+        name: str
+            The name of the track to be added.
+        index: int
+            The index of the track.
+            For a horizontal track, it should be [None, i] where i is the
+            value of abstract coordinate to place the routing track.
+            For a vertical track, it should be [i, None].
+        netname: str
+            The net name of the track.
+        """
+        if netname is None:
+            netname = name
+        self.tracks[name] = [index, netname]
+
+    def add_node(self, obj):
+        """Add a node object to the mesh.
+
+        Parameters
+        ----------
+        obj: laygo2.object.physical.Instance or laygo2.object.physical.VirtualInstance or laygo2.object.pythiscl.Rect
+            The object to be added to the mesh as a node.
+        """
+
+        if isinstance(obj, list):
+            self.nodes += obj
+        else:
+            self.nodes.append(obj)
+
+    def generate(self):
+        """Generate a routing mesh.
+
+        Returns
+        -------
+        laygo2.object.physical.VirtualInstance: the generated routing object.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> from laygo2.object.grid import CircularMapping as CM
+        >>> from laygo2.object.grid import CircularMappingArray as CMA
+        >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
+        >>> from laygo2.object.template import NativeInstanceTemplate
+        >>> from laygo2.object.physical import Instance, Rect
+        >>> # Routing grid construction (not needed if laygo2_tech is set up).
+        >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
+        >>> gh = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
+        >>> wv = CM([10])           # vertical (xgrid) width
+        >>> wh = CM([10])   # horizontal (ygrid) width
+        >>> ev = CM([10])           # vertical (xgrid) extension
+        >>> eh = CM([10])   # horizontal (ygrid) extension
+        >>> e0v = CM([5])          # vert. extension (for zero-length wires)
+        >>> e0h = CM([5])  # hori. extension (for zero-length wires)
+        >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
+        >>> lh = CM([['M2', 'drawing']], dtype=object)
+        >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
+        >>> plh = CM([['M2', 'pin']], dtype=object)
+        >>> xcolor = CM([None], dtype=object)  # not multi-patterned
+        >>> ycolor = CM([None]*3, dtype=object)
+        >>> primary_grid = 'horizontal'
+        >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via
+        >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
+        >>> g = RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
+        >>>                 vwidth=wv, hwidth=wh,
+        >>>                 vextension=ev, hextension=eh,
+        >>>                 vlayer=lv, hlayer=lh,
+        >>>                 pin_vlayer=plv, pin_hlayer=plh,
+        >>>                 viamap=viamap, primary_grid=primary_grid,
+        >>>                 xcolor=xcolor, ycolor=ycolor,
+        >>>                 vextension0=e0v, hextension0=e0h)
+        >>> # Create node objects.
+        >>> r0 = Rect(xy=[[45, -5], [55, 5]], layer=['M1', 'drawing'], netname = "A")
+        >>> r1 = Rect(xy=[[95, -5], [105, 5]], layer=['M1', 'drawing'], netname = "A")
+        >>> i0_pins = dict()
+        >>> i0_pins['X'] = laygo2.object.physical.Pin(xy=[[45, 95], [55, 105]],
+        >>>     layer = ['M1', 'drawing'], netname = 'A')
+        >>> i0 = laygo2.object.physical.Instance(name="I0", xy=[150,0],
+        >>>     libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200],
+        >>>     unit_size=[100, 100], pins=i0_pins, transform='R0')
+        >>>
+        >>> # Create a routing mesh.
+        >>> rm = laygo2.object.routing.RoutingMesh(grid = g)
+        >>> rm.add_track(name = "A", index = [None, 5], netname = "A")
+        >>> rm.add_node(r0)
+        >>> rm.add_node(r1)
+        >>> rm.add_node(i0)
+        >>> rinst = rm.generate()
+        >>>
+        >>> # Print horizontal wire
+        >>> print(rinst.pins["A"].xy)
+        [[ 50 250]
+         [200 250]]
+        >>> # Vertical wire to r0
+        >>> print(rinst.native_elements["A_0_0"].xy)
+        [[ 50   0]
+         [ 50 250]]
+        >>> # Vertical wire to r1
+        >>> print(rinst.native_elements["A_1_0"].xy)
+        [[100   0]
+         [100 250]]
+        >>> # Vertical wire to i0
+        >>> print(rinst.native_elements["A_2_0"].xy)
+        [[200 100]
+         [200 250]]
+        """
+        g = self.grid
+        tr = self.tracks
+        nds = self.nodes
+
+        # Variables for VirtualInstance construction.
+        nelements = dict()
+        pins = dict()
+        for tn, t in tr.items():  # for each track
+            ti = t[0]  # track index
+            tnn = t[1]  # track netname
+            mn = []
+            for n in nds:
+                if isinstance(n, Instance) or isinstance(n, VirtualInstance):
+                    for pn, p in n.pins.items():
+                        if p.netname == tnn:
+                            _mn = (g.mn(p)[0] + g.mn(p)[1])/2
+                            mn.append(_mn)
+                elif isinstance(n, Rect):
+                    if n.netname == tnn:
+                        mn.append(g.mn(n)[0])
+                elif isinstance(n, Pin):
+                    if n.netname == tnn:
+                        mn.append(g.mn(n)[0])
+            # Do routing
+            # if ti[0] is None:  # horizontal track
+            #    _t = [None, ti[1]]
+            # else:
+            #    _t = [ti[0], None]
+            # r = g.route_via_track(mn=mn, track=_t)
+            r = g.route_via_track(mn=mn, track=ti)
+
+            # Wrap the generated routing structure into a VirtualInstance
+            for i, _r in enumerate(r):
+                if isinstance(_r, list):
+                    for j, __r in enumerate(_r):
+                        nelements[tn + "_" + str(i) + "_" + str(j)] = __r
+                else:
+                    nelements[tn + "_" + str(i)] = _r
+            pins[tn] = Pin(xy=r[-1].xy, layer=r[-1].layer, netname=tnn)
+
+        # Instantiate a VirtualInstance.
+        rinst = VirtualInstance(
+            name=tn,
+            xy=np.array([0, 0]),
+            libname="mylib",
+            cellname="rtrack_" + tn + "_" + tnn,
+            native_elements=nelements,
+            transform="R0",
+            pins=pins,
+        )
+        return rinst
```

### Comparing `laygo2-0.5.6/laygo2/object/physical.py` & `laygo2-0.5.7/laygo2/object/physical.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,2737 +1,2737 @@
-#!/usr/bin/python
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-"""
-**laygo2.object.physical** module provides classes for physical objects 
-used in IC layout design. The supported physical objects include:
-
-:obj:`PhysicalObject` - Base class for all physical layout objects.
-
-:obj:`IterablePhysicalObject` - Base class for physical objects that can be iterated (eg. arrayed instances).
-
-:obj:`PhysicalObjectGroup` - Defines a group of physical objects (currently not implemented).
-
-:obj:`Rect` - Represents a rectangular shape.
-
-:obj:`Path` - Defines a path.
-
-:obj:`Pin` - Defines a pin.
-
-:obj:`Text` - Defines a text label.
-
-:obj:`Instance` - Represents an instance of a design element.
-
-:obj:`VirtualInstance` - Represents a virtual instance composed of multiple physical objects, acting as a single instance.
-
-Examples of the physical objects supported by this module are shown in the followng figure.
-
-.. image:: ../assets/img/user_guide_physical.png
-
-
-
-Check the following links for further details.
-"""
-
-__author__ = "Jaeduk Han"
-__maintainer__ = "Jaeduk Han"
-__status__ = "Prototype"
-
-import numpy as np
-
-# from copy import deepcopy
-import laygo2.util.transform as tf
-
-
-class PhysicalObject:
-    """
-    Base class for physical layout objects with physical coordinate info.
-
-    Notes
-    -----
-    **(Korean)**: 물리 객체들의 기본 클래스, 물리 좌표 정보를 갖고 있다.
-
-    """
-
-    def _get_xy(self):
-        """numpy.ndarray(dtype=numpy.int): Retrive x,y coordinate values of
-        the object."""
-        return self._xy
-
-    def _set_xy(self, value):
-        """numpy.ndarray(dtype=numpy.int): Update x,y coordinates of
-        the object."""
-        self._xy = np.asarray(value, dtype=int)
-        self._update_pointers()
-
-    name = None
-    """str: Object name.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]], 
-            name="test", params={'maxI': 0.005})
-    >>> obj.name 
-    “test”
-
-    .. image:: ../assets/img/object_physical_PhysicalObject_name.png
-      :height: 250
-
-    """
-
-    _xy = np.zeros(2, dtype=int)
-    """numpy.ndarray(dtype=numpy.int): The x and y coordinate values 
-    stored within."""
-
-    xy = property(_get_xy, _set_xy)
-    """numpy.ndarray: Physical coordinate values of the object 
-    in the form of [bottom_left, top_right].
-
-    Example
-    -------
-    >>> import laygo2
-    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]], 
-            name="test", params={'maxI': 0.005})
-    >>> obj.xy 
-    array([[  0,   0], 
-           [200, 200]])
-    
-    .. image:: ../assets/img/object_physical_PhysicalObject_xy.png
-      :height: 250
-
-    """
-
-    master = None
-    """numpy.ndarray: Master ojbect for current object (for arrays and pins).
-
-    Example
-    -------
-    >>> import laygo2
-    >>> obj1 = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]], 
-            name="test1", params=None) 
-    >>> obj2 = laygo2.object.physical.Pin(xy = [[0, 0], [100, 100]], 
-            layer = ["M1", "drawing"], master=obj1) 
-    >>> obj2.master
-    <laygo2.object.physical.PhysicalObject object at 0x00000204AAF3C7C0>
-
-    Notes
-    -----
-    **(Korean)**: 객체의 master (배열 element 또는 pin 객체들의 master 객체에 연결).
-    """
-
-    params = None
-    """dict: Dictionary storing the parameters associated with the object
-
-    Example
-    -------
-    >>> import laygo2
-    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]], 
-            name="test", params={'maxI': 0.005})
-    >>> obj.params 
-    {‘maxI’: 0.005 }
-
-    Notes
-    -----
-    **(Korean)**: 객체의 속성.
-    """
-
-    pointers = None
-    """dict: The dictionary containing the key-value pairs of the major physical 
-    coordinates of the object, such as 'left', 'right', 'top', 'bottom', 
-    'bottom_left', 'center', etc.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]])
-    >>> obj.pointers 
-    {'left': array([0, 100]), 'right': array([200, 100]),
-     'bottom': array([100, 0]), 'top': array([100, 200]),
-     'bottom_left': array([0, 0]), 'bottom_right': array([200, 0]),
-     'top_left': array([0, 200]), 'top_right': array([200, 200]),
-     ‘center’: array( [100, 100] ) 
-    }
-
-    .. image:: ../assets/img/object_physical_PhysicalObject_pointers.png
-      :height: 250
-
-    Notes
-    -----
-    **(Korean)**: 객체의 주요 좌표들을 담고 있는 dictionary.
-    """
-
-    # Frequently used pointers
-    left = None
-    """numpy.ndarray: The left-center coordinate of the object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]])
-    >>> obj.left
-    array([  0, 100])
-    
-    .. image:: ../assets/img/object_physical_PhysicalObject_left.png
-      :height: 250
-    """
-
-    right = None
-    """numpy.ndarray: The right-center coordinate of the object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]])
-    >>> obj.right
-    array([200, 100])
-    
-    .. image:: ../assets/img/object_physical_PhysicalObject_right.png
-      :height: 250
-    """
-
-    top = None
-    """numpy.ndarray: The top-center coordinate of the object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]])
-    >>> obj.top
-    array([100, 200])
-    
-    .. image:: ../assets/img/object_physical_PhysicalObject_top.png
-      :height: 250
-    """
-
-    bottom = None
-    """numpy.ndarray: The bottom-center coordinate of the object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]])
-    >>> obj.top
-    array([100,   0])
-    
-    .. image:: ../assets/img/object_physical_PhysicalObject_bottom.png
-      :height: 250
-    """
-
-    center = None
-    """numpy.ndarray: The center-center coordinate of the object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]])
-    >>> obj.center
-    array([100, 100])
-    
-    .. image:: ../assets/img/object_physical_PhysicalObject_center.png
-      :height: 250
-    """
-
-    bottom_left = None
-    """numpy.ndarray: The bottom-left coordinate of the object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]])
-    >>> obj.bottom_left
-    array([  0,   0])
-    
-    .. image:: ../assets/img/object_physical_PhysicalObject_bottom_left.png
-      :height: 250
-    """
-
-    bottom_right = None
-    """numpy.ndarray: The bottom-right coordinate of the object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]])
-    >>> obj.bottom_right
-    array([200,   0])
-    
-    .. image:: ../assets/img/object_physical_PhysicalObject_bottom_right.png 
-      :height: 250
-    """
-
-    top_left = None
-    """numpy.ndarray: The top-left coordinate of the object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]])
-    >>> obj.top_left
-    array([  0, 200])
-    
-    .. image:: ../assets/img/object_physical_PhysicalObject_top_left.png
-      :height: 250
-    """
-
-    top_right = None
-    """numpy.ndarray: The top-right coordinate of the object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]])
-    >>> obj.top_right
-    array([200, 200])
-    
-    .. image:: ../assets/img/object_physical_PhysicalObject_top_right.png
-      :height: 250
-    """
-
-    @property
-    def bbox(self):
-        """numpy.ndarray: The physical bounding box of the object.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]])
-        >>> obj.bbox
-        array([[  0,   0],
-               [200, 200]])
-
-        .. image:: ../assets/img/object_physical_PhysicalObject_bbox.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)**: numpy.ndarray: 객체의 bbox (bounding box).
-        """
-        # if self.xy.ndim == 2:
-        if isinstance(self.xy[0], np.ndarray):
-            return np.sort(np.array([self.xy[0, :], self.xy[1, :]]), axis=0)
-        else:  # single-point object.
-            return np.array([self.xy, self.xy])
-
-    def __init__(self, xy, name=None, params=None):
-        """
-        The constructor function.
-
-        Parameters
-        ----------
-        xy : numpy.ndarray
-            Physical coordinate values of the object
-            in the form of [bottom_left, top_right].
-        name : str
-            Object name.
-        params : dict
-            Dictionary storing the parameters associated with the object.
-
-        Returns
-        -------
-        PhysicalObject
-
-        Example
-        -------
-        >>> import laygo2
-        >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]],
-                name="test", params={'maxI': 0.005})
-        >>> print(obj)
-        <laygo2.object.physical.PhysicalObject object at 0x000001ECF0022948>
-         name: test,
-         class: PhysicalObject,
-         xy: [[0, 0], [200, 200]],
-         params: {'maxI': 0.005},
-
-        Notes
-        -----
-        **(Korean)** PhysicalObject 클래스의 생성자.
-
-        파라미터
-            - xy(numpy.ndarray): 객체의 물리적 좌표 (bbox).
-            - name(str): 객체의 이름.
-            - params(dict): 객체의 주요 속성을 갖고 있는 dict.
-
-        """
-
-        self.name = name
-        # Initialize pointers.
-        self.pointers = dict()
-        self.pointers["left"] = np.array([0, 0], dtype=int)
-        self.pointers["right"] = np.array([0, 0], dtype=int)
-        self.pointers["bottom"] = np.array([0, 0], dtype=int)
-        self.pointers["top"] = np.array([0, 0], dtype=int)
-        self.pointers["bottom_left"] = np.array([0, 0], dtype=int)
-        self.pointers["bottom_right"] = np.array([0, 0], dtype=int)
-        self.pointers["top_left"] = np.array([0, 0], dtype=int)
-        self.pointers["top_right"] = np.array([0, 0], dtype=int)
-        self.left = self.pointers["left"]
-        self.right = self.pointers["right"]
-        self.bottom = self.pointers["bottom"]
-        self.top = self.pointers["top"]
-        self.bottom_left = self.pointers["bottom_left"]
-        self.bottom_right = self.pointers["bottom_right"]
-        self.top_left = self.pointers["top_left"]
-        self.top_right = self.pointers["top_right"]
-
-        self.params = params  # deepcopy(params)  # deepcopy increases the memory usage.
-        self.xy = xy
-
-    def __str__(self):
-        """Return the summary of the object information."""
-        return self.summarize()
-
-    def summarize(self):
-        """Return the summary of the object information."""
-        name = "None" if self.name is None else self.name
-        return (
-            self.__repr__() + " \n"
-            "    name: "
-            + name
-            + ", \n"
-            + "    class: "
-            + self.__class__.__name__
-            + ", \n"
-            + "    xy: "
-            + str(self.xy.tolist())
-            + ", \n"
-            + "    params: "
-            + str(self.params)
-            + ", \n"
-        )
-
-    def _update_pointers(self):
-        """The internal function that updates the object's pointers
-        after a change in its physical coordinates."""
-        xy_left = np.diag(np.dot(np.array([[1, 0], [0.5, 0.5]]), self.bbox))
-        xy_right = np.diag(np.dot(np.array([[0, 1], [0.5, 0.5]]), self.bbox))
-        xy_bottom = np.diag(np.dot(np.array([[0.5, 0.5], [1, 0]]), self.bbox))
-        xy_top = np.diag(np.dot(np.array([[0.5, 0.5], [0, 1]]), self.bbox))
-        xy_bottom_left = np.diag(np.dot(np.array([[1, 0], [1, 0]]), self.bbox))
-        xy_bottom_right = np.diag(np.dot(np.array([[0, 1], [1, 0]]), self.bbox))
-        xy_top_left = np.diag(np.dot(np.array([[1, 0], [0, 1]]), self.bbox))
-        xy_top_right = np.diag(np.dot(np.array([[0, 1], [0, 1]]), self.bbox))
-        xy_center = np.diag(np.dot(np.array([[0.5, 0.5], [0.5, 0.5]]), self.bbox))
-        self.pointers["left"] = xy_left.astype(int)
-        self.pointers["right"] = xy_right.astype(int)
-        self.pointers["bottom"] = xy_bottom.astype(int)
-        self.pointers["top"] = xy_top.astype(int)
-        self.pointers["bottom_left"] = xy_bottom_left.astype(int)
-        self.pointers["bottom_right"] = xy_bottom_right.astype(int)
-        self.pointers["top_left"] = xy_top_left.astype(int)
-        self.pointers["top_right"] = xy_top_right.astype(int)
-        self.pointers["center"] = xy_center.astype(int)
-        self.left = self.pointers["left"]
-        self.right = self.pointers["right"]
-        self.bottom = self.pointers["bottom"]
-        self.top = self.pointers["top"]
-        self.bottom_left = self.pointers["bottom_left"]
-        self.bottom_right = self.pointers["bottom_right"]
-        self.top_left = self.pointers["top_left"]
-        self.top_right = self.pointers["top_right"]
-        self.center = self.pointers["center"]
-
-
-class IterablePhysicalObject(PhysicalObject):
-    """
-    The base class of entities capable of iterable operations among elements.
-
-    Notes
-    -----
-    **(Korean)**: 구성 요소의 iterable 연산이 가능한 객체들의 기본 클래스.
-
-    """
-
-    elements = None
-    """
-    dict: Numpy array containing its element objects.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> phy0 = laygo2.object.physical.PhysicalObject(xy=[[0, 0], [100, 100]]) 
-    >>> phy1 = laygo2.object.physical.PhysicalObject(xy=[[0, 0], [200, 200]]) 
-    >>> phy2 = laygo2.object.physical.PhysicalObject(xy=[[0, 0], [300, 300]]) 
-    >>> element = [phy0, phy1, phy2] 
-    >>> iphy0 = laygo2.object.physical.IterablePhysicalObject(
-            xy=[[0, 0], [300, 300]], elements = elements)
-    >>> iphy0.elements 
-    array([<laygo2.object.physical.PhysicalObject object at 0x000002049A77FDF0>,
-           <laygo2.object.physical.PhysicalObject object at 0x000002049A77F3D0>,
-           <laygo2.object.physical.PhysicalObject object at 0x000002049A77FF40>],
-          dtype=object)
-
-    Notes
-    -----
-    **(Korean)**: 객체의 하위 구성원을 담고 있는 list.
-    """
-
-    def _get_xy(self):
-        """numpy.ndarray(dtype=numpy.int): Retrive x,y coordinate values of
-        the object."""
-        return self._xy
-
-    def _set_xy(self, value):
-        """numpy.ndarray(dtype=numpy.int): Update x,y coordinates of
-        the object."""
-        # Update the coordinate value of its elements.
-        self._update_elements(xy_ofst=value - self.xy)
-        # Update the coordinate value of the object itself.
-        PhysicalObject._set_xy(self, value=value)
-
-    xy = property(_get_xy, _set_xy)
-
-    @property
-    def shape(self):
-        """Array size of the object.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> phy0 = laygo2.object.physical.PhysicalObject(xy=[[0, 0], [100, 100]])
-        >>> phy1 = laygo2.object.physical.PhysicalObject(xy=[[0, 0], [200, 200]])
-        >>> phy2 = laygo2.object.physical.PhysicalObject(xy=[[0, 0], [300, 300]])
-        >>> element = [phy0, phy1, phy2]
-        >>> iphy0 = laygo2.object.physical.IterablePhysicalObject(
-            xy=[[0, 0], [300, 300]], elements = elements)
-        >>> iphy0.shape
-        array([3])
-
-        Notes
-        -----
-        **(Korean)**: numpy.ndarray: 객체의 element의 배열 크기.
-        """
-        if self.elements is None:
-            return None
-        else:
-            return np.array(self.elements.shape, dtype=int)
-
-    def __init__(self, xy, name=None, params=None, elements=None):
-        """
-        The constructor function.
-
-        Parameters
-        ----------
-        xy : numpy.ndarray
-            Physical coordinate values of the object
-            in the form of [bottom_left, top_right].
-        name : str
-            Object name.
-        params : dict
-            Dictionary storing the parameters associated with the object.
-        elements : list
-            List containing its element objects.
-
-        Returns
-        -------
-        IterablePhysicalObject
-
-        Example
-        -------
-        >>> import laygo2
-        >>> phy0 = laygo2.object.physical.PhysicalObject(xy=[[0, 0], [100, 100]])
-        >>> phy1 = laygo2.object.physical.PhysicalObject(xy=[[0, 0], [200, 200]])
-        >>> phy2 = laygo2.object.physical.PhysicalObject(xy=[[0, 0], [300, 300]])
-        >>> element = [phy0, phy1, phy2]
-        >>> iphy0 = laygo2.object.physical.IterablePhysicalObject(
-            xy=[[0, 0], [300, 300]], elements = elements)
-        >>> print(iphy0)
-        <laygo2.object.physical.IterablePhysicalObject object at 0x000002049A77E380>
-        name: None,
-        class: IterablePhysicalObject,
-        xy: [[0, 0], [300, 300]],
-        params: None,
-
-        Notes
-        -----
-        **(Korean)**:  IterablePhysicalObject 클래스의 생성자.
-
-        파라미터
-            - xy(numpy.ndarray): 객체의 물리 좌표 (bbox).
-            - name(str): 객체의 이름.
-            - params(dict): 객체의 주요 속성이 담긴 dict.
-            - elements(list): 객체의 구성 요소 객체들(elements)이 담긴 list.
-
-        """
-        PhysicalObject.__init__(self, xy=xy, name=name, params=params)
-        if elements is None:
-            self.elements = None
-        else:
-            self.elements = np.asarray(elements)
-
-    def __getitem__(self, pos):
-        """Return the sub-elements of the object, based on the pos parameter."""
-        return self.elements[pos]
-
-    def __setitem__(self, pos, item):
-        """Update the sub-elements of the object, based on the pos and item
-        parameters."""
-        self.elements[pos] = item
-
-    def __iter__(self):
-        """Iterator that maps directly to the elements attribute of
-        this object."""
-        return self.elements.__iter__()
-
-    def __next__(self):
-        """Iterator that maps directly to the iterator function of
-        the elements attribute of this object."""
-        return self.elements.__next__()
-
-    def ndenumerate(self):
-        """Enumerate over the element array. Calls np.ndenumerate() of
-        the elements of this object."""
-        return np.ndenumerate(self.elements)
-
-    def _update_elements(self, xy_ofst):
-        """Update the xy coordinates of the elements of this object,
-        used internally by the _set_xy() function."""
-        if np.all(self.elements is not None):
-            # Update the x and y coordinate values of elements.
-            for n, e in self.ndenumerate():
-                if e is not None:
-                    e.xy = e.xy + xy_ofst
-
-
-class PhysicalObjectGroup(IterablePhysicalObject):
-    """
-    A class for grouped physical objects, designed to be generated as a group
-    in Cadence Virtuoso (currently not implemented).
-    """
-
-    # TODO: implement this.
-
-    def summarize(self):
-        """Get object information summary."""
-        return IterablePhysicalObject.summarize(self) + "    elements: " + str(self.elements) + ", \n"
-
-    def __init__(self, xy, name=None, params=None, elements=None):
-        """
-        The constructor function.
-
-        Parameters
-        ----------
-        xy : numpy.ndarray(dtype=int)
-            The coordinate of this object represented as a Numpy array [x, y].
-        name : str, optional
-            The name of the object.
-        params : dict or None
-            The dictionary that contains the parameters of this object, with
-            parameter names as keys.
-        elements : numpy.ndarray(dtype=LayoutObject) or None
-            The iterable elements of the object.
-        """
-        IterablePhysicalObject.__init__(self, xy=xy, name=name, params=params, elements=elements)
-
-
-'''
-# Deprecated as PhysicalObjectGroup can be used instead in most cases.
-# But the code is preserved for reference.
-class PhysicalObjectArray(np.ndarray):
-    """LayoutObject array class for containing multiple layout objects. Subclassing ndarray to utilize advance slicing
-     functions."""
-    name = None
-    """str: the name of the object."""
-
-    params = None
-    """dict or None: parameters of the object. """
-
-    _xy = None  # np.zeros(2, dtype=int)
-    """numpy.ndarray(dtype=numpy.int): the internal variable of xy."""
-
-    def get_xy(self):
-        """numpy.ndarray(dtype=numpy.int): gets the x and y coordinate values of this object."""
-        return self._xy
-
-    def set_xy(self, value):
-        """numpy.ndarray(dtype=numpy.int): sets the x and y coordinate values of this object."""
-        if value is None:
-            self._xy = value
-        else:
-            self._xy = np.asarray(value, dtype=int)
-
-    xy = property(get_xy, set_xy)
-    """numpy.ndarray(detype=numpy.int): the x and y coordinate values of the object."""
-
-    def moveby(self, delta):
-        """move the array and child objects by delta."""
-        self.xy = self.xy + delta
-        for i in self:
-            i.xy = i.xy + delta
-
-    def __new__(cls, input_array, name=None, xy=None, params=None):
-        """
-        Constructor for ndarray subclasses - check the NumPy manual for details.
-
-        Parameters
-        ----------
-        input_array : np.ndarray
-            An array of LayoutObject objects.
-        name : str
-            The name of the array.
-        xy : numpy.ndarray(dtype=int)
-            The xy-coordinate of the object. The format is [x0, y0].
-        params : dict
-            Additional parameters of the array.
-        """
-        # Input array is an already formed ndarray instance
-        # We first cast to be our class type
-        obj = np.asarray(input_array).view(cls)
-        # add the new attribute to the created instance
-        obj.name = name
-        obj.xy = None if xy is None else np.asarray(xy, dtype=int)
-        obj.params = params
-        # Finally, we must return the newly created object:
-        return obj
-
-    def __array_finalize__(self, obj):
-        """
-        Array finalizing function for subclassing ndarray - check the NumPy manual for details
-        """
-        if obj is None: return
-        # Transfer parameters
-        self.name = getattr(obj, 'name', None)
-        self.xy = getattr(obj, 'xy', None)
-        self.params = getattr(obj, 'params', None)
-
-    def __str__(self):
-        """Return the summary of the object information."""
-        return self.summarize()
-
-    def summarize(self):
-        """Return the summary of the object information."""
-        return "  " + \
-               "name:" + self.name + ", " + \
-               "class:" + self.__class__.__name__ + ", " + \
-               "shape:" + str(self.shape) + ", " + \
-               "xy:" + str(self.xy) + ", " + \
-               "params:" + str(self.params) + "\n" + \
-               "  elements:" + str(np.ndarray.__str__(self)) + "\n"
-'''
-
-
-class Rect(PhysicalObject):
-    """
-    Rectangle object class.
-
-    Example
-    -------
-    >>> from laygo2.object.physical import Rect
-    >>> rect0 = Rect(xy=[[0, 0], [100, 100]], layer=['M1', 'drawing'])
-    >>> print(rect0)
-    <laygo2.object.physical.Rect object at 0x000002049A77F3A0>
-    name: None,
-    class: Rect,
-    xy: [[0, 0], [100, 100]],
-    params: None, , layer: ['M1', 'drawing']
-
-    Notes
-    -----
-    **(Korean)**: 사각형 객체 클래스.
-    """
-
-    layer = None
-    """
-    numpy.ndarray: The physical layer information of the object, 
-    represented as a list with two elements: [name, purpose].
-
-    Example
-    -------
-    >>> import laygo2
-    >>> rect0 = laygo2.object.physical.Rect(xy=[[0, 0], [100, 100]], 
-            layer=['M1', 'drawing'], netname='net0', hextension=20, vextension=20)
-    >>> rect0.layer 
-    ['M1', 'drawing']
-
-    Notes
-    -----
-    **(Korean)**: 객체의 layer 정보 [name, purpose].
-    """
-
-    netname = None
-    """
-    str: The net name associated with the object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> rect0 = laygo2.object.physical.Rect(xy=[[0, 0], [100, 100]], 
-            layer=['M1', 'drawing'], netname='net0', hextension=20, vextension=20)
-    >>> rect0.netname 
-    “net0”
-    
-    Notes
-    -----
-    **(Korean)**: 객체의 노드 이름.
-    """
-
-    hextension = 0
-    """
-    int: The horizontal extension of the rectangle object above its bounding box.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> rect0 = laygo2.object.physical.Rect(xy=[[0, 0], [100, 100]], 
-            layer=['M1', 'drawing'], netname='net0', hextension=20, vextension=20)
-    >>> rect0.hextension 
-    20
-
-    .. image:: ../assets/img/object_physical_rect_hextension.png
-      :height: 250
-
-    Notes
-    -----
-    **(Korean)**: 객체의 기존 좌표로부터 수평 방향으로의 확장값.
-    """
-
-    vextension = 0
-    """
-    int: The vertical extension of the rectangle object above its bounding box.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> rect0 = laygo2.object.physical.Rect(xy=[[0, 0], [100, 100]], 
-            layer=['M1', 'drawing'], netname='net0', hextension=20, vextension=20)
-    >>> rect0.vextension 
-    20
-
-    .. image:: ../assets/img/object_physical_rect_vextension.png
-      :height: 250
-
-    Notes
-    -----
-    **(Korean)**: 객체의 기존 좌표로부터 수직 방향으로의 확장값.
-    """
-
-    color = None
-    """
-    int or None or "not_MPT": The color (multi-patterning identifier) parameter of 
-    the object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> rect0 = laygo2.object.physical.Rect(xy=[[0, 0], [100, 100]], 
-            layer=['M1', 'drawing'], netname='net0', color=1)
-    >>> rect0.color 
-    1
-
-    Notes
-    -----
-    **(Korean)**: 객체의 color (multi-patterning ID).
-    """
-
-    @property
-    def height(self):
-        """
-        int: The height of the object.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> rect0 = laygo2.object.physical.Rect(xy=[[0, 0], [100, 100]],
-                layer=['M1', 'drawing'])
-        >>> rect0.height
-        100
-
-        .. image:: ../assets/img/object_physical_rect_height.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)**: int: 객체의 높이.
-        """
-        return abs(self.xy[0, 1] - self.xy[1, 1])
-
-    @property
-    def width(self):
-        """
-        int: The width of the object.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> rect0 = laygo2.object.physical.Rect(xy=[[0, 0], [100, 100]],
-                layer=['M1', 'drawing'])
-        >>> rect0.width
-        100
-
-        .. image:: ../assets/img/object_physical_rect_width.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)**: int: 객체의 폭.
-        """
-        return abs(self.xy[0, 0] - self.xy[1, 0])
-
-    @property
-    def height_vec(self):
-        """numpy.ndarray(dtype=int): The height direction vector [0, self.height]
-        of the object."""
-        return np.array([0, self.height])
-
-    @property
-    def width_vec(self):
-        """numpy.ndarray(dtype=int): The width direction vector [self.width, 0]
-        of the object."""
-        return np.array([self.width, 0])
-
-    @property
-    def size(self):
-        """
-        numpy.ndarray: The size of the object ([self.width, self.height]).
-
-        Example
-        -------
-        >>> import laygo2
-        >>> rect0 = laygo2.object.physical.Rect(xy=[[0, 0], [100, 100]],
-                layer=['M1', 'drawing'])
-        >>> rect0.size
-        array([100, 100])
-
-        .. image:: ../assets/img/object_physical_rect_size.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)**: numpy.ndarray: 객체의 크기 ([폭, 높이]).
-        """
-        return np.array([self.width, self.height])
-
-    def __init__(
-        self,
-        xy,
-        layer,
-        color=None,
-        hextension=0,
-        vextension=0,
-        name=None,
-        netname=None,
-        params=None,
-    ):
-        """
-        The constructor function.
-
-        Parameters
-        ----------
-        xy : numpy.ndarray
-            Physical coordinate values of the object
-            in the form of [bottom_left, top_right].
-        layer : list
-            The physical layer information of the object,
-            represented as a list with two elements: [name, purpose].
-        hextension : int
-            The horizontal extension value of the object.
-        vextension : int
-            The vertical extension value of the object.
-        name : str
-            Object name.
-        netname : str
-            The net name associated with the object.
-        params : dict
-            Dictionary storing the parameters associated with the object.
-        color : str, optional.
-            The color (multi-patterning identifier) parameter of the object.
-
-        Returns
-        -------
-        Rect
-
-        See Also
-        --------
-        PhysicalObject
-
-        Example
-        -------
-        >>> import laygo2
-        >>> rect0 = laygo2.object.physical.Rect(xy=[[0, 0], [100, 100]],
-                layer=['M1', 'drawing'], netname='net0', color=1)
-        >>> print(rect0)
-        <laygo2.object.physical.Rect object at 0x000002049A77F3A0>
-        name: None,
-        class: Rect,
-        xy: [[0, 0], [100, 100]],
-        params: None, , layer: ['M1', 'drawing'], netname: net0
-
-        .. image:: ../assets/img/object_physical_rect_init.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)**: Rect 클래스의 생성자 함수.
-
-        파라미터
-            - xy(numpy.ndarray): 객체의 물리 좌표 (bbox).
-            - layer(list): 객체의 layer 정보.
-            - hextension(int): 객체의 수평 방향 확장값.
-            - vextension(int): 객체의 수직 방향 확장값.
-            - name(str): 객체의 이름.
-            - netname(str): 객체의 노드 명.
-            - params(dict): 객체의 주요 속성을 갖는 dict [optional].
-            - color(str): 객체의 color [optional].
-        """
-        self.layer = layer
-        if netname is None:
-            self.netname = name
-        else:
-            self.netname = netname
-        self.hextension = hextension
-        self.vextension = vextension
-        self.color = color
-        PhysicalObject.__init__(self, xy=xy, name=name, params=params)
-
-    def align(self, rect2):
-        """
-        Match the length of the self and rect2 objects, if either object has a width or height of 0.
-
-        Parameters
-        ----------
-        rect2 : Rect
-            The rect object to be aligned with `self`.
-        """
-        index = 0
-        r0 = self
-        r1 = rect2
-        if r0.xy[0][0] == r0.xy[1][0]:  # width is zero
-            index = 1
-
-        pnt = np.zeros([2, 2], dtype=int)
-        pnt[0][1] = r0.bbox[1][index]  # tr
-        pnt[1][1] = r1.bbox[1][index]  # tr
-        pnt[0][0] = r0.bbox[0][index]  # bl
-        pnt[1][0] = r1.bbox[0][index]  # bl
-
-        if pnt[1][1] > pnt[0][1]:  # p1-top is upper then p0-top
-            _xy = r0.bbox  # r0 correction
-            _xy[1][index] = pnt[1][1]
-            r0.xy = _xy
-        elif pnt[1][1] < pnt[0][1]:  # p1-top is lower then p0-top
-            _xy = r1.bbox  # r1 correction
-            _xy[1][index] = pnt[0][1]
-            r1.xy = _xy
-
-        if pnt[1][0] < pnt[0][0]:  # p1-bottom is lower then p0-bottom
-            _xy = r0.bbox  # r0 correction
-            _xy[0][index] = pnt[1][0]
-            r0.xy = _xy
-        elif pnt[1][0] > pnt[0][0]:
-            _xy = r1.bbox  # r1 correction
-            _xy[0][index] = pnt[0][0]
-            r1.xy = _xy
-
-    def summarize(self):
-        """Get object information summary."""
-        return (
-            PhysicalObject.summarize(self)
-            + "    layer: "
-            + str(self.layer)
-            + ", \n"
-            + "    netname: "
-            + str(self.netname)
-            + ", \n"
-        )
-
-
-class Path(PhysicalObject):
-    """
-    Path object class.
-
-    Example
-    -------
-    >>> from laygo2.object.physical.Path import Path
-    >>> path0 = Path(xy=[[0, 0], [0, 100]], width=10,
-                     extension=5, layer=['M1', 'drawing'])
-    >>> print(path0)
-    <laygo2.object.physical.Path object at 0x00000280D1F3CE88>
-    name: None,
-    class: Path,
-    xy: [[0, 0], [0, 100]],
-    params: None,
-    width: 10,
-    extension: 5,
-    layer: ['M1', 'drawing'],
-
-    Notes
-    -----
-    **(Korean)**: Path 객체 클래스.
-    """
-
-    # TODO: implement pointers.
-
-    layer = None
-    """numpy.ndarray: The physical layer information of the object, 
-    represented as a list with two elements: [name, purpose].
-    
-    Notes
-    -----
-    **(Korean)**: 객체의 레이어 정보 [name, purpose].
-    """
-
-    netname = None
-    """
-    str: The net name associated with the object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> path0 = laygo2.object.physical.Path(xy=[[0, 0], [0, 100]], width=10, 
-            extension=5, layer=['M1', 'drawing'], netname='net0’)
-    >>> path0.netname 
-    “net0”
-    
-    .. image:: ../assets/img/object_physical_path_netname.png 
-      :height: 250
-
-    Notes
-    -----
-    **(Korean)**: 객체의 노드 명.
-    """
-
-    width = None
-    """
-    int: the width of the object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> path0 = laygo2.object.physical.Path(xy=[[0, 0], [0, 100]], width=10, 
-            extension=5, layer=['M1', 'drawing'], netname='net0’)
-    >>> path0.width 
-    10
-
-    .. image:: ../assets/img/object_physical_path_width.png
-      :height: 250
-
-    Notes
-    -----
-    **(Korean)**: 객체의 폭.
-    """
-
-    extension = 0
-    """
-    int: The path extension from its endpoints.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> path0 = laygo2.object.physical.Path(xy=[[0, 0], [0, 100]], width=10, 
-            extension=5, layer=['M1', 'drawing'], netname='net0’)
-    >>> path0.extension 
-    5
-    
-    .. image:: ../assets/img/object_physical_path_extension.png
-      :height: 250
-
-    Notes
-    -----
-    **(Korean)**: 객체의 양 끝점에서의 확장값.
-    """
-
-    @property
-    def bbox(self):
-        """The physical bounding box of the object."""
-        return np.sort(np.array([self.xy[0], self.xy[-1]]), axis=0)
-
-    def _update_pointers(self):
-        """The internal function that updates the object's pointers
-        after a change in its physical coordinates."""
-        pass
-
-    def __init__(self, xy, layer, width, extension=0, name=None, netname=None, params=None):
-        """
-        The constructor function.
-
-        Parameters
-        ----------
-        xy : numpy.ndarray
-            Physical coordinate values of the object
-            in the form of [bottom_left, top_right].
-        layer : list
-            The physical layer information of the object,
-            represented as a list with two elements: [name, purpose].
-        width : int
-            The width of the object.
-        extension : int
-            The path extension from its endpoints.
-        name : str
-            Object name.
-        netname : str
-            The net name associated with the object.
-        params : dict
-            Dictionary storing the parameters associated with the object.
-
-        Returns
-        -------
-        Path
-
-        Example
-        -------
-        >>> import laygo2
-        >>> path0 = laygo2.object.physical.Path(xy=[[0, 0], [0, 100]], width=10,
-                extension=5, layer=['M1', 'drawing'], netname='net0’)
-        >>> print(path0)
-        <laygo2.object.physical.Path object at 0x00000280D1F3CE88>
-        name: None,
-        class: Path,
-        xy: [[0, 0], [0, 100]],
-        params: None,
-        width: 10,
-        extension: 5,
-        layer: ['M1', 'drawing'],
-        netname: net0
-
-        .. image:: ../assets/img/object_physical_path_init.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)**: Path 객체 생성.
-
-        파라미터
-            - xy(numpy.ndarray): 객체의 물리 좌표 (bbox).
-            - layer(list): 객체의 layer 정보.
-            - width(int): 객체의 폭.
-            - extension(int): 객체의 끝점에서의 확장 값.
-            - name(str): 객체의 이름.
-            - netname(str): 객체의 노드 명.
-            - params(dict): 객체의 주요 속성을 갖는 dict.
-
-        """
-        self.layer = layer
-        self.width = width
-        self.extension = extension
-        self.netname = netname
-        PhysicalObject.__init__(self, xy=xy, name=name, params=params)
-        self.pointers = dict()  # Pointers are invalid for Path objects.
-
-    def summarize(self):
-        """Get object information summary."""
-        return (
-            PhysicalObject.summarize(self)
-            + "    width: "
-            + str(self.width)
-            + ", \n"
-            + "    extension: "
-            + str(self.extension)
-            + ", \n"
-            + "    layer: "
-            + str(self.layer)
-            + ", \n"
-            + "    netname: "
-            + str(self.netname)
-            + ", \n"
-        )
-
-
-class Pin(IterablePhysicalObject):
-    """
-    Pin object class.
-
-    Example
-    -------
-    >>> from laygo2.object.physical import Pin
-    >>> pin0 = Pin(xy=[[0, 0], [100, 100]], layer=['M1', 'drawing'],
-                   netname='net0', params={'direction': 'input'})
-    >>> print(pin0)
-    <laygo2.object.physical.Pin object at 0x000002049A77FF70>
-        name: None,
-        class: Pin,
-        xy: [[0, 0], [100, 100]],
-        params: {'direction': 'input'}, , layer: ['M1' 'drawing'],
-        netname: net0, shape: None, master: None
-
-    Notes
-    -----
-    **(Korean)**: Pin 객체 클래스.
-    """
-
-    layer = None
-    """
-    numpy.ndarray: The physical layer information of the object, 
-    represented as a list with two elements: [name, purpose].
-
-    Example
-    -------
-    >>> import laygo2
-    >>> pin0 = laygo2.object.physical.Pin(xy=[[0, 0], [100, 100]], 
-            layer=['M1', 'drawing'], netname='net0', params={'direction': 'input'})
-    >>> pin0.layer 
-    ['M1', 'drawing']
-    
-    numpy.ndarray: 객체의 layer 정보 [name, purpose].
-    """
-
-    netname = None
-    """
-    str: The net name associated with the object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> pin0 = laygo2.object.physical.Pin(xy=[[0, 0], [100, 100]], 
-            layer=['M1', 'drawing'], netname='net0', params={'direction': 'input'})
-    >>> pin0.netname 
-    “net0”
-    
-    str: 객체의 노드 명.
-    """
-
-    master = None
-    """
-    Instance: The instance that the pin belongs to. Used for pins of instances only.
-    """
-
-    @property
-    def height(self):
-        """
-        int: The height of the object.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> pin0 = laygo2.object.physical.Pin(xy=[[0, 0], [100, 100]],
-            layer=['M1', 'drawing'], netname='net0', params={'direction': 'input'})
-        >>> pin0.height
-        100
-
-        Notes
-        -----
-        **(Korean)**: 객체의 높이.
-        """
-        return abs(self.xy[0, 1] - self.xy[1, 1])
-
-    @property
-    def width(self):
-        """
-        int: The width of the object.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> pin0 = laygo2.object.physical.Pin(xy=[[0, 0], [100, 100]],
-            layer=['M1', 'drawing'], netname='net0', params={'direction': 'input'})
-        >>> pin0.width
-        100
-
-        Notes
-        -----
-        **(Korean)**: 객체의 폭.
-        """
-        return abs(self.xy[0, 0] - self.xy[1, 0])
-
-    @property
-    def size(self):
-        """
-        numpy.ndarray: The size of the object.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> pin0 = laygo2.object.physical.Pin(xy=[[0, 0], [100, 100]],
-            layer=['M1', 'drawing'], netname='net0', params={'direction': 'input'})
-        >>> pin0.size
-        [100, 100]
-
-        Notes
-        -----
-        **(Korean)**: 객체의 크기.
-        """
-        return np.array([self.width, self.height])
-
-    @property
-    def height_vec(self):
-        """numpy.ndarray(dtype=int): The height direction vector [0, self.height]
-        of the object."""
-        return np.array([0, self.height])
-
-    @property
-    def width_vec(self):
-        """numpy.ndarray(dtype=int): The width direction vector [self.width, 0]
-        of the object."""
-        return np.array([self.width, 0])
-
-    def __init__(
-        self,
-        xy,
-        layer,
-        name=None,
-        netname=None,
-        params=None,
-        master=None,
-        elements=None,
-    ):
-        """
-        The constructor function.
-
-        Parameters
-        ----------
-        xy : numpy.ndarray
-            Physical coordinate values of the object
-            in the form of [bottom_left, top_right].
-        layer : list
-            The physical layer information of the object,
-            represented as a list with two elements: [name, purpose].
-        name : str
-            Object name.
-        netname : str
-            The net name associated with the object.
-        params : dict
-            Dictionary storing the parameters associated with the object.
-
-        Returns
-        -------
-        Pin
-
-        Example
-        -------
-        >>> import laygo2
-        >>> pin0 = laygo2.object.physical.Pin(xy=[[0, 0], [100, 100]],
-            layer=['M1', 'drawing'], netname='net0', params={'direction': 'input'})
-        >>> print(pin0)
-        <laygo2.object.physical.Pin object at 0x000002049A77FF70>
-            name: None,
-            class: Pin,
-            xy: [[0, 0], [100, 100]],
-            params: {'direction': 'input'}, , layer: ['M1' 'drawing'],
-            netname: net0, shape: None, master: None
-
-        Notes
-        -----
-        **(Korean)**: Pin 클래스의 생성자 함수
-
-        파라미터
-            - xy(numpy.ndarray): 객체의 물리적 좌표 (bbox).
-            - layer(list): 객체의 layer 정보 ([name, purpose]).
-            - name(str): 객체의 이름.
-            - netname(str): 객체의 노드 명.
-            - params(dict): 객체의 주요 속성을 갖는 dict.
-
-        """
-        self.layer = np.asarray(layer)
-        if netname is None:
-            netname = name
-        self.netname = netname
-        self.master = master
-        IterablePhysicalObject.__init__(self, xy=xy, name=name, params=params, elements=elements)
-
-    def summarize(self):
-        """Get object information summary."""
-        return (
-            IterablePhysicalObject.summarize(self)
-            + "    layer: "
-            + str(self.layer)
-            + ", \n"
-            + "    netname: "
-            + str(self.netname)
-            + ", \n"
-            + "    shape: "
-            + str(self.shape)
-            + ", \n"
-            + "    master: "
-            + str(self.master)
-            + ", \n"
-        )
-
-    def export_to_dict(self):
-        db = dict()
-        db["xy"] = self.xy.tolist()
-        db["layer"] = self.layer.tolist()
-        db["name"] = self.name
-        db["netname"] = self.netname
-        return db
-
-
-class Text(PhysicalObject):
-    """
-    Text object class.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> text0 = laygo2.object.physical.Text(xy=[0, 0],
-        layer=['text', 'drawing'], text='test', params=None)
-    >>> print(text0)
-    <laygo2.object.physical.Text object at 0x000002049A77FD90>
-        name: None,
-        class: Text,
-        xy: [0, 0],
-        params: None,
-        layer: ['text', 'drawing'],
-        text: test
-
-    Notes
-    -----
-    **(Korean)**: Text 객체 클래스.
-    """
-
-    layer = None
-    """
-    list: The physical layer information of the object,
-          represented as a list with two elements: [name, purpose].
-
-    Example
-    -------
-    >>> import laygo2
-    >>> text0 = laygo2.object.physical.Text(xy=[0, 0], 
-            layer=['text', 'drawing'], text='test', params=None)
-    >>> text0.layer 
-    ['text', 'drawing']
-
-    Notes
-    -----
-    **(Korean)**: 객체의 layer 정보 [name, purpose].
-    """
-
-    text = None
-    """
-    str: Text content of the object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> text0 = laygo2.object.physical.Text(xy=[0, 0], 
-            layer=['text', 'drawing'], text='test', params=None)
-    >>> text0.text 
-    'test'
-    
-    Notes
-    -----
-    **(Korean)**: 객체의 텍스트 내용.
-    """
-
-    def __init__(self, xy, layer, text, name=None, params=None):
-        """
-        The constructor function.
-
-        Parameters
-        ----------
-        xy : numpy.ndarray
-            Physical coordinate values of the object
-            in the form of [bottom_left, top_right].
-        layer : list
-            The physical layer information of the object,
-            represented as a list with two elements: [name, purpose].
-        text : str
-            The text content.
-        name : str
-            Object name.
-        params : dict
-            Dictionary storing the parameters associated with the object.
-
-        Returns
-        -------
-        Text
-
-        See Also
-        --------
-        PhysicalObject : base class.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> text0 = laygo2.object.physical.Text(xy=[0, 0],
-            layer=['text', 'drawing'], text='test', params=None)
-        >>> print(text0)
-        <laygo2.object.physical.Text object at 0x000002049A77FD90>
-            name: None,
-            class: Text,
-            xy: [0, 0],
-            params: None,
-            layer: ['text', 'drawing'],
-            text: test
-
-        Notes
-        -----
-        **(Korean)**: Text 클래스의 생성자 함수.
-
-        파라미터
-            - xy(numpy.ndarray): 객체의 물리적 좌표, bbox.
-            - layer(list): 객체의 layer 정보.
-            - text(str): 텍스트 내용.
-            - name(str): 객체의 이름.
-            - params(dict): 객체의 주요 속성을 갖는 dict.
-
-        """
-        self.layer = layer
-        self.text = text
-
-        PhysicalObject.__init__(self, xy=xy, name=name, params=params)
-
-    def summarize(self):
-        """Get object information summary."""
-        return (
-            PhysicalObject.summarize(self)
-            + "    layer: "
-            + str(self.layer)
-            + ", \n"
-            + "    text: "
-            + str(self.text)
-            + ", \n"
-        )
-
-
-class Instance(IterablePhysicalObject):
-    """
-    Instance object class.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> inst0_pins = dict()
-    >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]],
-            layer = ['M1', 'drawing'], netname = 'in')
-    >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]],
-            layer=['M1', 'drawing'], netname='out')
-    >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100],
-            libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200],
-            unit_size=[100, 100], pins=inst0_pins, transform='R0')
-    >>> print(inst0)
-    <laygo2.object.physical.Instance object at 0x000001AF458AF8E0>
-        name: I0,
-        class: Instance,
-        xy: [100, 100],
-        params: None,
-        size: [500, 300],
-        shape: [3, 2],
-        pitch: [200, 200],
-        transform: R0,
-        pins: {'in': <laygo2.object.physical.Pin object at 0x000001AF560D6170>,
-               'out': <laygo2.object.physical.Pin object at 0x000001AF560D5F30>},
-    >>> print( inst0[1,0].xy0 )
-    array([300, 100])
-
-    Notes
-    -----
-    **(Korean)**: Instance 객체 클래스.
-    """
-
-    # TODO: update (maybe) xy and sub-elements after transform property is updated.
-
-    libname = None
-    """
-    str: The library name of the object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> inst0_pins = dict() 
-    >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]], 
-            layer = ['M1', 'drawing'], netname = 'in') 
-    >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]], 
-            layer=['M1', 'drawing'], netname='out')
-    >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100], 
-            libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200], 
-            unit_size=[100, 100], pins=inst0_pins, transform='R0')
-    >>> inst0.libname 
-    'mylib'
-    
-    .. image:: ../assets/img/object_physical_instance_libname.png
-      :height: 250
-
-    Notes
-    -----
-    **(Korean)**: 객체의 라이브러리 이름.
-    """
-
-    cellname = None
-    """
-    str: The cellname of the instance object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> inst0_pins = dict() 
-    >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]], 
-            layer = ['M1', 'drawing'], netname = 'in') 
-    >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]], 
-            layer=['M1', 'drawing'], netname='out')
-    >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100], 
-            libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200], 
-            unit_size=[100, 100], pins=inst0_pins, transform='R0')
-    >>> inst0.cellname
-    'mycell'
-    
-    .. image:: ../assets/img/object_physical_instance_cellname.png
-      :height: 250
-
-    Notes
-    -----
-    **(Korean)**: 객체가 속한 셀 이름.
-    """
-
-    viewname = None
-    """str: The view name of the instance."""
-
-    shape = None
-    """np.array([int, int]) or None: The mosaic shape of the instance. 
-    None if the instance is non-mosaic."""
-
-    _pitch = None
-    """np.array([int, int]) or None: The internal variable for self.pitch."""
-
-    unit_size = None
-    """
-    numpy.ndarray: The array unit size for the object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> inst0_pins = dict() 
-    >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]], 
-            layer = ['M1', 'drawing'], netname = 'in') 
-    >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]], 
-            layer=['M1', 'drawing'], netname='out')
-    >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100], 
-            libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200], 
-            unit_size=[100, 100], pins=inst0_pins, transform='R0')
-    >>> inst0.unit_size 
-    array([100, 100])
-    
-    .. image:: ../assets/img/object_physical_instance_unit_size.png
-      :height: 250
-
-    Notes
-    -----
-    **(Korean)**: 객체가 배열로 구성되었을 때 단위 크기.
-    """
-
-    transform = "R0"
-    """
-    str: The attribute of the object that defines its transformation 
-    (rotation and mirroring).
-
-    Example
-    -------
-    >>> import laygo2
-    >>> inst0_pins = dict() 
-    >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]], 
-            layer = ['M1', 'drawing'], netname = 'in') 
-    >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]], 
-            layer=['M1', 'drawing'], netname='out')
-    >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100], 
-            libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200], 
-            unit_size=[100, 100], pins=inst0_pins, transform='R0')
-    >>> inst0.transform 
-    "R0"
-    
-    .. image:: ../assets/img/object_physical_instance_transform.png
-      :height: 250
-
-    Notes
-    -----
-    **(Korean)**: 객체의 변환 속성 (R0, MX, MY 등).
-    """
-
-    pins = None
-    """
-    dict: Dictionary of pins belonging to the object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> inst0_pins = dict() 
-    >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]], 
-            layer = ['M1', 'drawing'], netname = 'in') 
-    >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]], 
-            layer=['M1', 'drawing'], netname='out')
-    >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100], 
-            libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200], 
-            unit_size=[100, 100], pins=inst0_pins, transform='R0')
-    >>> inst0.pins 
-    {'in': <laygo2.object.physical.Pin object at 0x000001CA76EE1348>, 
-    'out': <laygo2.object.physical.Pin object at 0x000001CA7709BD48>} 
-    >>> inst0.pins["in"].shape 
-    array([3, 2])
-    >>> inst0.pins["out"].shape 
-    array([3, 2] )
-    >>> inst0.pins["in"][1, 1].xy 
-    array([[300, 300], [310, 310]])
-    
-    .. image:: ../assets/img/object_physical_instance_pins.png
-      :height: 250
-
-    Notes
-    -----
-    **(Korean)**: 객체에 속한 핀들을 갖는 dict.
-    """
-    
-    def get_p(self):
-        return self.pins
-
-    def set_p(self, val):
-        self.pins = val
-
-    p = property(get_p, set_p)
-    """str: Alias of pins."""
-    
-    def _update_pins(self, xy_ofst):
-        """
-        Internal function to update x,y coordinates of the object's pins. 
-        Used as part of _set_xy().
-        """
-        if self.pins is not None:
-            for pn, p in self.pins.items():
-                if np.all(p is not None):
-                    # Update the x and y coordinate values of elements.
-                    for n, e in np.ndenumerate(p):
-                        if e is not None:
-                            e.xy = e.xy + xy_ofst
-
-    def _get_xy(self):
-        """numpy.ndarray(dtype=numpy.int): Retrive x,y coordinate values of
-        the object."""
-        return self._xy
-
-    def _set_xy(self, value):
-        """numpy.ndarray(dtype=numpy.int): Update x,y coordinates of
-        the object."""
-        # Update the coordinate value of its pins.
-        self._update_pins(xy_ofst=value - self.xy)
-        IterablePhysicalObject._set_xy(self, value=value)
-
-    xy = property(_get_xy, _set_xy)
-
-    @property
-    def xy0(self):
-        """
-        numpy.ndarray: The x,y coordinates of the primary corner of the object.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> inst0_pins = dict()
-        >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]],
-                layer = ['M1', 'drawing'], netname = 'in')
-        >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]],
-                layer=['M1', 'drawing'], netname='out')
-        >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100],
-                libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200],
-                unit_size=[100, 100], pins=inst0_pins, transform='R0')
-        >>> inst0.xy0
-        array([100, 100])
-
-        .. image:: ../assets/img/object_physical_instance_xy0.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)**: 객체의 주 코너 좌표.
-        """
-        return self.xy
-
-    @property
-    def xy1(self):
-        """
-        numpy.ndarray: The x,y coordinates of the secondary corner of the object.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> inst0_pins = dict()
-        >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]],
-                layer = ['M1', 'drawing'], netname = 'in')
-        >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]],
-                layer=['M1', 'drawing'], netname='out')
-        >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100],
-                libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200],
-                unit_size=[100, 100], pins=inst0_pins, transform='R0')
-        >>> inst0.xy1
-        array([600, 400])
-
-        .. image:: ../assets/img/object_physical_instance_xy1.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)**: 객체의 보조 코너 좌표.
-        """
-        if self.size is None:
-            return self.xy
-        else:
-            return self.xy + np.dot(self.size, tf.Mt(self.transform).T)
-
-    @property
-    def size(self):
-        """
-        numpy.ndarray: The size of the object ([self.width, self.height]).
-
-        Example
-        -------
-        >>> import laygo2
-        >>> inst0_pins = dict()
-        >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]],
-                layer = ['M1', 'drawing'], netname = 'in')
-        >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]],
-                layer=['M1', 'drawing'], netname='out')
-        >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100],
-                libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200],
-                unit_size=[100, 100], pins=inst0_pins, transform='R0')
-        >>> inst0.size
-        array([500, 300])
-
-        .. image:: ../assets/img/object_physical_instance_size.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)**: 객체의 크기 ([width, height]).
-        """
-        if self.shape is None:
-            return self.unit_size
-        else:
-            return (self.shape - np.array([1, 1])) * self.pitch + self.unit_size
-
-    def get_pitch(self):
-        """numpy.ndarray(dtype=int): Retrive the pitch of the instance."""
-        if self._pitch is None:
-            return self.unit_size
-        else:
-            return self._pitch
-
-    def set_pitch(self, value):
-        """numpy.ndarray(dtype=int): Update the pitch of the instance."""
-        self._pitch = value
-
-    pitch = property(get_pitch, set_pitch)
-    """
-    numpy.ndarray: The pitch between unit objects in the array.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> inst0_pins = dict() 
-    >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]], 
-            layer = ['M1', 'drawing'], netname = 'in') 
-    >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]], 
-            layer=['M1', 'drawing'], netname='out')
-    >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100], 
-            libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200], 
-            unit_size=[100, 100], pins=inst0_pins, transform='R0')
-    >>> inst0.pitch 
-    array([200, 200])
-    
-    .. image:: ../assets/img/object_physical_instance_pitch.png
-      :height: 250
-
-    See Also
-    --------
-    Instance.spacing
-
-    Notes
-    -----
-    **(Korean)**: 배열로 구성된 객체의 단위 객체(element)간 간격 (pitch).
-    """
-
-    def get_spacing(self):
-        return self.pitch
-
-    def set_spacing(self, value):
-        self.pitch = value
-
-    spacing = property(get_spacing, set_spacing)
-    """
-    numpy.ndarray: Spacing between unit object of the object in array.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> inst0_pins = dict() 
-    >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]], 
-            layer = ['M1', 'drawing'], netname = 'in') 
-    >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]], 
-            layer=['M1', 'drawing'], netname='out')
-    >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100], 
-            libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200], 
-            unit_size=[100, 100], pins=inst0_pins, transform='R0')
-    >>> inst0.spacing 
-    array([200, 200])
-    
-    .. image:: ../assets/img/object_physical_instance_spacing.png
-      :height: 250
-
-    See Also
-    --------
-    Instance.pitch
-
-    Notes
-    -----
-    **(Korean)**: 배열로 구성된 객체의 단위 객체(element)간 간격 (spacing).
-    """
-
-    @property
-    def bbox(self):
-        """The physical bounding box of the object."""
-        bbox = np.array([self.xy0, self.xy1])
-        # return bbox
-        # return self.xy + np.dot(self.size, tf.Mt(self.transform).T)
-        return np.sort(bbox, axis=0)
-
-    @property
-    def height(self):
-        """
-        int: The height of the object.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> inst0_pins = dict()
-        >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]],
-                layer = ['M1', 'drawing'], netname = 'in')
-        >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]],
-                layer=['M1', 'drawing'], netname='out')
-        >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100],
-                libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200],
-                unit_size=[100, 100], pins=inst0_pins, transform='R0')
-        >>> inst0.height
-        300
-
-        .. image:: ../assets/img/object_physical_instance_height.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)**: 객체의 높이.
-        """
-        return abs(self.bbox[1][1] - self.bbox[0][1])
-
-    @property
-    def width(self):
-        """
-        int: The width of the object.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> inst0_pins = dict()
-        >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]],
-                layer = ['M1', 'drawing'], netname = 'in')
-        >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]],
-                layer=['M1', 'drawing'], netname='out')
-        >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100],
-                libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200],
-                unit_size=[100, 100], pins=inst0_pins, transform='R0')
-        >>> inst0.width
-        500
-
-        .. image:: ../assets/img/object_physical_instance_width.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)**: 객체의 폭.
-        """
-        return abs(self.bbox[1][0] - self.bbox[0][0])
-
-    @property
-    def height_vec(self):
-        """numpy.ndarray(dtype=int): The height direction vector [0, self.height]
-        of the object."""
-        return np.array([0, self.height])
-
-    @property
-    def width_vec(self):
-        """numpy.ndarray(dtype=int): The width direction vector [self.width, 0]
-        of the object."""
-        return np.array([self.width, 0])
-
-    def __init__(
-        self,
-        xy,
-        libname,
-        cellname,
-        viewname="layout",
-        shape=None,
-        pitch=None,
-        transform="R0",
-        unit_size=np.array([0, 0]),
-        pins=None,
-        name=None,
-        params=None,
-    ):
-        """
-        The constructor function.
-
-        Parameters
-        ----------
-        xy : numpy.ndarray
-            The primary coordinate ([x0, y0]) of the object.
-        libname : str
-            The library name of the object.
-        cellname : str
-            The cell name of the object.
-        shape : numpy.ndarray
-            The shape [col, row] of the elements.
-        pitch : numpy.ndarray
-            The pitch between unit objects in the array.
-        transform : str
-            The attribute of the object that defines its transformation 
-            (rotation and mirroring).
-        unit_size : list
-            The array unit size for the object.
-        pins : dict
-            Dictionary of pins belonging to the object.
-        name : str
-            Object name.
-        params : dict
-            (optional) Dictionary storing the parameters associated with 
-            the object.
-
-        Returns
-        -------
-        Instance : The constructed Instance object.
-
-        See Also
-        --------
-        IterablePhysicalObject
-
-        Example
-        -------
-        >>> import laygo2
-        >>> inst0_pins = dict()
-        >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]],
-                layer = ['M1', 'drawing'], netname = 'in')
-        >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]],
-                layer=['M1', 'drawing'], netname='out')
-        >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100],
-                libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200],
-                unit_size=[100, 100], pins=inst0_pins, transform='R0')
-        >>> print(inst0)
-        <laygo2.object.physical.Instance object at 0x000001AF458AF8E0>
-            name: I0,
-            class: Instance,
-            xy: [100, 100],
-            params: None,
-            size: [500, 300],
-            shape: [3, 2],
-            pitch: [200, 200],
-            transform: R0,
-            pins: {'in': <laygo2.object.physical.Pin object at 0x000001AF560D6170>,
-                   'out': <laygo2.object.physical.Pin object at 0x000001AF560D5F30>},
-        >>> print( inst0[1,0].xy0 )
-        array([300, 100])
-
-        .. image:: ../assets/img/object_physical_instance_init.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)**: Instance 클래스의 생성함수
-
-        파라미터
-            - xy(numpy.ndarray): 객체의 주좌표 [x0, y0].
-            - libname(str): 객체의 library 이름.
-            - cellname(str): 객체의 cell 이름.
-            - shape(numpy.ndarray): elements의 배열 크기 ([column, row]).
-            - pitch(numpy.ndarray): 배열로 구성된 객체의 구성 요소 (element) 간격 (pitch).
-            - transform(str): 객체의 변환 속성.
-            - unit_size(list): 객체의 단위 크기.
-            - pins(dict): 객체에 속한 핀들을 갖는 dict.
-            - name(str): 객체의 이름.
-            - params(dict): 객체의 주요 속성을 갖는 dict.
-        """
-        # Assign parameters.
-        xy = np.asarray(xy)
-        self.libname = libname
-        self.cellname = cellname
-        self.viewname = viewname
-        if shape is not None:
-            _shape = np.asarray(shape)
-            if _shape.shape != (2,):
-                raise ValueError("Instance shape should be a (2, ) numpy array or None.")
-            self.shape = _shape
-        if pitch is not None:
-            self.pitch = np.asarray(pitch)
-        self.transform = transform
-        self.unit_size = np.asarray(unit_size)
-
-        # Construct an array for elements.
-        if shape is None:
-            # elements = self  # self-referencing causes recursion errors.
-            # (Deprecated).
-            elements = None
-        else:
-            _shape = tuple(shape)
-            elements = np.zeros(_shape, dtype=object)
-            # elements = LayoutObjectArray(np.zeros(_shape, dtype=np.object))
-            _it = np.nditer(elements, flags=["multi_index", "refs_ok"])
-            while not _it.finished:
-                _idx = _it.multi_index
-                _xy = xy + np.dot(self.pitch * np.array(_idx), tf.Mt(self.transform).T)
-                inst = Instance(
-                    xy=_xy,
-                    libname=libname,
-                    cellname=cellname,
-                    shape=None,
-                    pitch=pitch,
-                    transform=self.transform,
-                    unit_size=self.unit_size,
-                    pins=pins,
-                    name=name,
-                    params=params,
-                )
-                elements[_idx] = inst
-                _it.iternext()
-
-        IterablePhysicalObject.__init__(self, xy=xy, name=name, params=params, elements=elements)
-        # Create the pin dictionary. Can we do the same thing without generating
-        # these many Pin objects?
-        self.pins = dict()
-        if pins is not None:
-            if not isinstance(pins, dict):
-                raise ValueError("The pins parameter for Instance objects should be a dictionary.")
-            for pn, p in pins.items():
-                _xy0 = xy + np.dot(p.xy, tf.Mt(transform).T)
-                if shape is not None:
-                    elements = []
-                    for i in range(shape[0]):
-                        elements.append([])
-                        for j in range(shape[1]):
-                            _xy = _xy0 + np.dot(self.pitch * np.array([i, j]), tf.Mt(transform).T)
-                            # If p has elements, they need to be copied and
-                            # transferred to the new pin.
-                            _pelem = None
-                            if p.elements is not None:
-                                _pelem = np.empty(p.elements.shape, dtype=object)
-                                for _idx, _pe in np.ndenumerate(p.elements):
-                                    _pexy0 = (
-                                        xy
-                                        + np.dot(_pe.xy, tf.Mt(transform).T)
-                                        + np.dot(
-                                            self.pitch * np.array([i, j]),
-                                            tf.Mt(transform).T,
-                                        )
-                                    )
-                                    _pelem[_idx] = Pin(
-                                        xy=_pexy0,
-                                        netname=_pe.netname,
-                                        layer=_pe.layer,
-                                        name=_pe.name,
-                                        master=self,
-                                    )
-                            pin = Pin(
-                                xy=_xy,
-                                netname=p.netname,
-                                layer=p.layer,
-                                name=p.name,
-                                master=self,
-                                elements=_pelem,
-                            )  # master uses self instead of self.elements[i, j].
-                            elements[i].append(pin)
-                    elements = np.array(elements)
-                else:
-                    # If p has elements, they need to be copied and transferred
-                    # to the new pin.
-                    _pelem = None
-                    if p.elements is not None:
-                        _pelem = np.empty(p.elements.shape, dtype=object)
-                        for _idx, _pe in np.ndenumerate(p.elements):
-                            _pexy0 = xy + np.dot(_pe.xy, tf.Mt(transform).T)
-                            _pelem[_idx] = Pin(
-                                xy=_pexy0,
-                                netname=_pe.netname,
-                                layer=_pe.layer,
-                                name=_pe.name,
-                                master=self,
-                            )
-                    elements = _pelem
-                self.pins[pn] = Pin(
-                    xy=_xy0,
-                    netname=p.netname,
-                    layer=p.layer,
-                    name=p.name,
-                    master=self,
-                    elements=elements,
-                )
-
-    def summarize(self):
-        """Return the summary of the object information."""
-        _shape = str(None if self.shape is None else self.shape.tolist())
-        return (
-            PhysicalObject.summarize(self)
-            + "    size: "
-            + str(self.size.tolist())
-            + ", \n"
-            + "    shape: "
-            + _shape
-            + ", \n"
-            + "    pitch: "
-            + str(self.pitch.tolist())
-            + ", \n"
-            + "    transform: "
-            + str(self.transform)
-            + ", \n"
-            + "    pins: "
-            + str(self.pins)
-            + ", \n"
-        )
-
-    def update_netname(self, netmap: dict):
-        """
-        Update the netname information for all pins belonging 
-        to this object.
-        """
-        for pn, p in self.pins.items():
-            if p.netname in netmap:
-                p.netname = netmap[p.netname]  # update netname information
-
-
-class VirtualInstance(Instance):  # IterablePhysicalObject):
-    """
-    The VirtualInstance class implements functions for a group of objects 
-    to be treated as a single instance with dedicated dimensional, 
-    port, and related parameters.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> vinst0_pins = dict()
-    >>> # Pin information
-    >>> vinst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10, 10]],
-            layer=['M1', 'drawing'], netname='in')
-    >>> vinst0_pins['out'] = laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]],
-            layer=['M1', 'drawing'], netname='out')
-    >>> # Element information
-    >>> native_elements = dict()
-    >>> native_elements['R0'] = laygo2.object.physical.Rect(xy=[[0, 0], [10, 10]],
-            layer=['M1', 'drawing'])
-    >>> native_elements['R1'] = laygo2.object.physical.Rect(xy=[[90, 90], [100, 100]],
-            layer=['M1', 'drawing'])
-    >>> native_elements['R2'] = laygo2.object.physical.Rect(xy=[[0, 0], [100, 100]],
-            layer=['prBoundary', 'drawing'])
-    >>> vinst0 = laygo2.object.physical.VirtualInstance(name='I0', libname='mylib',
-            cellname='myvcell', xy=[500, 500], native_elements=native_elements,
-            shape=[3, 2], pitch=[100, 100], unit_size=[100, 100], pins=vinst0_pins,
-            transform='R0')
-    >>> vinst0.native_elements
-    {'R0': <laygo2.object.physical.Rect object at 0x00000204AAFCE170>,
-     'R1': <laygo2.object.physical.Rect object at 0x00000204AAFCEA40>,
-     'R2': <laygo2.object.physical.Rect object at 0x00000204AAFCE0B0>}
-
-    Notes
-    -----
-    **(Korean)**: VirtualInstance 객체 클래스. VirtualInstance는 여러 개의
-    레이아웃 오브젝트를 하나의 그룹으로 묶어 크기/포트 등의 관련된 파라미터
-    들을 이용해 추상화 할 수 있는 객체를 구현한다.
-    """
-
-    native_elements = None
-    """
-    dict: Dictionary that holds the physical element entities 
-        of the VirtualInstance object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> vinst0_pins = dict() 
-    >>> # Pin information
-    >>> vinst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10, 10]], 
-            layer=['M1', 'drawing'], netname='in') 
-    >>> vinst0_pins['out'] = laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]], 
-            layer=['M1', 'drawing'], netname='out')
-    >>> # Element information
-    >>> native_elements = dict() 
-    >>> native_elements['R0'] = laygo2.object.physical.Rect(xy=[[0, 0], [10, 10]], 
-            layer=['M1', 'drawing']) 
-    >>> native_elements['R1'] = laygo2.object.physical.Rect(xy=[[90, 90], [100, 100]], 
-            layer=['M1', 'drawing']) 
-    >>> native_elements['R2'] = laygo2.object.physical.Rect(xy=[[0, 0], [100, 100]], 
-            layer=['prBoundary', 'drawing'])
-    >>> vinst0 = laygo2.object.physical.VirtualInstance(name='I0', libname='mylib', 
-            cellname='myvcell', xy=[500, 500], native_elements=native_elements, 
-            shape=[3, 2], pitch=[100, 100], unit_size=[100, 100], pins=vinst0_pins, 
-            transform='R0')
-    >>> vinst0.native_elements 
-    {'R0': <laygo2.object.physical.Rect object at 0x00000204AAFCE170>, 
-     'R1': <laygo2.object.physical.Rect object at 0x00000204AAFCEA40>, 
-     'R2': <laygo2.object.physical.Rect object at 0x00000204AAFCE0B0>}
-
-    .. image:: ../assets/img/object_physical_VirtualInstance_native_elements.png
-      :height: 250
-
-    Notes
-    -----
-    **(Korean)**: 객체를 구성하는 하위 물리 객체들(Rect, Path, Pin, Text, Instance 등)을 갖고 있는 dict.
-    """
-    # Dict[PhysicalObject] the elements that compose the virtual instance. Its keys represent the names of the elements.
-
-    def __init__(
-        self,
-        xy,
-        libname,
-        cellname,
-        native_elements,
-        viewname="layout",
-        shape=None,
-        pitch=None,
-        transform="R0",
-        unit_size=np.array([0, 0]),
-        pins=None,
-        name=None,
-        params=None,
-    ):
-        """
-        The constructor function.
-
-        Parameters
-        ----------
-        xy : numpy.ndarray
-            Physical coordinate values of the object
-            in the form of [bottom_left, top_right].
-        libname : str
-            The library name of the object.
-        cellname : str
-            The cell name of the object.
-        native_elements : dict
-            Dictionary that holds the physical element entities 
-            of the VirtualInstance object.
-        shape : numpy.ndarray
-            The shape [col, row] of the elements.
-        pitch : numpy.ndarray
-            The pitch between unit objects in the array.
-        transform : str
-            The attribute of the object that defines its transformation 
-            (rotation and mirroring).
-        unit_size : list
-            Unit size of object.
-        pins : dict
-            The array unit size for the object.
-        name : str
-            Object name.
-        params : dict
-            (optional) Dictionary storing the parameters associated with 
-            the object.
-
-        Returns
-        -------
-        laygo2.VirtualInstance : The constructed VirtualInstance object.
-
-        See Also
-        --------
-        Instance
-
-        Example
-        -------
-        >>> import laygo2
-        >>> vinst0_pins = dict()
-        >>> # Pin information
-        >>> vinst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10, 10]],
-                layer=['M1', 'drawing'], netname='in')
-        >>> vinst0_pins['out'] = laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]],
-                layer=['M1', 'drawing'], netname='out')
-        >>> # Element information
-        >>> native_elements = dict()
-        >>> native_elements['R0'] = laygo2.object.physical.Rect(xy=[[0, 0], [10, 10]],
-                layer=['M1', 'drawing'])
-        >>> native_elements['R1'] = laygo2.object.physical.Rect(xy=[[90, 90], [100, 100]],
-                layer=['M1', 'drawing'])
-        >>> native_elements['R2'] = laygo2.object.physical.Rect(xy=[[0, 0], [100, 100]],
-                layer=['prBoundary', 'drawing'])
-        >>> vinst0 = laygo2.object.physical.VirtualInstance(name='I0', libname='mylib',
-                cellname='myvcell', xy=[500, 500], native_elements=native_elements,
-                shape=[3, 2], pitch=[100, 100], unit_size=[100, 100], pins=vinst0_pins,
-                transform='R0')
-        >>> vinst0.native_elements
-        {'R0': <laygo2.object.physical.Rect object at 0x00000204AAFCE170>,
-         'R1': <laygo2.object.physical.Rect object at 0x00000204AAFCEA40>,
-         'R2': <laygo2.object.physical.Rect object at 0x00000204AAFCE0B0>}
-
-        .. image:: ../assets/img/object_physical_VirtualInstance_init.png
-          :height: 250
-
-        Notes
-        -----
-        **(Korean)**: VirtualInstance 클래스의 생성자.
-
-        파라미터
-        - xy(numpy.ndarray): 객체의 주좌표 [x0, y0].
-        - libname(str): 객체의 library 이름.
-        - cellname(str): 객체의 cell이름.
-        - native_elements(dict): 객체를 구성하는 물리 객체를 갖는 dict.
-        - shape(numpy.ndarray): elements의 배열 크기 ([col, row]).
-        - pitch(numpy.ndarray): 배열로 구성된 객체의 하위 객체 (element)간의 간격.
-        - transform(str): 객체의 변환 속성 (R0, MX, MY 등).
-        - unit_size(list): 객체의 단위 크기.
-        - pins(dict): 객체에 속한 핀들을 갖는 dict.
-        - name(str): 객체의 이름.
-        - params(dict): 객체의 주요 속성을 갖는 dict.
-
-        """
-        self.native_elements = native_elements
-
-        Instance.__init__(
-            self,
-            xy=xy,
-            libname=libname,
-            cellname=cellname,
-            viewname=viewname,
-            shape=shape,
-            pitch=pitch,
-            transform=transform,
-            unit_size=unit_size,
-            pins=pins,
-            name=name,
-            params=params,
-        )
-
-    def summarize(self):
-        """Return the summary of the object information."""
-        return Instance.summarize(self) + "    native elements: " + str(self.native_elements) + "\n"
-
-    def get_element_position(self, obj):
-        """
-        Get x,y coordinates of the element obj (which belongs to the object)
-        relative to the origin (0, 0).
-
-        Parameters
-        ----------
-        obj : element
-            The element belongs to the object.
-        """
-        vinst = self
-        tr = vinst.transform
-        coners = np.zeros((4, 2))
-        v_r = np.zeros(2)  # for rotation
-        bbox_raw = obj.bbox
-        offset = vinst.xy
-        if tr == "R0":
-            v_r = v_r + (1, 1)
-            coners[0] = offset + v_r * bbox_raw[0]
-            coners[2] = offset + v_r * bbox_raw[1]
-        elif tr == "MX":
-            v_r = v_r + (1, -1)
-            coners[1] = offset + v_r * bbox_raw[0]
-            coners[3] = offset + v_r * bbox_raw[1]
-            coners[0] = coners[0] + (coners[1][0], coners[3][1])
-            coners[2] = coners[2] + (coners[3][0], coners[1][1])
-        elif tr == "MY":
-            v_r = v_r + (-1, 1)
-            coners[3] = offset + v_r * bbox_raw[0]
-            coners[1] = offset + v_r * bbox_raw[1]
-            coners[0] = coners[0] + (coners[1][0], coners[3][1])
-            coners[2] = coners[2] + (coners[3][0], coners[1][1])
-        elif tr == "R90":
-            v_r = v_r + (-1, -1)
-            coners[2] = offset + v_r * bbox_raw[0]
-            coners[0] = offset + v_r * bbox_raw[1]
-        else:
-            raise ValueError(" Others transfom not implemented")
-        return coners[0], coners[2]
-
-class Via(IterablePhysicalObject):
-    """
-    Via object class.
-
-    Attributes
-    ----------
-    netname : str
-    color : str
-    size : np.array(dtype=np.int)
-
-    Methods
-    -------
-    """
-
-    netname = None
-    size = np.array([0,0])
-    unit_size = None
-    _pitch = None
-    transform = 'R0'
-    color = None
-    
-    def _get_xy(self):
-        """numpy.ndarray(dtype=numpy.int): Get the x and y coordinate values of this object."""
-        return self._xy
-
-    def _set_xy(self, value):
-        """numpy.ndarray(dtype=numpy.int): Set the x and y coordinate values of this object."""
-        # Update the coordinate value of its pins.
-        IterablePhysicalObject._set_xy(self, value=value)
-
-    xy = property(_get_xy, _set_xy)
-    
-    @property
-    def xy0(self):
-        """attribute
-        numpy.ndarray: Coordinates of major corner of object.
-
-        
-
-        Examples
-        --------
-       
-        Notes
-        -----
-        Related Images:
-
-        Reference in Korean:
-        numpy.ndarray: 객체의 주 코너 좌표.
-        """
-        return self.xy
-
-    @property
-    def xy1(self):
-        """attribute
-        numpy.ndarray: Coordinates of minor corner of object.
-
-        Examples
-        --------
-
-        Notes
-        -----
-        Related Images:
-
-        Reference in Korean:
-        numpy.ndarray: 객체의 보조 코너 좌표.
-        """
-        if self.size is None:
-            return self.xy
-        else:
-            return self.xy + np.dot(self.size, tf.Mt(self.transform).T)
-
-    @property
-    def bbox(self):
-        bbox = np.array([self.xy0, self.xy1])
-        #return bbox
-        #return self.xy + np.dot(self.size, tf.Mt(self.transform).T)
-        return np.sort(bbox, axis=0)
-     
-    def __init__(self, xy, color=None, name=None, netname=None, params=None, transform= 'R0',elements=None):
-
-        xy = np.asarray(xy)
-        if netname is None:
-            self.netname = name
-        else:
-            self.netname = netname
-        self.color = color
-        IterablePhysicalObject.__init__(self, xy=xy, name=name, params=params, elements=elements)
-
-
-    def summarize(self):
-        """Return the summary of the object information."""
-        return IterablePhysicalObject.summarize(self) + ", " + \
-                                              "netname: " + str(self.netname)
-
-
-# Test
-if __name__ == "__main__":
-    test_rect = False
-    test_path = False
-    test_pin = False
-    test_text = False
-    test_pointer = False
-    test_instance = True
-    test_virtual_instance = False
-
-    # You can create various objects by running part of the following commands.
-    if test_rect:
-        print("Rect test")
-        rect0 = Rect(
-            xy=[[0, 0], [100, 100]],
-            layer=["M1", "drawing"],
-            netname="net0",
-            params={"maxI": 0.005},
-        )
-        print(rect0)
-    if test_path:
-        print("Path test")
-        path0 = Path(
-            xy=[[0, 0], [0, 100]],
-            width=10,
-            extension=5,
-            layer=["M1", "drawing"],
-            netname="net0",
-        )
-        print(path0)
-    if test_pin:
-        print("Pin test")
-        pin0 = Pin(
-            xy=[[0, 0], [100, 100]],
-            layer=["M1", "drawing"],
-            netname="net0",
-            master=rect0,
-            params={"direction": "input"},
-        )
-        print(pin0)
-    if test_text:
-        print("Text test")
-        text0 = Text(xy=[0, 0], layer=["text", "drawing"], text="test", params=None)
-        print(text0)
-    if test_instance:
-        print("Instance test - creating a vanilla instance.")
-        inst0_pins = dict()
-        inst0_pins["in"] = Pin(xy=[[0, 0], [10, 10]], layer=["M1", "drawing"], netname="in")
-        inst0_pins["out"] = Pin(xy=[[90, 90], [100, 100]], layer=["M1", "drawing"], netname="out")
-        inst0 = Instance(
-            name="I0",
-            xy=[100, 100],
-            libname="mylib",
-            cellname="mycell",
-            shape=[3, 2],
-            pitch=[100, 100],
-            unit_size=[100, 100],
-            pins=inst0_pins,
-            transform="R0",
-        )
-        print("  ", inst0)
-        print("  ", inst0.pointers)
-        print(inst0.elements)
-        for idx, it in inst0.ndenumerate():
-            print("what?")
-            print("  ", idx, it)
-            print("  ", idx, it.pins["in"])
-        print("Instance test - updating the instance's coordinate values.")
-        inst0.xy = [200, 200]
-        print("  ", inst0)
-        print("  ", inst0.pointers)
-        for idx, it in inst0.ndenumerate():
-            print("  ", idx, it)
-            print("  ", idx, it.pins["in"])
-    if test_virtual_instance:
-        print("VirtualInstance test - creating a vanilla virtual instance.")
-        inst1_pins = dict()
-        inst1_pins["in"] = Pin(xy=[[0, 0], [10, 10]], layer=["M1", "drawing"], netname="in")
-        inst1_pins["out"] = Pin(xy=[[90, 90], [100, 100]], layer=["M1", "drawing"], netname="out")
-        inst1_native_elements = dict()
-        inst1_native_elements["R0"] = Rect(xy=[[0, 0], [10, 10]], layer=["M1", "drawing"])
-        inst1_native_elements["R1"] = Rect(xy=[[90, 90], [100, 100]], layer=["M1", "drawing"])
-        inst1_native_elements["R2"] = Rect(xy=[[0, 0], [100, 100]], layer=["prBoundary", "drawing"])
-        inst1 = VirtualInstance(
-            name="I0",
-            libname="mylib",
-            cellname="myvcell",
-            xy=[500, 500],
-            native_elements=inst1_native_elements,
-            shape=[3, 2],
-            pitch=[100, 100],
-            unit_size=[100, 100],
-            pins=inst1_pins,
-            transform="R0",
-        )
-        print("  ", inst1)
-        for idx, it in inst1.ndenumerate():
-            print("  ", idx, it.pins["in"])
-        for idx, it in inst1.pins["in"].ndenumerate():
-            print("  ", idx, it)
+#!/usr/bin/python
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+"""
+**laygo2.object.physical** module provides classes for physical objects 
+used in IC layout design. The supported physical objects include:
+
+:obj:`PhysicalObject` - Base class for all physical layout objects.
+
+:obj:`IterablePhysicalObject` - Base class for physical objects that can be iterated (eg. arrayed instances).
+
+:obj:`PhysicalObjectGroup` - Defines a group of physical objects (currently not implemented).
+
+:obj:`Rect` - Represents a rectangular shape.
+
+:obj:`Path` - Defines a path.
+
+:obj:`Pin` - Defines a pin.
+
+:obj:`Text` - Defines a text label.
+
+:obj:`Instance` - Represents an instance of a design element.
+
+:obj:`VirtualInstance` - Represents a virtual instance composed of multiple physical objects, acting as a single instance.
+
+Examples of the physical objects supported by this module are shown in the followng figure.
+
+.. image:: ../assets/img/user_guide_physical.png
+
+
+
+Check the following links for further details.
+"""
+
+__author__ = "Jaeduk Han"
+__maintainer__ = "Jaeduk Han"
+__status__ = "Prototype"
+
+import numpy as np
+
+# from copy import deepcopy
+import laygo2.util.transform as tf
+
+
+class PhysicalObject:
+    """
+    Base class for physical layout objects with physical coordinate info.
+
+    Notes
+    -----
+    **(Korean)**: 물리 객체들의 기본 클래스, 물리 좌표 정보를 갖고 있다.
+
+    """
+
+    def _get_xy(self):
+        """numpy.ndarray(dtype=numpy.int): Retrive x,y coordinate values of
+        the object."""
+        return self._xy
+
+    def _set_xy(self, value):
+        """numpy.ndarray(dtype=numpy.int): Update x,y coordinates of
+        the object."""
+        self._xy = np.asarray(value, dtype=int)
+        self._update_pointers()
+
+    name = None
+    """str: Object name.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]], 
+            name="test", params={'maxI': 0.005})
+    >>> obj.name 
+    “test”
+
+    .. image:: ../assets/img/object_physical_PhysicalObject_name.png
+      :height: 250
+
+    """
+
+    _xy = np.zeros(2, dtype=int)
+    """numpy.ndarray(dtype=numpy.int): The x and y coordinate values 
+    stored within."""
+
+    xy = property(_get_xy, _set_xy)
+    """numpy.ndarray: Physical coordinate values of the object 
+    in the form of [bottom_left, top_right].
+
+    Example
+    -------
+    >>> import laygo2
+    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]], 
+            name="test", params={'maxI': 0.005})
+    >>> obj.xy 
+    array([[  0,   0], 
+           [200, 200]])
+    
+    .. image:: ../assets/img/object_physical_PhysicalObject_xy.png
+      :height: 250
+
+    """
+
+    master = None
+    """numpy.ndarray: Master ojbect for current object (for arrays and pins).
+
+    Example
+    -------
+    >>> import laygo2
+    >>> obj1 = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]], 
+            name="test1", params=None) 
+    >>> obj2 = laygo2.object.physical.Pin(xy = [[0, 0], [100, 100]], 
+            layer = ["M1", "drawing"], master=obj1) 
+    >>> obj2.master
+    <laygo2.object.physical.PhysicalObject object at 0x00000204AAF3C7C0>
+
+    Notes
+    -----
+    **(Korean)**: 객체의 master (배열 element 또는 pin 객체들의 master 객체에 연결).
+    """
+
+    params = None
+    """dict: Dictionary storing the parameters associated with the object
+
+    Example
+    -------
+    >>> import laygo2
+    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]], 
+            name="test", params={'maxI': 0.005})
+    >>> obj.params 
+    {‘maxI’: 0.005 }
+
+    Notes
+    -----
+    **(Korean)**: 객체의 속성.
+    """
+
+    pointers = None
+    """dict: The dictionary containing the key-value pairs of the major physical 
+    coordinates of the object, such as 'left', 'right', 'top', 'bottom', 
+    'bottom_left', 'center', etc.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]])
+    >>> obj.pointers 
+    {'left': array([0, 100]), 'right': array([200, 100]),
+     'bottom': array([100, 0]), 'top': array([100, 200]),
+     'bottom_left': array([0, 0]), 'bottom_right': array([200, 0]),
+     'top_left': array([0, 200]), 'top_right': array([200, 200]),
+     ‘center’: array( [100, 100] ) 
+    }
+
+    .. image:: ../assets/img/object_physical_PhysicalObject_pointers.png
+      :height: 250
+
+    Notes
+    -----
+    **(Korean)**: 객체의 주요 좌표들을 담고 있는 dictionary.
+    """
+
+    # Frequently used pointers
+    left = None
+    """numpy.ndarray: The left-center coordinate of the object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]])
+    >>> obj.left
+    array([  0, 100])
+    
+    .. image:: ../assets/img/object_physical_PhysicalObject_left.png
+      :height: 250
+    """
+
+    right = None
+    """numpy.ndarray: The right-center coordinate of the object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]])
+    >>> obj.right
+    array([200, 100])
+    
+    .. image:: ../assets/img/object_physical_PhysicalObject_right.png
+      :height: 250
+    """
+
+    top = None
+    """numpy.ndarray: The top-center coordinate of the object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]])
+    >>> obj.top
+    array([100, 200])
+    
+    .. image:: ../assets/img/object_physical_PhysicalObject_top.png
+      :height: 250
+    """
+
+    bottom = None
+    """numpy.ndarray: The bottom-center coordinate of the object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]])
+    >>> obj.top
+    array([100,   0])
+    
+    .. image:: ../assets/img/object_physical_PhysicalObject_bottom.png
+      :height: 250
+    """
+
+    center = None
+    """numpy.ndarray: The center-center coordinate of the object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]])
+    >>> obj.center
+    array([100, 100])
+    
+    .. image:: ../assets/img/object_physical_PhysicalObject_center.png
+      :height: 250
+    """
+
+    bottom_left = None
+    """numpy.ndarray: The bottom-left coordinate of the object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]])
+    >>> obj.bottom_left
+    array([  0,   0])
+    
+    .. image:: ../assets/img/object_physical_PhysicalObject_bottom_left.png
+      :height: 250
+    """
+
+    bottom_right = None
+    """numpy.ndarray: The bottom-right coordinate of the object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]])
+    >>> obj.bottom_right
+    array([200,   0])
+    
+    .. image:: ../assets/img/object_physical_PhysicalObject_bottom_right.png 
+      :height: 250
+    """
+
+    top_left = None
+    """numpy.ndarray: The top-left coordinate of the object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]])
+    >>> obj.top_left
+    array([  0, 200])
+    
+    .. image:: ../assets/img/object_physical_PhysicalObject_top_left.png
+      :height: 250
+    """
+
+    top_right = None
+    """numpy.ndarray: The top-right coordinate of the object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]])
+    >>> obj.top_right
+    array([200, 200])
+    
+    .. image:: ../assets/img/object_physical_PhysicalObject_top_right.png
+      :height: 250
+    """
+
+    @property
+    def bbox(self):
+        """numpy.ndarray: The physical bounding box of the object.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]])
+        >>> obj.bbox
+        array([[  0,   0],
+               [200, 200]])
+
+        .. image:: ../assets/img/object_physical_PhysicalObject_bbox.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)**: numpy.ndarray: 객체의 bbox (bounding box).
+        """
+        # if self.xy.ndim == 2:
+        if isinstance(self.xy[0], np.ndarray):
+            return np.sort(np.array([self.xy[0, :], self.xy[1, :]]), axis=0)
+        else:  # single-point object.
+            return np.array([self.xy, self.xy])
+
+    def __init__(self, xy, name=None, params=None):
+        """
+        The constructor function.
+
+        Parameters
+        ----------
+        xy : numpy.ndarray
+            Physical coordinate values of the object
+            in the form of [bottom_left, top_right].
+        name : str
+            Object name.
+        params : dict
+            Dictionary storing the parameters associated with the object.
+
+        Returns
+        -------
+        PhysicalObject
+
+        Example
+        -------
+        >>> import laygo2
+        >>> obj = laygo2.object.physical.PhysicalObject(xy = [[0, 0], [200, 200]],
+                name="test", params={'maxI': 0.005})
+        >>> print(obj)
+        <laygo2.object.physical.PhysicalObject object at 0x000001ECF0022948>
+         name: test,
+         class: PhysicalObject,
+         xy: [[0, 0], [200, 200]],
+         params: {'maxI': 0.005},
+
+        Notes
+        -----
+        **(Korean)** PhysicalObject 클래스의 생성자.
+
+        파라미터
+            - xy(numpy.ndarray): 객체의 물리적 좌표 (bbox).
+            - name(str): 객체의 이름.
+            - params(dict): 객체의 주요 속성을 갖고 있는 dict.
+
+        """
+
+        self.name = name
+        # Initialize pointers.
+        self.pointers = dict()
+        self.pointers["left"] = np.array([0, 0], dtype=int)
+        self.pointers["right"] = np.array([0, 0], dtype=int)
+        self.pointers["bottom"] = np.array([0, 0], dtype=int)
+        self.pointers["top"] = np.array([0, 0], dtype=int)
+        self.pointers["bottom_left"] = np.array([0, 0], dtype=int)
+        self.pointers["bottom_right"] = np.array([0, 0], dtype=int)
+        self.pointers["top_left"] = np.array([0, 0], dtype=int)
+        self.pointers["top_right"] = np.array([0, 0], dtype=int)
+        self.left = self.pointers["left"]
+        self.right = self.pointers["right"]
+        self.bottom = self.pointers["bottom"]
+        self.top = self.pointers["top"]
+        self.bottom_left = self.pointers["bottom_left"]
+        self.bottom_right = self.pointers["bottom_right"]
+        self.top_left = self.pointers["top_left"]
+        self.top_right = self.pointers["top_right"]
+
+        self.params = params  # deepcopy(params)  # deepcopy increases the memory usage.
+        self.xy = xy
+
+    def __str__(self):
+        """Return the summary of the object information."""
+        return self.summarize()
+
+    def summarize(self):
+        """Return the summary of the object information."""
+        name = "None" if self.name is None else self.name
+        return (
+            self.__repr__() + " \n"
+            "    name: "
+            + name
+            + ", \n"
+            + "    class: "
+            + self.__class__.__name__
+            + ", \n"
+            + "    xy: "
+            + str(self.xy.tolist())
+            + ", \n"
+            + "    params: "
+            + str(self.params)
+            + ", \n"
+        )
+
+    def _update_pointers(self):
+        """The internal function that updates the object's pointers
+        after a change in its physical coordinates."""
+        xy_left = np.diag(np.dot(np.array([[1, 0], [0.5, 0.5]]), self.bbox))
+        xy_right = np.diag(np.dot(np.array([[0, 1], [0.5, 0.5]]), self.bbox))
+        xy_bottom = np.diag(np.dot(np.array([[0.5, 0.5], [1, 0]]), self.bbox))
+        xy_top = np.diag(np.dot(np.array([[0.5, 0.5], [0, 1]]), self.bbox))
+        xy_bottom_left = np.diag(np.dot(np.array([[1, 0], [1, 0]]), self.bbox))
+        xy_bottom_right = np.diag(np.dot(np.array([[0, 1], [1, 0]]), self.bbox))
+        xy_top_left = np.diag(np.dot(np.array([[1, 0], [0, 1]]), self.bbox))
+        xy_top_right = np.diag(np.dot(np.array([[0, 1], [0, 1]]), self.bbox))
+        xy_center = np.diag(np.dot(np.array([[0.5, 0.5], [0.5, 0.5]]), self.bbox))
+        self.pointers["left"] = xy_left.astype(int)
+        self.pointers["right"] = xy_right.astype(int)
+        self.pointers["bottom"] = xy_bottom.astype(int)
+        self.pointers["top"] = xy_top.astype(int)
+        self.pointers["bottom_left"] = xy_bottom_left.astype(int)
+        self.pointers["bottom_right"] = xy_bottom_right.astype(int)
+        self.pointers["top_left"] = xy_top_left.astype(int)
+        self.pointers["top_right"] = xy_top_right.astype(int)
+        self.pointers["center"] = xy_center.astype(int)
+        self.left = self.pointers["left"]
+        self.right = self.pointers["right"]
+        self.bottom = self.pointers["bottom"]
+        self.top = self.pointers["top"]
+        self.bottom_left = self.pointers["bottom_left"]
+        self.bottom_right = self.pointers["bottom_right"]
+        self.top_left = self.pointers["top_left"]
+        self.top_right = self.pointers["top_right"]
+        self.center = self.pointers["center"]
+
+
+class IterablePhysicalObject(PhysicalObject):
+    """
+    The base class of entities capable of iterable operations among elements.
+
+    Notes
+    -----
+    **(Korean)**: 구성 요소의 iterable 연산이 가능한 객체들의 기본 클래스.
+
+    """
+
+    elements = None
+    """
+    dict: Numpy array containing its element objects.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> phy0 = laygo2.object.physical.PhysicalObject(xy=[[0, 0], [100, 100]]) 
+    >>> phy1 = laygo2.object.physical.PhysicalObject(xy=[[0, 0], [200, 200]]) 
+    >>> phy2 = laygo2.object.physical.PhysicalObject(xy=[[0, 0], [300, 300]]) 
+    >>> element = [phy0, phy1, phy2] 
+    >>> iphy0 = laygo2.object.physical.IterablePhysicalObject(
+            xy=[[0, 0], [300, 300]], elements = elements)
+    >>> iphy0.elements 
+    array([<laygo2.object.physical.PhysicalObject object at 0x000002049A77FDF0>,
+           <laygo2.object.physical.PhysicalObject object at 0x000002049A77F3D0>,
+           <laygo2.object.physical.PhysicalObject object at 0x000002049A77FF40>],
+          dtype=object)
+
+    Notes
+    -----
+    **(Korean)**: 객체의 하위 구성원을 담고 있는 list.
+    """
+
+    def _get_xy(self):
+        """numpy.ndarray(dtype=numpy.int): Retrive x,y coordinate values of
+        the object."""
+        return self._xy
+
+    def _set_xy(self, value):
+        """numpy.ndarray(dtype=numpy.int): Update x,y coordinates of
+        the object."""
+        # Update the coordinate value of its elements.
+        self._update_elements(xy_ofst=value - self.xy)
+        # Update the coordinate value of the object itself.
+        PhysicalObject._set_xy(self, value=value)
+
+    xy = property(_get_xy, _set_xy)
+
+    @property
+    def shape(self):
+        """Array size of the object.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> phy0 = laygo2.object.physical.PhysicalObject(xy=[[0, 0], [100, 100]])
+        >>> phy1 = laygo2.object.physical.PhysicalObject(xy=[[0, 0], [200, 200]])
+        >>> phy2 = laygo2.object.physical.PhysicalObject(xy=[[0, 0], [300, 300]])
+        >>> element = [phy0, phy1, phy2]
+        >>> iphy0 = laygo2.object.physical.IterablePhysicalObject(
+            xy=[[0, 0], [300, 300]], elements = elements)
+        >>> iphy0.shape
+        array([3])
+
+        Notes
+        -----
+        **(Korean)**: numpy.ndarray: 객체의 element의 배열 크기.
+        """
+        if self.elements is None:
+            return None
+        else:
+            return np.array(self.elements.shape, dtype=int)
+
+    def __init__(self, xy, name=None, params=None, elements=None):
+        """
+        The constructor function.
+
+        Parameters
+        ----------
+        xy : numpy.ndarray
+            Physical coordinate values of the object
+            in the form of [bottom_left, top_right].
+        name : str
+            Object name.
+        params : dict
+            Dictionary storing the parameters associated with the object.
+        elements : list
+            List containing its element objects.
+
+        Returns
+        -------
+        IterablePhysicalObject
+
+        Example
+        -------
+        >>> import laygo2
+        >>> phy0 = laygo2.object.physical.PhysicalObject(xy=[[0, 0], [100, 100]])
+        >>> phy1 = laygo2.object.physical.PhysicalObject(xy=[[0, 0], [200, 200]])
+        >>> phy2 = laygo2.object.physical.PhysicalObject(xy=[[0, 0], [300, 300]])
+        >>> element = [phy0, phy1, phy2]
+        >>> iphy0 = laygo2.object.physical.IterablePhysicalObject(
+            xy=[[0, 0], [300, 300]], elements = elements)
+        >>> print(iphy0)
+        <laygo2.object.physical.IterablePhysicalObject object at 0x000002049A77E380>
+        name: None,
+        class: IterablePhysicalObject,
+        xy: [[0, 0], [300, 300]],
+        params: None,
+
+        Notes
+        -----
+        **(Korean)**:  IterablePhysicalObject 클래스의 생성자.
+
+        파라미터
+            - xy(numpy.ndarray): 객체의 물리 좌표 (bbox).
+            - name(str): 객체의 이름.
+            - params(dict): 객체의 주요 속성이 담긴 dict.
+            - elements(list): 객체의 구성 요소 객체들(elements)이 담긴 list.
+
+        """
+        PhysicalObject.__init__(self, xy=xy, name=name, params=params)
+        if elements is None:
+            self.elements = None
+        else:
+            self.elements = np.asarray(elements)
+
+    def __getitem__(self, pos):
+        """Return the sub-elements of the object, based on the pos parameter."""
+        return self.elements[pos]
+
+    def __setitem__(self, pos, item):
+        """Update the sub-elements of the object, based on the pos and item
+        parameters."""
+        self.elements[pos] = item
+
+    def __iter__(self):
+        """Iterator that maps directly to the elements attribute of
+        this object."""
+        return self.elements.__iter__()
+
+    def __next__(self):
+        """Iterator that maps directly to the iterator function of
+        the elements attribute of this object."""
+        return self.elements.__next__()
+
+    def ndenumerate(self):
+        """Enumerate over the element array. Calls np.ndenumerate() of
+        the elements of this object."""
+        return np.ndenumerate(self.elements)
+
+    def _update_elements(self, xy_ofst):
+        """Update the xy coordinates of the elements of this object,
+        used internally by the _set_xy() function."""
+        if np.all(self.elements is not None):
+            # Update the x and y coordinate values of elements.
+            for n, e in self.ndenumerate():
+                if e is not None:
+                    e.xy = e.xy + xy_ofst
+
+
+class PhysicalObjectGroup(IterablePhysicalObject):
+    """
+    A class for grouped physical objects, designed to be generated as a group
+    in Cadence Virtuoso (currently not implemented).
+    """
+
+    # TODO: implement this.
+
+    def summarize(self):
+        """Get object information summary."""
+        return IterablePhysicalObject.summarize(self) + "    elements: " + str(self.elements) + ", \n"
+
+    def __init__(self, xy, name=None, params=None, elements=None):
+        """
+        The constructor function.
+
+        Parameters
+        ----------
+        xy : numpy.ndarray(dtype=int)
+            The coordinate of this object represented as a Numpy array [x, y].
+        name : str, optional
+            The name of the object.
+        params : dict or None
+            The dictionary that contains the parameters of this object, with
+            parameter names as keys.
+        elements : numpy.ndarray(dtype=LayoutObject) or None
+            The iterable elements of the object.
+        """
+        IterablePhysicalObject.__init__(self, xy=xy, name=name, params=params, elements=elements)
+
+
+'''
+# Deprecated as PhysicalObjectGroup can be used instead in most cases.
+# But the code is preserved for reference.
+class PhysicalObjectArray(np.ndarray):
+    """LayoutObject array class for containing multiple layout objects. Subclassing ndarray to utilize advance slicing
+     functions."""
+    name = None
+    """str: the name of the object."""
+
+    params = None
+    """dict or None: parameters of the object. """
+
+    _xy = None  # np.zeros(2, dtype=int)
+    """numpy.ndarray(dtype=numpy.int): the internal variable of xy."""
+
+    def get_xy(self):
+        """numpy.ndarray(dtype=numpy.int): gets the x and y coordinate values of this object."""
+        return self._xy
+
+    def set_xy(self, value):
+        """numpy.ndarray(dtype=numpy.int): sets the x and y coordinate values of this object."""
+        if value is None:
+            self._xy = value
+        else:
+            self._xy = np.asarray(value, dtype=int)
+
+    xy = property(get_xy, set_xy)
+    """numpy.ndarray(detype=numpy.int): the x and y coordinate values of the object."""
+
+    def moveby(self, delta):
+        """move the array and child objects by delta."""
+        self.xy = self.xy + delta
+        for i in self:
+            i.xy = i.xy + delta
+
+    def __new__(cls, input_array, name=None, xy=None, params=None):
+        """
+        Constructor for ndarray subclasses - check the NumPy manual for details.
+
+        Parameters
+        ----------
+        input_array : np.ndarray
+            An array of LayoutObject objects.
+        name : str
+            The name of the array.
+        xy : numpy.ndarray(dtype=int)
+            The xy-coordinate of the object. The format is [x0, y0].
+        params : dict
+            Additional parameters of the array.
+        """
+        # Input array is an already formed ndarray instance
+        # We first cast to be our class type
+        obj = np.asarray(input_array).view(cls)
+        # add the new attribute to the created instance
+        obj.name = name
+        obj.xy = None if xy is None else np.asarray(xy, dtype=int)
+        obj.params = params
+        # Finally, we must return the newly created object:
+        return obj
+
+    def __array_finalize__(self, obj):
+        """
+        Array finalizing function for subclassing ndarray - check the NumPy manual for details
+        """
+        if obj is None: return
+        # Transfer parameters
+        self.name = getattr(obj, 'name', None)
+        self.xy = getattr(obj, 'xy', None)
+        self.params = getattr(obj, 'params', None)
+
+    def __str__(self):
+        """Return the summary of the object information."""
+        return self.summarize()
+
+    def summarize(self):
+        """Return the summary of the object information."""
+        return "  " + \
+               "name:" + self.name + ", " + \
+               "class:" + self.__class__.__name__ + ", " + \
+               "shape:" + str(self.shape) + ", " + \
+               "xy:" + str(self.xy) + ", " + \
+               "params:" + str(self.params) + "\n" + \
+               "  elements:" + str(np.ndarray.__str__(self)) + "\n"
+'''
+
+
+class Rect(PhysicalObject):
+    """
+    Rectangle object class.
+
+    Example
+    -------
+    >>> from laygo2.object.physical import Rect
+    >>> rect0 = Rect(xy=[[0, 0], [100, 100]], layer=['M1', 'drawing'])
+    >>> print(rect0)
+    <laygo2.object.physical.Rect object at 0x000002049A77F3A0>
+    name: None,
+    class: Rect,
+    xy: [[0, 0], [100, 100]],
+    params: None, , layer: ['M1', 'drawing']
+
+    Notes
+    -----
+    **(Korean)**: 사각형 객체 클래스.
+    """
+
+    layer = None
+    """
+    numpy.ndarray: The physical layer information of the object, 
+    represented as a list with two elements: [name, purpose].
+
+    Example
+    -------
+    >>> import laygo2
+    >>> rect0 = laygo2.object.physical.Rect(xy=[[0, 0], [100, 100]], 
+            layer=['M1', 'drawing'], netname='net0', hextension=20, vextension=20)
+    >>> rect0.layer 
+    ['M1', 'drawing']
+
+    Notes
+    -----
+    **(Korean)**: 객체의 layer 정보 [name, purpose].
+    """
+
+    netname = None
+    """
+    str: The net name associated with the object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> rect0 = laygo2.object.physical.Rect(xy=[[0, 0], [100, 100]], 
+            layer=['M1', 'drawing'], netname='net0', hextension=20, vextension=20)
+    >>> rect0.netname 
+    “net0”
+    
+    Notes
+    -----
+    **(Korean)**: 객체의 노드 이름.
+    """
+
+    hextension = 0
+    """
+    int: The horizontal extension of the rectangle object above its bounding box.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> rect0 = laygo2.object.physical.Rect(xy=[[0, 0], [100, 100]], 
+            layer=['M1', 'drawing'], netname='net0', hextension=20, vextension=20)
+    >>> rect0.hextension 
+    20
+
+    .. image:: ../assets/img/object_physical_rect_hextension.png
+      :height: 250
+
+    Notes
+    -----
+    **(Korean)**: 객체의 기존 좌표로부터 수평 방향으로의 확장값.
+    """
+
+    vextension = 0
+    """
+    int: The vertical extension of the rectangle object above its bounding box.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> rect0 = laygo2.object.physical.Rect(xy=[[0, 0], [100, 100]], 
+            layer=['M1', 'drawing'], netname='net0', hextension=20, vextension=20)
+    >>> rect0.vextension 
+    20
+
+    .. image:: ../assets/img/object_physical_rect_vextension.png
+      :height: 250
+
+    Notes
+    -----
+    **(Korean)**: 객체의 기존 좌표로부터 수직 방향으로의 확장값.
+    """
+
+    color = None
+    """
+    int or None or "not_MPT": The color (multi-patterning identifier) parameter of 
+    the object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> rect0 = laygo2.object.physical.Rect(xy=[[0, 0], [100, 100]], 
+            layer=['M1', 'drawing'], netname='net0', color=1)
+    >>> rect0.color 
+    1
+
+    Notes
+    -----
+    **(Korean)**: 객체의 color (multi-patterning ID).
+    """
+
+    @property
+    def height(self):
+        """
+        int: The height of the object.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> rect0 = laygo2.object.physical.Rect(xy=[[0, 0], [100, 100]],
+                layer=['M1', 'drawing'])
+        >>> rect0.height
+        100
+
+        .. image:: ../assets/img/object_physical_rect_height.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)**: int: 객체의 높이.
+        """
+        return abs(self.xy[0, 1] - self.xy[1, 1])
+
+    @property
+    def width(self):
+        """
+        int: The width of the object.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> rect0 = laygo2.object.physical.Rect(xy=[[0, 0], [100, 100]],
+                layer=['M1', 'drawing'])
+        >>> rect0.width
+        100
+
+        .. image:: ../assets/img/object_physical_rect_width.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)**: int: 객체의 폭.
+        """
+        return abs(self.xy[0, 0] - self.xy[1, 0])
+
+    @property
+    def height_vec(self):
+        """numpy.ndarray(dtype=int): The height direction vector [0, self.height]
+        of the object."""
+        return np.array([0, self.height])
+
+    @property
+    def width_vec(self):
+        """numpy.ndarray(dtype=int): The width direction vector [self.width, 0]
+        of the object."""
+        return np.array([self.width, 0])
+
+    @property
+    def size(self):
+        """
+        numpy.ndarray: The size of the object ([self.width, self.height]).
+
+        Example
+        -------
+        >>> import laygo2
+        >>> rect0 = laygo2.object.physical.Rect(xy=[[0, 0], [100, 100]],
+                layer=['M1', 'drawing'])
+        >>> rect0.size
+        array([100, 100])
+
+        .. image:: ../assets/img/object_physical_rect_size.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)**: numpy.ndarray: 객체의 크기 ([폭, 높이]).
+        """
+        return np.array([self.width, self.height])
+
+    def __init__(
+        self,
+        xy,
+        layer,
+        color=None,
+        hextension=0,
+        vextension=0,
+        name=None,
+        netname=None,
+        params=None,
+    ):
+        """
+        The constructor function.
+
+        Parameters
+        ----------
+        xy : numpy.ndarray
+            Physical coordinate values of the object
+            in the form of [bottom_left, top_right].
+        layer : list
+            The physical layer information of the object,
+            represented as a list with two elements: [name, purpose].
+        hextension : int
+            The horizontal extension value of the object.
+        vextension : int
+            The vertical extension value of the object.
+        name : str
+            Object name.
+        netname : str
+            The net name associated with the object.
+        params : dict
+            Dictionary storing the parameters associated with the object.
+        color : str, optional.
+            The color (multi-patterning identifier) parameter of the object.
+
+        Returns
+        -------
+        Rect
+
+        See Also
+        --------
+        PhysicalObject
+
+        Example
+        -------
+        >>> import laygo2
+        >>> rect0 = laygo2.object.physical.Rect(xy=[[0, 0], [100, 100]],
+                layer=['M1', 'drawing'], netname='net0', color=1)
+        >>> print(rect0)
+        <laygo2.object.physical.Rect object at 0x000002049A77F3A0>
+        name: None,
+        class: Rect,
+        xy: [[0, 0], [100, 100]],
+        params: None, , layer: ['M1', 'drawing'], netname: net0
+
+        .. image:: ../assets/img/object_physical_rect_init.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)**: Rect 클래스의 생성자 함수.
+
+        파라미터
+            - xy(numpy.ndarray): 객체의 물리 좌표 (bbox).
+            - layer(list): 객체의 layer 정보.
+            - hextension(int): 객체의 수평 방향 확장값.
+            - vextension(int): 객체의 수직 방향 확장값.
+            - name(str): 객체의 이름.
+            - netname(str): 객체의 노드 명.
+            - params(dict): 객체의 주요 속성을 갖는 dict [optional].
+            - color(str): 객체의 color [optional].
+        """
+        self.layer = layer
+        if netname is None:
+            self.netname = name
+        else:
+            self.netname = netname
+        self.hextension = hextension
+        self.vextension = vextension
+        self.color = color
+        PhysicalObject.__init__(self, xy=xy, name=name, params=params)
+
+    def align(self, rect2):
+        """
+        Match the length of the self and rect2 objects, if either object has a width or height of 0.
+
+        Parameters
+        ----------
+        rect2 : Rect
+            The rect object to be aligned with `self`.
+        """
+        index = 0
+        r0 = self
+        r1 = rect2
+        if r0.xy[0][0] == r0.xy[1][0]:  # width is zero
+            index = 1
+
+        pnt = np.zeros([2, 2], dtype=int)
+        pnt[0][1] = r0.bbox[1][index]  # tr
+        pnt[1][1] = r1.bbox[1][index]  # tr
+        pnt[0][0] = r0.bbox[0][index]  # bl
+        pnt[1][0] = r1.bbox[0][index]  # bl
+
+        if pnt[1][1] > pnt[0][1]:  # p1-top is upper then p0-top
+            _xy = r0.bbox  # r0 correction
+            _xy[1][index] = pnt[1][1]
+            r0.xy = _xy
+        elif pnt[1][1] < pnt[0][1]:  # p1-top is lower then p0-top
+            _xy = r1.bbox  # r1 correction
+            _xy[1][index] = pnt[0][1]
+            r1.xy = _xy
+
+        if pnt[1][0] < pnt[0][0]:  # p1-bottom is lower then p0-bottom
+            _xy = r0.bbox  # r0 correction
+            _xy[0][index] = pnt[1][0]
+            r0.xy = _xy
+        elif pnt[1][0] > pnt[0][0]:
+            _xy = r1.bbox  # r1 correction
+            _xy[0][index] = pnt[0][0]
+            r1.xy = _xy
+
+    def summarize(self):
+        """Get object information summary."""
+        return (
+            PhysicalObject.summarize(self)
+            + "    layer: "
+            + str(self.layer)
+            + ", \n"
+            + "    netname: "
+            + str(self.netname)
+            + ", \n"
+        )
+
+
+class Path(PhysicalObject):
+    """
+    Path object class.
+
+    Example
+    -------
+    >>> from laygo2.object.physical.Path import Path
+    >>> path0 = Path(xy=[[0, 0], [0, 100]], width=10,
+                     extension=5, layer=['M1', 'drawing'])
+    >>> print(path0)
+    <laygo2.object.physical.Path object at 0x00000280D1F3CE88>
+    name: None,
+    class: Path,
+    xy: [[0, 0], [0, 100]],
+    params: None,
+    width: 10,
+    extension: 5,
+    layer: ['M1', 'drawing'],
+
+    Notes
+    -----
+    **(Korean)**: Path 객체 클래스.
+    """
+
+    # TODO: implement pointers.
+
+    layer = None
+    """numpy.ndarray: The physical layer information of the object, 
+    represented as a list with two elements: [name, purpose].
+    
+    Notes
+    -----
+    **(Korean)**: 객체의 레이어 정보 [name, purpose].
+    """
+
+    netname = None
+    """
+    str: The net name associated with the object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> path0 = laygo2.object.physical.Path(xy=[[0, 0], [0, 100]], width=10, 
+            extension=5, layer=['M1', 'drawing'], netname='net0’)
+    >>> path0.netname 
+    “net0”
+    
+    .. image:: ../assets/img/object_physical_path_netname.png 
+      :height: 250
+
+    Notes
+    -----
+    **(Korean)**: 객체의 노드 명.
+    """
+
+    width = None
+    """
+    int: the width of the object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> path0 = laygo2.object.physical.Path(xy=[[0, 0], [0, 100]], width=10, 
+            extension=5, layer=['M1', 'drawing'], netname='net0’)
+    >>> path0.width 
+    10
+
+    .. image:: ../assets/img/object_physical_path_width.png
+      :height: 250
+
+    Notes
+    -----
+    **(Korean)**: 객체의 폭.
+    """
+
+    extension = 0
+    """
+    int: The path extension from its endpoints.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> path0 = laygo2.object.physical.Path(xy=[[0, 0], [0, 100]], width=10, 
+            extension=5, layer=['M1', 'drawing'], netname='net0’)
+    >>> path0.extension 
+    5
+    
+    .. image:: ../assets/img/object_physical_path_extension.png
+      :height: 250
+
+    Notes
+    -----
+    **(Korean)**: 객체의 양 끝점에서의 확장값.
+    """
+
+    @property
+    def bbox(self):
+        """The physical bounding box of the object."""
+        return np.sort(np.array([self.xy[0], self.xy[-1]]), axis=0)
+
+    def _update_pointers(self):
+        """The internal function that updates the object's pointers
+        after a change in its physical coordinates."""
+        pass
+
+    def __init__(self, xy, layer, width, extension=0, name=None, netname=None, params=None):
+        """
+        The constructor function.
+
+        Parameters
+        ----------
+        xy : numpy.ndarray
+            Physical coordinate values of the object
+            in the form of [bottom_left, top_right].
+        layer : list
+            The physical layer information of the object,
+            represented as a list with two elements: [name, purpose].
+        width : int
+            The width of the object.
+        extension : int
+            The path extension from its endpoints.
+        name : str
+            Object name.
+        netname : str
+            The net name associated with the object.
+        params : dict
+            Dictionary storing the parameters associated with the object.
+
+        Returns
+        -------
+        Path
+
+        Example
+        -------
+        >>> import laygo2
+        >>> path0 = laygo2.object.physical.Path(xy=[[0, 0], [0, 100]], width=10,
+                extension=5, layer=['M1', 'drawing'], netname='net0’)
+        >>> print(path0)
+        <laygo2.object.physical.Path object at 0x00000280D1F3CE88>
+        name: None,
+        class: Path,
+        xy: [[0, 0], [0, 100]],
+        params: None,
+        width: 10,
+        extension: 5,
+        layer: ['M1', 'drawing'],
+        netname: net0
+
+        .. image:: ../assets/img/object_physical_path_init.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)**: Path 객체 생성.
+
+        파라미터
+            - xy(numpy.ndarray): 객체의 물리 좌표 (bbox).
+            - layer(list): 객체의 layer 정보.
+            - width(int): 객체의 폭.
+            - extension(int): 객체의 끝점에서의 확장 값.
+            - name(str): 객체의 이름.
+            - netname(str): 객체의 노드 명.
+            - params(dict): 객체의 주요 속성을 갖는 dict.
+
+        """
+        self.layer = layer
+        self.width = width
+        self.extension = extension
+        self.netname = netname
+        PhysicalObject.__init__(self, xy=xy, name=name, params=params)
+        self.pointers = dict()  # Pointers are invalid for Path objects.
+
+    def summarize(self):
+        """Get object information summary."""
+        return (
+            PhysicalObject.summarize(self)
+            + "    width: "
+            + str(self.width)
+            + ", \n"
+            + "    extension: "
+            + str(self.extension)
+            + ", \n"
+            + "    layer: "
+            + str(self.layer)
+            + ", \n"
+            + "    netname: "
+            + str(self.netname)
+            + ", \n"
+        )
+
+
+class Pin(IterablePhysicalObject):
+    """
+    Pin object class.
+
+    Example
+    -------
+    >>> from laygo2.object.physical import Pin
+    >>> pin0 = Pin(xy=[[0, 0], [100, 100]], layer=['M1', 'drawing'],
+                   netname='net0', params={'direction': 'input'})
+    >>> print(pin0)
+    <laygo2.object.physical.Pin object at 0x000002049A77FF70>
+        name: None,
+        class: Pin,
+        xy: [[0, 0], [100, 100]],
+        params: {'direction': 'input'}, , layer: ['M1' 'drawing'],
+        netname: net0, shape: None, master: None
+
+    Notes
+    -----
+    **(Korean)**: Pin 객체 클래스.
+    """
+
+    layer = None
+    """
+    numpy.ndarray: The physical layer information of the object, 
+    represented as a list with two elements: [name, purpose].
+
+    Example
+    -------
+    >>> import laygo2
+    >>> pin0 = laygo2.object.physical.Pin(xy=[[0, 0], [100, 100]], 
+            layer=['M1', 'drawing'], netname='net0', params={'direction': 'input'})
+    >>> pin0.layer 
+    ['M1', 'drawing']
+    
+    numpy.ndarray: 객체의 layer 정보 [name, purpose].
+    """
+
+    netname = None
+    """
+    str: The net name associated with the object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> pin0 = laygo2.object.physical.Pin(xy=[[0, 0], [100, 100]], 
+            layer=['M1', 'drawing'], netname='net0', params={'direction': 'input'})
+    >>> pin0.netname 
+    “net0”
+    
+    str: 객체의 노드 명.
+    """
+
+    master = None
+    """
+    Instance: The instance that the pin belongs to. Used for pins of instances only.
+    """
+
+    @property
+    def height(self):
+        """
+        int: The height of the object.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> pin0 = laygo2.object.physical.Pin(xy=[[0, 0], [100, 100]],
+            layer=['M1', 'drawing'], netname='net0', params={'direction': 'input'})
+        >>> pin0.height
+        100
+
+        Notes
+        -----
+        **(Korean)**: 객체의 높이.
+        """
+        return abs(self.xy[0, 1] - self.xy[1, 1])
+
+    @property
+    def width(self):
+        """
+        int: The width of the object.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> pin0 = laygo2.object.physical.Pin(xy=[[0, 0], [100, 100]],
+            layer=['M1', 'drawing'], netname='net0', params={'direction': 'input'})
+        >>> pin0.width
+        100
+
+        Notes
+        -----
+        **(Korean)**: 객체의 폭.
+        """
+        return abs(self.xy[0, 0] - self.xy[1, 0])
+
+    @property
+    def size(self):
+        """
+        numpy.ndarray: The size of the object.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> pin0 = laygo2.object.physical.Pin(xy=[[0, 0], [100, 100]],
+            layer=['M1', 'drawing'], netname='net0', params={'direction': 'input'})
+        >>> pin0.size
+        [100, 100]
+
+        Notes
+        -----
+        **(Korean)**: 객체의 크기.
+        """
+        return np.array([self.width, self.height])
+
+    @property
+    def height_vec(self):
+        """numpy.ndarray(dtype=int): The height direction vector [0, self.height]
+        of the object."""
+        return np.array([0, self.height])
+
+    @property
+    def width_vec(self):
+        """numpy.ndarray(dtype=int): The width direction vector [self.width, 0]
+        of the object."""
+        return np.array([self.width, 0])
+
+    def __init__(
+        self,
+        xy,
+        layer,
+        name=None,
+        netname=None,
+        params=None,
+        master=None,
+        elements=None,
+    ):
+        """
+        The constructor function.
+
+        Parameters
+        ----------
+        xy : numpy.ndarray
+            Physical coordinate values of the object
+            in the form of [bottom_left, top_right].
+        layer : list
+            The physical layer information of the object,
+            represented as a list with two elements: [name, purpose].
+        name : str
+            Object name.
+        netname : str
+            The net name associated with the object.
+        params : dict
+            Dictionary storing the parameters associated with the object.
+
+        Returns
+        -------
+        Pin
+
+        Example
+        -------
+        >>> import laygo2
+        >>> pin0 = laygo2.object.physical.Pin(xy=[[0, 0], [100, 100]],
+            layer=['M1', 'drawing'], netname='net0', params={'direction': 'input'})
+        >>> print(pin0)
+        <laygo2.object.physical.Pin object at 0x000002049A77FF70>
+            name: None,
+            class: Pin,
+            xy: [[0, 0], [100, 100]],
+            params: {'direction': 'input'}, , layer: ['M1' 'drawing'],
+            netname: net0, shape: None, master: None
+
+        Notes
+        -----
+        **(Korean)**: Pin 클래스의 생성자 함수
+
+        파라미터
+            - xy(numpy.ndarray): 객체의 물리적 좌표 (bbox).
+            - layer(list): 객체의 layer 정보 ([name, purpose]).
+            - name(str): 객체의 이름.
+            - netname(str): 객체의 노드 명.
+            - params(dict): 객체의 주요 속성을 갖는 dict.
+
+        """
+        self.layer = np.asarray(layer)
+        if netname is None:
+            netname = name
+        self.netname = netname
+        self.master = master
+        IterablePhysicalObject.__init__(self, xy=xy, name=name, params=params, elements=elements)
+
+    def summarize(self):
+        """Get object information summary."""
+        return (
+            IterablePhysicalObject.summarize(self)
+            + "    layer: "
+            + str(self.layer)
+            + ", \n"
+            + "    netname: "
+            + str(self.netname)
+            + ", \n"
+            + "    shape: "
+            + str(self.shape)
+            + ", \n"
+            + "    master: "
+            + str(self.master)
+            + ", \n"
+        )
+
+    def export_to_dict(self):
+        db = dict()
+        db["xy"] = self.xy.tolist()
+        db["layer"] = self.layer.tolist()
+        db["name"] = self.name
+        db["netname"] = self.netname
+        return db
+
+
+class Text(PhysicalObject):
+    """
+    Text object class.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> text0 = laygo2.object.physical.Text(xy=[0, 0],
+        layer=['text', 'drawing'], text='test', params=None)
+    >>> print(text0)
+    <laygo2.object.physical.Text object at 0x000002049A77FD90>
+        name: None,
+        class: Text,
+        xy: [0, 0],
+        params: None,
+        layer: ['text', 'drawing'],
+        text: test
+
+    Notes
+    -----
+    **(Korean)**: Text 객체 클래스.
+    """
+
+    layer = None
+    """
+    list: The physical layer information of the object,
+          represented as a list with two elements: [name, purpose].
+
+    Example
+    -------
+    >>> import laygo2
+    >>> text0 = laygo2.object.physical.Text(xy=[0, 0], 
+            layer=['text', 'drawing'], text='test', params=None)
+    >>> text0.layer 
+    ['text', 'drawing']
+
+    Notes
+    -----
+    **(Korean)**: 객체의 layer 정보 [name, purpose].
+    """
+
+    text = None
+    """
+    str: Text content of the object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> text0 = laygo2.object.physical.Text(xy=[0, 0], 
+            layer=['text', 'drawing'], text='test', params=None)
+    >>> text0.text 
+    'test'
+    
+    Notes
+    -----
+    **(Korean)**: 객체의 텍스트 내용.
+    """
+
+    def __init__(self, xy, layer, text, name=None, params=None):
+        """
+        The constructor function.
+
+        Parameters
+        ----------
+        xy : numpy.ndarray
+            Physical coordinate values of the object
+            in the form of [bottom_left, top_right].
+        layer : list
+            The physical layer information of the object,
+            represented as a list with two elements: [name, purpose].
+        text : str
+            The text content.
+        name : str
+            Object name.
+        params : dict
+            Dictionary storing the parameters associated with the object.
+
+        Returns
+        -------
+        Text
+
+        See Also
+        --------
+        PhysicalObject : base class.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> text0 = laygo2.object.physical.Text(xy=[0, 0],
+            layer=['text', 'drawing'], text='test', params=None)
+        >>> print(text0)
+        <laygo2.object.physical.Text object at 0x000002049A77FD90>
+            name: None,
+            class: Text,
+            xy: [0, 0],
+            params: None,
+            layer: ['text', 'drawing'],
+            text: test
+
+        Notes
+        -----
+        **(Korean)**: Text 클래스의 생성자 함수.
+
+        파라미터
+            - xy(numpy.ndarray): 객체의 물리적 좌표, bbox.
+            - layer(list): 객체의 layer 정보.
+            - text(str): 텍스트 내용.
+            - name(str): 객체의 이름.
+            - params(dict): 객체의 주요 속성을 갖는 dict.
+
+        """
+        self.layer = layer
+        self.text = text
+
+        PhysicalObject.__init__(self, xy=xy, name=name, params=params)
+
+    def summarize(self):
+        """Get object information summary."""
+        return (
+            PhysicalObject.summarize(self)
+            + "    layer: "
+            + str(self.layer)
+            + ", \n"
+            + "    text: "
+            + str(self.text)
+            + ", \n"
+        )
+
+
+class Instance(IterablePhysicalObject):
+    """
+    Instance object class.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> inst0_pins = dict()
+    >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]],
+            layer = ['M1', 'drawing'], netname = 'in')
+    >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]],
+            layer=['M1', 'drawing'], netname='out')
+    >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100],
+            libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200],
+            unit_size=[100, 100], pins=inst0_pins, transform='R0')
+    >>> print(inst0)
+    <laygo2.object.physical.Instance object at 0x000001AF458AF8E0>
+        name: I0,
+        class: Instance,
+        xy: [100, 100],
+        params: None,
+        size: [500, 300],
+        shape: [3, 2],
+        pitch: [200, 200],
+        transform: R0,
+        pins: {'in': <laygo2.object.physical.Pin object at 0x000001AF560D6170>,
+               'out': <laygo2.object.physical.Pin object at 0x000001AF560D5F30>},
+    >>> print( inst0[1,0].xy0 )
+    array([300, 100])
+
+    Notes
+    -----
+    **(Korean)**: Instance 객체 클래스.
+    """
+
+    # TODO: update (maybe) xy and sub-elements after transform property is updated.
+
+    libname = None
+    """
+    str: The library name of the object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> inst0_pins = dict() 
+    >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]], 
+            layer = ['M1', 'drawing'], netname = 'in') 
+    >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]], 
+            layer=['M1', 'drawing'], netname='out')
+    >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100], 
+            libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200], 
+            unit_size=[100, 100], pins=inst0_pins, transform='R0')
+    >>> inst0.libname 
+    'mylib'
+    
+    .. image:: ../assets/img/object_physical_instance_libname.png
+      :height: 250
+
+    Notes
+    -----
+    **(Korean)**: 객체의 라이브러리 이름.
+    """
+
+    cellname = None
+    """
+    str: The cellname of the instance object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> inst0_pins = dict() 
+    >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]], 
+            layer = ['M1', 'drawing'], netname = 'in') 
+    >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]], 
+            layer=['M1', 'drawing'], netname='out')
+    >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100], 
+            libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200], 
+            unit_size=[100, 100], pins=inst0_pins, transform='R0')
+    >>> inst0.cellname
+    'mycell'
+    
+    .. image:: ../assets/img/object_physical_instance_cellname.png
+      :height: 250
+
+    Notes
+    -----
+    **(Korean)**: 객체가 속한 셀 이름.
+    """
+
+    viewname = None
+    """str: The view name of the instance."""
+
+    shape = None
+    """np.array([int, int]) or None: The mosaic shape of the instance. 
+    None if the instance is non-mosaic."""
+
+    _pitch = None
+    """np.array([int, int]) or None: The internal variable for self.pitch."""
+
+    unit_size = None
+    """
+    numpy.ndarray: The array unit size for the object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> inst0_pins = dict() 
+    >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]], 
+            layer = ['M1', 'drawing'], netname = 'in') 
+    >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]], 
+            layer=['M1', 'drawing'], netname='out')
+    >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100], 
+            libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200], 
+            unit_size=[100, 100], pins=inst0_pins, transform='R0')
+    >>> inst0.unit_size 
+    array([100, 100])
+    
+    .. image:: ../assets/img/object_physical_instance_unit_size.png
+      :height: 250
+
+    Notes
+    -----
+    **(Korean)**: 객체가 배열로 구성되었을 때 단위 크기.
+    """
+
+    transform = "R0"
+    """
+    str: The attribute of the object that defines its transformation 
+    (rotation and mirroring).
+
+    Example
+    -------
+    >>> import laygo2
+    >>> inst0_pins = dict() 
+    >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]], 
+            layer = ['M1', 'drawing'], netname = 'in') 
+    >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]], 
+            layer=['M1', 'drawing'], netname='out')
+    >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100], 
+            libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200], 
+            unit_size=[100, 100], pins=inst0_pins, transform='R0')
+    >>> inst0.transform 
+    "R0"
+    
+    .. image:: ../assets/img/object_physical_instance_transform.png
+      :height: 250
+
+    Notes
+    -----
+    **(Korean)**: 객체의 변환 속성 (R0, MX, MY 등).
+    """
+
+    pins = None
+    """
+    dict: Dictionary of pins belonging to the object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> inst0_pins = dict() 
+    >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]], 
+            layer = ['M1', 'drawing'], netname = 'in') 
+    >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]], 
+            layer=['M1', 'drawing'], netname='out')
+    >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100], 
+            libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200], 
+            unit_size=[100, 100], pins=inst0_pins, transform='R0')
+    >>> inst0.pins 
+    {'in': <laygo2.object.physical.Pin object at 0x000001CA76EE1348>, 
+    'out': <laygo2.object.physical.Pin object at 0x000001CA7709BD48>} 
+    >>> inst0.pins["in"].shape 
+    array([3, 2])
+    >>> inst0.pins["out"].shape 
+    array([3, 2] )
+    >>> inst0.pins["in"][1, 1].xy 
+    array([[300, 300], [310, 310]])
+    
+    .. image:: ../assets/img/object_physical_instance_pins.png
+      :height: 250
+
+    Notes
+    -----
+    **(Korean)**: 객체에 속한 핀들을 갖는 dict.
+    """
+    
+    def get_p(self):
+        return self.pins
+
+    def set_p(self, val):
+        self.pins = val
+
+    p = property(get_p, set_p)
+    """str: Alias of pins."""
+    
+    def _update_pins(self, xy_ofst):
+        """
+        Internal function to update x,y coordinates of the object's pins. 
+        Used as part of _set_xy().
+        """
+        if self.pins is not None:
+            for pn, p in self.pins.items():
+                if np.all(p is not None):
+                    # Update the x and y coordinate values of elements.
+                    for n, e in np.ndenumerate(p):
+                        if e is not None:
+                            e.xy = e.xy + xy_ofst
+
+    def _get_xy(self):
+        """numpy.ndarray(dtype=numpy.int): Retrive x,y coordinate values of
+        the object."""
+        return self._xy
+
+    def _set_xy(self, value):
+        """numpy.ndarray(dtype=numpy.int): Update x,y coordinates of
+        the object."""
+        # Update the coordinate value of its pins.
+        self._update_pins(xy_ofst=value - self.xy)
+        IterablePhysicalObject._set_xy(self, value=value)
+
+    xy = property(_get_xy, _set_xy)
+
+    @property
+    def xy0(self):
+        """
+        numpy.ndarray: The x,y coordinates of the primary corner of the object.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> inst0_pins = dict()
+        >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]],
+                layer = ['M1', 'drawing'], netname = 'in')
+        >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]],
+                layer=['M1', 'drawing'], netname='out')
+        >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100],
+                libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200],
+                unit_size=[100, 100], pins=inst0_pins, transform='R0')
+        >>> inst0.xy0
+        array([100, 100])
+
+        .. image:: ../assets/img/object_physical_instance_xy0.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)**: 객체의 주 코너 좌표.
+        """
+        return self.xy
+
+    @property
+    def xy1(self):
+        """
+        numpy.ndarray: The x,y coordinates of the secondary corner of the object.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> inst0_pins = dict()
+        >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]],
+                layer = ['M1', 'drawing'], netname = 'in')
+        >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]],
+                layer=['M1', 'drawing'], netname='out')
+        >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100],
+                libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200],
+                unit_size=[100, 100], pins=inst0_pins, transform='R0')
+        >>> inst0.xy1
+        array([600, 400])
+
+        .. image:: ../assets/img/object_physical_instance_xy1.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)**: 객체의 보조 코너 좌표.
+        """
+        if self.size is None:
+            return self.xy
+        else:
+            return self.xy + np.dot(self.size, tf.Mt(self.transform).T)
+
+    @property
+    def size(self):
+        """
+        numpy.ndarray: The size of the object ([self.width, self.height]).
+
+        Example
+        -------
+        >>> import laygo2
+        >>> inst0_pins = dict()
+        >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]],
+                layer = ['M1', 'drawing'], netname = 'in')
+        >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]],
+                layer=['M1', 'drawing'], netname='out')
+        >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100],
+                libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200],
+                unit_size=[100, 100], pins=inst0_pins, transform='R0')
+        >>> inst0.size
+        array([500, 300])
+
+        .. image:: ../assets/img/object_physical_instance_size.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)**: 객체의 크기 ([width, height]).
+        """
+        if self.shape is None:
+            return self.unit_size
+        else:
+            return (self.shape - np.array([1, 1])) * self.pitch + self.unit_size
+
+    def get_pitch(self):
+        """numpy.ndarray(dtype=int): Retrive the pitch of the instance."""
+        if self._pitch is None:
+            return self.unit_size
+        else:
+            return self._pitch
+
+    def set_pitch(self, value):
+        """numpy.ndarray(dtype=int): Update the pitch of the instance."""
+        self._pitch = value
+
+    pitch = property(get_pitch, set_pitch)
+    """
+    numpy.ndarray: The pitch between unit objects in the array.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> inst0_pins = dict() 
+    >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]], 
+            layer = ['M1', 'drawing'], netname = 'in') 
+    >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]], 
+            layer=['M1', 'drawing'], netname='out')
+    >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100], 
+            libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200], 
+            unit_size=[100, 100], pins=inst0_pins, transform='R0')
+    >>> inst0.pitch 
+    array([200, 200])
+    
+    .. image:: ../assets/img/object_physical_instance_pitch.png
+      :height: 250
+
+    See Also
+    --------
+    Instance.spacing
+
+    Notes
+    -----
+    **(Korean)**: 배열로 구성된 객체의 단위 객체(element)간 간격 (pitch).
+    """
+
+    def get_spacing(self):
+        return self.pitch
+
+    def set_spacing(self, value):
+        self.pitch = value
+
+    spacing = property(get_spacing, set_spacing)
+    """
+    numpy.ndarray: Spacing between unit object of the object in array.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> inst0_pins = dict() 
+    >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]], 
+            layer = ['M1', 'drawing'], netname = 'in') 
+    >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]], 
+            layer=['M1', 'drawing'], netname='out')
+    >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100], 
+            libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200], 
+            unit_size=[100, 100], pins=inst0_pins, transform='R0')
+    >>> inst0.spacing 
+    array([200, 200])
+    
+    .. image:: ../assets/img/object_physical_instance_spacing.png
+      :height: 250
+
+    See Also
+    --------
+    Instance.pitch
+
+    Notes
+    -----
+    **(Korean)**: 배열로 구성된 객체의 단위 객체(element)간 간격 (spacing).
+    """
+
+    @property
+    def bbox(self):
+        """The physical bounding box of the object."""
+        bbox = np.array([self.xy0, self.xy1])
+        # return bbox
+        # return self.xy + np.dot(self.size, tf.Mt(self.transform).T)
+        return np.sort(bbox, axis=0)
+
+    @property
+    def height(self):
+        """
+        int: The height of the object.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> inst0_pins = dict()
+        >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]],
+                layer = ['M1', 'drawing'], netname = 'in')
+        >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]],
+                layer=['M1', 'drawing'], netname='out')
+        >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100],
+                libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200],
+                unit_size=[100, 100], pins=inst0_pins, transform='R0')
+        >>> inst0.height
+        300
+
+        .. image:: ../assets/img/object_physical_instance_height.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)**: 객체의 높이.
+        """
+        return abs(self.bbox[1][1] - self.bbox[0][1])
+
+    @property
+    def width(self):
+        """
+        int: The width of the object.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> inst0_pins = dict()
+        >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]],
+                layer = ['M1', 'drawing'], netname = 'in')
+        >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]],
+                layer=['M1', 'drawing'], netname='out')
+        >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100],
+                libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200],
+                unit_size=[100, 100], pins=inst0_pins, transform='R0')
+        >>> inst0.width
+        500
+
+        .. image:: ../assets/img/object_physical_instance_width.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)**: 객체의 폭.
+        """
+        return abs(self.bbox[1][0] - self.bbox[0][0])
+
+    @property
+    def height_vec(self):
+        """numpy.ndarray(dtype=int): The height direction vector [0, self.height]
+        of the object."""
+        return np.array([0, self.height])
+
+    @property
+    def width_vec(self):
+        """numpy.ndarray(dtype=int): The width direction vector [self.width, 0]
+        of the object."""
+        return np.array([self.width, 0])
+
+    def __init__(
+        self,
+        xy,
+        libname,
+        cellname,
+        viewname="layout",
+        shape=None,
+        pitch=None,
+        transform="R0",
+        unit_size=np.array([0, 0]),
+        pins=None,
+        name=None,
+        params=None,
+    ):
+        """
+        The constructor function.
+
+        Parameters
+        ----------
+        xy : numpy.ndarray
+            The primary coordinate ([x0, y0]) of the object.
+        libname : str
+            The library name of the object.
+        cellname : str
+            The cell name of the object.
+        shape : numpy.ndarray
+            The shape [col, row] of the elements.
+        pitch : numpy.ndarray
+            The pitch between unit objects in the array.
+        transform : str
+            The attribute of the object that defines its transformation 
+            (rotation and mirroring).
+        unit_size : list
+            The array unit size for the object.
+        pins : dict
+            Dictionary of pins belonging to the object.
+        name : str
+            Object name.
+        params : dict
+            (optional) Dictionary storing the parameters associated with 
+            the object.
+
+        Returns
+        -------
+        Instance : The constructed Instance object.
+
+        See Also
+        --------
+        IterablePhysicalObject
+
+        Example
+        -------
+        >>> import laygo2
+        >>> inst0_pins = dict()
+        >>> inst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10,10]],
+                layer = ['M1', 'drawing'], netname = 'in')
+        >>> inst0_pins['out']= laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]],
+                layer=['M1', 'drawing'], netname='out')
+        >>> inst0 = laygo2.object.physical.Instance(name="I0", xy=[100,100],
+                libname="mylib", cellname="mycell", shape=[3, 2], pitch=[200,200],
+                unit_size=[100, 100], pins=inst0_pins, transform='R0')
+        >>> print(inst0)
+        <laygo2.object.physical.Instance object at 0x000001AF458AF8E0>
+            name: I0,
+            class: Instance,
+            xy: [100, 100],
+            params: None,
+            size: [500, 300],
+            shape: [3, 2],
+            pitch: [200, 200],
+            transform: R0,
+            pins: {'in': <laygo2.object.physical.Pin object at 0x000001AF560D6170>,
+                   'out': <laygo2.object.physical.Pin object at 0x000001AF560D5F30>},
+        >>> print( inst0[1,0].xy0 )
+        array([300, 100])
+
+        .. image:: ../assets/img/object_physical_instance_init.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)**: Instance 클래스의 생성함수
+
+        파라미터
+            - xy(numpy.ndarray): 객체의 주좌표 [x0, y0].
+            - libname(str): 객체의 library 이름.
+            - cellname(str): 객체의 cell 이름.
+            - shape(numpy.ndarray): elements의 배열 크기 ([column, row]).
+            - pitch(numpy.ndarray): 배열로 구성된 객체의 구성 요소 (element) 간격 (pitch).
+            - transform(str): 객체의 변환 속성.
+            - unit_size(list): 객체의 단위 크기.
+            - pins(dict): 객체에 속한 핀들을 갖는 dict.
+            - name(str): 객체의 이름.
+            - params(dict): 객체의 주요 속성을 갖는 dict.
+        """
+        # Assign parameters.
+        xy = np.asarray(xy)
+        self.libname = libname
+        self.cellname = cellname
+        self.viewname = viewname
+        if shape is not None:
+            _shape = np.asarray(shape)
+            if _shape.shape != (2,):
+                raise ValueError("Instance shape should be a (2, ) numpy array or None.")
+            self.shape = _shape
+        if pitch is not None:
+            self.pitch = np.asarray(pitch)
+        self.transform = transform
+        self.unit_size = np.asarray(unit_size)
+
+        # Construct an array for elements.
+        if shape is None:
+            # elements = self  # self-referencing causes recursion errors.
+            # (Deprecated).
+            elements = None
+        else:
+            _shape = tuple(shape)
+            elements = np.zeros(_shape, dtype=object)
+            # elements = LayoutObjectArray(np.zeros(_shape, dtype=np.object))
+            _it = np.nditer(elements, flags=["multi_index", "refs_ok"])
+            while not _it.finished:
+                _idx = _it.multi_index
+                _xy = xy + np.dot(self.pitch * np.array(_idx), tf.Mt(self.transform).T)
+                inst = Instance(
+                    xy=_xy,
+                    libname=libname,
+                    cellname=cellname,
+                    shape=None,
+                    pitch=pitch,
+                    transform=self.transform,
+                    unit_size=self.unit_size,
+                    pins=pins,
+                    name=name,
+                    params=params,
+                )
+                elements[_idx] = inst
+                _it.iternext()
+
+        IterablePhysicalObject.__init__(self, xy=xy, name=name, params=params, elements=elements)
+        # Create the pin dictionary. Can we do the same thing without generating
+        # these many Pin objects?
+        self.pins = dict()
+        if pins is not None:
+            if not isinstance(pins, dict):
+                raise ValueError("The pins parameter for Instance objects should be a dictionary.")
+            for pn, p in pins.items():
+                _xy0 = xy + np.dot(p.xy, tf.Mt(transform).T)
+                if shape is not None:
+                    elements = []
+                    for i in range(shape[0]):
+                        elements.append([])
+                        for j in range(shape[1]):
+                            _xy = _xy0 + np.dot(self.pitch * np.array([i, j]), tf.Mt(transform).T)
+                            # If p has elements, they need to be copied and
+                            # transferred to the new pin.
+                            _pelem = None
+                            if p.elements is not None:
+                                _pelem = np.empty(p.elements.shape, dtype=object)
+                                for _idx, _pe in np.ndenumerate(p.elements):
+                                    _pexy0 = (
+                                        xy
+                                        + np.dot(_pe.xy, tf.Mt(transform).T)
+                                        + np.dot(
+                                            self.pitch * np.array([i, j]),
+                                            tf.Mt(transform).T,
+                                        )
+                                    )
+                                    _pelem[_idx] = Pin(
+                                        xy=_pexy0,
+                                        netname=_pe.netname,
+                                        layer=_pe.layer,
+                                        name=_pe.name,
+                                        master=self,
+                                    )
+                            pin = Pin(
+                                xy=_xy,
+                                netname=p.netname,
+                                layer=p.layer,
+                                name=p.name,
+                                master=self,
+                                elements=_pelem,
+                            )  # master uses self instead of self.elements[i, j].
+                            elements[i].append(pin)
+                    elements = np.array(elements)
+                else:
+                    # If p has elements, they need to be copied and transferred
+                    # to the new pin.
+                    _pelem = None
+                    if p.elements is not None:
+                        _pelem = np.empty(p.elements.shape, dtype=object)
+                        for _idx, _pe in np.ndenumerate(p.elements):
+                            _pexy0 = xy + np.dot(_pe.xy, tf.Mt(transform).T)
+                            _pelem[_idx] = Pin(
+                                xy=_pexy0,
+                                netname=_pe.netname,
+                                layer=_pe.layer,
+                                name=_pe.name,
+                                master=self,
+                            )
+                    elements = _pelem
+                self.pins[pn] = Pin(
+                    xy=_xy0,
+                    netname=p.netname,
+                    layer=p.layer,
+                    name=p.name,
+                    master=self,
+                    elements=elements,
+                )
+
+    def summarize(self):
+        """Return the summary of the object information."""
+        _shape = str(None if self.shape is None else self.shape.tolist())
+        return (
+            PhysicalObject.summarize(self)
+            + "    size: "
+            + str(self.size.tolist())
+            + ", \n"
+            + "    shape: "
+            + _shape
+            + ", \n"
+            + "    pitch: "
+            + str(self.pitch.tolist())
+            + ", \n"
+            + "    transform: "
+            + str(self.transform)
+            + ", \n"
+            + "    pins: "
+            + str(self.pins)
+            + ", \n"
+        )
+
+    def update_netname(self, netmap: dict):
+        """
+        Update the netname information for all pins belonging 
+        to this object.
+        """
+        for pn, p in self.pins.items():
+            if p.netname in netmap:
+                p.netname = netmap[p.netname]  # update netname information
+
+
+class VirtualInstance(Instance):  # IterablePhysicalObject):
+    """
+    The VirtualInstance class implements functions for a group of objects 
+    to be treated as a single instance with dedicated dimensional, 
+    port, and related parameters.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> vinst0_pins = dict()
+    >>> # Pin information
+    >>> vinst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10, 10]],
+            layer=['M1', 'drawing'], netname='in')
+    >>> vinst0_pins['out'] = laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]],
+            layer=['M1', 'drawing'], netname='out')
+    >>> # Element information
+    >>> native_elements = dict()
+    >>> native_elements['R0'] = laygo2.object.physical.Rect(xy=[[0, 0], [10, 10]],
+            layer=['M1', 'drawing'])
+    >>> native_elements['R1'] = laygo2.object.physical.Rect(xy=[[90, 90], [100, 100]],
+            layer=['M1', 'drawing'])
+    >>> native_elements['R2'] = laygo2.object.physical.Rect(xy=[[0, 0], [100, 100]],
+            layer=['prBoundary', 'drawing'])
+    >>> vinst0 = laygo2.object.physical.VirtualInstance(name='I0', libname='mylib',
+            cellname='myvcell', xy=[500, 500], native_elements=native_elements,
+            shape=[3, 2], pitch=[100, 100], unit_size=[100, 100], pins=vinst0_pins,
+            transform='R0')
+    >>> vinst0.native_elements
+    {'R0': <laygo2.object.physical.Rect object at 0x00000204AAFCE170>,
+     'R1': <laygo2.object.physical.Rect object at 0x00000204AAFCEA40>,
+     'R2': <laygo2.object.physical.Rect object at 0x00000204AAFCE0B0>}
+
+    Notes
+    -----
+    **(Korean)**: VirtualInstance 객체 클래스. VirtualInstance는 여러 개의
+    레이아웃 오브젝트를 하나의 그룹으로 묶어 크기/포트 등의 관련된 파라미터
+    들을 이용해 추상화 할 수 있는 객체를 구현한다.
+    """
+
+    native_elements = None
+    """
+    dict: Dictionary that holds the physical element entities 
+        of the VirtualInstance object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> vinst0_pins = dict() 
+    >>> # Pin information
+    >>> vinst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10, 10]], 
+            layer=['M1', 'drawing'], netname='in') 
+    >>> vinst0_pins['out'] = laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]], 
+            layer=['M1', 'drawing'], netname='out')
+    >>> # Element information
+    >>> native_elements = dict() 
+    >>> native_elements['R0'] = laygo2.object.physical.Rect(xy=[[0, 0], [10, 10]], 
+            layer=['M1', 'drawing']) 
+    >>> native_elements['R1'] = laygo2.object.physical.Rect(xy=[[90, 90], [100, 100]], 
+            layer=['M1', 'drawing']) 
+    >>> native_elements['R2'] = laygo2.object.physical.Rect(xy=[[0, 0], [100, 100]], 
+            layer=['prBoundary', 'drawing'])
+    >>> vinst0 = laygo2.object.physical.VirtualInstance(name='I0', libname='mylib', 
+            cellname='myvcell', xy=[500, 500], native_elements=native_elements, 
+            shape=[3, 2], pitch=[100, 100], unit_size=[100, 100], pins=vinst0_pins, 
+            transform='R0')
+    >>> vinst0.native_elements 
+    {'R0': <laygo2.object.physical.Rect object at 0x00000204AAFCE170>, 
+     'R1': <laygo2.object.physical.Rect object at 0x00000204AAFCEA40>, 
+     'R2': <laygo2.object.physical.Rect object at 0x00000204AAFCE0B0>}
+
+    .. image:: ../assets/img/object_physical_VirtualInstance_native_elements.png
+      :height: 250
+
+    Notes
+    -----
+    **(Korean)**: 객체를 구성하는 하위 물리 객체들(Rect, Path, Pin, Text, Instance 등)을 갖고 있는 dict.
+    """
+    # Dict[PhysicalObject] the elements that compose the virtual instance. Its keys represent the names of the elements.
+
+    def __init__(
+        self,
+        xy,
+        libname,
+        cellname,
+        native_elements,
+        viewname="layout",
+        shape=None,
+        pitch=None,
+        transform="R0",
+        unit_size=np.array([0, 0]),
+        pins=None,
+        name=None,
+        params=None,
+    ):
+        """
+        The constructor function.
+
+        Parameters
+        ----------
+        xy : numpy.ndarray
+            Physical coordinate values of the object
+            in the form of [bottom_left, top_right].
+        libname : str
+            The library name of the object.
+        cellname : str
+            The cell name of the object.
+        native_elements : dict
+            Dictionary that holds the physical element entities 
+            of the VirtualInstance object.
+        shape : numpy.ndarray
+            The shape [col, row] of the elements.
+        pitch : numpy.ndarray
+            The pitch between unit objects in the array.
+        transform : str
+            The attribute of the object that defines its transformation 
+            (rotation and mirroring).
+        unit_size : list
+            Unit size of object.
+        pins : dict
+            The array unit size for the object.
+        name : str
+            Object name.
+        params : dict
+            (optional) Dictionary storing the parameters associated with 
+            the object.
+
+        Returns
+        -------
+        laygo2.VirtualInstance : The constructed VirtualInstance object.
+
+        See Also
+        --------
+        Instance
+
+        Example
+        -------
+        >>> import laygo2
+        >>> vinst0_pins = dict()
+        >>> # Pin information
+        >>> vinst0_pins['in'] = laygo2.object.physical.Pin(xy=[[0, 0], [10, 10]],
+                layer=['M1', 'drawing'], netname='in')
+        >>> vinst0_pins['out'] = laygo2.object.physical.Pin(xy=[[90, 90], [100, 100]],
+                layer=['M1', 'drawing'], netname='out')
+        >>> # Element information
+        >>> native_elements = dict()
+        >>> native_elements['R0'] = laygo2.object.physical.Rect(xy=[[0, 0], [10, 10]],
+                layer=['M1', 'drawing'])
+        >>> native_elements['R1'] = laygo2.object.physical.Rect(xy=[[90, 90], [100, 100]],
+                layer=['M1', 'drawing'])
+        >>> native_elements['R2'] = laygo2.object.physical.Rect(xy=[[0, 0], [100, 100]],
+                layer=['prBoundary', 'drawing'])
+        >>> vinst0 = laygo2.object.physical.VirtualInstance(name='I0', libname='mylib',
+                cellname='myvcell', xy=[500, 500], native_elements=native_elements,
+                shape=[3, 2], pitch=[100, 100], unit_size=[100, 100], pins=vinst0_pins,
+                transform='R0')
+        >>> vinst0.native_elements
+        {'R0': <laygo2.object.physical.Rect object at 0x00000204AAFCE170>,
+         'R1': <laygo2.object.physical.Rect object at 0x00000204AAFCEA40>,
+         'R2': <laygo2.object.physical.Rect object at 0x00000204AAFCE0B0>}
+
+        .. image:: ../assets/img/object_physical_VirtualInstance_init.png
+          :height: 250
+
+        Notes
+        -----
+        **(Korean)**: VirtualInstance 클래스의 생성자.
+
+        파라미터
+        - xy(numpy.ndarray): 객체의 주좌표 [x0, y0].
+        - libname(str): 객체의 library 이름.
+        - cellname(str): 객체의 cell이름.
+        - native_elements(dict): 객체를 구성하는 물리 객체를 갖는 dict.
+        - shape(numpy.ndarray): elements의 배열 크기 ([col, row]).
+        - pitch(numpy.ndarray): 배열로 구성된 객체의 하위 객체 (element)간의 간격.
+        - transform(str): 객체의 변환 속성 (R0, MX, MY 등).
+        - unit_size(list): 객체의 단위 크기.
+        - pins(dict): 객체에 속한 핀들을 갖는 dict.
+        - name(str): 객체의 이름.
+        - params(dict): 객체의 주요 속성을 갖는 dict.
+
+        """
+        self.native_elements = native_elements
+
+        Instance.__init__(
+            self,
+            xy=xy,
+            libname=libname,
+            cellname=cellname,
+            viewname=viewname,
+            shape=shape,
+            pitch=pitch,
+            transform=transform,
+            unit_size=unit_size,
+            pins=pins,
+            name=name,
+            params=params,
+        )
+
+    def summarize(self):
+        """Return the summary of the object information."""
+        return Instance.summarize(self) + "    native elements: " + str(self.native_elements) + "\n"
+
+    def get_element_position(self, obj):
+        """
+        Get x,y coordinates of the element obj (which belongs to the object)
+        relative to the origin (0, 0).
+
+        Parameters
+        ----------
+        obj : element
+            The element belongs to the object.
+        """
+        vinst = self
+        tr = vinst.transform
+        coners = np.zeros((4, 2))
+        v_r = np.zeros(2)  # for rotation
+        bbox_raw = obj.bbox
+        offset = vinst.xy
+        if tr == "R0":
+            v_r = v_r + (1, 1)
+            coners[0] = offset + v_r * bbox_raw[0]
+            coners[2] = offset + v_r * bbox_raw[1]
+        elif tr == "MX":
+            v_r = v_r + (1, -1)
+            coners[1] = offset + v_r * bbox_raw[0]
+            coners[3] = offset + v_r * bbox_raw[1]
+            coners[0] = coners[0] + (coners[1][0], coners[3][1])
+            coners[2] = coners[2] + (coners[3][0], coners[1][1])
+        elif tr == "MY":
+            v_r = v_r + (-1, 1)
+            coners[3] = offset + v_r * bbox_raw[0]
+            coners[1] = offset + v_r * bbox_raw[1]
+            coners[0] = coners[0] + (coners[1][0], coners[3][1])
+            coners[2] = coners[2] + (coners[3][0], coners[1][1])
+        elif tr == "R90":
+            v_r = v_r + (-1, -1)
+            coners[2] = offset + v_r * bbox_raw[0]
+            coners[0] = offset + v_r * bbox_raw[1]
+        else:
+            raise ValueError(" Others transfom not implemented")
+        return coners[0], coners[2]
+
+class Via(IterablePhysicalObject):
+    """
+    Via object class.
+
+    Attributes
+    ----------
+    netname : str
+    color : str
+    size : np.array(dtype=np.int)
+
+    Methods
+    -------
+    """
+
+    netname = None
+    size = np.array([0,0])
+    unit_size = None
+    _pitch = None
+    transform = 'R0'
+    color = None
+    
+    def _get_xy(self):
+        """numpy.ndarray(dtype=numpy.int): Get the x and y coordinate values of this object."""
+        return self._xy
+
+    def _set_xy(self, value):
+        """numpy.ndarray(dtype=numpy.int): Set the x and y coordinate values of this object."""
+        # Update the coordinate value of its pins.
+        IterablePhysicalObject._set_xy(self, value=value)
+
+    xy = property(_get_xy, _set_xy)
+    
+    @property
+    def xy0(self):
+        """attribute
+        numpy.ndarray: Coordinates of major corner of object.
+
+        
+
+        Examples
+        --------
+       
+        Notes
+        -----
+        Related Images:
+
+        Reference in Korean:
+        numpy.ndarray: 객체의 주 코너 좌표.
+        """
+        return self.xy
+
+    @property
+    def xy1(self):
+        """attribute
+        numpy.ndarray: Coordinates of minor corner of object.
+
+        Examples
+        --------
+
+        Notes
+        -----
+        Related Images:
+
+        Reference in Korean:
+        numpy.ndarray: 객체의 보조 코너 좌표.
+        """
+        if self.size is None:
+            return self.xy
+        else:
+            return self.xy + np.dot(self.size, tf.Mt(self.transform).T)
+
+    @property
+    def bbox(self):
+        bbox = np.array([self.xy0, self.xy1])
+        #return bbox
+        #return self.xy + np.dot(self.size, tf.Mt(self.transform).T)
+        return np.sort(bbox, axis=0)
+     
+    def __init__(self, xy, color=None, name=None, netname=None, params=None, transform= 'R0',elements=None):
+
+        xy = np.asarray(xy)
+        if netname is None:
+            self.netname = name
+        else:
+            self.netname = netname
+        self.color = color
+        IterablePhysicalObject.__init__(self, xy=xy, name=name, params=params, elements=elements)
+
+
+    def summarize(self):
+        """Return the summary of the object information."""
+        return IterablePhysicalObject.summarize(self) + ", " + \
+                                              "netname: " + str(self.netname)
+
+
+# Test
+if __name__ == "__main__":
+    test_rect = False
+    test_path = False
+    test_pin = False
+    test_text = False
+    test_pointer = False
+    test_instance = True
+    test_virtual_instance = False
+
+    # You can create various objects by running part of the following commands.
+    if test_rect:
+        print("Rect test")
+        rect0 = Rect(
+            xy=[[0, 0], [100, 100]],
+            layer=["M1", "drawing"],
+            netname="net0",
+            params={"maxI": 0.005},
+        )
+        print(rect0)
+    if test_path:
+        print("Path test")
+        path0 = Path(
+            xy=[[0, 0], [0, 100]],
+            width=10,
+            extension=5,
+            layer=["M1", "drawing"],
+            netname="net0",
+        )
+        print(path0)
+    if test_pin:
+        print("Pin test")
+        pin0 = Pin(
+            xy=[[0, 0], [100, 100]],
+            layer=["M1", "drawing"],
+            netname="net0",
+            master=rect0,
+            params={"direction": "input"},
+        )
+        print(pin0)
+    if test_text:
+        print("Text test")
+        text0 = Text(xy=[0, 0], layer=["text", "drawing"], text="test", params=None)
+        print(text0)
+    if test_instance:
+        print("Instance test - creating a vanilla instance.")
+        inst0_pins = dict()
+        inst0_pins["in"] = Pin(xy=[[0, 0], [10, 10]], layer=["M1", "drawing"], netname="in")
+        inst0_pins["out"] = Pin(xy=[[90, 90], [100, 100]], layer=["M1", "drawing"], netname="out")
+        inst0 = Instance(
+            name="I0",
+            xy=[100, 100],
+            libname="mylib",
+            cellname="mycell",
+            shape=[3, 2],
+            pitch=[100, 100],
+            unit_size=[100, 100],
+            pins=inst0_pins,
+            transform="R0",
+        )
+        print("  ", inst0)
+        print("  ", inst0.pointers)
+        print(inst0.elements)
+        for idx, it in inst0.ndenumerate():
+            print("what?")
+            print("  ", idx, it)
+            print("  ", idx, it.pins["in"])
+        print("Instance test - updating the instance's coordinate values.")
+        inst0.xy = [200, 200]
+        print("  ", inst0)
+        print("  ", inst0.pointers)
+        for idx, it in inst0.ndenumerate():
+            print("  ", idx, it)
+            print("  ", idx, it.pins["in"])
+    if test_virtual_instance:
+        print("VirtualInstance test - creating a vanilla virtual instance.")
+        inst1_pins = dict()
+        inst1_pins["in"] = Pin(xy=[[0, 0], [10, 10]], layer=["M1", "drawing"], netname="in")
+        inst1_pins["out"] = Pin(xy=[[90, 90], [100, 100]], layer=["M1", "drawing"], netname="out")
+        inst1_native_elements = dict()
+        inst1_native_elements["R0"] = Rect(xy=[[0, 0], [10, 10]], layer=["M1", "drawing"])
+        inst1_native_elements["R1"] = Rect(xy=[[90, 90], [100, 100]], layer=["M1", "drawing"])
+        inst1_native_elements["R2"] = Rect(xy=[[0, 0], [100, 100]], layer=["prBoundary", "drawing"])
+        inst1 = VirtualInstance(
+            name="I0",
+            libname="mylib",
+            cellname="myvcell",
+            xy=[500, 500],
+            native_elements=inst1_native_elements,
+            shape=[3, 2],
+            pitch=[100, 100],
+            unit_size=[100, 100],
+            pins=inst1_pins,
+            transform="R0",
+        )
+        print("  ", inst1)
+        for idx, it in inst1.ndenumerate():
+            print("  ", idx, it.pins["in"])
+        for idx, it in inst1.pins["in"].ndenumerate():
+            print("  ", idx, it)
```

### Comparing `laygo2-0.5.6/laygo2/object/grid/uniformrouting.py` & `laygo2-0.5.7/laygo2/object/grid/uniformrouting.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,215 +1,215 @@
-#!/usr/bin/python
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-import numpy as np
-from .core import CircularMapping, OneDimGrid
-from .routing import RoutingGrid
-import laygo2.object
-
-class UniformRoutingGrid(RoutingGrid):
-    """
-    A class tahta implements wire connections in an uniform and flexible abstract coordinate system.
-
-    Attributes
-    ----------
-    type : str
-    xres : int
-    yres : int
-    xwidth : int
-    ywidth : int
-    xextension : int
-    yextension : int
-    xlayer : str
-    ylayer : str
-    pin_xlayer : str
-    pin_ylayer : str
-    via : UserDefinedTemplates
-    xcolor : 
-    ycolor :
-    primary_grid : str
-
-    Methods
-    -------
-    __init__()
-    via()
-
-    Notes
-    -----
-    Reference in Korean:
-    조절가능한 등간격 추상 좌표계의 동작을 구현하는 클래스.
-    """
-    type = 'uniform_routing'
-
-    xres = None
-    yres = None
-    xwidth = None
-    ywidth = None
-    xextension = None
-    yextension = None
-    xextension0 = None
-    yextension0 = None
-    xlayer = None
-    ylayer = None
-    pin_xlayer = None
-    pin_ylayer = None
-    via = None
-    xcolor = None
-    ycolor = None
-    primary_grid = None
-
-    def __init__(self, name, xres, yres, xwidth, ywidth, xextension, yextension, xlayer, ylayer, pin_xlayer, pin_ylayer,
-                via, xcolor, ycolor, primary_grid='horizontal', xextension0=None, yextension0=None):
-        """
-        Constructor function of UniformRoutingGrid class.
-
-        Parameters
-        ----------
-        name : str
-            Routing object name
-        xres : laygo2.OneDimGrid
-            OneDimGrid of x-coordinate system
-        yres : laygo2.OneDimGrid
-            OneDimGrid of y-coordinate system
-        
-        """
-        xres=OneDimGrid(name='xres', scope=[0,xres], elements=[0])
-        yres=OneDimGrid(name='yres', scope=[0,yres], elements=[0])
-        xwidth=CircularMapping([xwidth])
-        ywidth=CircularMapping([ywidth])
-
-        xextension=CircularMapping([ywidth.elements[0]/2])
-        yextension=CircularMapping([xwidth.elements[0]/2])
-        xextension0=CircularMapping([ywidth.elements[0]*2])
-        yextension0=CircularMapping([xwidth.elements[0]*2])
-        xlayer=CircularMapping([[xlayer,'drawing']], dtype=object)
-        ylayer=CircularMapping([[ylayer,'drawing']], dtype=object)
-        pin_xlayer=CircularMapping([[xlayer,'pin']], dtype=object)
-        pin_xlayer=CircularMapping([[xlayer,'pin']], dtype=object)
-        xcolor=CircularMapping(['not MPT'], dtype=object)
-        ycolor=CircularMapping(['not MPT'], dtype=object)
-
-        self.xwidth=xwidth
-        self.ywidth=ywidth
-        self.xlayer=xlayer
-        self.ylayer=ylayer
-        self.xextension=xextension
-        self.yextension=yextension
-
-        
-        RoutingGrid.__init__(self, name=name, vgrid=xres, hgrid=yres, vwidth=xwidth, hwidth=ywidth, vextension=xextension, hextension=yextension,
-        vlayer=xlayer, hlayer=ylayer, pin_vlayer=pin_xlayer, pin_hlayer=pin_ylayer, viamap=via, xcolor=xcolor, ycolor=ycolor,
-        primary_grid='vertical', vextension0=xextension0, hextension0=yextension0)
-    
-    def via(self, mn=np.array([0,0]), params=None):
-        # Supporting different type of via cut patterns(default,LRG,BAR,...)
-        if isinstance(mn, list):
-            if isinstance(mn[0], (int, np.integer)):  # It's actually a single coordinate.
-                return self.via(mn=np.asarray(mn), params=params)
-            else:
-                return [self.via(mn=_mn, params=params) for _mn in mn]
-        elif isinstance(mn, np.ndarray):
-            if isinstance(mn[0], (int, np.integer)):  # It's actually a single coordinate.
-                pass
-            else:
-                return np.array([self.via(mn=_mn, params=params) for _mn in mn])
-        if not isinstance(mn, tuple):
-            mn = tuple(mn)  # viamap (CircularMapping) works only with tuples
-        tvia = self.viamap
-        if params == None:
-            params={'cut':'Default'}
-        else:
-            pass
-        params['xlayer']=self.xlayer.elements[0][0]
-        params['ylayer']=self.ylayer.elements[0][0]
-        via = tvia.generate(params=params)
-        via.xy = self[mn]
-        return via
-
-    def route(self, mn, direction=None, via_tag=None):
-       
-        mn = np.asarray(mn)
-        _mn = list()
-        for i in range(1, mn.shape[0]):  
-            # when more than two points are given,
-            # create a multi-point wire compose of sub-routing wires
-            # connecting the points given by mn in sequence.
-            _mn.append([mn[i - 1, :], mn[i, :]])
-        route = list()
-        # via at the starting point
-        if via_tag is not None:
-            if via_tag[0] is True:
-                route.append(self.via(mn=_mn[0][0], params=None))
-            elif via_tag[0] != False:
-                route.append(self.via(mn=_mn[0][0], params={'cut':via_tag[0]}))
-            else:
-                pass
-        # routing wires
-        for i, __mn in enumerate(_mn):
-            xy0 = self.abs2phy[__mn[0]]
-            xy1 = self.abs2phy[__mn[1]]
-            _xy = np.array([[xy0[0], xy0[1]], [xy1[0], xy1[1]]])
-            if np.all(xy0 == xy1):  # if two points are identical, generate a metal stub on the bottom layer.
-                if (direction == 'vertical') or ((direction is None) and (self.primary_grid == 'vertical')):
-                    width = self.xwidth[__mn[0][0]]
-                    yextension = int(width/2)
-                    xextension = self.xextension0[__mn[0][0]]
-                    layer = self.xlayer[__mn[0][0]]
-                    color = self.xcolor[__mn[0][0]%self.xcolor.shape[0]] # xcolor is determined by its grid layer.
-                else:
-                    width = self.ywidth[__mn[0][1]]
-                    yextension = self.yextension0[__mn[0][1]]
-                    xextension = int(width/2)
-                    layer = self.ylayer[__mn[0][1]]
-                    color = self.ycolor[__mn[0][1]%self.ycolor.shape[0]] # ycolor is determined by its grid layer.
-            else:
-                if (xy0[0] == xy1[0]) or (direction == 'vertical'):  # vertical routing
-                    width = self.xwidth[__mn[0][0]]
-                    yextension = int(width/2)
-                    xextension = self.xextension[__mn[0][0]]
-                    layer = self.xlayer[__mn[0][0]]
-                    color = self.xcolor[__mn[0][0]%self.xcolor.shape[0]] # xcolor is determined by its grid layer.
-
-                else:  # horizontal routing
-                    width = self.ywidth[__mn[0][1]]
-                    yextension = self.yextension[__mn[0][1]]
-                    xextension = int(width/2)
-                    layer = self.ylayer[__mn[0][1]]
-                    color = self.ycolor[__mn[0][1]%self.ycolor.shape[0]] # ycolor is determined by its grid layer.
-            p = laygo2.object.physical.Rect(xy=_xy, layer=layer, hextension=yextension, vextension=xextension, color=color)
-            route.append(p)
-            # via placement
-            if via_tag is None:
-                if (i > 0) and (i < mn.shape[0] - 1):
-                    route.append(self.via(mn=__mn[0], params=None))
-            else:
-                if via_tag[i + 1] == True:
-                    route.append(self.via(mn=__mn[1], params=None))
-                elif via_tag[i+1] != False:
-                    route.append(self.via(mn=__mn[1], params={'cut':via_tag[i+1]}))
-                else:
-                    pass
-        if len(route) == 1:  # not isinstance(mn[0][0], list):
-            return route[0]
-        else:
+#!/usr/bin/python
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+import numpy as np
+from .core import CircularMapping, OneDimGrid
+from .routing import RoutingGrid
+import laygo2.object
+
+class UniformRoutingGrid(RoutingGrid):
+    """
+    A class tahta implements wire connections in an uniform and flexible abstract coordinate system.
+
+    Attributes
+    ----------
+    type : str
+    xres : int
+    yres : int
+    xwidth : int
+    ywidth : int
+    xextension : int
+    yextension : int
+    xlayer : str
+    ylayer : str
+    pin_xlayer : str
+    pin_ylayer : str
+    via : UserDefinedTemplates
+    xcolor : 
+    ycolor :
+    primary_grid : str
+
+    Methods
+    -------
+    __init__()
+    via()
+
+    Notes
+    -----
+    Reference in Korean:
+    조절가능한 등간격 추상 좌표계의 동작을 구현하는 클래스.
+    """
+    type = 'uniform_routing'
+
+    xres = None
+    yres = None
+    xwidth = None
+    ywidth = None
+    xextension = None
+    yextension = None
+    xextension0 = None
+    yextension0 = None
+    xlayer = None
+    ylayer = None
+    pin_xlayer = None
+    pin_ylayer = None
+    via = None
+    xcolor = None
+    ycolor = None
+    primary_grid = None
+
+    def __init__(self, name, xres, yres, xwidth, ywidth, xextension, yextension, xlayer, ylayer, pin_xlayer, pin_ylayer,
+                via, xcolor, ycolor, primary_grid='horizontal', xextension0=None, yextension0=None):
+        """
+        Constructor function of UniformRoutingGrid class.
+
+        Parameters
+        ----------
+        name : str
+            Routing object name
+        xres : laygo2.OneDimGrid
+            OneDimGrid of x-coordinate system
+        yres : laygo2.OneDimGrid
+            OneDimGrid of y-coordinate system
+        
+        """
+        xres=OneDimGrid(name='xres', scope=[0,xres], elements=[0])
+        yres=OneDimGrid(name='yres', scope=[0,yres], elements=[0])
+        xwidth=CircularMapping([xwidth])
+        ywidth=CircularMapping([ywidth])
+
+        xextension=CircularMapping([ywidth.elements[0]/2])
+        yextension=CircularMapping([xwidth.elements[0]/2])
+        xextension0=CircularMapping([ywidth.elements[0]*2])
+        yextension0=CircularMapping([xwidth.elements[0]*2])
+        xlayer=CircularMapping([[xlayer,'drawing']], dtype=object)
+        ylayer=CircularMapping([[ylayer,'drawing']], dtype=object)
+        pin_xlayer=CircularMapping([[xlayer,'pin']], dtype=object)
+        pin_xlayer=CircularMapping([[xlayer,'pin']], dtype=object)
+        xcolor=CircularMapping(['not MPT'], dtype=object)
+        ycolor=CircularMapping(['not MPT'], dtype=object)
+
+        self.xwidth=xwidth
+        self.ywidth=ywidth
+        self.xlayer=xlayer
+        self.ylayer=ylayer
+        self.xextension=xextension
+        self.yextension=yextension
+
+        
+        RoutingGrid.__init__(self, name=name, vgrid=xres, hgrid=yres, vwidth=xwidth, hwidth=ywidth, vextension=xextension, hextension=yextension,
+        vlayer=xlayer, hlayer=ylayer, pin_vlayer=pin_xlayer, pin_hlayer=pin_ylayer, viamap=via, xcolor=xcolor, ycolor=ycolor,
+        primary_grid='vertical', vextension0=xextension0, hextension0=yextension0)
+    
+    def via(self, mn=np.array([0,0]), params=None):
+        # Supporting different type of via cut patterns(default,LRG,BAR,...)
+        if isinstance(mn, list):
+            if isinstance(mn[0], (int, np.integer)):  # It's actually a single coordinate.
+                return self.via(mn=np.asarray(mn), params=params)
+            else:
+                return [self.via(mn=_mn, params=params) for _mn in mn]
+        elif isinstance(mn, np.ndarray):
+            if isinstance(mn[0], (int, np.integer)):  # It's actually a single coordinate.
+                pass
+            else:
+                return np.array([self.via(mn=_mn, params=params) for _mn in mn])
+        if not isinstance(mn, tuple):
+            mn = tuple(mn)  # viamap (CircularMapping) works only with tuples
+        tvia = self.viamap
+        if params == None:
+            params={'cut':'Default'}
+        else:
+            pass
+        params['xlayer']=self.xlayer.elements[0][0]
+        params['ylayer']=self.ylayer.elements[0][0]
+        via = tvia.generate(params=params)
+        via.xy = self[mn]
+        return via
+
+    def route(self, mn, direction=None, via_tag=None):
+       
+        mn = np.asarray(mn)
+        _mn = list()
+        for i in range(1, mn.shape[0]):  
+            # when more than two points are given,
+            # create a multi-point wire compose of sub-routing wires
+            # connecting the points given by mn in sequence.
+            _mn.append([mn[i - 1, :], mn[i, :]])
+        route = list()
+        # via at the starting point
+        if via_tag is not None:
+            if via_tag[0] is True:
+                route.append(self.via(mn=_mn[0][0], params=None))
+            elif via_tag[0] != False:
+                route.append(self.via(mn=_mn[0][0], params={'cut':via_tag[0]}))
+            else:
+                pass
+        # routing wires
+        for i, __mn in enumerate(_mn):
+            xy0 = self.abs2phy[__mn[0]]
+            xy1 = self.abs2phy[__mn[1]]
+            _xy = np.array([[xy0[0], xy0[1]], [xy1[0], xy1[1]]])
+            if np.all(xy0 == xy1):  # if two points are identical, generate a metal stub on the bottom layer.
+                if (direction == 'vertical') or ((direction is None) and (self.primary_grid == 'vertical')):
+                    width = self.xwidth[__mn[0][0]]
+                    yextension = int(width/2)
+                    xextension = self.xextension0[__mn[0][0]]
+                    layer = self.xlayer[__mn[0][0]]
+                    color = self.xcolor[__mn[0][0]%self.xcolor.shape[0]] # xcolor is determined by its grid layer.
+                else:
+                    width = self.ywidth[__mn[0][1]]
+                    yextension = self.yextension0[__mn[0][1]]
+                    xextension = int(width/2)
+                    layer = self.ylayer[__mn[0][1]]
+                    color = self.ycolor[__mn[0][1]%self.ycolor.shape[0]] # ycolor is determined by its grid layer.
+            else:
+                if (xy0[0] == xy1[0]) or (direction == 'vertical'):  # vertical routing
+                    width = self.xwidth[__mn[0][0]]
+                    yextension = int(width/2)
+                    xextension = self.xextension[__mn[0][0]]
+                    layer = self.xlayer[__mn[0][0]]
+                    color = self.xcolor[__mn[0][0]%self.xcolor.shape[0]] # xcolor is determined by its grid layer.
+
+                else:  # horizontal routing
+                    width = self.ywidth[__mn[0][1]]
+                    yextension = self.yextension[__mn[0][1]]
+                    xextension = int(width/2)
+                    layer = self.ylayer[__mn[0][1]]
+                    color = self.ycolor[__mn[0][1]%self.ycolor.shape[0]] # ycolor is determined by its grid layer.
+            p = laygo2.object.physical.Rect(xy=_xy, layer=layer, hextension=yextension, vextension=xextension, color=color)
+            route.append(p)
+            # via placement
+            if via_tag is None:
+                if (i > 0) and (i < mn.shape[0] - 1):
+                    route.append(self.via(mn=__mn[0], params=None))
+            else:
+                if via_tag[i + 1] == True:
+                    route.append(self.via(mn=__mn[1], params=None))
+                elif via_tag[i+1] != False:
+                    route.append(self.via(mn=__mn[1], params={'cut':via_tag[i+1]}))
+                else:
+                    pass
+        if len(route) == 1:  # not isinstance(mn[0][0], list):
+            return route[0]
+        else:
             return route
```

### Comparing `laygo2-0.5.6/laygo2/object/grid/__init__.py` & `laygo2-0.5.7/LICENSE`

 * *Files 22% similar despite different names*

```diff
@@ -1,41 +1,29 @@
-# -*- coding: utf-8 -*-
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-"""
-**laygo2.object.grid** module contains classes that implement abstract coordinate systems that are interacting with technology-specific physical coordinate systems.
-
-laygo2 implements the layout designs based on the abstract coordinate system.
-
-.. image:: ../assets/img/user_guide_grid.png
-
-
-
-Check the following links for the details of component methods and classes.
-"""
-
-from .core import *
-from .routing import *
-from .placement import *
-from .uniformrouting import *
-#from laygo2.object.grid.routing import *
+BSD 3-Clause License
+
+Copyright (c) 2019, jdhan
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+1. Redistributions of source code must retain the above copyright notice, this
+   list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright notice,
+   this list of conditions and the following disclaimer in the documentation
+   and/or other materials provided with the distribution.
+
+3. Neither the name of the copyright holder nor the names of its
+   contributors may be used to endorse or promote products derived from
+   this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

### Comparing `laygo2-0.5.6/laygo2/object/grid/core.py` & `laygo2-0.5.7/laygo2/object/grid/core.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,3157 +1,3157 @@
-#!/usr/bin/python
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-__author__ = "Jaeduk Han"
-__maintainer__ = "Jaeduk Han"
-__status__ = "Prototype"
-
-import numpy as np
-import laygo2.object
-
-# import laygo2.util.conversion as cv
-
-
-# Internal functions.
-def _extend_index_dim(input_index, new_index, new_index_max):
-    """
-    A helper function to be used for the multi-dimensional circular array
-    indexing of CircularMappingArray. It extends the dimension of the input
-    array (input_index) that contains indexing information, with the
-    additional indexing variable (new_index) provided. The new_index_max
-    variable is specified in case of the new_index does not contain the
-    maximum index information (perhaps when an open-end slice is given for
-    the new_index).
-
-    Parameters
-    ----------
-    input_index : iterable
-        The iterable object to be extended.
-    new_index : iterable
-        The iterable object to be added to input_ind to extend its dimension.
-    new_index_max : iterable
-        The maximum index of new_index when its upper boundary is not
-        provided.
-
-    Returns
-    -------
-    Iterable: The extended index.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> # 0-dim to 1-dim
-    >>> laygo2.object.grid._extend_index_dim(None, [3, 4, 6], None)
-    [(3,), (4,), (6,)]
-    >>> # 0-dim to 1-dim (with slicing input)
-    >>> laygo2.object.grid._extend_index_dim(None, slice(3, 8, 2), None)
-    [(3,), (5,), (7,)]
-    >>> # 0-dim to 1-dim, with maximum index given
-    >>> laygo2.object.grid._extend_index_dim(None, slice(3, None, 2), 8)
-    [(3,), (4,), (6,)]
-    >>> # 1-dim to 2-dim
-    >>> laygo2.object.grid._extend_index_dim([(3,), (4,), (6,)], [1, 2], None)
-    [[(3, 1), (3, 2)], [(4, 1), (4, 2)], [(6, 1), (6, 2)]]
-    """
-    # Construct an iterator from new_index
-    if isinstance(new_index, (int, np.integer)):
-        it = [new_index]
-    else:
-        if isinstance(new_index, slice):
-            # slices don't work very well with multi-dimensional circular mappings.
-            it = _conv_slice_to_list(slice_obj=new_index, stop_def=new_index_max)
-        else:
-            it = new_index
-    # Index extension
-    if input_index is None:
-        output = []
-        for i in it:
-            output.append(tuple([i]))
-        return output
-    else:
-        output = []
-        for _i in input_index:
-            output_row = []
-            for i in it:
-                output_row.append(tuple(list(_i) + [i]))
-            output.append(output_row)
-        return output
-
-
-def _conv_slice_to_list(slice_obj, start_def=0, stop_def=100, step_def=1):
-    """Convert slice to a list.
-
-    Parameters
-    ----------
-    slice_obj : slice
-        The slice object to be converted.
-    start_def : int, optional
-        The default starting index if the slice object has no lower boundary.
-    stop_def : int, optional
-        The default stopping index if the slice object has no upper boundary.
-    step_def : int, optional
-        The default stepping index if the slice object has no step specified.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> laygo2.object.grid._conv_slice_to_list(slice(0, 10, 2))
-    [0, 2, 4, 6, 8]
-    """
-    if slice_obj.start is None:
-        start = start_def
-    else:
-        start = slice_obj.start
-    if slice_obj.stop is None:
-        stop = stop_def
-    else:
-        stop = slice_obj.stop
-    if slice_obj.step is None:
-        step = step_def
-    else:
-        step = slice_obj.step
-    return list(range(start, stop, step))
-
-
-def _conv_bbox_to_array(bbox):
-    """
-    Convert a bbox object to a 2-d array.
-
-    Parameters
-    ----------
-    bbox : numpy.ndarray
-        The bounding box to be converted.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> import numpy as np
-    >>> laygo2.object.grid._conv_bbox_to_array(np.array([[0, 0], [1, 2]]))
-    array([[[0, 0], [1, 0]],
-           [[0, 1], [1, 1]],
-           [[0, 2], [1, 2]]])
-    """
-    array = list()
-    for r in range(bbox[0, 1], bbox[1, 1] + 1):
-        row = list()
-        for c in range(bbox[0, 0], bbox[1, 0] + 1):
-            row.append([c, r])
-        array.append(row)
-    return np.array(array)
-
-
-def _conv_bbox_to_list(bbox):
-    """
-    Convert a bbox object to a 1-d list.
-
-    Parameters
-    ----------
-    bbox : numpy.ndarray
-        The bounding box to be converted.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> import numpy as np
-    >>> laygo2.object.grid._conv_bbox_to_list(np.array([[0, 0], [1, 2]]))
-    [[0, 0], [1, 0], [0, 1], [1, 1], [0, 2], [1, 2]]
-    """
-    array = list()
-    for r in range(bbox[0, 1], bbox[1, 1] + 1):
-        for c in range(bbox[0, 0], bbox[1, 0] + 1):
-            array.append([c, r])
-    return array
-
-
-# External functions
-def copy(obj):
-    """Make a copy of the input grid object.
-
-    Parameters
-    ----------
-    obj : laygo2.object.grid.Grid
-        The input grid object to be copied.
-
-    Returns
-    -------
-    laygo2.object.grid.Grid or derived: the copied grid object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.grid import OneDimGrid, Grid
-    >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
-    >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
-    >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
-    >>> g2_copy = laygo2.object.grid.copy(g2)
-    >>> print(g2)
-    <laygo2.object.grid.core.Grid object at 0x000002002EBA67A0>
-     name: test,
-    class: Grid,
-    scope: [[0, 0], [100, 100]],
-    elements: [array([ 0, 10, 20, 40, 50]), array([10, 20, 40, 50, 60])],
-    >>> print(g2_copy)
-    <laygo2.object.grid.core.Grid object at 0x0000020040C35240>
-     name: test,
-     class: Grid,
-     scope: [[0, 0], [100, 100]],
-     elements: [array([ 0, 10, 20, 40, 50]), array([10, 20, 40, 50, 60])],
-    """
-    return obj.copy()
-
-
-def vflip(obj):
-    """Make a vertically-flipped copy of the input grid object.
-    
-    Parameters
-    ----------
-    obj : laygo2.object.grid.Grid
-        The input grid object to be copied and flipped.
-
-    Returns
-    -------
-    laygo2.object.grid.Grid or derived: the generated grid object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.grid import OneDimGrid, Grid
-    >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
-    >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
-    >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
-    >>> g2_copy = laygo2.object.grid.vflip(g2)
-    >>> print(g2)
-    <laygo2.object.grid.core.Grid object at 0x000001EE82660BE0>
-     name: test,
-     class: Grid,
-     scope: [[0, 0], [100, 100]],
-     elements: [array([ 0, 10, 20, 40, 50]), array([10, 20, 40, 50, 60])],
-    >>> print(g2_copy)
-    <laygo2.object.grid.core.Grid object at 0x000001EE947152D0>
-     name: test,
-     class: Grid,
-     scope: [[0, 0], [100, 100]],
-     elements: [array([ 0, 10, 20, 40, 50]), array([40, 50, 60, 80, 90])],
-    """
-    return obj.vflip(copy=True)
-
-
-def hflip(obj):
-    """Make a horizontally-flipped copy of the input grid object.
-    
-    Parameters
-    ----------
-    obj : laygo2.object.grid.Grid
-        The input grid object to be copied and flipped.
-
-    Returns
-    -------
-    laygo2.object.grid.Grid: the generated grid object.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.grid import OneDimGrid, Grid
-    >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
-    >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
-    >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
-    >>> g2_copy = laygo2.object.grid.hflip(g2)
-    >>> print(g2)
-    <laygo2.object.grid.core.Grid object at 0x000001ACECC30BE0>
-     name: test,
-     class: Grid,
-     scope: [[0, 0], [100, 100]],
-     elements: [array([ 0, 10, 20, 40, 50]), array([10, 20, 40, 50, 60])],
-    >>> print(g2_copy)
-    <laygo2.object.grid.core.Grid object at 0x000001ACFED15300>
-     name: test,
-     class: Grid,
-     scope: [[0, 0], [100, 100]],
-     elements: [array([ 50,  60,  80,  90, 100]), array([10, 20, 40, 50, 60])],
-    """
-    return obj.hflip(copy=True)
-
-
-def vstack(obj):
-    """Stack grid(s) in vertical direction.
-    
-    Parameters
-    ----------
-    obj : list of laygo2.object.grid.Grid
-        The list containing grid objects to be stacked.
-    
-    Returns
-    -------
-    laygo2.object.grid.Grid: the generated grid object.
-    
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.grid import OneDimGrid, Grid
-    >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
-    >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
-    >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
-    >>> g2_copy = laygo2.object.grid.copy(g2)
-    >>> g2_stack = laygo2.object.grid.vstack([g2, g2_copy])
-    >>> print(g2)
-    <laygo2.object.grid.core.Grid object at 0x000001799FAA0BE0>
-     name: test,
-     class: Grid,
-     scope: [[0, 0], [100, 100]],
-     elements: [array([ 0, 10, 20, 40, 50]), array([10, 20, 40, 50, 60])],
-    >>> print(g2_stack)
-    <laygo2.object.grid.core.Grid object at 0x00000179B1B05870>
-     name: test,
-     class: Grid,
-     scope: [[0, 0], [100, 200]],
-     elements: [array([ 0, 10, 20, 40, 50]), array([ 10,  20,  40,  50,  60, 110, 120, 140, 150, 160])],
-    """
-    return obj[0].vstack(obj[1:], copy=True)
-
-
-def hstack(obj):
-    """Stack grid(s) in horizontal direction.
-
-    Parameters
-    ----------
-    obj : list of laygo2.object.grid.Grid
-        The list containing grid objects to be stacked.
-    
-    Returns
-    -------
-    laygo2.object.grid.Grid: the generated grid object.
-    
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.grid import OneDimGrid, Grid
-    >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
-    >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
-    >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
-    >>> g2_copy = laygo2.object.grid.copy(g2)
-    >>> g2_stack = laygo2.object.grid.hstack([g2, g2_copy])
-    >>> print(g2)
-    <laygo2.object.grid.core.Grid object at 0x000001799FAA0BE0>
-     name: test,
-     class: Grid,
-     scope: [[0, 0], [100, 100]],
-     elements: [array([ 0, 10, 20, 40, 50]), array([10, 20, 40, 50, 60])],
-    >>> print(g2_stack)
-    <laygo2.object.grid.core.Grid object at 0x0000015BD8C85570>
-     name: test,
-     class: Grid,
-     scope: [[0, 0], [200, 100]],
-     elements: [array([  0,  10,  20,  40,  50, 100, 110, 120, 140, 150]), array([10, 20, 40, 50, 60])],
-    """
-
-    return obj[0].hstack(obj[1:], copy=True)
-
-
-# Internal classes
-class CircularMapping:
-    """
-    Basic circular mapping class (index number expands infinitely).
-
-    Example
-    -------
-    >>> from laygo2.object.grid import Circularmapping
-    >>> map = CircularMapping(elements=[100, 200, 300])
-    >>> print(map[0])
-    100
-    >>> print(map[2])
-    300
-    >>> print(map[4])
-    200
-    >>> print(map[-3])
-    100
-    >>> print(map[[2, 3, -2])
-    [300, 100, 200]
-    >>> print(map[2:7])
-    [300, 100, 200, 300, 100]
-
-    Notes
-    -----
-    **(Korean)** 기본 순환 맵핑 (인덱싱 넘버가 무한히 확장) 클래스.
-    """
-
-    _elements = None
-    """list: Array consisting of the elements of circular mapping.
-
-    Example
-    -------
-    >>> from laygo2.object.grid import CircularMapping
-    >>> elements = [0, 35, 85, 130, 180] 
-    >>> cm = CircularMapping(elements) 
-    >>> cm.elements
-    [0, 35, 85, 130, 180]
-
-    .. image:: ../assets/img/object_grid_CircularMapping_elements.png
-           :height: 250 
-
-    Notes
-    -----
-    **(Korean)**
-    순환 맵핑의 구성 요소로 이루어진 배열. 
-    """
-
-    dtype = int
-    """type: Data type of the circular mapping.
-
-    Example
-    -------
-    >>> from laygo2.object.grid import CircularMapping
-    >>> elements = [0, 35, 85, 130, 180] 
-    >>> cm = CircularMapping(elements) 
-    >>> cm.dtype
-    int
-
-    .. image:: ../assets/img/object_grid_CircularMapping_dtype.png
-           :height: 250
-
-    Notes
-    -----
-    **(Korean)**
-    순환 맵핑의 데이터 유형.
-    """
-
-    def get_elements(self):
-        """numpy.ndarray: getter of elements."""
-        return self._elements
-
-    def set_elements(self, value):
-        """numpy.ndarray: setter of elements."""
-        self._elements = np.asarray(value, dtype=self.dtype)
-
-    elements = property(get_elements, set_elements)
-    """numpy.ndarray: the array that contains the physical coordinates of the grid."""
-
-    @property
-    def shape(self):
-        """numpy.ndarray: The shape of circular mapping.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import CircularMapping
-        >>> elements = [0, 35, 85, 130, 180]
-        >>> cm = CircularMapping(elements)
-        >>> cm.shape
-        array([5])
-
-        .. image:: ../assets/img/object_grid_CircularMapping_shape.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)**
-        순환 맵핑의 shape.
-        """
-        return np.array(self.elements.shape)
-
-    def __init__(self, elements=np.array([0]), dtype=int):
-        """
-        Constructor function of CircularMapping class.
-
-        Parameters
-        ----------
-        elements : list
-            elements.
-        dtype : type
-            data type of elements.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import CircularMapping
-        >>> elements = [0, 35, 85, 130, 180]
-        >>> cm = CircularMapping(elements)
-        >>> cm.shape
-        [5]
-        >>> cm[5]
-        35
-        >>> cm[0:10]
-        [0, 35, 85, 130, 0, 35, 85, 130, 0, 35]
-
-        .. image:: ../assets/img/object_grid_CircularMapping_init.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** CircularMapping 클래스의 생성자함수
-            파라미터
-            - elements(list): 구성 요소
-            - dtype(type): 구성 요소의 datatype
-        """
-        self.dtype = dtype
-        self.elements = np.asarray(elements, dtype=dtype)
-
-    # indexing and slicing
-    def __getitem__(self, pos):
-        """Element access function of circular mapping."""
-        if isinstance(pos, (int, np.integer)):
-            return self.elements[pos % self.shape[0]]
-        elif isinstance(pos, slice):
-            return self.__getitem__(
-                pos=_conv_slice_to_list(slice_obj=pos, stop_def=self.shape[0])
-            )
-        elif isinstance(pos, np.ndarray):
-            return np.array([self.__getitem__(pos=p) for p in pos])
-        elif isinstance(pos, list):
-            return [self.__getitem__(pos=p) for p in pos]
-        elif pos is None:
-            return None
-        else:
-            raise TypeError("CircularMapping received an invalid index:%s" % str(pos))
-
-    # Iterators
-    def __iter__(self):
-        """Iteration function of circular mapping."""
-        return self.elements.__iter__()
-
-    def __next__(self):
-        """Next element access function of circular mapping."""
-        # Check if numpy.ndarray implements __next__()
-        return self.elements.__next__()
-
-    # Informative functions
-    def __str__(self):
-        return self.summarize()
-
-    def summarize(self):
-        """Return the summary of the object information."""
-        return (
-            self.__repr__() + " "
-            "class: "
-            + self.__class__.__name__
-            + ", "
-            + "elements: "
-            + str(self.elements)
-        )
-
-    # Regular member functions
-    def append(self, elem):
-        """Append elements to the mapping."""
-        if not isinstance(elem, list):
-            elem = [elem]
-        self.elements = np.array(self.elements.tolist() + elem)
-
-    def flip(self):
-        """Flip the elements of the object."""
-        self.elements = np.flip(self.elements, axis=0)
-
-    def copy(self):
-        """Copy the object."""
-        return CircularMapping(self.elements.copy(), dtype=self.dtype)
-
-    def concatenate(self, obj):
-        self.elements = np.concatenate((self.elements, obj.elements))
-        # for e in elements:
-        #    self.elements = np.concatenate((self.elements, obj.elements))
-        # self.range[1] += obj.range[1] - obj.range[0]
-
-
-class CircularMappingArray(CircularMapping):
-    """
-    Multi-dimensional circular mapping class (index number expands infinitely).
-
-    Notes
-    -----
-    **(Korean)** 다차원 순환맵핑(인덱싱 넘버가 무한히 확장) 클래스.
-    """
-
-    def __getitem__(self, pos):
-        """
-        Element access function.
-
-        Parameters
-        ----------
-        pos : int
-            index number being accessed.
-
-        Returns
-        -------
-        numpy.ndarray
-
-        Example
-        -------
-        >>> from laygo2.object.grid import CircularMappingArray
-        >>> elements = [[0, 0], [35, 0], [85, 0], [130, 0]]
-        >>> cm = CircularMappingArray(elements = elements)
-        >>> cm[1, :]
-        array([[35, 0]])
-        >>> cm[3, 0]
-        130
-
-        .. image:: ../assets/img/object_grid_CircularMappingArray_getitem.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 순환 맵핑의 요소 접근함수
-        """
-        if isinstance(pos, list):  # pos is containing multiple indices as a list
-            return [self.__getitem__(pos=p) for p in pos]
-        elif pos is None:
-            return None
-        elif np.all(np.array([isinstance(p, (int, np.integer)) for p in pos])):
-            # pos is mapped to a single element (pos is composed of integer indices).
-            # just do rounding.
-            idx = []
-            for p, s in zip(pos, self.shape):
-                idx.append(p % s)
-            return self.elements[tuple(idx)]
-        else:
-            # pos is mapped to multiple indices. (possible Example include ([0:5, 3], [[1,2,3], 3], ...).
-            # Create a list containing the indices to iterate over, and return a numpy.ndarray containing items
-            # corresponding to the indices in the list.
-            # When the indices don't specify the lower boundary (e.g., [:5]), it iterates from 0.
-            # When the indices don't specify the upper boundary (e.g., [3:]), it iterates to the maximum index defined.
-            idx = None
-            for i, p in enumerate(pos):  # iterate over input indices (x and y).
-                idx = _extend_index_dim(idx, p, self.shape[i])
-            idx = np.asarray(idx)
-            # iterate and generate the list to return
-            item = np.empty(
-                idx.shape[:-1], dtype=self.dtype
-            )  # -1 because the tuples in idx are flatten.
-            for i, _null in np.ndenumerate(item):
-                item[i] = self.__getitem__(pos=tuple(idx[i]))
-            return np.asarray(item)
-
-    # Regular member functions
-    def flip(self, axis):
-        """Flip the elements of the object."""
-        self.elements = np.flip(self.elements, axis=axis)
-
-    def copy(self):
-        """Copy the object."""
-        return CircularMappingArray(self.elements.copy(), dtype=self.dtype)
-
-
-class _AbsToPhyGridConverter:
-    """
-    An internal class that converts abstract coordinates into physical
-    coordinates. Conversely, conditional operators convert physical
-    coordinates into abstract coordinates.
-
-    .. image:: ../assets/img/user_guide_abs2phy.png
-
-    Notes
-    -----
-    **(Korean)** 추상 좌표를 물리 좌표로 변환하는 클래스, 조건부연산은 역변환을
-    수행한다.
-    """
-
-    master = None
-    """laygo2.Grid or laygo2.OneDimGrid: Coordinate system to which 
-    _AbsToPhyGridConverter object belongs.
-
-    Example
-    -------
-    >>> from laygo2.object.grid import OneDimGrid, Grid
-    >>> g1_x = OneDimGrid(name='xg', scope=[0, 180], elements=[0, 35, 85, 130, 180]) 
-    >>> g1_y = OneDimGrid(name='yg', scope=[0, 30], elements=[0]) 
-    >>> g2   = Grid(name='g', vgrid=g1_x, hgrid=g1_y) 
-    >>> print(g1_x.abs2phy) 
-    <laygo2.object.grid._AbsToPhyGridConverter object> 
-    >>> print(g2.xy) 
-    <laygo2.object.grid._AbsToPhyGridConverter object>
-    >>> print(g1_x.abs2phy.master) 
-    <laygo2.object.grid.OneDimGrid object>
-    >>> print(g2.xy.master) 
-    <laygo2.object.grid.Grid object>
-
-    Notes
-    -----
-    **(Korean)** _AbsToPhyGridConverter 객체가 속한 좌표계.
-    """
-
-    # Constructor
-    def __init__(self, master):
-        """Constructor function of _AbsToPhyGridConverter class."""
-        self.master = master
-
-    # Access functions.
-    def __call__(self, pos):
-        """
-        Convert abstract coordinates of the master grid into corresponding
-        physical coordinates.
-
-        Parameters
-        ----------
-        pos : int
-            abstract coordinates.
-
-        Returns
-        -------
-        int or numpy.ndarray
-            physical coordinates.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xg', scope=[0, 180], elements=[0, 35, 85, 130, 180])
-        >>> g1_y = OneDimGrid(name='yg', scope=[0,30], elements=[0])
-        >>> g2   = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
-        >>> g1_x.abs2phy(0)
-        0
-        >>> g2.xy(0,0)
-        [0, 0]
-
-        .. image:: ../assets/img/object_grid_AbsToPhyGridConverter_call.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 추상 좌표를 master 좌표계에서 대응되는 물리 좌표로 변환.
-        """
-        return self.__getitem__(pos)
-
-    def __getitem__(self, pos):
-        """
-        Convert abstract coordinates of the master grid into corresponding
-        physical coordinates.
-
-        Parameters
-        ----------
-        pos : int
-            abstract coordinates.
-
-        Returns
-        -------
-        int or numpy.ndarray
-            physical coordinates.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xg', scope=[0, 180], elements=[0, 35, 85, 130, 180])
-        >>> g1_y = OneDimGrid(name='yg', scope=[0, 30], elements=[0])
-        >>> g2   = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
-        >>> g1_x.abs2phy(0)
-        0
-        >>> g2.xy(0,0)
-        [0, 0]
-
-        .. image:: ../assets/img/object_grid_AbsToPhyGridConverter_getitem.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 추상 좌표를 master 좌표계에서 대응되는 물리 좌표로 변환.
-        """
-        if (self.master.__class__.__name__ == "OneDimGrid") or (
-            issubclass(self.master.__class__, OneDimGrid)
-        ):
-            return self._getitem_1d(pos)
-        if (self.master.__class__.__name__ == "Grid") or (
-            issubclass(self.master.__class__, Grid)
-        ):
-            return self._getitem_2d(pos)
-        else:
-            return None
-
-    def _getitem_1d(self, pos):
-        """An internal function of __getitem__() for 1-d grids."""
-        # Check if pos has multiple elements.
-        if isinstance(pos, slice):
-            return self._getitem_1d(
-                _conv_slice_to_list(slice_obj=pos, stop_def=self.master.shape[0])
-            )
-        elif isinstance(pos, np.ndarray):
-            return self._getitem_1d(pos.tolist())
-        elif isinstance(pos, list):
-            return np.array([self._getitem_1d(p) for p in pos])
-        elif pos is None:
-            raise TypeError(
-                "_AbsToPhyConverter._getitem_1d does not accept None as its input."
-            )
-        else:
-            # pos is a single element. Compute quotient and modulo for grid extension.
-            quo = 0
-            mod = int(round(pos))
-            if pos >= self.master.shape[0]:
-                mod = int(round(pos % self.master.shape[0]))
-                quo = int(round((pos - mod) / self.master.shape[0]))
-            elif pos < 0:
-                mod = int(round(pos % self.master.shape[0]))
-                quo = int(round((pos - mod)) / self.master.shape[0])
-            return quo * self.master.range[1] + self.master.elements[mod]
-            # the following command cannot handle the size extension of the grid, disabled.
-            # return self.master.elements.take(pos, mode='wrap')
-
-    def _getitem_2d(self, pos):
-        """An internal function of __getitem__() for 2-d grids."""
-        if isinstance(pos, list):
-            if isinstance(pos[0], (int, np.integer)):  # single point
-                return self[pos[0], pos[1]]
-            else:
-                return [self[p] for p in pos]
-        elif isinstance(pos, np.ndarray):
-            if isinstance(pos[0], (int, np.integer)):  # single point
-                return np.array(self[pos[0], pos[1]])
-            else:
-                return np.array([self[p] for p in pos])
-        # compute coordinates from OneDimGrids of its master.
-        x = self.master.x[pos[0]]
-        y = self.master.y[pos[1]]
-        # TODO: Refactor the following code to avoid the use of double for loops and list comprehensions.
-        if (not isinstance(x, np.ndarray)) and (
-            not isinstance(y, np.ndarray)
-        ):  # x and y are scalars.
-            return np.array([x, y])
-        if not isinstance(x, np.ndarray):  # x is a scalar.
-            return np.array([np.array([x, _y]) for _y in y])
-        elif not isinstance(y, np.ndarray):  # y is a scalar.
-            return np.array([np.array([_x, y]) for _x in x])
-        else:
-            xy = []
-            for _x in x:  # vectorize this operation.
-                row = []
-                for _y in y:
-                    row.append(np.array([_x, _y]))
-                xy.append(np.array(row))
-        return np.array(xy)
-
-    # Reverse-access operators (comparison operators are used for reverse-access).
-    def __eq__(self, other):
-        """
-        Convert physical coordinates into abstract coordinates of the master grid
-        satisfying conditional operations.
-
-        Parameters
-        ----------
-        other : int
-            physical coordinates.
-
-        Returns
-        -------
-        int or numpy.ndarray
-            abstract coordinates.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xg', scope=[0, 180], elements=[0, 35, 85, 130, 180])
-        >>> g1_y = OneDimGrid(name='yg', scope=[0, 30], elements=[0])
-        >>> g2   = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
-        >>> g1_x.abs2phy == 35
-        1
-        >>> g2.xy == [35, 35]
-        [1, None]
-
-        .. image:: ../assets/img/object_grid_AbsToPhyGridConverter_eq.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 물리 좌표를 master 좌표계에서 조건부 연산을 만족하는 추상 좌표로 변환.
-        """
-        return self.master.phy2abs(pos=other)
-
-    def __lt__(self, other):
-        """
-        Convert physical coordinates into abstract coordinates of the master grid
-        satisfying conditional operations.
-
-        Parameters
-        ----------
-        other : int
-            physical coordinates.
-
-        Returns
-        -------
-        int or numpy.ndarray
-            abstract coordinates.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xg', scope=[0, 180], elements=[0, 35, 85, 130, 180])
-        >>> g1_y = OneDimGrid(name='yg', scope=[0, 30], elements=[0])
-        >>> g2   = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
-        >>> g1_x.abs2phy < 35
-        0
-        >>> g2.xy < [35, 35]
-        [0, 1]
-
-        .. image:: ../assets/img/object_grid_AbsToPhyGridConverter_lt.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 물리 좌표를 master 좌표계에서 조건부 연산을 만족하는 추상 좌표로 변환.
-        """
-        if (self.master.__class__.__name__ == "OneDimGrid") or (
-            issubclass(self.master.__class__, OneDimGrid)
-        ):
-            return self._lt_1d(other)
-        if (self.master.__class__.__name__ == "Grid") or (
-            issubclass(self.master.__class__, Grid)
-        ):
-            return self._lt_2d(other)
-        else:
-            return None
-
-    @staticmethod
-    def _phy2abs_operator(other, elements, width, shape, op):
-        def phy2abs(x):
-            if x > 0:
-                quo_coarce = 0 + x // width
-                msb_sub = 1
-            else:
-                quo_coarce = 0 + x // width
-                msb_sub = 0
-
-            remain = x % width  # positive
-            msb = quo_coarce * shape - 1
-            for i, e in np.ndenumerate(elements):
-                # print("e: %d r:%d, m:%d, i:%d off:%d phy:%d " %(e, remain, msb + i[0], i[0], lsb_offset, quo_coarce*width + e   ))
-                # print(comp( e , remain ))
-
-                if comp(e, remain) == True:  # find maximum less then remain , e < r
-                    pass
-                else:  # when it is False, latest true index
-                    return msb + i[0] + lsb_offset
-
-            return msb + shape + lsb_offset
-
-        if op == "<":  ## max lesser
-            comp = lambda e, r: e < r
-            lsb_offset = 0
-
-        elif op == "<=":  ## eq or max lesser eq
-            comp = lambda e, r: e <= r
-            lsb_offset = 0
-
-        elif op == ">":  ## min greater
-            comp = lambda e, r: e <= r
-            lsb_offset = 1
-
-        elif op == ">=":  ## eq or min greater
-            comp = lambda e, r: e < r
-            lsb_offset = 1
-
-        if isinstance(other, (int, np.integer)):
-            return phy2abs(other)
-        else:
-            list_return = []
-            for o in other:
-                list_return.append(phy2abs(o))
-            return np.array(list_return)
-
-    def _lt_1d(self, other):
-        return self._phy2abs_operator(
-            other,
-            self.master.elements,
-            self.master.width,
-            self.master.elements.shape[0],
-            "<",
-        )
-
-    def _lt_2d(self, other):
-        if isinstance(other[0], (int, np.integer)):
-            return np.array([self.master.x < other[0], self.master.y < other[1]])
-        else:
-            return np.array([self._lt_2d(o) for o in other])
-
-    def __le__(self, other):
-        """
-        Convert physical coordinates into abstract coordinates of the master grid
-        satisfying conditional operations.
-
-        Parameters
-        ----------
-        other : int
-            physical coordinates.
-
-        Returns
-        -------
-        int or numpy.ndarray
-            abstract coordinates.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 180])
-        >>> g1_y = OneDimGrid(name='ygrid', scope=[0,30], elements=[0])
-        >>> g2   = Grid(name='test', vgrid=g1_x, hgrid=g1_y)
-        >>> g1_x.abs2phy <= 35
-        1
-        >>> g2.xy <= [35,35]
-        [1,1]
-
-        .. image:: ../assets/img/object_grid_AbsToPhyGridConverter_le.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 물리 좌표를 master 좌표계에서 조건부 연산을 만족하는 추상 좌표로 변환.
-        """
-        if (self.master.__class__.__name__ == "OneDimGrid") or (
-            issubclass(self.master.__class__, OneDimGrid)
-        ):
-            return self._le_1d(other=other)
-        if (self.master.__class__.__name__ == "Grid") or (
-            issubclass(self.master.__class__, Grid)
-        ):
-            return self._le_2d(other=other)
-
-    def _le_1d(self, other):
-        return self._phy2abs_operator(
-            other,
-            self.master.elements,
-            self.master.width,
-            self.master.elements.shape[0],
-            "<=",
-        )
-
-    def _le_2d(self, other):
-        if isinstance(other[0], (int, np.integer)):
-            return np.array([self.master.x <= other[0], self.master.y <= other[1]])
-        else:
-            return np.array([self._le_2d(o) for o in other])
-
-    def __gt__(self, other):
-        """
-        Convert physical coordinates into abstract coordinates of the master grid
-        satisfying conditional operations.
-
-        Parameters
-        ----------
-        other : int
-            physical coordinates.
-
-        Returns
-        -------
-        int or numpy.ndarray
-            abstract coordinates.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 180])
-        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 30], elements=[0])
-        >>> g2   = Grid(name='test', vgrid=g1_x, hgrid=g1_y)
-        >>> g1_x.abs2phy > 35
-        2
-        >>> g2.xy > [35, 35]
-        [2, 2]
-
-        .. image:: ../assets/img/object_grid_AbsToPhyGridConverter_gt.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 물리 좌표를 master 좌표계에서 조건부 연산을 만족하는 추상 좌표로 변환.
-        """
-        if (self.master.__class__.__name__ == "OneDimGrid") or (
-            issubclass(self.master.__class__, OneDimGrid)
-        ):
-            return self._gt_1d(other=other)
-        if (self.master.__class__.__name__ == "Grid") or (
-            issubclass(self.master.__class__, Grid)
-        ):
-            return self._gt_2d(other=other)
-
-    def _gt_1d(self, other):
-        return self._phy2abs_operator(
-            other,
-            self.master.elements,
-            self.master.width,
-            self.master.elements.shape[0],
-            ">",
-        )
-
-    def _gt_2d(self, other):
-        if isinstance(other[0], (int, np.integer)):
-            return np.array([self.master.x > other[0], self.master.y > other[1]])
-        else:
-            return np.array([self._gt_2d(o) for o in other])
-
-    def __ge__(self, other):
-        """
-        Convert physical coordinates into abstract coordinates of the master grid
-        satisfying conditional operations.
-
-        Parameters
-        ----------
-        other : int
-            physical coordinates.
-
-        Returns
-        -------
-        int or numpy.ndarray
-            abstract coordinates.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 180])
-        >>> g1_y = OneDimGrid(name='ygrid', scope=[0,30], elements=[0])
-        >>> g2   = Grid(name='test', vgrid=g1_x, hgrid=g1_y)
-        >>> g1_x.abs2phy >= 35
-        1
-        >>> g2.xy >= [35, 35]
-        [1, 2]
-
-        .. image:: ../assets/img/object_grid_AbsToPhyGridConverter_ge.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 물리 좌표를 master 좌표계에서 조건부 연산을 만족하는 추상 좌표로 변환.
-        """
-        if (self.master.__class__.__name__ == "OneDimGrid") or (
-            issubclass(self.master.__class__, OneDimGrid)
-        ):
-            return self._ge_1d(other=other)
-        if (self.master.__class__.__name__ == "Grid") or (
-            issubclass(self.master.__class__, Grid)
-        ):
-            return self._ge_2d(other=other)
-
-    def _ge_1d(self, other):
-        return self._phy2abs_operator(
-            other,
-            self.master.elements,
-            self.master.width,
-            self.master.elements.shape[0],
-            ">=",
-        )
-
-    def _ge_2d(self, other):
-        if isinstance(other[0], (int, np.integer)):
-            return np.array([self.master.x >= other[0], self.master.y >= other[1]])
-        else:
-            return np.array([self._ge_2d(o) for o in other])
-
-
-class _PhyToAbsGridConverter:
-    """
-    A class that converts physical coordinates into abstract coordinates.
-    Conversely, conditional operators convert abstract coordinates into
-    physical coordinates.
-
-    .. image:: ../assets/img/user_guide_phy2abs.png
-
-    Notes
-    -----
-    **(Korean)**
-    물리 좌표를 추상 좌표로 변환하는 클래스, 조건부연산은 반대로 추상 좌표를
-    물리 좌표로 변환한다.
-
-    """
-
-    master = None
-    """laygo2.Grid or laygo2.OneDimGrid: Coordinate system to which 
-    _PhyToAbsGridConverter object belongs.
-
-    Example
-    -------
-    >>> from laygo2.object.grid import OneDimGrid, Grid
-    >>> g1_x = OneDimGrid(name='xg', scope=[0, 180], elements=[0, 35, 85, 130, 180]) 
-    >>> g1_y = OneDimGrid(name='yg', scope=[0, 30], elements=[0]) 
-    >>> g2   = Grid(name='g', vgrid=g1_x, hgrid=g1_y) 
-    >>> print(g1_x.phy2abs) 
-    <laygo2.object.grid._PhyToAbsGridConverter object> 
-    >>> print(g2.mn) 
-    <laygo2.object.grid._PhyToAbsGridConverter object>
-    >>> print(g1_x.phy2abs.master) 
-    <laygo2.object.grid.OneDimGrid object>
-    >>> print(g2.mn.master) 
-    <laygo2.object.grid.Grid object>
-
-    Notes
-    -----
-    **(Korean)** _PhyToAbsGridConverter 객체가 속한 좌표계.
-    """
-
-    # Constructor
-    def __init__(self, master):
-        """Constructor function of _PhyToAbsGridConverter class."""
-        self.master = master
-
-    # Access functions.
-    def __call__(self, pos):
-        """
-        Convert physical coordinates into the corresponding abstract coordinates of
-        the master grid.
-
-        Parameters
-        ----------
-        pos : int
-            physical coordinates.
-
-        Returns
-        -------
-        int or numpy.ndarray
-            abstract coordinates.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 180])
-        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 30], elements=[0])
-        >>> g2   = Grid(name='test', vgrid=g1_x, hgrid=g1_y)
-        >>> g1_x.phy2abs(35)
-        1
-        >>> g2.mn([[35, 35]])
-        [1, None]
-
-        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_call.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 물리 좌표를 master 좌표계에서 대응되는 추상 좌표로 변환.
-        """
-        return self.__getitem__(pos)
-
-    def __getitem__(self, pos):
-        """
-        Convert physical coordinates into the corresponding abstract coordinates of the master grid.
-
-        Parameters
-        ----------
-        pos : int
-            physical coordinates.
-
-        Returns
-        -------
-        int or numpy.ndarray
-            abstract coordinates.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xg', scope=[0, 180], elements=[0, 35, 85, 130, 180])
-        >>> g1_y = OneDimGrid(name='yg', scope=[0, 30], elements=[0])
-        >>> g2   = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
-        >>> g1_x.phy2abs(35)
-        1
-        >>> g2.mn( [[35, 35]])
-        [1, None]
-
-        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_getItem.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 물리 좌표를 master 좌표계에서 대응되는 추상 좌표로 변환.
-        """
-        if (self.master.__class__.__name__ == "OneDimGrid") or (
-            issubclass(self.master.__class__, OneDimGrid)
-        ):
-            return self._getitem_1d(pos)
-        if (self.master.__class__.__name__ == "Grid") or (
-            issubclass(self.master.__class__, Grid)
-        ):
-            return self._getitem_2d(pos)
-        else:
-            return None
-
-    def _getitem_1d(self, pos):
-        """An internal function of __getitem__() for 1-d grids."""
-        # Check if pos has multiple elements.
-        if isinstance(pos, OneDimGrid):
-            return self._getitem_1d(pos=pos.elements)
-        elif isinstance(pos, slice):
-            return self._getitem_1d(
-                _conv_slice_to_list(slice_obj=pos, stop_def=self.master.shape[0])
-            )
-        elif isinstance(pos, np.ndarray):
-            return self._getitem_1d(pos.tolist())
-        elif isinstance(pos, list):
-            return np.array([self._getitem_1d(p) for p in pos])
-        elif pos is None:
-            raise TypeError(
-                "_AbsToPhyConverter._getitem_1d does not accept None as its input."
-            )
-        else:
-            # pos is a single element.
-            for i, e in np.ndenumerate(self.master.elements):
-                if (pos - e) % self.master.width == 0:
-                    return (
-                        int(round((pos - e) / self.master.width))
-                        * self.master.elements.shape[0]
-                        + i[0]
-                    )
-            return None  # no matched coordinate
-
-    def _getitem_2d(self, pos):
-        """An internal function of __getitem__() for 2-d grid."""
-        # If pos contains multiple coordinates (or objects), convert recursively.
-        if isinstance(pos, list):
-            if isinstance(
-                pos[0], (int, np.integer)
-            ):  # It's actually a single coordinate.
-                return self[pos[0], pos[1]]
-            else:
-                return [self[p] for p in pos]
-        elif isinstance(pos, np.ndarray):
-            if isinstance(
-                pos[0], (int, np.integer)
-            ):  # It's actually a single coordinate.
-                return np.array(self[pos[0], pos[1]])
-            else:
-                return np.array([self[p] for p in pos])
-        # If pos contains only one physical object, convert its bounding box to abstract coordinates
-        if (pos.__class__.__name__ == "PhysicalObject") or (
-            issubclass(pos.__class__, laygo2.object.PhysicalObject)
-        ):
-            return self.bbox(pos)
-        # If pos contains only one coordinate, convert it to abstract grid.
-        m = self.master.x == pos[0]
-        n = self.master.y == pos[1]
-        # refactor the following code to avoid the use of double for-loops and list comprehensions.
-        if (not isinstance(m, np.ndarray)) and (
-            not isinstance(n, np.ndarray)
-        ):  # x and y are scalars.
-            return np.array([m, n])
-        if not isinstance(m, np.ndarray):  # x is a scalar.
-            return np.array([np.array([m, _n]) for _n in n])
-        elif not isinstance(n, np.ndarray):  # y is a scalar.
-            return np.array([np.array([_m, n]) for _m in m])
-        else:
-            mn = []
-            for _m in m:  # vectorize this operation.
-                row = []
-                for _n in n:
-                    row.append(np.array([_m, _n]))
-                mn.append(np.array(row))
-        return np.array(mn)
-
-    # Reverse-access operators (comparison operators are used for reverse-access).
-    def __eq__(self, other):
-        """
-        Convert abstract coordinates into physical coordinates satisfying
-        conditional operations in the master grid.
-
-        Parameters
-        ----------
-        other : int
-            abstract coordinates.
-
-        Returns
-        -------
-        int or numpy.ndarray
-            physical coordinates.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xg', scope=[0, 180], elements=[0, 35, 85, 130, 180])
-        >>> g1_y = OneDimGrid(name='yg', scope=[0, 30], elements=[0])
-        >>> g2   = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
-        >>> g1_x.phy2abs == 1
-        35
-        >>> g2.mn == [1, 1]
-        [35, 30]
-
-        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_eq.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 추상 좌표를 master 좌표계에서 조건부 연산을 만족하는 물리 좌표로 변환.
-        """
-        return self.master.abs2phy(pos=other)
-
-    """
-        if (self.master.__class__.__name__ == 'OneDimGrid') or (issubclass(self.master.__class__, OneDimGrid)):
-            return self._eq_1d(other=other)
-        if (self.master.__class__.__name__ == 'Grid') or (issubclass(self.master.__class__, Grid)):
-            return self._eq_2d(other=other)
-
-    def _eq_1d(self, other):
-        return self._getitem_1d(pos=other)
-
-    def _eq_2d(self, other):
-        # If other is a physical object, convert its bounding box to abstract coordinates.
-        if (other.__class__.__name__ == 'PhysicalObject') or (issubclass(other.__class__, laygo2.object.PhysicalObject)):
-            mn0 = self.master >= other.bbox[0]
-            mn1 = self.master <= other.bbox[1]
-            return np.array([mn0, mn1])
-        if isinstance(other[0], (int, np.integer)):
-            return np.array([self.master.m[other[0]],
-                             self.master.n[other[1]]])
-        else:
-            return np.array([self._eq_2d(o) for o in other])
-    """
-
-    def __lt__(self, other):
-        """
-        Convert abstract coordinates into physical coordinates satisfying
-        conditional operations in the master grid.
-
-        Parameters
-        ----------
-        other : int
-            abstract coordinates.
-
-        Returns
-        -------
-        int or numpy.ndarray
-            physical coordinates.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 180])
-        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 30], elements=[0])
-        >>> g2   = Grid(name='test', vgrid=g1_x, hgrid=g1_y)
-        >>> g1_x.phy2abs < 1
-        0
-        >>> g2.mn < [1, 1]
-        [0, 0]
-
-        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_lt.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 추상 좌표를 master 좌표계에서 조건부 연산을 만족하는 물리 좌표로 변환.
-        """
-        if (self.master.__class__.__name__ == "OneDimGrid") or (
-            issubclass(self.master.__class__, OneDimGrid)
-        ):
-            return self._lt_1d(other=other)
-        if (self.master.__class__.__name__ == "Grid") or (
-            issubclass(self.master.__class__, Grid)
-        ):
-            return self._lt_2d(other=other)
-
-    def _lt_1d(self, other):
-        if isinstance(other, (int, np.integer)):
-            return self.master.abs2phy.__getitem__(pos=other - 1)
-        return np.array([self._lt_1d(o) for o in other])
-
-    def _lt_2d(self, other):
-        if isinstance(other[0], (int, np.integer)):
-            return self.master.abs2phy.__getitem__(pos=(other[0] - 1, other[1] - 1))
-        return np.array([self._lt_2d(o) for o in other])
-
-    def __le__(self, other):
-        """
-        Convert abstract coordinates into physical coordinates satisfying
-        conditional operations in the master grid.
-
-        Parameters
-        ----------
-        other : int
-            abstract coordinates.
-
-        Returns
-        -------
-        int or numpy.ndarray
-            physical coordinates.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xg', scope=[0, 180], elements=[0, 35, 85, 130, 180])
-        >>> g1_y = OneDimGrid(name='yg', scope=[0, 30], elements=[0])
-        >>> g2   = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
-        >>> g1_x.phy2abs <= 1
-        35
-        >>> g2.mn <= [1, 1]
-        [35, 30]
-
-        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_le.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 추상 좌표를 master 좌표계에서 조건부 연산을 만족하는 물리 좌표로 변환.
-        """
-        return self.master.abs2phy(pos=other)
-
-    def __gt__(self, other):
-        """
-        Convert abstract coordinates into physical coordinates satisfying
-        conditional operations in the master grid.
-
-        Parameters
-        ----------
-        other : int
-            abstract coordinates.
-
-        Returns
-        -------
-        int or numpy.ndarray
-            physical coordinates.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 180])
-        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 30], elements=[0])
-        >>> g2   = Grid(name='test', vgrid=g1_x, hgrid=g1_y)
-        >>> g1_x.phy2abs > 1
-        85
-        >>> g2.mn > [1, 1]
-        [85, 60]
-
-        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_gt.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 추상 좌표를 master 좌표계에서 조건부 연산을 만족하는 물리 좌표로 변환.
-        """
-        if (self.master.__class__.__name__ == "OneDimGrid") or (
-            issubclass(self.master.__class__, OneDimGrid)
-        ):
-            return self._gt_1d(other)
-        if (self.master.__class__.__name__ == "Grid") or (
-            issubclass(self.master.__class__, Grid)
-        ):
-            return self._gt_2d(other)
-        else:
-            return None
-
-    def _gt_1d(self, other):
-        if isinstance(other, (int, np.integer)):
-            return self.master.abs2phy.__getitem__(pos=other + 1)
-        return np.array([self._gt_1d(o) for o in other])
-
-    def _gt_2d(self, other):
-        if isinstance(other[0], (int, np.integer)):
-            return self.master.abs2phy.__getitem__(pos=(other[0] + 1, other[1] + 1))
-        return np.array([self._gt_2d(o) for o in other])
-
-    def __ge__(self, other):
-        """
-        Convert abstract coordinates into physical coordinates satisfying
-        conditional operations in the master grid.
-
-        Parameters
-        ----------
-        other : int
-            abstract coordinates.
-
-        Returns
-        -------
-        int or numpy.ndarray
-            physical coordinates.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 180])
-        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 30], elements=[0])
-        >>> g2   = Grid(name='test', vgrid=g1_x, hgrid=g1_y)
-        >>> g1_x.phy2abs >= 1
-        35
-        >>> g2.mn >=[1, 1]
-        [35, 30]
-
-        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_ge.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 추상 좌표를 master 좌표계에서 조건부 연산을 만족하는 물리 좌표로 변환.
-        """
-        return self.master.abs2phy.__getitem__(pos=other)
-
-    def bbox(self, obj):
-        """
-        Convert the bounding box of the object into the abstract coordinates
-        of the master grid.
-
-        Parameters
-        ----------
-        obj : laygo2.physical
-            object having physical coordinate.
-
-        Returns
-        -------
-        numy.ndarray
-            abstract coordinates.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x    = OneDimGrid(name='xg', scope=[0, 100], elements=[10, 20, 40, 50, 60])
-        >>> g1_y    = OneDimGrid(name='yg', scope=[0, 100], elements=[10, 20, 40, 50, 60])
-        >>> g2      = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
-        >>> phy2abs = _PhyToAbsGridConverter(master=g2)
-        >>> rect0 = physical.Rect(xy=[[0, 0], [100, 100]], layer=['M1', 'drawing'], netname='net0’)
-        >>> phy2abs.bbox(rect0)
-        [[0, 0] , [4, 4]]
-        >>> g2.mn.bbox(rect0)
-        [[0, 0] , [4, 4]]
-
-        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_bbox.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 객체의 bounding box를 master 좌표계의 추상 좌표로 변환.
-        _AbsToPhyGridConverter 객체의 >=, <=를 사용하므로 추상면적이 작아질수있다.
-        """
-        if (obj.__class__.__name__ == "PhysicalObject") or (
-            issubclass(obj.__class__, laygo2.object.PhysicalObject)
-        ):
-            obj = obj.bbox
-
-        # phy -> abs
-        mn0 = self.master.xy >= obj[0]  ## ge than lower left
-        mn1 = self.master.xy <= obj[1]  ## le than upper right\
-
-        return np.array([mn0, mn1])
-
-    def bottom_left(self, obj):
-        """
-        Convert an object's physical corner coordinates into abstract coordinates
-        of the master grid.
-
-        Parameters
-        ----------
-        obj : laygo2.physical
-            object having physical coordinate.
-
-        Returns
-        -------
-        numy.ndarray
-            abstract coordinates.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x    = OneDimGrid(name='xgrid', scope=[0, 100], elements=[10, 20, 40, 50, 60])
-        >>> g1_y    = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60])
-        >>> g2      = Grid(name='test', vgrid=g1_x, hgrid=g1_y)
-        >>> phy2abs = _PhyToAbsGridConverter(master=g2)
-        >>> rect0 = physical.Rect(xy=[[0, 0], [100, 100]], layer=['M1', 'drawing'], netname='net0’)
-        >>> phy2abs.bottom_left(rect0)
-        [0, 0]
-        >>> g2.mn.bottom_left(rect0)
-        [0, 0]
-
-        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_bottom_left.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 객체의 물리 코너 좌표를 master 좌표계의 추상 좌표로 변환.
-        """
-        if (obj.__class__.__name__ == "PhysicalObject") or (
-            issubclass(obj.__class__, laygo2.object.PhysicalObject)
-        ):
-            return self.bottom_left(obj.bbox)
-        else:
-            _i = self.bbox(obj)
-            return _i[0]
-
-    def bottom_right(self, obj):
-        """
-        Convert an object's physical corner coordinates into abstract coordinates
-        of the master grid.
-
-        Parameters
-        ----------
-        obj : laygo2.physical
-            object having physical coordinate.
-
-        Returns
-        -------
-        numy.ndarray
-            abstract coordinates.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x    = OneDimGrid(name='xg', scope=[0, 100], elements=[10, 20, 40, 50, 60])
-        >>> g1_y    = OneDimGrid(name='yg', scope=[0, 100], elements=[10, 20, 40, 50, 60])
-        >>> g2      = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
-        >>> phy2abs = _PhyToAbsGridConverter(master=g2)
-        >>> rect0 = physical.Rect(xy=[[0, 0], [100, 100]], layer=['M1', 'drawing'], netname='net0’)
-        >>> phy2abs.bottom_right(rect0)
-        [4, 0]
-        >>> g2.mn.bottom_right(rect0)
-        [4, 0]
-
-        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_bottom_right.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 객체의 물리 코너 좌표를 master 좌표계의 추상 좌표로 변환.
-        """
-        if (obj.__class__.__name__ == "PhysicalObject") or (
-            issubclass(obj.__class__, laygo2.object.PhysicalObject)
-        ):
-            return self.bottom_right(obj.bbox)
-        else:
-            _i = self.bbox(obj)
-            return np.array([_i[1, 0], _i[0, 1]])
-
-    def top_left(self, obj):
-        """
-        Convert an object's physical corner coordinates into abstract coordinates
-        of the master grid.
-
-        Parameters
-        ----------
-        obj : laygo2.physical
-            object having physical coordinate.
-
-        Returns
-        -------
-        numy.ndarray
-            abstract coordinates.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x    = OneDimGrid(name='xg', scope=[0, 100], elements=[10, 20, 40, 50, 60])
-        >>> g1_y    = OneDimGrid(name='yg', scope=[0, 100], elements=[10, 20, 40, 50, 60])
-        >>> g2      = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
-        >>> phy2abs = _PhyToAbsGridConverter(master=g2)
-        >>> rect0 = physical.Rect(xy=[[0, 0], [100, 100]], layer=['M1', 'drawing'], netname='net0’)
-        >>> phy2abs.top_left(rect0)
-        [0, 4]
-        >>> g2.mn.top_left(rect0)
-        [0, 4]
-
-        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_top_left.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 객체의 물리 코너 좌표를 master 좌표계의 추상 좌표로 변환.
-        """
-        if (obj.__class__.__name__ == "PhysicalObject") or (
-            issubclass(obj.__class__, laygo2.object.PhysicalObject)
-        ):
-            return self.top_left(obj.bbox)
-        else:
-            _i = self.bbox(obj)
-            return np.array([_i[0, 0], _i[1, 1]])
-
-    def top_right(self, obj):
-        """
-        Convert an object's physical corner coordinates into abstract
-        coordinates of the master grid.
-
-        Parameters
-        ----------
-        obj : laygo2.physical
-            object having physical coordinate.
-
-        Returns
-        -------
-        numy.ndarray
-            abstract coordinates.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x    = OneDimGrid(name='xg', scope=[0, 100], elements=[10, 20, 40, 50, 60])
-        >>> g1_y    = OneDimGrid(name='yg', scope=[0, 100], elements=[10, 20, 40, 50, 60])
-        >>> g2      = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
-        >>> phy2abs = _PhyToAbsGridConverter(master=g2)
-        >>> rect0 = physical.Rect(xy=[[0, 0], [100, 100]], layer=['M1', 'drawing'], netname='net0’)
-        >>> phy2abs.top_right(rect0)
-        [4, 4]
-        >>> g2.mn.top_right(rect0)
-        [4, 4]
-
-        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_top_right.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 객체의 물리 코너 좌표를 master 좌표계의 추상 좌표로 변환.
-        """
-        if (obj.__class__.__name__ == "PhysicalObject") or (
-            issubclass(obj.__class__, laygo2.object.PhysicalObject)
-        ):
-            return self.top_right(obj.bbox)
-        else:
-            _i = self.bbox(obj)
-            return _i[1]
-
-    def width(self, obj):
-        """Return the width of an object on this grid."""
-        if (obj.__class__.__name__ == "PhysicalObject") or (
-            issubclass(obj.__class__, laygo2.object.PhysicalObject)
-        ):
-            return self.width(obj.bbox)
-        else:
-            _i = self.bbox(obj)
-            return abs(_i[1, 0] - _i[0, 0])
-
-    def height(self, obj):
-        """Return the height of an object on this grid."""
-        if (obj.__class__.__name__ == "PhysicalObject") or (
-            issubclass(obj.__class__, laygo2.object.PhysicalObject)
-        ):
-            return self.height(obj.bbox)
-        else:
-            _i = self.bbox(obj)
-            return abs(_i[1, 1] - _i[0, 1])
-
-    def height_vec(self, obj):
-        """numpy.ndarray(dtype=int): Return np.array([0, height])."""
-        return np.array([0, self.height(obj)])
-
-    def width_vec(self, obj):
-        """numpy.ndarray(dtype=int): Return np.array([width, 0])."""
-        return np.array([self.width(obj), 0])
-
-    def size(self, obj):
-        """
-        Convert an object's size ([width, height]) into abstract coordinates
-        of the master grid.
-
-        Parameters
-        ----------
-        obj : laygo2.physical
-            object having physical coordinate.
-
-        Returns
-        -------
-        numpy.ndarray
-            abstract coordinates.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x    = OneDimGrid(name='xg', scope=[0, 100], elements=[10, 20, 40, 50, 60])
-        >>> g1_y    = OneDimGrid(name='yg', scope=[0, 100], elements=[10, 20, 40, 50, 60])
-        >>> g2      = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
-        >>> phy2abs = _PhyToAbsGridConverter(master=g2)
-        >>> rect0 = physical.Rect(xy=[[0, 0], [100, 100]], layer=['M1', 'drawing'], netname='net0’)
-        >>> phy2abs.size(rect0)
-        [4, 4]
-        >>> g2.mn.size(rect0)
-        [4, 4]
-
-        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_size.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 객체의 크기([width, height])를 master 좌표계의 추상 좌표로 변환.
-        """
-        return np.array([self.width(obj), self.height(obj)])
-
-    def crossing(self, *args):
-        """
-        Convert the physical intersections of objects into abstract coordinates
-        of the master grid.
-
-        Parameters
-        ----------
-        args : laygo2.Physical
-            physical object having bbox.
-
-        Returns
-        -------
-        numpy.ndarray(int, int)
-            abstract points.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xg', scope=[0, 10], elements=[0])
-        >>> g1_y = OneDimGrid(name='yg’, scope=[0, 120], elements=[0, 20, 40, 80, 100, 120])
-        >>> g2   = Grid(name='g', vgrid = g1_x, hgrid = g1_y )
-        >>> phy2abs = _PhyToAbsGridConverter(master=g2)
-        >>> rect0= physical.Rect(xy=[[0, 0], [60, 90]])
-        >>> rect1= physical.Rect(xy=[[30, 30], [120, 120]])
-        >>> phy2abs.crossing(rect0, rect1)
-        [3, 2]
-        >>> g2.mn.crossing(rect0, rect1)
-        [3, 2]
-
-        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_crossing.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 객체들의 물리적 교차점을 master 좌표계의 추상 좌표로 변환.
-        """
-        return self.overlap(*args, type="point")
-
-    def overlap(self, *args, type="bbox"):
-        """
-        Convert the overlapping area of objects into abstract coordinates of
-        the master grid and return in a format specified in type.
-
-        A bounding box is returned if type='bbox'
-
-        All coordinates in the overlapped region are returned in a
-        two-dimensional array if type='array'
-
-        An one-dimensional list is returned if type='list'.
-
-        Parameters
-        ----------
-        args : laygo2.Physical
-            physical object having bbox.
-
-        Returns
-        -------
-        numpy.ndarray
-            bbox abstract coordinates.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xg', scope=[0, 10], elements=[0])
-        >>> g1_y = OneDimGrid(name='yg', scope=[0, 120], elements=[0, 20, 40, 80, 100, 120])
-        >>> g2   = Grid(name='g', vgrid = g1_x, hgrid = g1_y )
-        >>> phy2abs = _PhyToAbsGridConverter(master=g2)
-        >>> rect0= physical.Rect(xy=[[0, 0], [60, 90]])
-        >>> rect1= physical.Rect(xy=[[30, 30], [120, 120]])
-        >>> phy2abs.overlap(rect0, rect1)
-        [[3, 2], [6,4]]
-        >>> g2.mn.overlap(rect0, rect1)
-        [[3, 2], [6,4]]
-
-        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_overlap.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 객체들의 겹치는 면적을 master 좌표계의 추상 좌표로 변환 후
-        type에 따른 형태로 반환.
-
-        'bbox'인 경우, bounding box로 반환.
-
-        'array' 인 경우 모든 교점을 2차원 array로 반환.
-
-        'list' 인경우 모든 교점을 1차원 list로 변환.
-        """
-        _ib = None
-        for _obj in args:
-            if _ib is None:
-                _ib = self.bbox(_obj)  ## shaped
-            else:
-                _b = self.bbox(_obj)
-                _x = np.sort(np.array([_b[:, 0], _ib[:, 0]]), axis=None)
-                _y = np.sort(np.array([_b[:, 1], _ib[:, 1]]), axis=None)
-                _ib = np.array([[_x[1], _y[1]], [_x[2], _y[2]]])
-        if type == "bbox":
-            return _ib
-        elif type == "point":
-            return _ib[0]
-        elif type == "list":
-            return _conv_bbox_to_list(_ib)
-        elif type == "array":
-            return _conv_bbox_to_array(_ib)
-        else:
-            raise ValueError(
-                "overlap() should receive a valid value for its type (bbox, point, array, ...)"
-            )
-
-    def union(self, *args):
-        """
-        Convert the bounding box containing all objects into abstract coordinates
-        of the master grid.
-
-        Parameters
-        ----------
-        args : laygo2.Physical
-            physical object having bbox.
-
-        Returns
-        -------
-        numpy.ndarray
-            bbox abstract coordinates.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 10], elements=[0])
-        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 120], elements=[0, 20, 40, 80, 100, 120 )
-        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
-        >>> rect0= physical.Rect(xy=[[0, 0], [60, 90]])
-        >>> rect1= physical.Rect(xy=[[30, 30], [120, 120]])
-        >>> g2.mn.union(rect0, rect1)
-        [[0, 0], [12,7]]
-
-        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_union.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 객체들을 모두 포함하는 bounding box를 master 좌표계의
-        추상 좌표로 변환.
-        """
-        _ub = None
-        for _obj in args:
-            if _ub is None:
-                _ub = self.bbox(_obj)
-            else:
-                _b = self.bbox(_obj)
-                _x = np.sort(np.array([_b[:, 0], _ub[:, 0]]), axis=None)
-                _y = np.sort(np.array([_b[:, 1], _ub[:, 1]]), axis=None)
-                _ub = np.array([[_x[0], _y[0]], [_x[3], _y[3]]])
-        return _ub
-
-    def center(self, obj):
-        """
-        Convert an object's physical center coordinates into abstract coordinates
-        of the master grid.
-
-        Parameters
-        ----------
-        obj : laygo2.physical
-            object having physical coordinate.
-
-        Returns
-        -------
-        numy.ndarray
-            abstract coordinates.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x    = OneDimGrid(name='xg', scope=[0, 100], elements=[10, 20, 40, 50, 60])
-        >>> g1_y    = OneDimGrid(name='yg', scope=[0, 100], elements=[10, 20, 40, 50, 60])
-        >>> g2      = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
-        >>> phy2abs = _PhyToAbsGridConverter(master=g2)
-        >>> rect0 = physical.Rect(xy=[[0, 0], [100, 100]], layer=['M1', 'drawing'], netname='net0’)
-        >>> phy2abs.center(rect0)
-        [3, 3]
-        >>> g2.mn.center(rect0)
-        [3, 3]
-
-        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_center.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 객체의 물리 중앙 좌표를 master 좌표계의 추상 좌표로 변환.
-        """
-        mn0 = self.master.xy >= obj.center
-        mn1 = self.master.xy <= obj.center
-
-        point_list = [
-            self.master.xy[mn0],
-            self.master.xy[mn1],
-            self.master.xy[mn0[0], mn1[1]],
-            self.master.xy[mn1[0], mn0[1]],
-        ]  # 4 physical points near the center coordinate.
-        dist_list = []
-        idx = 0
-        for point in point_list:
-            dist_list.append(
-                [idx, np.linalg.norm(point - obj.center)]
-            )  # Calculate Euclidean distances.
-            idx += 1
-        dist_sorted = sorted(
-            dist_list, key=lambda distance: distance[1]
-        )  # Sort distances in ascending order.
-        return self.master.mn(
-            point_list[dist_sorted[0][0]]
-        )  # Convert the closest point to abstract coordinate and then return.
-    
-    def left(self, obj):
-        """
-        Convert an object's physical left-center coordinate into abstract
-        coordinate of the master grid.
-        """
-        return np.array([self.bottom_left(obj)[0], self.center(obj)[1]])
-    
-    def right(self, obj):
-        """
-        Convert an object's physical right-center coordinate into abstract
-        coordinate of the master grid.
-        """
-        return np.array([self.bottom_right(obj)[0], self.center(obj)[1]])
-    
-    def top(self, obj):
-        """
-        Convert an object's physical upper-center coordinate into abstract
-        coordinate of the master grid.
-        """
-        return np.array([self.center(obj)[0], self.top_left(obj)[1]])
-    
-    def bottom(self, obj):
-        """
-        Convert an object's physical lower-center coordinate into abstract
-        coordinate of the master grid.
-        """
-        return np.array([self.center(obj)[0], self.bottom_left(obj)[1]])
-
-
-
-class OneDimGrid(CircularMapping):
-    """
-    Class implementing one-dimensional abstract coordinates.
-
-    Notes
-    -----
-    **(Korean)**
-    1차원 추상좌표를 구현하는 클래스.
-
-    """
-
-    # Member variables and properties
-    name = None
-    """str: Coordinate system name.
-
-    Example
-    -------
-    >>> from laygo2.object.grid import OneDimGrid
-    >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 50]) 
-    >>> g1_x.name
-    "xgrid"
-
-    .. image:: ../assets/img/object_grid_OneDimGrid_name.png
-           :height: 250
-
-    Notes
-    -----
-    **(Korean)** 좌표계 이름.
-    """
-
-    range = None
-    """str: Region in which the coordinate system is defined Coordinates in 
-    the defined region are repeatedly expanded.
-
-    Example
-    -------
-    >>> from laygo2.object.grid import OneDimGrid
-    >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 50]) 
-    >>> g1_x.range
-    [0, 180]
-    
-    .. image:: ../assets/img/object_grid_OneDimGrid_range.png
-           :height: 250
-
-    Notes
-    -----
-    **(Korean)** 좌표계가 정의된 영역. 정의된 영역의 좌표들이 반복되는 형태로 확장된다.
-    """
-
-    phy2abs = None
-    """self.phy2abs (laygo2._PhyToAbsGridConverter): Object that converts physical 
-    coordinates into abstract coordinates.
-
-    Example
-    -------
-    >>> from laygo2.object.grid import OneDimGrid
-    >>> g1_x  = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 50]) 
-    >>> g1_x.phy2abs
-    <_PhyToAbsGridConverter object>
-
-    Notes
-    -----
-    **(Korean)** 물리 좌표에서 추상 좌표로 변환연산을 해주는 객체. 
-    """
-
-    abs2phy = None
-    """self.abs2phy (laygo2._AbsToPhyGridConverter): Object that converts abstract 
-    coordinates into physical coordinates.
-
-    Example
-    -------
-    >>> from laygo2.object.grid import OneDimGrid
-    >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 50]) 
-    >>> g1_x.abs2phy
-    <_AbsToPhyGridConverter object>
-
-    Notes
-    -----
-    **(Korean)** 추상 좌표에서 물리 좌표로 변환연산을 해주는 객체. 
-    """
-
-    @property
-    def width(self):
-        """int: The size of the region in which the coordinate system is defined.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 50])
-        >>> g1_x.width
-        180
-
-        .. image:: ../assets/img/object_grid_OneDimGrid_width.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 좌표계가 정의된 영역의 크기.
-        """
-        return abs(self.range[1] - self.range[0])
-
-    # Constructor
-    def __init__(self, name, scope, elements=np.array([0])):
-        """
-        Constructor function of OneDimGrid class.
-
-        Parameters
-        ----------
-        name : str
-        scope : numpy.ndarray
-            scope of one-dimensional coordinate system
-        elements: numpy.ndarray
-            members of one-dimensional coordinate system
-
-        Returns
-        -------
-        laygo2.OneDimGrid
-
-
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 50])
-        >>> print(g1_x)
-        OneDimGrid object name: xgrid, class: OneDimGrid, scope: [0, 180], elements: [0, 35, 85, 130  50]
-
-        .. image:: ../assets/img/object_grid_OneDimGrid_init.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** OneDimGrid 클래스의 생성자함수.
-        """
-        self.name = name
-        self.range = np.asarray(scope)
-        self.phy2abs = _PhyToAbsGridConverter(master=self)
-        self.abs2phy = _AbsToPhyGridConverter(master=self)
-        CircularMapping.__init__(self, elements=elements)
-        # self.elements = np.asarray(elements)  # commented out because asarray does not woke well with Object arrays.
-
-    # Indexing and slicing functions
-    def __getitem__(self, pos):
-        """Return the physical coordinate corresponding to the abstract coordinate pos."""
-        return self.abs2phy([pos])
-
-    # Comparison operators
-    def __eq__(self, other):
-        """Return the abstract grid coordinate that matches to other."""
-        return self.abs2phy.__eq__(other)
-
-    def __lt__(self, other):
-        """Return the abstract grid coordinate that is the largest but less than other."""
-        return self.abs2phy.__lt__(other)
-
-    def __le__(self, other):
-        """Return the index of the grid coordinate that is the largest but less than or equal to other."""
-        return self.abs2phy.__le__(other)
-
-    def __gt__(self, other):
-        """Return the abstract grid coordinate that is the smallest but greater than other."""
-        return self.abs2phy.__gt__(other)
-
-    def __ge__(self, other):
-        """Return the index of the grid coordinate that is the smallest but greater than or equal to other."""
-        return self.abs2phy.__ge__(other)
-
-    # Informative functions
-    def __str__(self):
-        """Return the string representation of the object."""
-        return self.summarize()
-
-    def summarize(self):
-        """Return the summary of the object information."""
-        return (
-            self.__repr__() + " "
-            "name: "
-            + self.name
-            + ", "
-            + "class: "
-            + self.__class__.__name__
-            + ", "
-            + "scope: "
-            + str(self.range)
-            + ", "
-            + "elements: "
-            + str(self.elements)
-        )
-
-    # I/O functions
-    def export_to_dict(self):
-        """
-        Return dict object containing grid information.
-
-        Parameters
-        ----------
-        None
-
-        Returns
-        -------
-        dict
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 50])
-        >>> g1_x.export_to_dict()
-        {'scope': [0, 180], 'elements': [0, 35, 85, 130, 50]}
-
-        .. image:: ../assets/img/object_grid_OneDimGrid_export_to_dict.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 그리드의 정보를 담은 dict객체 반환.
-        """
-        export_dict = {
-            "scope": self.range.tolist(),
-            "elements": self.elements.tolist(),
-        }
-        return export_dict
-
-    def flip(self):
-        """Flip the elements of the object."""
-        # self.elements = self.range[1]*np.ones(self.elements.shape) - np.flip(self.elements) + self.range[0]*np.ones(self.elements.shape)
-        self.elements = np.flip(self.elements) * (-1) + self.range[1] + self.range[0]
-
-    def copy(self):
-        """Copy the object."""
-        return OneDimGrid(self.name, self.range.copy(), elements=self.elements.copy())
-
-    def concatenate(self, obj):
-        objelem = obj.elements - obj.range[0] + self.range[1]
-        self.elements = np.concatenate((self.elements, objelem))
-        self.range[1] += obj.range[1] - obj.range[0]
-        # for e in elements:
-        #    self.elements = np.concatenate((self.elements, obj.elements))
-        # self.range[1] += obj.range[1] - obj.range[0]
-
-
-class Grid:
-    """
-    A base class having conversion operators and the mapping information (element)
-    between two-dimensional physical coordinates and abstract coordinates.
-
-    Examplar grid conversions between abstract and physical coordinates are
-    summarized in the following figure.
-
-    .. image:: ../assets/img/user_guide_grid_conversion.png
-
-
-    Notes
-    -----
-    **(Korean)** 2차원 물리좌표와 추상좌표간 mapping 정보(element) 를 갖고 있으며
-    해당 element를 활용하는 좌표 연산자를 가지고 있는 기본 클래스.
-    """
-
-    name = None
-    """str: the name of the grid."""
-
-    _xy = None
-    """List[OneDimGrid]: the list contains the 1d-grid objects for x and y axes."""
-
-    def _get_vgrid(self):
-        return self._xy[0]
-
-    def _set_vgrid(self, value):
-        self._xy[0] = value
-
-    vgrid = property(_get_vgrid, _set_vgrid)
-
-    def _get_hgrid(self):
-        return self._xy[1]
-
-    def _set_hgrid(self, value):
-        self._xy[1] = value
-
-    hgrid = property(_get_hgrid, _set_hgrid)
-
-    @property
-    def elements(self):
-        """numpy.ndarray: Two-dimensional element of a coordinate system.
-            x elements, y elements
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50])
-        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60])
-        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
-        >>> g2.elements
-        [ array([0, 10, 20, 40, 50]), array( [10, 20, 40, 50, 60] ) ]
-
-        .. image:: ../assets/img/object_grid_Grid_Elements.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** 좌표계 2차원 element.
-        """
-        return [self._xy[0].elements, self._xy[1].elements]
-
-    phy2abs = None
-    """PhyToAbsGridConverter(master=self)"""
-
-    abs2phy = None
-    """AbsToPhyGridConverter(master=self)"""
-
-    @property
-    def xy(self):
-        """_AbsToPhyGridConverter: Two-dimensional
-        _AbsToPhyConverter of a coordinate system.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50])
-        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60])
-        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
-        >>> g2.xy[10,10]
-        [200 210]
-        >>> g2.xy([10, 10])
-        [200 210]
-        >>> g2.xy < [10,10]
-        [0,-1]
-        >>> g2.xy <= [10,10]
-        [1,0]
-        >>> g2.xy > [10,10]
-        [2,1]
-        >>> g2.xy >= [10,10]
-        [1,0]
-
-        Notes
-        -----
-        **(Korean)** 2차원 _AbsToPhyConverter.
-        """
-        return self.abs2phy
-
-    @property
-    def x(self):
-        """_AbsToPhyGridConverter: One-dimensional _AbsToPhyGridConverter
-            of the x-coordinate system.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
-        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
-        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
-        >>> g2.x[10]
-        200
-        >>> g2.x <  10
-        [0]
-        >>> g2.x <= 10
-        [1]
-        >>> g2.x >  10
-        [2]
-        >>> g2.x >= 10
-        [1]
-
-        Notes
-        -----
-        **(Korean)**
-        x좌표계 1차원 _AbsToPhyGridConverter.
-        """
-        return self._xy[0].abs2phy
-
-    @property
-    def y(self):
-        """_AbsToPhyGridConverter: One-dimensional _AbsToPhyGridConverter
-        of the y-coordinate system.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
-        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
-        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
-        >>> g2.y[10]
-        210
-        >>> g2.y <  10
-        [-1]
-        >>> g2.y <= 10
-        [0]
-        >>> g2.y >  10
-        [1]
-        >>> g2.y >= 10
-        [0]
-
-        Notes
-        -----
-        **(Korean)** y좌표계 1차원 _AbsToPhyGridConverter.
-        """
-        return self._xy[1].abs2phy
-
-    @property
-    def v(self):
-        """OneDimGrid: OneDimGrid of the x-coordinate system (=self.x).
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
-        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
-        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
-        >>> g2.v
-        g1_x
-
-        Notes
-        -----
-        **(Korean)** x좌표계 OneDimGrid.
-        """
-        return self.x
-
-    @property
-    def h(self):
-        """OneDimGrid: OneDimGrid of the y-coordinate system (=self.y).
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
-        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
-        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
-        >>> g2.h
-        g1_y
-
-        Notes
-        -----
-        **(Korean)** y좌표계 OneDimGrid.
-        """
-        return self.y
-
-    @property
-    def mn(self):
-        """laygo2._PhyToAbsGridConverter: Two-dimensional _PhyToAbsConverter of
-        a coordinate system.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
-        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
-        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
-        >>> g2.mn[40,40]
-        [3, 2]
-        >>> g2.mn([40, 40])
-        [3, 2]
-        >>> g2.mn <  [40,40]
-        [750, 760]
-        >>> g2.mn <= [40,40]
-        [800, 810]
-        >>> g2.mn >  [40,40]
-        [810, 820]
-        >>> g2.mn >= [40,40]
-        [800, 810]
-
-        Notes
-        -----
-        **(Korean)**
-        좌표계 2차원 _PhyToAbsConverter.
-        """
-        return self.phy2abs
-
-    @property
-    def m(self):
-        """_PhyToAbsGridConverter: One-dimensional _PhyToAbsConverter of
-        the x-coordinate system.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
-        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
-        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
-        >>> g2.n[40]
-        2
-        >>> g2.n(40)
-        2
-        >>> g2.n <  40
-        760
-        >>> g2.n <= 40
-        810
-        >>> g2.n >  40
-        820
-        >>> g2.n >= 40
-        810
-
-        Notes
-        -----
-        **(Korean)** x좌표계 1차원 _PhyToAbsConverter.
-        """
-        return self._xy[0].phy2abs
-
-    @property
-    def n(self):
-        """_PhyToAbsGridConverter: One-dimensional _PhyToAbsConverter of
-         the y-coordinate system.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
-        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
-        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
-        >>> g2.n[40]
-        2
-        >>> g2.n(40)
-        2
-        >>> g2.n <  40
-        760
-        >>> g2.n <= 40
-        810
-        >>> g2.n >  40
-        820
-        >>> g2.n >= 40
-        810
-
-        Notes
-        -----
-        **(Korean)** y좌표계 1차원 _PhyToAbsConverter.
-        """
-        return self._xy[1].phy2abs
-
-    @property
-    def shape(self):
-        """numpy.ndarray: Two-dimensional element length in a coordinate system.
-            length of x-axis elements, length of y-axis elements
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
-        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
-        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
-        >>> g2.shape
-        [5, 5]
-
-        Notes
-        -----
-        **(Korean)** 좌표게 2차원 element의 길이.
-        """
-        return np.hstack([self._xy[0].shape, self._xy[1].shape])
-
-    def get_range(self):
-        return np.transpose(np.vstack((self._xy[0].range, self._xy[1].range)))
-
-    def set_range(self, value):
-        self._xy[0].range = np.transpose(value)[0]
-        self._xy[1].range = np.transpose(value)[1]
-
-    range = property(get_range, set_range)
-    """numpy.ndarray: Region in which the coordinate system is defined.
-        bbox of the respective Grid
-
-    Example
-    -------
-    >>> from laygo2.object.grid import OneDimGrid, Grid
-    >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ]) 
-    >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ]) 
-    >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
-    >>> g2.range 
-    [ [0, 0], [100, 100 ]]
-
-    Notes
-    -----
-    **(Korean)** 좌표계가 정의된 영역.
-    """
-
-    @property
-    def width(self):
-        """numpy.int32: Width of the region in which the coordinate system is defined.
-            x scope
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
-        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
-        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
-        >>> g2.width
-        100
-
-        Notes
-        -----
-        **(Korean)** 좌표계가 정의된 영역의 폭.
-        """
-        return self._xy[0].width
-
-    @property
-    def height(self):
-        """numpy.int32: Height of the region in which the coordinate system is defined.
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
-        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
-        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
-        >>> g2.height
-        100
-
-        Notes
-        -----
-        **(Korean)** 좌표계가 정의된 영역의 높이.
-        """
-        return self._xy[1].width
-
-    @property
-    def height_vec(self):
-        """numpy.ndarray: Return the height vector [0, h].
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
-        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
-        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
-        >>> g2.height_vec
-        [0, 100]
-
-        Notes
-        -----
-        **(Korean)** height를 list로 반환.
-        """
-        return np.array([0, self.height])
-
-    @property
-    def width_vec(self):
-        """numpy.ndarray: Return width as a list.
-            length of the respective axis and zero
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
-        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
-        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
-        >>> g2.width_vec
-        [100, 0]
-
-        Notes
-        -----
-        **(Korean)** width를 list로 반환.
-        """
-        return np.array([self.width, 0])
-
-    def __init__(self, name, vgrid, hgrid):
-        """
-        Constructor function of Grid class.
-
-        Parameters
-        ----------
-        name : str
-        vgrid : laygo2.object.grid.OndDimGrid
-            OneDimGrid object of the x-coordinate system
-        hgrid : laygo2.object.grid.OndDimGrid
-            OneDimGrid object of the y-coordinate system
-
-        Returns
-        -------
-        laygo2.object.grid.Grid
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
-        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
-        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
-        >>> print(g2)
-        <laygo2.object.grid.Grid object> name: test, class: Grid, scope: [[0, 0], [100, 100]], elements: [array([ 0, 10, 20, 40, 50]), array([10, 20, 40, 50, 60])
-
-        Notes
-        -----
-        **(Korean)** Grid 클래스의 생성자함수.
-        파라미터
-            - name(str): 이름
-            - vgrid(laygo2.OneDimGrid): x좌표계 OneDimGrid 객체
-            - hgrid(laygo2.OneDimGrid): y좌표계 OneDimGrid 객체
-        반환값
-            - laygo2.Grid
-        """
-        self.name = name
-        self._xy = [vgrid, hgrid]
-        self.phy2abs = _PhyToAbsGridConverter(master=self)
-        self.abs2phy = _AbsToPhyGridConverter(master=self)
-
-    @property
-    def elements(self):
-        """list: return elements of subgrids
-        ([_xy[0].elements, _xy[1].elements]).
-
-        """
-        return [self._xy[0].elements, self._xy[1].elements]
-
-    # Indexing and slicing functions
-    def __call__(self, other):
-        return self.mn(other)
-
-    def __getitem__(self, pos):
-        return self.abs2phy.__getitem__(pos)
-
-    # Comparison operators
-    def __eq__(self, other):
-        """Return the physical grid coordinate that matches to other."""
-        return self.abs2phy.__eq__(other)
-
-    def __lt__(self, other):
-        """Return the index of the grid coordinate that is the largest
-        but less than other.
-        """
-        return self.abs2phy.__lt__(other)
-
-    def __le__(self, other):
-        """Return the index of the grid coordinate that is the largest
-        but less than or equal to other.
-        """
-        return self.abs2phy.__le__(other)
-
-    def __gt__(self, other):
-        """Return the index of the grid coordinate that is the smallest
-        but greater than other.
-        """
-        return self.abs2phy.__gt__(other)
-
-    def __ge__(self, other):
-        """Return the index of the grid coordinate that is the smallest
-        but greater than or equal to other.
-        """
-        return self.abs2phy.__ge__(other)
-
-    def bbox(self, obj):
-        """
-        Return the abstract grid coordinates corresponding to the
-        'internal' bounding box of obj.
-
-        See Also
-        --------
-        _PhyToAbsGridConverter.bbox
-        """
-        return self.phy2abs.bbox(obj)
-
-    def bottom_left(self, obj):
-        """
-        Return the abstract grid coordinates corresponding to the
-        bottom-left corner of obj.
-
-        See Also
-        --------
-        _PhyToAbsGridConverter.bottom_left
-        """
-        return self.phy2abs.bottom_left(obj)
-
-    def bottom_right(self, obj):
-        """
-        Return the abstract grid coordinates corresponding to the
-        bottom-right corner of obj.
-
-        See Also
-        --------
-        _PhyToAbsGridConverter.bottom_right
-        """
-        return self.phy2abs.bottom_right(obj)
-
-    def top_left(self, obj):
-        """
-        Return the abstract grid coordinates corresponding to the top-left
-        corner of obj.
-
-        See Also
-        --------
-        _PhyToAbsGridConverter.top_left
-        """
-        return self.phy2abs.top_left(obj)
-
-    def top_right(self, obj):
-        """
-        Return the abstract grid coordinates corresponding to the top-right
-        corner of obj.
-
-        See Also
-        --------
-        _PhyToAbsGridConverter.top_right
-        """
-        return self.phy2abs.top_right(obj)
-
-    def crossing(self, *args):
-        """
-        Return the abstract grid coordinates corresponding to the crossing
-        point of args.
-
-        See Also
-        --------
-        laygo2.object.grid._PhyToAbsGridConverter.crossing
-        """
-        return self.phy2abs.crossing(*args)
-
-    def overlap(self, *args, type="bbox"):
-        """
-        Return the abstract grid coordinates corresponding to the overlap
-        of args.
-
-        See Also
-        --------
-        laygo2.object.grid._PhyToAbsGridConverter.overlap
-        """
-        return self.phy2abs.overlap(*args, type=type)
-
-    def union(self, *args):
-        """
-        Return the abstract grid coordinates corresponding to union of args.
-
-        See Also
-        --------
-        laygo2.object.grid._PhyToAbsGridConverter.union
-        """
-        return self.phy2abs.union(*args)
-
-    def center(self, obj):
-        """
-        Return the abstract grid coordinates corresponding to the center
-        point of obj.
-
-        Parameters
-        ----------
-        obj : laygo2.object.physical.PhysicalObject
-            The object of which center coordinate is computed.
-
-        See Also
-        --------
-        laygo2.object.grid._PhyToAbsGridConverter.center
-        """
-        return self.phy2abs.center(obj)
-    
-    def left(self, obj):
-        """
-        Return the abstract grid coordinates corresponding to the left
-        point of obj.
-        """
-        return self.phy2abs.left(obj)
-
-    def right(self, obj):
-        """
-        Return the abstract grid coordinates corresponding to the right
-        point of obj.
-        """
-        return self.phy2abs.right(obj)
-
-    def top(self, obj):
-        """
-        Return the abstract grid coordinates corresponding to the top
-        point of obj.
-        """
-        return self.phy2abs.top(obj)
-
-    def bottom(self, obj):
-        """
-        Return the abstract grid coordinates corresponding to the bottom
-        point of obj.
-        """
-        return self.phy2abs.bottom(obj)
-
-    def copy(self):
-        """
-        Make a copy of the current Grid object
-
-        Returns
-        -------
-        laygo2.object.grid.Grid : the copied Grid object.
-        
-        See Also
-        --------
-        laygo2.object.grid.copy
-        """
-        name = self.name
-        vgrid = self.vgrid.copy()
-        hgrid = self.hgrid.copy()
-
-        g = Grid(
-            name=name,
-            vgrid=vgrid,
-            hgrid=hgrid,
-        )
-        return g
-
-    def vflip(self, copy=True):
-        """Flip the grid in vertical direction.
-
-        Parameters
-        ----------
-        copy: optional, boolean
-            If True, make a copy and flip the copied grid (default).
-            If False, flip the current grid object.
-
-        Returns
-        --------
-        laygo2.object.grid.Grid : the flipped Grid object.
-
-        See Also
-        --------
-        laygo2.object.grid.vflip
-        """
-        if copy:
-            g = self.copy()
-        else:
-            g = self
-        g.hgrid.flip()  # Flip vertically means filpping the horizontal grid.
-        return g
-
-    def hflip(self, copy=True):
-        """Flip the grid in horizontal direction.
-
-        Parameters
-        ----------
-        copy: optional, boolean
-            If True, make a copy and flip the copied grid (default).
-            If False, flip the current grid object.
-
-        Returns
-        --------
-        laygo2.object.grid.Grid : the flipped Grid object.
-
-        See Also
-        --------
-        laygo2.object.grid.hflip
-        """
-        if copy:
-            g = self.copy()
-        else:
-            g = self
-        g.vgrid.flip()
-        return g
-
-    def vstack(self, obj, copy=True):
-        """Stack grid(s) on top of the current grid in vertical direction.
-        """
-        if copy:
-            g = self.copy()
-        else:
-            g = self
-        if isinstance(obj, list):  # multiple stack
-            obj_list = obj
-        else:  # single stack
-            obj_list = [obj]
-        # compute the grid range first
-        grid_ofst = g.hgrid.width
-        for _obj in obj_list:
-            g.hgrid.range[1] += _obj.hgrid.width
-        # stack
-        for _obj in obj_list:
-            for i, h in enumerate(_obj.hgrid):
-                # Check if the new grid element exist in the current grid already.
-                val = (h - _obj.hgrid.range[0]) + grid_ofst
-                val = val % (g.hgrid.width)  # modulo
-                if not (val in g.hgrid):
-                    # Unique element
-                    g.hgrid.append(val + g.hgrid.range[0])
-            grid_ofst += _obj.hgrid.width  # increse offset
-        return g
-
-    def hstack(self, obj, copy=True):
-        """Stack grid(s) on top of the current grid in horizontal direction."""
-        if copy:
-            g = self.copy()
-        else:
-            g = self
-        if isinstance(obj, list):  # Multiple stack.
-            for o in obj:
-                g = g.hstack(o, copy=copy)
-            return g
-        for i, v in enumerate(obj.vgrid):
-            # Check if the new grid element exist in the current grid already.
-            val = (v - obj.vgrid.range[0]) + g.vgrid.width  
-            val = val % (g.vgrid.width + obj.vgrid.width)  # modulo
-            if not (val in g.vgrid):
-                # Unique element
-                g.vgrid.append(v + g.vgrid.range[1])
-        g.vgrid.range[1] += obj.vgrid.width
-        return g
-
-    # Iterators
-    def __iter__(self):
-        # TODO: fix this to iterate over the full coordinates
-        return np.array([self._xy[0].__iter__(), self._xy[1].__iter__()])
-
-    def __next__(self):
-        # TODO: fix this to iterate over the full coordinates
-        return np.array([self._xy[0].__next__(), self._xy[1].__next__()])
-
-    # Informative functions
-    def __str__(self):
-        """Return the string representation of the object."""
-        return self.summarize()
-
-    def summarize(self):
-        """
-        Output the information of the respective grid.
-
-        Parameters
-        ----------
-        None
-
-        Returns
-        -------
-        str
-
-        Example
-        -------
-        >>> from laygo2.object.grid import OneDimGrid, Grid
-        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
-        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
-        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
-        >>> g2.summarize()
-        <laygo2.object.grid.Grid object> name: test, class: Grid, scope: [[0, 0], [100, 100]], elements: [array([ 0, 10, 20, 40, 50]), array([10, 20, 40, 50, 60])
-
-        Notes
-        -----
-        **(Korean)** 해당 Grid의 정보 출력.
-        """
-        return (
-            self.__repr__()
-            + " \n"
-            + " name: "
-            + self.name
-            + ", \n"
-            + " class: "
-            + self.__class__.__name__
-            + ", \n"
-            + " scope: "
-            + str(self.range.tolist())
-            + ", \n"
-            + " elements: "
-            + str(self.elements)
-            + ", \n"
-        )
-
-
-'''
-class ParameterizedGrid(Grid):
-    """A parameterized grid to support flexible templates."""
-
-    # TODO: implement this.
-    pass
-
-
-class ParameterizedPlacementGrid(Grid):
-    # TODO: implement this.
-    pass
-
-
-class ParameterizedRoutingGrid(Grid):
-    # TODO: implement this.
-    pass
-'''
+#!/usr/bin/python
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+__author__ = "Jaeduk Han"
+__maintainer__ = "Jaeduk Han"
+__status__ = "Prototype"
+
+import numpy as np
+import laygo2.object
+
+# import laygo2.util.conversion as cv
+
+
+# Internal functions.
+def _extend_index_dim(input_index, new_index, new_index_max):
+    """
+    A helper function to be used for the multi-dimensional circular array
+    indexing of CircularMappingArray. It extends the dimension of the input
+    array (input_index) that contains indexing information, with the
+    additional indexing variable (new_index) provided. The new_index_max
+    variable is specified in case of the new_index does not contain the
+    maximum index information (perhaps when an open-end slice is given for
+    the new_index).
+
+    Parameters
+    ----------
+    input_index : iterable
+        The iterable object to be extended.
+    new_index : iterable
+        The iterable object to be added to input_ind to extend its dimension.
+    new_index_max : iterable
+        The maximum index of new_index when its upper boundary is not
+        provided.
+
+    Returns
+    -------
+    Iterable: The extended index.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> # 0-dim to 1-dim
+    >>> laygo2.object.grid._extend_index_dim(None, [3, 4, 6], None)
+    [(3,), (4,), (6,)]
+    >>> # 0-dim to 1-dim (with slicing input)
+    >>> laygo2.object.grid._extend_index_dim(None, slice(3, 8, 2), None)
+    [(3,), (5,), (7,)]
+    >>> # 0-dim to 1-dim, with maximum index given
+    >>> laygo2.object.grid._extend_index_dim(None, slice(3, None, 2), 8)
+    [(3,), (4,), (6,)]
+    >>> # 1-dim to 2-dim
+    >>> laygo2.object.grid._extend_index_dim([(3,), (4,), (6,)], [1, 2], None)
+    [[(3, 1), (3, 2)], [(4, 1), (4, 2)], [(6, 1), (6, 2)]]
+    """
+    # Construct an iterator from new_index
+    if isinstance(new_index, (int, np.integer)):
+        it = [new_index]
+    else:
+        if isinstance(new_index, slice):
+            # slices don't work very well with multi-dimensional circular mappings.
+            it = _conv_slice_to_list(slice_obj=new_index, stop_def=new_index_max)
+        else:
+            it = new_index
+    # Index extension
+    if input_index is None:
+        output = []
+        for i in it:
+            output.append(tuple([i]))
+        return output
+    else:
+        output = []
+        for _i in input_index:
+            output_row = []
+            for i in it:
+                output_row.append(tuple(list(_i) + [i]))
+            output.append(output_row)
+        return output
+
+
+def _conv_slice_to_list(slice_obj, start_def=0, stop_def=100, step_def=1):
+    """Convert slice to a list.
+
+    Parameters
+    ----------
+    slice_obj : slice
+        The slice object to be converted.
+    start_def : int, optional
+        The default starting index if the slice object has no lower boundary.
+    stop_def : int, optional
+        The default stopping index if the slice object has no upper boundary.
+    step_def : int, optional
+        The default stepping index if the slice object has no step specified.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> laygo2.object.grid._conv_slice_to_list(slice(0, 10, 2))
+    [0, 2, 4, 6, 8]
+    """
+    if slice_obj.start is None:
+        start = start_def
+    else:
+        start = slice_obj.start
+    if slice_obj.stop is None:
+        stop = stop_def
+    else:
+        stop = slice_obj.stop
+    if slice_obj.step is None:
+        step = step_def
+    else:
+        step = slice_obj.step
+    return list(range(start, stop, step))
+
+
+def _conv_bbox_to_array(bbox):
+    """
+    Convert a bbox object to a 2-d array.
+
+    Parameters
+    ----------
+    bbox : numpy.ndarray
+        The bounding box to be converted.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> import numpy as np
+    >>> laygo2.object.grid._conv_bbox_to_array(np.array([[0, 0], [1, 2]]))
+    array([[[0, 0], [1, 0]],
+           [[0, 1], [1, 1]],
+           [[0, 2], [1, 2]]])
+    """
+    array = list()
+    for r in range(bbox[0, 1], bbox[1, 1] + 1):
+        row = list()
+        for c in range(bbox[0, 0], bbox[1, 0] + 1):
+            row.append([c, r])
+        array.append(row)
+    return np.array(array)
+
+
+def _conv_bbox_to_list(bbox):
+    """
+    Convert a bbox object to a 1-d list.
+
+    Parameters
+    ----------
+    bbox : numpy.ndarray
+        The bounding box to be converted.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> import numpy as np
+    >>> laygo2.object.grid._conv_bbox_to_list(np.array([[0, 0], [1, 2]]))
+    [[0, 0], [1, 0], [0, 1], [1, 1], [0, 2], [1, 2]]
+    """
+    array = list()
+    for r in range(bbox[0, 1], bbox[1, 1] + 1):
+        for c in range(bbox[0, 0], bbox[1, 0] + 1):
+            array.append([c, r])
+    return array
+
+
+# External functions
+def copy(obj):
+    """Make a copy of the input grid object.
+
+    Parameters
+    ----------
+    obj : laygo2.object.grid.Grid
+        The input grid object to be copied.
+
+    Returns
+    -------
+    laygo2.object.grid.Grid or derived: the copied grid object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.grid import OneDimGrid, Grid
+    >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
+    >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
+    >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
+    >>> g2_copy = laygo2.object.grid.copy(g2)
+    >>> print(g2)
+    <laygo2.object.grid.core.Grid object at 0x000002002EBA67A0>
+     name: test,
+    class: Grid,
+    scope: [[0, 0], [100, 100]],
+    elements: [array([ 0, 10, 20, 40, 50]), array([10, 20, 40, 50, 60])],
+    >>> print(g2_copy)
+    <laygo2.object.grid.core.Grid object at 0x0000020040C35240>
+     name: test,
+     class: Grid,
+     scope: [[0, 0], [100, 100]],
+     elements: [array([ 0, 10, 20, 40, 50]), array([10, 20, 40, 50, 60])],
+    """
+    return obj.copy()
+
+
+def vflip(obj):
+    """Make a vertically-flipped copy of the input grid object.
+    
+    Parameters
+    ----------
+    obj : laygo2.object.grid.Grid
+        The input grid object to be copied and flipped.
+
+    Returns
+    -------
+    laygo2.object.grid.Grid or derived: the generated grid object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.grid import OneDimGrid, Grid
+    >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
+    >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
+    >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
+    >>> g2_copy = laygo2.object.grid.vflip(g2)
+    >>> print(g2)
+    <laygo2.object.grid.core.Grid object at 0x000001EE82660BE0>
+     name: test,
+     class: Grid,
+     scope: [[0, 0], [100, 100]],
+     elements: [array([ 0, 10, 20, 40, 50]), array([10, 20, 40, 50, 60])],
+    >>> print(g2_copy)
+    <laygo2.object.grid.core.Grid object at 0x000001EE947152D0>
+     name: test,
+     class: Grid,
+     scope: [[0, 0], [100, 100]],
+     elements: [array([ 0, 10, 20, 40, 50]), array([40, 50, 60, 80, 90])],
+    """
+    return obj.vflip(copy=True)
+
+
+def hflip(obj):
+    """Make a horizontally-flipped copy of the input grid object.
+    
+    Parameters
+    ----------
+    obj : laygo2.object.grid.Grid
+        The input grid object to be copied and flipped.
+
+    Returns
+    -------
+    laygo2.object.grid.Grid: the generated grid object.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.grid import OneDimGrid, Grid
+    >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
+    >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
+    >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
+    >>> g2_copy = laygo2.object.grid.hflip(g2)
+    >>> print(g2)
+    <laygo2.object.grid.core.Grid object at 0x000001ACECC30BE0>
+     name: test,
+     class: Grid,
+     scope: [[0, 0], [100, 100]],
+     elements: [array([ 0, 10, 20, 40, 50]), array([10, 20, 40, 50, 60])],
+    >>> print(g2_copy)
+    <laygo2.object.grid.core.Grid object at 0x000001ACFED15300>
+     name: test,
+     class: Grid,
+     scope: [[0, 0], [100, 100]],
+     elements: [array([ 50,  60,  80,  90, 100]), array([10, 20, 40, 50, 60])],
+    """
+    return obj.hflip(copy=True)
+
+
+def vstack(obj):
+    """Stack grid(s) in vertical direction.
+    
+    Parameters
+    ----------
+    obj : list of laygo2.object.grid.Grid
+        The list containing grid objects to be stacked.
+    
+    Returns
+    -------
+    laygo2.object.grid.Grid: the generated grid object.
+    
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.grid import OneDimGrid, Grid
+    >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
+    >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
+    >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
+    >>> g2_copy = laygo2.object.grid.copy(g2)
+    >>> g2_stack = laygo2.object.grid.vstack([g2, g2_copy])
+    >>> print(g2)
+    <laygo2.object.grid.core.Grid object at 0x000001799FAA0BE0>
+     name: test,
+     class: Grid,
+     scope: [[0, 0], [100, 100]],
+     elements: [array([ 0, 10, 20, 40, 50]), array([10, 20, 40, 50, 60])],
+    >>> print(g2_stack)
+    <laygo2.object.grid.core.Grid object at 0x00000179B1B05870>
+     name: test,
+     class: Grid,
+     scope: [[0, 0], [100, 200]],
+     elements: [array([ 0, 10, 20, 40, 50]), array([ 10,  20,  40,  50,  60, 110, 120, 140, 150, 160])],
+    """
+    return obj[0].vstack(obj[1:], copy=True)
+
+
+def hstack(obj):
+    """Stack grid(s) in horizontal direction.
+
+    Parameters
+    ----------
+    obj : list of laygo2.object.grid.Grid
+        The list containing grid objects to be stacked.
+    
+    Returns
+    -------
+    laygo2.object.grid.Grid: the generated grid object.
+    
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.grid import OneDimGrid, Grid
+    >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
+    >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
+    >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
+    >>> g2_copy = laygo2.object.grid.copy(g2)
+    >>> g2_stack = laygo2.object.grid.hstack([g2, g2_copy])
+    >>> print(g2)
+    <laygo2.object.grid.core.Grid object at 0x000001799FAA0BE0>
+     name: test,
+     class: Grid,
+     scope: [[0, 0], [100, 100]],
+     elements: [array([ 0, 10, 20, 40, 50]), array([10, 20, 40, 50, 60])],
+    >>> print(g2_stack)
+    <laygo2.object.grid.core.Grid object at 0x0000015BD8C85570>
+     name: test,
+     class: Grid,
+     scope: [[0, 0], [200, 100]],
+     elements: [array([  0,  10,  20,  40,  50, 100, 110, 120, 140, 150]), array([10, 20, 40, 50, 60])],
+    """
+
+    return obj[0].hstack(obj[1:], copy=True)
+
+
+# Internal classes
+class CircularMapping:
+    """
+    Basic circular mapping class (index number expands infinitely).
+
+    Example
+    -------
+    >>> from laygo2.object.grid import Circularmapping
+    >>> map = CircularMapping(elements=[100, 200, 300])
+    >>> print(map[0])
+    100
+    >>> print(map[2])
+    300
+    >>> print(map[4])
+    200
+    >>> print(map[-3])
+    100
+    >>> print(map[[2, 3, -2])
+    [300, 100, 200]
+    >>> print(map[2:7])
+    [300, 100, 200, 300, 100]
+
+    Notes
+    -----
+    **(Korean)** 기본 순환 맵핑 (인덱싱 넘버가 무한히 확장) 클래스.
+    """
+
+    _elements = None
+    """list: Array consisting of the elements of circular mapping.
+
+    Example
+    -------
+    >>> from laygo2.object.grid import CircularMapping
+    >>> elements = [0, 35, 85, 130, 180] 
+    >>> cm = CircularMapping(elements) 
+    >>> cm.elements
+    [0, 35, 85, 130, 180]
+
+    .. image:: ../assets/img/object_grid_CircularMapping_elements.png
+           :height: 250 
+
+    Notes
+    -----
+    **(Korean)**
+    순환 맵핑의 구성 요소로 이루어진 배열. 
+    """
+
+    dtype = int
+    """type: Data type of the circular mapping.
+
+    Example
+    -------
+    >>> from laygo2.object.grid import CircularMapping
+    >>> elements = [0, 35, 85, 130, 180] 
+    >>> cm = CircularMapping(elements) 
+    >>> cm.dtype
+    int
+
+    .. image:: ../assets/img/object_grid_CircularMapping_dtype.png
+           :height: 250
+
+    Notes
+    -----
+    **(Korean)**
+    순환 맵핑의 데이터 유형.
+    """
+
+    def get_elements(self):
+        """numpy.ndarray: getter of elements."""
+        return self._elements
+
+    def set_elements(self, value):
+        """numpy.ndarray: setter of elements."""
+        self._elements = np.asarray(value, dtype=self.dtype)
+
+    elements = property(get_elements, set_elements)
+    """numpy.ndarray: the array that contains the physical coordinates of the grid."""
+
+    @property
+    def shape(self):
+        """numpy.ndarray: The shape of circular mapping.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import CircularMapping
+        >>> elements = [0, 35, 85, 130, 180]
+        >>> cm = CircularMapping(elements)
+        >>> cm.shape
+        array([5])
+
+        .. image:: ../assets/img/object_grid_CircularMapping_shape.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)**
+        순환 맵핑의 shape.
+        """
+        return np.array(self.elements.shape)
+
+    def __init__(self, elements=np.array([0]), dtype=int):
+        """
+        Constructor function of CircularMapping class.
+
+        Parameters
+        ----------
+        elements : list
+            elements.
+        dtype : type
+            data type of elements.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import CircularMapping
+        >>> elements = [0, 35, 85, 130, 180]
+        >>> cm = CircularMapping(elements)
+        >>> cm.shape
+        [5]
+        >>> cm[5]
+        35
+        >>> cm[0:10]
+        [0, 35, 85, 130, 0, 35, 85, 130, 0, 35]
+
+        .. image:: ../assets/img/object_grid_CircularMapping_init.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** CircularMapping 클래스의 생성자함수
+            파라미터
+            - elements(list): 구성 요소
+            - dtype(type): 구성 요소의 datatype
+        """
+        self.dtype = dtype
+        self.elements = np.asarray(elements, dtype=dtype)
+
+    # indexing and slicing
+    def __getitem__(self, pos):
+        """Element access function of circular mapping."""
+        if isinstance(pos, (int, np.integer)):
+            return self.elements[pos % self.shape[0]]
+        elif isinstance(pos, slice):
+            return self.__getitem__(
+                pos=_conv_slice_to_list(slice_obj=pos, stop_def=self.shape[0])
+            )
+        elif isinstance(pos, np.ndarray):
+            return np.array([self.__getitem__(pos=p) for p in pos])
+        elif isinstance(pos, list):
+            return [self.__getitem__(pos=p) for p in pos]
+        elif pos is None:
+            return None
+        else:
+            raise TypeError("CircularMapping received an invalid index:%s" % str(pos))
+
+    # Iterators
+    def __iter__(self):
+        """Iteration function of circular mapping."""
+        return self.elements.__iter__()
+
+    def __next__(self):
+        """Next element access function of circular mapping."""
+        # Check if numpy.ndarray implements __next__()
+        return self.elements.__next__()
+
+    # Informative functions
+    def __str__(self):
+        return self.summarize()
+
+    def summarize(self):
+        """Return the summary of the object information."""
+        return (
+            self.__repr__() + " "
+            "class: "
+            + self.__class__.__name__
+            + ", "
+            + "elements: "
+            + str(self.elements)
+        )
+
+    # Regular member functions
+    def append(self, elem):
+        """Append elements to the mapping."""
+        if not isinstance(elem, list):
+            elem = [elem]
+        self.elements = np.array(self.elements.tolist() + elem)
+
+    def flip(self):
+        """Flip the elements of the object."""
+        self.elements = np.flip(self.elements, axis=0)
+
+    def copy(self):
+        """Copy the object."""
+        return CircularMapping(self.elements.copy(), dtype=self.dtype)
+
+    def concatenate(self, obj):
+        self.elements = np.concatenate((self.elements, obj.elements))
+        # for e in elements:
+        #    self.elements = np.concatenate((self.elements, obj.elements))
+        # self.range[1] += obj.range[1] - obj.range[0]
+
+
+class CircularMappingArray(CircularMapping):
+    """
+    Multi-dimensional circular mapping class (index number expands infinitely).
+
+    Notes
+    -----
+    **(Korean)** 다차원 순환맵핑(인덱싱 넘버가 무한히 확장) 클래스.
+    """
+
+    def __getitem__(self, pos):
+        """
+        Element access function.
+
+        Parameters
+        ----------
+        pos : int
+            index number being accessed.
+
+        Returns
+        -------
+        numpy.ndarray
+
+        Example
+        -------
+        >>> from laygo2.object.grid import CircularMappingArray
+        >>> elements = [[0, 0], [35, 0], [85, 0], [130, 0]]
+        >>> cm = CircularMappingArray(elements = elements)
+        >>> cm[1, :]
+        array([[35, 0]])
+        >>> cm[3, 0]
+        130
+
+        .. image:: ../assets/img/object_grid_CircularMappingArray_getitem.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 순환 맵핑의 요소 접근함수
+        """
+        if isinstance(pos, list):  # pos is containing multiple indices as a list
+            return [self.__getitem__(pos=p) for p in pos]
+        elif pos is None:
+            return None
+        elif np.all(np.array([isinstance(p, (int, np.integer)) for p in pos])):
+            # pos is mapped to a single element (pos is composed of integer indices).
+            # just do rounding.
+            idx = []
+            for p, s in zip(pos, self.shape):
+                idx.append(p % s)
+            return self.elements[tuple(idx)]
+        else:
+            # pos is mapped to multiple indices. (possible Example include ([0:5, 3], [[1,2,3], 3], ...).
+            # Create a list containing the indices to iterate over, and return a numpy.ndarray containing items
+            # corresponding to the indices in the list.
+            # When the indices don't specify the lower boundary (e.g., [:5]), it iterates from 0.
+            # When the indices don't specify the upper boundary (e.g., [3:]), it iterates to the maximum index defined.
+            idx = None
+            for i, p in enumerate(pos):  # iterate over input indices (x and y).
+                idx = _extend_index_dim(idx, p, self.shape[i])
+            idx = np.asarray(idx)
+            # iterate and generate the list to return
+            item = np.empty(
+                idx.shape[:-1], dtype=self.dtype
+            )  # -1 because the tuples in idx are flatten.
+            for i, _null in np.ndenumerate(item):
+                item[i] = self.__getitem__(pos=tuple(idx[i]))
+            return np.asarray(item)
+
+    # Regular member functions
+    def flip(self, axis):
+        """Flip the elements of the object."""
+        self.elements = np.flip(self.elements, axis=axis)
+
+    def copy(self):
+        """Copy the object."""
+        return CircularMappingArray(self.elements.copy(), dtype=self.dtype)
+
+
+class _AbsToPhyGridConverter:
+    """
+    An internal class that converts abstract coordinates into physical
+    coordinates. Conversely, conditional operators convert physical
+    coordinates into abstract coordinates.
+
+    .. image:: ../assets/img/user_guide_abs2phy.png
+
+    Notes
+    -----
+    **(Korean)** 추상 좌표를 물리 좌표로 변환하는 클래스, 조건부연산은 역변환을
+    수행한다.
+    """
+
+    master = None
+    """laygo2.Grid or laygo2.OneDimGrid: Coordinate system to which 
+    _AbsToPhyGridConverter object belongs.
+
+    Example
+    -------
+    >>> from laygo2.object.grid import OneDimGrid, Grid
+    >>> g1_x = OneDimGrid(name='xg', scope=[0, 180], elements=[0, 35, 85, 130, 180]) 
+    >>> g1_y = OneDimGrid(name='yg', scope=[0, 30], elements=[0]) 
+    >>> g2   = Grid(name='g', vgrid=g1_x, hgrid=g1_y) 
+    >>> print(g1_x.abs2phy) 
+    <laygo2.object.grid._AbsToPhyGridConverter object> 
+    >>> print(g2.xy) 
+    <laygo2.object.grid._AbsToPhyGridConverter object>
+    >>> print(g1_x.abs2phy.master) 
+    <laygo2.object.grid.OneDimGrid object>
+    >>> print(g2.xy.master) 
+    <laygo2.object.grid.Grid object>
+
+    Notes
+    -----
+    **(Korean)** _AbsToPhyGridConverter 객체가 속한 좌표계.
+    """
+
+    # Constructor
+    def __init__(self, master):
+        """Constructor function of _AbsToPhyGridConverter class."""
+        self.master = master
+
+    # Access functions.
+    def __call__(self, pos):
+        """
+        Convert abstract coordinates of the master grid into corresponding
+        physical coordinates.
+
+        Parameters
+        ----------
+        pos : int
+            abstract coordinates.
+
+        Returns
+        -------
+        int or numpy.ndarray
+            physical coordinates.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xg', scope=[0, 180], elements=[0, 35, 85, 130, 180])
+        >>> g1_y = OneDimGrid(name='yg', scope=[0,30], elements=[0])
+        >>> g2   = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
+        >>> g1_x.abs2phy(0)
+        0
+        >>> g2.xy(0,0)
+        [0, 0]
+
+        .. image:: ../assets/img/object_grid_AbsToPhyGridConverter_call.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 추상 좌표를 master 좌표계에서 대응되는 물리 좌표로 변환.
+        """
+        return self.__getitem__(pos)
+
+    def __getitem__(self, pos):
+        """
+        Convert abstract coordinates of the master grid into corresponding
+        physical coordinates.
+
+        Parameters
+        ----------
+        pos : int
+            abstract coordinates.
+
+        Returns
+        -------
+        int or numpy.ndarray
+            physical coordinates.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xg', scope=[0, 180], elements=[0, 35, 85, 130, 180])
+        >>> g1_y = OneDimGrid(name='yg', scope=[0, 30], elements=[0])
+        >>> g2   = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
+        >>> g1_x.abs2phy(0)
+        0
+        >>> g2.xy(0,0)
+        [0, 0]
+
+        .. image:: ../assets/img/object_grid_AbsToPhyGridConverter_getitem.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 추상 좌표를 master 좌표계에서 대응되는 물리 좌표로 변환.
+        """
+        if (self.master.__class__.__name__ == "OneDimGrid") or (
+            issubclass(self.master.__class__, OneDimGrid)
+        ):
+            return self._getitem_1d(pos)
+        if (self.master.__class__.__name__ == "Grid") or (
+            issubclass(self.master.__class__, Grid)
+        ):
+            return self._getitem_2d(pos)
+        else:
+            return None
+
+    def _getitem_1d(self, pos):
+        """An internal function of __getitem__() for 1-d grids."""
+        # Check if pos has multiple elements.
+        if isinstance(pos, slice):
+            return self._getitem_1d(
+                _conv_slice_to_list(slice_obj=pos, stop_def=self.master.shape[0])
+            )
+        elif isinstance(pos, np.ndarray):
+            return self._getitem_1d(pos.tolist())
+        elif isinstance(pos, list):
+            return np.array([self._getitem_1d(p) for p in pos])
+        elif pos is None:
+            raise TypeError(
+                "_AbsToPhyConverter._getitem_1d does not accept None as its input."
+            )
+        else:
+            # pos is a single element. Compute quotient and modulo for grid extension.
+            quo = 0
+            mod = int(round(pos))
+            if pos >= self.master.shape[0]:
+                mod = int(round(pos % self.master.shape[0]))
+                quo = int(round((pos - mod) / self.master.shape[0]))
+            elif pos < 0:
+                mod = int(round(pos % self.master.shape[0]))
+                quo = int(round((pos - mod)) / self.master.shape[0])
+            return quo * self.master.range[1] + self.master.elements[mod]
+            # the following command cannot handle the size extension of the grid, disabled.
+            # return self.master.elements.take(pos, mode='wrap')
+
+    def _getitem_2d(self, pos):
+        """An internal function of __getitem__() for 2-d grids."""
+        if isinstance(pos, list):
+            if isinstance(pos[0], (int, np.integer)):  # single point
+                return self[pos[0], pos[1]]
+            else:
+                return [self[p] for p in pos]
+        elif isinstance(pos, np.ndarray):
+            if isinstance(pos[0], (int, np.integer)):  # single point
+                return np.array(self[pos[0], pos[1]])
+            else:
+                return np.array([self[p] for p in pos])
+        # compute coordinates from OneDimGrids of its master.
+        x = self.master.x[pos[0]]
+        y = self.master.y[pos[1]]
+        # TODO: Refactor the following code to avoid the use of double for loops and list comprehensions.
+        if (not isinstance(x, np.ndarray)) and (
+            not isinstance(y, np.ndarray)
+        ):  # x and y are scalars.
+            return np.array([x, y])
+        if not isinstance(x, np.ndarray):  # x is a scalar.
+            return np.array([np.array([x, _y]) for _y in y])
+        elif not isinstance(y, np.ndarray):  # y is a scalar.
+            return np.array([np.array([_x, y]) for _x in x])
+        else:
+            xy = []
+            for _x in x:  # vectorize this operation.
+                row = []
+                for _y in y:
+                    row.append(np.array([_x, _y]))
+                xy.append(np.array(row))
+        return np.array(xy)
+
+    # Reverse-access operators (comparison operators are used for reverse-access).
+    def __eq__(self, other):
+        """
+        Convert physical coordinates into abstract coordinates of the master grid
+        satisfying conditional operations.
+
+        Parameters
+        ----------
+        other : int
+            physical coordinates.
+
+        Returns
+        -------
+        int or numpy.ndarray
+            abstract coordinates.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xg', scope=[0, 180], elements=[0, 35, 85, 130, 180])
+        >>> g1_y = OneDimGrid(name='yg', scope=[0, 30], elements=[0])
+        >>> g2   = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
+        >>> g1_x.abs2phy == 35
+        1
+        >>> g2.xy == [35, 35]
+        [1, None]
+
+        .. image:: ../assets/img/object_grid_AbsToPhyGridConverter_eq.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 물리 좌표를 master 좌표계에서 조건부 연산을 만족하는 추상 좌표로 변환.
+        """
+        return self.master.phy2abs(pos=other)
+
+    def __lt__(self, other):
+        """
+        Convert physical coordinates into abstract coordinates of the master grid
+        satisfying conditional operations.
+
+        Parameters
+        ----------
+        other : int
+            physical coordinates.
+
+        Returns
+        -------
+        int or numpy.ndarray
+            abstract coordinates.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xg', scope=[0, 180], elements=[0, 35, 85, 130, 180])
+        >>> g1_y = OneDimGrid(name='yg', scope=[0, 30], elements=[0])
+        >>> g2   = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
+        >>> g1_x.abs2phy < 35
+        0
+        >>> g2.xy < [35, 35]
+        [0, 1]
+
+        .. image:: ../assets/img/object_grid_AbsToPhyGridConverter_lt.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 물리 좌표를 master 좌표계에서 조건부 연산을 만족하는 추상 좌표로 변환.
+        """
+        if (self.master.__class__.__name__ == "OneDimGrid") or (
+            issubclass(self.master.__class__, OneDimGrid)
+        ):
+            return self._lt_1d(other)
+        if (self.master.__class__.__name__ == "Grid") or (
+            issubclass(self.master.__class__, Grid)
+        ):
+            return self._lt_2d(other)
+        else:
+            return None
+
+    @staticmethod
+    def _phy2abs_operator(other, elements, width, shape, op):
+        def phy2abs(x):
+            if x > 0:
+                quo_coarce = 0 + x // width
+                msb_sub = 1
+            else:
+                quo_coarce = 0 + x // width
+                msb_sub = 0
+
+            remain = x % width  # positive
+            msb = quo_coarce * shape - 1
+            for i, e in np.ndenumerate(elements):
+                # print("e: %d r:%d, m:%d, i:%d off:%d phy:%d " %(e, remain, msb + i[0], i[0], lsb_offset, quo_coarce*width + e   ))
+                # print(comp( e , remain ))
+
+                if comp(e, remain) == True:  # find maximum less then remain , e < r
+                    pass
+                else:  # when it is False, latest true index
+                    return msb + i[0] + lsb_offset
+
+            return msb + shape + lsb_offset
+
+        if op == "<":  ## max lesser
+            comp = lambda e, r: e < r
+            lsb_offset = 0
+
+        elif op == "<=":  ## eq or max lesser eq
+            comp = lambda e, r: e <= r
+            lsb_offset = 0
+
+        elif op == ">":  ## min greater
+            comp = lambda e, r: e <= r
+            lsb_offset = 1
+
+        elif op == ">=":  ## eq or min greater
+            comp = lambda e, r: e < r
+            lsb_offset = 1
+
+        if isinstance(other, (int, np.integer)):
+            return phy2abs(other)
+        else:
+            list_return = []
+            for o in other:
+                list_return.append(phy2abs(o))
+            return np.array(list_return)
+
+    def _lt_1d(self, other):
+        return self._phy2abs_operator(
+            other,
+            self.master.elements,
+            self.master.width,
+            self.master.elements.shape[0],
+            "<",
+        )
+
+    def _lt_2d(self, other):
+        if isinstance(other[0], (int, np.integer)):
+            return np.array([self.master.x < other[0], self.master.y < other[1]])
+        else:
+            return np.array([self._lt_2d(o) for o in other])
+
+    def __le__(self, other):
+        """
+        Convert physical coordinates into abstract coordinates of the master grid
+        satisfying conditional operations.
+
+        Parameters
+        ----------
+        other : int
+            physical coordinates.
+
+        Returns
+        -------
+        int or numpy.ndarray
+            abstract coordinates.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 180])
+        >>> g1_y = OneDimGrid(name='ygrid', scope=[0,30], elements=[0])
+        >>> g2   = Grid(name='test', vgrid=g1_x, hgrid=g1_y)
+        >>> g1_x.abs2phy <= 35
+        1
+        >>> g2.xy <= [35,35]
+        [1,1]
+
+        .. image:: ../assets/img/object_grid_AbsToPhyGridConverter_le.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 물리 좌표를 master 좌표계에서 조건부 연산을 만족하는 추상 좌표로 변환.
+        """
+        if (self.master.__class__.__name__ == "OneDimGrid") or (
+            issubclass(self.master.__class__, OneDimGrid)
+        ):
+            return self._le_1d(other=other)
+        if (self.master.__class__.__name__ == "Grid") or (
+            issubclass(self.master.__class__, Grid)
+        ):
+            return self._le_2d(other=other)
+
+    def _le_1d(self, other):
+        return self._phy2abs_operator(
+            other,
+            self.master.elements,
+            self.master.width,
+            self.master.elements.shape[0],
+            "<=",
+        )
+
+    def _le_2d(self, other):
+        if isinstance(other[0], (int, np.integer)):
+            return np.array([self.master.x <= other[0], self.master.y <= other[1]])
+        else:
+            return np.array([self._le_2d(o) for o in other])
+
+    def __gt__(self, other):
+        """
+        Convert physical coordinates into abstract coordinates of the master grid
+        satisfying conditional operations.
+
+        Parameters
+        ----------
+        other : int
+            physical coordinates.
+
+        Returns
+        -------
+        int or numpy.ndarray
+            abstract coordinates.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 180])
+        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 30], elements=[0])
+        >>> g2   = Grid(name='test', vgrid=g1_x, hgrid=g1_y)
+        >>> g1_x.abs2phy > 35
+        2
+        >>> g2.xy > [35, 35]
+        [2, 2]
+
+        .. image:: ../assets/img/object_grid_AbsToPhyGridConverter_gt.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 물리 좌표를 master 좌표계에서 조건부 연산을 만족하는 추상 좌표로 변환.
+        """
+        if (self.master.__class__.__name__ == "OneDimGrid") or (
+            issubclass(self.master.__class__, OneDimGrid)
+        ):
+            return self._gt_1d(other=other)
+        if (self.master.__class__.__name__ == "Grid") or (
+            issubclass(self.master.__class__, Grid)
+        ):
+            return self._gt_2d(other=other)
+
+    def _gt_1d(self, other):
+        return self._phy2abs_operator(
+            other,
+            self.master.elements,
+            self.master.width,
+            self.master.elements.shape[0],
+            ">",
+        )
+
+    def _gt_2d(self, other):
+        if isinstance(other[0], (int, np.integer)):
+            return np.array([self.master.x > other[0], self.master.y > other[1]])
+        else:
+            return np.array([self._gt_2d(o) for o in other])
+
+    def __ge__(self, other):
+        """
+        Convert physical coordinates into abstract coordinates of the master grid
+        satisfying conditional operations.
+
+        Parameters
+        ----------
+        other : int
+            physical coordinates.
+
+        Returns
+        -------
+        int or numpy.ndarray
+            abstract coordinates.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 180])
+        >>> g1_y = OneDimGrid(name='ygrid', scope=[0,30], elements=[0])
+        >>> g2   = Grid(name='test', vgrid=g1_x, hgrid=g1_y)
+        >>> g1_x.abs2phy >= 35
+        1
+        >>> g2.xy >= [35, 35]
+        [1, 2]
+
+        .. image:: ../assets/img/object_grid_AbsToPhyGridConverter_ge.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 물리 좌표를 master 좌표계에서 조건부 연산을 만족하는 추상 좌표로 변환.
+        """
+        if (self.master.__class__.__name__ == "OneDimGrid") or (
+            issubclass(self.master.__class__, OneDimGrid)
+        ):
+            return self._ge_1d(other=other)
+        if (self.master.__class__.__name__ == "Grid") or (
+            issubclass(self.master.__class__, Grid)
+        ):
+            return self._ge_2d(other=other)
+
+    def _ge_1d(self, other):
+        return self._phy2abs_operator(
+            other,
+            self.master.elements,
+            self.master.width,
+            self.master.elements.shape[0],
+            ">=",
+        )
+
+    def _ge_2d(self, other):
+        if isinstance(other[0], (int, np.integer)):
+            return np.array([self.master.x >= other[0], self.master.y >= other[1]])
+        else:
+            return np.array([self._ge_2d(o) for o in other])
+
+
+class _PhyToAbsGridConverter:
+    """
+    A class that converts physical coordinates into abstract coordinates.
+    Conversely, conditional operators convert abstract coordinates into
+    physical coordinates.
+
+    .. image:: ../assets/img/user_guide_phy2abs.png
+
+    Notes
+    -----
+    **(Korean)**
+    물리 좌표를 추상 좌표로 변환하는 클래스, 조건부연산은 반대로 추상 좌표를
+    물리 좌표로 변환한다.
+
+    """
+
+    master = None
+    """laygo2.Grid or laygo2.OneDimGrid: Coordinate system to which 
+    _PhyToAbsGridConverter object belongs.
+
+    Example
+    -------
+    >>> from laygo2.object.grid import OneDimGrid, Grid
+    >>> g1_x = OneDimGrid(name='xg', scope=[0, 180], elements=[0, 35, 85, 130, 180]) 
+    >>> g1_y = OneDimGrid(name='yg', scope=[0, 30], elements=[0]) 
+    >>> g2   = Grid(name='g', vgrid=g1_x, hgrid=g1_y) 
+    >>> print(g1_x.phy2abs) 
+    <laygo2.object.grid._PhyToAbsGridConverter object> 
+    >>> print(g2.mn) 
+    <laygo2.object.grid._PhyToAbsGridConverter object>
+    >>> print(g1_x.phy2abs.master) 
+    <laygo2.object.grid.OneDimGrid object>
+    >>> print(g2.mn.master) 
+    <laygo2.object.grid.Grid object>
+
+    Notes
+    -----
+    **(Korean)** _PhyToAbsGridConverter 객체가 속한 좌표계.
+    """
+
+    # Constructor
+    def __init__(self, master):
+        """Constructor function of _PhyToAbsGridConverter class."""
+        self.master = master
+
+    # Access functions.
+    def __call__(self, pos):
+        """
+        Convert physical coordinates into the corresponding abstract coordinates of
+        the master grid.
+
+        Parameters
+        ----------
+        pos : int
+            physical coordinates.
+
+        Returns
+        -------
+        int or numpy.ndarray
+            abstract coordinates.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 180])
+        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 30], elements=[0])
+        >>> g2   = Grid(name='test', vgrid=g1_x, hgrid=g1_y)
+        >>> g1_x.phy2abs(35)
+        1
+        >>> g2.mn([[35, 35]])
+        [1, None]
+
+        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_call.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 물리 좌표를 master 좌표계에서 대응되는 추상 좌표로 변환.
+        """
+        return self.__getitem__(pos)
+
+    def __getitem__(self, pos):
+        """
+        Convert physical coordinates into the corresponding abstract coordinates of the master grid.
+
+        Parameters
+        ----------
+        pos : int
+            physical coordinates.
+
+        Returns
+        -------
+        int or numpy.ndarray
+            abstract coordinates.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xg', scope=[0, 180], elements=[0, 35, 85, 130, 180])
+        >>> g1_y = OneDimGrid(name='yg', scope=[0, 30], elements=[0])
+        >>> g2   = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
+        >>> g1_x.phy2abs(35)
+        1
+        >>> g2.mn( [[35, 35]])
+        [1, None]
+
+        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_getItem.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 물리 좌표를 master 좌표계에서 대응되는 추상 좌표로 변환.
+        """
+        if (self.master.__class__.__name__ == "OneDimGrid") or (
+            issubclass(self.master.__class__, OneDimGrid)
+        ):
+            return self._getitem_1d(pos)
+        if (self.master.__class__.__name__ == "Grid") or (
+            issubclass(self.master.__class__, Grid)
+        ):
+            return self._getitem_2d(pos)
+        else:
+            return None
+
+    def _getitem_1d(self, pos):
+        """An internal function of __getitem__() for 1-d grids."""
+        # Check if pos has multiple elements.
+        if isinstance(pos, OneDimGrid):
+            return self._getitem_1d(pos=pos.elements)
+        elif isinstance(pos, slice):
+            return self._getitem_1d(
+                _conv_slice_to_list(slice_obj=pos, stop_def=self.master.shape[0])
+            )
+        elif isinstance(pos, np.ndarray):
+            return self._getitem_1d(pos.tolist())
+        elif isinstance(pos, list):
+            return np.array([self._getitem_1d(p) for p in pos])
+        elif pos is None:
+            raise TypeError(
+                "_AbsToPhyConverter._getitem_1d does not accept None as its input."
+            )
+        else:
+            # pos is a single element.
+            for i, e in np.ndenumerate(self.master.elements):
+                if (pos - e) % self.master.width == 0:
+                    return (
+                        int(round((pos - e) / self.master.width))
+                        * self.master.elements.shape[0]
+                        + i[0]
+                    )
+            return None  # no matched coordinate
+
+    def _getitem_2d(self, pos):
+        """An internal function of __getitem__() for 2-d grid."""
+        # If pos contains multiple coordinates (or objects), convert recursively.
+        if isinstance(pos, list):
+            if isinstance(
+                pos[0], (int, np.integer)
+            ):  # It's actually a single coordinate.
+                return self[pos[0], pos[1]]
+            else:
+                return [self[p] for p in pos]
+        elif isinstance(pos, np.ndarray):
+            if isinstance(
+                pos[0], (int, np.integer)
+            ):  # It's actually a single coordinate.
+                return np.array(self[pos[0], pos[1]])
+            else:
+                return np.array([self[p] for p in pos])
+        # If pos contains only one physical object, convert its bounding box to abstract coordinates
+        if (pos.__class__.__name__ == "PhysicalObject") or (
+            issubclass(pos.__class__, laygo2.object.PhysicalObject)
+        ):
+            return self.bbox(pos)
+        # If pos contains only one coordinate, convert it to abstract grid.
+        m = self.master.x == pos[0]
+        n = self.master.y == pos[1]
+        # refactor the following code to avoid the use of double for-loops and list comprehensions.
+        if (not isinstance(m, np.ndarray)) and (
+            not isinstance(n, np.ndarray)
+        ):  # x and y are scalars.
+            return np.array([m, n])
+        if not isinstance(m, np.ndarray):  # x is a scalar.
+            return np.array([np.array([m, _n]) for _n in n])
+        elif not isinstance(n, np.ndarray):  # y is a scalar.
+            return np.array([np.array([_m, n]) for _m in m])
+        else:
+            mn = []
+            for _m in m:  # vectorize this operation.
+                row = []
+                for _n in n:
+                    row.append(np.array([_m, _n]))
+                mn.append(np.array(row))
+        return np.array(mn)
+
+    # Reverse-access operators (comparison operators are used for reverse-access).
+    def __eq__(self, other):
+        """
+        Convert abstract coordinates into physical coordinates satisfying
+        conditional operations in the master grid.
+
+        Parameters
+        ----------
+        other : int
+            abstract coordinates.
+
+        Returns
+        -------
+        int or numpy.ndarray
+            physical coordinates.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xg', scope=[0, 180], elements=[0, 35, 85, 130, 180])
+        >>> g1_y = OneDimGrid(name='yg', scope=[0, 30], elements=[0])
+        >>> g2   = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
+        >>> g1_x.phy2abs == 1
+        35
+        >>> g2.mn == [1, 1]
+        [35, 30]
+
+        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_eq.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 추상 좌표를 master 좌표계에서 조건부 연산을 만족하는 물리 좌표로 변환.
+        """
+        return self.master.abs2phy(pos=other)
+
+    """
+        if (self.master.__class__.__name__ == 'OneDimGrid') or (issubclass(self.master.__class__, OneDimGrid)):
+            return self._eq_1d(other=other)
+        if (self.master.__class__.__name__ == 'Grid') or (issubclass(self.master.__class__, Grid)):
+            return self._eq_2d(other=other)
+
+    def _eq_1d(self, other):
+        return self._getitem_1d(pos=other)
+
+    def _eq_2d(self, other):
+        # If other is a physical object, convert its bounding box to abstract coordinates.
+        if (other.__class__.__name__ == 'PhysicalObject') or (issubclass(other.__class__, laygo2.object.PhysicalObject)):
+            mn0 = self.master >= other.bbox[0]
+            mn1 = self.master <= other.bbox[1]
+            return np.array([mn0, mn1])
+        if isinstance(other[0], (int, np.integer)):
+            return np.array([self.master.m[other[0]],
+                             self.master.n[other[1]]])
+        else:
+            return np.array([self._eq_2d(o) for o in other])
+    """
+
+    def __lt__(self, other):
+        """
+        Convert abstract coordinates into physical coordinates satisfying
+        conditional operations in the master grid.
+
+        Parameters
+        ----------
+        other : int
+            abstract coordinates.
+
+        Returns
+        -------
+        int or numpy.ndarray
+            physical coordinates.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 180])
+        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 30], elements=[0])
+        >>> g2   = Grid(name='test', vgrid=g1_x, hgrid=g1_y)
+        >>> g1_x.phy2abs < 1
+        0
+        >>> g2.mn < [1, 1]
+        [0, 0]
+
+        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_lt.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 추상 좌표를 master 좌표계에서 조건부 연산을 만족하는 물리 좌표로 변환.
+        """
+        if (self.master.__class__.__name__ == "OneDimGrid") or (
+            issubclass(self.master.__class__, OneDimGrid)
+        ):
+            return self._lt_1d(other=other)
+        if (self.master.__class__.__name__ == "Grid") or (
+            issubclass(self.master.__class__, Grid)
+        ):
+            return self._lt_2d(other=other)
+
+    def _lt_1d(self, other):
+        if isinstance(other, (int, np.integer)):
+            return self.master.abs2phy.__getitem__(pos=other - 1)
+        return np.array([self._lt_1d(o) for o in other])
+
+    def _lt_2d(self, other):
+        if isinstance(other[0], (int, np.integer)):
+            return self.master.abs2phy.__getitem__(pos=(other[0] - 1, other[1] - 1))
+        return np.array([self._lt_2d(o) for o in other])
+
+    def __le__(self, other):
+        """
+        Convert abstract coordinates into physical coordinates satisfying
+        conditional operations in the master grid.
+
+        Parameters
+        ----------
+        other : int
+            abstract coordinates.
+
+        Returns
+        -------
+        int or numpy.ndarray
+            physical coordinates.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xg', scope=[0, 180], elements=[0, 35, 85, 130, 180])
+        >>> g1_y = OneDimGrid(name='yg', scope=[0, 30], elements=[0])
+        >>> g2   = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
+        >>> g1_x.phy2abs <= 1
+        35
+        >>> g2.mn <= [1, 1]
+        [35, 30]
+
+        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_le.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 추상 좌표를 master 좌표계에서 조건부 연산을 만족하는 물리 좌표로 변환.
+        """
+        return self.master.abs2phy(pos=other)
+
+    def __gt__(self, other):
+        """
+        Convert abstract coordinates into physical coordinates satisfying
+        conditional operations in the master grid.
+
+        Parameters
+        ----------
+        other : int
+            abstract coordinates.
+
+        Returns
+        -------
+        int or numpy.ndarray
+            physical coordinates.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 180])
+        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 30], elements=[0])
+        >>> g2   = Grid(name='test', vgrid=g1_x, hgrid=g1_y)
+        >>> g1_x.phy2abs > 1
+        85
+        >>> g2.mn > [1, 1]
+        [85, 60]
+
+        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_gt.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 추상 좌표를 master 좌표계에서 조건부 연산을 만족하는 물리 좌표로 변환.
+        """
+        if (self.master.__class__.__name__ == "OneDimGrid") or (
+            issubclass(self.master.__class__, OneDimGrid)
+        ):
+            return self._gt_1d(other)
+        if (self.master.__class__.__name__ == "Grid") or (
+            issubclass(self.master.__class__, Grid)
+        ):
+            return self._gt_2d(other)
+        else:
+            return None
+
+    def _gt_1d(self, other):
+        if isinstance(other, (int, np.integer)):
+            return self.master.abs2phy.__getitem__(pos=other + 1)
+        return np.array([self._gt_1d(o) for o in other])
+
+    def _gt_2d(self, other):
+        if isinstance(other[0], (int, np.integer)):
+            return self.master.abs2phy.__getitem__(pos=(other[0] + 1, other[1] + 1))
+        return np.array([self._gt_2d(o) for o in other])
+
+    def __ge__(self, other):
+        """
+        Convert abstract coordinates into physical coordinates satisfying
+        conditional operations in the master grid.
+
+        Parameters
+        ----------
+        other : int
+            abstract coordinates.
+
+        Returns
+        -------
+        int or numpy.ndarray
+            physical coordinates.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 180])
+        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 30], elements=[0])
+        >>> g2   = Grid(name='test', vgrid=g1_x, hgrid=g1_y)
+        >>> g1_x.phy2abs >= 1
+        35
+        >>> g2.mn >=[1, 1]
+        [35, 30]
+
+        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_ge.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 추상 좌표를 master 좌표계에서 조건부 연산을 만족하는 물리 좌표로 변환.
+        """
+        return self.master.abs2phy.__getitem__(pos=other)
+
+    def bbox(self, obj):
+        """
+        Convert the bounding box of the object into the abstract coordinates
+        of the master grid.
+
+        Parameters
+        ----------
+        obj : laygo2.physical
+            object having physical coordinate.
+
+        Returns
+        -------
+        numy.ndarray
+            abstract coordinates.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x    = OneDimGrid(name='xg', scope=[0, 100], elements=[10, 20, 40, 50, 60])
+        >>> g1_y    = OneDimGrid(name='yg', scope=[0, 100], elements=[10, 20, 40, 50, 60])
+        >>> g2      = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
+        >>> phy2abs = _PhyToAbsGridConverter(master=g2)
+        >>> rect0 = physical.Rect(xy=[[0, 0], [100, 100]], layer=['M1', 'drawing'], netname='net0’)
+        >>> phy2abs.bbox(rect0)
+        [[0, 0] , [4, 4]]
+        >>> g2.mn.bbox(rect0)
+        [[0, 0] , [4, 4]]
+
+        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_bbox.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 객체의 bounding box를 master 좌표계의 추상 좌표로 변환.
+        _AbsToPhyGridConverter 객체의 >=, <=를 사용하므로 추상면적이 작아질수있다.
+        """
+        if (obj.__class__.__name__ == "PhysicalObject") or (
+            issubclass(obj.__class__, laygo2.object.PhysicalObject)
+        ):
+            obj = obj.bbox
+
+        # phy -> abs
+        mn0 = self.master.xy >= obj[0]  ## ge than lower left
+        mn1 = self.master.xy <= obj[1]  ## le than upper right\
+
+        return np.array([mn0, mn1])
+
+    def bottom_left(self, obj):
+        """
+        Convert an object's physical corner coordinates into abstract coordinates
+        of the master grid.
+
+        Parameters
+        ----------
+        obj : laygo2.physical
+            object having physical coordinate.
+
+        Returns
+        -------
+        numy.ndarray
+            abstract coordinates.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x    = OneDimGrid(name='xgrid', scope=[0, 100], elements=[10, 20, 40, 50, 60])
+        >>> g1_y    = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60])
+        >>> g2      = Grid(name='test', vgrid=g1_x, hgrid=g1_y)
+        >>> phy2abs = _PhyToAbsGridConverter(master=g2)
+        >>> rect0 = physical.Rect(xy=[[0, 0], [100, 100]], layer=['M1', 'drawing'], netname='net0’)
+        >>> phy2abs.bottom_left(rect0)
+        [0, 0]
+        >>> g2.mn.bottom_left(rect0)
+        [0, 0]
+
+        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_bottom_left.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 객체의 물리 코너 좌표를 master 좌표계의 추상 좌표로 변환.
+        """
+        if (obj.__class__.__name__ == "PhysicalObject") or (
+            issubclass(obj.__class__, laygo2.object.PhysicalObject)
+        ):
+            return self.bottom_left(obj.bbox)
+        else:
+            _i = self.bbox(obj)
+            return _i[0]
+
+    def bottom_right(self, obj):
+        """
+        Convert an object's physical corner coordinates into abstract coordinates
+        of the master grid.
+
+        Parameters
+        ----------
+        obj : laygo2.physical
+            object having physical coordinate.
+
+        Returns
+        -------
+        numy.ndarray
+            abstract coordinates.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x    = OneDimGrid(name='xg', scope=[0, 100], elements=[10, 20, 40, 50, 60])
+        >>> g1_y    = OneDimGrid(name='yg', scope=[0, 100], elements=[10, 20, 40, 50, 60])
+        >>> g2      = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
+        >>> phy2abs = _PhyToAbsGridConverter(master=g2)
+        >>> rect0 = physical.Rect(xy=[[0, 0], [100, 100]], layer=['M1', 'drawing'], netname='net0’)
+        >>> phy2abs.bottom_right(rect0)
+        [4, 0]
+        >>> g2.mn.bottom_right(rect0)
+        [4, 0]
+
+        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_bottom_right.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 객체의 물리 코너 좌표를 master 좌표계의 추상 좌표로 변환.
+        """
+        if (obj.__class__.__name__ == "PhysicalObject") or (
+            issubclass(obj.__class__, laygo2.object.PhysicalObject)
+        ):
+            return self.bottom_right(obj.bbox)
+        else:
+            _i = self.bbox(obj)
+            return np.array([_i[1, 0], _i[0, 1]])
+
+    def top_left(self, obj):
+        """
+        Convert an object's physical corner coordinates into abstract coordinates
+        of the master grid.
+
+        Parameters
+        ----------
+        obj : laygo2.physical
+            object having physical coordinate.
+
+        Returns
+        -------
+        numy.ndarray
+            abstract coordinates.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x    = OneDimGrid(name='xg', scope=[0, 100], elements=[10, 20, 40, 50, 60])
+        >>> g1_y    = OneDimGrid(name='yg', scope=[0, 100], elements=[10, 20, 40, 50, 60])
+        >>> g2      = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
+        >>> phy2abs = _PhyToAbsGridConverter(master=g2)
+        >>> rect0 = physical.Rect(xy=[[0, 0], [100, 100]], layer=['M1', 'drawing'], netname='net0’)
+        >>> phy2abs.top_left(rect0)
+        [0, 4]
+        >>> g2.mn.top_left(rect0)
+        [0, 4]
+
+        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_top_left.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 객체의 물리 코너 좌표를 master 좌표계의 추상 좌표로 변환.
+        """
+        if (obj.__class__.__name__ == "PhysicalObject") or (
+            issubclass(obj.__class__, laygo2.object.PhysicalObject)
+        ):
+            return self.top_left(obj.bbox)
+        else:
+            _i = self.bbox(obj)
+            return np.array([_i[0, 0], _i[1, 1]])
+
+    def top_right(self, obj):
+        """
+        Convert an object's physical corner coordinates into abstract
+        coordinates of the master grid.
+
+        Parameters
+        ----------
+        obj : laygo2.physical
+            object having physical coordinate.
+
+        Returns
+        -------
+        numy.ndarray
+            abstract coordinates.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x    = OneDimGrid(name='xg', scope=[0, 100], elements=[10, 20, 40, 50, 60])
+        >>> g1_y    = OneDimGrid(name='yg', scope=[0, 100], elements=[10, 20, 40, 50, 60])
+        >>> g2      = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
+        >>> phy2abs = _PhyToAbsGridConverter(master=g2)
+        >>> rect0 = physical.Rect(xy=[[0, 0], [100, 100]], layer=['M1', 'drawing'], netname='net0’)
+        >>> phy2abs.top_right(rect0)
+        [4, 4]
+        >>> g2.mn.top_right(rect0)
+        [4, 4]
+
+        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_top_right.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 객체의 물리 코너 좌표를 master 좌표계의 추상 좌표로 변환.
+        """
+        if (obj.__class__.__name__ == "PhysicalObject") or (
+            issubclass(obj.__class__, laygo2.object.PhysicalObject)
+        ):
+            return self.top_right(obj.bbox)
+        else:
+            _i = self.bbox(obj)
+            return _i[1]
+
+    def width(self, obj):
+        """Return the width of an object on this grid."""
+        if (obj.__class__.__name__ == "PhysicalObject") or (
+            issubclass(obj.__class__, laygo2.object.PhysicalObject)
+        ):
+            return self.width(obj.bbox)
+        else:
+            _i = self.bbox(obj)
+            return abs(_i[1, 0] - _i[0, 0])
+
+    def height(self, obj):
+        """Return the height of an object on this grid."""
+        if (obj.__class__.__name__ == "PhysicalObject") or (
+            issubclass(obj.__class__, laygo2.object.PhysicalObject)
+        ):
+            return self.height(obj.bbox)
+        else:
+            _i = self.bbox(obj)
+            return abs(_i[1, 1] - _i[0, 1])
+
+    def height_vec(self, obj):
+        """numpy.ndarray(dtype=int): Return np.array([0, height])."""
+        return np.array([0, self.height(obj)])
+
+    def width_vec(self, obj):
+        """numpy.ndarray(dtype=int): Return np.array([width, 0])."""
+        return np.array([self.width(obj), 0])
+
+    def size(self, obj):
+        """
+        Convert an object's size ([width, height]) into abstract coordinates
+        of the master grid.
+
+        Parameters
+        ----------
+        obj : laygo2.physical
+            object having physical coordinate.
+
+        Returns
+        -------
+        numpy.ndarray
+            abstract coordinates.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x    = OneDimGrid(name='xg', scope=[0, 100], elements=[10, 20, 40, 50, 60])
+        >>> g1_y    = OneDimGrid(name='yg', scope=[0, 100], elements=[10, 20, 40, 50, 60])
+        >>> g2      = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
+        >>> phy2abs = _PhyToAbsGridConverter(master=g2)
+        >>> rect0 = physical.Rect(xy=[[0, 0], [100, 100]], layer=['M1', 'drawing'], netname='net0’)
+        >>> phy2abs.size(rect0)
+        [4, 4]
+        >>> g2.mn.size(rect0)
+        [4, 4]
+
+        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_size.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 객체의 크기([width, height])를 master 좌표계의 추상 좌표로 변환.
+        """
+        return np.array([self.width(obj), self.height(obj)])
+
+    def crossing(self, *args):
+        """
+        Convert the physical intersections of objects into abstract coordinates
+        of the master grid.
+
+        Parameters
+        ----------
+        args : laygo2.Physical
+            physical object having bbox.
+
+        Returns
+        -------
+        numpy.ndarray(int, int)
+            abstract points.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xg', scope=[0, 10], elements=[0])
+        >>> g1_y = OneDimGrid(name='yg’, scope=[0, 120], elements=[0, 20, 40, 80, 100, 120])
+        >>> g2   = Grid(name='g', vgrid = g1_x, hgrid = g1_y )
+        >>> phy2abs = _PhyToAbsGridConverter(master=g2)
+        >>> rect0= physical.Rect(xy=[[0, 0], [60, 90]])
+        >>> rect1= physical.Rect(xy=[[30, 30], [120, 120]])
+        >>> phy2abs.crossing(rect0, rect1)
+        [3, 2]
+        >>> g2.mn.crossing(rect0, rect1)
+        [3, 2]
+
+        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_crossing.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 객체들의 물리적 교차점을 master 좌표계의 추상 좌표로 변환.
+        """
+        return self.overlap(*args, type="point")
+
+    def overlap(self, *args, type="bbox"):
+        """
+        Convert the overlapping area of objects into abstract coordinates of
+        the master grid and return in a format specified in type.
+
+        A bounding box is returned if type='bbox'
+
+        All coordinates in the overlapped region are returned in a
+        two-dimensional array if type='array'
+
+        An one-dimensional list is returned if type='list'.
+
+        Parameters
+        ----------
+        args : laygo2.Physical
+            physical object having bbox.
+
+        Returns
+        -------
+        numpy.ndarray
+            bbox abstract coordinates.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xg', scope=[0, 10], elements=[0])
+        >>> g1_y = OneDimGrid(name='yg', scope=[0, 120], elements=[0, 20, 40, 80, 100, 120])
+        >>> g2   = Grid(name='g', vgrid = g1_x, hgrid = g1_y )
+        >>> phy2abs = _PhyToAbsGridConverter(master=g2)
+        >>> rect0= physical.Rect(xy=[[0, 0], [60, 90]])
+        >>> rect1= physical.Rect(xy=[[30, 30], [120, 120]])
+        >>> phy2abs.overlap(rect0, rect1)
+        [[3, 2], [6,4]]
+        >>> g2.mn.overlap(rect0, rect1)
+        [[3, 2], [6,4]]
+
+        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_overlap.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 객체들의 겹치는 면적을 master 좌표계의 추상 좌표로 변환 후
+        type에 따른 형태로 반환.
+
+        'bbox'인 경우, bounding box로 반환.
+
+        'array' 인 경우 모든 교점을 2차원 array로 반환.
+
+        'list' 인경우 모든 교점을 1차원 list로 변환.
+        """
+        _ib = None
+        for _obj in args:
+            if _ib is None:
+                _ib = self.bbox(_obj)  ## shaped
+            else:
+                _b = self.bbox(_obj)
+                _x = np.sort(np.array([_b[:, 0], _ib[:, 0]]), axis=None)
+                _y = np.sort(np.array([_b[:, 1], _ib[:, 1]]), axis=None)
+                _ib = np.array([[_x[1], _y[1]], [_x[2], _y[2]]])
+        if type == "bbox":
+            return _ib
+        elif type == "point":
+            return _ib[0]
+        elif type == "list":
+            return _conv_bbox_to_list(_ib)
+        elif type == "array":
+            return _conv_bbox_to_array(_ib)
+        else:
+            raise ValueError(
+                "overlap() should receive a valid value for its type (bbox, point, array, ...)"
+            )
+
+    def union(self, *args):
+        """
+        Convert the bounding box containing all objects into abstract coordinates
+        of the master grid.
+
+        Parameters
+        ----------
+        args : laygo2.Physical
+            physical object having bbox.
+
+        Returns
+        -------
+        numpy.ndarray
+            bbox abstract coordinates.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 10], elements=[0])
+        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 120], elements=[0, 20, 40, 80, 100, 120 )
+        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
+        >>> rect0= physical.Rect(xy=[[0, 0], [60, 90]])
+        >>> rect1= physical.Rect(xy=[[30, 30], [120, 120]])
+        >>> g2.mn.union(rect0, rect1)
+        [[0, 0], [12,7]]
+
+        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_union.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 객체들을 모두 포함하는 bounding box를 master 좌표계의
+        추상 좌표로 변환.
+        """
+        _ub = None
+        for _obj in args:
+            if _ub is None:
+                _ub = self.bbox(_obj)
+            else:
+                _b = self.bbox(_obj)
+                _x = np.sort(np.array([_b[:, 0], _ub[:, 0]]), axis=None)
+                _y = np.sort(np.array([_b[:, 1], _ub[:, 1]]), axis=None)
+                _ub = np.array([[_x[0], _y[0]], [_x[3], _y[3]]])
+        return _ub
+
+    def center(self, obj):
+        """
+        Convert an object's physical center coordinates into abstract coordinates
+        of the master grid.
+
+        Parameters
+        ----------
+        obj : laygo2.physical
+            object having physical coordinate.
+
+        Returns
+        -------
+        numy.ndarray
+            abstract coordinates.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x    = OneDimGrid(name='xg', scope=[0, 100], elements=[10, 20, 40, 50, 60])
+        >>> g1_y    = OneDimGrid(name='yg', scope=[0, 100], elements=[10, 20, 40, 50, 60])
+        >>> g2      = Grid(name='g', vgrid=g1_x, hgrid=g1_y)
+        >>> phy2abs = _PhyToAbsGridConverter(master=g2)
+        >>> rect0 = physical.Rect(xy=[[0, 0], [100, 100]], layer=['M1', 'drawing'], netname='net0’)
+        >>> phy2abs.center(rect0)
+        [3, 3]
+        >>> g2.mn.center(rect0)
+        [3, 3]
+
+        .. image:: ../assets/img/object_grid_PhyToAbsGridConverter_center.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 객체의 물리 중앙 좌표를 master 좌표계의 추상 좌표로 변환.
+        """
+        mn0 = self.master.xy >= obj.center
+        mn1 = self.master.xy <= obj.center
+
+        point_list = [
+            self.master.xy[mn0],
+            self.master.xy[mn1],
+            self.master.xy[mn0[0], mn1[1]],
+            self.master.xy[mn1[0], mn0[1]],
+        ]  # 4 physical points near the center coordinate.
+        dist_list = []
+        idx = 0
+        for point in point_list:
+            dist_list.append(
+                [idx, np.linalg.norm(point - obj.center)]
+            )  # Calculate Euclidean distances.
+            idx += 1
+        dist_sorted = sorted(
+            dist_list, key=lambda distance: distance[1]
+        )  # Sort distances in ascending order.
+        return self.master.mn(
+            point_list[dist_sorted[0][0]]
+        )  # Convert the closest point to abstract coordinate and then return.
+    
+    def left(self, obj):
+        """
+        Convert an object's physical left-center coordinate into abstract
+        coordinate of the master grid.
+        """
+        return np.array([self.bottom_left(obj)[0], self.center(obj)[1]])
+    
+    def right(self, obj):
+        """
+        Convert an object's physical right-center coordinate into abstract
+        coordinate of the master grid.
+        """
+        return np.array([self.bottom_right(obj)[0], self.center(obj)[1]])
+    
+    def top(self, obj):
+        """
+        Convert an object's physical upper-center coordinate into abstract
+        coordinate of the master grid.
+        """
+        return np.array([self.center(obj)[0], self.top_left(obj)[1]])
+    
+    def bottom(self, obj):
+        """
+        Convert an object's physical lower-center coordinate into abstract
+        coordinate of the master grid.
+        """
+        return np.array([self.center(obj)[0], self.bottom_left(obj)[1]])
+
+
+
+class OneDimGrid(CircularMapping):
+    """
+    Class implementing one-dimensional abstract coordinates.
+
+    Notes
+    -----
+    **(Korean)**
+    1차원 추상좌표를 구현하는 클래스.
+
+    """
+
+    # Member variables and properties
+    name = None
+    """str: Coordinate system name.
+
+    Example
+    -------
+    >>> from laygo2.object.grid import OneDimGrid
+    >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 50]) 
+    >>> g1_x.name
+    "xgrid"
+
+    .. image:: ../assets/img/object_grid_OneDimGrid_name.png
+           :height: 250
+
+    Notes
+    -----
+    **(Korean)** 좌표계 이름.
+    """
+
+    range = None
+    """str: Region in which the coordinate system is defined Coordinates in 
+    the defined region are repeatedly expanded.
+
+    Example
+    -------
+    >>> from laygo2.object.grid import OneDimGrid
+    >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 50]) 
+    >>> g1_x.range
+    [0, 180]
+    
+    .. image:: ../assets/img/object_grid_OneDimGrid_range.png
+           :height: 250
+
+    Notes
+    -----
+    **(Korean)** 좌표계가 정의된 영역. 정의된 영역의 좌표들이 반복되는 형태로 확장된다.
+    """
+
+    phy2abs = None
+    """self.phy2abs (laygo2._PhyToAbsGridConverter): Object that converts physical 
+    coordinates into abstract coordinates.
+
+    Example
+    -------
+    >>> from laygo2.object.grid import OneDimGrid
+    >>> g1_x  = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 50]) 
+    >>> g1_x.phy2abs
+    <_PhyToAbsGridConverter object>
+
+    Notes
+    -----
+    **(Korean)** 물리 좌표에서 추상 좌표로 변환연산을 해주는 객체. 
+    """
+
+    abs2phy = None
+    """self.abs2phy (laygo2._AbsToPhyGridConverter): Object that converts abstract 
+    coordinates into physical coordinates.
+
+    Example
+    -------
+    >>> from laygo2.object.grid import OneDimGrid
+    >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 50]) 
+    >>> g1_x.abs2phy
+    <_AbsToPhyGridConverter object>
+
+    Notes
+    -----
+    **(Korean)** 추상 좌표에서 물리 좌표로 변환연산을 해주는 객체. 
+    """
+
+    @property
+    def width(self):
+        """int: The size of the region in which the coordinate system is defined.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 50])
+        >>> g1_x.width
+        180
+
+        .. image:: ../assets/img/object_grid_OneDimGrid_width.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 좌표계가 정의된 영역의 크기.
+        """
+        return abs(self.range[1] - self.range[0])
+
+    # Constructor
+    def __init__(self, name, scope, elements=np.array([0])):
+        """
+        Constructor function of OneDimGrid class.
+
+        Parameters
+        ----------
+        name : str
+        scope : numpy.ndarray
+            scope of one-dimensional coordinate system
+        elements: numpy.ndarray
+            members of one-dimensional coordinate system
+
+        Returns
+        -------
+        laygo2.OneDimGrid
+
+
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 50])
+        >>> print(g1_x)
+        OneDimGrid object name: xgrid, class: OneDimGrid, scope: [0, 180], elements: [0, 35, 85, 130  50]
+
+        .. image:: ../assets/img/object_grid_OneDimGrid_init.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** OneDimGrid 클래스의 생성자함수.
+        """
+        self.name = name
+        self.range = np.asarray(scope)
+        self.phy2abs = _PhyToAbsGridConverter(master=self)
+        self.abs2phy = _AbsToPhyGridConverter(master=self)
+        CircularMapping.__init__(self, elements=elements)
+        # self.elements = np.asarray(elements)  # commented out because asarray does not woke well with Object arrays.
+
+    # Indexing and slicing functions
+    def __getitem__(self, pos):
+        """Return the physical coordinate corresponding to the abstract coordinate pos."""
+        return self.abs2phy([pos])
+
+    # Comparison operators
+    def __eq__(self, other):
+        """Return the abstract grid coordinate that matches to other."""
+        return self.abs2phy.__eq__(other)
+
+    def __lt__(self, other):
+        """Return the abstract grid coordinate that is the largest but less than other."""
+        return self.abs2phy.__lt__(other)
+
+    def __le__(self, other):
+        """Return the index of the grid coordinate that is the largest but less than or equal to other."""
+        return self.abs2phy.__le__(other)
+
+    def __gt__(self, other):
+        """Return the abstract grid coordinate that is the smallest but greater than other."""
+        return self.abs2phy.__gt__(other)
+
+    def __ge__(self, other):
+        """Return the index of the grid coordinate that is the smallest but greater than or equal to other."""
+        return self.abs2phy.__ge__(other)
+
+    # Informative functions
+    def __str__(self):
+        """Return the string representation of the object."""
+        return self.summarize()
+
+    def summarize(self):
+        """Return the summary of the object information."""
+        return (
+            self.__repr__() + " "
+            "name: "
+            + self.name
+            + ", "
+            + "class: "
+            + self.__class__.__name__
+            + ", "
+            + "scope: "
+            + str(self.range)
+            + ", "
+            + "elements: "
+            + str(self.elements)
+        )
+
+    # I/O functions
+    def export_to_dict(self):
+        """
+        Return dict object containing grid information.
+
+        Parameters
+        ----------
+        None
+
+        Returns
+        -------
+        dict
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 180], elements=[0, 35, 85, 130, 50])
+        >>> g1_x.export_to_dict()
+        {'scope': [0, 180], 'elements': [0, 35, 85, 130, 50]}
+
+        .. image:: ../assets/img/object_grid_OneDimGrid_export_to_dict.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 그리드의 정보를 담은 dict객체 반환.
+        """
+        export_dict = {
+            "scope": self.range.tolist(),
+            "elements": self.elements.tolist(),
+        }
+        return export_dict
+
+    def flip(self):
+        """Flip the elements of the object."""
+        # self.elements = self.range[1]*np.ones(self.elements.shape) - np.flip(self.elements) + self.range[0]*np.ones(self.elements.shape)
+        self.elements = np.flip(self.elements) * (-1) + self.range[1] + self.range[0]
+
+    def copy(self):
+        """Copy the object."""
+        return OneDimGrid(self.name, self.range.copy(), elements=self.elements.copy())
+
+    def concatenate(self, obj):
+        objelem = obj.elements - obj.range[0] + self.range[1]
+        self.elements = np.concatenate((self.elements, objelem))
+        self.range[1] += obj.range[1] - obj.range[0]
+        # for e in elements:
+        #    self.elements = np.concatenate((self.elements, obj.elements))
+        # self.range[1] += obj.range[1] - obj.range[0]
+
+
+class Grid:
+    """
+    A base class having conversion operators and the mapping information (element)
+    between two-dimensional physical coordinates and abstract coordinates.
+
+    Examplar grid conversions between abstract and physical coordinates are
+    summarized in the following figure.
+
+    .. image:: ../assets/img/user_guide_grid_conversion.png
+
+
+    Notes
+    -----
+    **(Korean)** 2차원 물리좌표와 추상좌표간 mapping 정보(element) 를 갖고 있으며
+    해당 element를 활용하는 좌표 연산자를 가지고 있는 기본 클래스.
+    """
+
+    name = None
+    """str: the name of the grid."""
+
+    _xy = None
+    """List[OneDimGrid]: the list contains the 1d-grid objects for x and y axes."""
+
+    def _get_vgrid(self):
+        return self._xy[0]
+
+    def _set_vgrid(self, value):
+        self._xy[0] = value
+
+    vgrid = property(_get_vgrid, _set_vgrid)
+
+    def _get_hgrid(self):
+        return self._xy[1]
+
+    def _set_hgrid(self, value):
+        self._xy[1] = value
+
+    hgrid = property(_get_hgrid, _set_hgrid)
+
+    @property
+    def elements(self):
+        """numpy.ndarray: Two-dimensional element of a coordinate system.
+            x elements, y elements
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50])
+        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60])
+        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
+        >>> g2.elements
+        [ array([0, 10, 20, 40, 50]), array( [10, 20, 40, 50, 60] ) ]
+
+        .. image:: ../assets/img/object_grid_Grid_Elements.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** 좌표계 2차원 element.
+        """
+        return [self._xy[0].elements, self._xy[1].elements]
+
+    phy2abs = None
+    """PhyToAbsGridConverter(master=self)"""
+
+    abs2phy = None
+    """AbsToPhyGridConverter(master=self)"""
+
+    @property
+    def xy(self):
+        """_AbsToPhyGridConverter: Two-dimensional
+        _AbsToPhyConverter of a coordinate system.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50])
+        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60])
+        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
+        >>> g2.xy[10,10]
+        [200 210]
+        >>> g2.xy([10, 10])
+        [200 210]
+        >>> g2.xy < [10,10]
+        [0,-1]
+        >>> g2.xy <= [10,10]
+        [1,0]
+        >>> g2.xy > [10,10]
+        [2,1]
+        >>> g2.xy >= [10,10]
+        [1,0]
+
+        Notes
+        -----
+        **(Korean)** 2차원 _AbsToPhyConverter.
+        """
+        return self.abs2phy
+
+    @property
+    def x(self):
+        """_AbsToPhyGridConverter: One-dimensional _AbsToPhyGridConverter
+            of the x-coordinate system.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
+        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
+        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
+        >>> g2.x[10]
+        200
+        >>> g2.x <  10
+        [0]
+        >>> g2.x <= 10
+        [1]
+        >>> g2.x >  10
+        [2]
+        >>> g2.x >= 10
+        [1]
+
+        Notes
+        -----
+        **(Korean)**
+        x좌표계 1차원 _AbsToPhyGridConverter.
+        """
+        return self._xy[0].abs2phy
+
+    @property
+    def y(self):
+        """_AbsToPhyGridConverter: One-dimensional _AbsToPhyGridConverter
+        of the y-coordinate system.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
+        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
+        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
+        >>> g2.y[10]
+        210
+        >>> g2.y <  10
+        [-1]
+        >>> g2.y <= 10
+        [0]
+        >>> g2.y >  10
+        [1]
+        >>> g2.y >= 10
+        [0]
+
+        Notes
+        -----
+        **(Korean)** y좌표계 1차원 _AbsToPhyGridConverter.
+        """
+        return self._xy[1].abs2phy
+
+    @property
+    def v(self):
+        """OneDimGrid: OneDimGrid of the x-coordinate system (=self.x).
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
+        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
+        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
+        >>> g2.v
+        g1_x
+
+        Notes
+        -----
+        **(Korean)** x좌표계 OneDimGrid.
+        """
+        return self.x
+
+    @property
+    def h(self):
+        """OneDimGrid: OneDimGrid of the y-coordinate system (=self.y).
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
+        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
+        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
+        >>> g2.h
+        g1_y
+
+        Notes
+        -----
+        **(Korean)** y좌표계 OneDimGrid.
+        """
+        return self.y
+
+    @property
+    def mn(self):
+        """laygo2._PhyToAbsGridConverter: Two-dimensional _PhyToAbsConverter of
+        a coordinate system.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
+        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
+        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
+        >>> g2.mn[40,40]
+        [3, 2]
+        >>> g2.mn([40, 40])
+        [3, 2]
+        >>> g2.mn <  [40,40]
+        [750, 760]
+        >>> g2.mn <= [40,40]
+        [800, 810]
+        >>> g2.mn >  [40,40]
+        [810, 820]
+        >>> g2.mn >= [40,40]
+        [800, 810]
+
+        Notes
+        -----
+        **(Korean)**
+        좌표계 2차원 _PhyToAbsConverter.
+        """
+        return self.phy2abs
+
+    @property
+    def m(self):
+        """_PhyToAbsGridConverter: One-dimensional _PhyToAbsConverter of
+        the x-coordinate system.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
+        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
+        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
+        >>> g2.n[40]
+        2
+        >>> g2.n(40)
+        2
+        >>> g2.n <  40
+        760
+        >>> g2.n <= 40
+        810
+        >>> g2.n >  40
+        820
+        >>> g2.n >= 40
+        810
+
+        Notes
+        -----
+        **(Korean)** x좌표계 1차원 _PhyToAbsConverter.
+        """
+        return self._xy[0].phy2abs
+
+    @property
+    def n(self):
+        """_PhyToAbsGridConverter: One-dimensional _PhyToAbsConverter of
+         the y-coordinate system.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
+        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
+        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
+        >>> g2.n[40]
+        2
+        >>> g2.n(40)
+        2
+        >>> g2.n <  40
+        760
+        >>> g2.n <= 40
+        810
+        >>> g2.n >  40
+        820
+        >>> g2.n >= 40
+        810
+
+        Notes
+        -----
+        **(Korean)** y좌표계 1차원 _PhyToAbsConverter.
+        """
+        return self._xy[1].phy2abs
+
+    @property
+    def shape(self):
+        """numpy.ndarray: Two-dimensional element length in a coordinate system.
+            length of x-axis elements, length of y-axis elements
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
+        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
+        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
+        >>> g2.shape
+        [5, 5]
+
+        Notes
+        -----
+        **(Korean)** 좌표게 2차원 element의 길이.
+        """
+        return np.hstack([self._xy[0].shape, self._xy[1].shape])
+
+    def get_range(self):
+        return np.transpose(np.vstack((self._xy[0].range, self._xy[1].range)))
+
+    def set_range(self, value):
+        self._xy[0].range = np.transpose(value)[0]
+        self._xy[1].range = np.transpose(value)[1]
+
+    range = property(get_range, set_range)
+    """numpy.ndarray: Region in which the coordinate system is defined.
+        bbox of the respective Grid
+
+    Example
+    -------
+    >>> from laygo2.object.grid import OneDimGrid, Grid
+    >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ]) 
+    >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ]) 
+    >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
+    >>> g2.range 
+    [ [0, 0], [100, 100 ]]
+
+    Notes
+    -----
+    **(Korean)** 좌표계가 정의된 영역.
+    """
+
+    @property
+    def width(self):
+        """numpy.int32: Width of the region in which the coordinate system is defined.
+            x scope
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
+        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
+        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
+        >>> g2.width
+        100
+
+        Notes
+        -----
+        **(Korean)** 좌표계가 정의된 영역의 폭.
+        """
+        return self._xy[0].width
+
+    @property
+    def height(self):
+        """numpy.int32: Height of the region in which the coordinate system is defined.
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
+        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
+        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
+        >>> g2.height
+        100
+
+        Notes
+        -----
+        **(Korean)** 좌표계가 정의된 영역의 높이.
+        """
+        return self._xy[1].width
+
+    @property
+    def height_vec(self):
+        """numpy.ndarray: Return the height vector [0, h].
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
+        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
+        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
+        >>> g2.height_vec
+        [0, 100]
+
+        Notes
+        -----
+        **(Korean)** height를 list로 반환.
+        """
+        return np.array([0, self.height])
+
+    @property
+    def width_vec(self):
+        """numpy.ndarray: Return width as a list.
+            length of the respective axis and zero
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
+        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
+        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
+        >>> g2.width_vec
+        [100, 0]
+
+        Notes
+        -----
+        **(Korean)** width를 list로 반환.
+        """
+        return np.array([self.width, 0])
+
+    def __init__(self, name, vgrid, hgrid):
+        """
+        Constructor function of Grid class.
+
+        Parameters
+        ----------
+        name : str
+        vgrid : laygo2.object.grid.OndDimGrid
+            OneDimGrid object of the x-coordinate system
+        hgrid : laygo2.object.grid.OndDimGrid
+            OneDimGrid object of the y-coordinate system
+
+        Returns
+        -------
+        laygo2.object.grid.Grid
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
+        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
+        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
+        >>> print(g2)
+        <laygo2.object.grid.Grid object> name: test, class: Grid, scope: [[0, 0], [100, 100]], elements: [array([ 0, 10, 20, 40, 50]), array([10, 20, 40, 50, 60])
+
+        Notes
+        -----
+        **(Korean)** Grid 클래스의 생성자함수.
+        파라미터
+            - name(str): 이름
+            - vgrid(laygo2.OneDimGrid): x좌표계 OneDimGrid 객체
+            - hgrid(laygo2.OneDimGrid): y좌표계 OneDimGrid 객체
+        반환값
+            - laygo2.Grid
+        """
+        self.name = name
+        self._xy = [vgrid, hgrid]
+        self.phy2abs = _PhyToAbsGridConverter(master=self)
+        self.abs2phy = _AbsToPhyGridConverter(master=self)
+
+    @property
+    def elements(self):
+        """list: return elements of subgrids
+        ([_xy[0].elements, _xy[1].elements]).
+
+        """
+        return [self._xy[0].elements, self._xy[1].elements]
+
+    # Indexing and slicing functions
+    def __call__(self, other):
+        return self.mn(other)
+
+    def __getitem__(self, pos):
+        return self.abs2phy.__getitem__(pos)
+
+    # Comparison operators
+    def __eq__(self, other):
+        """Return the physical grid coordinate that matches to other."""
+        return self.abs2phy.__eq__(other)
+
+    def __lt__(self, other):
+        """Return the index of the grid coordinate that is the largest
+        but less than other.
+        """
+        return self.abs2phy.__lt__(other)
+
+    def __le__(self, other):
+        """Return the index of the grid coordinate that is the largest
+        but less than or equal to other.
+        """
+        return self.abs2phy.__le__(other)
+
+    def __gt__(self, other):
+        """Return the index of the grid coordinate that is the smallest
+        but greater than other.
+        """
+        return self.abs2phy.__gt__(other)
+
+    def __ge__(self, other):
+        """Return the index of the grid coordinate that is the smallest
+        but greater than or equal to other.
+        """
+        return self.abs2phy.__ge__(other)
+
+    def bbox(self, obj):
+        """
+        Return the abstract grid coordinates corresponding to the
+        'internal' bounding box of obj.
+
+        See Also
+        --------
+        _PhyToAbsGridConverter.bbox
+        """
+        return self.phy2abs.bbox(obj)
+
+    def bottom_left(self, obj):
+        """
+        Return the abstract grid coordinates corresponding to the
+        bottom-left corner of obj.
+
+        See Also
+        --------
+        _PhyToAbsGridConverter.bottom_left
+        """
+        return self.phy2abs.bottom_left(obj)
+
+    def bottom_right(self, obj):
+        """
+        Return the abstract grid coordinates corresponding to the
+        bottom-right corner of obj.
+
+        See Also
+        --------
+        _PhyToAbsGridConverter.bottom_right
+        """
+        return self.phy2abs.bottom_right(obj)
+
+    def top_left(self, obj):
+        """
+        Return the abstract grid coordinates corresponding to the top-left
+        corner of obj.
+
+        See Also
+        --------
+        _PhyToAbsGridConverter.top_left
+        """
+        return self.phy2abs.top_left(obj)
+
+    def top_right(self, obj):
+        """
+        Return the abstract grid coordinates corresponding to the top-right
+        corner of obj.
+
+        See Also
+        --------
+        _PhyToAbsGridConverter.top_right
+        """
+        return self.phy2abs.top_right(obj)
+
+    def crossing(self, *args):
+        """
+        Return the abstract grid coordinates corresponding to the crossing
+        point of args.
+
+        See Also
+        --------
+        laygo2.object.grid._PhyToAbsGridConverter.crossing
+        """
+        return self.phy2abs.crossing(*args)
+
+    def overlap(self, *args, type="bbox"):
+        """
+        Return the abstract grid coordinates corresponding to the overlap
+        of args.
+
+        See Also
+        --------
+        laygo2.object.grid._PhyToAbsGridConverter.overlap
+        """
+        return self.phy2abs.overlap(*args, type=type)
+
+    def union(self, *args):
+        """
+        Return the abstract grid coordinates corresponding to union of args.
+
+        See Also
+        --------
+        laygo2.object.grid._PhyToAbsGridConverter.union
+        """
+        return self.phy2abs.union(*args)
+
+    def center(self, obj):
+        """
+        Return the abstract grid coordinates corresponding to the center
+        point of obj.
+
+        Parameters
+        ----------
+        obj : laygo2.object.physical.PhysicalObject
+            The object of which center coordinate is computed.
+
+        See Also
+        --------
+        laygo2.object.grid._PhyToAbsGridConverter.center
+        """
+        return self.phy2abs.center(obj)
+    
+    def left(self, obj):
+        """
+        Return the abstract grid coordinates corresponding to the left
+        point of obj.
+        """
+        return self.phy2abs.left(obj)
+
+    def right(self, obj):
+        """
+        Return the abstract grid coordinates corresponding to the right
+        point of obj.
+        """
+        return self.phy2abs.right(obj)
+
+    def top(self, obj):
+        """
+        Return the abstract grid coordinates corresponding to the top
+        point of obj.
+        """
+        return self.phy2abs.top(obj)
+
+    def bottom(self, obj):
+        """
+        Return the abstract grid coordinates corresponding to the bottom
+        point of obj.
+        """
+        return self.phy2abs.bottom(obj)
+
+    def copy(self):
+        """
+        Make a copy of the current Grid object
+
+        Returns
+        -------
+        laygo2.object.grid.Grid : the copied Grid object.
+        
+        See Also
+        --------
+        laygo2.object.grid.copy
+        """
+        name = self.name
+        vgrid = self.vgrid.copy()
+        hgrid = self.hgrid.copy()
+
+        g = Grid(
+            name=name,
+            vgrid=vgrid,
+            hgrid=hgrid,
+        )
+        return g
+
+    def vflip(self, copy=True):
+        """Flip the grid in vertical direction.
+
+        Parameters
+        ----------
+        copy: optional, boolean
+            If True, make a copy and flip the copied grid (default).
+            If False, flip the current grid object.
+
+        Returns
+        --------
+        laygo2.object.grid.Grid : the flipped Grid object.
+
+        See Also
+        --------
+        laygo2.object.grid.vflip
+        """
+        if copy:
+            g = self.copy()
+        else:
+            g = self
+        g.hgrid.flip()  # Flip vertically means filpping the horizontal grid.
+        return g
+
+    def hflip(self, copy=True):
+        """Flip the grid in horizontal direction.
+
+        Parameters
+        ----------
+        copy: optional, boolean
+            If True, make a copy and flip the copied grid (default).
+            If False, flip the current grid object.
+
+        Returns
+        --------
+        laygo2.object.grid.Grid : the flipped Grid object.
+
+        See Also
+        --------
+        laygo2.object.grid.hflip
+        """
+        if copy:
+            g = self.copy()
+        else:
+            g = self
+        g.vgrid.flip()
+        return g
+
+    def vstack(self, obj, copy=True):
+        """Stack grid(s) on top of the current grid in vertical direction.
+        """
+        if copy:
+            g = self.copy()
+        else:
+            g = self
+        if isinstance(obj, list):  # multiple stack
+            obj_list = obj
+        else:  # single stack
+            obj_list = [obj]
+        # compute the grid range first
+        grid_ofst = g.hgrid.width
+        for _obj in obj_list:
+            g.hgrid.range[1] += _obj.hgrid.width
+        # stack
+        for _obj in obj_list:
+            for i, h in enumerate(_obj.hgrid):
+                # Check if the new grid element exist in the current grid already.
+                val = (h - _obj.hgrid.range[0]) + grid_ofst
+                val = val % (g.hgrid.width)  # modulo
+                if not (val in g.hgrid):
+                    # Unique element
+                    g.hgrid.append(val + g.hgrid.range[0])
+            grid_ofst += _obj.hgrid.width  # increse offset
+        return g
+
+    def hstack(self, obj, copy=True):
+        """Stack grid(s) on top of the current grid in horizontal direction."""
+        if copy:
+            g = self.copy()
+        else:
+            g = self
+        if isinstance(obj, list):  # Multiple stack.
+            for o in obj:
+                g = g.hstack(o, copy=copy)
+            return g
+        for i, v in enumerate(obj.vgrid):
+            # Check if the new grid element exist in the current grid already.
+            val = (v - obj.vgrid.range[0]) + g.vgrid.width  
+            val = val % (g.vgrid.width + obj.vgrid.width)  # modulo
+            if not (val in g.vgrid):
+                # Unique element
+                g.vgrid.append(v + g.vgrid.range[1])
+        g.vgrid.range[1] += obj.vgrid.width
+        return g
+
+    # Iterators
+    def __iter__(self):
+        # TODO: fix this to iterate over the full coordinates
+        return np.array([self._xy[0].__iter__(), self._xy[1].__iter__()])
+
+    def __next__(self):
+        # TODO: fix this to iterate over the full coordinates
+        return np.array([self._xy[0].__next__(), self._xy[1].__next__()])
+
+    # Informative functions
+    def __str__(self):
+        """Return the string representation of the object."""
+        return self.summarize()
+
+    def summarize(self):
+        """
+        Output the information of the respective grid.
+
+        Parameters
+        ----------
+        None
+
+        Returns
+        -------
+        str
+
+        Example
+        -------
+        >>> from laygo2.object.grid import OneDimGrid, Grid
+        >>> g1_x = OneDimGrid(name='xgrid', scope=[0, 100], elements=[0, 10, 20, 40, 50 ])
+        >>> g1_y = OneDimGrid(name='ygrid', scope=[0, 100], elements=[10, 20, 40, 50, 60 ])
+        >>> g2   = Grid(name="test", vgrid = g1_x, hgrid = g1_y )
+        >>> g2.summarize()
+        <laygo2.object.grid.Grid object> name: test, class: Grid, scope: [[0, 0], [100, 100]], elements: [array([ 0, 10, 20, 40, 50]), array([10, 20, 40, 50, 60])
+
+        Notes
+        -----
+        **(Korean)** 해당 Grid의 정보 출력.
+        """
+        return (
+            self.__repr__()
+            + " \n"
+            + " name: "
+            + self.name
+            + ", \n"
+            + " class: "
+            + self.__class__.__name__
+            + ", \n"
+            + " scope: "
+            + str(self.range.tolist())
+            + ", \n"
+            + " elements: "
+            + str(self.elements)
+            + ", \n"
+        )
+
+
+'''
+class ParameterizedGrid(Grid):
+    """A parameterized grid to support flexible templates."""
+
+    # TODO: implement this.
+    pass
+
+
+class ParameterizedPlacementGrid(Grid):
+    # TODO: implement this.
+    pass
+
+
+class ParameterizedRoutingGrid(Grid):
+    # TODO: implement this.
+    pass
+'''
```

### Comparing `laygo2-0.5.6/laygo2/object/grid/placement.py` & `laygo2-0.5.7/laygo2/object/grid/placement.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,94 +1,94 @@
-#!/usr/bin/python
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-from .core import Grid
-
-class PlacementGrid(Grid):
-    """
-    PlacementGrid class implements a grid for placement of Instance and
-    VirtualInstance objects.
-
-    Notes
-    -----
-    **(Korean)** PlacementGrid 클래스는 Instance 및 VirtualInstance 개체들의
-        배치를 위한 격자 그리드를 구현한다.
-
-    """
-
-    type = "placement"
-    """ Type of grid. Should be 'placement' for placement grids."""
-
-    def place(self, inst, mn):
-        """
-        Place the instance on the specified coordinate mn, on this grid.
-
-        Parameters
-        ----------
-        inst : laygo2.object.physical.Instance or laygo2.object.physical.VirtualInstance
-            The instance to be placed on the grid.
-        mn : numpy.ndarray or list
-            The abstract coordinate [m, n] to place the instance.
-
-        Returns
-        -------
-        laygo2.object.physical.Instance or
-        laygo2.object.physical.VirtualInstance :
-            The placed instance.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> from laygo2.object.grid import OneDimGrid, PlacementGrid
-        >>> from laygo2.object.physical import Instance
-        >>> #
-        >>> # Create a grid (not needed if laygo2_tech is set up).
-        >>> #
-        >>> gx  = OneDimGrid(name="gx", scope=[0, 20], elements=[0])
-        >>> gy  = OneDimGrid(name="gy", scope=[0, 100], elements=[0])
-        >>> g   = PlacementGrid(name="test", vgrid=gx, hgrid=gy)
-        >>> #
-        >>> # Create an instance
-        >>> #
-        >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
-        >>> print(inst0.xy)
-        [100, 100]
-        >>> #
-        >>> # Place the created instance
-        >>> #
-        >>> g.place(inst=i0, mn=[10,10])
-        >>> # Print parameters of the placed instance.
-        >>> print(i0.xy)
-        [200, 1000]
-
-        Notes
-        -----
-        **(Korean)** 인스턴스 xy속성에 추상좌표를 매핑함.
-            파라미터
-            - inst(laygo2.physical.instance): 배치할 인스턴스
-            - mn(numpy.ndarray or list): 인스턴스를 배치할 추상좌표
-            반환값
-            - laygo2.physical.instance: 좌표가 수정된 인스턴스
-        """
-        inst.xy = self[mn]
-        return inst
+#!/usr/bin/python
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+from .core import Grid
+
+class PlacementGrid(Grid):
+    """
+    PlacementGrid class implements a grid for placement of Instance and
+    VirtualInstance objects.
+
+    Notes
+    -----
+    **(Korean)** PlacementGrid 클래스는 Instance 및 VirtualInstance 개체들의
+        배치를 위한 격자 그리드를 구현한다.
+
+    """
+
+    type = "placement"
+    """ Type of grid. Should be 'placement' for placement grids."""
+
+    def place(self, inst, mn):
+        """
+        Place the instance on the specified coordinate mn, on this grid.
+
+        Parameters
+        ----------
+        inst : laygo2.object.physical.Instance or laygo2.object.physical.VirtualInstance
+            The instance to be placed on the grid.
+        mn : numpy.ndarray or list
+            The abstract coordinate [m, n] to place the instance.
+
+        Returns
+        -------
+        laygo2.object.physical.Instance or
+        laygo2.object.physical.VirtualInstance :
+            The placed instance.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> from laygo2.object.grid import OneDimGrid, PlacementGrid
+        >>> from laygo2.object.physical import Instance
+        >>> #
+        >>> # Create a grid (not needed if laygo2_tech is set up).
+        >>> #
+        >>> gx  = OneDimGrid(name="gx", scope=[0, 20], elements=[0])
+        >>> gy  = OneDimGrid(name="gy", scope=[0, 100], elements=[0])
+        >>> g   = PlacementGrid(name="test", vgrid=gx, hgrid=gy)
+        >>> #
+        >>> # Create an instance
+        >>> #
+        >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
+        >>> print(inst0.xy)
+        [100, 100]
+        >>> #
+        >>> # Place the created instance
+        >>> #
+        >>> g.place(inst=i0, mn=[10,10])
+        >>> # Print parameters of the placed instance.
+        >>> print(i0.xy)
+        [200, 1000]
+
+        Notes
+        -----
+        **(Korean)** 인스턴스 xy속성에 추상좌표를 매핑함.
+            파라미터
+            - inst(laygo2.physical.instance): 배치할 인스턴스
+            - mn(numpy.ndarray or list): 인스턴스를 배치할 추상좌표
+            반환값
+            - laygo2.physical.instance: 좌표가 수정된 인스턴스
+        """
+        inst.xy = self[mn]
+        return inst
```

### Comparing `laygo2-0.5.6/laygo2/object/grid/routing.py` & `laygo2-0.5.7/laygo2/object/grid/routing.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,1578 +1,1578 @@
-#!/usr/bin/python
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-import numpy as np
-from .core import CircularMapping, Grid, OneDimGrid
-import laygo2.object
-
-class RoutingGrid(Grid):
-    """
-    A class that implements wire connections in an abstract coordinate system.
-
-    Notes
-    -----
-    **(Korean)** 추상 좌표계 상의 배선 동작을 구현하는 클래스.
-    """
-
-    type = "routing"
-    """ Type of grid. Should be 'routing' for routing grids."""
-
-    vwidth = None
-    """CircularMapping: Width of vertical wires.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.grid import CircularMapping as CM
-    >>> from laygo2.object.grid import CircularMappingArray as CMA
-    >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
-    >>> from laygo2.object.template import NativeInstanceTemplate
-    >>> # Routing grid construction (not needed if laygo2_tech is set up).
-    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
-    >>> gh = OneDimGrid(name="gh", scope=[0, 100], elements=[0, 40, 60])
-    >>> wv = CM([10])           # vertical (xgrid) width
-    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
-    >>> ev = CM([10])           # vertical (xgrid) extension
-    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
-    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
-    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
-    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
-    >>> lh = CM([['M2', 'drawing']]*3, dtype=object) 
-    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
-    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
-    >>> xcolor = CM([None], dtype=object)  # not multi-patterned 
-    >>> ycolor = CM([None]*3, dtype=object) 
-    >>> primary_grid = 'horizontal'
-    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via 
-    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
-    >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
-                                           vwidth=wv, hwidth=wh,
-                                           vextension=ev, hextension=eh,
-                                           vlayer=lv, hlayer=lh,
-                                           pin_vlayer=plv, pin_hlayer=plh,
-                                           viamap=viamap, primary_grid=primary_grid,
-                                           xcolor=xcolor, ycolor=ycolor,
-                                           vextension0=e0v, hextension0=e0h)
-    >>> print(g.vwidth)
-    <laygo2.object.grid.CircularMapping object > 
-        class: CircularMapping, 
-        elements: [10]
-
-    .. image:: ../assets/img/object_grid_RoutingGrid_vwidth.png
-           :height: 250
-
-    See Also
-    --------
-    vwidth, hwidth, vextension, hextension, vextension0, hextension0
-
-    Notes
-    -----
-    **(Korean)** 수직 wire들의 폭.
-    """
-
-    hwidth = None
-    """CircularMapping: Width of horizontal wires.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.grid import CircularMapping as CM
-    >>> from laygo2.object.grid import CircularMappingArray as CMA
-    >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
-    >>> from laygo2.object.template import NativeInstanceTemplate
-    >>> # Routing grid construction (not needed if laygo2_tech is set up).
-    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
-    >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
-    >>> wv = CM([10])           # vertical (xgrid) width
-    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
-    >>> ev = CM([10])           # vertical (xgrid) extension
-    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
-    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
-    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
-    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
-    >>> lh = CM([['M2', 'drawing']]*3, dtype=object) 
-    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
-    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
-    >>> xcolor = CM([None], dtype=object)  # not multi-patterned 
-    >>> ycolor = CM([None]*3, dtype=object) 
-    >>> primary_grid = 'horizontal'
-    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via 
-    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
-    >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
-                                           vwidth=wv, hwidth=wh,
-                                           vextension=ev, hextension=eh,
-                                           vlayer=lv, hlayer=lh,
-                                           pin_vlayer=plv, pin_hlayer=plh,
-                                           viamap=viamap, primary_grid=primary_grid,
-                                           xcolor=xcolor, ycolor=ycolor,
-                                           vextension0=e0v, hextension0=e0h)
-    >>> print(g.hwidth)
-    <laygo2.object.grid.CircularMapping object > 
-        class: CircularMapping, 
-        elements: [20, 10, 10]
-
-    .. image:: ../assets/img/object_grid_RoutingGrid_hwidth.png
-           :height: 250 
-
-    See Also
-    --------
-    vwidth, hwidth, vextension, hextension, vextension0, hextension0
-
-    Notes
-    -----
-    **(Korean)** 수평 wire들의 폭.
-    """
-
-    vextension = None
-    """CircularMapping: Extension of vertical wires.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.grid import CircularMapping as CM
-    >>> from laygo2.object.grid import CircularMappingArray as CMA
-    >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
-    >>> from laygo2.object.template import NativeInstanceTemplate
-    >>> # Routing grid construction (not needed if laygo2_tech is set up).
-    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
-    >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
-    >>> wv = CM([10])           # vertical (xgrid) width
-    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
-    >>> ev = CM([10])           # vertical (xgrid) extension
-    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
-    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
-    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
-    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
-    >>> lh = CM([['M2', 'drawing']]*3, dtype=object) 
-    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
-    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
-    >>> xcolor = CM([None], dtype=object)  # not multi-patterned 
-    >>> ycolor = CM([None]*3, dtype=object) 
-    >>> primary_grid = 'horizontal'
-    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via 
-    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
-    >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
-                                           vwidth=wv, hwidth=wh,
-                                           vextension=ev, hextension=eh,
-                                           vlayer=lv, hlayer=lh,
-                                           pin_vlayer=plv, pin_hlayer=plh,
-                                           viamap=viamap, primary_grid=primary_grid,
-                                           xcolor=xcolor, ycolor=ycolor,
-                                           vextension0=e0v, hextension0=e0h)
-    >>> print(g.vextension)
-    <laygo2.object.grid.CircularMapping object > 
-        class: CircularMapping, 
-        elements: [10]
-
-    .. image:: ../assets/img/object_grid_RoutingGrid_vextension.png
-           :height: 250
-
-    Notes
-    -----
-    **(Korean)** 수직 wire들의 extension.
-    """
-
-    hextension = None
-    """CircularMapping: Extension of horizontal wires.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.grid import CircularMapping as CM
-    >>> from laygo2.object.grid import CircularMappingArray as CMA
-    >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
-    >>> from laygo2.object.template import NativeInstanceTemplate
-    >>> # Routing grid construction (not needed if laygo2_tech is set up).
-    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
-    >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
-    >>> wv = CM([10])           # vertical (xgrid) width
-    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
-    >>> ev = CM([10])           # vertical (xgrid) extension
-    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
-    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
-    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
-    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
-    >>> lh = CM([['M2', 'drawing']]*3, dtype=object) 
-    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
-    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
-    >>> xcolor = CM([None], dtype=object)  # not multi-patterned 
-    >>> ycolor = CM([None]*3, dtype=object) 
-    >>> primary_grid = 'horizontal'
-    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via 
-    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
-    >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
-                                           vwidth=wv, hwidth=wh,
-                                           vextension=ev, hextension=eh,
-                                           vlayer=lv, hlayer=lh,
-                                           pin_vlayer=plv, pin_hlayer=plh,
-                                           viamap=viamap, primary_grid=primary_grid,
-                                           xcolor=xcolor, ycolor=ycolor,
-                                           vextension0=e0v, hextension0=e0h)
-    >>> print(g.hextension)
-    <laygo2.object.grid.CircularMapping object > 
-        class: CircularMapping, 
-        elements: [10, 10, 10]
-
-    .. image:: ../assets/img/object_grid_RoutingGrid_hextension.png
-           :height: 250 
-
-    Notes
-    -----
-    **(Korean)** 수평 wire들의 extension.
-    """
-
-    vextension0 = None
-    """CircularMapping: the array containing the extension of the zero-length wires on the vertical grid.
-    
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.grid import CircularMapping as CM
-    >>> from laygo2.object.grid import CircularMappingArray as CMA
-    >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
-    >>> from laygo2.object.template import NativeInstanceTemplate
-    >>> # Routing grid construction (not needed if laygo2_tech is set up).
-    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
-    >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
-    >>> wv = CM([10])           # vertical (xgrid) width
-    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
-    >>> ev = CM([10])           # vertical (xgrid) extension
-    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
-    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
-    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
-    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
-    >>> lh = CM([['M2', 'drawing']]*3, dtype=object) 
-    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
-    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
-    >>> xcolor = CM([None], dtype=object)  # not multi-patterned 
-    >>> ycolor = CM([None]*3, dtype=object) 
-    >>> primary_grid = 'horizontal'
-    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via 
-    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
-    >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
-                                           vwidth=wv, hwidth=wh,
-                                           vextension=ev, hextension=eh,
-                                           vlayer=lv, hlayer=lh,
-                                           pin_vlayer=plv, pin_hlayer=plh,
-                                           viamap=viamap, primary_grid=primary_grid,
-                                           xcolor=xcolor, ycolor=ycolor,
-                                           vextension0=e0v, hextension0=e0h)
-    >>> print(g.vextension0)
-    <laygo2.object.grid.CircularMapping object > 
-        class: CircularMapping, 
-        elements: [15]
-    """
-
-    hextension0 = None
-    """CircularMapping: the array containing the extension of the zero-length wires on the horizontal grid. 
-    
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.grid import CircularMapping as CM
-    >>> from laygo2.object.grid import CircularMappingArray as CMA
-    >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
-    >>> from laygo2.object.template import NativeInstanceTemplate
-    >>> # Routing grid construction (not needed if laygo2_tech is set up).
-    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
-    >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
-    >>> wv = CM([10])           # vertical (xgrid) width
-    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
-    >>> ev = CM([10])           # vertical (xgrid) extension
-    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
-    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
-    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
-    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
-    >>> lh = CM([['M2', 'drawing']]*3, dtype=object) 
-    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
-    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
-    >>> xcolor = CM([None], dtype=object)  # not multi-patterned 
-    >>> ycolor = CM([None]*3, dtype=object) 
-    >>> primary_grid = 'horizontal'
-    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via 
-    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
-    >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
-                                           vwidth=wv, hwidth=wh,
-                                           vextension=ev, hextension=eh,
-                                           vlayer=lv, hlayer=lh,
-                                           pin_vlayer=plv, pin_hlayer=plh,
-                                           viamap=viamap, primary_grid=primary_grid,
-                                           xcolor=xcolor, ycolor=ycolor,
-                                           vextension0=e0v, hextension0=e0h)
-    >>> print(g.hextension0)
-    <laygo2.object.grid.CircularMapping object > 
-        class: CircularMapping, 
-        elements: [15, 15, 15]
-    """
-
-    vlayer = None
-    """CircularMapping: Layer information of vertical wires.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.grid import CircularMapping as CM
-    >>> from laygo2.object.grid import CircularMappingArray as CMA
-    >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
-    >>> from laygo2.object.template import NativeInstanceTemplate
-    >>> # Routing grid construction (not needed if laygo2_tech is set up).
-    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
-    >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
-    >>> wv = CM([10])           # vertical (xgrid) width
-    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
-    >>> ev = CM([10])           # vertical (xgrid) extension
-    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
-    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
-    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
-    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
-    >>> lh = CM([['M2', 'drawing']]*3, dtype=object) 
-    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
-    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
-    >>> xcolor = CM([None], dtype=object)  # not multi-patterned 
-    >>> ycolor = CM([None]*3, dtype=object) 
-    >>> primary_grid = 'horizontal'
-    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via 
-    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
-    >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
-                                           vwidth=wv, hwidth=wh,
-                                           vextension=ev, hextension=eh,
-                                           vlayer=lv, hlayer=lh,
-                                           pin_vlayer=plv, pin_hlayer=plh,
-                                           viamap=viamap, primary_grid=primary_grid,
-                                           xcolor=xcolor, ycolor=ycolor,
-                                           vextension0=e0v, hextension0=e0h)
-    >>> print(g.vlayer)
-    <laygo2.object.grid.CircularMapping object > 
-        class: CircularMapping, 
-        elements: [['M1', 'drawing']]
-
-    .. image:: ../assets/img/object_grid_RoutingGrid_vlayer.png
-           :height: 250
-
-    Notes
-    -----
-    **(Korean)** 수직 wire들의 레이어 정보.
-    """
-
-    hlayer = None
-    """CircularMapping: Layer information of horizontal wires.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.grid import CircularMapping as CM
-    >>> from laygo2.object.grid import CircularMappingArray as CMA
-    >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
-    >>> from laygo2.object.template import NativeInstanceTemplate
-    >>> # Routing grid construction (not needed if laygo2_tech is set up).
-    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
-    >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
-    >>> wv = CM([10])           # vertical (xgrid) width
-    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
-    >>> ev = CM([10])           # vertical (xgrid) extension
-    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
-    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
-    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
-    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
-    >>> lh = CM([['M2', 'drawing']]*3, dtype=object) 
-    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
-    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
-    >>> xcolor = CM([None], dtype=object)  # not multi-patterned 
-    >>> ycolor = CM([None]*3, dtype=object) 
-    >>> primary_grid = 'horizontal'
-    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via 
-    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
-    >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
-                                           vwidth=wv, hwidth=wh,
-                                           vextension=ev, hextension=eh,
-                                           vlayer=lv, hlayer=lh,
-                                           pin_vlayer=plv, pin_hlayer=plh,
-                                           viamap=viamap, primary_grid=primary_grid,
-                                           xcolor=xcolor, ycolor=ycolor,
-                                           vextension0=e0v, hextension0=e0h)
-    >>> print(g.hlayer)
-    <laygo2.object.grid.CircularMapping object > 
-        class: CircularMapping, 
-        elements: [['M1', 'drawing'], ['M1', 'drawing'], ['M1', 'drawing']]
-
-    .. image:: ../assets/img/object_grid_RoutingGrid_hlayer.png
-           :height: 250
-
-    Notes
-    -----
-    **(Korean)** 수평 wire들의 레이어정보.
-    """
-
-    pin_vlayer = None
-    """CircularMapping: Layer information of vertical pin wires.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.grid import CircularMapping as CM
-    >>> from laygo2.object.grid import CircularMappingArray as CMA
-    >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
-    >>> from laygo2.object.template import NativeInstanceTemplate
-    >>> # Routing grid construction (not needed if laygo2_tech is set up).
-    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
-    >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
-    >>> wv = CM([10])           # vertical (xgrid) width
-    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
-    >>> ev = CM([10])           # vertical (xgrid) extension
-    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
-    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
-    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
-    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
-    >>> lh = CM([['M2', 'drawing']]*3, dtype=object) 
-    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
-    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
-    >>> xcolor = CM([None], dtype=object)  # not multi-patterned 
-    >>> ycolor = CM([None]*3, dtype=object) 
-    >>> primary_grid = 'horizontal'
-    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via 
-    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
-    >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
-                                           vwidth=wv, hwidth=wh,
-                                           vextension=ev, hextension=eh,
-                                           vlayer=lv, hlayer=lh,
-                                           pin_vlayer=plv, pin_hlayer=plh,
-                                           viamap=viamap, primary_grid=primary_grid,
-                                           xcolor=xcolor, ycolor=ycolor,
-                                           vextension0=e0v, hextension0=e0h)
-    >>> print(g.pin_vlayer)
-    <laygo2.object.grid.CircularMapping object > 
-        class: CircularMapping, 
-        elements: [['M1', 'pin']]
-
-    .. image:: ../assets/img/object_grid_RoutingGrid_pin_vlayer.png
-           :height: 250
-
-    Notes
-    -----
-    **(Korean)** 수직 pin wire들의 레이어 정보.
-    """
-
-    pin_hlayer = None
-    """CircularMapping: Layer information of horizontal pine wires.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.grid import CircularMapping as CM
-    >>> from laygo2.object.grid import CircularMappingArray as CMA
-    >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
-    >>> from laygo2.object.template import NativeInstanceTemplate
-    >>> # Routing grid construction (not needed if laygo2_tech is set up).
-    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
-    >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
-    >>> wv = CM([10])           # vertical (xgrid) width
-    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
-    >>> ev = CM([10])           # vertical (xgrid) extension
-    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
-    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
-    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
-    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
-    >>> lh = CM([['M2', 'drawing']]*3, dtype=object) 
-    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
-    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
-    >>> xcolor = CM([None], dtype=object)  # not multi-patterned 
-    >>> ycolor = CM([None]*3, dtype=object) 
-    >>> primary_grid = 'horizontal'
-    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via 
-    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
-    >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
-                                           vwidth=wv, hwidth=wh,
-                                           vextension=ev, hextension=eh,
-                                           vlayer=lv, hlayer=lh,
-                                           pin_vlayer=plv, pin_hlayer=plh,
-                                           viamap=viamap, primary_grid=primary_grid,
-                                           xcolor=xcolor, ycolor=ycolor,
-                                           vextension0=e0v, hextension0=e0h)
-    >>> print(g.pin_hlayer)
-    <laygo2.object.grid.CircularMapping object > 
-        class: CircularMapping, 
-        elements: [['M1', 'pin'], ['M1', 'pin'], ['M1', 'pin']]
-
-    .. image:: ../assets/img/object_grid_RoutingGrid_pin_hlayer.png
-           :height: 250
-
-    Notes
-    -----
-    **(Korean)** 수평 pin wire 들의 레이어정보.
-    """
-
-    viamap = None
-    """CircularMappingArray: Array containing Via objects positioned on grid crossing points.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.grid import CircularMapping as CM
-    >>> from laygo2.object.grid import CircularMappingArray as CMA
-    >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
-    >>> from laygo2.object.template import NativeInstanceTemplate
-    >>> # Routing grid construction (not needed if laygo2_tech is set up).
-    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
-    >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
-    >>> wv = CM([10])           # vertical (xgrid) width
-    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
-    >>> ev = CM([10])           # vertical (xgrid) extension
-    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
-    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
-    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
-    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
-    >>> lh = CM([['M2', 'drawing']]*3, dtype=object) 
-    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
-    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
-    >>> xcolor = CM([None], dtype=object)  # not multi-patterned 
-    >>> ycolor = CM([None]*3, dtype=object) 
-    >>> primary_grid = 'horizontal'
-    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via 
-    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
-    >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
-                                           vwidth=wv, hwidth=wh,
-                                           vextension=ev, hextension=eh,
-                                           vlayer=lv, hlayer=lh,
-                                           pin_vlayer=plv, pin_hlayer=plh,
-                                           viamap=viamap, primary_grid=primary_grid,
-                                           xcolor=xcolor, ycolor=ycolor,
-                                           vextension0=e0v, hextension0=e0h)
-    >>> print(g.viamap)
-    <laygo2.object.grid.CircularMappingArray object at 0x000002217F15A530> 
-    class: CircularMappingArray, 
-    elements: [
-        [<laygo2.object.template.NativeInstanceTemplate object at 0x000002217F15ADD0>
-         <laygo2.object.template.NativeInstanceTemplate object at 0x000002217F15ADD0>
-         <laygo2.object.template.NativeInstanceTemplate object at 0x000002217F15ADD0>]]
-
-    .. image:: ../assets/img/object_grid_RoutingGrid_viamap.png
-           :height: 250
-
-    Notes
-    -----
-    **(Korean)** 그리드 교차점에 위치하는 via개채들을 담고있는배열.
-    """
-
-    primary_grid = "vertical"
-    """str: The default direction of routing 
-        (Direction of wire having length 0).
-
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.grid import CircularMapping as CM
-    >>> from laygo2.object.grid import CircularMappingArray as CMA
-    >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
-    >>> from laygo2.object.template import NativeInstanceTemplate
-    >>> # Routing grid construction (not needed if laygo2_tech is set up).
-    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
-    >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
-    >>> wv = CM([10])           # vertical (xgrid) width
-    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
-    >>> ev = CM([10])           # vertical (xgrid) extension
-    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
-    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
-    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
-    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
-    >>> lh = CM([['M2', 'drawing']]*3, dtype=object) 
-    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
-    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
-    >>> xcolor = CM([None], dtype=object)  # not multi-patterned 
-    >>> ycolor = CM([None]*3, dtype=object) 
-    >>> primary_grid = 'horizontal'
-    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via 
-    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
-    >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
-                                           vwidth=wv, hwidth=wh,
-                                           vextension=ev, hextension=eh,
-                                           vlayer=lv, hlayer=lh,
-                                           pin_vlayer=plv, pin_hlayer=plh,
-                                           viamap=viamap, primary_grid=primary_grid,
-                                           xcolor=xcolor, ycolor=ycolor,
-                                           vextension0=e0v, hextension0=e0h)
-    >>> print(g.primary_grid) 
-    “horizontal”
-
-    .. image:: ../assets/img/object_grid_RoutingGrid_primary_grid.png
-           :height: 250
-
-    Notes
-    -----
-    **(Korean)** Routing의 기본 방향 (길이가 0인 wire방향).
-    """
-
-    xcolor = None
-    """CircularMapping: Color of horizontal wires.
-
-    Example
-    -------
-    >>> templates = tech.load_templates() 
-    >>> grids = tech.load_grids(templates=templates) 
-    >>> r23   = grids['routing_23_cmos’] 
-    >>> print(r23.xcolor) 
-    <laygo2.object.grid.CircularMapping object> class: CircularMapping, 
-        elements: [[“colorA”], [“colorB”], [“colorA”], [“colorB”], [“colorA”], [“colorB”], [“colorA”], [“colorB”]]
-
-    .. image:: ../assets/img/object_grid_RoutingGrid_xcolor.png
-           :height: 250
-
-    Notes
-    -----
-    **(Korean)** 수평 wire 들의 color.
-    """
-
-    ycolor = None
-    """CircularMapping: Color of vertical wires.
-
-    Example
-    -------
-    >>> templates = tech.load_templates() 
-    >>> grids = tech.load_grids(templates=templates) 
-    >>> r23   = grids['routing_23_cmos’]
-    >>> print(r23.ycolor) 
-    <laygo2.object.grid.CircularMapping object> class: CircularMapping, 
-        elements: [[“colorA”]]
-
-    .. image:: ../assets/img/object_grid_RoutingGrid_ycolor.png
-           :height: 250
-
-    Notes
-    -----
-    **(Korean)** 수직 wire들의 color.
-    """
-
-    def __init__(
-        self,
-        name,
-        vgrid,
-        hgrid,
-        vwidth,
-        hwidth,
-        vextension,
-        hextension,
-        vlayer,
-        hlayer,
-        pin_vlayer,
-        pin_hlayer,
-        viamap,
-        xcolor=None,
-        ycolor=None,
-        primary_grid="vertical",
-        vextension0=None,
-        hextension0=None,
-    ):
-        """
-        Constructor function of RoutingGrid class.
-
-        Parameters
-        ----------
-        name : str
-            Routing object name
-        vgrid : laygo2.OneDimGrid
-            OneDimGrid of x-coordinate system
-        hgrid : laygo2.OneDimGrid
-            OneDimGrid of y-coordinate system
-        vwidth : CircularMapping
-            x-coordinate system width
-        hwidth : CircularMapping
-            y-coordinate system width
-        vextension : CircularMapping
-            x-coordinate system extension
-        hextension : CircularMapping
-            y-coordinate system extension
-        vlayer : CircularMapping
-            x-coordinate system layer
-        hlayer : CircularMapping
-            y-coordinate system layer
-        pin_vlayer : CircularMapping
-            layer of x-coordinate system pin
-        pin_hlayer : CircularMapping
-            layer of y-coordinate system pin
-        xcolor : list
-            x-coordinate system color
-        ycolor : list
-            y-coordinate system color
-        viamap : CircularMappingArray
-            Via map of Grid
-        primary_grid : str
-            direction of wire having length 0
-
-        Returns
-        -------
-        laygo2.RoutingGrid
-
-        Example
-        -------
-        >>> import laygo2
-        >>> from laygo2.object.grid import CircularMapping as CM
-        >>> from laygo2.object.grid import CircularMappingArray as CMA
-        >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
-        >>> from laygo2.object.template import NativeInstanceTemplate
-        >>> from laygo2.object.physical import Instance
-        >>> # Routing grid construction (not needed if laygo2_tech is set up).
-        >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
-        >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
-        >>> wv = CM([10])           # vertical (xgrid) width
-        >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
-        >>> ev = CM([10])           # vertical (xgrid) extension
-        >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
-        >>> e0v = CM([15])          # vert. extension (for zero-length wires)
-        >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
-        >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
-        >>> lh = CM([['M2', 'drawing']]*3, dtype=object)
-        >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
-        >>> plh = CM([['M2', 'pin']]*3, dtype=object)
-        >>> xcolor = CM([None], dtype=object)  # not multi-patterned
-        >>> ycolor = CM([None]*3, dtype=object)
-        >>> primary_grid = 'horizontal'
-        >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via
-        >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
-        >>> g = RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
-                            vwidth=wv, hwidth=wh,
-                            vextension=ev, hextension=eh,
-                            vlayer=lv, hlayer=lh,
-                            pin_vlayer=plv, pin_hlayer=plh,
-                            viamap=viamap, primary_grid=primary_grid,
-                            xcolor=xcolor, ycolor=ycolor,
-                            vextension0=e0v, hextension0=e0h)
-        >>> # Routing on grid
-        >>> mn_list = [[0, -2], [0, 1], [2, 1], [5,1] ]
-        >>> route = g.route(mn=mn_list, via_tag=[True, False, True, True])
-        >>> for r in route:
-        >>>     print(r)
-        <laygo2.object.physical.Instance object at 0x0000016939A23A90>
-            name: None,
-            class: Instance,
-            xy: [0, -60],
-            params: None,
-            size: [0, 0]
-            shape: None
-            pitch: [0, 0]
-            transform: R0
-            pins: {}
-        <laygo2.object.physical.Rect object at 0x0000016939A23880>
-            name: None,
-            class: Rect,
-            xy: [[0, -60], [0, 40]],
-            params: None, , layer: ['M1' 'drawing'], netname: None
-        <laygo2.object.physical.Rect object at 0x0000016939A21BA0>
-            name: None,
-            class: Rect,
-            xy: [[0, 40], [100, 40]],
-            params: None, , layer: ['M2' 'drawing'], netname: None
-        <laygo2.object.physical.Instance object at 0x0000016939A21B70>
-            name: None,
-            class: Instance,
-            xy: [100, 40],
-            params: None,
-            size: [0, 0]
-            shape: None
-            pitch: [0, 0]
-            transform: R0
-            pins: {}
-        <laygo2.object.physical.Rect object at 0x0000016939A21D80>
-            name: None,
-            class: Rect,
-            xy: [[100, 40], [250, 40]],
-            params: None, , layer: ['M2' 'drawing'], netname: None
-        <laygo2.object.physical.Instance object at 0x0000016939A22350>
-            name: None,
-            class: Instance,
-            xy: [250, 40],
-            params: None,
-            size: [0, 0]
-            shape: None
-            pitch: [0, 0]
-            transform: R0
-            pins: {}
-
-        .. image:: ../assets/img/object_grid_RoutingGrid_init.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)**
-        RoutingGrid 클래스의 생성자함수.
-        파라미터
-        name(str): Routing 객체의 이름
-        vgrid(laygo2.OneDimGrid): x좌표계 OneDimGrid
-        hgrid(laygo2.OneDimGrid): y좌표계 OneDimGrid
-        vwidth(CircularMapping): x좌표계 Width
-        hwidth(CircularMapping): y좌표계 Width
-        vextension(CircularMapping): x좌표계의 extension
-        hextension(CircularMapping): y좌표계의 extension
-        vlayer(CircularMapping): x좌표계의 layer
-        hlayer(CircularMapping): y좌표계의 layer
-        pin_vlayer(CircularMapping): x좌표계 pin의 layer
-        pin_hlayer(CircularMapping): y좌표계 pin의 layer
-        xcolor(list): x좌표계 color
-        ycolor(list): y좌표계 color
-        viamap(CircularMappingArray): Grid의 Via map
-        primary_grid(str): 길이가 0인 Wire방향
-        반환값
-        laygo2.RoutingGrid
-        참조
-        없음
-        """
-        self.vwidth = vwidth
-        self.hwidth = hwidth
-        self.vextension = vextension
-        self.hextension = hextension
-        if vextension0 is None:
-            self.vextension0 = vextension
-        else:
-            self.vextension0 = vextension0
-        if hextension0 is None:
-            self.hextension0 = hextension
-        else:
-            self.hextension0 = hextension0
-        self.vlayer = vlayer
-        self.hlayer = hlayer
-        self.pin_vlayer = pin_vlayer
-        self.pin_hlayer = pin_hlayer
-        self.viamap = viamap
-        self.primary_grid = primary_grid
-        if xcolor is None:
-            self.xcolor = CircularMapping([None]*self.vwidth.shape[0], dtype=object)
-        else:
-            self.xcolor = xcolor
-        if ycolor is None:
-            self.ycolor = CircularMapping([None]*self.hwidth.shape[0], dtype=object)
-        else:
-            self.ycolor = ycolor
-        Grid.__init__(self, name=name, vgrid=vgrid, hgrid=hgrid)
-
-    def route(self, mn, direction=None, via_tag=None):
-        """
-        Create wire object(s) for routing.
-
-        Parameters
-        ----------
-        mn : list(numpy.ndarray)
-            The list containing two or more mn coordinates to be connected.
-        direction : str, optional.
-            None or “vertical” or "horizontal". The direction of the routing object.
-        via_tag : list(Boolean), optional.
-            The list containing switches deciding whether to place via at the edges.
-
-        Returns
-        -------
-        laygo2.object.physical.Rect or list :
-            The generated routing object(s). Check the example code for details.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> from laygo2.object.grid import CircularMapping as CM
-        >>> from laygo2.object.grid import CircularMappingArray as CMA
-        >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
-        >>> from laygo2.object.template import NativeInstanceTemplate
-        >>> from laygo2.object.physical import Instance
-        >>> #
-        >>> # Routing grid construction (not needed if laygo2_tech is set up).
-        >>> #
-        >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
-        >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
-        >>> wv = CM([10])           # vertical (xgrid) width
-        >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
-        >>> ev = CM([10])           # vertical (xgrid) extension
-        >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
-        >>> e0v = CM([15])          # vert. extension (for zero-length wires)
-        >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
-        >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
-        >>> lh = CM([['M2', 'drawing']]*3, dtype=object)
-        >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
-        >>> plh = CM([['M2', 'pin']]*3, dtype=object)
-        >>> xcolor = CM([None], dtype=object)  # not multi-patterned
-        >>> ycolor = CM([None]*3, dtype=object)
-        >>> primary_grid = 'horizontal'
-        >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via
-        >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
-        >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
-                                               vwidth=wv, hwidth=wh,
-                                               vextension=ev, hextension=eh,
-                                               vlayer=lv, hlayer=lh,
-                                               pin_vlayer=plv, pin_hlayer=plh,
-                                               viamap=viamap, primary_grid=primary_grid,
-                                               xcolor=xcolor, ycolor=ycolor,
-                                               vextension0=e0v, hextension0=e0h)
-        >>> #
-        >>> # Routing on grid
-        >>> #
-        >>> mn_list = [[0, -2], [0, 1], [2, 1], [5,1] ]
-        >>> route = g.route(mn=mn_list, via_tag=[True, False, True, True])
-        >>> for r in route:
-        >>>     print(r)
-        <laygo2.object.physical.Instance object at 0x0000016939A23A90>
-            name: None,
-            class: Instance,
-            xy: [0, -60],
-            params: None,
-            size: [0, 0]
-            shape: None
-            pitch: [0, 0]
-            transform: R0
-            pins: {}
-        <laygo2.object.physical.Rect object at 0x0000016939A23880>
-            name: None,
-            class: Rect,
-            xy: [[0, -60], [0, 40]],
-            params: None, , layer: ['M1' 'drawing'], netname: None
-        <laygo2.object.physical.Rect object at 0x0000016939A21BA0>
-            name: None,
-            class: Rect,
-            xy: [[0, 40], [100, 40]],
-            params: None, , layer: ['M2' 'drawing'], netname: None
-        <laygo2.object.physical.Instance object at 0x0000016939A21B70>
-            name: None,
-            class: Instance,
-            xy: [100, 40],
-            params: None,
-            size: [0, 0]
-            shape: None
-            pitch: [0, 0]
-            transform: R0
-            pins: {}
-        <laygo2.object.physical.Rect object at 0x0000016939A21D80>
-            name: None,
-            class: Rect,
-            xy: [[100, 40], [250, 40]],
-            params: None, , layer: ['M2' 'drawing'], netname: None
-        <laygo2.object.physical.Instance object at 0x0000016939A22350>
-            name: None,
-            class: Instance,
-            xy: [250, 40],
-            params: None,
-            size: [0, 0]
-            shape: None
-            pitch: [0, 0]
-            transform: R0
-            pins: {}
-
-        .. image:: ../assets/img/object_grid_RoutingGrid_route.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)**
-        추상 좌표 위에 라우팅을 수행 하는 함수.
-        파라미터
-        mn(list(numpy.ndarray)): 배선을 수행할 2개 이상의 mn 좌표를 담고 있는 list.
-        direction(str): None or “vertical”; path의 방향을 결정 (수평 or 수직) [optional].
-        via_tag(list(Boolean)): Path에 via를 형성 할지를 결정하는 switch들을 담고 있는 list [optional].
-        반환값
-        list: 생성된 routing object들을 담고 있는 list.
-        """
-        mn = np.asarray(mn)
-        _mn = list()
-        for i in range(1, mn.shape[0]):
-            # when more than two points are given,
-            # create a multi-point wire compose of sub-routing wires
-            # connecting the points given by mn in sequence.
-            _mn.append([mn[i - 1, :], mn[i, :]])
-        route = list()
-        # via at the starting point
-        if via_tag is not None:
-            if via_tag[0]:
-                route.append(self.via(mn=_mn[0][0], params=None))
-        # routing wires
-        for i, __mn in enumerate(_mn):
-            xy0 = self.abs2phy[__mn[0]]
-            xy1 = self.abs2phy[__mn[1]]
-            _xy = np.array([[xy0[0], xy0[1]], [xy1[0], xy1[1]]])
-            if np.all(xy0 == xy1):  # if two points are identical, generate a metal stub on the bottom layer.
-                if (direction == "vertical") or ((direction is None) and (self.primary_grid == "vertical")):
-                    width = self.vwidth[__mn[0][0]]
-                    hextension = int(width / 2)
-                    vextension = self.vextension0[__mn[0][0]]
-                    layer = self.vlayer[__mn[0][0]]
-                    if self.xcolor is not None:
-                        color = self.xcolor[
-                            __mn[0][0] % self.xcolor.shape[0]
-                        ]  # xcolor is determined by its grid layer.
-                    else:
-                        color = None
-                else:
-                    width = self.hwidth[__mn[0][1]]
-                    hextension = self.hextension0[__mn[0][1]]
-                    vextension = int(width / 2)
-                    layer = self.hlayer[__mn[0][1]]
-                    if self.ycolor is not None:
-                        color = self.ycolor[
-                            __mn[0][1] % self.ycolor.shape[0]
-                        ]  # ycolor is determined by its grid layer.
-                    else:
-                        color = None
-            else:
-                if (xy0[0] == xy1[0]) or (direction == "vertical"):  # vertical routing
-                    width = self.vwidth[__mn[0][0]]
-                    hextension = int(width / 2)
-                    vextension = self.vextension[__mn[0][0]]
-                    layer = self.vlayer[__mn[0][0]]
-                    if self.xcolor is not None:
-                        color = self.xcolor[
-                            __mn[0][0] % self.xcolor.shape[0]
-                        ]  # xcolor is determined by its grid layer.
-                    else:
-                        color = None
-                else:  # horizontal routing
-                    width = self.hwidth[__mn[0][1]]
-                    hextension = self.hextension[__mn[0][1]]
-                    vextension = int(width / 2)
-                    layer = self.hlayer[__mn[0][1]]
-                    if self.ycolor is not None:
-                        color = self.ycolor[
-                            __mn[0][1] % self.ycolor.shape[0]
-                        ]  # ycolor is determined by its grid layer.
-                    else:
-                        color = None
-            p = laygo2.object.physical.Rect(
-                xy=_xy,
-                layer=layer,
-                hextension=hextension,
-                vextension=vextension,
-                color=color,
-            )
-            route.append(p)
-            # via placement
-            if via_tag is None:
-                if (i > 0) and (i < mn.shape[0] - 1):
-                    route.append(self.via(mn=__mn[0], params=None))
-            else:
-                if via_tag[i + 1] == True:
-                    route.append(self.via(mn=__mn[1], params=None))
-        if len(route) == 1:  # not isinstance(mn[0][0], list):
-            return route[0]
-        else:
-            return route
-
-    def via(self, mn=np.array([0, 0]), params=None):
-        """
-        Create Via object(s) on abstract grid.
-
-        Parameters
-        ----------
-        mn : list(numpy.ndarray)
-            Abstract coordinate(s) that specify location(s) to insert via(s).
-
-        Returns
-        -------
-        list(physical.PhysicalObject):
-            The list containing the generated via objects.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> from laygo2.object.grid import CircularMapping as CM
-        >>> from laygo2.object.grid import CircularMappingArray as CMA
-        >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
-        >>> from laygo2.object.template import NativeInstanceTemplate
-        >>> from laygo2.object.physical import Instance
-        >>> # Routing grid construction (not needed if laygo2_tech is set up).
-        >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
-        >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
-        >>> wv = CM([10])           # vertical (xgrid) width
-        >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
-        >>> ev = CM([10])           # vertical (xgrid) extension
-        >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
-        >>> e0v = CM([15])          # vert. extension (for zero-length wires)
-        >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
-        >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
-        >>> lh = CM([['M2', 'drawing']]*3, dtype=object)
-        >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
-        >>> plh = CM([['M2', 'pin']]*3, dtype=object)
-        >>> xcolor = CM([None], dtype=object)  # not multi-patterned
-        >>> ycolor = CM([None]*3, dtype=object)
-        >>> primary_grid = 'horizontal'
-        >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via
-        >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
-        >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
-                                               vwidth=wv, hwidth=wh,
-                                               vextension=ev, hextension=eh,
-                                               vlayer=lv, hlayer=lh,
-                                               pin_vlayer=plv, pin_hlayer=plh,
-                                               viamap=viamap, primary_grid=primary_grid,
-                                               xcolor=xcolor, ycolor=ycolor,
-                                               vextension0=e0v, hextension0=e0h)
-        >>> # Routing on grid
-        >>> mn_list = [[0, -2], [1, 0], [2, 5]]
-        >>> via = mygrid.via(mn=mn_list)
-        >>> print(via)
-        [<laygo2.object.physical.VirtualInstance object>,
-         <laygo2.object.physical.VirtualInstance object>,
-         <laygo2.object.physical.VirtualInstance object>]
-
-        .. image:: ../assets/img/object_grid_RoutingGrid_via.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** via 생성함수.
-
-        파라미터
-            - mn(list(numpy.ndarray)): via를 생성할 mn좌표. 복수 개 입력 가능.
-        반환값
-            - list(physical.PhysicalObject)): 생성된 via들을 담고 있는 list.
-        """
-        # If mn contains multiple coordinates (or objects), place iteratively.
-        if isinstance(mn, list):
-            if isinstance(mn[0], (int, np.integer)):  # It's actually a single coordinate.
-                return self.via(mn=np.asarray(mn), params=params)
-            else:
-                return [self.via(mn=_mn, params=params) for _mn in mn]
-        elif isinstance(mn, np.ndarray):
-            if isinstance(mn[0], (int, np.integer)):  # It's actually a single coordinate.
-                pass
-            else:
-                return np.array([self.via(mn=_mn, params=params) for _mn in mn])
-        if not isinstance(mn, tuple):
-            mn = tuple(mn)  # viamap (CircularMapping) works only with tuples
-        tvia = self.viamap[mn]
-        via = tvia.generate(params=params)
-        via.xy = self[mn]
-        return via
-
-    def route_via_track(self, mn, track, via_tag=[False, True]):
-        """
-        Perform routing on the specified track with accessing wires to mn.
-
-        Parameters
-        ----------
-        mn : list(numpy.ndarray)
-            list containing coordinates of the points being connected through a track
-        track : numpy.ndarray
-            list containing coordinate values and direction of a track.
-            Vertical tracks have [v, None] format, while horizontal tracks have [None, v] format
-            (v is the coordinates of the track).
-
-        Returns
-        -------
-        list:
-            The list containing the generated routing objects;
-            The last object corresponds to the routing object on the track.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> from laygo2.object.grid import CircularMapping as CM
-        >>> from laygo2.object.grid import CircularMappingArray as CMA
-        >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
-        >>> from laygo2.object.template import NativeInstanceTemplate
-        >>> from laygo2.object.physical import Instance
-        >>> # Routing grid construction (not needed if laygo2_tech is set up).
-        >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
-        >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
-        >>> wv = CM([10])           # vertical (xgrid) width
-        >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
-        >>> ev = CM([10])           # vertical (xgrid) extension
-        >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
-        >>> e0v = CM([15])          # vert. extension (for zero-length wires)
-        >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
-        >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
-        >>> lh = CM([['M2', 'drawing']]*3, dtype=object)
-        >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
-        >>> plh = CM([['M2', 'pin']]*3, dtype=object)
-        >>> xcolor = CM([None], dtype=object)  # not multi-patterned
-        >>> ycolor = CM([None]*3, dtype=object)
-        >>> primary_grid = 'horizontal'
-        >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via
-        >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
-        >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
-                                               vwidth=wv, hwidth=wh,
-                                               vextension=ev, hextension=eh,
-                                               vlayer=lv, hlayer=lh,
-                                               pin_vlayer=plv, pin_hlayer=plh,
-                                               viamap=viamap, primary_grid=primary_grid,
-                                               xcolor=xcolor, ycolor=ycolor,
-                                               vextension0=e0v, hextension0=e0h)
-        >>> # Routing on grid
-        >>> mn_list = [[0, -2], [1, 0], [2, 5], [3, 4], [4, 5], [5, 5]]
-        >>> track = g.route_via_track(mn=mn_list, track=[None, 0])
-        >>> print(track)
-        [[<laygo2.object.physical.Rect object>,
-          <laygo2.object.physical.VirtualInstance object>],
-          <laygo2.object.physical.VirtualInstance object>,
-         [<laygo2.object.physical.Rect object>,
-          <laygo2.object.physical.VirtualInstance object>],
-         [<laygo2.object.physical.Rect object>,
-          <laygo2.object.physical.VirtualInstance object>],
-         [<laygo2.object.physical.Rect object>,
-          <laygo2.object.physical.VirtualInstance object>],
-         [<laygo2.object.physical.Rect object>,
-          <laygo2.object.physical.VirtualInstance object>],
-          <laygo2.object.physical.Rect object>]
-
-        .. image:: ../assets/img/object_grid_RoutingGrid_route_via_track.png
-           :height: 250
-
-        Notes
-        -----
-        **(Korean)** wire 라우팅 함수, track을 기준점으로 routing을 진행한다.
-
-        파라미터
-            - track(numpy.ndarray): track의 좌표값과 방향을 담고 있는 list.
-                수직 트랙일 경우 [v, None],
-                수평 트랙일 경우 [None, v]의 형태를 가지고 있다 (v는 track의 좌표값).
-            - mn(list(numpy.ndarray)): track을 통해 연결될 지점들의 좌표를 담고 있는 list.
-        반환값
-            - list: 생성된 routing object들을 담고 있는 list.
-                마지막 object가 track위의 routing object에 해당.
-        """
-        mn = np.array(mn)
-        route = list()
-
-        if track[1] != None:  # x direction
-            t = 0  # index of track axis
-            p = 1  # index of perpendicular track
-            mn_pivot = track[1]
-        else:  # y direction
-            t = 1
-            p = 0
-            mn_pivot = track[0]
-
-        mn_b = np.array([[0, 0], [0, 0]])  # 1.branch
-        min_t, max_t = mn[0][t], mn[0][t]
-
-        for i in range(len(mn)):
-            mn_b[0] = mn[i]
-            mn_b[1][t] = mn_b[0][t]
-            mn_b[1][p] = mn_pivot
-            if np.array_equal(mn_b[0], mn_b[1]):  #### via only
-                route.append(self.via(mn=mn_b[0], params=None))
-            else:
-                route.append(self.route(mn=[mn_b[0], mn_b[1]], via_tag=via_tag))
-
-            center_t = mn[i][t]
-            if center_t < min_t:
-                min_t = center_t
-            elif max_t < center_t:
-                max_t = center_t
-
-        mn_track = np.array([[0, 0], [0, 0]])  # 2.track
-        mn_track[0][t], mn_track[0][p] = min_t, mn_pivot  # min
-        mn_track[1][t], mn_track[1][p] = max_t, mn_pivot  # max
-
-        if np.array_equal(mn_track[0], mn_track[1]):  # Skip
-            route.append(None)
-        else:
-            route.append(self.route(mn=mn_track))
-
-        return route
-
-    def pin(self, name, mn, direction=None, netname=None, params=None):
-        """
-        Create a Pin object over the abstract coordinates specified by mn,
-        on the specified routing grid.
-
-        Parameters
-        ----------
-        name : str
-            Pin name.
-        mn : numpy.ndarray
-            Abstract coordinates for generating Pin.
-        direction : str, optional.
-            Direction.
-        netname : str, optional.
-            Net name of Pin.
-        params : dict, optional
-            Pin attributes.
-
-        Returns
-        -------
-        laygo2.physical.Pin: The generated pin object.
-
-        Example
-        -------
-        >>> import laygo2
-        >>> from laygo2.object.grid import CircularMapping as CM
-        >>> from laygo2.object.grid import CircularMappingArray as CMA
-        >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
-        >>> from laygo2.object.template import NativeInstanceTemplate
-        >>> # Routing grid construction (not needed if laygo2_tech is set up).
-        >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
-        >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
-        >>> wv = CM([10])           # vertical (xgrid) width
-        >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
-        >>> ev = CM([10])           # vertical (xgrid) extension
-        >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
-        >>> e0v = CM([15])          # vert. extension (for zero-length wires)
-        >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
-        >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
-        >>> lh = CM([['M2', 'drawing']]*3, dtype=object)
-        >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
-        >>> plh = CM([['M2', 'pin']]*3, dtype=object)
-        >>> xcolor = CM([None], dtype=object)  # not multi-patterned
-        >>> ycolor = CM([None]*3, dtype=object)
-        >>> primary_grid = 'horizontal'
-        >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via
-        >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
-        >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
-                                               vwidth=wv, hwidth=wh,
-                                               vextension=ev, hextension=eh,
-                                               vlayer=lv, hlayer=lh,
-                                               pin_vlayer=plv, pin_hlayer=plh,
-                                               viamap=viamap, primary_grid=primary_grid,
-                                               xcolor=xcolor, ycolor=ycolor,
-                                               vextension0=e0v, hextension0=e0h)
-        >>> mn = [[0, 0], [10, 10]]
-        >>> pin = g.pin(name="pin", grid=g, mn=mn)
-        >>> print(pin)
-        <laygo2.object.physical.Pin object at 0x0000028DABE3AB90>
-            name: pin,
-            class: Pin,
-            xy: [[0, -10], [500, 350]],
-            params: None, , layer: ['M2' 'pin'], netname: pin, shape: None,
-            master: None
-
-        Notes
-        -----
-        **(Korean)** pin 생성함수.
-
-        파라미터
-            - name(str): Pin 이름
-            - mn(numpy.ndarray): Pin을 생성할 abstract 좌표
-            - direction(str): 방향 [optional]
-            - netname(str): Pin의 net이름 [optional]
-            - params(dict): Pin 속성 [optional]
-        반환값
-            - laygo2.physical.Pin: Pin object
-        """
-        xy0 = self.abs2phy[mn[0]]
-        xy1 = self.abs2phy[mn[1]]
-        # _xy = np.array([[xy0[0], xy0[1]], [xy1[0], xy1[1]]])
-        if np.all(xy0 == xy1):  # if two points are identical, generate a metal stub on the bottom layer.
-            if (direction == "vertical") or ((direction is None) and (self.primary_grid == "vertical")):
-                width = self.vwidth[mn[0][0]]
-                hextension = int(width / 2)
-                vextension = 0
-                layer = self.pin_vlayer[mn[0][0]]
-            else:
-                width = self.hwidth[mn[0][1]]
-                hextension = 0
-                vextension = int(width / 2)
-                layer = self.pin_hlayer[mn[0][1]]
-        else:
-            if (xy0[0] == xy1[0]) or (direction == "vertical"):  # vertical routing
-                width = self.vwidth[mn[0][0]]
-                hextension = int(width / 2)
-                vextension = 0
-                layer = self.pin_vlayer[mn[0][0]]
-            else:  # horizontal routing
-                width = self.hwidth[mn[0][1]]
-                hextension = 0
-                vextension = int(width / 2)
-                layer = self.pin_hlayer[mn[0][1]]
-        # TODO: pin.xy differ from tech.py.
-        _xy = np.array(
-            [
-                [xy0[0] - hextension, xy0[1] - vextension],
-                [xy1[0] + hextension, xy1[1] + vextension],
-            ]
-        )  ## need to check
-        p = laygo2.object.physical.Pin(name=name, xy=_xy, layer=layer, netname=netname, params=params)
-        return p
-
-    def copy(self): 
-        """Copy the current RoutingGrid object.
-        """
-        name = self.name
-        vgrid = self.vgrid.copy()
-        hgrid = self.hgrid.copy()
-        vwidth = self.vwidth.copy()
-        hwidth = self.hwidth.copy()
-        vextension = self.vextension.copy()
-        hextension = self.hextension.copy()
-        vlayer = self.vlayer.copy()
-        hlayer = self.hlayer.copy()
-        pin_vlayer = self.pin_vlayer.copy()
-        pin_hlayer = self.pin_hlayer.copy()
-        viamap = self.viamap.copy()
-        xcolor = self.xcolor.copy()
-        ycolor = self.ycolor.copy()
-        primary_grid = self.primary_grid
-        vextension0 = self.vextension0.copy()
-        hextension0 = self.hextension0.copy()
-
-        rg = RoutingGrid(
-            name = name,
-            vgrid = vgrid,
-            hgrid = hgrid,
-            vwidth = vwidth,
-            hwidth = hwidth,
-            vextension = vextension,
-            hextension = hextension,
-            vlayer = vlayer,
-            hlayer = hlayer,
-            pin_vlayer = pin_vlayer,
-            pin_hlayer = pin_hlayer,
-            viamap = viamap,
-            xcolor = xcolor,
-            ycolor = ycolor,
-            primary_grid = primary_grid,
-            vextension0 = vextension0,
-            hextension0 = hextension0,
-        )
-        return rg
-
-    def vflip(self, copy=True):
-        """Flip the routing grid in vertical direction."""
-        if copy:
-            g = self.copy()
-        else:
-            g = self
-        g.hgrid.flip()
-        g.hwidth.flip()
-        g.hextension.flip()
-        g.hlayer.flip()
-        g.pin_hlayer.flip()
-        g.ycolor.flip()
-        g.viamap.flip(axis=1)
-        g.hextension0.flip()
-        return g
-
-    def hflip(self, copy=True):
-        """Flip the routing grid in horizontal direction."""
-        if copy:
-            g = self.copy()
-        else:
-            g = self
-        g.vgrid.flip()
-        g.vwidth.flip()
-        g.vextension.flip()
-        g.vlayer.flip()
-        g.pin_vlayer.flip()
-        g.xcolor.flip()
-        g.viamap.flip(axis=0)
-        g.vextension0.flip()
-        return g
-
-    def vstack(self, obj, copy=True):
-        """Stack routing grid(s) on top of the routing grid in vertical direction."""
-        if copy:
-            g = self.copy()
-        else:
-            g = self
-        if isinstance(obj, list):  # multiple stack
-            obj_list = obj
-        else:  # single stack
-            obj_list = [obj]
-        # compute the grid range first
-        grid_ofst = g.hgrid.width
-        for _obj in obj_list:
-            g.hgrid.range[1] += _obj.hgrid.width
-        # stack
-        for _obj in obj_list:
-            for i, h in enumerate(_obj.hgrid):
-                # Check if the new grid element exist in the current grid already.
-                val = (h - _obj.hgrid.range[0]) + grid_ofst
-                val = val % (g.hgrid.width)  # modulo
-                if not (val in g.hgrid):
-                    # Unique element
-                    g.hgrid.append(val + g.hgrid.range[0])
-                    #g.hgrid.append(h - _obj.hgrid.range[0] + g.hgrid.range[0] + grid_ofst)
-                    g.hwidth.append(_obj.hwidth[i])
-                    g.hextension.append(_obj.hextension[i])
-                    g.hlayer.append(_obj.hlayer[i])
-                    g.pin_hlayer.append(_obj.pin_hlayer[i])
-                    g.ycolor.append(_obj.ycolor[i])
-                    g.hextension0.append(_obj.hextension0[i])
-                    elem = np.expand_dims(_obj.viamap.elements[:, i], axis=0)
-                    # hstack due to the transposition of numpy array and cartesian system.
-                    g.viamap.elements = np.hstack((g.viamap.elements, elem)) 
-            grid_ofst += _obj.hgrid.width  # increse offset
-        # Do not use the following code, 
-        # as it does not work when stacking multiple grids with elements at boundaries. 
-        '''
-        if isinstance(obj, list):  # Multiple stack.
-            for o in obj:
-                g = g.vstack(o, copy=copy)
-            return g
-        for i, h in enumerate(obj.hgrid):
-            # Check if the new grid element exist in the current grid already.
-            val = (h - obj.hgrid.range[0]) + g.hgrid.width  
-            val = val % (g.hgrid.width + obj.hgrid.width)  # modulo
-            if not (val in g.hgrid):
-                # Unique element
-                g.hgrid.append(h + g.hgrid.range[1])
-                g.hwidth.append(obj.hwidth[i])
-                g.hextension.append(obj.hextension[i])
-                g.hlayer.append(obj.hlayer[i])
-                g.pin_hlayer.append(obj.pin_hlayer[i])
-                g.ycolor.append(obj.ycolor[i])
-                g.hextension0.append(obj.hextension0[i])
-                elem = np.expand_dims(obj.viamap.elements[:, i], axis=0)
-                # hstack due to the transposition of numpy array and cartesian system.
-                g.viamap.elements = np.hstack((g.viamap.elements, elem)) 
-        g.hgrid.range[1] += obj.hgrid.width
-        '''
-        return g
-
-    def hstack(self, obj, copy=True):
-        """Stack routing grid(s) on top of the routing grid in horizontal direction."""
-        if copy:
-            g = self.copy()
-        else:
-            g = self
-        if isinstance(obj, list):  # Multiple stack.
-            for o in obj:
-                g = g.hstack(o, copy=copy)
-            return g
-        for i, v in enumerate(obj.vgrid):
-            # Check if the new grid element exist in the current grid already.
-            val = (v - obj.vgrid.range[0]) + g.vgrid.width  
-            val = val % (g.vgrid.width + obj.vgrid.width)  # modulo
-            if not (val in g.vgrid):
-                # Unique element
-                g.vgrid.append(v + g.vgrid.range[1])
-                g.vwidth.append(obj.vwidth[i])
-                g.vextension.append(obj.vextension[i])
-                g.vlayer.append(obj.vlayer[i])
-                g.pin_vlayer.append(obj.pin_vlayer[i])
-                g.xcolor.append(obj.xcolor[i])
-                g.vextension0.append(obj.vextension0[i])
-                elem = np.expand_dims(obj.viamap.elements[i, :], axis=0)
-                # vstack due to the transposition of numpy array and cartesian system.
-                g.viamap.elements = np.vstack((g.viamap.elements, elem)) 
-        g.vgrid.range[1] += obj.vgrid.width
-        return g
-
-
-    def summarize(self):
-        """Summarize object information."""
-        return (
-            Grid.summarize(self) 
-            + " vwidth: " + str(self.vwidth) + "\n"
-            + " hwidth: " + str(self.hwidth) + "\n"
-            + " vextension: " + str(self.vextension) + "\n"
-            + " hextension: " + str(self.hextension) + "\n"
-            + " vextension0: " + str(self.vextension0) + "\n"
-            + " hextension0: " + str(self.hextension0) + "\n"
-            + " vlayer: " + str(self.vlayer) + "\n"
-            + " hlayer: " + str(self.hlayer) + "\n"
-            + " primary_grid: " + str(self.primary_grid) + "\n"
-            + " xcolor: " + str(self.xcolor) + "\n"
-            + " ycolor: " + str(self.ycolor) + "\n"
-            + " viamap: " + str(self.viamap) + "\n"
-        )
-    
+#!/usr/bin/python
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+import numpy as np
+from .core import CircularMapping, Grid, OneDimGrid
+import laygo2.object
+
+class RoutingGrid(Grid):
+    """
+    A class that implements wire connections in an abstract coordinate system.
+
+    Notes
+    -----
+    **(Korean)** 추상 좌표계 상의 배선 동작을 구현하는 클래스.
+    """
+
+    type = "routing"
+    """ Type of grid. Should be 'routing' for routing grids."""
+
+    vwidth = None
+    """CircularMapping: Width of vertical wires.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.grid import CircularMapping as CM
+    >>> from laygo2.object.grid import CircularMappingArray as CMA
+    >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
+    >>> from laygo2.object.template import NativeInstanceTemplate
+    >>> # Routing grid construction (not needed if laygo2_tech is set up).
+    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
+    >>> gh = OneDimGrid(name="gh", scope=[0, 100], elements=[0, 40, 60])
+    >>> wv = CM([10])           # vertical (xgrid) width
+    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
+    >>> ev = CM([10])           # vertical (xgrid) extension
+    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
+    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
+    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
+    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
+    >>> lh = CM([['M2', 'drawing']]*3, dtype=object) 
+    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
+    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
+    >>> xcolor = CM([None], dtype=object)  # not multi-patterned 
+    >>> ycolor = CM([None]*3, dtype=object) 
+    >>> primary_grid = 'horizontal'
+    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via 
+    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
+    >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
+                                           vwidth=wv, hwidth=wh,
+                                           vextension=ev, hextension=eh,
+                                           vlayer=lv, hlayer=lh,
+                                           pin_vlayer=plv, pin_hlayer=plh,
+                                           viamap=viamap, primary_grid=primary_grid,
+                                           xcolor=xcolor, ycolor=ycolor,
+                                           vextension0=e0v, hextension0=e0h)
+    >>> print(g.vwidth)
+    <laygo2.object.grid.CircularMapping object > 
+        class: CircularMapping, 
+        elements: [10]
+
+    .. image:: ../assets/img/object_grid_RoutingGrid_vwidth.png
+           :height: 250
+
+    See Also
+    --------
+    vwidth, hwidth, vextension, hextension, vextension0, hextension0
+
+    Notes
+    -----
+    **(Korean)** 수직 wire들의 폭.
+    """
+
+    hwidth = None
+    """CircularMapping: Width of horizontal wires.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.grid import CircularMapping as CM
+    >>> from laygo2.object.grid import CircularMappingArray as CMA
+    >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
+    >>> from laygo2.object.template import NativeInstanceTemplate
+    >>> # Routing grid construction (not needed if laygo2_tech is set up).
+    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
+    >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
+    >>> wv = CM([10])           # vertical (xgrid) width
+    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
+    >>> ev = CM([10])           # vertical (xgrid) extension
+    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
+    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
+    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
+    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
+    >>> lh = CM([['M2', 'drawing']]*3, dtype=object) 
+    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
+    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
+    >>> xcolor = CM([None], dtype=object)  # not multi-patterned 
+    >>> ycolor = CM([None]*3, dtype=object) 
+    >>> primary_grid = 'horizontal'
+    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via 
+    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
+    >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
+                                           vwidth=wv, hwidth=wh,
+                                           vextension=ev, hextension=eh,
+                                           vlayer=lv, hlayer=lh,
+                                           pin_vlayer=plv, pin_hlayer=plh,
+                                           viamap=viamap, primary_grid=primary_grid,
+                                           xcolor=xcolor, ycolor=ycolor,
+                                           vextension0=e0v, hextension0=e0h)
+    >>> print(g.hwidth)
+    <laygo2.object.grid.CircularMapping object > 
+        class: CircularMapping, 
+        elements: [20, 10, 10]
+
+    .. image:: ../assets/img/object_grid_RoutingGrid_hwidth.png
+           :height: 250 
+
+    See Also
+    --------
+    vwidth, hwidth, vextension, hextension, vextension0, hextension0
+
+    Notes
+    -----
+    **(Korean)** 수평 wire들의 폭.
+    """
+
+    vextension = None
+    """CircularMapping: Extension of vertical wires.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.grid import CircularMapping as CM
+    >>> from laygo2.object.grid import CircularMappingArray as CMA
+    >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
+    >>> from laygo2.object.template import NativeInstanceTemplate
+    >>> # Routing grid construction (not needed if laygo2_tech is set up).
+    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
+    >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
+    >>> wv = CM([10])           # vertical (xgrid) width
+    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
+    >>> ev = CM([10])           # vertical (xgrid) extension
+    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
+    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
+    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
+    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
+    >>> lh = CM([['M2', 'drawing']]*3, dtype=object) 
+    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
+    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
+    >>> xcolor = CM([None], dtype=object)  # not multi-patterned 
+    >>> ycolor = CM([None]*3, dtype=object) 
+    >>> primary_grid = 'horizontal'
+    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via 
+    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
+    >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
+                                           vwidth=wv, hwidth=wh,
+                                           vextension=ev, hextension=eh,
+                                           vlayer=lv, hlayer=lh,
+                                           pin_vlayer=plv, pin_hlayer=plh,
+                                           viamap=viamap, primary_grid=primary_grid,
+                                           xcolor=xcolor, ycolor=ycolor,
+                                           vextension0=e0v, hextension0=e0h)
+    >>> print(g.vextension)
+    <laygo2.object.grid.CircularMapping object > 
+        class: CircularMapping, 
+        elements: [10]
+
+    .. image:: ../assets/img/object_grid_RoutingGrid_vextension.png
+           :height: 250
+
+    Notes
+    -----
+    **(Korean)** 수직 wire들의 extension.
+    """
+
+    hextension = None
+    """CircularMapping: Extension of horizontal wires.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.grid import CircularMapping as CM
+    >>> from laygo2.object.grid import CircularMappingArray as CMA
+    >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
+    >>> from laygo2.object.template import NativeInstanceTemplate
+    >>> # Routing grid construction (not needed if laygo2_tech is set up).
+    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
+    >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
+    >>> wv = CM([10])           # vertical (xgrid) width
+    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
+    >>> ev = CM([10])           # vertical (xgrid) extension
+    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
+    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
+    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
+    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
+    >>> lh = CM([['M2', 'drawing']]*3, dtype=object) 
+    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
+    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
+    >>> xcolor = CM([None], dtype=object)  # not multi-patterned 
+    >>> ycolor = CM([None]*3, dtype=object) 
+    >>> primary_grid = 'horizontal'
+    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via 
+    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
+    >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
+                                           vwidth=wv, hwidth=wh,
+                                           vextension=ev, hextension=eh,
+                                           vlayer=lv, hlayer=lh,
+                                           pin_vlayer=plv, pin_hlayer=plh,
+                                           viamap=viamap, primary_grid=primary_grid,
+                                           xcolor=xcolor, ycolor=ycolor,
+                                           vextension0=e0v, hextension0=e0h)
+    >>> print(g.hextension)
+    <laygo2.object.grid.CircularMapping object > 
+        class: CircularMapping, 
+        elements: [10, 10, 10]
+
+    .. image:: ../assets/img/object_grid_RoutingGrid_hextension.png
+           :height: 250 
+
+    Notes
+    -----
+    **(Korean)** 수평 wire들의 extension.
+    """
+
+    vextension0 = None
+    """CircularMapping: the array containing the extension of the zero-length wires on the vertical grid.
+    
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.grid import CircularMapping as CM
+    >>> from laygo2.object.grid import CircularMappingArray as CMA
+    >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
+    >>> from laygo2.object.template import NativeInstanceTemplate
+    >>> # Routing grid construction (not needed if laygo2_tech is set up).
+    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
+    >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
+    >>> wv = CM([10])           # vertical (xgrid) width
+    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
+    >>> ev = CM([10])           # vertical (xgrid) extension
+    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
+    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
+    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
+    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
+    >>> lh = CM([['M2', 'drawing']]*3, dtype=object) 
+    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
+    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
+    >>> xcolor = CM([None], dtype=object)  # not multi-patterned 
+    >>> ycolor = CM([None]*3, dtype=object) 
+    >>> primary_grid = 'horizontal'
+    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via 
+    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
+    >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
+                                           vwidth=wv, hwidth=wh,
+                                           vextension=ev, hextension=eh,
+                                           vlayer=lv, hlayer=lh,
+                                           pin_vlayer=plv, pin_hlayer=plh,
+                                           viamap=viamap, primary_grid=primary_grid,
+                                           xcolor=xcolor, ycolor=ycolor,
+                                           vextension0=e0v, hextension0=e0h)
+    >>> print(g.vextension0)
+    <laygo2.object.grid.CircularMapping object > 
+        class: CircularMapping, 
+        elements: [15]
+    """
+
+    hextension0 = None
+    """CircularMapping: the array containing the extension of the zero-length wires on the horizontal grid. 
+    
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.grid import CircularMapping as CM
+    >>> from laygo2.object.grid import CircularMappingArray as CMA
+    >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
+    >>> from laygo2.object.template import NativeInstanceTemplate
+    >>> # Routing grid construction (not needed if laygo2_tech is set up).
+    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
+    >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
+    >>> wv = CM([10])           # vertical (xgrid) width
+    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
+    >>> ev = CM([10])           # vertical (xgrid) extension
+    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
+    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
+    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
+    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
+    >>> lh = CM([['M2', 'drawing']]*3, dtype=object) 
+    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
+    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
+    >>> xcolor = CM([None], dtype=object)  # not multi-patterned 
+    >>> ycolor = CM([None]*3, dtype=object) 
+    >>> primary_grid = 'horizontal'
+    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via 
+    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
+    >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
+                                           vwidth=wv, hwidth=wh,
+                                           vextension=ev, hextension=eh,
+                                           vlayer=lv, hlayer=lh,
+                                           pin_vlayer=plv, pin_hlayer=plh,
+                                           viamap=viamap, primary_grid=primary_grid,
+                                           xcolor=xcolor, ycolor=ycolor,
+                                           vextension0=e0v, hextension0=e0h)
+    >>> print(g.hextension0)
+    <laygo2.object.grid.CircularMapping object > 
+        class: CircularMapping, 
+        elements: [15, 15, 15]
+    """
+
+    vlayer = None
+    """CircularMapping: Layer information of vertical wires.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.grid import CircularMapping as CM
+    >>> from laygo2.object.grid import CircularMappingArray as CMA
+    >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
+    >>> from laygo2.object.template import NativeInstanceTemplate
+    >>> # Routing grid construction (not needed if laygo2_tech is set up).
+    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
+    >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
+    >>> wv = CM([10])           # vertical (xgrid) width
+    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
+    >>> ev = CM([10])           # vertical (xgrid) extension
+    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
+    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
+    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
+    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
+    >>> lh = CM([['M2', 'drawing']]*3, dtype=object) 
+    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
+    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
+    >>> xcolor = CM([None], dtype=object)  # not multi-patterned 
+    >>> ycolor = CM([None]*3, dtype=object) 
+    >>> primary_grid = 'horizontal'
+    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via 
+    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
+    >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
+                                           vwidth=wv, hwidth=wh,
+                                           vextension=ev, hextension=eh,
+                                           vlayer=lv, hlayer=lh,
+                                           pin_vlayer=plv, pin_hlayer=plh,
+                                           viamap=viamap, primary_grid=primary_grid,
+                                           xcolor=xcolor, ycolor=ycolor,
+                                           vextension0=e0v, hextension0=e0h)
+    >>> print(g.vlayer)
+    <laygo2.object.grid.CircularMapping object > 
+        class: CircularMapping, 
+        elements: [['M1', 'drawing']]
+
+    .. image:: ../assets/img/object_grid_RoutingGrid_vlayer.png
+           :height: 250
+
+    Notes
+    -----
+    **(Korean)** 수직 wire들의 레이어 정보.
+    """
+
+    hlayer = None
+    """CircularMapping: Layer information of horizontal wires.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.grid import CircularMapping as CM
+    >>> from laygo2.object.grid import CircularMappingArray as CMA
+    >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
+    >>> from laygo2.object.template import NativeInstanceTemplate
+    >>> # Routing grid construction (not needed if laygo2_tech is set up).
+    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
+    >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
+    >>> wv = CM([10])           # vertical (xgrid) width
+    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
+    >>> ev = CM([10])           # vertical (xgrid) extension
+    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
+    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
+    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
+    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
+    >>> lh = CM([['M2', 'drawing']]*3, dtype=object) 
+    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
+    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
+    >>> xcolor = CM([None], dtype=object)  # not multi-patterned 
+    >>> ycolor = CM([None]*3, dtype=object) 
+    >>> primary_grid = 'horizontal'
+    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via 
+    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
+    >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
+                                           vwidth=wv, hwidth=wh,
+                                           vextension=ev, hextension=eh,
+                                           vlayer=lv, hlayer=lh,
+                                           pin_vlayer=plv, pin_hlayer=plh,
+                                           viamap=viamap, primary_grid=primary_grid,
+                                           xcolor=xcolor, ycolor=ycolor,
+                                           vextension0=e0v, hextension0=e0h)
+    >>> print(g.hlayer)
+    <laygo2.object.grid.CircularMapping object > 
+        class: CircularMapping, 
+        elements: [['M1', 'drawing'], ['M1', 'drawing'], ['M1', 'drawing']]
+
+    .. image:: ../assets/img/object_grid_RoutingGrid_hlayer.png
+           :height: 250
+
+    Notes
+    -----
+    **(Korean)** 수평 wire들의 레이어정보.
+    """
+
+    pin_vlayer = None
+    """CircularMapping: Layer information of vertical pin wires.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.grid import CircularMapping as CM
+    >>> from laygo2.object.grid import CircularMappingArray as CMA
+    >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
+    >>> from laygo2.object.template import NativeInstanceTemplate
+    >>> # Routing grid construction (not needed if laygo2_tech is set up).
+    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
+    >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
+    >>> wv = CM([10])           # vertical (xgrid) width
+    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
+    >>> ev = CM([10])           # vertical (xgrid) extension
+    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
+    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
+    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
+    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
+    >>> lh = CM([['M2', 'drawing']]*3, dtype=object) 
+    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
+    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
+    >>> xcolor = CM([None], dtype=object)  # not multi-patterned 
+    >>> ycolor = CM([None]*3, dtype=object) 
+    >>> primary_grid = 'horizontal'
+    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via 
+    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
+    >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
+                                           vwidth=wv, hwidth=wh,
+                                           vextension=ev, hextension=eh,
+                                           vlayer=lv, hlayer=lh,
+                                           pin_vlayer=plv, pin_hlayer=plh,
+                                           viamap=viamap, primary_grid=primary_grid,
+                                           xcolor=xcolor, ycolor=ycolor,
+                                           vextension0=e0v, hextension0=e0h)
+    >>> print(g.pin_vlayer)
+    <laygo2.object.grid.CircularMapping object > 
+        class: CircularMapping, 
+        elements: [['M1', 'pin']]
+
+    .. image:: ../assets/img/object_grid_RoutingGrid_pin_vlayer.png
+           :height: 250
+
+    Notes
+    -----
+    **(Korean)** 수직 pin wire들의 레이어 정보.
+    """
+
+    pin_hlayer = None
+    """CircularMapping: Layer information of horizontal pine wires.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.grid import CircularMapping as CM
+    >>> from laygo2.object.grid import CircularMappingArray as CMA
+    >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
+    >>> from laygo2.object.template import NativeInstanceTemplate
+    >>> # Routing grid construction (not needed if laygo2_tech is set up).
+    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
+    >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
+    >>> wv = CM([10])           # vertical (xgrid) width
+    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
+    >>> ev = CM([10])           # vertical (xgrid) extension
+    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
+    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
+    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
+    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
+    >>> lh = CM([['M2', 'drawing']]*3, dtype=object) 
+    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
+    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
+    >>> xcolor = CM([None], dtype=object)  # not multi-patterned 
+    >>> ycolor = CM([None]*3, dtype=object) 
+    >>> primary_grid = 'horizontal'
+    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via 
+    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
+    >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
+                                           vwidth=wv, hwidth=wh,
+                                           vextension=ev, hextension=eh,
+                                           vlayer=lv, hlayer=lh,
+                                           pin_vlayer=plv, pin_hlayer=plh,
+                                           viamap=viamap, primary_grid=primary_grid,
+                                           xcolor=xcolor, ycolor=ycolor,
+                                           vextension0=e0v, hextension0=e0h)
+    >>> print(g.pin_hlayer)
+    <laygo2.object.grid.CircularMapping object > 
+        class: CircularMapping, 
+        elements: [['M1', 'pin'], ['M1', 'pin'], ['M1', 'pin']]
+
+    .. image:: ../assets/img/object_grid_RoutingGrid_pin_hlayer.png
+           :height: 250
+
+    Notes
+    -----
+    **(Korean)** 수평 pin wire 들의 레이어정보.
+    """
+
+    viamap = None
+    """CircularMappingArray: Array containing Via objects positioned on grid crossing points.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.grid import CircularMapping as CM
+    >>> from laygo2.object.grid import CircularMappingArray as CMA
+    >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
+    >>> from laygo2.object.template import NativeInstanceTemplate
+    >>> # Routing grid construction (not needed if laygo2_tech is set up).
+    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
+    >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
+    >>> wv = CM([10])           # vertical (xgrid) width
+    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
+    >>> ev = CM([10])           # vertical (xgrid) extension
+    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
+    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
+    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
+    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
+    >>> lh = CM([['M2', 'drawing']]*3, dtype=object) 
+    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
+    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
+    >>> xcolor = CM([None], dtype=object)  # not multi-patterned 
+    >>> ycolor = CM([None]*3, dtype=object) 
+    >>> primary_grid = 'horizontal'
+    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via 
+    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
+    >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
+                                           vwidth=wv, hwidth=wh,
+                                           vextension=ev, hextension=eh,
+                                           vlayer=lv, hlayer=lh,
+                                           pin_vlayer=plv, pin_hlayer=plh,
+                                           viamap=viamap, primary_grid=primary_grid,
+                                           xcolor=xcolor, ycolor=ycolor,
+                                           vextension0=e0v, hextension0=e0h)
+    >>> print(g.viamap)
+    <laygo2.object.grid.CircularMappingArray object at 0x000002217F15A530> 
+    class: CircularMappingArray, 
+    elements: [
+        [<laygo2.object.template.NativeInstanceTemplate object at 0x000002217F15ADD0>
+         <laygo2.object.template.NativeInstanceTemplate object at 0x000002217F15ADD0>
+         <laygo2.object.template.NativeInstanceTemplate object at 0x000002217F15ADD0>]]
+
+    .. image:: ../assets/img/object_grid_RoutingGrid_viamap.png
+           :height: 250
+
+    Notes
+    -----
+    **(Korean)** 그리드 교차점에 위치하는 via개채들을 담고있는배열.
+    """
+
+    primary_grid = "vertical"
+    """str: The default direction of routing 
+        (Direction of wire having length 0).
+
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.grid import CircularMapping as CM
+    >>> from laygo2.object.grid import CircularMappingArray as CMA
+    >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
+    >>> from laygo2.object.template import NativeInstanceTemplate
+    >>> # Routing grid construction (not needed if laygo2_tech is set up).
+    >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
+    >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
+    >>> wv = CM([10])           # vertical (xgrid) width
+    >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
+    >>> ev = CM([10])           # vertical (xgrid) extension
+    >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
+    >>> e0v = CM([15])          # vert. extension (for zero-length wires)
+    >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
+    >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
+    >>> lh = CM([['M2', 'drawing']]*3, dtype=object) 
+    >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
+    >>> plh = CM([['M2', 'pin']]*3, dtype=object)
+    >>> xcolor = CM([None], dtype=object)  # not multi-patterned 
+    >>> ycolor = CM([None]*3, dtype=object) 
+    >>> primary_grid = 'horizontal'
+    >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via 
+    >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
+    >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
+                                           vwidth=wv, hwidth=wh,
+                                           vextension=ev, hextension=eh,
+                                           vlayer=lv, hlayer=lh,
+                                           pin_vlayer=plv, pin_hlayer=plh,
+                                           viamap=viamap, primary_grid=primary_grid,
+                                           xcolor=xcolor, ycolor=ycolor,
+                                           vextension0=e0v, hextension0=e0h)
+    >>> print(g.primary_grid) 
+    “horizontal”
+
+    .. image:: ../assets/img/object_grid_RoutingGrid_primary_grid.png
+           :height: 250
+
+    Notes
+    -----
+    **(Korean)** Routing의 기본 방향 (길이가 0인 wire방향).
+    """
+
+    xcolor = None
+    """CircularMapping: Color of horizontal wires.
+
+    Example
+    -------
+    >>> templates = tech.load_templates() 
+    >>> grids = tech.load_grids(templates=templates) 
+    >>> r23   = grids['routing_23_cmos’] 
+    >>> print(r23.xcolor) 
+    <laygo2.object.grid.CircularMapping object> class: CircularMapping, 
+        elements: [[“colorA”], [“colorB”], [“colorA”], [“colorB”], [“colorA”], [“colorB”], [“colorA”], [“colorB”]]
+
+    .. image:: ../assets/img/object_grid_RoutingGrid_xcolor.png
+           :height: 250
+
+    Notes
+    -----
+    **(Korean)** 수평 wire 들의 color.
+    """
+
+    ycolor = None
+    """CircularMapping: Color of vertical wires.
+
+    Example
+    -------
+    >>> templates = tech.load_templates() 
+    >>> grids = tech.load_grids(templates=templates) 
+    >>> r23   = grids['routing_23_cmos’]
+    >>> print(r23.ycolor) 
+    <laygo2.object.grid.CircularMapping object> class: CircularMapping, 
+        elements: [[“colorA”]]
+
+    .. image:: ../assets/img/object_grid_RoutingGrid_ycolor.png
+           :height: 250
+
+    Notes
+    -----
+    **(Korean)** 수직 wire들의 color.
+    """
+
+    def __init__(
+        self,
+        name,
+        vgrid,
+        hgrid,
+        vwidth,
+        hwidth,
+        vextension,
+        hextension,
+        vlayer,
+        hlayer,
+        pin_vlayer,
+        pin_hlayer,
+        viamap,
+        xcolor=None,
+        ycolor=None,
+        primary_grid="vertical",
+        vextension0=None,
+        hextension0=None,
+    ):
+        """
+        Constructor function of RoutingGrid class.
+
+        Parameters
+        ----------
+        name : str
+            Routing object name
+        vgrid : laygo2.OneDimGrid
+            OneDimGrid of x-coordinate system
+        hgrid : laygo2.OneDimGrid
+            OneDimGrid of y-coordinate system
+        vwidth : CircularMapping
+            x-coordinate system width
+        hwidth : CircularMapping
+            y-coordinate system width
+        vextension : CircularMapping
+            x-coordinate system extension
+        hextension : CircularMapping
+            y-coordinate system extension
+        vlayer : CircularMapping
+            x-coordinate system layer
+        hlayer : CircularMapping
+            y-coordinate system layer
+        pin_vlayer : CircularMapping
+            layer of x-coordinate system pin
+        pin_hlayer : CircularMapping
+            layer of y-coordinate system pin
+        xcolor : list
+            x-coordinate system color
+        ycolor : list
+            y-coordinate system color
+        viamap : CircularMappingArray
+            Via map of Grid
+        primary_grid : str
+            direction of wire having length 0
+
+        Returns
+        -------
+        laygo2.RoutingGrid
+
+        Example
+        -------
+        >>> import laygo2
+        >>> from laygo2.object.grid import CircularMapping as CM
+        >>> from laygo2.object.grid import CircularMappingArray as CMA
+        >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
+        >>> from laygo2.object.template import NativeInstanceTemplate
+        >>> from laygo2.object.physical import Instance
+        >>> # Routing grid construction (not needed if laygo2_tech is set up).
+        >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
+        >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
+        >>> wv = CM([10])           # vertical (xgrid) width
+        >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
+        >>> ev = CM([10])           # vertical (xgrid) extension
+        >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
+        >>> e0v = CM([15])          # vert. extension (for zero-length wires)
+        >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
+        >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
+        >>> lh = CM([['M2', 'drawing']]*3, dtype=object)
+        >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
+        >>> plh = CM([['M2', 'pin']]*3, dtype=object)
+        >>> xcolor = CM([None], dtype=object)  # not multi-patterned
+        >>> ycolor = CM([None]*3, dtype=object)
+        >>> primary_grid = 'horizontal'
+        >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via
+        >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
+        >>> g = RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
+                            vwidth=wv, hwidth=wh,
+                            vextension=ev, hextension=eh,
+                            vlayer=lv, hlayer=lh,
+                            pin_vlayer=plv, pin_hlayer=plh,
+                            viamap=viamap, primary_grid=primary_grid,
+                            xcolor=xcolor, ycolor=ycolor,
+                            vextension0=e0v, hextension0=e0h)
+        >>> # Routing on grid
+        >>> mn_list = [[0, -2], [0, 1], [2, 1], [5,1] ]
+        >>> route = g.route(mn=mn_list, via_tag=[True, False, True, True])
+        >>> for r in route:
+        >>>     print(r)
+        <laygo2.object.physical.Instance object at 0x0000016939A23A90>
+            name: None,
+            class: Instance,
+            xy: [0, -60],
+            params: None,
+            size: [0, 0]
+            shape: None
+            pitch: [0, 0]
+            transform: R0
+            pins: {}
+        <laygo2.object.physical.Rect object at 0x0000016939A23880>
+            name: None,
+            class: Rect,
+            xy: [[0, -60], [0, 40]],
+            params: None, , layer: ['M1' 'drawing'], netname: None
+        <laygo2.object.physical.Rect object at 0x0000016939A21BA0>
+            name: None,
+            class: Rect,
+            xy: [[0, 40], [100, 40]],
+            params: None, , layer: ['M2' 'drawing'], netname: None
+        <laygo2.object.physical.Instance object at 0x0000016939A21B70>
+            name: None,
+            class: Instance,
+            xy: [100, 40],
+            params: None,
+            size: [0, 0]
+            shape: None
+            pitch: [0, 0]
+            transform: R0
+            pins: {}
+        <laygo2.object.physical.Rect object at 0x0000016939A21D80>
+            name: None,
+            class: Rect,
+            xy: [[100, 40], [250, 40]],
+            params: None, , layer: ['M2' 'drawing'], netname: None
+        <laygo2.object.physical.Instance object at 0x0000016939A22350>
+            name: None,
+            class: Instance,
+            xy: [250, 40],
+            params: None,
+            size: [0, 0]
+            shape: None
+            pitch: [0, 0]
+            transform: R0
+            pins: {}
+
+        .. image:: ../assets/img/object_grid_RoutingGrid_init.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)**
+        RoutingGrid 클래스의 생성자함수.
+        파라미터
+        name(str): Routing 객체의 이름
+        vgrid(laygo2.OneDimGrid): x좌표계 OneDimGrid
+        hgrid(laygo2.OneDimGrid): y좌표계 OneDimGrid
+        vwidth(CircularMapping): x좌표계 Width
+        hwidth(CircularMapping): y좌표계 Width
+        vextension(CircularMapping): x좌표계의 extension
+        hextension(CircularMapping): y좌표계의 extension
+        vlayer(CircularMapping): x좌표계의 layer
+        hlayer(CircularMapping): y좌표계의 layer
+        pin_vlayer(CircularMapping): x좌표계 pin의 layer
+        pin_hlayer(CircularMapping): y좌표계 pin의 layer
+        xcolor(list): x좌표계 color
+        ycolor(list): y좌표계 color
+        viamap(CircularMappingArray): Grid의 Via map
+        primary_grid(str): 길이가 0인 Wire방향
+        반환값
+        laygo2.RoutingGrid
+        참조
+        없음
+        """
+        self.vwidth = vwidth
+        self.hwidth = hwidth
+        self.vextension = vextension
+        self.hextension = hextension
+        if vextension0 is None:
+            self.vextension0 = vextension
+        else:
+            self.vextension0 = vextension0
+        if hextension0 is None:
+            self.hextension0 = hextension
+        else:
+            self.hextension0 = hextension0
+        self.vlayer = vlayer
+        self.hlayer = hlayer
+        self.pin_vlayer = pin_vlayer
+        self.pin_hlayer = pin_hlayer
+        self.viamap = viamap
+        self.primary_grid = primary_grid
+        if xcolor is None:
+            self.xcolor = CircularMapping([None]*self.vwidth.shape[0], dtype=object)
+        else:
+            self.xcolor = xcolor
+        if ycolor is None:
+            self.ycolor = CircularMapping([None]*self.hwidth.shape[0], dtype=object)
+        else:
+            self.ycolor = ycolor
+        Grid.__init__(self, name=name, vgrid=vgrid, hgrid=hgrid)
+
+    def route(self, mn, direction=None, via_tag=None):
+        """
+        Create wire object(s) for routing.
+
+        Parameters
+        ----------
+        mn : list(numpy.ndarray)
+            The list containing two or more mn coordinates to be connected.
+        direction : str, optional.
+            None or “vertical” or "horizontal". The direction of the routing object.
+        via_tag : list(Boolean), optional.
+            The list containing switches deciding whether to place via at the edges.
+
+        Returns
+        -------
+        laygo2.object.physical.Rect or list :
+            The generated routing object(s). Check the example code for details.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> from laygo2.object.grid import CircularMapping as CM
+        >>> from laygo2.object.grid import CircularMappingArray as CMA
+        >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
+        >>> from laygo2.object.template import NativeInstanceTemplate
+        >>> from laygo2.object.physical import Instance
+        >>> #
+        >>> # Routing grid construction (not needed if laygo2_tech is set up).
+        >>> #
+        >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
+        >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
+        >>> wv = CM([10])           # vertical (xgrid) width
+        >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
+        >>> ev = CM([10])           # vertical (xgrid) extension
+        >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
+        >>> e0v = CM([15])          # vert. extension (for zero-length wires)
+        >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
+        >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
+        >>> lh = CM([['M2', 'drawing']]*3, dtype=object)
+        >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
+        >>> plh = CM([['M2', 'pin']]*3, dtype=object)
+        >>> xcolor = CM([None], dtype=object)  # not multi-patterned
+        >>> ycolor = CM([None]*3, dtype=object)
+        >>> primary_grid = 'horizontal'
+        >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via
+        >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
+        >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
+                                               vwidth=wv, hwidth=wh,
+                                               vextension=ev, hextension=eh,
+                                               vlayer=lv, hlayer=lh,
+                                               pin_vlayer=plv, pin_hlayer=plh,
+                                               viamap=viamap, primary_grid=primary_grid,
+                                               xcolor=xcolor, ycolor=ycolor,
+                                               vextension0=e0v, hextension0=e0h)
+        >>> #
+        >>> # Routing on grid
+        >>> #
+        >>> mn_list = [[0, -2], [0, 1], [2, 1], [5,1] ]
+        >>> route = g.route(mn=mn_list, via_tag=[True, False, True, True])
+        >>> for r in route:
+        >>>     print(r)
+        <laygo2.object.physical.Instance object at 0x0000016939A23A90>
+            name: None,
+            class: Instance,
+            xy: [0, -60],
+            params: None,
+            size: [0, 0]
+            shape: None
+            pitch: [0, 0]
+            transform: R0
+            pins: {}
+        <laygo2.object.physical.Rect object at 0x0000016939A23880>
+            name: None,
+            class: Rect,
+            xy: [[0, -60], [0, 40]],
+            params: None, , layer: ['M1' 'drawing'], netname: None
+        <laygo2.object.physical.Rect object at 0x0000016939A21BA0>
+            name: None,
+            class: Rect,
+            xy: [[0, 40], [100, 40]],
+            params: None, , layer: ['M2' 'drawing'], netname: None
+        <laygo2.object.physical.Instance object at 0x0000016939A21B70>
+            name: None,
+            class: Instance,
+            xy: [100, 40],
+            params: None,
+            size: [0, 0]
+            shape: None
+            pitch: [0, 0]
+            transform: R0
+            pins: {}
+        <laygo2.object.physical.Rect object at 0x0000016939A21D80>
+            name: None,
+            class: Rect,
+            xy: [[100, 40], [250, 40]],
+            params: None, , layer: ['M2' 'drawing'], netname: None
+        <laygo2.object.physical.Instance object at 0x0000016939A22350>
+            name: None,
+            class: Instance,
+            xy: [250, 40],
+            params: None,
+            size: [0, 0]
+            shape: None
+            pitch: [0, 0]
+            transform: R0
+            pins: {}
+
+        .. image:: ../assets/img/object_grid_RoutingGrid_route.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)**
+        추상 좌표 위에 라우팅을 수행 하는 함수.
+        파라미터
+        mn(list(numpy.ndarray)): 배선을 수행할 2개 이상의 mn 좌표를 담고 있는 list.
+        direction(str): None or “vertical”; path의 방향을 결정 (수평 or 수직) [optional].
+        via_tag(list(Boolean)): Path에 via를 형성 할지를 결정하는 switch들을 담고 있는 list [optional].
+        반환값
+        list: 생성된 routing object들을 담고 있는 list.
+        """
+        mn = np.asarray(mn)
+        _mn = list()
+        for i in range(1, mn.shape[0]):
+            # when more than two points are given,
+            # create a multi-point wire compose of sub-routing wires
+            # connecting the points given by mn in sequence.
+            _mn.append([mn[i - 1, :], mn[i, :]])
+        route = list()
+        # via at the starting point
+        if via_tag is not None:
+            if via_tag[0]:
+                route.append(self.via(mn=_mn[0][0], params=None))
+        # routing wires
+        for i, __mn in enumerate(_mn):
+            xy0 = self.abs2phy[__mn[0]]
+            xy1 = self.abs2phy[__mn[1]]
+            _xy = np.array([[xy0[0], xy0[1]], [xy1[0], xy1[1]]])
+            if np.all(xy0 == xy1):  # if two points are identical, generate a metal stub on the bottom layer.
+                if (direction == "vertical") or ((direction is None) and (self.primary_grid == "vertical")):
+                    width = self.vwidth[__mn[0][0]]
+                    hextension = int(width / 2)
+                    vextension = self.vextension0[__mn[0][0]]
+                    layer = self.vlayer[__mn[0][0]]
+                    if self.xcolor is not None:
+                        color = self.xcolor[
+                            __mn[0][0] % self.xcolor.shape[0]
+                        ]  # xcolor is determined by its grid layer.
+                    else:
+                        color = None
+                else:
+                    width = self.hwidth[__mn[0][1]]
+                    hextension = self.hextension0[__mn[0][1]]
+                    vextension = int(width / 2)
+                    layer = self.hlayer[__mn[0][1]]
+                    if self.ycolor is not None:
+                        color = self.ycolor[
+                            __mn[0][1] % self.ycolor.shape[0]
+                        ]  # ycolor is determined by its grid layer.
+                    else:
+                        color = None
+            else:
+                if (xy0[0] == xy1[0]) or (direction == "vertical"):  # vertical routing
+                    width = self.vwidth[__mn[0][0]]
+                    hextension = int(width / 2)
+                    vextension = self.vextension[__mn[0][0]]
+                    layer = self.vlayer[__mn[0][0]]
+                    if self.xcolor is not None:
+                        color = self.xcolor[
+                            __mn[0][0] % self.xcolor.shape[0]
+                        ]  # xcolor is determined by its grid layer.
+                    else:
+                        color = None
+                else:  # horizontal routing
+                    width = self.hwidth[__mn[0][1]]
+                    hextension = self.hextension[__mn[0][1]]
+                    vextension = int(width / 2)
+                    layer = self.hlayer[__mn[0][1]]
+                    if self.ycolor is not None:
+                        color = self.ycolor[
+                            __mn[0][1] % self.ycolor.shape[0]
+                        ]  # ycolor is determined by its grid layer.
+                    else:
+                        color = None
+            p = laygo2.object.physical.Rect(
+                xy=_xy,
+                layer=layer,
+                hextension=hextension,
+                vextension=vextension,
+                color=color,
+            )
+            route.append(p)
+            # via placement
+            if via_tag is None:
+                if (i > 0) and (i < mn.shape[0] - 1):
+                    route.append(self.via(mn=__mn[0], params=None))
+            else:
+                if via_tag[i + 1] == True:
+                    route.append(self.via(mn=__mn[1], params=None))
+        if len(route) == 1:  # not isinstance(mn[0][0], list):
+            return route[0]
+        else:
+            return route
+
+    def via(self, mn=np.array([0, 0]), params=None):
+        """
+        Create Via object(s) on abstract grid.
+
+        Parameters
+        ----------
+        mn : list(numpy.ndarray)
+            Abstract coordinate(s) that specify location(s) to insert via(s).
+
+        Returns
+        -------
+        list(physical.PhysicalObject):
+            The list containing the generated via objects.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> from laygo2.object.grid import CircularMapping as CM
+        >>> from laygo2.object.grid import CircularMappingArray as CMA
+        >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
+        >>> from laygo2.object.template import NativeInstanceTemplate
+        >>> from laygo2.object.physical import Instance
+        >>> # Routing grid construction (not needed if laygo2_tech is set up).
+        >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
+        >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
+        >>> wv = CM([10])           # vertical (xgrid) width
+        >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
+        >>> ev = CM([10])           # vertical (xgrid) extension
+        >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
+        >>> e0v = CM([15])          # vert. extension (for zero-length wires)
+        >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
+        >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
+        >>> lh = CM([['M2', 'drawing']]*3, dtype=object)
+        >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
+        >>> plh = CM([['M2', 'pin']]*3, dtype=object)
+        >>> xcolor = CM([None], dtype=object)  # not multi-patterned
+        >>> ycolor = CM([None]*3, dtype=object)
+        >>> primary_grid = 'horizontal'
+        >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via
+        >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
+        >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
+                                               vwidth=wv, hwidth=wh,
+                                               vextension=ev, hextension=eh,
+                                               vlayer=lv, hlayer=lh,
+                                               pin_vlayer=plv, pin_hlayer=plh,
+                                               viamap=viamap, primary_grid=primary_grid,
+                                               xcolor=xcolor, ycolor=ycolor,
+                                               vextension0=e0v, hextension0=e0h)
+        >>> # Routing on grid
+        >>> mn_list = [[0, -2], [1, 0], [2, 5]]
+        >>> via = mygrid.via(mn=mn_list)
+        >>> print(via)
+        [<laygo2.object.physical.VirtualInstance object>,
+         <laygo2.object.physical.VirtualInstance object>,
+         <laygo2.object.physical.VirtualInstance object>]
+
+        .. image:: ../assets/img/object_grid_RoutingGrid_via.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** via 생성함수.
+
+        파라미터
+            - mn(list(numpy.ndarray)): via를 생성할 mn좌표. 복수 개 입력 가능.
+        반환값
+            - list(physical.PhysicalObject)): 생성된 via들을 담고 있는 list.
+        """
+        # If mn contains multiple coordinates (or objects), place iteratively.
+        if isinstance(mn, list):
+            if isinstance(mn[0], (int, np.integer)):  # It's actually a single coordinate.
+                return self.via(mn=np.asarray(mn), params=params)
+            else:
+                return [self.via(mn=_mn, params=params) for _mn in mn]
+        elif isinstance(mn, np.ndarray):
+            if isinstance(mn[0], (int, np.integer)):  # It's actually a single coordinate.
+                pass
+            else:
+                return np.array([self.via(mn=_mn, params=params) for _mn in mn])
+        if not isinstance(mn, tuple):
+            mn = tuple(mn)  # viamap (CircularMapping) works only with tuples
+        tvia = self.viamap[mn]
+        via = tvia.generate(params=params)
+        via.xy = self[mn]
+        return via
+
+    def route_via_track(self, mn, track, via_tag=[False, True]):
+        """
+        Perform routing on the specified track with accessing wires to mn.
+
+        Parameters
+        ----------
+        mn : list(numpy.ndarray)
+            list containing coordinates of the points being connected through a track
+        track : numpy.ndarray
+            list containing coordinate values and direction of a track.
+            Vertical tracks have [v, None] format, while horizontal tracks have [None, v] format
+            (v is the coordinates of the track).
+
+        Returns
+        -------
+        list:
+            The list containing the generated routing objects;
+            The last object corresponds to the routing object on the track.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> from laygo2.object.grid import CircularMapping as CM
+        >>> from laygo2.object.grid import CircularMappingArray as CMA
+        >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
+        >>> from laygo2.object.template import NativeInstanceTemplate
+        >>> from laygo2.object.physical import Instance
+        >>> # Routing grid construction (not needed if laygo2_tech is set up).
+        >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
+        >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
+        >>> wv = CM([10])           # vertical (xgrid) width
+        >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
+        >>> ev = CM([10])           # vertical (xgrid) extension
+        >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
+        >>> e0v = CM([15])          # vert. extension (for zero-length wires)
+        >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
+        >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
+        >>> lh = CM([['M2', 'drawing']]*3, dtype=object)
+        >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
+        >>> plh = CM([['M2', 'pin']]*3, dtype=object)
+        >>> xcolor = CM([None], dtype=object)  # not multi-patterned
+        >>> ycolor = CM([None]*3, dtype=object)
+        >>> primary_grid = 'horizontal'
+        >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via
+        >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
+        >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
+                                               vwidth=wv, hwidth=wh,
+                                               vextension=ev, hextension=eh,
+                                               vlayer=lv, hlayer=lh,
+                                               pin_vlayer=plv, pin_hlayer=plh,
+                                               viamap=viamap, primary_grid=primary_grid,
+                                               xcolor=xcolor, ycolor=ycolor,
+                                               vextension0=e0v, hextension0=e0h)
+        >>> # Routing on grid
+        >>> mn_list = [[0, -2], [1, 0], [2, 5], [3, 4], [4, 5], [5, 5]]
+        >>> track = g.route_via_track(mn=mn_list, track=[None, 0])
+        >>> print(track)
+        [[<laygo2.object.physical.Rect object>,
+          <laygo2.object.physical.VirtualInstance object>],
+          <laygo2.object.physical.VirtualInstance object>,
+         [<laygo2.object.physical.Rect object>,
+          <laygo2.object.physical.VirtualInstance object>],
+         [<laygo2.object.physical.Rect object>,
+          <laygo2.object.physical.VirtualInstance object>],
+         [<laygo2.object.physical.Rect object>,
+          <laygo2.object.physical.VirtualInstance object>],
+         [<laygo2.object.physical.Rect object>,
+          <laygo2.object.physical.VirtualInstance object>],
+          <laygo2.object.physical.Rect object>]
+
+        .. image:: ../assets/img/object_grid_RoutingGrid_route_via_track.png
+           :height: 250
+
+        Notes
+        -----
+        **(Korean)** wire 라우팅 함수, track을 기준점으로 routing을 진행한다.
+
+        파라미터
+            - track(numpy.ndarray): track의 좌표값과 방향을 담고 있는 list.
+                수직 트랙일 경우 [v, None],
+                수평 트랙일 경우 [None, v]의 형태를 가지고 있다 (v는 track의 좌표값).
+            - mn(list(numpy.ndarray)): track을 통해 연결될 지점들의 좌표를 담고 있는 list.
+        반환값
+            - list: 생성된 routing object들을 담고 있는 list.
+                마지막 object가 track위의 routing object에 해당.
+        """
+        mn = np.array(mn)
+        route = list()
+
+        if track[1] != None:  # x direction
+            t = 0  # index of track axis
+            p = 1  # index of perpendicular track
+            mn_pivot = track[1]
+        else:  # y direction
+            t = 1
+            p = 0
+            mn_pivot = track[0]
+
+        mn_b = np.array([[0, 0], [0, 0]])  # 1.branch
+        min_t, max_t = mn[0][t], mn[0][t]
+
+        for i in range(len(mn)):
+            mn_b[0] = mn[i]
+            mn_b[1][t] = mn_b[0][t]
+            mn_b[1][p] = mn_pivot
+            if np.array_equal(mn_b[0], mn_b[1]):  #### via only
+                route.append(self.via(mn=mn_b[0], params=None))
+            else:
+                route.append(self.route(mn=[mn_b[0], mn_b[1]], via_tag=via_tag))
+
+            center_t = mn[i][t]
+            if center_t < min_t:
+                min_t = center_t
+            elif max_t < center_t:
+                max_t = center_t
+
+        mn_track = np.array([[0, 0], [0, 0]])  # 2.track
+        mn_track[0][t], mn_track[0][p] = min_t, mn_pivot  # min
+        mn_track[1][t], mn_track[1][p] = max_t, mn_pivot  # max
+
+        if np.array_equal(mn_track[0], mn_track[1]):  # Skip
+            route.append(None)
+        else:
+            route.append(self.route(mn=mn_track))
+
+        return route
+
+    def pin(self, name, mn, direction=None, netname=None, params=None):
+        """
+        Create a Pin object over the abstract coordinates specified by mn,
+        on the specified routing grid.
+
+        Parameters
+        ----------
+        name : str
+            Pin name.
+        mn : numpy.ndarray
+            Abstract coordinates for generating Pin.
+        direction : str, optional.
+            Direction.
+        netname : str, optional.
+            Net name of Pin.
+        params : dict, optional
+            Pin attributes.
+
+        Returns
+        -------
+        laygo2.physical.Pin: The generated pin object.
+
+        Example
+        -------
+        >>> import laygo2
+        >>> from laygo2.object.grid import CircularMapping as CM
+        >>> from laygo2.object.grid import CircularMappingArray as CMA
+        >>> from laygo2.object.grid import OneDimGrid, RoutingGrid
+        >>> from laygo2.object.template import NativeInstanceTemplate
+        >>> # Routing grid construction (not needed if laygo2_tech is set up).
+        >>> gv = OneDimGrid(name="gv", scope=[0, 50], elements=[0])
+        >>> gh = OneDimGrid(name="gv", scope=[0, 100], elements=[0, 40, 60])
+        >>> wv = CM([10])           # vertical (xgrid) width
+        >>> wh = CM([20, 10, 10])   # horizontal (ygrid) width
+        >>> ev = CM([10])           # vertical (xgrid) extension
+        >>> eh = CM([10, 10, 10])   # horizontal (ygrid) extension
+        >>> e0v = CM([15])          # vert. extension (for zero-length wires)
+        >>> e0h = CM([15, 15, 15])  # hori. extension (for zero-length wires)
+        >>> lv = CM([['M1', 'drawing']], dtype=object)  # layer information
+        >>> lh = CM([['M2', 'drawing']]*3, dtype=object)
+        >>> plv = CM([['M1', 'pin']], dtype=object) # pin layers
+        >>> plh = CM([['M2', 'pin']]*3, dtype=object)
+        >>> xcolor = CM([None], dtype=object)  # not multi-patterned
+        >>> ycolor = CM([None]*3, dtype=object)
+        >>> primary_grid = 'horizontal'
+        >>> tvia = NativeInstanceTemplate(libname='tlib', cellname='via0')  # via
+        >>> viamap = CMA(elements=[[tvia, tvia, tvia]], dtype=object)
+        >>> g = laygo2.object.grid.RoutingGrid(name='mygrid', vgrid=gv, hgrid=gh,
+                                               vwidth=wv, hwidth=wh,
+                                               vextension=ev, hextension=eh,
+                                               vlayer=lv, hlayer=lh,
+                                               pin_vlayer=plv, pin_hlayer=plh,
+                                               viamap=viamap, primary_grid=primary_grid,
+                                               xcolor=xcolor, ycolor=ycolor,
+                                               vextension0=e0v, hextension0=e0h)
+        >>> mn = [[0, 0], [10, 10]]
+        >>> pin = g.pin(name="pin", grid=g, mn=mn)
+        >>> print(pin)
+        <laygo2.object.physical.Pin object at 0x0000028DABE3AB90>
+            name: pin,
+            class: Pin,
+            xy: [[0, -10], [500, 350]],
+            params: None, , layer: ['M2' 'pin'], netname: pin, shape: None,
+            master: None
+
+        Notes
+        -----
+        **(Korean)** pin 생성함수.
+
+        파라미터
+            - name(str): Pin 이름
+            - mn(numpy.ndarray): Pin을 생성할 abstract 좌표
+            - direction(str): 방향 [optional]
+            - netname(str): Pin의 net이름 [optional]
+            - params(dict): Pin 속성 [optional]
+        반환값
+            - laygo2.physical.Pin: Pin object
+        """
+        xy0 = self.abs2phy[mn[0]]
+        xy1 = self.abs2phy[mn[1]]
+        # _xy = np.array([[xy0[0], xy0[1]], [xy1[0], xy1[1]]])
+        if np.all(xy0 == xy1):  # if two points are identical, generate a metal stub on the bottom layer.
+            if (direction == "vertical") or ((direction is None) and (self.primary_grid == "vertical")):
+                width = self.vwidth[mn[0][0]]
+                hextension = int(width / 2)
+                vextension = 0
+                layer = self.pin_vlayer[mn[0][0]]
+            else:
+                width = self.hwidth[mn[0][1]]
+                hextension = 0
+                vextension = int(width / 2)
+                layer = self.pin_hlayer[mn[0][1]]
+        else:
+            if (xy0[0] == xy1[0]) or (direction == "vertical"):  # vertical routing
+                width = self.vwidth[mn[0][0]]
+                hextension = int(width / 2)
+                vextension = 0
+                layer = self.pin_vlayer[mn[0][0]]
+            else:  # horizontal routing
+                width = self.hwidth[mn[0][1]]
+                hextension = 0
+                vextension = int(width / 2)
+                layer = self.pin_hlayer[mn[0][1]]
+        # TODO: pin.xy differ from tech.py.
+        _xy = np.array(
+            [
+                [xy0[0] - hextension, xy0[1] - vextension],
+                [xy1[0] + hextension, xy1[1] + vextension],
+            ]
+        )  ## need to check
+        p = laygo2.object.physical.Pin(name=name, xy=_xy, layer=layer, netname=netname, params=params)
+        return p
+
+    def copy(self): 
+        """Copy the current RoutingGrid object.
+        """
+        name = self.name
+        vgrid = self.vgrid.copy()
+        hgrid = self.hgrid.copy()
+        vwidth = self.vwidth.copy()
+        hwidth = self.hwidth.copy()
+        vextension = self.vextension.copy()
+        hextension = self.hextension.copy()
+        vlayer = self.vlayer.copy()
+        hlayer = self.hlayer.copy()
+        pin_vlayer = self.pin_vlayer.copy()
+        pin_hlayer = self.pin_hlayer.copy()
+        viamap = self.viamap.copy()
+        xcolor = self.xcolor.copy()
+        ycolor = self.ycolor.copy()
+        primary_grid = self.primary_grid
+        vextension0 = self.vextension0.copy()
+        hextension0 = self.hextension0.copy()
+
+        rg = RoutingGrid(
+            name = name,
+            vgrid = vgrid,
+            hgrid = hgrid,
+            vwidth = vwidth,
+            hwidth = hwidth,
+            vextension = vextension,
+            hextension = hextension,
+            vlayer = vlayer,
+            hlayer = hlayer,
+            pin_vlayer = pin_vlayer,
+            pin_hlayer = pin_hlayer,
+            viamap = viamap,
+            xcolor = xcolor,
+            ycolor = ycolor,
+            primary_grid = primary_grid,
+            vextension0 = vextension0,
+            hextension0 = hextension0,
+        )
+        return rg
+
+    def vflip(self, copy=True):
+        """Flip the routing grid in vertical direction."""
+        if copy:
+            g = self.copy()
+        else:
+            g = self
+        g.hgrid.flip()
+        g.hwidth.flip()
+        g.hextension.flip()
+        g.hlayer.flip()
+        g.pin_hlayer.flip()
+        g.ycolor.flip()
+        g.viamap.flip(axis=1)
+        g.hextension0.flip()
+        return g
+
+    def hflip(self, copy=True):
+        """Flip the routing grid in horizontal direction."""
+        if copy:
+            g = self.copy()
+        else:
+            g = self
+        g.vgrid.flip()
+        g.vwidth.flip()
+        g.vextension.flip()
+        g.vlayer.flip()
+        g.pin_vlayer.flip()
+        g.xcolor.flip()
+        g.viamap.flip(axis=0)
+        g.vextension0.flip()
+        return g
+
+    def vstack(self, obj, copy=True):
+        """Stack routing grid(s) on top of the routing grid in vertical direction."""
+        if copy:
+            g = self.copy()
+        else:
+            g = self
+        if isinstance(obj, list):  # multiple stack
+            obj_list = obj
+        else:  # single stack
+            obj_list = [obj]
+        # compute the grid range first
+        grid_ofst = g.hgrid.width
+        for _obj in obj_list:
+            g.hgrid.range[1] += _obj.hgrid.width
+        # stack
+        for _obj in obj_list:
+            for i, h in enumerate(_obj.hgrid):
+                # Check if the new grid element exist in the current grid already.
+                val = (h - _obj.hgrid.range[0]) + grid_ofst
+                val = val % (g.hgrid.width)  # modulo
+                if not (val in g.hgrid):
+                    # Unique element
+                    g.hgrid.append(val + g.hgrid.range[0])
+                    #g.hgrid.append(h - _obj.hgrid.range[0] + g.hgrid.range[0] + grid_ofst)
+                    g.hwidth.append(_obj.hwidth[i])
+                    g.hextension.append(_obj.hextension[i])
+                    g.hlayer.append(_obj.hlayer[i])
+                    g.pin_hlayer.append(_obj.pin_hlayer[i])
+                    g.ycolor.append(_obj.ycolor[i])
+                    g.hextension0.append(_obj.hextension0[i])
+                    elem = np.expand_dims(_obj.viamap.elements[:, i], axis=0)
+                    # hstack due to the transposition of numpy array and cartesian system.
+                    g.viamap.elements = np.hstack((g.viamap.elements, elem)) 
+            grid_ofst += _obj.hgrid.width  # increse offset
+        # Do not use the following code, 
+        # as it does not work when stacking multiple grids with elements at boundaries. 
+        '''
+        if isinstance(obj, list):  # Multiple stack.
+            for o in obj:
+                g = g.vstack(o, copy=copy)
+            return g
+        for i, h in enumerate(obj.hgrid):
+            # Check if the new grid element exist in the current grid already.
+            val = (h - obj.hgrid.range[0]) + g.hgrid.width  
+            val = val % (g.hgrid.width + obj.hgrid.width)  # modulo
+            if not (val in g.hgrid):
+                # Unique element
+                g.hgrid.append(h + g.hgrid.range[1])
+                g.hwidth.append(obj.hwidth[i])
+                g.hextension.append(obj.hextension[i])
+                g.hlayer.append(obj.hlayer[i])
+                g.pin_hlayer.append(obj.pin_hlayer[i])
+                g.ycolor.append(obj.ycolor[i])
+                g.hextension0.append(obj.hextension0[i])
+                elem = np.expand_dims(obj.viamap.elements[:, i], axis=0)
+                # hstack due to the transposition of numpy array and cartesian system.
+                g.viamap.elements = np.hstack((g.viamap.elements, elem)) 
+        g.hgrid.range[1] += obj.hgrid.width
+        '''
+        return g
+
+    def hstack(self, obj, copy=True):
+        """Stack routing grid(s) on top of the routing grid in horizontal direction."""
+        if copy:
+            g = self.copy()
+        else:
+            g = self
+        if isinstance(obj, list):  # Multiple stack.
+            for o in obj:
+                g = g.hstack(o, copy=copy)
+            return g
+        for i, v in enumerate(obj.vgrid):
+            # Check if the new grid element exist in the current grid already.
+            val = (v - obj.vgrid.range[0]) + g.vgrid.width  
+            val = val % (g.vgrid.width + obj.vgrid.width)  # modulo
+            if not (val in g.vgrid):
+                # Unique element
+                g.vgrid.append(v + g.vgrid.range[1])
+                g.vwidth.append(obj.vwidth[i])
+                g.vextension.append(obj.vextension[i])
+                g.vlayer.append(obj.vlayer[i])
+                g.pin_vlayer.append(obj.pin_vlayer[i])
+                g.xcolor.append(obj.xcolor[i])
+                g.vextension0.append(obj.vextension0[i])
+                elem = np.expand_dims(obj.viamap.elements[i, :], axis=0)
+                # vstack due to the transposition of numpy array and cartesian system.
+                g.viamap.elements = np.vstack((g.viamap.elements, elem)) 
+        g.vgrid.range[1] += obj.vgrid.width
+        return g
+
+
+    def summarize(self):
+        """Summarize object information."""
+        return (
+            Grid.summarize(self) 
+            + " vwidth: " + str(self.vwidth) + "\n"
+            + " hwidth: " + str(self.hwidth) + "\n"
+            + " vextension: " + str(self.vextension) + "\n"
+            + " hextension: " + str(self.hextension) + "\n"
+            + " vextension0: " + str(self.vextension0) + "\n"
+            + " hextension0: " + str(self.hextension0) + "\n"
+            + " vlayer: " + str(self.vlayer) + "\n"
+            + " hlayer: " + str(self.hlayer) + "\n"
+            + " primary_grid: " + str(self.primary_grid) + "\n"
+            + " xcolor: " + str(self.xcolor) + "\n"
+            + " ycolor: " + str(self.ycolor) + "\n"
+            + " viamap: " + str(self.viamap) + "\n"
+        )
+
```

### Comparing `laygo2-0.5.6/laygo2/interface/skillbridge.py` & `laygo2-0.5.7/laygo2/interface/skillbridge.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,108 +1,108 @@
-#!/usr/bin/python
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-"""
-This module implements interface with Skillbridge in skill language
-"""
-import laygo2.interface
-
-
-def export(
-    db,
-    filename,
-    cellname,
-    scale=1e-3,
-    reset_library=False,
-    tech_library=None,
-    pyserver_id=None,
-):
-    """
-    Export a laygo2.object.database.Library object to Cadence Virtuoso via 
-    skillbridge.
-
-    Parameters
-    ----------
-    db: laygo2.database.Library
-        The library database to be exported.
-    filename: str, optional
-        The path of the intermediate skill script file.
-    cellname: str or List[str]
-        The name(s) of cell(s) to be exported.
-    scale: float
-        The scaling factor between laygo2's integer coordinats actual physical coordinates.
-    reset_library: bool, optional
-        If True, the library to export the cells is reset.
-    tech_library: str, optional
-        The name of technology library to be attached to the resetted library.
-
-    Returns
-    -------
-    str: The generated skill script.
-
-    Example
-    --------
-    >>> import laygo2
-    >>> from laygo2.object.database import Design
-    >>> from laygo2.object.physical import Rect, Pin, Instance, Text
-    >>> # Create a design.
-    >>> dsn = Design(name="mycell", libname="genlib")
-    >>> # Create layout objects.
-    >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
-    >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
-    >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
-    >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
-    >>> # Add the layout objects to the design object.
-    >>> dsn.append(r0)
-    >>> dsn.append(p0)
-    >>> dsn.append(i0)
-    >>> dsn.append(t0)
-    >>> # 
-    >>> # Export to skillbridge.
-    >>> lib = laygo2.object.database.Library(name="mylib")
-    >>> lib.append(dsn)
-    >>> scr = laygo2.interface.skillbridge.export(lib, filename="myscript.il")
-    >>> print(scr)
-    ; (definitions of laygo2 skill functions)
-    ; exporting mylib__mycell
-    cv = _laygo2_open_layout("mylib" "mycell" "layout")
-    _laygo2_generate_rect(cv, list( "M1" "drawing" ), list( list( 0.0000  0.0000  ) list( 0.1000  0.1000  ) ), "None")
-    _laygo2_generate_pin(cv, "P", list( "M1" "pin" ), list( list( 0.0000  0.0000  ) list( 0.0500  0.0500  ) ) )
-    _laygo2_generate_instance(cv, "I0", "tlib", "t0", "layout", list( 0.0000  0.0000  ), "R0", 1, 1, 0, 0, nil, nil)
-    _laygo2_save_and_close_layout(cv)
-    """
-    skill_str = laygo2.interface.skill.export(
-        db, filename, cellname, scale, reset_library, tech_library
-    )
-
-    # Export skill script to skillbridge
-    import os
-    from skillbridge import Workspace
-
-    # ws = Workspace.open(os.environ['USER'])
-    if pyserver_id is None:
-        ws = Workspace.open()
-    else:
-        ws = Workspace.open(pyserver_id)
-    ws["load"](filename)
-
-    return skill_str
+#!/usr/bin/python
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+"""
+This module implements interface with Skillbridge in skill language
+"""
+import laygo2.interface
+
+
+def export(
+    db,
+    filename,
+    cellname,
+    scale=1e-3,
+    reset_library=False,
+    tech_library=None,
+    pyserver_id=None,
+):
+    """
+    Export a laygo2.object.database.Library object to Cadence Virtuoso via 
+    skillbridge.
+
+    Parameters
+    ----------
+    db: laygo2.database.Library
+        The library database to be exported.
+    filename: str, optional
+        The path of the intermediate skill script file.
+    cellname: str or List[str]
+        The name(s) of cell(s) to be exported.
+    scale: float
+        The scaling factor between laygo2's integer coordinats actual physical coordinates.
+    reset_library: bool, optional
+        If True, the library to export the cells is reset.
+    tech_library: str, optional
+        The name of technology library to be attached to the resetted library.
+
+    Returns
+    -------
+    str: The generated skill script.
+
+    Example
+    --------
+    >>> import laygo2
+    >>> from laygo2.object.database import Design
+    >>> from laygo2.object.physical import Rect, Pin, Instance, Text
+    >>> # Create a design.
+    >>> dsn = Design(name="mycell", libname="genlib")
+    >>> # Create layout objects.
+    >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
+    >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
+    >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
+    >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
+    >>> # Add the layout objects to the design object.
+    >>> dsn.append(r0)
+    >>> dsn.append(p0)
+    >>> dsn.append(i0)
+    >>> dsn.append(t0)
+    >>> # 
+    >>> # Export to skillbridge.
+    >>> lib = laygo2.object.database.Library(name="mylib")
+    >>> lib.append(dsn)
+    >>> scr = laygo2.interface.skillbridge.export(lib, filename="myscript.il")
+    >>> print(scr)
+    ; (definitions of laygo2 skill functions)
+    ; exporting mylib__mycell
+    cv = _laygo2_open_layout("mylib" "mycell" "layout")
+    _laygo2_generate_rect(cv, list( "M1" "drawing" ), list( list( 0.0000  0.0000  ) list( 0.1000  0.1000  ) ), "None")
+    _laygo2_generate_pin(cv, "P", list( "M1" "pin" ), list( list( 0.0000  0.0000  ) list( 0.0500  0.0500  ) ) )
+    _laygo2_generate_instance(cv, "I0", "tlib", "t0", "layout", list( 0.0000  0.0000  ), "R0", 1, 1, 0, 0, nil, nil)
+    _laygo2_save_and_close_layout(cv)
+    """
+    skill_str = laygo2.interface.skill.export(
+        db, filename, cellname, scale, reset_library, tech_library
+    )
+
+    # Export skill script to skillbridge
+    import os
+    from skillbridge import Workspace
+
+    # ws = Workspace.open(os.environ['USER'])
+    if pyserver_id is None:
+        ws = Workspace.open()
+    else:
+        ws = Workspace.open(pyserver_id)
+    ws["load"](filename)
+
+    return skill_str
```

### Comparing `laygo2-0.5.6/laygo2/interface/gdspy.py` & `laygo2-0.5.7/laygo2/interface/gdspy.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,313 +1,313 @@
-#!/usr/bin/python
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-"""
-This module implements interfaces with gds files via gdspy.
-"""
-
-import logging
-import pprint
-from math import log10
-from decimal import *
-import laygo2.util.transform as tf
-
-import numpy as np
-
-import laygo2.object
-
-
-def _load_layermap(layermapfile):
-    """
-    Load layermap information from layermapfile (Foundry techfile can be used)
-
-    Parameters
-    ----------
-    layermapfile : str
-        layermap filename.
-
-        The example file can be found in default.layermap or see below:
-        #technology layer information
-        #layername  layerpurpose stream# datatype
-        text        drawing 100 0
-        prBoundary  drawing 101 0
-        M1      drawing 50  0
-        M1      pin     50  10
-        M2      drawing 51  0
-        M2      pin     51  10
-
-    Returns
-    -------
-    dict
-        constructed layermap information.
-
-    """
-    layermap = dict()
-    f = open(layermapfile, "r")
-    for line in f:
-        tokens = line.split()
-        if not len(tokens) == 0:
-            if not tokens[0].startswith("#"):
-                name = tokens[0]
-                # if not layermap.has_key(name):
-                if name not in layermap:
-                    layermap[name] = dict()
-                layermap[name][tokens[1]] = {
-                    "layer": int(tokens[2]),
-                    "datatype": int(tokens[3]),
-                }
-    return layermap
-
-
-def _translate_obj(
-    objname,
-    obj,
-    layermap,
-    scale=0.001,
-    master=None,
-    offset=np.array([0, 0]),
-    pin_label_height=0.1,
-):
-    """
-    Convert an object to corresponding skill commands.
-    offset : np.array([int, int])
-        Offsets to obj.xy
-    """
-    # import gdspy here to avoid unnecessary C++ compliations for non-gds options.
-    import gdspy
-
-    if master is None:
-        mxy = np.array([0, 0])
-        mtf = "R0"
-    else:  # if the translated object has a master (e.g. VirtualInstance)
-        mxy = master.xy
-        mtf = master.transform
-
-    if obj.__class__ == laygo2.object.Rect:
-        ## TODO: add color handling.
-        # color = obj.color # coloring function example for skill.
-
-        _xy = np.sort(obj.xy, axis=0)  # make sure obj.xy is sorted
-        _xy = mxy + np.dot(
-            _xy
-            + np.array(
-                [[-obj.hextension, -obj.vextension], [obj.hextension, obj.vextension]]
-            ),
-            tf.Mt(mtf).T,
-        )
-
-        l = layermap[obj.layer[0]][obj.layer[1]]
-        rect = gdspy.Rectangle((_xy[0, 0], _xy[0, 1]), (_xy[1, 0], _xy[1, 1]), **l)
-        return rect
-    elif obj.__class__ == laygo2.object.Path:
-        # TODO: implement path export function.
-        pass
-    elif obj.__class__ == laygo2.object.Pin:
-        if obj.elements is None:
-            _objelem = [obj]
-        else:
-            _objelem = obj.elements
-        item = []
-        for idx, _obj in np.ndenumerate(_objelem):
-            _xy = mxy + np.dot(_obj.xy, tf.Mt(mtf).T)
-            l = layermap[_obj.layer[0]][_obj.layer[1]]
-            rect = gdspy.Rectangle((_xy[0, 0], _xy[0, 1]), (_xy[1, 0], _xy[1, 1]), **l)
-            _xy_c = 0.5 * (_xy[0, :] + _xy[1, :])
-            text = gdspy.Label(
-                _obj.netname, _xy_c, "nw", magnification=pin_label_height * 100
-            )
-            item += [rect, text]
-        return item
-    elif obj.__class__ == laygo2.object.Text:
-        # TODO: implement text export function.
-        pass
-    elif obj.__class__ == laygo2.object.Instance:
-        print(
-            "[Warning] laygo2.interface.gdspy: Instance transform is not implemented yet."
-        )
-        _xy = mxy + np.dot(obj.xy, tf.Mt(mtf).T)
-        if master is None:
-            transform = obj.transform
-        else:  # if the translated object has a master (e.g. VirtualInstance)
-            transform = tf.combine(obj.transform, master.transform)
-        if obj.shape is None:
-            num_rows = 1
-            num_cols = 1
-            sp_rows = 0
-            sp_cols = 0
-        else:
-            num_rows = obj.shape[1]
-            num_cols = obj.shape[0]
-            sp_rows = obj.pitch[1]
-            sp_cols = obj.pitch[0]
-        # if obj.params is None:  # gds cannot handle pcell parameters.
-        #    inst_params = "nil"
-        # else:
-        #    inst_params = _py2skill_inst_params(obj.params['pcell_params'])
-        inst = gdspy.CellReference(obj.cellname, _xy)  # , transform)
-        return inst
-    elif obj.__class__ == laygo2.object.VirtualInstance:
-        item = []
-        if obj.shape is None:
-            for elem_name, elem in obj.native_elements.items():
-                if not elem.__class__ == laygo2.object.Pin:
-                    if obj.name == None:
-                        obj.name = "NoName"
-                    else:
-                        pass
-                    item += [
-                        _translate_obj(
-                            obj.name + "_" + elem_name,
-                            elem,
-                            layermap=layermap,
-                            master=obj,
-                            scale=scale,
-                            pin_label_height=pin_label_height,
-                        )
-                    ]
-        else:  # arrayed VirtualInstance
-            for i, j in np.ndindex(tuple(obj.shape.tolist())):  # iterate over obj.shape
-                for elem_name, elem in obj.native_elements.items():
-                    if not elem.__class__ == laygo2.object.Pin:
-                        item += [
-                            _translate_obj(
-                                obj.name + "_" + elem_name + str(i) + "_" + str(j),
-                                elem,
-                                layermap=layermap,
-                                master=obj[i, j],
-                                scale=scale,
-                                pin_label_height=pin_label_height,
-                            )
-                        ]
-        return item
-    return None
-    # raise Exception("No corresponding GDS structure for:"+obj.summarize())
-
-
-def export(
-    db,
-    filename,
-    cellname=None,
-    scale=1e-9,
-    layermapfile="default.layermap",
-    physical_unit=1e-9,
-    logical_unit=0.001,
-    pin_label_height=0.1,
-    svg_filename=None,
-    png_filename=None,
-):
-    """
-    Export a laygo2.object.database.Library object to a gds file via gdspy.
-
-    Parameters
-    ----------
-    db: laygo2.database.Library
-        The library database to exported.
-    filename: str, optional
-        The name of output gds file.
-    cellname: str or List[str]
-        The name(s) of cell(s) to be exported.
-    scale: float
-        The scaling factor between laygo2's integer coordinats actual physical coordinates.
-    layermapfile : str
-        the name of layermap file.
-    physical_unit : float, optional
-        GDS physical unit.
-    logical_unit : float, optional
-        GDS logical unit.
-    pin_label_height : float, optional
-        the height of pin label.
-    svg_filename: str, optional
-        If specified, it exports a svg file with the specified filename.
-    svg_filename: str, optional
-        If specified, it exports a png file with the specified filename
-        (svg_filename needs to be specified as well).
-
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.database import Design
-    >>> from laygo2.object.physical import Rect, Pin, Instance, Text
-    >>> # Create a design.
-    >>> dsn = Design(name="mycell", libname="genlib")
-    >>> # Create layout objects.
-    >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
-    >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
-    >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
-    >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
-    >>> # Add the layout objects to the design object.
-    >>> dsn.append(r0)
-    >>> dsn.append(p0)
-    >>> dsn.append(i0)
-    >>> dsn.append(t0)
-    >>> #
-    >>> # Export to a gds file.
-    >>> lib = laygo2.object.database.Library(name="mylib")
-    >>> lib.append(dsn)
-    >>> laygo2.interface.gds.export(lib, filename="mylayout.gds")
-    """
-    # Compute scale parameter.
-    _scale = round(1 / scale * physical_unit / logical_unit)
-    # 1um in phy
-    # 1um/1nm = 1000 in laygo2 if scale = 1e-9 (1nm)
-    # 1000/1nm*1nm/0.001 = 1000000 in gds if physical_unit = 1e-9 (1nm) and logical_unit = 0.001
-
-    # Load layermap file.
-    layermap = _load_layermap(layermapfile)  # load layermap information
-
-    # Construct cellname.
-    cellname = (
-        db.keys() if cellname is None else cellname
-    )  # export all cells if cellname is not given.
-    cellname = (
-        [cellname] if isinstance(cellname, str) else cellname
-    )  # convert to a list for iteration.
-
-    # import gdspy here to avoid unnecessary C++ compliations for non-gds options.
-    import gdspy
-
-    # Create library.
-    lib = gdspy.GdsLibrary()
-    for cn in cellname:
-        # Create cell.
-        cell = lib.new_cell(cn)
-        # Translate objects.
-        for objname, obj in db[cn].items():
-            tobj = _translate_obj(
-                objname,
-                obj,
-                layermap=layermap,
-                scale=_scale,
-                pin_label_height=pin_label_height,
-            )
-            if tobj is not None:
-                cell.add(tobj)
-    lib.write_gds(filename)
-    if svg_filename is not None:
-        cell.write_svg(svg_filename)
-        if svg_filename is not None:
-            # import cairosvg here to avoid unnecessary lib installation for non-gds options.
-            import cairosvg
-
-            cairosvg.svg2png(url=svg_filename, write_to=png_filename, scale=1.0)
-    # gdspy.LayoutViewer()
+#!/usr/bin/python
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+"""
+This module implements interfaces with gds files via gdspy.
+"""
+
+import logging
+import pprint
+from math import log10
+from decimal import *
+import laygo2.util.transform as tf
+
+import numpy as np
+
+import laygo2.object
+
+
+def _load_layermap(layermapfile):
+    """
+    Load layermap information from layermapfile (Foundry techfile can be used)
+
+    Parameters
+    ----------
+    layermapfile : str
+        layermap filename.
+
+        The example file can be found in default.layermap or see below:
+        #technology layer information
+        #layername  layerpurpose stream# datatype
+        text        drawing 100 0
+        prBoundary  drawing 101 0
+        M1      drawing 50  0
+        M1      pin     50  10
+        M2      drawing 51  0
+        M2      pin     51  10
+
+    Returns
+    -------
+    dict
+        constructed layermap information.
+
+    """
+    layermap = dict()
+    f = open(layermapfile, "r")
+    for line in f:
+        tokens = line.split()
+        if not len(tokens) == 0:
+            if not tokens[0].startswith("#"):
+                name = tokens[0]
+                # if not layermap.has_key(name):
+                if name not in layermap:
+                    layermap[name] = dict()
+                layermap[name][tokens[1]] = {
+                    "layer": int(tokens[2]),
+                    "datatype": int(tokens[3]),
+                }
+    return layermap
+
+
+def _translate_obj(
+    objname,
+    obj,
+    layermap,
+    scale=0.001,
+    master=None,
+    offset=np.array([0, 0]),
+    pin_label_height=0.1,
+):
+    """
+    Convert an object to corresponding skill commands.
+    offset : np.array([int, int])
+        Offsets to obj.xy
+    """
+    # import gdspy here to avoid unnecessary C++ compliations for non-gds options.
+    import gdspy
+
+    if master is None:
+        mxy = np.array([0, 0])
+        mtf = "R0"
+    else:  # if the translated object has a master (e.g. VirtualInstance)
+        mxy = master.xy
+        mtf = master.transform
+
+    if obj.__class__ == laygo2.object.Rect:
+        ## TODO: add color handling.
+        # color = obj.color # coloring function example for skill.
+
+        _xy = np.sort(obj.xy, axis=0)  # make sure obj.xy is sorted
+        _xy = mxy + np.dot(
+            _xy
+            + np.array(
+                [[-obj.hextension, -obj.vextension], [obj.hextension, obj.vextension]]
+            ),
+            tf.Mt(mtf).T,
+        )
+
+        l = layermap[obj.layer[0]][obj.layer[1]]
+        rect = gdspy.Rectangle((_xy[0, 0], _xy[0, 1]), (_xy[1, 0], _xy[1, 1]), **l)
+        return rect
+    elif obj.__class__ == laygo2.object.Path:
+        # TODO: implement path export function.
+        pass
+    elif obj.__class__ == laygo2.object.Pin:
+        if obj.elements is None:
+            _objelem = [obj]
+        else:
+            _objelem = obj.elements
+        item = []
+        for idx, _obj in np.ndenumerate(_objelem):
+            _xy = mxy + np.dot(_obj.xy, tf.Mt(mtf).T)
+            l = layermap[_obj.layer[0]][_obj.layer[1]]
+            rect = gdspy.Rectangle((_xy[0, 0], _xy[0, 1]), (_xy[1, 0], _xy[1, 1]), **l)
+            _xy_c = 0.5 * (_xy[0, :] + _xy[1, :])
+            text = gdspy.Label(
+                _obj.netname, _xy_c, "nw", magnification=pin_label_height * 100
+            )
+            item += [rect, text]
+        return item
+    elif obj.__class__ == laygo2.object.Text:
+        # TODO: implement text export function.
+        pass
+    elif obj.__class__ == laygo2.object.Instance:
+        print(
+            "[Warning] laygo2.interface.gdspy: Instance transform is not implemented yet."
+        )
+        _xy = mxy + np.dot(obj.xy, tf.Mt(mtf).T)
+        if master is None:
+            transform = obj.transform
+        else:  # if the translated object has a master (e.g. VirtualInstance)
+            transform = tf.combine(obj.transform, master.transform)
+        if obj.shape is None:
+            num_rows = 1
+            num_cols = 1
+            sp_rows = 0
+            sp_cols = 0
+        else:
+            num_rows = obj.shape[1]
+            num_cols = obj.shape[0]
+            sp_rows = obj.pitch[1]
+            sp_cols = obj.pitch[0]
+        # if obj.params is None:  # gds cannot handle pcell parameters.
+        #    inst_params = "nil"
+        # else:
+        #    inst_params = _py2skill_inst_params(obj.params['pcell_params'])
+        inst = gdspy.CellReference(obj.cellname, _xy)  # , transform)
+        return inst
+    elif obj.__class__ == laygo2.object.VirtualInstance:
+        item = []
+        if obj.shape is None:
+            for elem_name, elem in obj.native_elements.items():
+                if not elem.__class__ == laygo2.object.Pin:
+                    if obj.name == None:
+                        obj.name = "NoName"
+                    else:
+                        pass
+                    item += [
+                        _translate_obj(
+                            obj.name + "_" + elem_name,
+                            elem,
+                            layermap=layermap,
+                            master=obj,
+                            scale=scale,
+                            pin_label_height=pin_label_height,
+                        )
+                    ]
+        else:  # arrayed VirtualInstance
+            for i, j in np.ndindex(tuple(obj.shape.tolist())):  # iterate over obj.shape
+                for elem_name, elem in obj.native_elements.items():
+                    if not elem.__class__ == laygo2.object.Pin:
+                        item += [
+                            _translate_obj(
+                                obj.name + "_" + elem_name + str(i) + "_" + str(j),
+                                elem,
+                                layermap=layermap,
+                                master=obj[i, j],
+                                scale=scale,
+                                pin_label_height=pin_label_height,
+                            )
+                        ]
+        return item
+    return None
+    # raise Exception("No corresponding GDS structure for:"+obj.summarize())
+
+
+def export(
+    db,
+    filename,
+    cellname=None,
+    scale=1e-9,
+    layermapfile="default.layermap",
+    physical_unit=1e-9,
+    logical_unit=0.001,
+    pin_label_height=0.1,
+    svg_filename=None,
+    png_filename=None,
+):
+    """
+    Export a laygo2.object.database.Library object to a gds file via gdspy.
+
+    Parameters
+    ----------
+    db: laygo2.database.Library
+        The library database to exported.
+    filename: str, optional
+        The name of output gds file.
+    cellname: str or List[str]
+        The name(s) of cell(s) to be exported.
+    scale: float
+        The scaling factor between laygo2's integer coordinats actual physical coordinates.
+    layermapfile : str
+        the name of layermap file.
+    physical_unit : float, optional
+        GDS physical unit.
+    logical_unit : float, optional
+        GDS logical unit.
+    pin_label_height : float, optional
+        the height of pin label.
+    svg_filename: str, optional
+        If specified, it exports a svg file with the specified filename.
+    svg_filename: str, optional
+        If specified, it exports a png file with the specified filename
+        (svg_filename needs to be specified as well).
+
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.database import Design
+    >>> from laygo2.object.physical import Rect, Pin, Instance, Text
+    >>> # Create a design.
+    >>> dsn = Design(name="mycell", libname="genlib")
+    >>> # Create layout objects.
+    >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
+    >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
+    >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
+    >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
+    >>> # Add the layout objects to the design object.
+    >>> dsn.append(r0)
+    >>> dsn.append(p0)
+    >>> dsn.append(i0)
+    >>> dsn.append(t0)
+    >>> #
+    >>> # Export to a gds file.
+    >>> lib = laygo2.object.database.Library(name="mylib")
+    >>> lib.append(dsn)
+    >>> laygo2.interface.gds.export(lib, filename="mylayout.gds")
+    """
+    # Compute scale parameter.
+    _scale = round(1 / scale * physical_unit / logical_unit)
+    # 1um in phy
+    # 1um/1nm = 1000 in laygo2 if scale = 1e-9 (1nm)
+    # 1000/1nm*1nm/0.001 = 1000000 in gds if physical_unit = 1e-9 (1nm) and logical_unit = 0.001
+
+    # Load layermap file.
+    layermap = _load_layermap(layermapfile)  # load layermap information
+
+    # Construct cellname.
+    cellname = (
+        db.keys() if cellname is None else cellname
+    )  # export all cells if cellname is not given.
+    cellname = (
+        [cellname] if isinstance(cellname, str) else cellname
+    )  # convert to a list for iteration.
+
+    # import gdspy here to avoid unnecessary C++ compliations for non-gds options.
+    import gdspy
+
+    # Create library.
+    lib = gdspy.GdsLibrary()
+    for cn in cellname:
+        # Create cell.
+        cell = lib.new_cell(cn)
+        # Translate objects.
+        for objname, obj in db[cn].items():
+            tobj = _translate_obj(
+                objname,
+                obj,
+                layermap=layermap,
+                scale=_scale,
+                pin_label_height=pin_label_height,
+            )
+            if tobj is not None:
+                cell.add(tobj)
+    lib.write_gds(filename)
+    if svg_filename is not None:
+        cell.write_svg(svg_filename)
+        if svg_filename is not None:
+            # import cairosvg here to avoid unnecessary lib installation for non-gds options.
+            import cairosvg
+
+            cairosvg.svg2png(url=svg_filename, write_to=png_filename, scale=1.0)
+    # gdspy.LayoutViewer()
```

### Comparing `laygo2-0.5.6/laygo2/interface/magic.py` & `laygo2-0.5.7/laygo2/interface/magic.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,270 +1,270 @@
-#!/usr/bin/python
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-import logging
-from math import log10
-from decimal import *
-
-import numpy as np
-import laygo2.object
-import laygo2.util.transform as tf
-
-__author__ = ""
-__maintainer__ = ""
-__status__ = "Prototype"
-
-
-def _py2magic_number(value, scale=1):
-    fmt_str = "%." + "%d" % (-1 * log10(scale) + 1) + "f "  # for truncations
-    return fmt_str % (value * scale)
-
-def _py2magic_list(pylist, scale=1):
-    """Convert a python list object to a magic(tcl) list."""
-    list_str = "{ "
-    for item in pylist:
-        if isinstance(item, list):  # nested list
-            list_str += _py2magic_list(item, scale=scale) + " "
-        elif isinstance(item, np.ndarray):  # nested list
-            list_str += _py2magic_list(item, scale=scale) + " "
-        elif isinstance(item, str):
-            list_str += "\"" + str(item) + "\" "
-        elif isinstance(item, int) or isinstance(item, np.integer):
-            # fmt_str = "%."+"%d" % (-1*log10(scale)+1)+"f "  # for truncations
-            # list_str += fmt_str%(item*scale) + " "
-            list_str += _py2magic_number(item, scale=scale) + " "
-    list_str += "}"
-    return list_str
-
-
-def _translate_obj(libpath, objname, obj, scale=1, master=None, offset=np.array([0, 0])):
-    """
-    Convert an object to corresponding scale commands.
-    offset : np.array([int, int])
-        Offsets to obj.xy
-    """
-    global pin_info
-    if master is None:  
-        mxy = np.array([0, 0])
-        mtf = 'R0'
-    else: # if the translated object has a master (e.g. VirtualInstance)
-        mxy = master.xy
-        mtf = master.transform
-    if obj.__class__ == laygo2.object.Rect:
-    #    color = obj.color # coloring func. added
-        # Invoke _laygo2_generate_rect( cv layer bbox ) in {header_filename}
-        _xy = np.sort(obj.xy, axis=0)  # make sure obj.xy is sorted
-        _xy = mxy + np.dot(_xy + np.array([[-obj.hextension, -obj.vextension], [obj.hextension, obj.vextension]]),
-                           tf.Mt(mtf).T)
-        #_xy = mxy + np.dot(obj.xy + np.array([[-obj.hextension, -obj.vextension], [obj.hextension, obj.vextension]]),
-        #                   tf.Mt(mtf).T)
-    #    return "_laygo2_generate_rect(cv, %s, %s, \"%s\") ; # for the Rect object %s \n" \
-    #           % (_py2magic_list(obj.layer), _py2magic_list(_xy, scale=scale), objname) # coloring func. added
-        return "_laygo2_generate_rect %s %s ; # for the Rect object %s \n" \
-               % (obj.layer[0], _py2magic_list(_xy, scale=scale), objname) # coloring func. added
-    elif obj.__class__ == laygo2.object.Path:
-        # TODO: implement path export function.
-        pass
-    elif obj.__class__ == laygo2.object.Pin:
-        if obj.elements is None:
-            _objelem = [obj]
-        else:
-            _objelem = obj.elements
-        for idx, _obj in np.ndenumerate(_objelem):
-            # Invoke _laygo2_generate_pin(cv, name, layer, bbox) in {header_filename}
-            _xy = mxy + np.dot(_obj.xy, tf.Mt(mtf).T)
-            # return "_laygo2_generate_pin(cv, \"%s\", %s, %s ) ; # for the Pin object %s \n" \
-            #        % (_obj.netname, _py2magic_list(_obj.layer), _py2magic_list(_xy, scale=scale),
-            #           objname)
-            pin_info.append([_obj.netname, obj.layer[0], _py2magic_list(_xy, scale=scale), objname])
-            return ''
-    elif obj.__class__ == laygo2.object.Text:
-        # TODO: implement text export function.
-        pass
-    elif obj.__class__ == laygo2.object.Instance:
-        # Invoke _laygo2_generate_instance( cv name libname cellname viewname loc orient num_rows num_cols
-        # sp_rows sp_cols params params_order )
-        _xy = mxy + np.dot(obj.xy, tf.Mt(mtf).T)
-        if master is None:  
-            transform = obj.transform
-        else: # if the translated object has a master (e.g. VirtualInstance)
-            transform = tf.combine(obj.transform, master.transform)
-        if obj.shape is None:
-            num_rows = 1
-            num_cols = 1
-            sp_rows = 0
-            sp_cols = 0
-        else:
-            num_rows = obj.shape[1]
-            num_cols = obj.shape[0]
-            sp_rows = _py2magic_number(obj.pitch[1], scale=scale)
-            sp_cols = _py2magic_number(obj.pitch[0], scale=scale)
-# Problem: if there is no cell at '/WORK/hjpark/laygo2_workspace_sky130/magic_layout' but exist at search path, this function dosen't work 
-# Solution 1: change  '/WORK/hjpark/laygo2_workspace_sky130/magic_layout' -> libpath (from layout generating script not here)
-# Solution 2: just use search path generate_instance function don't care where the libpath is 
-# solution 1: has serious problem -> microtemplate_dense lib has to be inside of libpath  
-# current state solution 2
-        if obj.libname.find("_microtemplates_dense") != -1:
-            cellfile_name = obj.cellname
-        else:
-            cellfile_name = obj.libname + '_' + obj.cellname
-        return "_laygo2_generate_instance %s %s/%s %s %s %s %d %d %s %s " \
-               "; # for the Instance object %s \n" \
-               % (objname, libpath, obj.libname, cellfile_name, _py2magic_list(_xy, scale=scale), transform,
-                  num_rows, num_cols, sp_rows, sp_cols, objname) # /WORK/magc_layout -> temp libpath
-    elif obj.__class__ == laygo2.object.VirtualInstance:
-        cmd = ""
-        if obj.shape is None:
-            for elem_name, elem in obj.native_elements.items():
-                if not elem.__class__ == laygo2.object.Pin:
-                    if obj.name == None:
-                        obj.name='NoName'
-                    else:
-                        pass
-                    cmd += _translate_obj(libpath, obj.name + '_' + elem_name, elem, scale=scale, master=obj)
-        else:  # arrayed VirtualInstance
-            for i, j in np.ndindex(tuple(obj.shape.tolist())):  # iterate over obj.shape
-                for elem_name, elem in obj.native_elements.items():
-                    if not elem.__class__ == laygo2.object.Pin:
-                        cmd += _translate_obj(libpath, obj.name + '_' + elem_name + str(i) + '_' + str(j), 
-                                              elem, scale=scale, master=obj[i, j])            
-        return cmd
-    else:
-        return None
-
-    return ""
-
-def export(db, filename=None, cellname=None, libpath='./magic_layout', scale=1, 
-           reset_library=False, tech_library=None, gds_filename=None):
-    """
-    Export a laygo2.object.database.Library object to magic's tcl code.
-
-    Parameters
-    ----------
-    db: laygo2.database.Library
-        The library database to be exported.
-    filename: str, optional
-        If specified, the generated magic(tcl) script is stored in filename.
-    cellname: str or List[str]
-        The name(s) of cell(s) to be exported.
-    libpath: str
-        The path where the generated magic layout is stored.
-    scale: float
-        The scaling factor between laygo2's integer coordinats actual physical coordinates.
-    reset_library: bool, optional
-        If True, the library to export the cells is reset.
-    tech_library: str, optional
-        The name of technology library to be attached to the resetted library.
-    gds_filename: str, optional
-        If specified, export a gds file with the filename provided.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.database import Design
-    >>> from laygo2.object.physical import Rect, Pin, Instance, Text
-    >>> # Create a design.
-    >>> dsn = Design(name="mycell", libname="genlib")
-    >>> # Create layout objects.
-    >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
-    >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
-    >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
-    >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
-    >>> # Add the layout objects to the design object.
-    >>> dsn.append(r0)
-    >>> dsn.append(p0)
-    >>> dsn.append(i0)
-    >>> dsn.append(t0)
-    >>> #
-    >>> # Export to magic tcl.
-    >>> lib = laygo2.object.database.Library(name="mylib")
-    >>> lib.append(dsn)
-    >>> scr = laygo2.interface.magic.export(lib, filename="myscript.tcl")
-    >>> print(scr)
-    (definitions of laygo2 tcl functions)
-    # exporting mylib__mycell
-    _laygo2_create_layout ./magic_layout/mylib mylib_mycell None
-    _laygo2_generate_rect M1 { { 0.0  0.0  } { 100.0  100.0  } } ; # for the Rect object NoName_0
-    _laygo2_generate_pin P M1 { { 0.0  0.0  } { 50.0  50.0  } }  ; # for the Pin object P
-    _laygo2_generate_instance I0 ./magic_layout/tlib tlib_t0 { 0.0  0.0  } R0 1 1 0 0 ; # for the Instance object I0
-    save
-
-    Returns
-    -------
-    str: the string object contains corresponding tcl scripts.
-    """
-
-    # parse header functions.
-    cmd = "# laygo2 layout export magic(tcl) script.\n\n"
-    import os
-    header_filename = os.path.abspath(laygo2.interface.__file__)[:-11] + 'magic_export.tcl'
-    with open(header_filename, 'r') as f:
-        cmd += f.read()
-        cmd += '\n'
-
-    cellname = db.keys() if cellname is None else cellname  # export all cells if cellname is not given.
-    cellname = [cellname] if isinstance(cellname, str) else cellname  # convert to a list for iteration.
-    # if reset_library: (not implemented)
-    global pin_info
-    pin_info = list()
-    for cn in cellname:
-        cmd += "\n# exporting %s__%s\n" % (db.name, cn)  # open the design.
-        logging.debug('Export_to_MAGIC: Cellname:' + cn)
-        cmd += "_laygo2_create_layout %s %s %s\n" % ((libpath+'/'+db.name), (db.name+'_'+cn), tech_library)  # open the design, /WORK/magc_layout -> temp libpath
-        # export objects
-        for objname, obj in db[cn].items():
-            cmd += _translate_obj(libpath, objname, obj, scale=scale)
-        # attach zeros to pin index for sorting by alphabet (ex: pin<1> -> pin<000000001>)
-        # set length of every pin index to 10
-        for info in pin_info:
-            if '<' in info[0] and '>' in info[0]:
-                _idx = info[0].find('<')
-                _len = info[0].find('>') - (_idx + 1)
-                if _len <= 0:
-                    print("wrong pin format: "+info[0])
-                    exit(-1)
-                _prefix = '0'*(10-_len)
-                info[0] = info[0][:_idx+1] +_prefix + info[0][_idx+1:]
-                info.append(10-_len)
-        
-        pin_info.sort(key=lambda info: info[0])
-        # detach zeros from pin index
-        for info in pin_info:
-            if len(info) == 5:
-                _idx = info[0].find('<')
-                info[0] = info[0][:_idx+1] + info[0][_idx+1+info[4]:]
-        # translate pin info to magic functon
-        for port_num, info in enumerate(pin_info):
-            cmd += "_laygo2_generate_pin %s %s %s %d ; # for the Pin object %s \n" \
-                    % (info[0], info[1], info[2], port_num+1, info[3])
-        cmd += "save\n"
-        pin_info = []    
-    # optional gds export
-    if gds_filename is not None:
-        cmd += "gds write "+gds_filename+"\n"
-
-    if filename is not None:  # export to a file.
-        with open(filename, "w") as f:
-            f.write(cmd)
-
-    return cmd
+#!/usr/bin/python
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+import logging
+from math import log10
+from decimal import *
+
+import numpy as np
+import laygo2.object
+import laygo2.util.transform as tf
+
+__author__ = ""
+__maintainer__ = ""
+__status__ = "Prototype"
+
+
+def _py2magic_number(value, scale=1):
+    fmt_str = "%." + "%d" % (-1 * log10(scale) + 1) + "f "  # for truncations
+    return fmt_str % (value * scale)
+
+def _py2magic_list(pylist, scale=1):
+    """Convert a python list object to a magic(tcl) list."""
+    list_str = "{ "
+    for item in pylist:
+        if isinstance(item, list):  # nested list
+            list_str += _py2magic_list(item, scale=scale) + " "
+        elif isinstance(item, np.ndarray):  # nested list
+            list_str += _py2magic_list(item, scale=scale) + " "
+        elif isinstance(item, str):
+            list_str += "\"" + str(item) + "\" "
+        elif isinstance(item, int) or isinstance(item, np.integer):
+            # fmt_str = "%."+"%d" % (-1*log10(scale)+1)+"f "  # for truncations
+            # list_str += fmt_str%(item*scale) + " "
+            list_str += _py2magic_number(item, scale=scale) + " "
+    list_str += "}"
+    return list_str
+
+
+def _translate_obj(libpath, objname, obj, scale=1, master=None, offset=np.array([0, 0])):
+    """
+    Convert an object to corresponding scale commands.
+    offset : np.array([int, int])
+        Offsets to obj.xy
+    """
+    global pin_info
+    if master is None:  
+        mxy = np.array([0, 0])
+        mtf = 'R0'
+    else: # if the translated object has a master (e.g. VirtualInstance)
+        mxy = master.xy
+        mtf = master.transform
+    if obj.__class__ == laygo2.object.Rect:
+    #    color = obj.color # coloring func. added
+        # Invoke _laygo2_generate_rect( cv layer bbox ) in {header_filename}
+        _xy = np.sort(obj.xy, axis=0)  # make sure obj.xy is sorted
+        _xy = mxy + np.dot(_xy + np.array([[-obj.hextension, -obj.vextension], [obj.hextension, obj.vextension]]),
+                           tf.Mt(mtf).T)
+        #_xy = mxy + np.dot(obj.xy + np.array([[-obj.hextension, -obj.vextension], [obj.hextension, obj.vextension]]),
+        #                   tf.Mt(mtf).T)
+    #    return "_laygo2_generate_rect(cv, %s, %s, \"%s\") ; # for the Rect object %s \n" \
+    #           % (_py2magic_list(obj.layer), _py2magic_list(_xy, scale=scale), objname) # coloring func. added
+        return "_laygo2_generate_rect %s %s ; # for the Rect object %s \n" \
+               % (obj.layer[0], _py2magic_list(_xy, scale=scale), objname) # coloring func. added
+    elif obj.__class__ == laygo2.object.Path:
+        # TODO: implement path export function.
+        pass
+    elif obj.__class__ == laygo2.object.Pin:
+        if obj.elements is None:
+            _objelem = [obj]
+        else:
+            _objelem = obj.elements
+        for idx, _obj in np.ndenumerate(_objelem):
+            # Invoke _laygo2_generate_pin(cv, name, layer, bbox) in {header_filename}
+            _xy = mxy + np.dot(_obj.xy, tf.Mt(mtf).T)
+            # return "_laygo2_generate_pin(cv, \"%s\", %s, %s ) ; # for the Pin object %s \n" \
+            #        % (_obj.netname, _py2magic_list(_obj.layer), _py2magic_list(_xy, scale=scale),
+            #           objname)
+            pin_info.append([_obj.netname, obj.layer[0], _py2magic_list(_xy, scale=scale), objname])
+            return ''
+    elif obj.__class__ == laygo2.object.Text:
+        # TODO: implement text export function.
+        pass
+    elif obj.__class__ == laygo2.object.Instance:
+        # Invoke _laygo2_generate_instance( cv name libname cellname viewname loc orient num_rows num_cols
+        # sp_rows sp_cols params params_order )
+        _xy = mxy + np.dot(obj.xy, tf.Mt(mtf).T)
+        if master is None:  
+            transform = obj.transform
+        else: # if the translated object has a master (e.g. VirtualInstance)
+            transform = tf.combine(obj.transform, master.transform)
+        if obj.shape is None:
+            num_rows = 1
+            num_cols = 1
+            sp_rows = 0
+            sp_cols = 0
+        else:
+            num_rows = obj.shape[1]
+            num_cols = obj.shape[0]
+            sp_rows = _py2magic_number(obj.pitch[1], scale=scale)
+            sp_cols = _py2magic_number(obj.pitch[0], scale=scale)
+# Problem: if there is no cell at '/WORK/hjpark/laygo2_workspace_sky130/magic_layout' but exist at search path, this function dosen't work 
+# Solution 1: change  '/WORK/hjpark/laygo2_workspace_sky130/magic_layout' -> libpath (from layout generating script not here)
+# Solution 2: just use search path generate_instance function don't care where the libpath is 
+# solution 1: has serious problem -> microtemplate_dense lib has to be inside of libpath  
+# current state solution 2
+        if obj.libname.find("_microtemplates_dense") != -1:
+            cellfile_name = obj.cellname
+        else:
+            cellfile_name = obj.libname + '_' + obj.cellname
+        return "_laygo2_generate_instance %s %s/%s %s %s %s %d %d %s %s " \
+               "; # for the Instance object %s \n" \
+               % (objname, libpath, obj.libname, cellfile_name, _py2magic_list(_xy, scale=scale), transform,
+                  num_rows, num_cols, sp_rows, sp_cols, objname) # /WORK/magc_layout -> temp libpath
+    elif obj.__class__ == laygo2.object.VirtualInstance:
+        cmd = ""
+        if obj.shape is None:
+            for elem_name, elem in obj.native_elements.items():
+                if not elem.__class__ == laygo2.object.Pin:
+                    if obj.name == None:
+                        obj.name='NoName'
+                    else:
+                        pass
+                    cmd += _translate_obj(libpath, obj.name + '_' + elem_name, elem, scale=scale, master=obj)
+        else:  # arrayed VirtualInstance
+            for i, j in np.ndindex(tuple(obj.shape.tolist())):  # iterate over obj.shape
+                for elem_name, elem in obj.native_elements.items():
+                    if not elem.__class__ == laygo2.object.Pin:
+                        cmd += _translate_obj(libpath, obj.name + '_' + elem_name + str(i) + '_' + str(j), 
+                                              elem, scale=scale, master=obj[i, j])            
+        return cmd
+    else:
+        return None
+
+    return ""
+
+def export(db, filename=None, cellname=None, libpath='./magic_layout', scale=1, 
+           reset_library=False, tech_library=None, gds_filename=None):
+    """
+    Export a laygo2.object.database.Library object to magic's tcl code.
+
+    Parameters
+    ----------
+    db: laygo2.database.Library
+        The library database to be exported.
+    filename: str, optional
+        If specified, the generated magic(tcl) script is stored in filename.
+    cellname: str or List[str]
+        The name(s) of cell(s) to be exported.
+    libpath: str
+        The path where the generated magic layout is stored.
+    scale: float
+        The scaling factor between laygo2's integer coordinats actual physical coordinates.
+    reset_library: bool, optional
+        If True, the library to export the cells is reset.
+    tech_library: str, optional
+        The name of technology library to be attached to the resetted library.
+    gds_filename: str, optional
+        If specified, export a gds file with the filename provided.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.database import Design
+    >>> from laygo2.object.physical import Rect, Pin, Instance, Text
+    >>> # Create a design.
+    >>> dsn = Design(name="mycell", libname="genlib")
+    >>> # Create layout objects.
+    >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
+    >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
+    >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
+    >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
+    >>> # Add the layout objects to the design object.
+    >>> dsn.append(r0)
+    >>> dsn.append(p0)
+    >>> dsn.append(i0)
+    >>> dsn.append(t0)
+    >>> #
+    >>> # Export to magic tcl.
+    >>> lib = laygo2.object.database.Library(name="mylib")
+    >>> lib.append(dsn)
+    >>> scr = laygo2.interface.magic.export(lib, filename="myscript.tcl")
+    >>> print(scr)
+    (definitions of laygo2 tcl functions)
+    # exporting mylib__mycell
+    _laygo2_create_layout ./magic_layout/mylib mylib_mycell None
+    _laygo2_generate_rect M1 { { 0.0  0.0  } { 100.0  100.0  } } ; # for the Rect object NoName_0
+    _laygo2_generate_pin P M1 { { 0.0  0.0  } { 50.0  50.0  } }  ; # for the Pin object P
+    _laygo2_generate_instance I0 ./magic_layout/tlib tlib_t0 { 0.0  0.0  } R0 1 1 0 0 ; # for the Instance object I0
+    save
+
+    Returns
+    -------
+    str: the string object contains corresponding tcl scripts.
+    """
+
+    # parse header functions.
+    cmd = "# laygo2 layout export magic(tcl) script.\n\n"
+    import os
+    header_filename = os.path.abspath(laygo2.interface.__file__)[:-11] + 'magic_export.tcl'
+    with open(header_filename, 'r') as f:
+        cmd += f.read()
+        cmd += '\n'
+
+    cellname = db.keys() if cellname is None else cellname  # export all cells if cellname is not given.
+    cellname = [cellname] if isinstance(cellname, str) else cellname  # convert to a list for iteration.
+    # if reset_library: (not implemented)
+    global pin_info
+    pin_info = list()
+    for cn in cellname:
+        cmd += "\n# exporting %s__%s\n" % (db.name, cn)  # open the design.
+        logging.debug('Export_to_MAGIC: Cellname:' + cn)
+        cmd += "_laygo2_create_layout %s %s %s\n" % ((libpath+'/'+db.name), (db.name+'_'+cn), tech_library)  # open the design, /WORK/magc_layout -> temp libpath
+        # export objects
+        for objname, obj in db[cn].items():
+            cmd += _translate_obj(libpath, objname, obj, scale=scale)
+        # attach zeros to pin index for sorting by alphabet (ex: pin<1> -> pin<000000001>)
+        # set length of every pin index to 10
+        for info in pin_info:
+            if '<' in info[0] and '>' in info[0]:
+                _idx = info[0].find('<')
+                _len = info[0].find('>') - (_idx + 1)
+                if _len <= 0:
+                    print("wrong pin format: "+info[0])
+                    exit(-1)
+                _prefix = '0'*(10-_len)
+                info[0] = info[0][:_idx+1] +_prefix + info[0][_idx+1:]
+                info.append(10-_len)
+        
+        pin_info.sort(key=lambda info: info[0])
+        # detach zeros from pin index
+        for info in pin_info:
+            if len(info) == 5:
+                _idx = info[0].find('<')
+                info[0] = info[0][:_idx+1] + info[0][_idx+1+info[4]:]
+        # translate pin info to magic functon
+        for port_num, info in enumerate(pin_info):
+            cmd += "_laygo2_generate_pin %s %s %s %d ; # for the Pin object %s \n" \
+                    % (info[0], info[1], info[2], port_num+1, info[3])
+        cmd += "save\n"
+        pin_info = []    
+    # optional gds export
+    if gds_filename is not None:
+        cmd += "gds write "+gds_filename+"\n"
+
+    if filename is not None:  # export to a file.
+        with open(filename, "w") as f:
+            f.write(cmd)
+
+    return cmd
```

### Comparing `laygo2-0.5.6/laygo2/interface/__init__.py` & `laygo2-0.5.7/laygo2/interface/__init__.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,44 +1,44 @@
-# -*- coding: utf-8 -*-
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-"""laygo2 interface package implements all interfaces to external data structure and tools (yaml, gds, skill, skillbridge, bag)."""
-
-#from . import *
-from . import gds         # gds (to be deprecated)
-from . import gdspy       # gdspy
-from . import skill       # Cadence skill
-from . import bag         # Berkeley Analog Generator
-from . import skillbridge # Uni. Heidelberg's skillbridge
-from . import yaml        # Pyyaml
-from . import magic       # Magic's tcl
-from . import mpl         # matplotlib
-
-#import laygo2.interface.gds         # gds (to be deprecated)
-#import laygo2.interface.gdspy       # gdspy
-#import laygo2.interface.skill       # Cadence skill
-#import laygo2.interface.bag         # Berkeley Analog Generator
-#import laygo2.interface.skillbridge # Uni. Heidelberg's skillbridge
-#import laygo2.interface.yaml        # Pyyaml
-#import laygo2.interface.magic       # Magic's tcl
-#import laygo2.interface.mpl         # matplotlib
+# -*- coding: utf-8 -*-
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+"""laygo2 interface package implements all interfaces to external data structure and tools (yaml, gds, skill, skillbridge, bag)."""
+
+#from . import *
+from . import gds         # gds (to be deprecated)
+from . import gdspy       # gdspy
+from . import skill       # Cadence skill
+from . import bag         # Berkeley Analog Generator
+from . import skillbridge # Uni. Heidelberg's skillbridge
+from . import yaml        # Pyyaml
+from . import magic       # Magic's tcl
+from . import mpl         # matplotlib
+
+#import laygo2.interface.gds         # gds (to be deprecated)
+#import laygo2.interface.gdspy       # gdspy
+#import laygo2.interface.skill       # Cadence skill
+#import laygo2.interface.bag         # Berkeley Analog Generator
+#import laygo2.interface.skillbridge # Uni. Heidelberg's skillbridge
+#import laygo2.interface.yaml        # Pyyaml
+#import laygo2.interface.magic       # Magic's tcl
+#import laygo2.interface.mpl         # matplotlib
```

### Comparing `laygo2-0.5.6/laygo2/interface/mpl.py` & `laygo2-0.5.7/laygo2/interface/mpl.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,502 +1,502 @@
-#!/usr/bin/python
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-"""
-This module implements the interface with matplotlib.
-
-"""
-import logging
-from math import log10
-from decimal import *
-
-import numpy as np
-import laygo2.object
-import laygo2.util.transform as tf
-
-import matplotlib
-import matplotlib.pyplot as plt
-
-__author__ = ""
-__maintainer__ = ""
-__status__ = "Prototype"
-
-
-def _translate_obj(objname, obj, colormap, scale=1, master=None, offset=np.array([0, 0])):
-    """
-    Convert a layout object to corresponding matplotlib patch object.
-    """
-    if master is None:
-        mxy = np.array([0, 0])
-        mtf = "R0"
-    else:  # if the translated object has a master (e.g. VirtualInstance)
-        mxy = master.xy
-        mtf = master.transform
-    if obj.__class__ == laygo2.object.Rect:
-        # Draw a rectangle
-        _xy = np.sort(obj.xy, axis=0)  # make sure obj.xy is sorted
-        _xy = mxy + np.dot(
-            _xy + np.array([[-obj.hextension, -obj.vextension], [obj.hextension, obj.vextension]]),
-            tf.Mt(mtf).T,
-        )
-        size = [_xy[1, 0] - _xy[0, 0], _xy[1, 1] - _xy[0, 1]]
-        if obj.layer[0] in colormap:
-            rect = matplotlib.patches.Rectangle(
-                (_xy[0, 0], _xy[0, 1]),
-                size[0],
-                size[1],
-                facecolor=colormap[obj.layer[0]][1],
-                edgecolor=colormap[obj.layer[0]][0],
-                alpha=colormap[obj.layer[0]][2],
-                lw=2,
-            )
-            # ax.add_patch(rect)
-            return [[rect, obj.layer[0]]]
-        return []
-    elif obj.__class__ == laygo2.object.Path:
-        # TODO: implement path export function.
-        pass
-    elif obj.__class__ == laygo2.object.Pin:
-        if obj.elements is None:
-            _objelem = [obj]
-        else:
-            _objelem = obj.elements
-        for idx, _obj in np.ndenumerate(_objelem):
-            # Invoke _laygo2_generate_pin(cv, name, layer, bbox) in {header_filename}
-            _xy = mxy + np.dot(_obj.xy, tf.Mt(mtf).T)
-            size = [_xy[1, 0] - _xy[0, 0], _xy[1, 1] - _xy[0, 1]]
-            if obj.layer[0] in colormap:
-                rect = matplotlib.patches.Rectangle(
-                    (_xy[0, 0], _xy[0, 1]),
-                    size[0],
-                    size[1],
-                    facecolor=colormap[obj.layer[0]][1],
-                    edgecolor=colormap[obj.layer[0]][0],
-                    alpha=colormap[obj.layer[0]][2],
-                    lw=2,
-                )
-                return [[rect, obj.layer[0], objname + "/" + obj.netname]]
-                # ax.add_patch(rect)
-            return []
-    elif obj.__class__ == laygo2.object.Text:
-        return [["text", obj.layer[0], obj.text, obj.xy]]
-        # TODO: implement text export function.
-        pass
-    elif obj.__class__ == laygo2.object.Instance:
-        # Invoke _laygo2_generate_instance( cv name libname cellname viewname loc orient num_rows num_cols
-        # sp_rows sp_cols params params_order )
-        _xy = mxy + np.dot(obj.xy, tf.Mt(mtf).T)
-
-        _xy0 = obj.xy0
-        _xy1 = np.dot(obj.size, tf.Mt(mtf).T) #* np.array([num_rows, num_cols])
-        rect = matplotlib.patches.Rectangle(
-            (_xy0[0], _xy0[1]),
-            _xy1[0],
-            _xy1[1],
-            facecolor=colormap["__instance__"][1],
-            edgecolor=colormap["__instance__"][0],
-            alpha=colormap["__instance__"][2],
-            lw=2,
-        )
-        #pypobjs = [[rect, "__instance__", obj.cellname + "/" + obj.name]]
-        pypobjs = [[rect, "__instance__", obj.cellname + "/" + objname]]
-
-        # Elements for array instances
-        if obj.shape is not None:
-            for i, e in np.ndenumerate(obj.elements):
-                pypobjs += _translate_obj(e.name+"_"+str(i), e, colormap, scale=scale)
-
-        # Instance pins
-        for pn, p in obj.pins.items():
-            _pypobj = _translate_obj(pn, p, colormap, scale=scale, master=master, offset=offset)
-            _pypobj[0][1] = "__instance_pin__"
-            _pypobj[0][0].set(edgecolor=colormap["__instance_pin__"][0])
-            _pypobj[0][0].set(facecolor=colormap["__instance_pin__"][1])
-            pypobjs += _pypobj
-        return pypobjs
-    elif obj.__class__ == laygo2.object.VirtualInstance:
-        pypobjs = []
-        if obj.shape is None:
-            for elem_name, elem in obj.native_elements.items():
-                if not elem.__class__ == laygo2.object.Pin:
-                    if obj.name == None:
-                        objname = "NoName"
-                    else:
-                        objname = obj.name
-                    _pypobj = _translate_obj(objname, elem, colormap, scale=scale, master=obj)
-                    pypobjs += _pypobj
-        else:  # arrayed VirtualInstance
-            for i, j in np.ndindex(tuple(obj.shape.tolist())):  # iterate over obj.shape
-                for elem_name, elem in obj.native_elements.items():
-                    if not elem.__class__ == laygo2.object.Pin:
-                        _pypobj = _translate_obj(
-                            obj.name + "_" + elem_name + str(i) + "_" + str(j),
-                            elem,
-                            colormap,
-                            scale=scale,
-                            master=obj[i, j],
-                        )
-                        pypobjs += _pypobj
-
-        # Instance pins
-        for pn, p in obj.pins.items():
-            _pypobj = _translate_obj(pn, p, colormap, scale=scale, master=master, offset=offset)
-            _pypobj[0][1] = "__instance_pin__"
-            _pypobj[0][0].set(edgecolor=colormap["__instance_pin__"][0])
-            _pypobj[0][0].set(facecolor=colormap["__instance_pin__"][1])
-            pypobjs += _pypobj
-        return pypobjs
-
-    else:
-        return []
-        # return [obj.translate_to_matplotlib()]
-    return []
-
-
-def export(
-    db,
-    cellname=None,
-    scale=1,
-    colormap=None,
-    order=None,
-    xlim=None,
-    ylim=None,
-    filename=None,
-):
-    """
-    Export a laygo2.object.database.Library or Design object to a matplotlib plot.
-
-    Parameters
-    ----------
-    db: laygo2.database.Library or laygo2.database design
-        The library database or design to exported.
-    cellname: str or List[str]
-        (optional) The name(s) of cell(s) to be exported.
-    scale: float
-        (optional) The scaling factor between laygo2's integer coordinates and plot coordinates.
-    colormap: dict
-        A dictionary that contains layer-color mapping information.
-    order: list
-        A list that contains the order of layers to be displayed (former is plotted first).
-    xlim: list
-        (optional) A list that specifies the range of plot in x-axis.
-    ylim: list
-        (optional) A list that specifies the range of plot in y-axis.
-    filename: str
-        (optional) If specified, export a output file for the plot.
-
-    Returns
-    -------
-    matplotlib.pyplot.figure or list: The generated figure object(s).
-
-    """
-    # colormap
-    if colormap is None:
-        colormap = dict()
-
-    # a list to align layered objects in order
-    if order is None:
-        order = []
-
-    # cell name handling.
-    if isinstance(db, laygo2.database.Design):
-        cellname = [db.cellname]
-        db = {db.cellname:db}
-    if isinstance(db, laygo2.database.Library):
-        cellname = db.keys() if cellname is None else cellname  # export all cells if cellname is not given.
-        cellname = [cellname] if isinstance(cellname, str) else cellname  # convert to a list for iteration.
-
-    fig = []
-    for cn in cellname:
-        _fig = plt.figure()
-        pypobjs = []
-        ax = _fig.add_subplot(111)
-        for objname, obj in db[cn].items():
-            pypobjs += _translate_obj(objname, obj, colormap, scale=scale)
-        for _alignobj in order:
-            for _pypobj in pypobjs:
-                if _pypobj[1] == _alignobj:  # layer is matched.
-                    if isinstance(_pypobj[0], str):
-                        if _pypobj[0] == 'text':  # Text
-                            # [["text", obj.layer[0], obj.text, obj.xy]]
-                            color = "black"
-                            ax.annotate(
-                                _pypobj[2], (_pypobj[3][0], _pypobj[3][1]), color=color, weight="bold", fontsize=6, ha="center", va="center"
-                            )
-                    elif _pypobj[0].__class__ == matplotlib.patches.Rectangle:  # Rect
-                        ax.add_patch(_pypobj[0])
-                        if len(_pypobj) == 3:  # annotation.
-                            ax.add_artist(_pypobj[0])
-                            rx, ry = _pypobj[0].get_xy()
-                            cx = rx + _pypobj[0].get_width() / 2.0
-                            cy = ry + _pypobj[0].get_height() / 2.0
-                            if _pypobj[1] == "__instance_pin__":
-                                color = _pypobj[0].get_edgecolor()
-                            else:
-                                color = "black"
-                            ax.annotate(
-                                _pypobj[2], (cx, cy), color=color, weight="bold", fontsize=6, ha="center", va="center"
-                            )
-        fig.append(_fig)
-    if len(fig) == 1:
-        fig = fig[0]
-
-    # scale
-    plt.autoscale()
-    if not (xlim == None):
-        plt.xlim(xlim)
-    if not (ylim == None):
-        plt.ylim(ylim)
-
-
-    if filename is not None:
-        plt.savefig(filename)
-
-    plt.show()
-
-    return fig
-
-
-def export_instance(
-    obj,
-    scale=1,
-    colormap=None,
-    order=None,
-    xlim=None,
-    ylim=None,
-    filename=None,
-):
-    """
-    Export a laygo2.object.physical.Instance object to a matplotlib plot.
-
-    Parameters
-    ----------
-    obj: laygo2.object.physical.Instance
-        The instance object to exported.
-    scale: float
-        (optional) The scaling factor between laygo2's integer coordinates and plot coordinates.
-    colormap: dict
-        A dictionary that contains layer-color mapping information.
-    order: list
-        A list that contains the order of layers to be displayed (former is plotted first).
-    xlim: list
-        (optional) A list that specifies the range of plot in x-axis.
-    ylim: list
-        (optional) A list that specifies the range of plot in y-axis.
-    filename: str
-        (optional) If specified, export a output file for the plot.
-
-    Returns
-    -------
-    matplotlib.pyplot.figure or list: The generated figure object(s).
-
-    """
-
-    # colormap
-    if colormap is None:
-        colormap = dict()
-
-    # a list to align layered objects in order
-    if order is None:
-        order = []
-
-    '''
-    # xlim and ylim
-    if xlim is None:
-        xlim = [obj.bbox[0][0] - obj.width, obj.bbox[1][0] + obj.width]
-    if ylim is None:
-        ylim = [obj.bbox[0][1] - obj.height, obj.bbox[1][1] + obj.height]
-    '''
-
-    fig = plt.figure()
-    pypobjs = []
-    ax = fig.add_subplot(111)
-    pypobjs += _translate_obj(obj.name, obj, colormap, scale=scale)
-    for _alignobj in order:
-        for _pypobj in pypobjs:
-            if _pypobj[1] == _alignobj:  # layer is matched.
-                if isinstance(_pypobj[0], str):
-                    if _pypobj[0] == 'text':  # Text
-                        # [["text", obj.layer[0], obj.text, obj.xy]]
-                        color = "black"
-                        ax.annotate(
-                            _pypobj[2], (_pypobj[3][0], _pypobj[3][1]), color=color, weight="bold", fontsize=6, ha="center", va="center"
-                        )
-                elif _pypobj[0].__class__ == matplotlib.patches.Rectangle:  # Rect
-                    ax.add_patch(_pypobj[0])
-                    if len(_pypobj) == 3:  # annotation.
-                        ax.add_artist(_pypobj[0])
-                        rx, ry = _pypobj[0].get_xy()
-                        cx = rx + _pypobj[0].get_width() / 2.0
-                        cy = ry + _pypobj[0].get_height() / 2.0
-                        if _pypobj[1] == "__instance_pin__":
-                            color = _pypobj[0].get_edgecolor()
-                        else:
-                            color = "black"
-                        ax.annotate(
-                            _pypobj[2], (cx, cy), color=color, weight="bold", fontsize=6, ha="center", va="center"
-                        )
-    # scale
-    plt.autoscale()
-    if not (xlim == None):
-        plt.xlim(xlim)
-    if not (ylim == None):
-        plt.ylim(ylim)
-
-    if filename is not None:
-        plt.savefig(filename)
-
-    plt.show()
-
-    return fig
-
-
-def export_grid(
-    obj,
-    colormap=None,
-    order=None,
-    xlim=None,
-    ylim=None,
-    filename=None,
-):
-    """
-    Export a laygo2.object.grid.Grid object to a matplotlib plot.
-
-    Parameters
-    ----------
-    obj: laygo2.object.grid.Grid
-        The grid object to exported.
-    scale: float
-        (optional) The scaling factor between laygo2's integer coordinates and plot coordinates.
-    colormap: dict
-        A dictionary that contains layer-color mapping information.
-    order: list
-        A list that contains the order of layers to be displayed (former is plotted first).
-    xlim: list
-        (optional) A list that specifies the range of plot in x-axis.
-    ylim: list
-        (optional) A list that specifies the range of plot in y-axis.
-    filename: str
-        (optional) If specified, export a output file for the plot.
-
-    Returns
-    -------
-    matplotlib.pyplot.figure or list: The generated figure object(s).
-
-    """
-    # colormap
-    if colormap is None:
-        colormap = dict()
-
-    # a list to align layered objects in order
-    if order is None:
-        order = []
-
-    fig = plt.figure()
-    pypobjs = []
-    ax = fig.add_subplot(111)
-    # scope
-    _xy = (obj.vgrid.range[0], obj.hgrid.range[0])
-    _width = obj.vgrid.range[1] - obj.vgrid.range[0]
-    _height = obj.hgrid.range[1] - obj.hgrid.range[0]
-    rect = matplotlib.patches.Rectangle(_xy, _width, _height, facecolor="none", edgecolor="black", lw=2)
-    ax.add_patch(rect)
-    rx, ry = rect.get_xy()
-    cx = rx + rect.get_width() / 2.0
-    cy = ry + rect.get_height() / 2.0
-    ax.annotate(
-        obj.name, (cx, cy), color="black", weight="bold", fontsize=6, ha="center", va="center"
-    )
-    if obj.__class__ == laygo2.object.RoutingGrid:  # Routing grid
-        for i in range(len(obj.vgrid.elements)):  # vertical routing grid
-            ve = obj.vgrid.elements[i]
-            _xy = (ve - obj.vwidth[i]/2, obj.hgrid.range[0]-obj.vextension[i])
-            _width = obj.vwidth[i]
-            _height = obj.hgrid.range[1] - obj.hgrid.range[0] + 2 * obj.vextension[i]
-            facecolor=colormap[obj.vlayer[i][0]][1]
-            edgecolor=colormap[obj.vlayer[i][0]][0]
-            alpha=colormap[obj.vlayer[i][0]][2]
-            rect = matplotlib.patches.Rectangle(_xy, _width, _height, facecolor=facecolor, edgecolor=edgecolor, alpha=alpha, lw=2)
-            ax.add_patch(rect)
-            _xy = (ve, obj.hgrid.range[0]-obj.vextension[i])
-            ax.annotate(_xy[0], _xy, color="black", weight="bold", fontsize=6, ha="center", va="center")
-        for i in range(len(obj.hgrid.elements)):  # horizontal routing grid
-            he = obj.hgrid.elements[i]
-            _xy = (obj.vgrid.range[0] - obj.hextension[i], he - obj.hwidth[i]/2)
-            _width = obj.vgrid.range[1] - obj.vgrid.range[0] + 2*obj.hextension[i]
-            _height = obj.hwidth[i]
-            facecolor=colormap[obj.hlayer[i][0]][1]
-            edgecolor=colormap[obj.hlayer[i][0]][0]
-            alpha=colormap[obj.hlayer[i][0]][2]
-            rect = matplotlib.patches.Rectangle(_xy, _width, _height, facecolor=facecolor, edgecolor=edgecolor, alpha=alpha, lw=2)
-            ax.add_patch(rect)
-            _xy = (obj.vgrid.range[0] - obj.hextension[i], he)
-            ax.annotate(_xy[1], _xy, color="black", weight="bold", fontsize=6, ha="center", va="center")
-        # viamap
-        for i in range(len(obj.vgrid.elements)):  # vertical routing grid
-            for j in range(len(obj.hgrid.elements)):  # horizontal routing grid
-                v = obj.viamap[i, j]
-                x = obj.vgrid.elements[i]
-                y = obj.hgrid.elements[j]
-                circ = matplotlib.patches.Circle((x, y), radius=2, facecolor="black", edgecolor="black") #, **kwargs)
-                ax.add_patch(circ)
-                ax.annotate(v.name, (x+2, y), color="black", fontsize=4, ha="left", va="bottom")
-
-    for _alignobj in order:
-        for _pypobj in pypobjs:
-            if _pypobj[1] == _alignobj:  # layer is matched.
-                if isinstance(_pypobj[0], str):
-                    if _pypobj[0] == 'text':  # Text
-                        # [["text", obj.layer[0], obj.text, obj.xy]]
-                        color = "black"
-                        ax.annotate(
-                            _pypobj[2], (_pypobj[3][0], _pypobj[3][1]), color=color, weight="bold", fontsize=6, ha="center", va="center"
-                        )
-                elif _pypobj[0].__class__ == matplotlib.patches.Rectangle:  # Rect
-                    ax.add_patch(_pypobj[0])
-                    if len(_pypobj) == 3:  # annotation.
-                        ax.add_artist(_pypobj[0])
-                        rx, ry = _pypobj[0].get_xy()
-                        cx = rx + _pypobj[0].get_width() / 2.0
-                        cy = ry + _pypobj[0].get_height() / 2.0
-                        if _pypobj[1] == "__instance_pin__":
-                            color = _pypobj[0].get_edgecolor()
-                        else:
-                            color = "black"
-                        ax.annotate(
-                            _pypobj[2], (cx, cy), color=color, weight="bold", fontsize=6, ha="center", va="center"
-                        )
-
-    # scale
-    plt.autoscale()
-    if not (xlim == None):
-        plt.xlim(xlim)
-    if not (ylim == None):
-        plt.ylim(ylim)
-
-    if filename is not None:
-        plt.savefig(filename)
-
-    plt.show()
-
-    return fig
+#!/usr/bin/python
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+"""
+This module implements the interface with matplotlib.
+
+"""
+import logging
+from math import log10
+from decimal import *
+
+import numpy as np
+import laygo2.object
+import laygo2.util.transform as tf
+
+import matplotlib
+import matplotlib.pyplot as plt
+
+__author__ = ""
+__maintainer__ = ""
+__status__ = "Prototype"
+
+
+def _translate_obj(objname, obj, colormap, scale=1, master=None, offset=np.array([0, 0])):
+    """
+    Convert a layout object to corresponding matplotlib patch object.
+    """
+    if master is None:
+        mxy = np.array([0, 0])
+        mtf = "R0"
+    else:  # if the translated object has a master (e.g. VirtualInstance)
+        mxy = master.xy
+        mtf = master.transform
+    if obj.__class__ == laygo2.object.Rect:
+        # Draw a rectangle
+        _xy = np.sort(obj.xy, axis=0)  # make sure obj.xy is sorted
+        _xy = mxy + np.dot(
+            _xy + np.array([[-obj.hextension, -obj.vextension], [obj.hextension, obj.vextension]]),
+            tf.Mt(mtf).T,
+        )
+        size = [_xy[1, 0] - _xy[0, 0], _xy[1, 1] - _xy[0, 1]]
+        if obj.layer[0] in colormap:
+            rect = matplotlib.patches.Rectangle(
+                (_xy[0, 0], _xy[0, 1]),
+                size[0],
+                size[1],
+                facecolor=colormap[obj.layer[0]][1],
+                edgecolor=colormap[obj.layer[0]][0],
+                alpha=colormap[obj.layer[0]][2],
+                lw=2,
+            )
+            # ax.add_patch(rect)
+            return [[rect, obj.layer[0]]]
+        return []
+    elif obj.__class__ == laygo2.object.Path:
+        # TODO: implement path export function.
+        pass
+    elif obj.__class__ == laygo2.object.Pin:
+        if obj.elements is None:
+            _objelem = [obj]
+        else:
+            _objelem = obj.elements
+        for idx, _obj in np.ndenumerate(_objelem):
+            # Invoke _laygo2_generate_pin(cv, name, layer, bbox) in {header_filename}
+            _xy = mxy + np.dot(_obj.xy, tf.Mt(mtf).T)
+            size = [_xy[1, 0] - _xy[0, 0], _xy[1, 1] - _xy[0, 1]]
+            if obj.layer[0] in colormap:
+                rect = matplotlib.patches.Rectangle(
+                    (_xy[0, 0], _xy[0, 1]),
+                    size[0],
+                    size[1],
+                    facecolor=colormap[obj.layer[0]][1],
+                    edgecolor=colormap[obj.layer[0]][0],
+                    alpha=colormap[obj.layer[0]][2],
+                    lw=2,
+                )
+                return [[rect, obj.layer[0], objname + "/" + obj.netname]]
+                # ax.add_patch(rect)
+            return []
+    elif obj.__class__ == laygo2.object.Text:
+        return [["text", obj.layer[0], obj.text, obj.xy]]
+        # TODO: implement text export function.
+        pass
+    elif obj.__class__ == laygo2.object.Instance:
+        # Invoke _laygo2_generate_instance( cv name libname cellname viewname loc orient num_rows num_cols
+        # sp_rows sp_cols params params_order )
+        _xy = mxy + np.dot(obj.xy, tf.Mt(mtf).T)
+
+        _xy0 = obj.xy0
+        _xy1 = np.dot(obj.size, tf.Mt(mtf).T) #* np.array([num_rows, num_cols])
+        rect = matplotlib.patches.Rectangle(
+            (_xy0[0], _xy0[1]),
+            _xy1[0],
+            _xy1[1],
+            facecolor=colormap["__instance__"][1],
+            edgecolor=colormap["__instance__"][0],
+            alpha=colormap["__instance__"][2],
+            lw=2,
+        )
+        #pypobjs = [[rect, "__instance__", obj.cellname + "/" + obj.name]]
+        pypobjs = [[rect, "__instance__", obj.cellname + "/" + objname]]
+
+        # Elements for array instances
+        if obj.shape is not None:
+            for i, e in np.ndenumerate(obj.elements):
+                pypobjs += _translate_obj(e.name+"_"+str(i), e, colormap, scale=scale)
+
+        # Instance pins
+        for pn, p in obj.pins.items():
+            _pypobj = _translate_obj(pn, p, colormap, scale=scale, master=master, offset=offset)
+            _pypobj[0][1] = "__instance_pin__"
+            _pypobj[0][0].set(edgecolor=colormap["__instance_pin__"][0])
+            _pypobj[0][0].set(facecolor=colormap["__instance_pin__"][1])
+            pypobjs += _pypobj
+        return pypobjs
+    elif obj.__class__ == laygo2.object.VirtualInstance:
+        pypobjs = []
+        if obj.shape is None:
+            for elem_name, elem in obj.native_elements.items():
+                if not elem.__class__ == laygo2.object.Pin:
+                    if obj.name == None:
+                        objname = "NoName"
+                    else:
+                        objname = obj.name
+                    _pypobj = _translate_obj(objname, elem, colormap, scale=scale, master=obj)
+                    pypobjs += _pypobj
+        else:  # arrayed VirtualInstance
+            for i, j in np.ndindex(tuple(obj.shape.tolist())):  # iterate over obj.shape
+                for elem_name, elem in obj.native_elements.items():
+                    if not elem.__class__ == laygo2.object.Pin:
+                        _pypobj = _translate_obj(
+                            obj.name + "_" + elem_name + str(i) + "_" + str(j),
+                            elem,
+                            colormap,
+                            scale=scale,
+                            master=obj[i, j],
+                        )
+                        pypobjs += _pypobj
+
+        # Instance pins
+        for pn, p in obj.pins.items():
+            _pypobj = _translate_obj(pn, p, colormap, scale=scale, master=master, offset=offset)
+            _pypobj[0][1] = "__instance_pin__"
+            _pypobj[0][0].set(edgecolor=colormap["__instance_pin__"][0])
+            _pypobj[0][0].set(facecolor=colormap["__instance_pin__"][1])
+            pypobjs += _pypobj
+        return pypobjs
+
+    else:
+        return []
+        # return [obj.translate_to_matplotlib()]
+    return []
+
+
+def export(
+    db,
+    cellname=None,
+    scale=1,
+    colormap=None,
+    order=None,
+    xlim=None,
+    ylim=None,
+    filename=None,
+):
+    """
+    Export a laygo2.object.database.Library or Design object to a matplotlib plot.
+
+    Parameters
+    ----------
+    db: laygo2.database.Library or laygo2.database design
+        The library database or design to exported.
+    cellname: str or List[str]
+        (optional) The name(s) of cell(s) to be exported.
+    scale: float
+        (optional) The scaling factor between laygo2's integer coordinates and plot coordinates.
+    colormap: dict
+        A dictionary that contains layer-color mapping information.
+    order: list
+        A list that contains the order of layers to be displayed (former is plotted first).
+    xlim: list
+        (optional) A list that specifies the range of plot in x-axis.
+    ylim: list
+        (optional) A list that specifies the range of plot in y-axis.
+    filename: str
+        (optional) If specified, export a output file for the plot.
+
+    Returns
+    -------
+    matplotlib.pyplot.figure or list: The generated figure object(s).
+
+    """
+    # colormap
+    if colormap is None:
+        colormap = dict()
+
+    # a list to align layered objects in order
+    if order is None:
+        order = []
+
+    # cell name handling.
+    if isinstance(db, laygo2.database.Design):
+        cellname = [db.cellname]
+        db = {db.cellname:db}
+    if isinstance(db, laygo2.database.Library):
+        cellname = db.keys() if cellname is None else cellname  # export all cells if cellname is not given.
+        cellname = [cellname] if isinstance(cellname, str) else cellname  # convert to a list for iteration.
+
+    fig = []
+    for cn in cellname:
+        _fig = plt.figure()
+        pypobjs = []
+        ax = _fig.add_subplot(111)
+        for objname, obj in db[cn].items():
+            pypobjs += _translate_obj(objname, obj, colormap, scale=scale)
+        for _alignobj in order:
+            for _pypobj in pypobjs:
+                if _pypobj[1] == _alignobj:  # layer is matched.
+                    if isinstance(_pypobj[0], str):
+                        if _pypobj[0] == 'text':  # Text
+                            # [["text", obj.layer[0], obj.text, obj.xy]]
+                            color = "black"
+                            ax.annotate(
+                                _pypobj[2], (_pypobj[3][0], _pypobj[3][1]), color=color, weight="bold", fontsize=6, ha="center", va="center"
+                            )
+                    elif _pypobj[0].__class__ == matplotlib.patches.Rectangle:  # Rect
+                        ax.add_patch(_pypobj[0])
+                        if len(_pypobj) == 3:  # annotation.
+                            ax.add_artist(_pypobj[0])
+                            rx, ry = _pypobj[0].get_xy()
+                            cx = rx + _pypobj[0].get_width() / 2.0
+                            cy = ry + _pypobj[0].get_height() / 2.0
+                            if _pypobj[1] == "__instance_pin__":
+                                color = _pypobj[0].get_edgecolor()
+                            else:
+                                color = "black"
+                            ax.annotate(
+                                _pypobj[2], (cx, cy), color=color, weight="bold", fontsize=6, ha="center", va="center"
+                            )
+        fig.append(_fig)
+    if len(fig) == 1:
+        fig = fig[0]
+
+    # scale
+    plt.autoscale()
+    if not (xlim == None):
+        plt.xlim(xlim)
+    if not (ylim == None):
+        plt.ylim(ylim)
+
+
+    if filename is not None:
+        plt.savefig(filename)
+
+    plt.show()
+
+    return fig
+
+
+def export_instance(
+    obj,
+    scale=1,
+    colormap=None,
+    order=None,
+    xlim=None,
+    ylim=None,
+    filename=None,
+):
+    """
+    Export a laygo2.object.physical.Instance object to a matplotlib plot.
+
+    Parameters
+    ----------
+    obj: laygo2.object.physical.Instance
+        The instance object to exported.
+    scale: float
+        (optional) The scaling factor between laygo2's integer coordinates and plot coordinates.
+    colormap: dict
+        A dictionary that contains layer-color mapping information.
+    order: list
+        A list that contains the order of layers to be displayed (former is plotted first).
+    xlim: list
+        (optional) A list that specifies the range of plot in x-axis.
+    ylim: list
+        (optional) A list that specifies the range of plot in y-axis.
+    filename: str
+        (optional) If specified, export a output file for the plot.
+
+    Returns
+    -------
+    matplotlib.pyplot.figure or list: The generated figure object(s).
+
+    """
+
+    # colormap
+    if colormap is None:
+        colormap = dict()
+
+    # a list to align layered objects in order
+    if order is None:
+        order = []
+
+    '''
+    # xlim and ylim
+    if xlim is None:
+        xlim = [obj.bbox[0][0] - obj.width, obj.bbox[1][0] + obj.width]
+    if ylim is None:
+        ylim = [obj.bbox[0][1] - obj.height, obj.bbox[1][1] + obj.height]
+    '''
+
+    fig = plt.figure()
+    pypobjs = []
+    ax = fig.add_subplot(111)
+    pypobjs += _translate_obj(obj.name, obj, colormap, scale=scale)
+    for _alignobj in order:
+        for _pypobj in pypobjs:
+            if _pypobj[1] == _alignobj:  # layer is matched.
+                if isinstance(_pypobj[0], str):
+                    if _pypobj[0] == 'text':  # Text
+                        # [["text", obj.layer[0], obj.text, obj.xy]]
+                        color = "black"
+                        ax.annotate(
+                            _pypobj[2], (_pypobj[3][0], _pypobj[3][1]), color=color, weight="bold", fontsize=6, ha="center", va="center"
+                        )
+                elif _pypobj[0].__class__ == matplotlib.patches.Rectangle:  # Rect
+                    ax.add_patch(_pypobj[0])
+                    if len(_pypobj) == 3:  # annotation.
+                        ax.add_artist(_pypobj[0])
+                        rx, ry = _pypobj[0].get_xy()
+                        cx = rx + _pypobj[0].get_width() / 2.0
+                        cy = ry + _pypobj[0].get_height() / 2.0
+                        if _pypobj[1] == "__instance_pin__":
+                            color = _pypobj[0].get_edgecolor()
+                        else:
+                            color = "black"
+                        ax.annotate(
+                            _pypobj[2], (cx, cy), color=color, weight="bold", fontsize=6, ha="center", va="center"
+                        )
+    # scale
+    plt.autoscale()
+    if not (xlim == None):
+        plt.xlim(xlim)
+    if not (ylim == None):
+        plt.ylim(ylim)
+
+    if filename is not None:
+        plt.savefig(filename)
+
+    plt.show()
+
+    return fig
+
+
+def export_grid(
+    obj,
+    colormap=None,
+    order=None,
+    xlim=None,
+    ylim=None,
+    filename=None,
+):
+    """
+    Export a laygo2.object.grid.Grid object to a matplotlib plot.
+
+    Parameters
+    ----------
+    obj: laygo2.object.grid.Grid
+        The grid object to exported.
+    scale: float
+        (optional) The scaling factor between laygo2's integer coordinates and plot coordinates.
+    colormap: dict
+        A dictionary that contains layer-color mapping information.
+    order: list
+        A list that contains the order of layers to be displayed (former is plotted first).
+    xlim: list
+        (optional) A list that specifies the range of plot in x-axis.
+    ylim: list
+        (optional) A list that specifies the range of plot in y-axis.
+    filename: str
+        (optional) If specified, export a output file for the plot.
+
+    Returns
+    -------
+    matplotlib.pyplot.figure or list: The generated figure object(s).
+
+    """
+    # colormap
+    if colormap is None:
+        colormap = dict()
+
+    # a list to align layered objects in order
+    if order is None:
+        order = []
+
+    fig = plt.figure()
+    pypobjs = []
+    ax = fig.add_subplot(111)
+    # scope
+    _xy = (obj.vgrid.range[0], obj.hgrid.range[0])
+    _width = obj.vgrid.range[1] - obj.vgrid.range[0]
+    _height = obj.hgrid.range[1] - obj.hgrid.range[0]
+    rect = matplotlib.patches.Rectangle(_xy, _width, _height, facecolor="none", edgecolor="black", lw=2)
+    ax.add_patch(rect)
+    rx, ry = rect.get_xy()
+    cx = rx + rect.get_width() / 2.0
+    cy = ry + rect.get_height() / 2.0
+    ax.annotate(
+        obj.name, (cx, cy), color="black", weight="bold", fontsize=6, ha="center", va="center"
+    )
+    if obj.__class__ == laygo2.object.RoutingGrid:  # Routing grid
+        for i in range(len(obj.vgrid.elements)):  # vertical routing grid
+            ve = obj.vgrid.elements[i]
+            _xy = (ve - obj.vwidth[i]/2, obj.hgrid.range[0]-obj.vextension[i])
+            _width = obj.vwidth[i]
+            _height = obj.hgrid.range[1] - obj.hgrid.range[0] + 2 * obj.vextension[i]
+            facecolor=colormap[obj.vlayer[i][0]][1]
+            edgecolor=colormap[obj.vlayer[i][0]][0]
+            alpha=colormap[obj.vlayer[i][0]][2]
+            rect = matplotlib.patches.Rectangle(_xy, _width, _height, facecolor=facecolor, edgecolor=edgecolor, alpha=alpha, lw=2)
+            ax.add_patch(rect)
+            _xy = (ve, obj.hgrid.range[0]-obj.vextension[i])
+            ax.annotate(_xy[0], _xy, color="black", weight="bold", fontsize=6, ha="center", va="center")
+        for i in range(len(obj.hgrid.elements)):  # horizontal routing grid
+            he = obj.hgrid.elements[i]
+            _xy = (obj.vgrid.range[0] - obj.hextension[i], he - obj.hwidth[i]/2)
+            _width = obj.vgrid.range[1] - obj.vgrid.range[0] + 2*obj.hextension[i]
+            _height = obj.hwidth[i]
+            facecolor=colormap[obj.hlayer[i][0]][1]
+            edgecolor=colormap[obj.hlayer[i][0]][0]
+            alpha=colormap[obj.hlayer[i][0]][2]
+            rect = matplotlib.patches.Rectangle(_xy, _width, _height, facecolor=facecolor, edgecolor=edgecolor, alpha=alpha, lw=2)
+            ax.add_patch(rect)
+            _xy = (obj.vgrid.range[0] - obj.hextension[i], he)
+            ax.annotate(_xy[1], _xy, color="black", weight="bold", fontsize=6, ha="center", va="center")
+        # viamap
+        for i in range(len(obj.vgrid.elements)):  # vertical routing grid
+            for j in range(len(obj.hgrid.elements)):  # horizontal routing grid
+                v = obj.viamap[i, j]
+                x = obj.vgrid.elements[i]
+                y = obj.hgrid.elements[j]
+                circ = matplotlib.patches.Circle((x, y), radius=2, facecolor="black", edgecolor="black") #, **kwargs)
+                ax.add_patch(circ)
+                ax.annotate(v.name, (x+2, y), color="black", fontsize=4, ha="left", va="bottom")
+
+    for _alignobj in order:
+        for _pypobj in pypobjs:
+            if _pypobj[1] == _alignobj:  # layer is matched.
+                if isinstance(_pypobj[0], str):
+                    if _pypobj[0] == 'text':  # Text
+                        # [["text", obj.layer[0], obj.text, obj.xy]]
+                        color = "black"
+                        ax.annotate(
+                            _pypobj[2], (_pypobj[3][0], _pypobj[3][1]), color=color, weight="bold", fontsize=6, ha="center", va="center"
+                        )
+                elif _pypobj[0].__class__ == matplotlib.patches.Rectangle:  # Rect
+                    ax.add_patch(_pypobj[0])
+                    if len(_pypobj) == 3:  # annotation.
+                        ax.add_artist(_pypobj[0])
+                        rx, ry = _pypobj[0].get_xy()
+                        cx = rx + _pypobj[0].get_width() / 2.0
+                        cy = ry + _pypobj[0].get_height() / 2.0
+                        if _pypobj[1] == "__instance_pin__":
+                            color = _pypobj[0].get_edgecolor()
+                        else:
+                            color = "black"
+                        ax.annotate(
+                            _pypobj[2], (cx, cy), color=color, weight="bold", fontsize=6, ha="center", va="center"
+                        )
+
+    # scale
+    plt.autoscale()
+    if not (xlim == None):
+        plt.xlim(xlim)
+    if not (ylim == None):
+        plt.ylim(ylim)
+
+    if filename is not None:
+        plt.savefig(filename)
+
+    plt.show()
+
+    return fig
```

### Comparing `laygo2-0.5.6/laygo2/interface/bag.py` & `laygo2-0.5.7/laygo2/interface/bag.py`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,147 +1,147 @@
-#!/usr/bin/python
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-"""
-This module implements interface with BAG in skill language
-"""
-import laygo2.interface
-import yaml
-import numpy as np
-
-def export(
-    db, filename, cellname=None, scale=1e-3, reset_library=False, tech_library=None
-):
-    """
-    Export a laygo2.object.database.Library object to BAG2.
-
-    Parameters
-    ----------
-    db: laygo2.object.database.Library
-        The library database to be exported.
-    filename: str, optional
-        The path of the intermediate skill script file.
-    cellname: str or List[str]
-        The name(s) of cell(s) to be exported.
-    scale: float
-        The scaling factor between laygo2's integer coordinats actual physical coordinates.
-    reset_library: bool, optional
-        If True, the library to export the cells is reset.
-    tech_library: str, optional
-        The name of technology library to be attached to the resetted library.
-
-    Returns
-    -------
-    str: The generated skill script.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.database import Design
-    >>> from laygo2.object.physical import Rect, Pin, Instance, Text
-    >>> # Create a design.
-    >>> dsn = Design(name="mycell", libname="genlib")
-    >>> # Create layout objects.
-    >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
-    >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
-    >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
-    >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
-    >>> # Add the layout objects to the design object.
-    >>> dsn.append(r0)
-    >>> dsn.append(p0)
-    >>> dsn.append(i0)
-    >>> dsn.append(t0)
-    >>> #
-    >>> # Export to BAG.
-    >>> lib = laygo2.object.database.Library(name="mylib")
-    >>> lib.append(dsn)
-    >>> scr = laygo2.interface.bag.export(lib, filename="myscript.il")
-    >>> print(scr)
-    ; (definitions of laygo2 skill functions)
-    ; exporting mylib__mycell
-    cv = _laygo2_open_layout("mylib" "mycell" "layout")
-    _laygo2_generate_rect(cv, list( "M1" "drawing" ), list( list( 0.0000  0.0000  ) list( 0.1000  0.1000  ) ), "None")
-    _laygo2_generate_pin(cv, "P", list( "M1" "pin" ), list( list( 0.0000  0.0000  ) list( 0.0500  0.0500  ) ) )
-    _laygo2_generate_instance(cv, "I0", "tlib", "t0", "layout", list( 0.0000  0.0000  ), "R0", 1, 1, 0, 0, nil, nil)
-    _laygo2_save_and_close_layout(cv)
-
-    """
-    skill_str = laygo2.interface.skill.export(
-        db, filename, cellname, scale, reset_library, tech_library
-    )
-    import bag
-
-    prj = bag.BagProject()
-    prj.impl_db._eval_skill('load("' + filename + '");1\n')
-    print("Your design was generated in Virtuoso.")
-
-    return skill_str
-
-def load(libname, cellname=None, il_filename="import_skill_scratch.il", yaml_filename="import_skill_scratch.yaml", scale=1e-3, mpt=False):
-    """
-    Import virtuoso layout to a laygo2.object.database.Library object via BAG2 interface.
-    """
-    import bag
-    prj = bag.BagProject()
-
-    if cellname==None: #import all cells
-        skill_str = laygo2.interface.skill.load_cell_list(libname, filename=il_filename, yaml_filename=yaml_filename)
-        prj.impl_db._eval_skill('load("' + il_filename + '");1\n')
-        with open(yaml_filename, 'r') as stream:
-            ydict = yaml.load(stream, Loader=yaml.FullLoader)
-            celllist=ydict[libname]
-    else:
-        if isinstance(cellname, list): celllist=cellname
-        else: celllist=[cellname]
-    
-    db = laygo2.object.database.Library(name=libname)
-    for cn in celllist:
-        skill_str = laygo2.interface.skill.load(libname, cellname=cn, filename=il_filename, 
-                                                  yaml_filename=yaml_filename, mpt=mpt)
-        prj.impl_db._eval_skill('load("' + il_filename + '");1\n')
-        with open(yaml_filename, 'r') as stream:
-            ydict = yaml.load(stream, Loader=yaml.FullLoader)
-        dsn = laygo2.object.database.Design(name=cn)
-        db.append(dsn)
-        for _r_key, _r in ydict['rects'].items():
-            if 'color' in _r:  # to support MPT
-                _color = _r['color']
-            else:
-                _color = None
-            r = laygo2.object.Rect(xy=np.array(_r['bBox'])*(1/scale), layer=_r['layer'].split(), color = _color) # former definition "xy0 / scale" sometimes returns error.
-            dsn.append(r)
-        for _t_key, _t in ydict['labels'].items():
-            t = laygo2.object.Pin(name=_t['label'], xy=np.array(_t['xy'])*(1/scale), layer=_t['layer'].split())
-            dsn.append(t)
-        for _i_key, _i in ydict['instances'].items():
-            if not 'rows' in _i: _i['rows']=1
-            if not 'cols' in _i: _i['cols']=1
-            if not 'sp_rows' in _i: _i['sp_rows']=0
-            if not 'sp_cols' in _i: _i['sp_cols']=0
-            if not 'transform' in _i: _i['transform']='R0'
-            inst = laygo2.object.Instance(xy = np.array(_i['xy'])*(1/scale), libname = _i['lib_name'], cellname = _i['cell_name'],
-                                          shape = np.array([_i['cols'], _i['rows']]), pitch = np.array([_i['sp_cols'], _i['sp_rows']]),
-                                          transform = _i['transform']) 
-            dsn.append(inst)
-    return db
-
-
+#!/usr/bin/python
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+"""
+This module implements interface with BAG in skill language
+"""
+import laygo2.interface
+import yaml
+import numpy as np
+
+def export(
+    db, filename, cellname=None, scale=1e-3, reset_library=False, tech_library=None
+):
+    """
+    Export a laygo2.object.database.Library object to BAG2.
+
+    Parameters
+    ----------
+    db: laygo2.object.database.Library
+        The library database to be exported.
+    filename: str, optional
+        The path of the intermediate skill script file.
+    cellname: str or List[str]
+        The name(s) of cell(s) to be exported.
+    scale: float
+        The scaling factor between laygo2's integer coordinats actual physical coordinates.
+    reset_library: bool, optional
+        If True, the library to export the cells is reset.
+    tech_library: str, optional
+        The name of technology library to be attached to the resetted library.
+
+    Returns
+    -------
+    str: The generated skill script.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.database import Design
+    >>> from laygo2.object.physical import Rect, Pin, Instance, Text
+    >>> # Create a design.
+    >>> dsn = Design(name="mycell", libname="genlib")
+    >>> # Create layout objects.
+    >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
+    >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
+    >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
+    >>> t0 = Text(xy=[[50, 50], [100, 100]], layer=["text", "drawing"], text="T")
+    >>> # Add the layout objects to the design object.
+    >>> dsn.append(r0)
+    >>> dsn.append(p0)
+    >>> dsn.append(i0)
+    >>> dsn.append(t0)
+    >>> #
+    >>> # Export to BAG.
+    >>> lib = laygo2.object.database.Library(name="mylib")
+    >>> lib.append(dsn)
+    >>> scr = laygo2.interface.bag.export(lib, filename="myscript.il")
+    >>> print(scr)
+    ; (definitions of laygo2 skill functions)
+    ; exporting mylib__mycell
+    cv = _laygo2_open_layout("mylib" "mycell" "layout")
+    _laygo2_generate_rect(cv, list( "M1" "drawing" ), list( list( 0.0000  0.0000  ) list( 0.1000  0.1000  ) ), "None")
+    _laygo2_generate_pin(cv, "P", list( "M1" "pin" ), list( list( 0.0000  0.0000  ) list( 0.0500  0.0500  ) ) )
+    _laygo2_generate_instance(cv, "I0", "tlib", "t0", "layout", list( 0.0000  0.0000  ), "R0", 1, 1, 0, 0, nil, nil)
+    _laygo2_save_and_close_layout(cv)
+
+    """
+    skill_str = laygo2.interface.skill.export(
+        db, filename, cellname, scale, reset_library, tech_library
+    )
+    import bag
+
+    prj = bag.BagProject()
+    prj.impl_db._eval_skill('load("' + filename + '");1\n')
+    print("Your design was generated in Virtuoso.")
+
+    return skill_str
+
+def load(libname, cellname=None, il_filename="import_skill_scratch.il", yaml_filename="import_skill_scratch.yaml", scale=1e-3, mpt=False):
+    """
+    Import virtuoso layout to a laygo2.object.database.Library object via BAG2 interface.
+    """
+    import bag
+    prj = bag.BagProject()
+
+    if cellname==None: #import all cells
+        skill_str = laygo2.interface.skill.load_cell_list(libname, filename=il_filename, yaml_filename=yaml_filename)
+        prj.impl_db._eval_skill('load("' + il_filename + '");1\n')
+        with open(yaml_filename, 'r') as stream:
+            ydict = yaml.load(stream, Loader=yaml.FullLoader)
+            celllist=ydict[libname]
+    else:
+        if isinstance(cellname, list): celllist=cellname
+        else: celllist=[cellname]
+    
+    db = laygo2.object.database.Library(name=libname)
+    for cn in celllist:
+        skill_str = laygo2.interface.skill.load(libname, cellname=cn, filename=il_filename, 
+                                                  yaml_filename=yaml_filename, mpt=mpt)
+        prj.impl_db._eval_skill('load("' + il_filename + '");1\n')
+        with open(yaml_filename, 'r') as stream:
+            ydict = yaml.load(stream, Loader=yaml.FullLoader)
+        dsn = laygo2.object.database.Design(name=cn)
+        db.append(dsn)
+        for _r_key, _r in ydict['rects'].items():
+            if 'color' in _r:  # to support MPT
+                _color = _r['color']
+            else:
+                _color = None
+            r = laygo2.object.Rect(xy=np.array(_r['bBox'])*(1/scale), layer=_r['layer'].split(), color = _color) # former definition "xy0 / scale" sometimes returns error.
+            dsn.append(r)
+        for _t_key, _t in ydict['labels'].items():
+            t = laygo2.object.Pin(name=_t['label'], xy=np.array(_t['xy'])*(1/scale), layer=_t['layer'].split())
+            dsn.append(t)
+        for _i_key, _i in ydict['instances'].items():
+            if not 'rows' in _i: _i['rows']=1
+            if not 'cols' in _i: _i['cols']=1
+            if not 'sp_rows' in _i: _i['sp_rows']=0
+            if not 'sp_cols' in _i: _i['sp_cols']=0
+            if not 'transform' in _i: _i['transform']='R0'
+            inst = laygo2.object.Instance(xy = np.array(_i['xy'])*(1/scale), libname = _i['lib_name'], cellname = _i['cell_name'],
+                                          shape = np.array([_i['cols'], _i['rows']]), pitch = np.array([_i['sp_cols'], _i['sp_rows']]),
+                                          transform = _i['transform']) 
+            dsn.append(inst)
+    return db
+
+
```

### Comparing `laygo2-0.5.6/laygo2/interface/yaml.py` & `laygo2-0.5.7/laygo2/interface/yaml.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,167 +1,167 @@
-#!/usr/bin/python
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-"""
-This module implements interfaces with yaml files.
-
-"""
-
-__author__ = "Jaeduk Han"
-__maintainer__ = "Jaeduk Han"
-__status__ = "Prototype"
-
-import yaml
-import os.path
-import laygo2
-
-def export_template(template, filename, mode='append'):
-    """Export a template to a yaml file.
-
-    Parameters
-    ----------
-    template: laygo2.object.template.Template
-        The template object to be exported.        
-    filename: str
-        The name of the yaml file.
-    mode: str
-        If 'append', it adds the template entry without erasing the 
-        preexisting file.
-
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.physical import Pin
-    >>> from laygo2.object.template import NativeInstanceTemplate
-    >>> p = dict()
-    >>> p['i'] = Pin(xy=[[0, 0], [10, 10]], layer=['M1', 'drawing'],
-    >>>                  netname='i')
-    >>> p['o'] = Pin(xy=[[90, 90], [100, 100]], layer=['M1', 'drawing'],
-    >>>                  netname='o')
-    >>> nt = NativeInstanceTemplate(libname='mylib', cellname='mytemp',
-    >>>                                 bbox=[[0, 0], [100, 100]], pins=p)
-    >>> laygo2.interface.yaml.export_template(nt, filename="mytemplates.yaml")    
-    Your design was translated into YAML format.
-    {'mylib': {
-        'mytemp': {
-            'libname': 'mylib', 
-            'cellname': 'mytemp', 
-            'bbox': [[0, 0], [100, 100]], 
-            'pins': {
-                'i': {
-                    'xy': [[0, 0], [10, 10]], 
-                    'layer': ['M1', 'drawing'], 
-                    'name': None, 
-                    'netname': 'i'
-                    }, 
-                'o': {
-                    'xy': [[90, 90], [100, 100]], 
-                    'layer': ['M1', 'drawing'], 
-                    'name': None, 
-                    'netname': 'o'
-    }}}}}
-    """
-    libname = template.libname
-    cellname = template.cellname
-    pins = template.pins()
-
-    db = dict()
-    if mode == 'append':  # in append mode, the template is appended to 'filename' if the file exists.
-        if os.path.exists(filename):
-            with open(filename, 'r') as stream:
-                db = yaml.load(stream, Loader=yaml.FullLoader)
-        else:
-            f_new = open(filename, "w")
-            f_new.write(f"{libname}:\n")
-            f_new.write(f"    dummy:\n")
-            f_new.write(f"        bbox:\n")
-            f_new.write(f"        - - 0\n")
-            f_new.write(f"          - 0\n")
-            f_new.write(f"        - - 0\n")
-            f_new.write(f"          - 0\n")
-            f_new.write(f"        cellname: dummy\n")
-            f_new.write(f"        libname: {libname}\n")
-
-            f_new.close()
-            with open(filename, 'r') as stream:
-                db = yaml.load(stream, Loader=yaml.FullLoader)
-
-    if libname not in db:
-        db[libname] = dict()
-    db[libname][cellname] = template.export_to_dict()
-    with open(filename, 'w') as stream:
-        yaml.dump(db, stream)
-    #print("Your design was translated into YAML format.")
-    return db
-
-#filename=libname+'_templates.yaml'
-
-def import_template(filename):
-    """Import templates from a yaml file.
-
-    Parameters
-    ----------
-    filename: str
-        The name of the yaml file.
-    
-    Example
-    -------
-    >>> import laygo2
-    >>> from laygo2.object.physical import Pin
-    >>> from laygo2.object.template import NativeInstanceTemplate
-    >>> p = dict()
-    >>> p['i'] = Pin(xy=[[0, 0], [10, 10]], layer=['M1', 'drawing'],
-    >>>                  netname='i')
-    >>> p['o'] = Pin(xy=[[90, 90], [100, 100]], layer=['M1', 'drawing'],
-    >>>                  netname='o')
-    >>> nt = NativeInstanceTemplate(libname='mylib', cellname='mytemp',
-    >>>                                 bbox=[[0, 0], [100, 100]], pins=p)
-    >>> laygo2.interface.yaml.export_template(nt, filename="mytemplates.yaml")    
-    >>> # Import the template back to python.
-    >>> my_tlib = laygo2.interface.yaml.import_template("mytemplates.yaml")
-    >>> print(my_tlib)
-    <laygo2.object.database.TemplateLibrary object at 0x000001FE3440A410> 
-        name: mylib, 
-        params: None       
-        elements: {
-            'mytemp': <laygo2.object.template.NativeInstanceTemplate object at 0x000001FE3440A2C0>
-        }
-    """
-    # load yaml file
-    if os.path.exists(filename):
-        with open(filename, 'r') as stream:
-            db = yaml.load(stream, Loader=yaml.FullLoader)
-
-    libname = list(db.keys())[0]  # assuming there's only one library defined in each file.
-    # create template library
-    tlib = laygo2.object.database.TemplateLibrary(name=libname)
-    # read out the yaml file entries and build template objects
-    for tn, tdict in db[libname].items():
-        pins = dict()
-        if 'pins' in tdict:
-            for pinname, pdict in tdict['pins'].items():
-                pins[pinname] = laygo2.object.Pin(xy=pdict['xy'], layer=pdict['layer'], netname=pdict['netname'])
-        t = laygo2.object.NativeInstanceTemplate(libname=libname, cellname=tn, bbox=tdict['bbox'], pins=pins)
-        tlib.append(t)
-    return tlib
-
+#!/usr/bin/python
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+"""
+This module implements interfaces with yaml files.
+
+"""
+
+__author__ = "Jaeduk Han"
+__maintainer__ = "Jaeduk Han"
+__status__ = "Prototype"
+
+import yaml
+import os.path
+import laygo2
+
+def export_template(template, filename, mode='append'):
+    """Export a template to a yaml file.
+
+    Parameters
+    ----------
+    template: laygo2.object.template.Template
+        The template object to be exported.        
+    filename: str
+        The name of the yaml file.
+    mode: str
+        If 'append', it adds the template entry without erasing the 
+        preexisting file.
+
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.physical import Pin
+    >>> from laygo2.object.template import NativeInstanceTemplate
+    >>> p = dict()
+    >>> p['i'] = Pin(xy=[[0, 0], [10, 10]], layer=['M1', 'drawing'],
+    >>>                  netname='i')
+    >>> p['o'] = Pin(xy=[[90, 90], [100, 100]], layer=['M1', 'drawing'],
+    >>>                  netname='o')
+    >>> nt = NativeInstanceTemplate(libname='mylib', cellname='mytemp',
+    >>>                                 bbox=[[0, 0], [100, 100]], pins=p)
+    >>> laygo2.interface.yaml.export_template(nt, filename="mytemplates.yaml")    
+    Your design was translated into YAML format.
+    {'mylib': {
+        'mytemp': {
+            'libname': 'mylib', 
+            'cellname': 'mytemp', 
+            'bbox': [[0, 0], [100, 100]], 
+            'pins': {
+                'i': {
+                    'xy': [[0, 0], [10, 10]], 
+                    'layer': ['M1', 'drawing'], 
+                    'name': None, 
+                    'netname': 'i'
+                    }, 
+                'o': {
+                    'xy': [[90, 90], [100, 100]], 
+                    'layer': ['M1', 'drawing'], 
+                    'name': None, 
+                    'netname': 'o'
+    }}}}}
+    """
+    libname = template.libname
+    cellname = template.cellname
+    pins = template.pins()
+
+    db = dict()
+    if mode == 'append':  # in append mode, the template is appended to 'filename' if the file exists.
+        if os.path.exists(filename):
+            with open(filename, 'r') as stream:
+                db = yaml.load(stream, Loader=yaml.FullLoader)
+        else:
+            f_new = open(filename, "w")
+            f_new.write(f"{libname}:\n")
+            f_new.write(f"    dummy:\n")
+            f_new.write(f"        bbox:\n")
+            f_new.write(f"        - - 0\n")
+            f_new.write(f"          - 0\n")
+            f_new.write(f"        - - 0\n")
+            f_new.write(f"          - 0\n")
+            f_new.write(f"        cellname: dummy\n")
+            f_new.write(f"        libname: {libname}\n")
+
+            f_new.close()
+            with open(filename, 'r') as stream:
+                db = yaml.load(stream, Loader=yaml.FullLoader)
+
+    if libname not in db:
+        db[libname] = dict()
+    db[libname][cellname] = template.export_to_dict()
+    with open(filename, 'w') as stream:
+        yaml.dump(db, stream)
+    #print("Your design was translated into YAML format.")
+    return db
+
+#filename=libname+'_templates.yaml'
+
+def import_template(filename):
+    """Import templates from a yaml file.
+
+    Parameters
+    ----------
+    filename: str
+        The name of the yaml file.
+    
+    Example
+    -------
+    >>> import laygo2
+    >>> from laygo2.object.physical import Pin
+    >>> from laygo2.object.template import NativeInstanceTemplate
+    >>> p = dict()
+    >>> p['i'] = Pin(xy=[[0, 0], [10, 10]], layer=['M1', 'drawing'],
+    >>>                  netname='i')
+    >>> p['o'] = Pin(xy=[[90, 90], [100, 100]], layer=['M1', 'drawing'],
+    >>>                  netname='o')
+    >>> nt = NativeInstanceTemplate(libname='mylib', cellname='mytemp',
+    >>>                                 bbox=[[0, 0], [100, 100]], pins=p)
+    >>> laygo2.interface.yaml.export_template(nt, filename="mytemplates.yaml")    
+    >>> # Import the template back to python.
+    >>> my_tlib = laygo2.interface.yaml.import_template("mytemplates.yaml")
+    >>> print(my_tlib)
+    <laygo2.object.database.TemplateLibrary object at 0x000001FE3440A410> 
+        name: mylib, 
+        params: None       
+        elements: {
+            'mytemp': <laygo2.object.template.NativeInstanceTemplate object at 0x000001FE3440A2C0>
+        }
+    """
+    # load yaml file
+    if os.path.exists(filename):
+        with open(filename, 'r') as stream:
+            db = yaml.load(stream, Loader=yaml.FullLoader)
+
+    libname = list(db.keys())[0]  # assuming there's only one library defined in each file.
+    # create template library
+    tlib = laygo2.object.database.TemplateLibrary(name=libname)
+    # read out the yaml file entries and build template objects
+    for tn, tdict in db[libname].items():
+        pins = dict()
+        if 'pins' in tdict:
+            for pinname, pdict in tdict['pins'].items():
+                pins[pinname] = laygo2.object.Pin(xy=pdict['xy'], layer=pdict['layer'], netname=pdict['netname'])
+        t = laygo2.object.NativeInstanceTemplate(libname=libname, cellname=tn, bbox=tdict['bbox'], pins=pins)
+        tlib.append(t)
+    return tlib
+
```

### Comparing `laygo2-0.5.6/laygo2/interface/skill.py` & `laygo2-0.5.7/laygo2/interface/skill.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,384 +1,384 @@
-#!/usr/bin/python
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-"""
-This module implements interface with virtuoso in skill language
-
-"""
-import logging
-from math import log10
-from decimal import *
-import yaml
-
-import numpy as np
-import laygo2.object
-import laygo2.util.transform as tf
-import laygo2_tech as tech
-
-__author__ = ""
-__maintainer__ = ""
-__status__ = "Prototype"
-
-
-def _py2skill_number(value, scale=0.001):
-    fmt_str = "%." + "%d" % (-1 * log10(scale) + 1) + "f "  # for truncations
-    return fmt_str % (value * scale)
-
-
-def _py2skill_float(value, scale=0.001):
-    exp = np.ceil(-1 * log10(value) + 1)
-    fmt_str = "%." + "%d" % (-1 * log10(scale) + 1) + "f"  # for truncations
-    # convert to exponentail expression
-    print(value, exp, str(value))
-    return fmt_str % (value * (10**exp) * scale) + "e" + str(int(-1 * exp))
-
-
-def _py2skill_list(pylist, scale=0.001):
-    """Convert a python list object to a skill list."""
-    list_str = "list( "
-    for item in pylist:
-        if isinstance(item, list):  # nested list
-            list_str += _py2skill_list(item) + " "
-        elif isinstance(item, np.ndarray):  # nested list
-            list_str += _py2skill_list(item, scale=scale) + " "
-        elif isinstance(item, str):
-            list_str += '"' + str(item) + '" '
-        elif isinstance(item, bool):
-            if item:
-                list_str += "t "
-            else:
-                list_str += "nil "
-        elif isinstance(item, int) or isinstance(item, np.integer):
-            # fmt_str = "%."+"%d" % (-1*log10(scale)+1)+"f "  # for truncations
-            # list_str += fmt_str%(item*scale) + " "
-            list_str += _py2skill_number(item, scale) + " "
-    list_str += ")"
-    return list_str
-
-
-def _py2skill_inst_params_list(pylist):
-    """Convert a python list object to a skill list. (for pcell parameters)"""
-    list_str = "list( "
-    for item in pylist:
-        if isinstance(item, list):  # nested list
-            list_str += _py2skill_inst_params_list(item) + " "
-        elif isinstance(item, np.ndarray):  # nested list
-            list_str += _py2skill_inst_params_list(item) + " "
-        elif isinstance(item, str):
-            list_str += '"' + str(item) + '" '
-        elif isinstance(item, float):
-            list_str += str(item)
-            # list_str += _py2skill_float(item, scale) + " "
-        elif isinstance(item, bool):
-            if item:
-                list_str += "t "
-            else:
-                list_str += "nil "
-        elif isinstance(item, int) or isinstance(item, np.integer):
-            # fmt_str = "%."+"%d" % (-1*log10(scale)+1)+"f "  # for truncations
-            # list_str += fmt_str%(item*scale) + " "
-            # list_str += _py2skill_number(item, 1) + " "  # do not scale integers
-            list_str += str(item) + " "  # do not scale integers
-    list_str += ")"
-    return list_str
-
-
-def _py2skill_inst_params(value_dict):
-    """Convert instance parameter dictionary to skill list"""
-    _list = []
-    for k, v in value_dict.items():
-        if isinstance(v, str):
-            _type = "string"
-        elif isinstance(v, float):
-            _type = "float"
-        elif isinstance(v, bool):
-            _type = "boolean"
-        elif isinstance(v, int) or isinstance(v, np.integer):
-            _type = "int"
-        _list.append([k, _type, v])
-    return _py2skill_inst_params_list(_list)
-
-
-def _translate_obj(objname, obj, scale=0.001, master=None, offset=np.array([0, 0])):
-    """
-    Convert an object to corresponding skill commands.
-    offset : np.array([int, int])
-        Offsets to obj.xy
-    """
-    if master is None:
-        mxy = np.array([0, 0])
-        mtf = "R0"
-    else:  # if the translated object has a master (e.g. VirtualInstance)
-        mxy = master.xy
-        mtf = master.transform
-    if obj.__class__ == laygo2.object.Rect:
-        # coloring
-        if obj.color == None:
-            color = "not MPT"
-        else:
-            color = obj.color
-        # Invoke _laygo2_generate_rect( cv layer bbox ) in {header_filename}
-        _xy = np.sort(obj.xy, axis=0)  # make sure obj.xy is sorted
-        _xy = mxy + np.dot(
-            _xy
-            + np.array(
-                [[-obj.hextension, -obj.vextension], [obj.hextension, obj.vextension]]
-            ),
-            tf.Mt(mtf).T,
-        )
-        # _xy = mxy + np.dot(obj.xy + np.array([[-obj.hextension, -obj.vextension], [obj.hextension, obj.vextension]]),
-        #                   tf.Mt(mtf).T)
-        return '_laygo2_generate_rect(cv, %s, %s, "%s") ; for the Rect object %s \n' % (
-            _py2skill_list(obj.layer),
-            _py2skill_list(_xy, scale=scale),
-            color,
-            objname,
-        )  # coloring func. added
-    elif obj.__class__ == laygo2.object.Path:
-        # TODO: implement path export function.
-        pass
-    elif obj.__class__ == laygo2.object.Pin:
-        if obj.elements is None:
-            _objelem = [obj]
-        else:
-            _objelem = obj.elements
-        for idx, _obj in np.ndenumerate(_objelem):
-            # Invoke _laygo2_generate_pin(cv, name, layer, bbox) in {header_filename}
-            _xy = mxy + np.dot(_obj.xy, tf.Mt(mtf).T)
-            return (
-                '_laygo2_generate_pin(cv, "%s", %s, %s ) ; for the Pin object %s \n'
-                % (
-                    _obj.netname,
-                    _py2skill_list(_obj.layer),
-                    _py2skill_list(_xy, scale=scale),
-                    objname,
-                )
-            )
-    elif obj.__class__ == laygo2.object.Text:
-        # TODO: implement text export function.
-        pass
-    elif obj.__class__ == laygo2.object.Instance:
-        # Invoke _laygo2_generate_instance( cv name libname cellname viewname loc orient num_rows num_cols
-        # sp_rows sp_cols params params_order )
-        _xy = mxy + np.dot(obj.xy, tf.Mt(mtf).T)
-        if master is None:
-            transform = obj.transform
-        else:  # if the translated object has a master (e.g. VirtualInstance)
-            transform = tf.combine(obj.transform, master.transform)
-        if obj.shape is None:
-            num_rows = 1
-            num_cols = 1
-            sp_rows = 0
-            sp_cols = 0
-        else:
-            num_rows = obj.shape[1]
-            num_cols = obj.shape[0]
-            sp_rows = _py2skill_number(obj.pitch[1])
-            sp_cols = _py2skill_number(obj.pitch[0])
-        if obj.params is None:
-            inst_params = "nil"
-        else:
-            inst_params = _py2skill_inst_params(obj.params["pcell_params"])
-            # inst_params = _py2skill_list([["Wfg", "string", "500n"], ["fingers", "string", "4"], ["l", "string", "500n"]])
-        return (
-            '_laygo2_generate_instance(cv, "%s", "%s", "%s", "%s", %s, "%s", %d, %d, %s, %s, %s, %s) '
-            "; for the Instance object %s \n"
-            % (
-                objname,
-                obj.libname,
-                obj.cellname,
-                obj.viewname,
-                _py2skill_list(_xy),
-                transform,
-                num_rows,
-                num_cols,
-                sp_rows,
-                sp_cols,
-                inst_params,
-                "nil",
-                objname,
-            )
-        )
-    elif obj.__class__ == laygo2.object.VirtualInstance:
-        cmd = ""
-        if obj.shape is None:
-            for elem_name, elem in obj.native_elements.items():
-                if not elem.__class__ == laygo2.object.Pin:
-                    if obj.name == None:
-                        obj.name = "NoName"
-                    else:
-                        pass
-                    cmd += _translate_obj(
-                        obj.name + "_" + elem_name, elem, scale=scale, master=obj
-                    )
-        else:  # arrayed VirtualInstance
-            for i, j in np.ndindex(tuple(obj.shape.tolist())):  # iterate over obj.shape
-                for elem_name, elem in obj.native_elements.items():
-                    if not elem.__class__ == laygo2.object.Pin:
-                        cmd += _translate_obj(
-                            obj.name + "_" + elem_name + str(i) + "_" + str(j),
-                            elem,
-                            scale=scale,
-                            master=obj[i, j],
-                        )
-        return cmd
-    elif obj.__class__ == laygo2.object.Via: # For autovia skill
-        cmd = ""
-        center = _py2skill_list(obj.center, scale=scale)
-        cut = obj.params['cut']
-        color = obj.color # coloring func. added
-        layer = _py2skill_list([obj.params['xlayer'],obj.params['ylayer']])
-        cmd += "_laygo2_generate_autovia(cv,%s, %s, \"%s\", \"%s\", \"%s\") "  \
-               "; for the Via object %s \n" \
-               % (layer, center, cut, color, tech.name, objname)
-        return cmd
-    else:
-        return obj.translate_to_skill()  #
-
-    return ""
-
-
-def export(
-    db, filename=None, cellname=None, scale=1e-3, reset_library=False, tech_library=None
-):
-    """
-    Export a laygo2.object.database.Library object to skill code.
-
-    Parameters
-    ----------
-    db: laygo2.database.Library
-        The library database to exported.
-    filename: str, optional
-        If specified, the generated skill script is stored in filename.
-    cellname: str or List[str]
-        The name(s) of cell(s) to be exported.
-    scale: float
-        The scaling factor between laygo2's integer coordinats actual physical coordinates.
-    reset_library: bool, optional
-        If True, the library to export the cells is reset.
-    tech_library: str, optional
-        The name of technology library to be attached to the resetted library.
-
-    Returns
-    -------
-    str: The generated skill script.
-
-    Example
-    --------
-    >>> import laygo2
-    >>> from laygo2.object.database import Design
-    >>> from laygo2.object.physical import Rect, Pin, Instance, Text
-    >>> # Create a design.
-    >>> dsn = Design(name="mycell", libname="genlib")
-    >>> # Create layout objects.
-    >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
-    >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
-    >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
-    >>> t0 = Text(xy=[50, 50], layer=["text", "drawing"], text="T")
-    >>> # Add the layout objects to the design object.
-    >>> dsn.append(r0)
-    >>> dsn.append(p0)
-    >>> dsn.append(i0)
-    >>> dsn.append(t0)
-    >>> #
-    >>> # Export to skill.
-    >>> lib = laygo2.object.database.Library(name="mylib")
-    >>> lib.append(dsn)
-    >>> scr = laygo2.interface.skill.export(lib, filename="myscript.il")
-    >>> print(scr)
-    ; (definitions of laygo2 skill functions)
-    ; exporting mylib__mycell
-    cv = _laygo2_open_layout("mylib" "mycell" "layout")
-    _laygo2_generate_rect(cv, list( "M1" "drawing" ), list( list( 0.0000  0.0000  ) list( 0.1000  0.1000  ) ), "None")
-    _laygo2_generate_pin(cv, "P", list( "M1" "pin" ), list( list( 0.0000  0.0000  ) list( 0.0500  0.0500  ) ) )
-    _laygo2_generate_instance(cv, "I0", "tlib", "t0", "layout", list( 0.0000  0.0000  ), "R0", 1, 1, 0, 0, nil, nil)
-    _laygo2_save_and_close_layout(cv)
-
-    """
-    # parse header functions.
-    cmd = "; laygo2 layout export skill script.\n\n"
-    import os
-
-    header_filename = (
-        os.path.abspath(laygo2.interface.__file__)[:-11] + "skill_export.il"
-    )
-    with open(header_filename, "r") as f:
-        cmd += f.read()
-        cmd += "\n"
-
-    cellname = (
-        db.keys() if cellname is None else cellname
-    )  # export all cells if cellname is not given.
-    cellname = (
-        [cellname] if isinstance(cellname, str) else cellname
-    )  # convert to a list for iteration.
-    if reset_library:
-        cmd += '_laygo2_reset_library("%s" "%s")\n' % (db.name, tech_library)
-    for cn in cellname:
-        cmd += "\n; exporting %s__%s\n" % (db.name, cn)  # open the design.
-        logging.debug("Export_to_SKILL: Cellname:" + cn)
-        # cmd += "let( (cv) \n"  # limit the scope of cv. Disabled to prevent overflow.
-        cmd += 'cv = _laygo2_open_layout("%s" "%s" "layout")\n' % (
-            db.name,
-            cn,
-        )  # open the design.
-        # export objects
-        for objname, obj in db[cn].items():
-            cmd += _translate_obj(objname, obj, scale=scale)
-        cmd += "_laygo2_save_and_close_layout(cv)\n"  # close the layout
-        # cmd += ");let\n" Disabled to prevent overflow.
-    if filename is not None:  # export to a file.
-        with open(filename, "w") as f:
-            f.write(cmd)
-    return cmd
-
-
-def load_cell_list(libname, filename, yaml_filename="import_skill_scratch.yaml"):
-    # parse header functions.
-    cmd = "; laygo2 cell-list load script.\n\n"
-    import os
-
-    header_filename = (
-        os.path.abspath(laygo2.interface.__file__)[:-11] + "skill_import.il"
-    )
-    with open(header_filename, "r") as f:
-        cmd += f.read()
-        cmd += "\n"
-    cmd += '_laygo2_get_cell_list("%s" "%s")\n' % (libname, yaml_filename)
-    if filename is not None:  # export to a file.
-        with open(filename, "w") as f:
-            f.write(cmd)
-    return cmd
-
-
-def load(libname, mpt=False, cellname=None, filename=None, yaml_filename="import_skill_scratch.yaml"):
-    mpt = "t" if mpt else "nil"
-    cmd = "; laygo2 cell load script.\n\n"
-    cmd += '_laygo2_parse_cad_layout("%s" "%s" "%s" "%s" )\n' %(libname, cellname, yaml_filename, mpt)
-    #cmd += "_laygo2_parse_cad_layout(\"" + libname + "\" \"" + cn + "\" \"" + yaml_filename + "\" \"" + mpt + "\")"
-    if filename is not None:  # export to a file.
-        with open(filename, "w") as f:
-            f.write(cmd)
-    return cmd
-
+#!/usr/bin/python
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+"""
+This module implements interface with virtuoso in skill language
+
+"""
+import logging
+from math import log10
+from decimal import *
+import yaml
+
+import numpy as np
+import laygo2.object
+import laygo2.util.transform as tf
+import laygo2_tech as tech
+
+__author__ = ""
+__maintainer__ = ""
+__status__ = "Prototype"
+
+
+def _py2skill_number(value, scale=0.001):
+    fmt_str = "%." + "%d" % (-1 * log10(scale) + 1) + "f "  # for truncations
+    return fmt_str % (value * scale)
+
+
+def _py2skill_float(value, scale=0.001):
+    exp = np.ceil(-1 * log10(value) + 1)
+    fmt_str = "%." + "%d" % (-1 * log10(scale) + 1) + "f"  # for truncations
+    # convert to exponentail expression
+    print(value, exp, str(value))
+    return fmt_str % (value * (10**exp) * scale) + "e" + str(int(-1 * exp))
+
+
+def _py2skill_list(pylist, scale=0.001):
+    """Convert a python list object to a skill list."""
+    list_str = "list( "
+    for item in pylist:
+        if isinstance(item, list):  # nested list
+            list_str += _py2skill_list(item) + " "
+        elif isinstance(item, np.ndarray):  # nested list
+            list_str += _py2skill_list(item, scale=scale) + " "
+        elif isinstance(item, str):
+            list_str += '"' + str(item) + '" '
+        elif isinstance(item, bool):
+            if item:
+                list_str += "t "
+            else:
+                list_str += "nil "
+        elif isinstance(item, int) or isinstance(item, np.integer):
+            # fmt_str = "%."+"%d" % (-1*log10(scale)+1)+"f "  # for truncations
+            # list_str += fmt_str%(item*scale) + " "
+            list_str += _py2skill_number(item, scale) + " "
+    list_str += ")"
+    return list_str
+
+
+def _py2skill_inst_params_list(pylist):
+    """Convert a python list object to a skill list. (for pcell parameters)"""
+    list_str = "list( "
+    for item in pylist:
+        if isinstance(item, list):  # nested list
+            list_str += _py2skill_inst_params_list(item) + " "
+        elif isinstance(item, np.ndarray):  # nested list
+            list_str += _py2skill_inst_params_list(item) + " "
+        elif isinstance(item, str):
+            list_str += '"' + str(item) + '" '
+        elif isinstance(item, float):
+            list_str += str(item)
+            # list_str += _py2skill_float(item, scale) + " "
+        elif isinstance(item, bool):
+            if item:
+                list_str += "t "
+            else:
+                list_str += "nil "
+        elif isinstance(item, int) or isinstance(item, np.integer):
+            # fmt_str = "%."+"%d" % (-1*log10(scale)+1)+"f "  # for truncations
+            # list_str += fmt_str%(item*scale) + " "
+            # list_str += _py2skill_number(item, 1) + " "  # do not scale integers
+            list_str += str(item) + " "  # do not scale integers
+    list_str += ")"
+    return list_str
+
+
+def _py2skill_inst_params(value_dict):
+    """Convert instance parameter dictionary to skill list"""
+    _list = []
+    for k, v in value_dict.items():
+        if isinstance(v, str):
+            _type = "string"
+        elif isinstance(v, float):
+            _type = "float"
+        elif isinstance(v, bool):
+            _type = "boolean"
+        elif isinstance(v, int) or isinstance(v, np.integer):
+            _type = "int"
+        _list.append([k, _type, v])
+    return _py2skill_inst_params_list(_list)
+
+
+def _translate_obj(objname, obj, scale=0.001, master=None, offset=np.array([0, 0])):
+    """
+    Convert an object to corresponding skill commands.
+    offset : np.array([int, int])
+        Offsets to obj.xy
+    """
+    if master is None:
+        mxy = np.array([0, 0])
+        mtf = "R0"
+    else:  # if the translated object has a master (e.g. VirtualInstance)
+        mxy = master.xy
+        mtf = master.transform
+    if obj.__class__ == laygo2.object.Rect:
+        # coloring
+        if obj.color == None:
+            color = "not MPT"
+        else:
+            color = obj.color
+        # Invoke _laygo2_generate_rect( cv layer bbox ) in {header_filename}
+        _xy = np.sort(obj.xy, axis=0)  # make sure obj.xy is sorted
+        _xy = mxy + np.dot(
+            _xy
+            + np.array(
+                [[-obj.hextension, -obj.vextension], [obj.hextension, obj.vextension]]
+            ),
+            tf.Mt(mtf).T,
+        )
+        # _xy = mxy + np.dot(obj.xy + np.array([[-obj.hextension, -obj.vextension], [obj.hextension, obj.vextension]]),
+        #                   tf.Mt(mtf).T)
+        return '_laygo2_generate_rect(cv, %s, %s, "%s") ; for the Rect object %s \n' % (
+            _py2skill_list(obj.layer),
+            _py2skill_list(_xy, scale=scale),
+            color,
+            objname,
+        )  # coloring func. added
+    elif obj.__class__ == laygo2.object.Path:
+        # TODO: implement path export function.
+        pass
+    elif obj.__class__ == laygo2.object.Pin:
+        if obj.elements is None:
+            _objelem = [obj]
+        else:
+            _objelem = obj.elements
+        for idx, _obj in np.ndenumerate(_objelem):
+            # Invoke _laygo2_generate_pin(cv, name, layer, bbox) in {header_filename}
+            _xy = mxy + np.dot(_obj.xy, tf.Mt(mtf).T)
+            return (
+                '_laygo2_generate_pin(cv, "%s", %s, %s ) ; for the Pin object %s \n'
+                % (
+                    _obj.netname,
+                    _py2skill_list(_obj.layer),
+                    _py2skill_list(_xy, scale=scale),
+                    objname,
+                )
+            )
+    elif obj.__class__ == laygo2.object.Text:
+        # TODO: implement text export function.
+        pass
+    elif obj.__class__ == laygo2.object.Instance:
+        # Invoke _laygo2_generate_instance( cv name libname cellname viewname loc orient num_rows num_cols
+        # sp_rows sp_cols params params_order )
+        _xy = mxy + np.dot(obj.xy, tf.Mt(mtf).T)
+        if master is None:
+            transform = obj.transform
+        else:  # if the translated object has a master (e.g. VirtualInstance)
+            transform = tf.combine(obj.transform, master.transform)
+        if obj.shape is None:
+            num_rows = 1
+            num_cols = 1
+            sp_rows = 0
+            sp_cols = 0
+        else:
+            num_rows = obj.shape[1]
+            num_cols = obj.shape[0]
+            sp_rows = _py2skill_number(obj.pitch[1])
+            sp_cols = _py2skill_number(obj.pitch[0])
+        if obj.params is None:
+            inst_params = "nil"
+        else:
+            inst_params = _py2skill_inst_params(obj.params["pcell_params"])
+            # inst_params = _py2skill_list([["Wfg", "string", "500n"], ["fingers", "string", "4"], ["l", "string", "500n"]])
+        return (
+            '_laygo2_generate_instance(cv, "%s", "%s", "%s", "%s", %s, "%s", %d, %d, %s, %s, %s, %s) '
+            "; for the Instance object %s \n"
+            % (
+                objname,
+                obj.libname,
+                obj.cellname,
+                obj.viewname,
+                _py2skill_list(_xy),
+                transform,
+                num_rows,
+                num_cols,
+                sp_rows,
+                sp_cols,
+                inst_params,
+                "nil",
+                objname,
+            )
+        )
+    elif obj.__class__ == laygo2.object.VirtualInstance:
+        cmd = ""
+        if obj.shape is None:
+            for elem_name, elem in obj.native_elements.items():
+                if not elem.__class__ == laygo2.object.Pin:
+                    if obj.name == None:
+                        obj.name = "NoName"
+                    else:
+                        pass
+                    cmd += _translate_obj(
+                        obj.name + "_" + elem_name, elem, scale=scale, master=obj
+                    )
+        else:  # arrayed VirtualInstance
+            for i, j in np.ndindex(tuple(obj.shape.tolist())):  # iterate over obj.shape
+                for elem_name, elem in obj.native_elements.items():
+                    if not elem.__class__ == laygo2.object.Pin:
+                        cmd += _translate_obj(
+                            obj.name + "_" + elem_name + str(i) + "_" + str(j),
+                            elem,
+                            scale=scale,
+                            master=obj[i, j],
+                        )
+        return cmd
+    elif obj.__class__ == laygo2.object.Via: # For autovia skill
+        cmd = ""
+        center = _py2skill_list(obj.center, scale=scale)
+        cut = obj.params['cut']
+        color = obj.color # coloring func. added
+        layer = _py2skill_list([obj.params['xlayer'],obj.params['ylayer']])
+        cmd += "_laygo2_generate_autovia(cv,%s, %s, \"%s\", \"%s\", \"%s\") "  \
+               "; for the Via object %s \n" \
+               % (layer, center, cut, color, tech.name, objname)
+        return cmd
+    else:
+        return obj.translate_to_skill()  #
+
+    return ""
+
+
+def export(
+    db, filename=None, cellname=None, scale=1e-3, reset_library=False, tech_library=None
+):
+    """
+    Export a laygo2.object.database.Library object to skill code.
+
+    Parameters
+    ----------
+    db: laygo2.database.Library
+        The library database to exported.
+    filename: str, optional
+        If specified, the generated skill script is stored in filename.
+    cellname: str or List[str]
+        The name(s) of cell(s) to be exported.
+    scale: float
+        The scaling factor between laygo2's integer coordinats actual physical coordinates.
+    reset_library: bool, optional
+        If True, the library to export the cells is reset.
+    tech_library: str, optional
+        The name of technology library to be attached to the resetted library.
+
+    Returns
+    -------
+    str: The generated skill script.
+
+    Example
+    --------
+    >>> import laygo2
+    >>> from laygo2.object.database import Design
+    >>> from laygo2.object.physical import Rect, Pin, Instance, Text
+    >>> # Create a design.
+    >>> dsn = Design(name="mycell", libname="genlib")
+    >>> # Create layout objects.
+    >>> r0 = Rect(xy=[[0, 0], [100, 100]], layer=["M1", "drawing"])
+    >>> p0 = Pin(xy=[[0, 0], [50, 50]], layer=["M1", "pin"], name="P")
+    >>> i0 = Instance(libname="tlib", cellname="t0", name="I0", xy=[0, 0])
+    >>> t0 = Text(xy=[50, 50], layer=["text", "drawing"], text="T")
+    >>> # Add the layout objects to the design object.
+    >>> dsn.append(r0)
+    >>> dsn.append(p0)
+    >>> dsn.append(i0)
+    >>> dsn.append(t0)
+    >>> #
+    >>> # Export to skill.
+    >>> lib = laygo2.object.database.Library(name="mylib")
+    >>> lib.append(dsn)
+    >>> scr = laygo2.interface.skill.export(lib, filename="myscript.il")
+    >>> print(scr)
+    ; (definitions of laygo2 skill functions)
+    ; exporting mylib__mycell
+    cv = _laygo2_open_layout("mylib" "mycell" "layout")
+    _laygo2_generate_rect(cv, list( "M1" "drawing" ), list( list( 0.0000  0.0000  ) list( 0.1000  0.1000  ) ), "None")
+    _laygo2_generate_pin(cv, "P", list( "M1" "pin" ), list( list( 0.0000  0.0000  ) list( 0.0500  0.0500  ) ) )
+    _laygo2_generate_instance(cv, "I0", "tlib", "t0", "layout", list( 0.0000  0.0000  ), "R0", 1, 1, 0, 0, nil, nil)
+    _laygo2_save_and_close_layout(cv)
+
+    """
+    # parse header functions.
+    cmd = "; laygo2 layout export skill script.\n\n"
+    import os
+
+    header_filename = (
+        os.path.abspath(laygo2.interface.__file__)[:-11] + "skill_export.il"
+    )
+    with open(header_filename, "r") as f:
+        cmd += f.read()
+        cmd += "\n"
+
+    cellname = (
+        db.keys() if cellname is None else cellname
+    )  # export all cells if cellname is not given.
+    cellname = (
+        [cellname] if isinstance(cellname, str) else cellname
+    )  # convert to a list for iteration.
+    if reset_library:
+        cmd += '_laygo2_reset_library("%s" "%s")\n' % (db.name, tech_library)
+    for cn in cellname:
+        cmd += "\n; exporting %s__%s\n" % (db.name, cn)  # open the design.
+        logging.debug("Export_to_SKILL: Cellname:" + cn)
+        # cmd += "let( (cv) \n"  # limit the scope of cv. Disabled to prevent overflow.
+        cmd += 'cv = _laygo2_open_layout("%s" "%s" "layout")\n' % (
+            db.name,
+            cn,
+        )  # open the design.
+        # export objects
+        for objname, obj in db[cn].items():
+            cmd += _translate_obj(objname, obj, scale=scale)
+        cmd += "_laygo2_save_and_close_layout(cv)\n"  # close the layout
+        # cmd += ");let\n" Disabled to prevent overflow.
+    if filename is not None:  # export to a file.
+        with open(filename, "w") as f:
+            f.write(cmd)
+    return cmd
+
+
+def load_cell_list(libname, filename, yaml_filename="import_skill_scratch.yaml"):
+    # parse header functions.
+    cmd = "; laygo2 cell-list load script.\n\n"
+    import os
+
+    header_filename = (
+        os.path.abspath(laygo2.interface.__file__)[:-11] + "skill_import.il"
+    )
+    with open(header_filename, "r") as f:
+        cmd += f.read()
+        cmd += "\n"
+    cmd += '_laygo2_get_cell_list("%s" "%s")\n' % (libname, yaml_filename)
+    if filename is not None:  # export to a file.
+        with open(filename, "w") as f:
+            f.write(cmd)
+    return cmd
+
+
+def load(libname, mpt=False, cellname=None, filename=None, yaml_filename="import_skill_scratch.yaml"):
+    mpt = "t" if mpt else "nil"
+    cmd = "; laygo2 cell load script.\n\n"
+    cmd += '_laygo2_parse_cad_layout("%s" "%s" "%s" "%s" )\n' %(libname, cellname, yaml_filename, mpt)
+    #cmd += "_laygo2_parse_cad_layout(\"" + libname + "\" \"" + cn + "\" \"" + yaml_filename + "\" \"" + mpt + "\")"
+    if filename is not None:  # export to a file.
+        with open(filename, "w") as f:
+            f.write(cmd)
+    return cmd
+
```

### Comparing `laygo2-0.5.6/laygo2/interface/gds.py` & `laygo2-0.5.7/laygo2/interface/gds.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,240 +1,240 @@
-#!/usr/bin/python
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-"""
-This module implements interfaces with gds files via gdspy.
-Hard copy of gds.py. This file will be deprecated soon.
-"""
-
-import logging
-import pprint
-from math import log10
-from decimal import *
-import laygo2.util.transform as tf
-
-import numpy as np
-
-import laygo2.object
-
-def _load_layermap(layermapfile):
-    """
-    Load layermap information from layermapfile (Foundry techfile can be used)
-
-    Parameters
-    ----------
-    layermapfile : str
-        layermap filename.
-
-        The example file can be found in default.layermap or see below:
-        #technology layer information
-        #layername  layerpurpose stream# datatype
-        text        drawing 100 0
-        prBoundary  drawing 101 0
-        M1      drawing 50  0
-        M1      pin     50  10
-        M2      drawing 51  0
-        M2      pin     51  10
-
-    Returns
-    -------
-    dict
-        constructed layermap information.
-
-    """
-    layermap = dict()
-    f = open(layermapfile, 'r')
-    for line in f:
-        tokens = line.split()
-        if not len(tokens) == 0:
-            if not tokens[0].startswith('#'):
-                name = tokens[0]
-                #if not layermap.has_key(name):
-                if name not in layermap:
-                    layermap[name] = dict()
-                layermap[name][tokens[1]] = {"layer":int(tokens[2]), "datatype":int(tokens[3])}
-    return layermap
-
-
-def _translate_obj(objname, obj, layermap, scale=0.001, master=None, offset=np.array([0, 0]), 
-                   pin_label_height=0.1):
-    """
-    Convert an object to corresponding skill commands.
-    offset : np.array([int, int])
-        Offsets to obj.xy
-    """
-    # import gdspy here to avoid unnecessary C++ compliations for non-gds options.
-    import gdspy
-
-    if master is None:  
-        mxy = np.array([0, 0])
-        mtf = 'R0'
-    else: # if the translated object has a master (e.g. VirtualInstance)
-        mxy = master.xy
-        mtf = master.transform
-
-    if obj.__class__ == laygo2.object.Rect:
-        ## TODO: add color handling.
-        #color = obj.color # coloring function example for skill.
-        
-        _xy = np.sort(obj.xy, axis=0)  # make sure obj.xy is sorted
-        _xy = mxy + np.dot(_xy + np.array([[-obj.hextension, -obj.vextension], 
-                           [obj.hextension, obj.vextension]]), tf.Mt(mtf).T)
-         
-        l = layermap[obj.layer[0]][obj.layer[1]]
-        rect = gdspy.Rectangle((_xy[0, 0], _xy[0, 1]), (_xy[1, 0], _xy[1, 1]), **l)
-        return rect
-    elif obj.__class__ == laygo2.object.Path:
-        # TODO: implement path export function.
-        pass
-    elif obj.__class__ == laygo2.object.Pin:
-        if obj.elements is None:
-            _objelem = [obj]
-        else:
-            _objelem = obj.elements
-        item = []
-        for idx, _obj in np.ndenumerate(_objelem):
-            _xy = mxy + np.dot(_obj.xy, tf.Mt(mtf).T)
-            l = layermap[_obj.layer[0]][_obj.layer[1]]
-            rect = gdspy.Rectangle((_xy[0, 0], _xy[0, 1]), (_xy[1, 0], _xy[1, 1]), **l)
-            _xy_c = 0.5*(_xy[0, :] + _xy[1, :])
-            text = gdspy.Label(_obj.netname, _xy_c, "nw", magnification=pin_label_height*100) 
-            item += [rect, text]
-        return item
-    elif obj.__class__ == laygo2.object.Text:
-        # TODO: implement text export function.
-        pass
-    elif obj.__class__ == laygo2.object.Instance:
-        print("[Warning] laygo2.interface.gdspy: Instance transform is not implemented yet.")
-        _xy = mxy + np.dot(obj.xy, tf.Mt(mtf).T)
-        if master is None:  
-            transform = obj.transform
-        else: # if the translated object has a master (e.g. VirtualInstance)
-            transform = tf.combine(obj.transform, master.transform)
-        if obj.shape is None:
-            num_rows = 1
-            num_cols = 1
-            sp_rows = 0
-            sp_cols = 0
-        else:
-            num_rows = obj.shape[1]
-            num_cols = obj.shape[0]
-            sp_rows = obj.pitch[1]
-            sp_cols = obj.pitch[0]
-        #if obj.params is None:  # gds cannot handle pcell parameters.
-        #    inst_params = "nil"
-        #else:
-        #    inst_params = _py2skill_inst_params(obj.params['pcell_params'])
-        inst = gdspy.CellReference(obj.cellname, _xy) #, transform)
-        return inst
-    elif obj.__class__ == laygo2.object.VirtualInstance:
-        item = []
-        if obj.shape is None:
-            for elem_name, elem in obj.native_elements.items():
-                if not elem.__class__ == laygo2.object.Pin:
-                    if obj.name == None:
-                        obj.name='NoName'
-                    else:
-                        pass
-                    item += [_translate_obj(obj.name + '_' + elem_name, elem, layermap=layermap, 
-                                           master=obj, scale=scale, pin_label_height=pin_label_height)]
-        else:  # arrayed VirtualInstance
-            for i, j in np.ndindex(tuple(obj.shape.tolist())):  # iterate over obj.shape
-                for elem_name, elem in obj.native_elements.items():
-                    if not elem.__class__ == laygo2.object.Pin:
-                        item += [_translate_obj(obj.name + '_' + elem_name + str(i) + '_' + str(j), 
-                                               elem, layermap=layermap, master=obj[i, j],
-                                               scale=scale, pin_label_height=pin_label_height)]
-        return item
-    return None
-    #raise Exception("No corresponding GDS structure for:"+obj.summarize())
-
-
-def export(db, filename, cellname=None, scale = 1e-9, layermapfile="default.layermap",
-           physical_unit=1e-9, logical_unit=0.001, pin_label_height=0.1,
-           svg_filename=None,png_filename=None):
-    """
-    Export design(s) to skill code.
-
-    Parameters
-    ----------
-    db: laygo2.database.Library
-        The library database to exported.
-    filename: str, optional
-        If specified, the generated skill script is stored in filename.
-    cellname: str or List[str]
-        The name(s) of cell(s) to be exported.
-    scale: float
-        The scaling factor between laygo2's integer coordinats actual physical coordinates.
-    layermapfile : str
-        the name of layermap file.
-    physical_unit : float, optional
-        GDS physical unit.
-    logical_unit : float, optional
-        GDS logical unit.
-    pin_label_height : float, optional
-        the height of pin label.
-    svg_filename: str, optional
-        If specified, it exports a svg file with the specified filename. 
-    svg_filename: str, optional
-        If specified, it exports a png file with the specified filename 
-        (svg_filename needs to be specified as well). 
-    """
-    #raise Exception("GDS support is currently disabled. Will be reinvented by using gds-tk.")
-    
-    # Compute scale parameter.
-    _scale = round(1/scale*physical_unit/logical_unit)
-    # 1um in phy
-    # 1um/1nm = 1000 in laygo2 if scale = 1e-9 (1nm)
-    # 1000/1nm*1nm/0.001 = 1000000 in gds if physical_unit = 1e-9 (1nm) and logical_unit = 0.001
-
-    # Load layermap file.
-    layermap = _load_layermap(layermapfile)  # load layermap information
-
-    # Construct cellname.    
-    cellname = db.keys() if cellname is None else cellname  # export all cells if cellname is not given.
-    cellname = [cellname] if isinstance(cellname, str) else cellname  # convert to a list for iteration.
-
-    # import gdspy here to avoid unnecessary C++ compliations for non-gds options.
-    import gdspy
-
-    # Create library.
-    lib = gdspy.GdsLibrary()
-    for cn in cellname:
-        # Create cell.
-        cell = lib.new_cell(cn)
-        # Translate objects.
-        for objname, obj in db[cn].items():
-            tobj = _translate_obj(objname, obj, layermap=layermap, scale=_scale,
-                                  pin_label_height=pin_label_height,
-                                 )
-            if tobj is not None:
-                cell.add(tobj)
-    lib.write_gds(filename)
-    if svg_filename is not None: 
-        cell.write_svg(svg_filename)
-        if svg_filename is not None: 
-            # import cairosvg here to avoid unnecessary lib installation for non-gds options.
-            import cairosvg
-            cairosvg.svg2png(url=svg_filename, write_to=png_filename, scale=1.0)
+#!/usr/bin/python
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+"""
+This module implements interfaces with gds files via gdspy.
+Hard copy of gds.py. This file will be deprecated soon.
+"""
+
+import logging
+import pprint
+from math import log10
+from decimal import *
+import laygo2.util.transform as tf
+
+import numpy as np
+
+import laygo2.object
+
+def _load_layermap(layermapfile):
+    """
+    Load layermap information from layermapfile (Foundry techfile can be used)
+
+    Parameters
+    ----------
+    layermapfile : str
+        layermap filename.
+
+        The example file can be found in default.layermap or see below:
+        #technology layer information
+        #layername  layerpurpose stream# datatype
+        text        drawing 100 0
+        prBoundary  drawing 101 0
+        M1      drawing 50  0
+        M1      pin     50  10
+        M2      drawing 51  0
+        M2      pin     51  10
+
+    Returns
+    -------
+    dict
+        constructed layermap information.
+
+    """
+    layermap = dict()
+    f = open(layermapfile, 'r')
+    for line in f:
+        tokens = line.split()
+        if not len(tokens) == 0:
+            if not tokens[0].startswith('#'):
+                name = tokens[0]
+                #if not layermap.has_key(name):
+                if name not in layermap:
+                    layermap[name] = dict()
+                layermap[name][tokens[1]] = {"layer":int(tokens[2]), "datatype":int(tokens[3])}
+    return layermap
+
+
+def _translate_obj(objname, obj, layermap, scale=0.001, master=None, offset=np.array([0, 0]), 
+                   pin_label_height=0.1):
+    """
+    Convert an object to corresponding skill commands.
+    offset : np.array([int, int])
+        Offsets to obj.xy
+    """
+    # import gdspy here to avoid unnecessary C++ compliations for non-gds options.
+    import gdspy
+
+    if master is None:  
+        mxy = np.array([0, 0])
+        mtf = 'R0'
+    else: # if the translated object has a master (e.g. VirtualInstance)
+        mxy = master.xy
+        mtf = master.transform
+
+    if obj.__class__ == laygo2.object.Rect:
+        ## TODO: add color handling.
+        #color = obj.color # coloring function example for skill.
+        
+        _xy = np.sort(obj.xy, axis=0)  # make sure obj.xy is sorted
+        _xy = mxy + np.dot(_xy + np.array([[-obj.hextension, -obj.vextension], 
+                           [obj.hextension, obj.vextension]]), tf.Mt(mtf).T)
+         
+        l = layermap[obj.layer[0]][obj.layer[1]]
+        rect = gdspy.Rectangle((_xy[0, 0], _xy[0, 1]), (_xy[1, 0], _xy[1, 1]), **l)
+        return rect
+    elif obj.__class__ == laygo2.object.Path:
+        # TODO: implement path export function.
+        pass
+    elif obj.__class__ == laygo2.object.Pin:
+        if obj.elements is None:
+            _objelem = [obj]
+        else:
+            _objelem = obj.elements
+        item = []
+        for idx, _obj in np.ndenumerate(_objelem):
+            _xy = mxy + np.dot(_obj.xy, tf.Mt(mtf).T)
+            l = layermap[_obj.layer[0]][_obj.layer[1]]
+            rect = gdspy.Rectangle((_xy[0, 0], _xy[0, 1]), (_xy[1, 0], _xy[1, 1]), **l)
+            _xy_c = 0.5*(_xy[0, :] + _xy[1, :])
+            text = gdspy.Label(_obj.netname, _xy_c, "nw", magnification=pin_label_height*100) 
+            item += [rect, text]
+        return item
+    elif obj.__class__ == laygo2.object.Text:
+        # TODO: implement text export function.
+        pass
+    elif obj.__class__ == laygo2.object.Instance:
+        print("[Warning] laygo2.interface.gdspy: Instance transform is not implemented yet.")
+        _xy = mxy + np.dot(obj.xy, tf.Mt(mtf).T)
+        if master is None:  
+            transform = obj.transform
+        else: # if the translated object has a master (e.g. VirtualInstance)
+            transform = tf.combine(obj.transform, master.transform)
+        if obj.shape is None:
+            num_rows = 1
+            num_cols = 1
+            sp_rows = 0
+            sp_cols = 0
+        else:
+            num_rows = obj.shape[1]
+            num_cols = obj.shape[0]
+            sp_rows = obj.pitch[1]
+            sp_cols = obj.pitch[0]
+        #if obj.params is None:  # gds cannot handle pcell parameters.
+        #    inst_params = "nil"
+        #else:
+        #    inst_params = _py2skill_inst_params(obj.params['pcell_params'])
+        inst = gdspy.CellReference(obj.cellname, _xy) #, transform)
+        return inst
+    elif obj.__class__ == laygo2.object.VirtualInstance:
+        item = []
+        if obj.shape is None:
+            for elem_name, elem in obj.native_elements.items():
+                if not elem.__class__ == laygo2.object.Pin:
+                    if obj.name == None:
+                        obj.name='NoName'
+                    else:
+                        pass
+                    item += [_translate_obj(obj.name + '_' + elem_name, elem, layermap=layermap, 
+                                           master=obj, scale=scale, pin_label_height=pin_label_height)]
+        else:  # arrayed VirtualInstance
+            for i, j in np.ndindex(tuple(obj.shape.tolist())):  # iterate over obj.shape
+                for elem_name, elem in obj.native_elements.items():
+                    if not elem.__class__ == laygo2.object.Pin:
+                        item += [_translate_obj(obj.name + '_' + elem_name + str(i) + '_' + str(j), 
+                                               elem, layermap=layermap, master=obj[i, j],
+                                               scale=scale, pin_label_height=pin_label_height)]
+        return item
+    return None
+    #raise Exception("No corresponding GDS structure for:"+obj.summarize())
+
+
+def export(db, filename, cellname=None, scale = 1e-9, layermapfile="default.layermap",
+           physical_unit=1e-9, logical_unit=0.001, pin_label_height=0.1,
+           svg_filename=None,png_filename=None):
+    """
+    Export design(s) to skill code.
+
+    Parameters
+    ----------
+    db: laygo2.database.Library
+        The library database to exported.
+    filename: str, optional
+        If specified, the generated skill script is stored in filename.
+    cellname: str or List[str]
+        The name(s) of cell(s) to be exported.
+    scale: float
+        The scaling factor between laygo2's integer coordinats actual physical coordinates.
+    layermapfile : str
+        the name of layermap file.
+    physical_unit : float, optional
+        GDS physical unit.
+    logical_unit : float, optional
+        GDS logical unit.
+    pin_label_height : float, optional
+        the height of pin label.
+    svg_filename: str, optional
+        If specified, it exports a svg file with the specified filename. 
+    svg_filename: str, optional
+        If specified, it exports a png file with the specified filename 
+        (svg_filename needs to be specified as well). 
+    """
+    #raise Exception("GDS support is currently disabled. Will be reinvented by using gds-tk.")
+    
+    # Compute scale parameter.
+    _scale = round(1/scale*physical_unit/logical_unit)
+    # 1um in phy
+    # 1um/1nm = 1000 in laygo2 if scale = 1e-9 (1nm)
+    # 1000/1nm*1nm/0.001 = 1000000 in gds if physical_unit = 1e-9 (1nm) and logical_unit = 0.001
+
+    # Load layermap file.
+    layermap = _load_layermap(layermapfile)  # load layermap information
+
+    # Construct cellname.    
+    cellname = db.keys() if cellname is None else cellname  # export all cells if cellname is not given.
+    cellname = [cellname] if isinstance(cellname, str) else cellname  # convert to a list for iteration.
+
+    # import gdspy here to avoid unnecessary C++ compliations for non-gds options.
+    import gdspy
+
+    # Create library.
+    lib = gdspy.GdsLibrary()
+    for cn in cellname:
+        # Create cell.
+        cell = lib.new_cell(cn)
+        # Translate objects.
+        for objname, obj in db[cn].items():
+            tobj = _translate_obj(objname, obj, layermap=layermap, scale=_scale,
+                                  pin_label_height=pin_label_height,
+                                 )
+            if tobj is not None:
+                cell.add(tobj)
+    lib.write_gds(filename)
+    if svg_filename is not None: 
+        cell.write_svg(svg_filename)
+        if svg_filename is not None: 
+            # import cairosvg here to avoid unnecessary lib installation for non-gds options.
+            import cairosvg
+            cairosvg.svg2png(url=svg_filename, write_to=png_filename, scale=1.0)
     #gdspy.LayoutViewer()
```

### Comparing `laygo2-0.5.6/laygo2/__init__.py` & `laygo2-0.5.7/laygo2/__init__.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-# -*- coding: utf-8 -*-
-########################################################################################################################
-#
-# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
-# following conditions are met:
-#
-# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
-#   disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
-#    following disclaimer in the documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
-# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-########################################################################################################################
-
-"""laygo2 package"""
-
-#from .object import *
-#from .util import *
-
-# Objects
-from . import object
-from .object import *
-from .object.database import *
-from .object.grid import *
-from .object.physical import *
-from .object.template import *
-
-# Interface
-from . import interface
-from .interface.yaml import export_template
-from .interface.bag import export as export_to_bag
-from .interface.skill import export as export_to_skill
-#from . import util
-
-# Util
-from . import util
-
-#__all__ = ['object', 'util']
-#__all__ = ['object', 'PrimitiveUtil']
-
-
+# -*- coding: utf-8 -*-
+########################################################################################################################
+#
+# Copyright (c) 2020, Nifty Chips Laboratory, Hanyang University
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
+# following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
+#   disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
+#    following disclaimer in the documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+########################################################################################################################
+
+"""laygo2 package"""
+
+#from .object import *
+#from .util import *
+
+# Objects
+from . import object
+from .object import *
+from .object.database import *
+from .object.grid import *
+from .object.physical import *
+from .object.template import *
+
+# Interface
+from . import interface
+from .interface.yaml import export_template
+from .interface.bag import export as export_to_bag
+from .interface.skill import export as export_to_skill
+#from . import util
+
+# Util
+from . import util
+
+#__all__ = ['object', 'util']
+#__all__ = ['object', 'PrimitiveUtil']
+
+
```

