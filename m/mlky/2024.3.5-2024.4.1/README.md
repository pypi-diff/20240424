# Comparing `tmp/mlky-2024.3.5-py3-none-any.whl.zip` & `tmp/mlky-2024.4.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,31 +1,31 @@
-Zip file size: 52791 bytes, number of entries: 29
--rw-r--r--  2.0 unx      128 b- defN 24-Mar-19 19:57 mlky/__init__.py
+Zip file size: 55749 bytes, number of entries: 29
+-rw-r--r--  2.0 unx      128 b- defN 24-Apr-11 20:58 mlky/__init__.py
 -rw-r--r--  2.0 unx     7187 b- defN 23-Aug-10 22:28 mlky/utils.py
 -rw-r--r--  2.0 unx      857 b- defN 24-Mar-07 22:18 mlky/configs/__init__.py
--rw-r--r--  2.0 unx     8436 b- defN 24-Mar-07 22:37 mlky/configs/builtins.py
+-rw-r--r--  2.0 unx     9766 b- defN 24-Apr-23 21:41 mlky/configs/builtins.py
 -rw-r--r--  2.0 unx     5128 b- defN 24-Mar-08 00:30 mlky/configs/cli.py
--rw-r--r--  2.0 unx     5767 b- defN 23-Dec-07 23:02 mlky/configs/config.py
+-rw-r--r--  2.0 unx     5713 b- defN 24-Apr-22 17:52 mlky/configs/config.py
 -rw-r--r--  2.0 unx     9447 b- defN 23-Dec-07 22:51 mlky/configs/definitions.py
 -rw-r--r--  2.0 unx     2650 b- defN 23-Dec-07 22:51 mlky/configs/funcs.py
 -rw-r--r--  2.0 unx     4601 b- defN 23-Aug-17 21:54 mlky/configs/functions.py
--rw-r--r--  2.0 unx     4322 b- defN 24-Mar-07 22:34 mlky/configs/magics.py
--rw-r--r--  2.0 unx     2293 b- defN 24-Jan-04 20:22 mlky/configs/null.py
+-rw-r--r--  2.0 unx     5051 b- defN 24-Apr-22 18:45 mlky/configs/magics.py
+-rw-r--r--  2.0 unx     3005 b- defN 24-Apr-11 20:09 mlky/configs/null.py
 -rw-r--r--  2.0 unx     3802 b- defN 23-Feb-25 02:12 mlky/configs/registers.py
--rw-r--r--  2.0 unx    31807 b- defN 24-Feb-28 22:15 mlky/configs/sect.py
+-rw-r--r--  2.0 unx    35950 b- defN 24-Apr-23 22:32 mlky/configs/sect.py
 -rw-r--r--  2.0 unx    16228 b- defN 23-Jun-13 22:37 mlky/configs/section.py
 -rw-r--r--  2.0 unx     2849 b- defN 23-Dec-07 22:51 mlky/configs/ui.py
--rw-r--r--  2.0 unx    16225 b- defN 24-Mar-19 19:57 mlky/configs/var.py
+-rw-r--r--  2.0 unx    20595 b- defN 24-Apr-23 23:13 mlky/configs/var.py
 -rw-r--r--  2.0 unx      128 b- defN 23-Dec-07 22:51 mlky/utils/__init__.py
--rw-r--r--  2.0 unx     5059 b- defN 23-Dec-14 21:16 mlky/utils/formatters.py
+-rw-r--r--  2.0 unx     5087 b- defN 24-Apr-23 23:02 mlky/utils/formatters.py
 -rw-r--r--  2.0 unx      868 b- defN 23-Dec-07 22:51 mlky/utils/funcs.py
 -rw-r--r--  2.0 unx     1597 b- defN 23-Dec-07 22:51 mlky/utils/io.py
 -rw-r--r--  2.0 unx      605 b- defN 23-Dec-07 22:51 mlky/utils/prettyslice.py
 -rw-r--r--  2.0 unx     1044 b- defN 23-Dec-07 22:51 mlky/utils/templates.py
--rw-r--r--  2.0 unx     3688 b- defN 24-Mar-12 00:48 mlky/utils/track.py
--rw-r--r--  2.0 unx    11357 b- defN 24-Mar-19 20:16 mlky-2024.3.5.dist-info/LICENSE
--rw-r--r--  2.0 unx     5248 b- defN 24-Mar-19 20:16 mlky-2024.3.5.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Mar-19 20:16 mlky-2024.3.5.dist-info/WHEEL
--rw-r--r--  2.0 unx       40 b- defN 24-Mar-19 20:16 mlky-2024.3.5.dist-info/entry_points.txt
--rw-r--r--  2.0 unx        5 b- defN 24-Mar-19 20:16 mlky-2024.3.5.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2276 b- defN 24-Mar-19 20:16 mlky-2024.3.5.dist-info/RECORD
-29 files, 153734 bytes uncompressed, 49195 bytes compressed:  68.0%
+-rw-r--r--  2.0 unx     4024 b- defN 24-Apr-10 21:31 mlky/utils/track.py
+-rw-r--r--  2.0 unx    11357 b- defN 24-Apr-23 23:31 mlky-2024.4.1.dist-info/LICENSE
+-rw-r--r--  2.0 unx     5248 b- defN 24-Apr-23 23:31 mlky-2024.4.1.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-Apr-23 23:31 mlky-2024.4.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx       40 b- defN 24-Apr-23 23:31 mlky-2024.4.1.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx        5 b- defN 24-Apr-23 23:31 mlky-2024.4.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2276 b- defN 24-Apr-23 23:31 mlky-2024.4.1.dist-info/RECORD
+29 files, 165328 bytes uncompressed, 52153 bytes compressed:  68.5%
```

## zipnote {}

```diff
@@ -63,26 +63,26 @@
 
 Filename: mlky/utils/templates.py
 Comment: 
 
 Filename: mlky/utils/track.py
 Comment: 
 
-Filename: mlky-2024.3.5.dist-info/LICENSE
+Filename: mlky-2024.4.1.dist-info/LICENSE
 Comment: 
 
-Filename: mlky-2024.3.5.dist-info/METADATA
+Filename: mlky-2024.4.1.dist-info/METADATA
 Comment: 
 
-Filename: mlky-2024.3.5.dist-info/WHEEL
+Filename: mlky-2024.4.1.dist-info/WHEEL
 Comment: 
 
-Filename: mlky-2024.3.5.dist-info/entry_points.txt
+Filename: mlky-2024.4.1.dist-info/entry_points.txt
 Comment: 
 
-Filename: mlky-2024.3.5.dist-info/top_level.txt
+Filename: mlky-2024.4.1.dist-info/top_level.txt
 Comment: 
 
-Filename: mlky-2024.3.5.dist-info/RECORD
+Filename: mlky-2024.4.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## mlky/__init__.py

```diff
@@ -1,7 +1,7 @@
 """
 """
-__version__ = '2024.03.5'
+__version__ = '2024.04.1'
 
 # Instantiate before the CLI
 from mlky.configs     import *
 from mlky.configs.cli import CLI
```

## mlky/configs/builtins.py

```diff
@@ -25,15 +25,15 @@
     key: str
         Key name for the environment variable to retrieve
     other: any, defaults=''
         Return this value if the key doesn't exist in the environment
 
     Returns
     -------
-    str, any
+    str | any
         If the key exists the return will be a str, otherwise return the `other`
         parameter
     """
     return os.environ.get(key, other)
 
 
 @register()
@@ -96,15 +96,15 @@
         List of objects to check if `value` is in
     regex: bool, defaults=False
         Informs that the options of the list are regex strings to compare to.
         The `value` is oneof `options` if `value` regex matches to any option.
 
     Returns
     -------
-    True, str
+    True | str
         Returns True if `value` is oneof `options`, otherwise return an error
         message as a string
     """
     value   = var.getValue()
     options = opts or options
     if regex:
         for opt in options:
@@ -148,15 +148,15 @@
     Parameters
     ----------
     var: mlky.Var
         The Var object to check os.path.isdir(var.value) on
 
     Returns
     -------
-    bool or str
+    bool | str
         Returns True if the path exists, otherwise returns an error string
     """
     path = var.getValue()
     if path is Null:
         if var.strict or var.required:
             return f'Directory path not provided'
         else:
@@ -172,15 +172,15 @@
     Parameters
     ----------
     var: mlky.Var
         The Var object to check os.path.isfile(var.value) on
 
     Returns
     -------
-    bool or str
+    bool | str
         Returns True if the path exists, otherwise returns an error string
     """
     path = var.getValue()
     if path is Null:
         if var.strict or var.required:
             return f'File path not provided'
         else:
@@ -223,25 +223,25 @@
     ----------
     value: any
         The value to compare
     a: any
         The upper bound comparison
     b: any
         The lower bound comparison
-    inclusive: bool or str, defaults=False
+    inclusive: bool | str, defaults=False
         Boundary inclusivity:
         - False   = Both bounds are exclusive
         - 'lower' = The lower bound is inclusive, upper is not
         - 'upper' = The upper bound is inclusive, lower is not
         - 'both'  = Both bounds are inclusive
         - True    = Both bounds are inclusive
 
     Returns
     -------
-    list or True
+    list | True
         Returns compare(value) with the correct bounds. If `value` is
         within specified bounds, return True, else return a list of strings
         which are the error message(s).
     """
     kwargs = {}
     if inclusive in ['lower', 'both', True]:
         kwargs['gte'] = a
@@ -256,14 +256,28 @@
     return compare(var, **kwargs)
 
 
 @register()
 def one_valid(items):
     """
     Checks that one of the keys passes .validate()
+
+    Parameters
+    ----------
+    items: list of Var
+        Var objects to validate on
+
+    Returns
+    -------
+    True | str
+        Returns True if one item is valid, otherwise returns an error string
+
+    Notes
+    -----
+    This is a Sect check function, not be used for Vars
     """
     ov = False # One Valid
     for item in items:
         # Update the Var to ensure checks are properly done
         item._skip_checks = False
         item.strict = True
 
@@ -280,25 +294,72 @@
     return f'At least one key must be valid and none are: {[k.name for k in items]}'
 
 
 @register()
 def mutually_exclusive(items):
     """
     Checks that only one key is defined
+
+    Parameters
+    ----------
+    items: list of Var
+        Var objects to validate on
+
+    Returns
+    -------
+    True | str
+        Returns True if one item is valid, otherwise returns an error string
+
+    Notes
+    -----
+    This is a Sect check function, not be used for Vars
     """
     defined = []
     for item in items:
         if item._f.value is not Null:
             defined.append(item._f.name)
 
     if len(defined) > 1:
         return f'The following keys are mutually exclusive, please only set one: {defined}'
     return True
 
 
+@register
+def if_one_then_all(items):
+    """
+    If one item is defined then all must be defined
+
+    Parameters
+    ----------
+    items: list of Var
+        Var objects to validate on
+
+    Returns
+    -------
+    True | str
+        Returns True if one item is valid, otherwise returns an error string
+
+    Notes
+    -----
+    This is a Sect check function, not be used for Vars
+    """
+    defined   = []
+    undefined = []
+    for item in items:
+        name = item._f.name
+        if item._f.value is not Null:
+            defined.append(name)
+        else:
+            undefined.append(name)
+
+    if defined and undefined:
+        return f'If one is defined, all must be defined: defined={defined}, undefined={undefined}'
+    return True
+
+
 # dtypes assigned to these values always pass checks
 Typeless = (Null, 'Null', None, 'None', 'any')
 
 @register()
 def check_dtype(value, dtype):
     """
     Checks the type of a given value.
@@ -311,24 +372,24 @@
         The type this value is supposed to be. If type in [Null, 'Null', None,
         'None', 'any'] then the check is disabled and will return True.
         Otherwise, uses the Types dictionary to lookup the function to validate
         with.
 
     Returns
     -------
-    True or str or list of str
+    True | str | list of str
         Returns True if this value is the expected type. If it is not, returns
         either a string or list of strings describing the error.
     """
     if dtype in Typeless:
         return True
 
     if isinstance(dtype, list):
-        if True not in [check_type(value, t) for t in dtype]:
-            return f'Value type <{dtype!r}> is not one of {dtype}'
+        if True not in [check_dtype(value, t) for t in dtype]:
+            return f'Value {value!r} (type: {type(value)}) is not one of types {dtype}'
         return True
 
     # Use a custom function to check the type
     if isinstance(dtype, FunctionType):
         check = dtype(value)
 
     # If not a function, this must be a python-registered type
```

## mlky/configs/config.py

```diff
@@ -18,20 +18,19 @@
 )
 
 
 Logger = logging.getLogger(__file__)
 
 
 class Config(Sect):
-    def __init__(self, data={}, patch=[], defs={}, debug=-1, validate=True, _raise=True, **kwargs):
+    def __init__(self, data={}, patch=[], defs={}, debug=-1, validate=True, **kwargs):
         """
         """
         # Config-specific private variables
         self.__dict__['_patch'] = patch = self.parsePatch(patch)
-        self.__dict__['_raise'] = _raise
 
         # If patching, don't apply defs with creation
         if patch:
             # Patching the post initialized state is easiest
             super().__init__(data=data, debug=debug, **kwargs)
             self.patchSects(patch, inplace=True)
```

## mlky/configs/magics.py

```diff
@@ -5,36 +5,50 @@
 import re
 
 from . import (
     Config,
     funcs,
     magic_regex,
     Null,
-    register
+    register,
+    Var
 )
 
 
 Logger = logging.getLogger(__file__)
 
 
+def _debug(lvl, name, msg):
+    """
+    """
+    if lvl == 'e':
+        Logger.error(msg)
+    else:
+        Logger.warning(msg)
+
+
 @register(name='config.replace')
-def replace(value, instance=None, dtype=None):
+def replace(value, instance=None, dtype=None, callResets=False, _debug=_debug):
     """
     Replaces format signals in strings with values from the config relative to
     its inheritance structure.
 
     Parameters
     ----------
     value: str
         Matches roughly to ${config.*} in the string and replaces them with the
         corrosponding config value. See notes the regex for accuracy.
     instance: Sect, defaults=None
         Instance to use for value lookups. Defaults to the global instance
     dtype: any, defaults=None
         Data type to attempt casting the replacement value to
+    callResets: bool, defaults=False
+        Calls reset on retrieved Vars. Warning: This may cause a recursive loop. Experimental.
+    _debug: function
+        Sect or Var ._debug() function for debug logging
 
     Returns
     -------
     value: any
         Replaced value
 
     Notes
@@ -84,52 +98,60 @@
 
         for match in matches:
             # Config lookup case
             if match.startswith('.'):
                 keys = match.split('.')
 
                 if len(keys) < 2:
-                    Logger.error(f'Keys path provided is invalid, returning without replacement: {keys!r}')
+                    _debug('e', 'replace', f'Keys path provided is invalid, returning without replacement: {keys!r}')
                     return value
 
                 data = instance or Config
                 for key in keys[1:]:
-                    data = data.__getattr__(key)
+                    data = data.get(key, other=Null, var=True)
+
+                if isinstance(data, Var):
+                    if callResets:
+                        _debug(0, 'replace', f'Calling reset from magics.replace on {data.name}')
+                        data.reset()
+
+                    data = data.getValue()
 
                 if isinstance(data, Null):
-                    Logger.warning(f'Lookup({match}) returned Null. This may not be expected and may cause issues.')
+                    _debug(0, 'replace', f'Lookup({match}) returned Null. This may not be expected and may cause issues.')
 
             # Environment variable lookup case
             elif match.startswith('$'):
                 data = funcs.getRegister('get_env')(match[1:])
 
             # Lookup custom function case
             elif match.startswith('?'):
                 data = funcs.getRegister(match[1:])()
 
             # Data lookup case
             elif match.startswith('!'):
                 return funcs.getRegister(match[1:])()
 
             else:
-                Logger.warning(f'Replacement matched to string but no valid starter token provided: {match!r}')
+                _debug(0, 'replace', f'Replacement matched to string but no valid starter token provided: {match!r}')
 
-            value = value.replace('${'+ match +'}', str(data))
+            if data is not Null:
+                value = value.replace('${'+ match +'}', str(data))
 
     if dtype:
         if isinstance(dtype, list):
-            Logger.debug(f'Cannot cast replacement value {value!r} as the dtype is a list and cannot be assumed: {dtype=}')
+            _debug(0, 'replace', f'Cannot cast replacement value {value!r} as the dtype is a list and cannot be assumed: {dtype=}')
         elif dtype in (list, tuple):
             # Logger.debug(f'List dtype casting is not supported')
             pass
         else:
             try:
                 value = dtype(value)
             except:
-                Logger.error(f'Failed to cast replacement value {value!r} to {dtype=}')
+                _debug('e', 'replace', f'Failed to cast replacement value {value!r} to {dtype=}')
 
     return value
 
 
 @register(name='config.addChecks')
 def addChecks():
     """
```

## mlky/configs/null.py

```diff
@@ -1,16 +1,43 @@
 """
 The Null class of mlky.
 """
 import logging
 
+from datetime import datetime as dtt
+
 
 Logger = logging.getLogger(__file__)
 
 
+def NullErrors(msg, warn):
+    """
+    Attempt to track how many errors are occurring on Null objects. If the errors
+    amount to more than 1k within seconds, raise an exception to prevent an endless
+    loop.
+    """
+    now = dtt.now()
+
+    if (now - NullErrors.now).seconds < 1:
+        NullErrors.err += 1
+    else:
+        NullErrors.err = 0
+
+        if warn:
+            Logger.warning(msg)
+
+    NullErrors.now = now
+
+    if NullErrors.err >= 1000:
+        raise RuntimeError("Endless loop of errors detected (more than 1k errors per second), killing fault tolerance")
+
+NullErrors.now = dtt.now()
+NullErrors.err = 0
+
+
 class NullType(type):
     """
     Acts like a Nonetype (generally) without raising an exception in common use
     cases such as:
     - __getattr__, __getitem__ will return itself, preventing raising missing
     attribute. Ex: config.this_key_is_missing.also_missing will return Null.
     - Dict functions .get, .keys, and .items will return empty lists/dicts.
@@ -19,16 +46,16 @@
 
     Warnings can be disabled via:
     >>> Null._warn = False
     """
     _warn = True
 
     def __call__(cls, *args, **kwargs):
-        if cls._warn:
-            Logger.warning(f'Null received a call like a function, was this intended?')
+        NullErrors('Null received a call like a function, was this intended?', cls._warn)
+
         return cls
 
     def __deepcopy__(self, memo):
         return type(self)()
 
     def __hash__(cls):
         return hash(None)
@@ -41,19 +68,23 @@
 
     def __contains__(cls):
         return False
 
     def __eq__(cls, other):
         return type(other) in [type(None), type(cls)]
 
+    def __iter__(cls):
+        return iter({})
+
     def __setattr__(cls, key, value):
-        if key == '_warn':
+        if key in ('_warn', '_raise'):
             super().__setattr__(key, value)
-        elif cls._warn:
-            Logger.warning(f'Null objects cannot take attribute assignments but will not raise an exception')
+            return
+
+        NullErrors('Null objects cannot take attribute assignments but will not raise an exception', cls._warn)
 
     def __getattr__(cls, key):
         return cls
 
     def __setitem__(cls, key, value):
         setattr(cls, key, value)
 
@@ -62,15 +93,15 @@
 
     def __str__(cls):
         return 'Null'
 
     def __repr__(cls):
         return 'Null'
 
-    def get(self, key, other=None):
+    def get(self, key, other=None, **kwargs):
         return other
 
     def keys(self):
         return []
 
     def items(self):
         return ()
```

## mlky/configs/sect.py

```diff
@@ -142,15 +142,15 @@
             self.applyDefinition(defs)
 
     def __call__(self, other, inplace=True):
         """
         Enables patching via call, Sect(other)
         """
         if isinstance(other, (type(self), dict)):
-            return self._patch(other, inplace=inplace)
+            return self.applyPatch(other, inplace=inplace)
         raise TypeError(f'mlky.Sect can only be patched using other dicts or Sects')
 
     def __eq__(self, other):
         if self._dbug:
             self._log(1, '__eq__', f'Comparing to type: {type(other)} = {other!r}')
 
         # Convert this to its primitive type for safer comparisons
@@ -168,28 +168,28 @@
 
         Notes
         -----
         To enable subclass patching behaviour with both itself and this class,
         check if isinstance of itself and Sect
         """
         if isinstance(other, (type(self), Sect, dict)):
-            return self._patch(other, inplace=False)
+            return self.applyPatch(other, inplace=False)
         raise TypeError(f'mlky.Sect can only use operator | (or) with other dicts or Sects')
 
     def __lt__(self, other):
         """
         Enables patching using the < operator
 
         Notes
         -----
         To enable subclass patching behaviour with both itself and this class,
         check if isinstance of itself and Sect
         """
         if isinstance(other, (type(self), Sect, dict)):
-            return self._patch(other, inplace=False)
+            return self.applyPatch(other, inplace=False)
         raise TypeError(f'mlky.Sect can only use operator < (lt) with other dicts or Sects')
 
     def __setattr__(self, key, value):
         self._setdata(key, value)
 
     def __setitem__(self, key, value):
         self._setdata(key, value)
@@ -337,45 +337,50 @@
         """
         message = f'{self._offset}<{type(self).__name__}>({self._name}).{func}() {msg}'
         if level == 'e':
             Logger.error(message)
         elif level in self._dbug or func in self._dbug:
             Logger.debug(message)
 
-    def _patch(self, other, inplace=True):
+    def applyPatch(self, other, inplace=True):
         """
         Patches this Sect using another Sect or dict
         """
         if not inplace:
             self = self.deepCopy()
-            self._log(1, '_patch', 'Patching on deep copy')
+            self._log(0, 'applyPatch', 'Patching on deep copy')
 
         # Auto cast to Sect so merges are easier
         for key, item in Sect(other).items(var=True):
             name = self._subkey(key)
             data = self.get(key, var=True)
 
             if isinstance(item, Sect):
                 # Patch two Sects together
                 if isinstance(data, Sect):
-                    self._log(1, '_patch', f'Patching sub Sect [{key!r}] = {data} | {item}')
+                    self._log(0, 'applyPatch', f'Patching sub Sect [{key!r}] = {data} | {item}')
                     self[key] = data | item
                 # Replace with the other Sect
                 else:
-                    self._log(1, '_patch', f'Adding sub Sect [{key!r}] = {item}')
+                    self._log(0, 'applyPatch', f'Adding sub Sect [{key!r}] = {item}')
                     self[key] = item
             else:
                 # Log whether this is replacing or adding a Var, or if something borked
                 if isinstance(item, Var):
                     if isinstance(data, Var):
-                        self._log(1, '_patch', f'Replacing Var [{key!r}] = {item!r}')
+                        # Defs already defined and the patch doesn't, keep the already existing Var
+                        if not item.defs and data.defs:
+                            item = item.getValue()
+                            self._log(0, 'applyPatch', f'Updating Var [{key!r}] = {item!r}')
+                        else:
+                            self._log(0, 'applyPatch', f'Replacing Var [{key!r}] = {item!r}')
                     else:
-                        self._log(1, '_patch', f'Adding Var [{key!r}] = {item!r}')
+                        self._log(0, 'applyPatch', f'Adding Var [{key!r}] = {item!r}')
                 else:
-                    self._log('e', '_patch', f'A value other than a Sect or Var was found and should not have been: {type(item)} = {item!r}')
+                    self._log('e', 'applyPatch', f'A value other than a Sect or Var was found and should not have been: {type(item)} = {item!r}')
 
                 self[key] = item
 
         # Update the name to reflect potential changes in the hierarchy
         # self.updateNames()
 
         return self
@@ -405,14 +410,23 @@
         # Generate the proper name for this key
         name = self._subkey(key)
 
         # Retrieve this key from self if it exists
         self._log(2, '_setdata', f'Retrieving if this key [{key!r}] already exists')
         data = self._sect[key]
 
+        # Retrieve the defs for this key if this parent has it and wasn't provided
+        if not defs:
+            if 'items' in self._defs:
+                defs = self._defs['items']
+            else:
+                defs = self._defs.get(f'.{key}')
+
+            self._log(2, '_setdata', f'Retrieving defs for key [{key!r}]: {defs}')
+
         # Var is the last resort type
         setVar = False
 
         # Reduce duplicate code as this is repeated a few times
         args = dict(
             name   = name,
             data   = value,
@@ -434,14 +448,20 @@
             value._update(key, self)
 
         # These types are Sects, everything else will be Vars
         elif isinstance(value, dict):
             self._log(2, '_setdata', f'Setting new Sect [{key!r}] = Sect({value}, defs={defs})')
             self._sect[key] = Sect(**args, **kwargs)
 
+        # Check if this is a Var and has multiple types
+        elif isinstance(data, Var) and (sub := data.getSubType(value)):
+            self._log(2, '_setdata', f"Updating existing Var [{key!r}] to subtype {sub['dtype']}")
+            data.applyDefinition(sub)
+            data.value = value
+
         # List types may be Sects, depends on options set
         elif isinstance(value, (list, tuple)):
             # if convertListTypes then we set a Sect, all other option combinations create a Var
             setVar = True
 
             # Default behaviour, cast to a Sect
             if self._opts.convertListTypes:
@@ -479,38 +499,71 @@
             )
 
         # Update definitions at the end regardless of input type
         if defs:
             self._log(2, '_setdata', f'[{key!r}] Applying defs: {defs}')
             self._sect[key].applyDefinition(defs)
 
+        # Return the object for further operations
+        return self._sect[key]
+
     def _setdefs(self, key, defs):
         """
         Sets keys from a definitions dictionary
         """
+        kwargs = {}
+
         value = Null
         dtype = defs.get('dtype')
 
-        if dtype == 'list':
+        # Check if this key has multiple subtypes to it
+        if (subtypes := defs.get('subtypes')):
+            # Which subtype to be the default value
+            default = defs.get('defaultType', 0)
+
+            # Skip these keys
+            keys = set(defs) - {'subtypes',}
+
+            # Update subtypes with keys from the parent defs if the key is not defined by the subtype
+            for i, sub in enumerate(subtypes):
+                for k in keys:
+                    if k not in sub:
+                        sub[k] = defs[k]
+
+            # Retrieve the default defs for this key
+            defs = subtypes[default]
+
+            kwargs['subtypes'] = subtypes
+
+        elif dtype == 'list':
             self.__dict__['_type'] = 'List'
             copies  = range(defs.get('repeat', 0))
             subdefs = defs.get('items', defs)
             subval  = Null
-            if any(key.startswith('.') for key in subdefs):
-                subval = {}
-            value = [subval for _ in copies]
+            if 'subtypes' in subdefs:
+                value = [
+                    {item.get('key'): item.get('value')}
+                    for item in subdefs.get('subtypes', [])
+                ]
+            else:
+                if any(key.startswith('.') for key in subdefs):
+                    subval = {}
+
+                value = [subval for _ in copies]
 
         elif dtype == 'dict':
             copies = defs.get('repeat', [])
             value  = {key: {} for key in copies}
+
+        # Any child starting with . implies this is a dict type
         elif any(key.startswith('.') for key in defs):
             value = {}
 
         self._log(1, '_setdefs', f'[{key!r}] = {value!r}, defs={defs}')
-        self._setdata(key, value, defs=defs, missing=True)
+        self._setdata(key, value, defs=defs, missing=True, **kwargs)
 
     def _update(self, key, parent=Null):
         """
         Updates parameters of self relative to parent, then updates its children
 
         Parameters
         ----------
@@ -547,19 +600,35 @@
                 key = key[1:]
                 if key not in self:
                     self._log(0, 'applyDefinition', f'Adding missing key {key!r}')
                     self._setdefs(key, val)
                 else:
                     self._log(0, 'applyDefinition', f'Applying defs to key {key!r}')
                     self.get(key, var=True).applyDefinition(val)
+
+            # List type
             elif key == 'items':
                 for name, child in self.items(var=True):
                     self._log(0, 'applyDefinition', f'Applying defs to child {key!r}')
                     child.applyDefinition(val)
 
+            # Sublist type
+            elif key == 'subtypes':
+                for item in val:
+                    key   = item.get('key')
+                    value = item.get('value')
+
+                    if key is None:
+                        raise AttributeError(f'A `key` field needs to be set for item subtypes in the defs: {defs}')
+                    if value is None:
+                        raise AttributeError(f'A `value` field needs to be set for item subtypes in the defs: {defs}')
+
+                    if self[key] == value:
+                        self.applyDefinition(item)
+
     def deepUpdate(self):
         """
         Calls _update() on each Var/Sect in self. This will bring parent/child
         relationships in line with the current data, such as names and keys
         """
         for key, item in self.items(var=True):
             if not isinstance(item, (type(self), Sect, Var)):
@@ -732,29 +801,38 @@
             if isinstance(item, Sect):
                 item.resetVars()
             elif isinstance(item, Var):
                 item.reset()
             else:
                 self._log('e', 'resetVars', f'Internal _sect has a value other than a Var or Sect: {key!r} = {item!r}')
 
-    def dumpYaml(self, key=Null, string=True, truncate=None):
+    def dumpYaml(self, key=Null, string=True, truncate=None, nulls=True, comments='inline', space=False):
         """
         Dumps this object as a YAML string.
 
         Leverages the yaml.dump function to ensure 'key: value' are yaml compatible
 
         Parameters
         ----------
         string: bool, default=True
             Converts the dump to a compatible YAML string. If false, returns
             the dump list which is a list of tuples where each tuple defines the
             column values for a given row
         truncate: int, default=None
             `truncate` argument of mlky.utils.printTable; only relevant if
             `string=True`
+        nulls: bool, default=True
+            Include Vars that return Null. Set False to exclude these
+        comments: str, default='inline'
+            Comment styling:
+                - inline = key: value # comment
+                - above  = Comment line above the key: value (Not Implemented)
+                - None   = Comments removed
+        space: bool, default=False
+            Adds a blank line space between lines
 
         Notes
         -----
         `string=False` will return the `dump` list. The `dump` list is a list
         of tuples, ie.
         ```
         dump = [
@@ -782,34 +860,69 @@
                 if parent._defs.get('required'):
                     flag = '?'
                     break
                 parent = parent._prnt
 
         if key is None:
             key = self._f.name
+
         if key is Null:
-            line = [['generated:', 'K', 'dtype', 'Short description']]
+            # Root level section
+            line, flag, dtype, sdesc = 'generated:', 'K', 'dtype', 'Short description'
         else:
             if key == '':
                 line = ''
             else:
                 line = f'{key}:'
-            line = [[line, flag, dtype, sdesc]]
+
+                # If this Sect doesn't have children just set the value to {}
+                if not any(self):
+                    line = f'{key}:' + ' {}'
+
+        line = [[line, flag, dtype, sdesc]]
 
         # Dump all child objects to yaml
         lines = []
         for name, child in self.items(var=True):
-            lines += child.dumpYaml(name, string=False)
+            lines += child.dumpYaml(name, string=False, nulls=nulls)
 
         # Apply offset
         if lines:
             for i, child in enumerate(lines):
                 lines[i][0] = '  ' + child[0]
 
         dump = line + lines
+
+
+        if comments == 'above':
+            # # flag | dtype | sdesc
+            # key: value
+
+            hold = []
+            for line in dump:
+                offset = ' ' * (len(line[0]) - len(line[0].lstrip()))
+
+                if space:
+                    offset = f'\n{offset}'
+
+                hold.append([offset + '# ' + ' | '.join(line[1:])])
+                hold.append([line[0]])
+
+            dump = hold
+
+        else:
+            if comments == 'inline':
+                pass # Dump list is already formatted properly to this style
+            elif comments is None:
+                dump = [[line[0]] for line in dump]
+
+            if space:
+                for line in dump:
+                    line[0] = '\n' + line[0]
+
         if string:
             return '\n'.join(
                 printTable(dump, columns = {
                         0: {'delimiter': '#'},
                         1: {'delimiter': '|'},
                     },
                     print    = None,
```

## mlky/configs/var.py

```diff
@@ -23,41 +23,59 @@
     'float'  : float,
     'int'    : int,
     'list'   : list,
     'set'    : set,
     'str'    : str,
     'tuple'  : tuple
 }
+TypeNames = {v: k for k, v in Types.items()}
+
+
+def getType(dtype):
+    """
+    Helper function to convert strings to actual types
+    """
+    # Get actual type, else fallback to a registered function, else the parameter itself
+    if isinstance(dtype, list):
+        return [Types.get(val, funcs.Funcs.get(val, val)) for val in dtype]
+    return Types.get(dtype, funcs.Funcs.get(dtype, dtype))
+
 
 class Var:
     value    = Null
+    defs     = Null
     debug    = set()
     missing  = True
     required = False
     strict   = False
 
     # Special flag to indicate when to skip checks
     _skip_checks = False
 
     # .reset() will replace magic strings "${...}", this will disable that
     _disable_reset_magics = False
 
     # Will only call replace on magic strings, not any value
     _replace_only_if_magic = True
 
+    # Recursively call replace so values get populated correctly no matter order of operation
+    _replace_recursively = True
+
     # Replace backslashes "\" with Null
     _replace_slash_null = True
 
     # Assists getValue() to retrieve a temporary value without setting it as .value
     _tmp_value = Null
 
     def __init__(self, name, key,
         value    = Null,
         default  = Null,
+        example  = Null,
         dtype    = Null,
+        subtypes = Null,
         required = False,
         missing  = False,
         checks   = [],
         strict   = False,
         debug    = -1,
         sdesc    = '',
         ldesc    = '',
@@ -77,15 +95,17 @@
         """
         if isinstance(debug, int):
             debug = range(0, debug+1)
 
         self.name     = name
         self.key      = key
         self.default  = default
+        self.example  = example
         self.dtype    = dtype
+        self.subtypes = subtypes
         self.required = required
         self.missing  = missing
         self.checks   = checks
         self.strict   = strict
         self.debug    = set(debug)
         self.sdesc    = sdesc
         self.ldesc    = ldesc
@@ -93,15 +113,16 @@
         self.original = value
 
         if replace and not missing:
             # This will call replace() then validate()
             self.value = value
         else:
             # No replace(), takes as-is
-            super().__setattr__('value', value)
+            # super().__setattr__('value', value)
+            self.setValue(value, replace=False, validate=False)
 
     def __eq__(self, other):
         data = self.toDict()
         if isinstance(other, dict):
             return data == other
         elif isinstance(other, self.__class__):
             return data == other.toDict()
@@ -138,46 +159,59 @@
                     self._debug(2, 'deepReplace', f'Replacing index [{i}] {item!r} with {new!r}')
                     value[i] = new
 
             elif isinstance(item, (list, tuple)):
                 self._debug(2, 'deepReplace', f'Calling deepReplace on child list {item}')
                 self.deepReplace(item)
 
-    def __setattr__(self, key, value):
+    def __setattr__(self, key, value, replace=True, validate=True):
         """
         """
         if key == 'value':
             # Reset this if it was set elsewhere when the Var.value is changed
             self._skip_checks = False
 
-            # Lists to Sects disabled, perform a deep replacement
-            if isinstance(value, (list, tuple)):
-                self.original = copy.deepcopy(value)
-                self.deepReplace(value)
-            else:
-                # Always call to see if this value should be replaced
-                new = self.replace(value)
-                if new is not None:
-                    self.original = value
-                    value = new
+            # Call replace if enabled
+            if replace:
+                # Lists to Sects disabled, perform a deep replacement
+                if isinstance(value, (list, tuple)):
+                    self.original = copy.deepcopy(value)
+                    self.deepReplace(value)
+                else:
+                    # Always call to see if this value should be replaced
+                    new = self.replace(value)
+                    if new is not None:
+                        self.original = value
+                        value = new
 
             # Replacement may cause a value to become Null, this is always considered "missing"
             if value is Null:
                 self.missing = True
             else:
                 self.missing = False
 
-            # Non-empty dict means errors found
-            errs = self.validate(value).reduce()
-            if errs:
-                Logger.error(f'Changing the value of this Var({self.name}) to will cause validation to fail. See var.validate() for errors')
+            # Call validation checks if enabled
+            if validate:
+                # Non-empty dict means errors found
+                errs = self.validate(value).reduce()
+                if errs:
+                    Logger.error(f'Changing the value of this Var({self.name}) to will cause validation to fail. See var.validate() for errors')
 
         elif key == 'dtype':
-            # Replace string dtypes with actual types, else fallback to a registered function, else just whatever was given
-            value = Types.get(value, funcs.Funcs.get(value, value))
+            value = getType(value)
+
+        # Cast subtype dtypes to real types
+        elif key == 'subtypes':
+            for sub in value:
+                if 'dtype' not in sub:
+                    msg = f'Defs keys with multiple types must define the dtype for each explicitly. Missing for {key}[{i}]'
+                    self._log('e', '__setattr__', msg)
+                    raise AttributeError(msg)
+
+                sub['dtype'] = getType(sub['dtype'])
 
         super().__setattr__(key, value)
 
     def __repr__(self):
         return f'<Var({self.key}={self.value!r})>'
 
     @property
@@ -221,16 +255,19 @@
 
         return '  ' * (name - key)
 
     def _debug(self, level, func, msg):
         """
         Formats debug messages
         """
-        if level in self.debug or func in self.debug:
-            Logger.debug(f'{self._offset}<{type(self).__name__}>({self.name}).{func}() {msg}')
+        message = f'{self._offset}<{type(self).__name__}>({self.name}).{func}() {msg}'
+        if level == 'e':
+            Logger.error(message)
+        elif level in self.debug or func in self.debug:
+            Logger.debug(message)
 
     def _update(self, key, parent):
         """
         Updates values of this Var given a new parent Sect
         """
         self.debug = parent._dbug
 
@@ -248,43 +285,47 @@
 
     def toDict(self):
         return self.__dict__
 
     def deepCopy(self, memo=None):
         return copy.deepcopy(self, memo)
 
-    def checkType(self, value=Null):
+    def checkType(self, value=Null, strict=False):
         """
         Checks a given value against the type set for this object.
 
         Parameters
         ----------
         value: any, default=Null
             Value to test against. If left as default Null, will use the Var.value
+        strict: bool, defaults=False
+            Sets strict for this call only
         """
         if value is Null:
             value = self.getValue()
 
         if all([
-            not self.strict,        # Strict cases always check dtype
-            not self.required, # Not required to be set
-            value is Null      # Already a null value, possibly inherently null
+            not (self.strict or strict), # Strict cases always check dtype
+            not self.required,           # Not required to be set
+            value is Null                # Already a null value, possibly inherently null
         ]):
             return True
 
         return funcs.getRegister('check_dtype')(value, self.dtype)
 
-    def validate(self, value=Null, **kwargs):
+    def validate(self, value=Null, strict=False, **kwargs):
         """
         Validates a value against this variable's checks
 
         Parameters
         ----------
         value: any, defaults=Null
             Value to validate. If left as default Null, will use the Var.value
+        strict: bool, defaults=False
+            Sets strict for this call only
 
         Returns
         -------
         errors: mlky.ErrorsDict or True
             If all checks pass, returns True, otherwise returns an Errors
             object. Essentially the same as a dict. Each key is the check name
             and the value is either True for passing, a string for a single
@@ -304,22 +345,22 @@
 
         # Special cases may not want to execute the checks
         if self._skip_checks:
             self._debug(0, 'validate', '_skip_checks enabled, returning no errors')
             return errors
 
         # Don't run any checks if the key was missing
-        if self.missing and not self.strict:
+        if self.missing and not (self.strict or strict):
             if self.required:
                 errors['required'] = 'This key is required to be manually set in the config'
             self._debug(0, 'validate', f'This Var is missing and not strict')
             return errors
 
         # Check the type before anything else
-        errors['type'] = self.checkType(value)
+        errors['type'] = self.checkType(value, strict)
 
         for check in self.checks:
             args   = []
             kwargs = {}
             if isinstance(check, dict):
                 (check, args), = list(check.items())
                 if isinstance(args, dict):
@@ -329,15 +370,15 @@
             self._debug(0, 'validate', f'Running check {check}(args={args}, kwargs={kwargs})')
             errors[check] = funcs.getRegister(check)(self, *args, **kwargs)
 
         # Validate child objects if this is a list
         if isinstance(value, list):
             for item in value:
                 if hasattr(item, 'validate'):
-                    errors[item._f.name] = item.validate()
+                    errors[item._f.name] = item.validate(asbool=False, report=False)
 
         # Reset at the end
         self._tmp_value = Null
 
         # self._debug(0, 'validate', f'Errors reduced: {errors.reduce()}') # Very spammy, unsure about usefulness
         return errors
 
@@ -345,41 +386,58 @@
         """
         Resets this Var's value to its original. This is primarily useful to
         reset all Vars to trigger replacements after a Config finishes
         initialization
         """
         value = self.getValue()
 
-        if value is not self.original:
+        if isinstance(value, list):
+            for item in value:
+                # Sect type
+                if hasattr(item, 'resetVars'):
+                    item.resetVars()
+                elif isinstance(item, Var):
+                    item.reset()
+
+        elif value is not self.original:
             self._debug(0, 'reset', f'Resetting from {value} to {self.original}')
             self.value = self.original
+
         elif isinstance(value, str) and value.startswith('$'):
             if not self._disable_reset_magics:
                 self._debug(0, 'reset', f'Current value is a magic, resetting to call replacement')
                 self.value = value
 
     def applyDefinition(self, defs):
         """
         Applies values from a definitions object
         """
         value = self.getValue()
         for key, val in defs.items():
+            # This is a list type
             if key == 'items':
+                # For each item in the list
                 for subval in value:
+                    # If it is a Sect or Var, apply def
                     if subval is not Null and hasattr(subval, 'applyDefinition'):
                         name = subval._f.name
                         self._debug(0, 'applyDefinition', f'Applying definitions to child objects: {name}')
                         subval.applyDefinition(val.get(name, val))
+
+                # List may have changed, set as the original
+                self.original = self.getValue()
             else:
                 self._debug(0, 'applyDefinition', f'{key} = {val!r}')
                 setattr(self, key, val)
 
                 if key == 'default' and self.original is Null:
                     self._debug(0, 'applyDefinition', f'Original is Null and default provided, setting original to default')
                     setattr(self, 'original', val)
+        else:
+            setattr(self, 'defs', defs)
 
     def replace(self, value):
         """
         mlky replacement magic to support independent Sect instances
 
         Work in progress
         """
@@ -401,76 +459,142 @@
         parent = self.parent
         while parent._prnt:
             parent = parent._prnt
 
         # TODO: This is broken, just default to the global instance until further research
         parent = None
 
-        replacement = funcs.getRegister('config.replace')(value, parent, dtype=self.dtype)
+        replacement = funcs.getRegister('config.replace')(value, parent, dtype=self.dtype, callResets=self._replace_recursively, _debug=self._debug)
         if replacement is not value:
             self._debug(0, 'replace', f'Replacing {value!r} with {replacement!r}')
             return replacement
 
-    def getValue(self, default=True):
+    def setValue(self, value, validate=True, replace=True):
+        """
+        Sets the value for the Var. Enables circumventing validate and replace that
+        typically happens in __setattr__.
+        """
+        self.__setattr__('value', value, validate=validate, replace=replace)
+
+    def getValue(self, default=True, example=False):
         """
         Returns this Var's value. If it is Null and default is enabled, returns the
         default value instead.
 
         Parameters
         ----------
         default: bool, default=True
             If .value is Null, return .default
             If this is false, always return .value
+        example: bool, default=False
+            Override and return the example value
         """
+        if example:
+            return self.example
+
         # If a user passes in a value to validate(), return that on any call to this function
         # This helps registered functions retrieve a temporary value instead
         if self._tmp_value is not Null:
             return self._tmp_value
 
         # Otherwise if default is enabled, return that
         if default and self.value is Null:
             return self.default
 
         return self.value
 
-    def dumpYaml(self, key=None, **kwargs):
+    def getSubType(self, value):
+        """
+        Retrieves the subtype definition if the input value matches to one
+
+        Parameters
+        ----------
+        value: any
+            Value to check
+
+        Returns
+        -------
+        False or dict
+            The defs dict for the subtype if it matches the value type, False otherwise
         """
+        for sub in self.subtypes:
+            if isinstance(value, sub['dtype']):
+                return sub
+        return False
+
+    def dumpYaml(self, key=None, example=False, nulls=True, **kwargs):
+        """
+        Serialize the object to YAML format.
+
+        Parameters
+        ----------
+        key: str or None, optional
+            The key to use in the YAML output. If None, the name of the object will be used as the key.
+        example: bool, default=False
+            Use example values instead of actual or default values
+        **kwargs: dict
+            Ignore other kwargs that may be passed by a Sect parent but are unused by Var objects
+
+        Returns
+        -------
+        list
+            A list containing the YAML representation of the object
         """
         if key is None:
             key = self.name
 
         # Cast dtype back to str name
         dtype = self.dtype
-        if isinstance(dtype, type):
-            if (match := re.match(r"<class '(\w+)'>", str(dtype))):
-                dtype = match.groups()[0]
+        if isinstance(dtype, list):
+            dtype = ', '.join([TypeNames.get(item, str(item)) for item in dtype])
+        else:
+            dtype = TypeNames.get(dtype, str(dtype))
 
         # Change the flag comment if set
         flag = ' '
         if self.required:
             flag = '!'
         else:
             parent = self.parent
             while parent is not Null:
                 if parent._defs.get('required'):
                     flag = '?'
                     break
                 parent = parent._prnt
 
-        value = self.getValue()
+        value = self.getValue(example=example)
+
+        # If this is a Null or a list of Nulls and nulls is turned off, return nothing
+        if not nulls:
+            if isinstance(value, list):
+                if all([v is Null for v in value]):
+                    return []
+            elif value is Null:
+                return []
+
         lines = []
-        if isinstance(value, list):
+        if example:
+            # TODO: Finish implementation
+            # Multiple examples
+            if isinstance(value, list):
+                for val in value:
+                    if isinstance(val, dict):
+                        ...
+            else:
+                line = yaml.dump({key: value})[:-1]
+
+        elif isinstance(value, list):
             line = f'{key}:'
             if value:
                 for val in value:
                     if val is Null:
                         # Replace Null values with backslash
                         lines.append(['- \\'])
                     elif hasattr(val, 'dumpYaml'):
-                        dump = val.dumpYaml('', string=False)
+                        dump = val.dumpYaml('', string=False, nulls=nulls)
                         dump[0][0] = '- ' + dump[0][0]
                         lines += dump
                     else:
                         lines.append(['- ' + yaml.dump(val).split('\n')[0]])
             else:
                 line = f'{key}: []'
         else:
```

## mlky/utils/formatters.py

```diff
@@ -42,39 +42,41 @@
     offset    = args.get('offset'   , offset   )
     truncate  = args.get('truncate' , truncate )
 
     # Left and right side of the delimiter for this column
     left  = []
     right = []
     for item in iterable:
+        left.append(str(item[0]))
+
         if len(item) > 1:
-            left.append(str(item[0]))
             right.append(str(item[1]))
+        else:
+            right.append(None)
 
     if not left:
         return []
     elif isinstance(truncate, int):
         left = [item[:truncate] for item in left]
 
     padding   = max([0, max(map(len, left))]) + offset
     formatter = prepend
     if enum:
         formatter += '{i:' + f'{len(str(len(iterable)))}' + '}: '
     formatter += '{left:'+ str(padding) + '}' + delimiter + ' {right}'
 
-    i = 0
     formatted = []
-    for item in iterable:
+    for i, item in enumerate(iterable):
         if len(item) > 1:
             string = formatter.format(i=i, left=left[i], right=right[i])
             if len(item) > 2:
                 formatted.append((string, *item[2:]))
             else:
                 formatted.append((string, ))
-            i += 1
+
         else:
             formatted.append(item)
 
     # Check if there are any more columns to format
     if any([len(item) > 1 for item in formatted]):
         # Only delimiter and offset are carried forward, other parameters disabled
         formatted = printTable(formatted,
```

## mlky/utils/track.py

```diff
@@ -38,40 +38,50 @@
     """
     def __init__(self, total, step=5, print=print, reverse=False, message="complete"):
         """
         Parameters
         ----------
         total: int, iterable
             Total items in iterable. If iterable, will call len() on it
-        step: float, default=0.05
-            Percentage step size to use for reporting, eg. 0.05 is every 5%
+        step: float, default=5
+            Step size to use for reporting
+        absolute: int, default=None
+            Changes the return
         print: func, default=print
             Print function to use, eg. logging.info
         reverse: bool, default=False
             Reverse the count such that 0 is 100%
         message: str, default="complete"
             Message to be included in the output
         """
-        if hasattr(total, '__iter__'):
+        if hasattr(total, '__len__'):
             total = len(total)
 
+        if step > 100:
+            raise AttributeError('Step size should be an integer representing a percentage, eg. 5 = report every 5%')
+
         self.step = step
         self.total = total
         self.print = print
         self.start = dtt.now()
         self.percent = step
         self.reverse = reverse
         self.message = message
 
     def __call__(self, count):
         """
         Parameters
         ----------
         count: int, iterable
             The current count of items finished. If iterable, will call len() on it
+
+        Returns
+        -------
+        bool
+            True if a percentage step was just crossed, False otherwise
         """
         if hasattr(count, '__iter__'):
             count = len(count)
 
         current = count / self.total
         if self.reverse:
             current = 1 - current
@@ -80,7 +90,10 @@
         if current >= self.percent:
             elap = dtt.now() - self.start
             rate = elap / self.total
             esti = 100 / self.percent * elap - elap
 
             self.print(f"{current:6.2f}% {self.message} (elapsed: {elap}, rate: {rate}, eta: {esti})")
             self.percent += self.step
+
+            return True
+        return False
```

## Comparing `mlky-2024.3.5.dist-info/LICENSE` & `mlky-2024.4.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `mlky-2024.3.5.dist-info/METADATA` & `mlky-2024.4.1.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: mlky
-Version: 2024.3.5
+Version: 2024.4.1
 Summary: Machine Learning key utilities
 Author: James Montgomery
 Author-email: J.Montgomery@jpl.nasa.gov
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
 Description-Content-Type: text/markdown
```

## Comparing `mlky-2024.3.5.dist-info/RECORD` & `mlky-2024.4.1.dist-info/RECORD`

 * *Files 9% similar despite different names*

```diff
@@ -1,29 +1,29 @@
-mlky/__init__.py,sha256=CP6JJLt3kB95I1ZFzsGiii-JCFobHer5k3rNKFgY7-4,128
+mlky/__init__.py,sha256=asekZG9153V9XkQTI6sRVRRPj7nvHk2yqfEKo1O5g90,128
 mlky/utils.py,sha256=ln0A9REnFBeVHKCXyfucJMZcuckYaCE3e5Sq4Fb74FU,7187
 mlky/configs/__init__.py,sha256=SBvRNJeRGZzXBYSQTQlrTFAOd5apU-caSw4GjbT67JI,857
-mlky/configs/builtins.py,sha256=uzCrobugKY61-OJwelMaCbl2IbFImk0X04en674O7M8,8436
+mlky/configs/builtins.py,sha256=peic8tHN1ldUW5oSbVPZuYa25kUY6izy4IwHYapm2pk,9766
 mlky/configs/cli.py,sha256=f4xmtCEpOyUXbWRrh352Bi6KQaxfVQk6oUEWlHSNjzY,5128
-mlky/configs/config.py,sha256=Xf251xl5brIBPxciLyhzBEJ4i7wFNu3qdbUIb_E0rco,5767
+mlky/configs/config.py,sha256=NHuEvPtUl4kRTk55MXn5DthV0GViD-mbasHbfK3DYDw,5713
 mlky/configs/definitions.py,sha256=5vCpi8mYBsqYKGNrMDZfR4REvZwEEqnuS0OAzZq8SqU,9447
 mlky/configs/funcs.py,sha256=mprVJCvqPxprP7Xk70I1dsLU9nJTHlbU_I-3O7c4gww,2650
 mlky/configs/functions.py,sha256=ioP13gVD6WpsTRQCFJ0ZrD9GzkMeUfbM9CGjHBxbDTA,4601
-mlky/configs/magics.py,sha256=NYOqa_pv_lk5Kn1nnGQ5i51ThgJQbIjr5S2YILFbIcY,4322
-mlky/configs/null.py,sha256=emMKh68ex7UIbUqUdKr8T-qLzI5Y3klCuz74XBmKsi0,2293
+mlky/configs/magics.py,sha256=H337KbEp_w5Jjm33EKBNV3Dp61OKAuGoJXNOuqtKVj4,5051
+mlky/configs/null.py,sha256=_Aw-bDOtpNXTfYWWvZ-A1g_-DfQtwpb47E-Rc7NmcDo,3005
 mlky/configs/registers.py,sha256=OxE4Tr-YlZCQ3A5rtbnJNhHr0lpPcNlNnHHWSKiLWjk,3802
-mlky/configs/sect.py,sha256=LGSIYeGC8nAxGdzjCmAFekQZBCQnjO6Ig_OHmL-6OKY,31807
+mlky/configs/sect.py,sha256=3l0Gf_KASNkmW4eJJhh46jr6UjrTRcuVLPkon7LTuZg,35950
 mlky/configs/section.py,sha256=CLRoennt9nfq_2WOSmPbtmkRLP_2D8Y8hrcsoCT8rEA,16228
 mlky/configs/ui.py,sha256=K7GS8DX3NrIwL56Vv33Hmz8kPiGLApEV3Ie4rdwmAwI,2849
-mlky/configs/var.py,sha256=IJ6cG6SEDGYKABTD4HCYDZjlYLcr09b1aaaUCUVUXGA,16225
+mlky/configs/var.py,sha256=SaW8f9kI-SjkV6vAmYNDhgveWmyVLlqNOYv_dONBhuw,20595
 mlky/utils/__init__.py,sha256=iB43jmOJRjWG0wvy7yW7o45hsc7a92CRazRxLBQJQ9g,128
-mlky/utils/formatters.py,sha256=a9thxl0wnmg1RHdPpRBOzTsrhUYNvPciACMa6CwmyI4,5059
+mlky/utils/formatters.py,sha256=kKBbf38fA8qOOfd8pThqvKIrMI9EiuXuwonxcxQ4L2E,5087
 mlky/utils/funcs.py,sha256=ohL6m01XGGA48h3VGIrb8rcNmSVFxXZvwiKem2mnmTQ,868
 mlky/utils/io.py,sha256=vt0oyr0fKVBJ5XHoJ7Zv3eInkxIWFnRGuYZjcB-fOWM,1597
 mlky/utils/prettyslice.py,sha256=M1HWR3CG2-e7_BXkx9UOHoOaauQnu9yYXzBTo70ASWs,605
 mlky/utils/templates.py,sha256=_ACsELhJZI5162FMsIUhMlC8s167ADONhZNArsRN6zQ,1044
-mlky/utils/track.py,sha256=915BVCDcjhophVmmq5GAHkKXcO2nRPKDGNTMOcaiG4w,3688
-mlky-2024.3.5.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
-mlky-2024.3.5.dist-info/METADATA,sha256=85KcBnAyhmdSB7S5oZprsyrHaNmTpnpj9MrrX4EXSwk,5248
-mlky-2024.3.5.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-mlky-2024.3.5.dist-info/entry_points.txt,sha256=rSk152YBxPoUekX323nBTxroXmAjm1gb9fY52SXqOGY,40
-mlky-2024.3.5.dist-info/top_level.txt,sha256=agfjA-hNDXMJAiG_t0qo2yBbTjJzoPezdBYvRMXNr58,5
-mlky-2024.3.5.dist-info/RECORD,,
+mlky/utils/track.py,sha256=mw3VUWNrSQVN4a7zCPmbGSbatZkslDeR7Za5_FKCaE8,4024
+mlky-2024.4.1.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
+mlky-2024.4.1.dist-info/METADATA,sha256=f58NbQtnJmj6aAC7avnSGrdzLwVbn3jrWfd82XnXRUM,5248
+mlky-2024.4.1.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+mlky-2024.4.1.dist-info/entry_points.txt,sha256=rSk152YBxPoUekX323nBTxroXmAjm1gb9fY52SXqOGY,40
+mlky-2024.4.1.dist-info/top_level.txt,sha256=agfjA-hNDXMJAiG_t0qo2yBbTjJzoPezdBYvRMXNr58,5
+mlky-2024.4.1.dist-info/RECORD,,
```

