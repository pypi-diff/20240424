# Comparing `tmp/kelvin_python_api_client-0.0.1-py3-none-any.whl.zip` & `tmp/kelvin_python_api_client-0.0.2-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,45 +1,46 @@
-Zip file size: 125258 bytes, number of entries: 43
--rw-r--r--  2.0 unx      366 b- defN 24-Apr-08 15:56 kelvin/api/client/__init__.py
--rw-r--r--  2.0 unx    29854 b- defN 24-Apr-08 15:56 kelvin/api/client/base_client.py
--rw-r--r--  2.0 unx     5120 b- defN 24-Apr-08 15:56 kelvin/api/client/base_model.py
--rw-r--r--  2.0 unx     5559 b- defN 24-Apr-08 15:56 kelvin/api/client/client.py
--rw-r--r--  2.0 unx    22575 b- defN 24-Apr-08 15:56 kelvin/api/client/config.py
--rw-r--r--  2.0 unx    17103 b- defN 24-Apr-08 15:56 kelvin/api/client/data_model.py
--rw-r--r--  2.0 unx     5130 b- defN 24-Apr-08 15:56 kelvin/api/client/dataframe_conversion.py
--rw-r--r--  2.0 unx     8635 b- defN 24-Apr-08 15:56 kelvin/api/client/deeplist.py
--rw-r--r--  2.0 unx     2132 b- defN 24-Apr-08 15:56 kelvin/api/client/error.py
--rw-r--r--  2.0 unx        0 b- defN 24-Apr-08 15:56 kelvin/api/client/py.typed
--rw-r--r--  2.0 unx     2677 b- defN 24-Apr-08 15:56 kelvin/api/client/retry.py
--rw-r--r--  2.0 unx     6591 b- defN 24-Apr-08 15:56 kelvin/api/client/serialize.py
--rw-r--r--  2.0 unx     7940 b- defN 24-Apr-08 15:56 kelvin/api/client/utils.py
--rw-r--r--  2.0 unx      411 b- defN 24-Apr-08 16:03 kelvin/api/client/version.py
--rw-r--r--  2.0 unx    23238 b- defN 24-Apr-08 15:56 kelvin/api/client/api/app_manager.py
--rw-r--r--  2.0 unx    11529 b- defN 24-Apr-08 15:56 kelvin/api/client/api/app_registry.py
--rw-r--r--  2.0 unx    34959 b- defN 24-Apr-08 15:56 kelvin/api/client/api/asset.py
--rw-r--r--  2.0 unx     2258 b- defN 24-Apr-08 15:56 kelvin/api/client/api/asset_insights.py
--rw-r--r--  2.0 unx    10510 b- defN 24-Apr-08 15:56 kelvin/api/client/api/bridge.py
--rw-r--r--  2.0 unx    15191 b- defN 24-Apr-08 15:56 kelvin/api/client/api/control_change.py
--rw-r--r--  2.0 unx    15558 b- defN 24-Apr-08 15:56 kelvin/api/client/api/data_tag.py
--rw-r--r--  2.0 unx    35358 b- defN 24-Apr-08 15:56 kelvin/api/client/api/datastreams.py
--rw-r--r--  2.0 unx     6846 b- defN 24-Apr-08 15:56 kelvin/api/client/api/filestorage.py
--rw-r--r--  2.0 unx    19581 b- defN 24-Apr-08 15:56 kelvin/api/client/api/instance.py
--rw-r--r--  2.0 unx    27445 b- defN 24-Apr-08 15:56 kelvin/api/client/api/orchestration.py
--rw-r--r--  2.0 unx    16054 b- defN 24-Apr-08 15:56 kelvin/api/client/api/parameters.py
--rw-r--r--  2.0 unx    28980 b- defN 24-Apr-08 15:56 kelvin/api/client/api/recommendation.py
--rw-r--r--  2.0 unx     5694 b- defN 24-Apr-08 15:56 kelvin/api/client/api/secret.py
--rw-r--r--  2.0 unx    11253 b- defN 24-Apr-08 15:56 kelvin/api/client/api/thread.py
--rw-r--r--  2.0 unx     9022 b- defN 24-Apr-08 15:56 kelvin/api/client/api/timeseries.py
--rw-r--r--  2.0 unx    13200 b- defN 24-Apr-08 15:56 kelvin/api/client/api/user.py
--rw-r--r--  2.0 unx    14840 b- defN 24-Apr-08 15:56 kelvin/api/client/api/workload.py
--rw-r--r--  2.0 unx      103 b- defN 24-Apr-08 15:56 kelvin/api/client/model/__init__.py
--rw-r--r--  2.0 unx     1671 b- defN 24-Apr-08 15:56 kelvin/api/client/model/enum.py
--rw-r--r--  2.0 unx     1812 b- defN 24-Apr-08 15:56 kelvin/api/client/model/pagination.py
--rw-r--r--  2.0 unx   110122 b- defN 24-Apr-08 15:56 kelvin/api/client/model/requests.py
--rw-r--r--  2.0 unx     2259 b- defN 24-Apr-08 15:56 kelvin/api/client/model/response.py
--rw-r--r--  2.0 unx   145363 b- defN 24-Apr-08 15:56 kelvin/api/client/model/responses.py
--rw-r--r--  2.0 unx    64135 b- defN 24-Apr-08 15:56 kelvin/api/client/model/type.py
--rw-r--r--  2.0 unx     2881 b- defN 24-Apr-08 16:03 kelvin_python_api_client-0.0.1.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Apr-08 16:03 kelvin_python_api_client-0.0.1.dist-info/WHEEL
--rw-r--r--  2.0 unx        7 b- defN 24-Apr-08 16:03 kelvin_python_api_client-0.0.1.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     3874 b- defN 24-Apr-08 16:03 kelvin_python_api_client-0.0.1.dist-info/RECORD
-43 files, 747928 bytes uncompressed, 119036 bytes compressed:  84.1%
+Zip file size: 127803 bytes, number of entries: 44
+-rw-r--r--  2.0 unx      366 b- defN 24-Apr-24 15:46 kelvin/api/client/__init__.py
+-rw-r--r--  2.0 unx    12746 b- defN 24-Apr-24 15:46 kelvin/api/client/api_service_model.py
+-rw-r--r--  2.0 unx    29864 b- defN 24-Apr-24 15:46 kelvin/api/client/base_client.py
+-rw-r--r--  2.0 unx     5195 b- defN 24-Apr-24 15:46 kelvin/api/client/base_model.py
+-rw-r--r--  2.0 unx     5584 b- defN 24-Apr-24 15:46 kelvin/api/client/client.py
+-rw-r--r--  2.0 unx    22575 b- defN 24-Apr-24 15:46 kelvin/api/client/config.py
+-rw-r--r--  2.0 unx     6532 b- defN 24-Apr-24 15:46 kelvin/api/client/data_model.py
+-rw-r--r--  2.0 unx     5130 b- defN 24-Apr-24 15:46 kelvin/api/client/dataframe_conversion.py
+-rw-r--r--  2.0 unx     8635 b- defN 24-Apr-24 15:46 kelvin/api/client/deeplist.py
+-rw-r--r--  2.0 unx     2132 b- defN 24-Apr-24 15:46 kelvin/api/client/error.py
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-24 15:46 kelvin/api/client/py.typed
+-rw-r--r--  2.0 unx     2677 b- defN 24-Apr-24 15:46 kelvin/api/client/retry.py
+-rw-r--r--  2.0 unx     6663 b- defN 24-Apr-24 15:46 kelvin/api/client/serialize.py
+-rw-r--r--  2.0 unx     7940 b- defN 24-Apr-24 15:46 kelvin/api/client/utils.py
+-rw-r--r--  2.0 unx      411 b- defN 24-Apr-24 15:53 kelvin/api/client/version.py
+-rw-r--r--  2.0 unx    23883 b- defN 24-Apr-24 15:46 kelvin/api/client/api/app_manager.py
+-rw-r--r--  2.0 unx    11747 b- defN 24-Apr-24 15:46 kelvin/api/client/api/app_registry.py
+-rw-r--r--  2.0 unx    35906 b- defN 24-Apr-24 15:46 kelvin/api/client/api/asset.py
+-rw-r--r--  2.0 unx     2469 b- defN 24-Apr-24 15:46 kelvin/api/client/api/asset_insights.py
+-rw-r--r--  2.0 unx    10723 b- defN 24-Apr-24 15:46 kelvin/api/client/api/bridge.py
+-rw-r--r--  2.0 unx    15840 b- defN 24-Apr-24 15:46 kelvin/api/client/api/control_change.py
+-rw-r--r--  2.0 unx    15920 b- defN 24-Apr-24 15:46 kelvin/api/client/api/data_tag.py
+-rw-r--r--  2.0 unx    36415 b- defN 24-Apr-24 15:46 kelvin/api/client/api/datastreams.py
+-rw-r--r--  2.0 unx     7009 b- defN 24-Apr-24 15:46 kelvin/api/client/api/filestorage.py
+-rw-r--r--  2.0 unx    20019 b- defN 24-Apr-24 15:46 kelvin/api/client/api/instance.py
+-rw-r--r--  2.0 unx    28191 b- defN 24-Apr-24 15:46 kelvin/api/client/api/orchestration.py
+-rw-r--r--  2.0 unx    22415 b- defN 24-Apr-24 15:46 kelvin/api/client/api/parameters.py
+-rw-r--r--  2.0 unx    29814 b- defN 24-Apr-24 15:46 kelvin/api/client/api/recommendation.py
+-rw-r--r--  2.0 unx     5907 b- defN 24-Apr-24 15:46 kelvin/api/client/api/secret.py
+-rw-r--r--  2.0 unx    11270 b- defN 24-Apr-24 15:46 kelvin/api/client/api/thread.py
+-rw-r--r--  2.0 unx     9237 b- defN 24-Apr-24 15:46 kelvin/api/client/api/timeseries.py
+-rw-r--r--  2.0 unx    13606 b- defN 24-Apr-24 15:46 kelvin/api/client/api/user.py
+-rw-r--r--  2.0 unx    17724 b- defN 24-Apr-24 15:46 kelvin/api/client/api/workload.py
+-rw-r--r--  2.0 unx      103 b- defN 24-Apr-24 15:46 kelvin/api/client/model/__init__.py
+-rw-r--r--  2.0 unx     2433 b- defN 24-Apr-24 15:46 kelvin/api/client/model/enum.py
+-rw-r--r--  2.0 unx     1812 b- defN 24-Apr-24 15:46 kelvin/api/client/model/pagination.py
+-rw-r--r--  2.0 unx   111310 b- defN 24-Apr-24 15:46 kelvin/api/client/model/requests.py
+-rw-r--r--  2.0 unx     2259 b- defN 24-Apr-24 15:46 kelvin/api/client/model/response.py
+-rw-r--r--  2.0 unx   149548 b- defN 24-Apr-24 15:46 kelvin/api/client/model/responses.py
+-rw-r--r--  2.0 unx    62707 b- defN 24-Apr-24 15:46 kelvin/api/client/model/type.py
+-rw-r--r--  2.0 unx     2881 b- defN 24-Apr-24 15:53 kelvin_python_api_client-0.0.2.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-Apr-24 15:53 kelvin_python_api_client-0.0.2.dist-info/WHEEL
+-rw-r--r--  2.0 unx        7 b- defN 24-Apr-24 15:53 kelvin_python_api_client-0.0.2.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     3969 b- defN 24-Apr-24 15:53 kelvin_python_api_client-0.0.2.dist-info/RECORD
+44 files, 771666 bytes uncompressed, 121429 bytes compressed:  84.3%
```

## zipnote {}

```diff
@@ -1,10 +1,13 @@
 Filename: kelvin/api/client/__init__.py
 Comment: 
 
+Filename: kelvin/api/client/api_service_model.py
+Comment: 
+
 Filename: kelvin/api/client/base_client.py
 Comment: 
 
 Filename: kelvin/api/client/base_model.py
 Comment: 
 
 Filename: kelvin/api/client/client.py
@@ -111,20 +114,20 @@
 
 Filename: kelvin/api/client/model/responses.py
 Comment: 
 
 Filename: kelvin/api/client/model/type.py
 Comment: 
 
-Filename: kelvin_python_api_client-0.0.1.dist-info/METADATA
+Filename: kelvin_python_api_client-0.0.2.dist-info/METADATA
 Comment: 
 
-Filename: kelvin_python_api_client-0.0.1.dist-info/WHEEL
+Filename: kelvin_python_api_client-0.0.2.dist-info/WHEEL
 Comment: 
 
-Filename: kelvin_python_api_client-0.0.1.dist-info/top_level.txt
+Filename: kelvin_python_api_client-0.0.2.dist-info/top_level.txt
 Comment: 
 
-Filename: kelvin_python_api_client-0.0.1.dist-info/RECORD
+Filename: kelvin_python_api_client-0.0.2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## kelvin/api/client/base_client.py

```diff
@@ -145,15 +145,15 @@
                 values["metadata"] = {}
                 raise TypeError("Unable to retrieve metadata")
         return value
 
     url: AnyUrl = Field(None, description="Base URL of API")
 
     @validator("realm_name", pre=True)
-    def check_realm_name(cls, value: Optional[str], values: MutableMapping[str, Any]) -> str:
+    def check_realm_name(cls, value: Optional[str], values: MutableMapping[str, Any]) -> Optional[str]:
         """Validate realm field."""
 
         if value is None:
             metadata = values.get("metadata")
             value = metadata.get("authentication", {}).get("realm") if metadata is not None else None
             if value is None:
                 url = values.get("url")
```

## kelvin/api/client/base_model.py

```diff
@@ -2,15 +2,15 @@
 Base data-model.
 """
 
 from __future__ import annotations
 
 from datetime import date
 from functools import reduce
-from typing import TYPE_CHECKING, Any, Iterable, Iterator, List, Mapping, Optional, Sequence, Tuple, TypeVar
+from typing import TYPE_CHECKING, Any, Iterable, Iterator, Mapping, Optional, Sequence, Tuple, TypeVar
 
 import pydantic
 from pydantic.main import ModelMetaclass
 
 if TYPE_CHECKING:
     from IPython.lib.pretty import RepresentationPrinter
 
@@ -145,23 +145,25 @@
 
     def __init__(self, **kwargs: Any) -> None:
         """Initialise model."""
 
         super().__init__(**kwargs)
 
     def __str__(self) -> str:
-        return self.__root__
+        return self.__root__.__str__()
 
     def __eq__(self, other: Any) -> bool:
         return self.__root__ == other
 
+    def __repr__(self) -> Any:
+        return self.__root__.__repr__()
+
     # Sequence methods
     def __getitem__(self, item) -> P:  # type: ignore
         """Get item."""
-
         return self.__root__[item]
 
     def __len__(self) -> int:
         """Number of items."""
 
         return len(self.__root__)
```

## kelvin/api/client/client.py

```diff
@@ -22,18 +22,18 @@
 from .api.parameters import Parameters
 from .api.recommendation import Recommendation
 from .api.secret import Secret
 from .api.thread import Thread
 from .api.timeseries import Timeseries
 from .api.user import User
 from .api.workload import Workload
+from .api_service_model import ApiServiceModel
 from .base_client import BaseClient
-from .data_model import DataModel
 
-MODELS: Mapping[str, Type[DataModel]] = {
+MODELS: Mapping[str, Type[ApiServiceModel]] = {
     "app_manager": AppManager,  # type: ignore
     "app_registry": AppRegistry,  # type: ignore
     "asset": Asset,  # type: ignore
     "asset_insights": AssetInsights,  # type: ignore
     "bridge": Bridge,  # type: ignore
     "control_change": ControlChange,  # type: ignore
     "data_tag": DataTag,  # type: ignore
@@ -47,15 +47,15 @@
     "thread": Thread,  # type: ignore
     "timeseries": Timeseries,  # type: ignore
     "user": User,  # type: ignore
     "workload": Workload,  # type: ignore
 }
 
 
-T = TypeVar("T", bound=DataModel)
+T = TypeVar("T", bound=ApiServiceModel)
 
 
 class DataModelProxy(Generic[T]):
     """Proxy client to data models."""
 
     def __init__(self, model: Type[T], client: Client) -> None:
         """Initialise resource adaptor."""
```

## kelvin/api/client/data_model.py

```diff
@@ -1,83 +1,46 @@
 """
 Data Model.
 """
 
 from __future__ import annotations
 
-import json
-from collections import ChainMap
 from datetime import datetime, timezone
 from functools import wraps
-from importlib import import_module
 from inspect import signature
 from types import FunctionType, MethodType
 from typing import (
     TYPE_CHECKING,
     Any,
     Callable,
     Dict,
     Generic,
-    Iterator,
     List,
     Mapping,
     Optional,
     Sequence,
     Tuple,
     Type,
     TypeVar,
     Union,
     cast,
 )
 
 import structlog
 from pydantic import Extra, ValidationError, validator
-from pydantic.main import ModelField
-from typing_inspect import get_args, get_origin
-
-from kelvin.api.client.serialize import lower
+from pydantic.fields import ModelField
 
 from .base_model import BaseModel, BaseModelMeta
 from .deeplist import deeplist
-from .error import APIError, ResponseError
-from .serialize import is_json
-from .utils import file_tuple, instance_classmethod, metadata_tuple, snake_name
-
-if TYPE_CHECKING:
-    from .client import Client
+from .utils import snake_name
 
 logger = structlog.get_logger(__name__)
 
 T = TypeVar("T")
 
-JSON_CONTENT_TYPES = (
-    "application/json",
-    "application/x-json-stream",
-)
-MODELS = "kelvin.api.client.model"
-
-
-def resolve_fields(x: Mapping[str, Any]) -> Dict[str, Any]:
-    """Resolve fields from data models."""
-
-    result: Dict[str, Any] = {**x}
-    items = [*x.items()]
-
-    for name, value in items:
-        if "_" in name and isinstance(value, DataModel):
-            head, tail = name.rsplit("_", 1)
-            if head != type(value).__name__.lower():
-                raise TypeError(f"Unable to get {name!r} from {type(value).__name__!r} object")
-            value = result[name] = value[tail]
-        if isinstance(value, datetime):
-            suffix = "Z" if value.microsecond else ".000000Z"
-            result[name] = value.astimezone(timezone.utc).replace(tzinfo=None).isoformat() + suffix
-
-    return result
-
 
 class DataModelMeta(BaseModelMeta):
     """DataModel metaclass."""
 
     def __new__(
         metacls: Type[DataModelMeta], name: str, bases: Tuple[Type, ...], __dict__: Dict[str, Any]
     ) -> DataModelMeta:
@@ -101,52 +64,31 @@
 
     def __str__(self) -> str:
         """Return str(self)."""
 
         return f"<class {self.__name__!r}>"
 
 
-def get_type(name: str) -> Type:
-    module_name, type_name = name.rsplit(".", 1)
-    return getattr(import_module(f"{MODELS}.{module_name}"), type_name)
-
-
 class DataModel(BaseModel, metaclass=DataModelMeta):
     """Model base-class."""
 
     if TYPE_CHECKING:
         fields: Any
         schema: Any
 
-    __slots__ = ("_client",)
-
     class Config(BaseModel.Config):
         """Model config."""
 
         extra = Extra.allow
 
-    def __init__(self, client: Optional[Client] = None, **kwargs: Any) -> None:
+    def __init__(self, **kwargs: Any) -> None:
         """Initialise model."""
 
         super().__init__(**kwargs)
 
-        object.__setattr__(self, "_client", client)
-
-    @property
-    def client(self) -> Optional[Client]:
-        """Resource client."""
-
-        if self._client is not None:
-            return self._client
-
-        if self._owner is not None:
-            return self._owner.client
-
-        return None
-
     def __getattribute__(self, name: str) -> Any:
         """Get attribute."""
 
         if name.startswith("_"):
             return super().__getattribute__(name)
 
         try:
@@ -216,215 +158,14 @@
 
                 return f(obj, *args, **kwargs)
 
             return inner
 
         return outer
 
-    @instance_classmethod
-    def _make_request(
-        obj: Any,
-        client: Optional[Client],
-        method: str,
-        path: str,
-        values: Mapping[str, Any],
-        params: Mapping[str, Any],
-        files: Mapping[str, Any],
-        headers: Mapping[str, Any],
-        data: Optional[Union[Mapping[str, Any], Sequence[Mapping[str, Any]]]],
-        body_type: Optional[str],
-        array_body: bool,
-        result_types: Mapping[str, Optional[Type]],
-        stream: bool = False,
-        dry_run: bool = False,
-        kwargs: Optional[Dict[str, Any]] = None,
-    ) -> Any:
-        """Make request to API."""
-
-        if isinstance(obj, DataModel):
-            if client is None:
-                client = obj.client
-
-        if client is None:
-            raise ValueError("No client set.")
-
-        # check for fields that need to be dereferenced
-        values = resolve_fields(values)
-        params = resolve_fields(params)
-        files = resolve_fields(files)
-        headers = resolve_fields(headers)
-
-        if "{" in path:
-            path = path.format_map(values)
-
-        body_data: Any
-
-        if body_type is not None:
-            body_type_ = get_type(body_type)
-
-            def prepare(x: Mapping[str, Any]) -> Dict[str, Any]:
-                if kwargs:
-                    x = ChainMap(kwargs, x)  # type: ignore
-                return {
-                    k: v
-                    for k, v in ((name, x.get(name)) for name in cast(Type[DataModel], body_type_).__fields__)
-                    if v is not None
-                }
-
-            if array_body:
-                if data is None:
-                    data = [{}] if kwargs else []
-                elif not isinstance(data, Sequence) and all(isinstance(x, Mapping) for x in data):
-                    raise ValueError("Data must be a sequence of mappings")
-
-                body_data = [
-                    body_type_(**lower(prepare(x))).dict(by_alias=True) for x in cast(Sequence[Mapping[str, Any]], data)
-                ]
-            else:
-                if data is None:
-                    data = {}
-                elif not isinstance(data, Mapping):
-                    raise ValueError("Data must be a mapping")
-
-                if isinstance(obj, DataModel):
-                    data = ChainMap(data, obj)  # type: ignore
-
-                body_data = body_type_(**lower(prepare(data))).dict(by_alias=True)
-        else:
-            body_data = None
-        metadata = None
-        if "metadata" in files:
-            metadata = files.pop("metadata")
-        files = {k: file_tuple(v) for k, v in files.items()}
-        if metadata is not None:
-            files = {**files, "metadata": metadata_tuple(metadata)}
-        if dry_run:
-            return {
-                "path": path,
-                "method": method,
-                "data": body_data,
-                "params": params,
-                "files": files,
-                "headers": headers,
-            }
-
-        response = client.request(path, method, body_data, params, files, headers, raise_error=False, stream=stream)
-
-        try:
-            content_type = response.headers.get("Content-Type", "")
-            if content_type == "application/octet-stream":
-                return response.iter_content(1024)
-
-            status_code = response.status_code
-
-            result_type = result_types.get(str(status_code), ...)
-
-            if not response.ok:
-                if result_type is ...:
-                    # try to fill gap with first not "OK" response
-                    result_type = next(
-                        (v for k, v in sorted(result_types.items()) if not 200 <= status_code < 300),
-                        ...,
-                    )
-                    if result_type is ...:
-                        logger.warning("Unknown response code", status_code=status_code)
-                        result_type = None
-                        if content_type == "application/json" or is_json(response.text):
-                            raise APIError(response)
-                        response.raise_for_status()
-
-            elif result_type is ...:
-                # try to fill gap with first "OK" response
-                result_type = next((v for k, v in sorted(result_types.items()) if 200 <= status_code < 300), ...)
-                if result_type is ...:
-                    logger.warning("Unknown response code", status_code=status_code)
-                    result_type = None
-
-            if isinstance(result_type, type):
-                if not content_type.startswith(JSON_CONTENT_TYPES):
-                    with response:
-                        raise ResponseError(
-                            f"Unexpected response for {result_type.__name__}",  # type: ignore
-                            response,
-                        )
-
-                def converter(x: Any) -> Any:
-                    return result_type(client=client, **x)  # type: ignore
-
-            elif get_origin(result_type) is list:
-                result_type, *_ = get_args(result_type)
-                if not content_type.startswith(JSON_CONTENT_TYPES):
-                    with response:
-                        raise ResponseError(
-                            f"Unexpected response for {result_type.__name__}",  # type: ignore
-                            response,
-                        )
-
-                def converter(x: Any) -> Any:
-                    return [result_type(client=client, **v) for v in x]  # type: ignore
-
-            else:
-                if not content_type.startswith(JSON_CONTENT_TYPES):
-                    with response:
-                        return response.text or None
-
-                def converter(x: Any) -> Any:
-                    return x
-
-            if not response.ok:
-                with response:
-                    raise APIError(response, converter)
-
-            if stream:
-
-                def results() -> Iterator[Any]:
-                    i = -1
-                    errors = []
-                    success = False
-                    with response:
-                        for x in response.iter_lines():
-                            if not x:
-                                continue
-                            i += 0
-                            records = json.loads(x)
-                            if isinstance(records, dict):
-                                records = [records]
-
-                            for record in records:
-                                try:
-                                    yield converter(record)
-                                except ValidationError as e:
-                                    errors += [(i, e)]
-                                    continue
-                                else:
-                                    success = True
-
-                        if not errors:
-                            return
-
-                        if not success:
-                            raise errors[0][1] from None
-                        elif errors:
-                            summary = "\n".join(f"  {i}: {x}" for i, x in errors)
-                            logger.warning("Skipped items", result_type=result_type, summary=summary)
-
-                results.__qualname__ = "results"
-
-                return results()
-            else:
-                with response:
-                    try:
-                        return converter(response.json())
-                    except ValidationError as e:
-                        raise e from None
-
-        except Exception:
-            response.close()
-            raise
-
     @validator("*", pre=True)
     def convert_datetime(cls, value: Any, field: ModelField) -> Any:
         """Correct data-type for datetime values."""
 
         if not isinstance(value, datetime):
             return value
 
@@ -451,17 +192,14 @@
     """Paginator data-model."""
 
     def __init__(self, **kwargs: Any) -> None:
         """Initialise model."""
 
         super().__init__(**kwargs)
 
-        for x in self.data:
-            object.__setattr__(x, "_client", self._client)
-
     @validator("data", pre=True, check_fields=False)
     def validate_data(cls, v: Sequence[Mapping[str, Any]], field: ModelField) -> List[P]:
         """Validate data field."""
 
         T = field.type_
         results = []
 
@@ -477,47 +215,9 @@
         """Get item."""
 
         if isinstance(item, int):
             return self.data[item]
 
         return super().__getitem__(item)
 
-    def scan(self, path: str, flatten: bool = True, method: str = "GET", data: Any = None) -> Iterator[P]:
-        """Iterate pages."""
-
-        result = self
-        client = self._client
-
-        while True:
-            if not result.data:
-                return
-
-            if flatten:
-                yield from result.data
-            else:
-                yield result.data
-
-            pagination = result.pagination
-            if pagination is None:
-                return
-
-            next_page = pagination.next_page
-            if next_page is None:
-                return
-
-            if "?" in next_page:
-                path = next_page
-                params = {}
-            else:
-                page_size = len(result.data)
-                params = {"next": next_page, "page_size": page_size}
-
-            with client.request(path, method=method, params=params, data=data) as response:
-                result = type(self)(**response.json(), client=client)
-
-    def fetch(self, path: str, method: str = "GET", data: Any = None) -> Sequence[P]:
-        """Fetch all data."""
-
-        return type(self.data)(self.scan(path, True, method=method, data=data))
-
 
 DataModelBase = DataModel
```

## kelvin/api/client/serialize.py

```diff
@@ -8,14 +8,15 @@
 import os
 import re
 from datetime import date, datetime, timedelta, timezone
 from enum import Enum
 from math import isfinite
 from pathlib import Path
 from typing import Any, Callable, Dict, Iterable, Mapping, Tuple, Type, cast
+from uuid import UUID
 
 import yaml
 
 from kelvin.api.client.base_model import BaseModelRoot
 
 from .utils import chdir
 
@@ -116,14 +117,16 @@
         return {k: lower(v, skip) for k, v in x.dict().items()}
     if isinstance(x, Iterable):
         if not skip:
             return [lower(v, skip) for v in x]
         return [v for v in (lower(v, skip) for v in x) if v is not ...]
     if isinstance(x, Enum):
         return x.name
+    if isinstance(x, UUID):
+        return str(x)
 
     if skip:
         return ...
 
     raise ValueError(f"Un-lowerable type: {type(x).__name__}")
```

## kelvin/api/client/version.py

```diff
@@ -8,9 +8,9 @@
     VERSION_TUPLE = object
 
 version: str
 __version__: str
 __version_tuple__: VERSION_TUPLE
 version_tuple: VERSION_TUPLE
 
-__version__ = version = '0.0.1'
-__version_tuple__ = version_tuple = (0, 0, 1)
+__version__ = version = '0.0.2'
+__version_tuple__ = version_tuple = (0, 0, 2)
```

## kelvin/api/client/api/app_manager.py

```diff
@@ -1,23 +1,23 @@
 """
 Kelvin API Client.
 """
 
 from __future__ import annotations
 
-from typing import Any, List, Mapping, Optional, Sequence, Union
+from typing import Any, List, Mapping, Optional, Sequence, Union, cast
 
 from typing_extensions import Literal
 
-from kelvin.api.client.data_model import DataModelBase
+from kelvin.api.client.api_service_model import ApiServiceModel
 
 from ..model import requests, responses, type
 
 
-class AppManager(DataModelBase):
+class AppManager(ApiServiceModel):
     @classmethod
     def get_app_manager_app(
         cls, app_name: str, _dry_run: bool = False, _client: Any = None
     ) -> responses.AppManagerAppGet:
         """
         Retrieve the parameters of an Application.
 
@@ -217,15 +217,21 @@
             False,
             {"200": responses.AppManagerAppResourcesListPaginatedResponseCursor, "400": None, "401": None},
             False,
             _dry_run,
             kwargs,
         )
         return (
-            result.fetch("/api/v4/app-manager/app/{app_name}/resources/list", "POST", data)
+            cast(
+                Union[
+                    List[responses.AppManagerResourceContext],
+                    responses.AppManagerAppResourcesListPaginatedResponseCursor,
+                ],
+                cls.fetch(_client, "/api/v4/app-manager/app/{app_name}/resources/list", result, "POST", data),
+            )
             if fetch and not _dry_run
             else result
         )
 
     @classmethod
     def get_app_manager_app_version_data_mapping(
         cls,
@@ -559,15 +565,22 @@
             "requests.AppManagerList",
             False,
             {"200": responses.AppManagerListPaginatedResponseCursor, "400": None, "401": None},
             False,
             _dry_run,
             kwargs,
         )
-        return result.fetch("/api/v4/app-manager/list", "POST", data) if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[type.AppManagerApp], responses.AppManagerListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/app-manager/list", result, "POST", data),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def get_app_manager_resource(
         cls,
         resource_krn: str,
         pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
         page_size: Optional[int] = 10000,
@@ -638,9 +651,14 @@
             None,
             False,
             {"200": responses.AppManagerResourceGetPaginatedResponseCursor, "400": None, "401": None, "404": None},
             False,
             _dry_run,
         )
         return (
-            result.fetch("/api/v4/app-manager/resource/{resource_krn}/get", "GET") if fetch and not _dry_run else result
+            cast(
+                Union[List[type.AppManagerAppVersionSummary], responses.AppManagerResourceGetPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/app-manager/resource/{resource_krn}/get", result, "GET"),
+            )
+            if fetch and not _dry_run
+            else result
         )
```

## kelvin/api/client/api/app_registry.py

```diff
@@ -1,23 +1,23 @@
 """
 Kelvin API Client.
 """
 
 from __future__ import annotations
 
-from typing import Any, List, Mapping, Optional, Sequence, Union
+from typing import Any, List, Mapping, Optional, Sequence, Union, cast
 
 from typing_extensions import Literal
 
-from kelvin.api.client.data_model import DataModelBase
+from kelvin.api.client.api_service_model import ApiServiceModel
 
 from ..model import requests, responses
 
 
-class AppRegistry(DataModelBase):
+class AppRegistry(ApiServiceModel):
     @classmethod
     def create_app(
         cls,
         data: Optional[Union[requests.AppCreate, Mapping[str, Any]]] = None,
         _dry_run: bool = False,
         _client: Any = None,
         **kwargs: Any,
@@ -139,15 +139,22 @@
             None,
             None,
             False,
             {"200": responses.AppRegistryAppsListPaginatedResponseCursor, "400": None, "401": None},
             False,
             _dry_run,
         )
-        return result.fetch("/api/v4/appregistry/list", "GET") if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[responses.AppItem], responses.AppRegistryAppsListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/appregistry/list", result, "GET"),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def delete_app(cls, app_name: str, _dry_run: bool = False, _client: Any = None) -> None:
         """
         Permanently delete all versions of an App in the App Registry. This cannot be undone once the API request has been submitted.
 
         **Permission Required:** `kelvin.permission.appregistry.delete`.
```

## kelvin/api/client/api/asset.py

```diff
@@ -1,23 +1,23 @@
 """
 Kelvin API Client.
 """
 
 from __future__ import annotations
 
-from typing import Any, List, Mapping, Optional, Sequence, Union
+from typing import Any, List, Mapping, Optional, Sequence, Union, cast
 
 from typing_extensions import Literal
 
-from kelvin.api.client.data_model import DataModelBase
+from kelvin.api.client.api_service_model import ApiServiceModel
 
 from ..model import requests, responses, type
 
 
-class Asset(DataModelBase):
+class Asset(ApiServiceModel):
     @classmethod
     def create_asset_bulk(
         cls,
         dry_run: Optional[bool] = None,
         data: Optional[Union[requests.AssetBulkCreate, Mapping[str, Any]]] = None,
         _dry_run: bool = False,
         _client: Any = None,
@@ -239,15 +239,22 @@
             None,
             None,
             False,
             {"200": responses.AssetsListPaginatedResponseCursor, "400": None, "401": None, "404": None},
             False,
             _dry_run,
         )
-        return result.fetch("/api/v4/assets/list", "GET") if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[type.Asset], responses.AssetsListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/assets/list", result, "GET"),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def list_assets_advanced(
         cls,
         pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
         page_size: Optional[int] = 10000,
         page: Optional[int] = None,
@@ -319,15 +326,22 @@
             "requests.AssetsAdvancedList",
             False,
             {"200": responses.AssetsAdvancedListPaginatedResponseCursor, "400": None, "401": None, "404": None},
             False,
             _dry_run,
             kwargs,
         )
-        return result.fetch("/api/v4/assets/list", "POST", data) if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[type.Asset], responses.AssetsAdvancedListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/assets/list", result, "POST", data),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def list_asset_property_definitions(
         cls,
         all: Optional[bool] = None,
         pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
         page_size: Optional[int] = 10000,
@@ -410,15 +424,18 @@
                 "404": None,
             },
             False,
             _dry_run,
             kwargs,
         )
         return (
-            result.fetch("/api/v4/assets/properties/definitions/list", "POST", data)
+            cast(
+                Union[List[type.Property], responses.AssetPropertyDefinitionsListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/assets/properties/definitions/list", result, "POST", data),
+            )
             if fetch and not _dry_run
             else result
         )
 
     @classmethod
     def get_asset_property_values(
         cls,
@@ -686,15 +703,22 @@
             None,
             None,
             False,
             {"200": responses.AssetTypesListPaginatedResponseCursor, "400": None, "401": None},
             False,
             _dry_run,
         )
-        return result.fetch("/api/v4/assets/types/list", "GET") if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[type.AssetType], responses.AssetTypesListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/assets/types/list", result, "GET"),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def list_asset_types_advanced(
         cls,
         pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
         page_size: Optional[int] = 10000,
         page: Optional[int] = None,
@@ -766,15 +790,22 @@
             "requests.AssetTypesAdvancedList",
             False,
             {"200": responses.AssetTypesAdvancedListPaginatedResponseCursor, "400": None, "401": None},
             False,
             _dry_run,
             kwargs,
         )
-        return result.fetch("/api/v4/assets/types/list", "POST", data) if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[type.AssetType], responses.AssetTypesAdvancedListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/assets/types/list", result, "POST", data),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def delete_asset_type(cls, asset_type_name: str, _dry_run: bool = False, _client: Any = None) -> None:
         """
         Permanently delete an existing Asset Type. An error will be returned if there are any current links to an Asset. This cannot be undone once the API request has been submitted.
 
         **Permission Required:** `kelvin.permission.asset_type.delete`.
```

## kelvin/api/client/api/asset_insights.py

```diff
@@ -1,23 +1,23 @@
 """
 Kelvin API Client.
 """
 
 from __future__ import annotations
 
-from typing import Any, List, Mapping, Optional, Union
+from typing import Any, List, Mapping, Optional, Union, cast
 
 from typing_extensions import Literal
 
-from kelvin.api.client.data_model import DataModelBase
+from kelvin.api.client.api_service_model import ApiServiceModel
 
 from ..model import requests, responses
 
 
-class AssetInsights(DataModelBase):
+class AssetInsights(ApiServiceModel):
     @classmethod
     def get_asset_insights(
         cls,
         page_size: Optional[int] = 10000,
         page: Optional[int] = None,
         data: Optional[Union[requests.AssetInsightsGet, Mapping[str, Any]]] = None,
         fetch: bool = True,
@@ -60,8 +60,15 @@
             "requests.AssetInsightsGet",
             False,
             {"200": responses.AssetInsightsGetPaginated, "400": None, "424": None},
             False,
             _dry_run,
             kwargs,
         )
-        return result.fetch("/api/v4/asset-insights/get", "POST", data) if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[responses.AssetInsightsItem], responses.AssetInsightsGetPaginated],
+                cls.fetch(_client, "/api/v4/asset-insights/get", result, "POST", data),
+            )
+            if fetch and not _dry_run
+            else result
+        )
```

## kelvin/api/client/api/bridge.py

```diff
@@ -1,23 +1,23 @@
 """
 Kelvin API Client.
 """
 
 from __future__ import annotations
 
-from typing import Any, List, Mapping, Optional, Sequence, Union
+from typing import Any, List, Mapping, Optional, Sequence, Union, cast
 
 from typing_extensions import Literal
 
-from kelvin.api.client.data_model import DataModelBase
+from kelvin.api.client.api_service_model import ApiServiceModel
 
 from ..model import requests, responses
 
 
-class Bridge(DataModelBase):
+class Bridge(ApiServiceModel):
     @classmethod
     def deploy_bridge(
         cls,
         data: Optional[Union[requests.BridgeDeploy, Mapping[str, Any]]] = None,
         _dry_run: bool = False,
         _client: Any = None,
         **kwargs: Any,
@@ -166,15 +166,22 @@
             None,
             None,
             False,
             {"200": responses.BridgesListPaginatedResponseCursor, "400": None, "401": None},
             False,
             _dry_run,
         )
-        return result.fetch("/api/v4/bridges/list", "GET") if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[responses.BridgeItem], responses.BridgesListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/bridges/list", result, "GET"),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def delete_bridge(cls, bridge_name: str, _dry_run: bool = False, _client: Any = None) -> None:
         """
         Permanently delete an existing Bridge (Connection). You will no longer receieve Asset / Data Stream data from the assets associated with the Bridge (Connection). This cannot be undone once the API request has been submitted.
 
         **Permission Required:** `kelvin.permission.bridge.delete`.
```

## kelvin/api/client/api/control_change.py

```diff
@@ -1,23 +1,23 @@
 """
 Kelvin API Client.
 """
 
 from __future__ import annotations
 
-from typing import Any, List, Mapping, Optional, Sequence, Union
+from typing import Any, List, Mapping, Optional, Sequence, Union, cast
 
 from typing_extensions import Literal
 
-from kelvin.api.client.data_model import DataModelBase
+from kelvin.api.client.api_service_model import ApiServiceModel
 
 from ..model import requests, responses
 
 
-class ControlChange(DataModelBase):
+class ControlChange(ApiServiceModel):
     @classmethod
     def get_control_change_clustering(
         cls,
         data: Optional[Union[requests.ControlChangeClusteringGet, Mapping[str, Any]]] = None,
         _dry_run: bool = False,
         _client: Any = None,
         **kwargs: Any,
@@ -181,15 +181,22 @@
             "requests.ControlChangeLastGet",
             False,
             {"200": responses.ControlChangeLastGetPaginatedResponseCursor, "400": None},
             False,
             _dry_run,
             kwargs,
         )
-        return result.fetch("/api/v4/control-changes/last/get", "POST", data) if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[responses.ControlChangeGet], responses.ControlChangeLastGetPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/control-changes/last/get", result, "POST", data),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def list_control_changes(
         cls,
         status_limit: Optional[int] = None,
         pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
         page_size: Optional[int] = 10000,
@@ -266,15 +273,22 @@
             "requests.ControlChangesList",
             False,
             {"200": responses.ControlChangesListPaginatedResponseCursor, "400": None},
             False,
             _dry_run,
             kwargs,
         )
-        return result.fetch("/api/v4/control-changes/list", "POST", data) if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[responses.ControlChangeGet], responses.ControlChangesListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/control-changes/list", result, "POST", data),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def get_control_change_range(
         cls,
         status_limit: Optional[int] = None,
         pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
         page_size: Optional[int] = 10000,
@@ -351,15 +365,22 @@
             "requests.ControlChangeRangeGet",
             False,
             {"200": responses.ControlChangeRangeGetPaginatedResponseCursor, "400": None},
             False,
             _dry_run,
             kwargs,
         )
-        return result.fetch("/api/v4/control-changes/range/get", "POST", data) if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[responses.ControlChangeGet], responses.ControlChangeRangeGetPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/control-changes/range/get", result, "POST", data),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def get_control_change(
         cls, control_change_id: str, status_limit: Optional[int] = None, _dry_run: bool = False, _client: Any = None
     ) -> responses.ControlChangeGet:
         """
         Retrieves the properties, status and all associated logs of a Control Change.
```

## kelvin/api/client/api/data_tag.py

```diff
@@ -1,35 +1,35 @@
 """
 Kelvin API Client.
 """
 
 from __future__ import annotations
 
-from typing import Any, List, Mapping, Optional, Sequence, Union
+from typing import Any, List, Mapping, Optional, Sequence, Union, cast
 
 from typing_extensions import Literal
 
-from kelvin.api.client.data_model import DataModelBase
+from kelvin.api.client.api_service_model import ApiServiceModel
 
 from ..model import requests, responses, type
 
 
-class DataTag(DataModelBase):
+class DataTag(ApiServiceModel):
     @classmethod
     def create_data_tag(
         cls,
         data: Optional[Union[requests.DataTagCreate, Mapping[str, Any]]] = None,
         _dry_run: bool = False,
         _client: Any = None,
         **kwargs: Any,
     ) -> responses.DataTagCreate:
         """
         Create a new Data Tag event.
 
-        **Permission Required:** `kelvin.permission.data_tag.create`.
+        **Permission Required:** `kelvin.permission.datatag.create`.
 
         ``createDataTag``: ``POST`` ``/api/v4/datatags/create``
 
         Parameters
         ----------
         data: requests.DataTagCreate, optional
         **kwargs:
@@ -55,35 +55,35 @@
             False,
             _dry_run,
             kwargs,
         )
         return result
 
     @classmethod
-    def list_data_tags(
+    def list_data_tag(
         cls,
         pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
         page_size: Optional[int] = 10000,
         page: Optional[int] = None,
         next: Optional[str] = None,
         previous: Optional[str] = None,
         direction: Optional[Literal["asc", "desc"]] = None,
         sort_by: Optional[Sequence[str]] = None,
-        data: Optional[Union[requests.DataTagsList, Mapping[str, Any]]] = None,
+        data: Optional[Union[requests.DataTagList, Mapping[str, Any]]] = None,
         fetch: bool = True,
         _dry_run: bool = False,
         _client: Any = None,
         **kwargs: Any,
-    ) -> Union[List[type.DataTag], responses.DataTagsListPaginatedResponseCursor]:
+    ) -> Union[List[type.DataTag], responses.DataTagListPaginatedResponseCursor]:
         """
         Returns a list of Data Tags. The Data Tags can be optionally filtered and sorted on the server before being returned.
 
-        **Permission Required:** `kelvin.permission.data_tag.read`.
+        **Permission Required:** `kelvin.permission.datatag.read`.
 
-        ``listDataTags``: ``POST`` ``/api/v4/datatags/list``
+        ``listDataTag``: ``POST`` ``/api/v4/datatags/list``
 
         Parameters
         ----------
         pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
             Method of pagination to use for return results where `total_items` is
             greater than `page_size`. `cursor` and `limits` will return one `page`
             of results, `stream` will return all results. ('limits', 'cursor',
@@ -99,18 +99,18 @@
             next page. Used only with `pagination_type` set as `cursor`.
         previous : :obj:`str`
             An alphanumeric string bookmark to indicate where to end for the
             previous page. Used only with `pagination_type` set as `cursor`.
         direction : :obj:`Literal['asc', 'desc']`
             Sorting order according to the `sort_by` parameter. ('asc', 'desc')
         sort_by : :obj:`Sequence[str]`
-        data: requests.DataTagsList, optional
+        data: requests.DataTagList, optional
         **kwargs:
-            Extra parameters for requests.DataTagsList
-              - list_data_tags: dict
+            Extra parameters for requests.DataTagList
+              - list_data_tag: dict
 
         """
 
         from ..model import responses
 
         result = cls._make_request(
             _client,
@@ -125,35 +125,42 @@
                 "previous": previous,
                 "direction": direction,
                 "sort_by": sort_by,
             },
             {},
             {},
             data,
-            "requests.DataTagsList",
+            "requests.DataTagList",
             False,
-            {"200": responses.DataTagsListPaginatedResponseCursor, "400": None, "401": None},
+            {"200": responses.DataTagListPaginatedResponseCursor, "400": None, "401": None},
             False,
             _dry_run,
             kwargs,
         )
-        return result.fetch("/api/v4/datatags/list", "POST", data) if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[type.DataTag], responses.DataTagListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/datatags/list", result, "POST", data),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def create_tag(
         cls,
         data: Optional[Union[requests.TagCreate, Mapping[str, Any]]] = None,
         _dry_run: bool = False,
         _client: Any = None,
         **kwargs: Any,
     ) -> responses.TagCreate:
         """
         Create a new Tag.
 
-        **Permission Required:** `kelvin.permission.data_tag.create`.
+        **Permission Required:** `kelvin.permission.datatag.create`.
 
         ``createTag``: ``POST`` ``/api/v4/datatags/tags/create``
 
         Parameters
         ----------
         data: requests.TagCreate, optional
         **kwargs:
@@ -179,35 +186,35 @@
             False,
             _dry_run,
             kwargs,
         )
         return result
 
     @classmethod
-    def list_tags(
+    def list_tag(
         cls,
         search: Optional[Sequence[str]] = None,
         names: Optional[Sequence[str]] = None,
         pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
         page_size: Optional[int] = 10000,
         page: Optional[int] = None,
         next: Optional[str] = None,
         previous: Optional[str] = None,
         direction: Optional[Literal["asc", "desc"]] = None,
         sort_by: Optional[Sequence[str]] = None,
         fetch: bool = True,
         _dry_run: bool = False,
         _client: Any = None,
-    ) -> Union[List[type.Tag], responses.TagsListPaginatedResponseCursor]:
+    ) -> Union[List[type.Tag], responses.TagListPaginatedResponseCursor]:
         """
         Returns a list of Tags. The Tags can be optionally filtered and sorted on the server before being returned.
 
-        **Permission Required:** `kelvin.permission.data_tag.read`.
+        **Permission Required:** `kelvin.permission.datatag.read`.
 
-        ``listTags``: ``GET`` ``/api/v4/datatags/tags/list``
+        ``listTag``: ``GET`` ``/api/v4/datatags/tags/list``
 
         Parameters
         ----------
         search : :obj:`Sequence[str]`
             Search and filter on the list based on the key `name` (Tag Name). All
             values in array will be filtered as `OR`. The search is case
             insensitive and will find partial matches as well.
@@ -257,25 +264,32 @@
                 "sort_by": sort_by,
             },
             {},
             {},
             None,
             None,
             False,
-            {"200": responses.TagsListPaginatedResponseCursor, "400": None, "401": None},
+            {"200": responses.TagListPaginatedResponseCursor, "400": None, "401": None},
             False,
             _dry_run,
         )
-        return result.fetch("/api/v4/datatags/tags/list", "GET") if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[type.Tag], responses.TagListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/datatags/tags/list", result, "GET"),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def delete_tag(cls, tag_name: str, _dry_run: bool = False, _client: Any = None) -> None:
         """
         Permanently delete an existing Tag. An error will be returned if there are any current links to a DataTag and the Tag will not be deleted.
-        **Permission Required:** `kelvin.permission.data_tag.delete`.
+        **Permission Required:** `kelvin.permission.datatag.delete`.
 
         ``deleteTag``: ``POST`` ``/api/v4/datatags/tags/{tag_name}/delete``
 
         Parameters
         ----------
         tag_name : :obj:`str`, optional
             Tag key `name`.
@@ -300,15 +314,15 @@
         return result
 
     @classmethod
     def get_tag(cls, tag_name: str, _dry_run: bool = False, _client: Any = None) -> responses.TagGet:
         """
         Retrieves a Tag.
 
-        **Permission Required:** `kelvin.permission.data_tag.read`.
+        **Permission Required:** `kelvin.permission.datatag.read`.
 
         ``getTag``: ``GET`` ``/api/v4/datatags/tags/{tag_name}/get``
 
         Parameters
         ----------
         tag_name : :obj:`str`, optional
             Tag key `name`.
@@ -342,15 +356,15 @@
         _dry_run: bool = False,
         _client: Any = None,
         **kwargs: Any,
     ) -> responses.TagUpdate:
         """
         Update an existing Tag. The Tag key `name` can not be updated.
 
-        **Permission Required:** `kelvin.permission.data_tag.update`.
+        **Permission Required:** `kelvin.permission.datatag.update`.
 
         ``updateTag``: ``POST`` ``/api/v4/datatags/tags/{tag_name}/update``
 
         Parameters
         ----------
         tag_name : :obj:`str`, optional
             Tag key `name`.
@@ -381,15 +395,15 @@
         )
         return result
 
     @classmethod
     def delete_data_tag(cls, datatag_id: str, _dry_run: bool = False, _client: Any = None) -> None:
         """
         Permanently delete an existing Data Tag.
-        **Permission Required:** `kelvin.permission.data_tag.delete`.
+        **Permission Required:** `kelvin.permission.datatag.delete`.
 
         ``deleteDataTag``: ``POST`` ``/api/v4/datatags/{datatag_id}/delete``
 
         Parameters
         ----------
         datatag_id : :obj:`str`, optional
             Data Tag key `id`. The string can only contain alphanumeric characters
@@ -415,15 +429,15 @@
         return result
 
     @classmethod
     def get_data_tag(cls, datatag_id: str, _dry_run: bool = False, _client: Any = None) -> responses.DataTagGet:
         """
         Retrieves a Data Tag.
 
-        **Permission Required:** `kelvin.permission.data_tag.read`.
+        **Permission Required:** `kelvin.permission.datatag.read`.
 
         ``getDataTag``: ``GET`` ``/api/v4/datatags/{datatag_id}/get``
 
         Parameters
         ----------
         datatag_id : :obj:`str`, optional
             Data Tag key `id`. The string can only contain alphanumeric characters
@@ -458,15 +472,15 @@
         _dry_run: bool = False,
         _client: Any = None,
         **kwargs: Any,
     ) -> responses.DataTagUpdate:
         """
         Update an existing Data Tag. Any parameters that are not provided will remain unchanged.
 
-        **Permission Required:** `kelvin.permission.data_tag.update`.
+        **Permission Required:** `kelvin.permission.datatag.update`.
 
         ``updateDataTag``: ``POST`` ``/api/v4/datatags/{datatag_id}/update``
 
         Parameters
         ----------
         datatag_id : :obj:`str`, optional
             Data Tag key `id`. The string can only contain alphanumeric characters
```

## kelvin/api/client/api/datastreams.py

```diff
@@ -1,23 +1,23 @@
 """
 Kelvin API Client.
 """
 
 from __future__ import annotations
 
-from typing import Any, List, Mapping, Optional, Sequence, Union
+from typing import Any, List, Mapping, Optional, Sequence, Union, cast
 
 from typing_extensions import Literal
 
-from kelvin.api.client.data_model import DataModelBase
+from kelvin.api.client.api_service_model import ApiServiceModel
 
 from ..model import requests, responses, type
 
 
-class Datastreams(DataModelBase):
+class Datastreams(ApiServiceModel):
     @classmethod
     def create_bulk_data_stream(
         cls,
         data: Optional[Union[requests.BulkDataStreamCreate, Mapping[str, Any]]] = None,
         _dry_run: bool = False,
         _client: Any = None,
         **kwargs: Any,
@@ -130,15 +130,22 @@
             "requests.DataStreamContextsList",
             False,
             {"200": responses.DataStreamContextsListPaginatedResponseCursor, "400": None, "401": None},
             False,
             _dry_run,
             kwargs,
         )
-        return result.fetch("/api/v4/datastreams/context/list", "POST", data) if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[responses.DataStreamContext], responses.DataStreamContextsListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/datastreams/context/list", result, "POST", data),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def create_data_stream(
         cls,
         data: Optional[Union[requests.DataStreamCreate, Mapping[str, Any]]] = None,
         _dry_run: bool = False,
         _client: Any = None,
@@ -252,15 +259,22 @@
             None,
             None,
             False,
             {"200": responses.DataStreamsDataTypesListPaginatedResponseCursor, "400": None, "401": None},
             False,
             _dry_run,
         )
-        return result.fetch("/api/v4/datastreams/data-types/list", "GET") if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[type.DataStreamDataType], responses.DataStreamsDataTypesListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/datastreams/data-types/list", result, "GET"),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def list_data_streams(
         cls,
         pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
         page_size: Optional[int] = 10000,
         page: Optional[int] = None,
@@ -332,15 +346,22 @@
             "requests.DataStreamsList",
             False,
             {"200": responses.DataStreamsListPaginatedResponseCursor, "400": None, "401": None},
             False,
             _dry_run,
             kwargs,
         )
-        return result.fetch("/api/v4/datastreams/list", "POST", data) if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[responses.DataStream], responses.DataStreamsListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/datastreams/list", result, "POST", data),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def create_data_stream_semantic_type(
         cls,
         data: Optional[Union[requests.DataStreamSemanticTypeCreate, Mapping[str, Any]]] = None,
         _dry_run: bool = False,
         _client: Any = None,
@@ -452,15 +473,22 @@
             None,
             None,
             False,
             {"200": responses.DataStreamsSemanticTypesListPaginatedResponseCursor, "400": None, "401": None},
             False,
             _dry_run,
         )
-        return result.fetch("/api/v4/datastreams/semantic-types/list", "GET") if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[type.DataStreamSemanticType], responses.DataStreamsSemanticTypesListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/datastreams/semantic-types/list", result, "GET"),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def delete_data_stream_semantic_type(
         cls, semantic_type_name: str, _dry_run: bool = False, _client: Any = None
     ) -> None:
         """
         Permanently delete an existing Semantic Type. An error will be returned if there are any current links to a Semantic Type. This cannot be undone once the API request has been submitted.
@@ -736,15 +764,22 @@
             None,
             None,
             False,
             {"200": responses.DataStreamsUnitsListPaginatedResponseCursor, "400": None, "401": None},
             False,
             _dry_run,
         )
-        return result.fetch("/api/v4/datastreams/units/list", "GET") if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[type.Unit], responses.DataStreamsUnitsListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/datastreams/units/list", result, "GET"),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def delete_data_stream_unit(cls, unit_name: str, _dry_run: bool = False, _client: Any = None) -> None:
         """
         Permanently delete an existing Unit. An error will be returned if there are any current links to a Unit. This cannot be undone once the API request has been submitted.
 
         **Permission Required:** `kelvin.permission.datastreams.delete`.
```

## kelvin/api/client/api/filestorage.py

```diff
@@ -1,23 +1,23 @@
 """
 Kelvin API Client.
 """
 
 from __future__ import annotations
 
-from typing import Any, Dict, Iterator, List, Mapping, Optional, Union
+from typing import Any, Dict, Iterator, List, Mapping, Optional, Union, cast
 
 from typing_extensions import Literal
 
-from kelvin.api.client.data_model import DataModelBase
+from kelvin.api.client.api_service_model import ApiServiceModel
 
 from ..model import requests, responses, type
 
 
-class Filestorage(DataModelBase):
+class Filestorage(ApiServiceModel):
     @classmethod
     def list_files(
         cls,
         pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
         page_size: Optional[int] = 10000,
         page: Optional[int] = None,
         next: Optional[str] = None,
@@ -85,34 +85,37 @@
             "requests.FilesList",
             False,
             {"200": responses.FilesListPaginatedCursor, "400": None, "401": None},
             False,
             _dry_run,
             kwargs,
         )
-        return result.fetch("/api/v4/filestorage/list", "POST", data) if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[type.FileStorage], responses.FilesListPaginatedCursor],
+                cls.fetch(_client, "/api/v4/filestorage/list", result, "POST", data),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def upload_file(
-        cls,
-        file: Optional[str] = None,
-        metadata: Optional[Dict[str, Any]] = None,
-        _dry_run: bool = False,
-        _client: Any = None,
+        cls, file: str, metadata: Optional[Dict[str, Any]] = None, _dry_run: bool = False, _client: Any = None
     ) -> responses.FileUpload:
         """
         Upload a file
 
         **Permission Required:** `kelvin.permission.filestorage.upload`.
 
         ``uploadFile``: ``POST`` ``/api/v4/filestorage/upload``
 
         Parameters
         ----------
-        file : :obj:`str`
+        file : :obj:`str`, optional
         metadata : :obj:`Dict[str, Any]`
 
         """
 
         from ..model import responses
 
         result = cls._make_request(
@@ -166,15 +169,15 @@
         return result
 
     @classmethod
     def download_file(cls, file_id: str, _dry_run: bool = False, _client: Any = None) -> Iterator[bytes]:
         """
         Downloads the requested file
 
-        **Permission Required:** `kelvin.permission.filestorage.read`.
+        **Permission Required:** `kelvin.permission.filestorage.download`.
 
         ``downloadFile``: ``GET`` ``/api/v4/filestorage/{file_id}/download``
 
         Parameters
         ----------
         file_id : :obj:`str`, optional
             UUID of the desired file
```

## kelvin/api/client/api/instance.py

```diff
@@ -1,24 +1,24 @@
 """
 Kelvin API Client.
 """
 
 from __future__ import annotations
 
 from datetime import datetime
-from typing import Any, List, Mapping, Optional, Sequence, Union
+from typing import Any, List, Mapping, Optional, Sequence, Union, cast
 
 from typing_extensions import Literal
 
-from kelvin.api.client.data_model import DataModelBase
+from kelvin.api.client.api_service_model import ApiServiceModel
 
 from ..model import requests, responses, type
 
 
-class Instance(DataModelBase):
+class Instance(ApiServiceModel):
     @classmethod
     def list_instance_audit_logs(
         cls,
         action: Optional[Sequence[str]] = None,
         user_id: Optional[Sequence[str]] = None,
         namespace: Optional[Sequence[str]] = None,
         identifier: Optional[Sequence[str]] = None,
@@ -133,15 +133,22 @@
             None,
             None,
             False,
             {"200": responses.InstanceAuditLogsListPaginatedResponseCursor, "400": None, "401": None},
             False,
             _dry_run,
         )
-        return result.fetch("/api/v4/instance/auditlog/list", "GET") if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[responses.InstanceAuditLogGet], responses.InstanceAuditLogsListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/instance/auditlog/list", result, "GET"),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def get_instance_audit_log(
         cls, audit_logger_id: int, _dry_run: bool = False, _client: Any = None
     ) -> responses.InstanceAuditLogGet:
         """
         Get Audit Log
@@ -405,15 +412,22 @@
             None,
             None,
             False,
             {"200": responses.InstanceSettingsListPaginatedResponseCursor, "400": None, "401": None},
             False,
             _dry_run,
         )
-        return result.fetch("/api/v4/instance/settings/list", "GET") if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[type.InstanceSettings], responses.InstanceSettingsListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/instance/settings/list", result, "GET"),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def delete_instance_setting(cls, setting_name: str, _dry_run: bool = False, _client: Any = None) -> None:
         """
         Permanently delete an existing Instance Setting. This cannot be undone once the API request has been submitted.
 
         **Permission Required:** `kelvin.permission.instance.delete`.
```

## kelvin/api/client/api/orchestration.py

```diff
@@ -1,23 +1,23 @@
 """
 Kelvin API Client.
 """
 
 from __future__ import annotations
 
-from typing import Any, Iterator, List, Mapping, Optional, Sequence, Union
+from typing import Any, Iterator, List, Mapping, Optional, Sequence, Union, cast
 
 from typing_extensions import Literal
 
-from kelvin.api.client.data_model import DataModelBase
+from kelvin.api.client.api_service_model import ApiServiceModel
 
 from ..model import requests, responses
 
 
-class Orchestration(DataModelBase):
+class Orchestration(ApiServiceModel):
     @classmethod
     def create_orchestration_clusters(
         cls,
         data: Optional[Union[requests.OrchestrationClustersCreate, Mapping[str, Any]]] = None,
         _dry_run: bool = False,
         _client: Any = None,
         **kwargs: Any,
@@ -103,16 +103,16 @@
             Options are `k3s` and `kubernetes`
         ready : :obj:`bool`
             A filter on the list based on the Cluster key `ready`. Options are
             `true` and `false`
         status : :obj:`Sequence[str]`
             A filter on the list based on the Cluster key `status`. The filter is
             on the full name only. All strings in the array are treated as `OR`.
-            Options are `pending`, `online`, `unreachable` and
-            `requires_attention`
+            Options are `pending_provision`, `pending`, `online`, `unreachable`
+            and `requires_attention`
         pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
             Method of pagination to use for return results where `total_items` is
             greater than `page_size`. `cursor` and `limits` will return one `page`
             of results, `stream` will return all results. ('limits', 'cursor',
             'stream')
         page_size : :obj:`int`
             Number of objects to be returned in each page. Page size can range
@@ -161,15 +161,25 @@
             None,
             None,
             False,
             {"200": responses.OrchestrationClustersListPaginatedResponseCursor, "400": None, "401": None},
             False,
             _dry_run,
         )
-        return result.fetch("/api/v4/orchestration/clusters/list", "GET") if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[
+                    List[responses.OrchestrationClustersCreateItem],
+                    responses.OrchestrationClustersListPaginatedResponseCursor,
+                ],
+                cls.fetch(_client, "/api/v4/orchestration/clusters/list", result, "GET"),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def download_orchestration_cluster_provision_binary(
         cls, _dry_run: bool = False, _client: Any = None
     ) -> Iterator[bytes]:
         """
         Download Cluster Provision Binary
@@ -476,15 +486,21 @@
             None,
             False,
             {"200": responses.OrchestrationClustersNodeListPaginatedResponseCursor, "400": None, "401": None},
             False,
             _dry_run,
         )
         return (
-            result.fetch("/api/v4/orchestration/clusters/{cluster_name}/nodes/list", "GET")
+            cast(
+                Union[
+                    List[responses.OrchestrationClustersNodesGetItem],
+                    responses.OrchestrationClustersNodeListPaginatedResponseCursor,
+                ],
+                cls.fetch(_client, "/api/v4/orchestration/clusters/{cluster_name}/nodes/list", result, "GET"),
+            )
             if fetch and not _dry_run
             else result
         )
 
     @classmethod
     def get_orchestration_clusters_nodes(
         cls, cluster_name: str, node_name: str, _dry_run: bool = False, _client: Any = None
@@ -658,15 +674,18 @@
             None,
             False,
             {"200": responses.OrchestrationClustersServiceListPaginatedResponseCursor, "400": None, "401": None},
             False,
             _dry_run,
         )
         return (
-            result.fetch("/api/v4/orchestration/clusters/{cluster_name}/services/list", "GET")
+            cast(
+                Union[List[responses.ServiceItem], responses.OrchestrationClustersServiceListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/orchestration/clusters/{cluster_name}/services/list", result, "GET"),
+            )
             if fetch and not _dry_run
             else result
         )
 
     @classmethod
     def update_orchestration_clusters(
         cls,
```

## kelvin/api/client/api/parameters.py

```diff
@@ -1,23 +1,23 @@
 """
 Kelvin API Client.
 """
 
 from __future__ import annotations
 
-from typing import Any, List, Mapping, Optional, Sequence, Union
+from typing import Any, List, Mapping, Optional, Sequence, Union, cast
 
 from typing_extensions import Literal
 
-from kelvin.api.client.data_model import DataModelBase
+from kelvin.api.client.api_service_model import ApiServiceModel
 
 from ..model import requests, responses
 
 
-class Parameters(DataModelBase):
+class Parameters(ApiServiceModel):
     @classmethod
     def list_parameters_app_version_asset(
         cls,
         app_name: str,
         version: str,
         asset_name: str,
         search: Optional[Sequence[str]] = None,
@@ -107,15 +107,25 @@
                 "401": None,
                 "404": None,
             },
             False,
             _dry_run,
         )
         return (
-            result.fetch("/api/v4/parameters/app/{app_name}/versions/{version}/assets/{asset_name}/list", "GET")
+            cast(
+                Union[
+                    List[responses.ParameterValueItem], responses.ParametersAppVersionAssetListPaginatedResponseCursor
+                ],
+                cls.fetch(
+                    _client,
+                    "/api/v4/parameters/app/{app_name}/versions/{version}/assets/{asset_name}/list",
+                    result,
+                    "GET",
+                ),
+            )
             if fetch and not _dry_run
             else result
         )
 
     @classmethod
     def update_parameters(
         cls,
@@ -207,14 +217,68 @@
             {"200": responses.ParamtersAppVersionSchemaGet, "400": None, "401": None, "404": None},
             False,
             _dry_run,
         )
         return result
 
     @classmethod
+    def update_paramters_app_version(
+        cls,
+        app_name: str,
+        version: str,
+        data: Optional[Union[requests.ParamtersAppVersionUpdate, Mapping[str, Any]]] = None,
+        _dry_run: bool = False,
+        _client: Any = None,
+        **kwargs: Any,
+    ) -> None:
+        """
+        Bulk update Parameters for multiple resources of a given App Version.
+        Parameters belonging to the App Version but not specified in the payload
+        will **not** be changed. Setting a value to `null` will cause the parameter
+        to be unset.  Additionally, it's also possible to set a comment for each
+        parameter change.
+
+        The source of the change will, by default, be the user making the API
+        request. If the user making the request is a Service Account, it can,
+        optionally, set its own source KRN.
+
+        ``updateParamtersAppVersion``: ``POST`` ``/api/v4/parameters/app/{app_name}/versions/{version}/update``
+
+        Parameters
+        ----------
+        app_name : :obj:`str`, optional
+            App name
+        version : :obj:`str`, optional
+            App version
+        data: requests.ParamtersAppVersionUpdate, optional
+        **kwargs:
+            Extra parameters for requests.ParamtersAppVersionUpdate
+              - update_paramters_app_version: dict
+
+        """
+
+        result = cls._make_request(
+            _client,
+            "post",
+            "/api/v4/parameters/app/{app_name}/versions/{version}/update",
+            {"app_name": app_name, "version": version},
+            {},
+            {},
+            {},
+            data,
+            "requests.ParamtersAppVersionUpdate",
+            False,
+            {"200": None, "400": None, "401": None, "404": None},
+            False,
+            _dry_run,
+            kwargs,
+        )
+        return result
+
+    @classmethod
     def list_parameters_definitions(
         cls,
         pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
         page_size: Optional[int] = 10000,
         page: Optional[int] = None,
         next: Optional[str] = None,
         previous: Optional[str] = None,
@@ -285,38 +349,135 @@
             "requests.ParametersDefinitionsList",
             False,
             {"200": responses.ParametersDefinitionsListPaginatedResponseCursor, "400": None, "401": None, "404": None},
             False,
             _dry_run,
             kwargs,
         )
-        return result.fetch("/api/v4/parameters/definitions/list", "POST", data) if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[
+                    List[responses.ParameterDefinitionItem], responses.ParametersDefinitionsListPaginatedResponseCursor
+                ],
+                cls.fetch(_client, "/api/v4/parameters/definitions/list", result, "POST", data),
+            )
+            if fetch and not _dry_run
+            else result
+        )
+
+    @classmethod
+    def get_last_parameters_resources(
+        cls,
+        pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
+        page_size: Optional[int] = 10000,
+        page: Optional[int] = None,
+        next: Optional[str] = None,
+        previous: Optional[str] = None,
+        direction: Optional[Literal["asc", "desc"]] = None,
+        sort_by: Optional[Sequence[str]] = None,
+        data: Optional[Union[requests.LastParametersResourcesGet, Mapping[str, Any]]] = None,
+        fetch: bool = True,
+        _dry_run: bool = False,
+        _client: Any = None,
+        **kwargs: Any,
+    ) -> Union[List[responses.ParameterValueItem], responses.LastParametersResourcesGetPaginatedResponseCursor]:
+        """
+        Returns the current value of Parameters for each Resource. The list can be optionally filtered and sorted on the server before being returned.
+
+        **Permission Required:** `kelvin.permission.parameter.read`.
+
+        ``getLastParametersResources``: ``POST`` ``/api/v4/parameters/resources/last/get``
+
+        Parameters
+        ----------
+        pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
+            Method of pagination to use for return results where `total_items` is
+            greater than `page_size`. `cursor` and `limits` will return one `page`
+            of results, `stream` will return all results. ('limits', 'cursor',
+            'stream')
+        page_size : :obj:`int`
+            Number of objects to be returned in each page. Page size can range
+            between 1 and 1000 objects.
+        page : :obj:`int`
+            An integer for the wanted page of results. Used only with
+            `pagination_type` set as `limits`.
+        next : :obj:`str`
+            An alphanumeric string bookmark to indicate where to start for the
+            next page. Used only with `pagination_type` set as `cursor`.
+        previous : :obj:`str`
+            An alphanumeric string bookmark to indicate where to end for the
+            previous page. Used only with `pagination_type` set as `cursor`.
+        direction : :obj:`Literal['asc', 'desc']`
+            Sorting order according to the `sort_by` parameter. ('asc', 'desc')
+        sort_by : :obj:`Sequence[str]`
+            Sort the results by one or more enumerators.
+        data: requests.LastParametersResourcesGet, optional
+        **kwargs:
+            Extra parameters for requests.LastParametersResourcesGet
+              - get_last_parameters_resources: dict
+
+        """
+
+        from ..model import responses
+
+        result = cls._make_request(
+            _client,
+            "post",
+            "/api/v4/parameters/resources/last/get",
+            {},
+            {
+                "pagination_type": pagination_type,
+                "page_size": page_size,
+                "page": page,
+                "next": next,
+                "previous": previous,
+                "direction": direction,
+                "sort_by": sort_by,
+            },
+            {},
+            {},
+            data,
+            "requests.LastParametersResourcesGet",
+            False,
+            {"200": responses.LastParametersResourcesGetPaginatedResponseCursor, "400": None, "401": None, "404": None},
+            False,
+            _dry_run,
+            kwargs,
+        )
+        return (
+            cast(
+                Union[List[responses.ParameterValueItem], responses.LastParametersResourcesGetPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/parameters/resources/last/get", result, "POST", data),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
-    def list_parameters_resources(
+    def list_resource_parameters(
         cls,
         pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
         page_size: Optional[int] = 10000,
         page: Optional[int] = None,
         next: Optional[str] = None,
         previous: Optional[str] = None,
         direction: Optional[Literal["asc", "desc"]] = None,
         sort_by: Optional[Sequence[str]] = None,
-        data: Optional[Union[requests.ParametersResourcesList, Mapping[str, Any]]] = None,
+        data: Optional[Union[requests.ResourceParametersList, Mapping[str, Any]]] = None,
         fetch: bool = True,
         _dry_run: bool = False,
         _client: Any = None,
         **kwargs: Any,
-    ) -> Union[List[responses.ParameterValueItem], responses.ParametersResourcesListPaginatedResponseCursor]:
+    ) -> Union[List[responses.ParameterValueHistorianItem], responses.ResourceParametersListPaginatedResponseCursor]:
         """
-        Returns a list of Parameters and its current value for each Resource. The list can be optionally filtered and sorted on the server before being returned.
+        Returns a list of Parameters and all values for each Resource. The list can be optionally filtered and sorted on the server before being returned.
 
         **Permission Required:** `kelvin.permission.parameter.read`.
 
-        ``listParametersResources``: ``POST`` ``/api/v4/parameters/resources/list``
+        ``listResourceParameters``: ``POST`` ``/api/v4/parameters/resources/list``
 
         Parameters
         ----------
         pagination_type : :obj:`Literal['limits', 'cursor', 'stream']`
             Method of pagination to use for return results where `total_items` is
             greater than `page_size`. `cursor` and `limits` will return one `page`
             of results, `stream` will return all results. ('limits', 'cursor',
@@ -333,18 +494,18 @@
         previous : :obj:`str`
             An alphanumeric string bookmark to indicate where to end for the
             previous page. Used only with `pagination_type` set as `cursor`.
         direction : :obj:`Literal['asc', 'desc']`
             Sorting order according to the `sort_by` parameter. ('asc', 'desc')
         sort_by : :obj:`Sequence[str]`
             Sort the results by one or more enumerators.
-        data: requests.ParametersResourcesList, optional
+        data: requests.ResourceParametersList, optional
         **kwargs:
-            Extra parameters for requests.ParametersResourcesList
-              - list_parameters_resources: dict
+            Extra parameters for requests.ResourceParametersList
+              - list_resource_parameters: dict
 
         """
 
         from ..model import responses
 
         result = cls._make_request(
             _client,
@@ -359,22 +520,31 @@
                 "previous": previous,
                 "direction": direction,
                 "sort_by": sort_by,
             },
             {},
             {},
             data,
-            "requests.ParametersResourcesList",
+            "requests.ResourceParametersList",
             False,
-            {"200": responses.ParametersResourcesListPaginatedResponseCursor, "400": None, "401": None, "404": None},
+            {"200": responses.ResourceParametersListPaginatedResponseCursor, "400": None, "401": None, "404": None},
             False,
             _dry_run,
             kwargs,
         )
-        return result.fetch("/api/v4/parameters/resources/list", "POST", data) if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[
+                    List[responses.ParameterValueHistorianItem], responses.ResourceParametersListPaginatedResponseCursor
+                ],
+                cls.fetch(_client, "/api/v4/parameters/resources/list", result, "POST", data),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def get_parameters_values(
         cls,
         data: Optional[Union[requests.ParametersValuesGet, Mapping[str, Any]]] = None,
         _dry_run: bool = False,
         _client: Any = None,
```

## kelvin/api/client/api/recommendation.py

```diff
@@ -1,23 +1,23 @@
 """
 Kelvin API Client.
 """
 
 from __future__ import annotations
 
-from typing import Any, List, Mapping, Optional, Sequence, Union
+from typing import Any, List, Mapping, Optional, Sequence, Union, cast
 
 from typing_extensions import Literal
 
-from kelvin.api.client.data_model import DataModelBase
+from kelvin.api.client.api_service_model import ApiServiceModel
 
 from ..model import requests, responses, type
 
 
-class Recommendation(DataModelBase):
+class Recommendation(ApiServiceModel):
     @classmethod
     def get_recommendation_clustering(
         cls,
         data: Optional[Union[requests.RecommendationClusteringGet, Mapping[str, Any]]] = None,
         _dry_run: bool = False,
         _client: Any = None,
         **kwargs: Any,
@@ -176,15 +176,22 @@
             "requests.RecommendationLastGet",
             False,
             {"200": responses.RecommendationLastGetPaginatedResponseCursor, "400": None},
             False,
             _dry_run,
             kwargs,
         )
-        return result.fetch("/api/v4/recommendations/last/get", "POST", data) if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[type.Recommendation], responses.RecommendationLastGetPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/recommendations/last/get", result, "POST", data),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def list_recommendations(
         cls,
         pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
         page_size: Optional[int] = 10000,
         page: Optional[int] = None,
@@ -256,15 +263,22 @@
             "requests.RecommendationsList",
             False,
             {"200": responses.RecommendationsListPaginatedResponseCursor, "400": None},
             False,
             _dry_run,
             kwargs,
         )
-        return result.fetch("/api/v4/recommendations/list", "POST", data) if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[type.Recommendation], responses.RecommendationsListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/recommendations/list", result, "POST", data),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def get_recommendation_range(
         cls,
         pagination_type: Optional[Literal["limits", "cursor", "stream"]] = None,
         page_size: Optional[int] = 10000,
         page: Optional[int] = None,
@@ -336,15 +350,22 @@
             "requests.RecommendationRangeGet",
             False,
             {"200": responses.RecommendationRangeGetPaginatedResponseCursor, "400": None},
             False,
             _dry_run,
             kwargs,
         )
-        return result.fetch("/api/v4/recommendations/range/get", "POST", data) if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[type.Recommendation], responses.RecommendationRangeGetPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/recommendations/range/get", result, "POST", data),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def create_recommendation_type(
         cls,
         data: Optional[Union[requests.RecommendationTypeCreate, Mapping[str, Any]]] = None,
         _dry_run: bool = False,
         _client: Any = None,
@@ -458,15 +479,22 @@
             None,
             None,
             False,
             {"200": responses.RecommendationTypesListPaginatedCursor, "400": None, "401": None},
             False,
             _dry_run,
         )
-        return result.fetch("/api/v4/recommendations/types/list", "GET") if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[type.RecommendationType], responses.RecommendationTypesListPaginatedCursor],
+                cls.fetch(_client, "/api/v4/recommendations/types/list", result, "GET"),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def delete_recommendation_type(cls, name: str, _dry_run: bool = False, _client: Any = None) -> None:
         """
         Permanently delete an existing Recommendation Type. An error will be returned if there are any current Recommendations linked to the Recommendation Type. This cannot be undone once the API request has been submitted.
 
         **Permission Required:** `kelvin.permission.recommendation.delete`.
```

## kelvin/api/client/api/secret.py

```diff
@@ -1,23 +1,23 @@
 """
 Kelvin API Client.
 """
 
 from __future__ import annotations
 
-from typing import Any, List, Mapping, Optional, Sequence, Union
+from typing import Any, List, Mapping, Optional, Sequence, Union, cast
 
 from typing_extensions import Literal
 
-from kelvin.api.client.data_model import DataModelBase
+from kelvin.api.client.api_service_model import ApiServiceModel
 
 from ..model import requests, responses
 
 
-class Secret(DataModelBase):
+class Secret(ApiServiceModel):
     @classmethod
     def create_secret(
         cls,
         data: Optional[Union[requests.SecretCreate, Mapping[str, Any]]] = None,
         _dry_run: bool = False,
         _client: Any = None,
         **kwargs: Any,
@@ -132,15 +132,22 @@
             None,
             None,
             False,
             {"200": responses.SecretsListPaginatedResponseCursor, "400": None, "401": None},
             False,
             _dry_run,
         )
-        return result.fetch("/api/v4/secrets/list", "GET") if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[responses.SecretItem], responses.SecretsListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/secrets/list", result, "GET"),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def delete_secret(cls, secret_name: str, _dry_run: bool = False, _client: Any = None) -> None:
         """
         Permanently delete a Secret. This cannot be undone once the API request has been submitted.
 
         **Permission Required:** `kelvin.permission.secret.delete`.
```

## kelvin/api/client/api/thread.py

```diff
@@ -1,23 +1,23 @@
 """
 Kelvin API Client.
 """
 
 from __future__ import annotations
 
-from typing import Any, Mapping, Optional, Union
+from typing import Any, Mapping, Optional, Union, cast
 
 from typing_extensions import Literal
 
-from kelvin.api.client.data_model import DataModelBase
+from kelvin.api.client.api_service_model import ApiServiceModel
 
 from ..model import requests, responses
 
 
-class Thread(DataModelBase):
+class Thread(ApiServiceModel):
     @classmethod
     def create_thread(
         cls,
         data: Optional[Union[requests.ThreadCreate, Mapping[str, Any]]] = None,
         _dry_run: bool = False,
         _client: Any = None,
         **kwargs: Any,
```

## kelvin/api/client/api/timeseries.py

```diff
@@ -1,23 +1,23 @@
 """
 Kelvin API Client.
 """
 
 from __future__ import annotations
 
-from typing import Any, Iterator, List, Mapping, Optional, Sequence, Union
+from typing import Any, Iterator, List, Mapping, Optional, Sequence, Union, cast
 
 from typing_extensions import Literal
 
-from kelvin.api.client.data_model import DataModelBase
+from kelvin.api.client.api_service_model import ApiServiceModel
 
 from ..model import requests, responses, type
 
 
-class Timeseries(DataModelBase):
+class Timeseries(ApiServiceModel):
     @classmethod
     def create_timeseries(
         cls,
         publish: Optional[bool] = None,
         data: Optional[Union[requests.TimeseriesCreate, Mapping[str, Any]]] = None,
         _dry_run: bool = False,
         _client: Any = None,
@@ -180,15 +180,22 @@
             "requests.TimeseriesList",
             False,
             {"200": responses.TimeseriesListPaginatedResponseCursor, "400": None, "401": None},
             False,
             _dry_run,
             kwargs,
         )
-        return result.fetch("/api/v4/timeseries/list", "POST", data) if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[type.TimeseriesData], responses.TimeseriesListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/timeseries/list", result, "POST", data),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def download_timeseries_range(
         cls,
         data: Optional[Union[requests.TimeseriesRangeDownload, Mapping[str, Any]]] = None,
         _dry_run: bool = False,
         _client: Any = None,
```

## kelvin/api/client/api/user.py

```diff
@@ -1,23 +1,23 @@
 """
 Kelvin API Client.
 """
 
 from __future__ import annotations
 
-from typing import Any, List, Mapping, Optional, Sequence, Union
+from typing import Any, List, Mapping, Optional, Sequence, Union, cast
 
 from typing_extensions import Literal
 
-from kelvin.api.client.data_model import DataModelBase
+from kelvin.api.client.api_service_model import ApiServiceModel
 
 from ..model import requests, responses, type
 
 
-class User(DataModelBase):
+class User(ApiServiceModel):
     @classmethod
     def list_users(
         cls,
         username: Optional[Sequence[str]] = None,
         email: Optional[Sequence[str]] = None,
         name: Optional[Sequence[str]] = None,
         search: Optional[Sequence[str]] = None,
@@ -105,15 +105,22 @@
             None,
             None,
             False,
             {"200": responses.UsersListPaginatedResponseCursor, "400": None, "401": None},
             False,
             _dry_run,
         )
-        return result.fetch("/api/v4/users/list", "GET") if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[responses.UserItem], responses.UsersListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/users/list", result, "GET"),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def get_user_me(cls, _dry_run: bool = False, _client: Any = None) -> responses.UserMeGet:
         """
         Get Current User
 
         **Permission Required:** `n/a`.
@@ -218,15 +225,22 @@
             None,
             None,
             False,
             {"200": responses.UserSettingsListPaginatedResponseCursor, "400": None, "401": None},
             False,
             _dry_run,
         )
-        return result.fetch("/api/v4/users/settings/list", "GET") if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[type.UserSetting], responses.UserSettingsListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/users/settings/list", result, "GET"),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def delete_user_settings(cls, setting_name: str, _dry_run: bool = False, _client: Any = None) -> None:
         """
         Permanently delete an existing User Setting. This cannot be undone once the API request has been submitted.
 
         **Permission Required:** `kelvin.permission.users.delete`.
```

## kelvin/api/client/api/workload.py

```diff
@@ -1,24 +1,24 @@
 """
 Kelvin API Client.
 """
 
 from __future__ import annotations
 
 from datetime import datetime
-from typing import Any, List, Mapping, Optional, Sequence, Union
+from typing import Any, List, Mapping, Optional, Sequence, Union, cast
 
 from typing_extensions import Literal
 
-from kelvin.api.client.data_model import DataModelBase
+from kelvin.api.client.api_service_model import ApiServiceModel
 
 from ..model import requests, responses
 
 
-class Workload(DataModelBase):
+class Workload(ApiServiceModel):
     @classmethod
     def deploy_workload(
         cls,
         data: Optional[Union[requests.WorkloadDeploy, Mapping[str, Any]]] = None,
         _dry_run: bool = False,
         _client: Any = None,
         **kwargs: Any,
@@ -182,15 +182,22 @@
             None,
             None,
             False,
             {"200": responses.WorkloadsListPaginatedResponseCursor, "400": None, "401": None},
             False,
             _dry_run,
         )
-        return result.fetch("/api/v4/workloads/list", "GET") if fetch and not _dry_run else result
+        return (
+            cast(
+                Union[List[responses.WorkloadItem], responses.WorkloadsListPaginatedResponseCursor],
+                cls.fetch(_client, "/api/v4/workloads/list", result, "GET"),
+            )
+            if fetch and not _dry_run
+            else result
+        )
 
     @classmethod
     def apply_workload(cls, workload_name: str, _dry_run: bool = False, _client: Any = None) -> None:
         """
         Initiate final deploy action for downloaded Workload. Only valid for Workload that were previously deployed with the keys `pre_download` set to true and `instantly_apply` set to false.
 
         **Permission Required:** `kelvin.permission.workload.update`.
@@ -218,14 +225,100 @@
             {"200": None, "400": None, "401": None, "404": None, "406": None},
             False,
             _dry_run,
         )
         return result
 
     @classmethod
+    def get_workload_configuration(
+        cls, workload_name: str, _dry_run: bool = False, _client: Any = None
+    ) -> responses.WorkloadConfigurationGet:
+        """
+        Retrieve the configuration of a Workload.
+
+        **Permission Required:** `kelvin.permission.workload.read`.
+
+        ``getWorkloadConfiguration``: ``GET`` ``/api/v4/workloads/{workload_name}/configurations/get``
+
+        Parameters
+        ----------
+        workload_name : :obj:`str`, optional
+            Unique identifier `name` of the Workload.
+
+        """
+
+        from ..model import responses
+
+        result = cls._make_request(
+            _client,
+            "get",
+            "/api/v4/workloads/{workload_name}/configurations/get",
+            {"workload_name": workload_name},
+            {},
+            {},
+            {},
+            None,
+            None,
+            False,
+            {"200": responses.WorkloadConfigurationGet, "400": None, "401": None, "404": None, "500": None},
+            False,
+            _dry_run,
+        )
+        return result
+
+    @classmethod
+    def update_workload_configuration(
+        cls,
+        workload_name: str,
+        data: Optional[Union[requests.WorkloadConfigurationUpdate, Mapping[str, Any]]] = None,
+        _dry_run: bool = False,
+        _client: Any = None,
+        **kwargs: Any,
+    ) -> responses.WorkloadConfigurationUpdate:
+        """
+        Update the configuration of a Workload.
+
+        **Permission Required:** `kelvin.permission.workload.update`
+
+        **`WARNING!!`: Sending an empty configuration object will remove all configurations**.
+
+        ``updateWorkloadConfiguration``: ``POST`` ``/api/v4/workloads/{workload_name}/configurations/update``
+
+        Parameters
+        ----------
+        workload_name : :obj:`str`, optional
+            Unique identifier `name` of the Workload.
+        data: requests.WorkloadConfigurationUpdate, optional
+        **kwargs:
+            Extra parameters for requests.WorkloadConfigurationUpdate
+              - update_workload_configuration: dict
+
+        """
+
+        from ..model import responses
+
+        result = cls._make_request(
+            _client,
+            "post",
+            "/api/v4/workloads/{workload_name}/configurations/update",
+            {"workload_name": workload_name},
+            {},
+            {},
+            {},
+            data,
+            "requests.WorkloadConfigurationUpdate",
+            False,
+            {"200": responses.WorkloadConfigurationUpdate, "400": None, "401": None, "404": None, "500": None},
+            False,
+            _dry_run,
+            kwargs,
+        )
+        return result
+
+    @classmethod
     def download_workload(cls, workload_name: str, _dry_run: bool = False, _client: Any = None) -> str:
         """
         Download the Workload package file for offline installation on the Edge System. The system automatically generates the file for download if the package is not already available.
 
         **Permission Required:** `kelvin.permission.workload.read`.
 
         ``downloadWorkload``: ``GET`` ``/api/v4/workloads/{workload_name}/download``
```

## kelvin/api/client/model/__init__.py

```diff
@@ -1,3 +1,3 @@
 # generated by datamodel-codegen:
 #   filename:  openapi.json
-#   timestamp: 2024-04-08T09:50:50+00:00
+#   timestamp: 2024-04-24T09:43:45+00:00
```

## kelvin/api/client/model/enum.py

```diff
@@ -1,43 +1,70 @@
 # generated by datamodel-codegen:
 #   filename:  openapi.json
-#   timestamp: 2024-04-08T09:50:50+00:00
+#   timestamp: 2024-04-24T09:43:45+00:00
 
 from __future__ import annotations
 
 from enum import Enum
 
 
-class DataTypeName(Enum):
+class AppManagerAppStatus(Enum):
+    running = "running"
+    stopped = "stopped"
+    updating = "updating"
+    requires_attention = "requires_attention"
+
+
+class DataType(Enum):
     boolean = "boolean"
     number = "number"
     object = "object"
     string = "string"
 
 
 class AppType(Enum):
     kelvin = "kelvin"
     docker = "docker"
     bridge = "bridge"
 
 
-class PropertyTypeName(Enum):
+class AssetState(Enum):
+    online = "online"
+    offline = "offline"
+    unknown = "unknown"
+
+
+class PropertyType(Enum):
     boolean = "boolean"
     number = "number"
     string = "string"
     timestamp = "timestamp"
 
 
 class ControlChangeState(Enum):
     pending = "pending"
+    ready = "ready"
     sent = "sent"
+    processed = "processed"
     applied = "applied"
     failed = "failed"
 
 
+class ParameterType(Enum):
+    raw_boolean = "raw.boolean"
+    raw_float32 = "raw.float32"
+    raw_float64 = "raw.float64"
+    raw_int32 = "raw.int32"
+    raw_uint32 = "raw.uint32"
+    raw_text = "raw.text"
+    number = "number"
+    string = "string"
+    boolean = "boolean"
+
+
 class RecommendationState(Enum):
     pending = "pending"
     accepted = "accepted"
     auto_accepted = "auto_accepted"
     rejected = "rejected"
     expired = "expired"
     error = "error"
@@ -66,17 +93,26 @@
 
 
 class ClusterType(Enum):
     k3s = "k3s"
     kubernetes = "kubernetes"
 
 
-class ParameterTypeName(Enum):
-    raw_boolean = "raw.boolean"
-    raw_float32 = "raw.float32"
-    raw_float64 = "raw.float64"
-    raw_int32 = "raw.int32"
-    raw_uint32 = "raw.uint32"
-    raw_text = "raw.text"
-    number = "number"
-    string = "string"
-    boolean = "boolean"
+class OrchestrationClusterStatus(Enum):
+    pending_provision = "pending_provision"
+    pending = "pending"
+    online = "online"
+    unreachable = "unreachable"
+    requires_attention = "requires_attention"
+
+
+class OrchestrationNodeStatus(Enum):
+    online = "online"
+    unreachable = "unreachable"
+    not_ready = "not_ready"
+
+
+class WorkloadDownloadStatus(Enum):
+    pending = "pending"
+    processing = "processing"
+    ready = "ready"
+    downloading = "downloading"
```

## kelvin/api/client/model/pagination.py

```diff
@@ -1,10 +1,10 @@
 # generated by datamodel-codegen:
 #   filename:  openapi.json
-#   timestamp: 2024-04-08T09:50:50+00:00
+#   timestamp: 2024-04-24T09:43:45+00:00
 
 from __future__ import annotations
 
 from typing import Optional
 
 from pydantic import Field
```

## kelvin/api/client/model/requests.py

```diff
@@ -1,10 +1,10 @@
 # generated by datamodel-codegen:
 #   filename:  openapi.json
-#   timestamp: 2024-04-08T09:50:50+00:00
+#   timestamp: 2024-04-24T09:43:45+00:00
 
 from __future__ import annotations
 
 from datetime import datetime
 from enum import Enum
 from typing import Any, Dict, List, Optional
 from uuid import UUID
@@ -37,31 +37,24 @@
     __root__: str = Field(..., max_length=256, min_length=1)
 
     """
 
     __root__: str = Field(..., max_length=256, min_length=1)
 
 
-class Status(Enum):
-    running = "running"
-    stopped = "stopped"
-    updating = "updating"
-    requires_attention = "requires_attention"
-
-
 class AppManagerAppResourcesList(DataModelBase):
     """
     AppManagerAppResourcesList object.
 
     Parameters
     ----------
     app_versions: Optional[List[str]]
     enabled_states: Optional[List[bool]]
     resources: Optional[List[Resource]]
-    statuses: Optional[List[Status]]
+    statuses: Optional[List[enum.AppManagerAppStatus]]
 
     """
 
     app_versions: Optional[List[str]] = Field(
         None,
         description="Search and filter on the list based on the Application versions. All strings in the array are treated as `OR`. ",
         example=["1.0.1", "1.0.2"],
@@ -72,15 +65,15 @@
         example=[True],
     )
     resources: Optional[List[Resource]] = Field(
         None,
         description="A filter on the list showing only Applications associated with any Assets in the array. The filter is on the full name only. All strings in the array are treated as `OR`. Each Asset name can only contain lowercase alphanumeric characters and `.`, `_` or `-` characters.",
         example=["krn:asset:beam_pump_16", "krn:asset:beam_pump_21"],
     )
-    statuses: Optional[List[Status]] = Field(
+    statuses: Optional[List[enum.AppManagerAppStatus]] = Field(
         None,
         description="Search and filter on the list based on the key 'status'. All strings in the array are treated as `OR`. ",
         example=["running", "updating"],
     )
 
 
 class AppManagerAppVersionDataMappingGet(DataModelBase):
@@ -213,15 +206,15 @@
     AppManagerList object.
 
     Parameters
     ----------
     app_names: Optional[List[AppName]]
     resources: Optional[List[Resource]]
     search: Optional[str]
-    statuses: Optional[List[Status]]
+    statuses: Optional[List[enum.AppManagerAppStatus]]
 
     """
 
     app_names: Optional[List[AppName]] = Field(
         None,
         description="A filter on the list based on the Application key `name`. The filter is on the full name only. All strings in the array are treated as `OR`. Can only contain lowercase alphanumeric characters and `.`, `_` or `-` characters.",
         example=["motor-speed-control", "load-control-app"],
@@ -234,15 +227,15 @@
     search: Optional[str] = Field(
         None,
         description="Search and filter on the list based on the Application keys `title` (Display Name) or `name`. The search is case insensitive and will find partial matches as well.",
         example="Optimizer",
         max_length=64,
         min_length=1,
     )
-    statuses: Optional[List[Status]] = Field(
+    statuses: Optional[List[enum.AppManagerAppStatus]] = Field(
         None,
         description="Search and filter on the list based on the key 'status'. All strings in the array are treated as `OR`.",
         example=["running", "updating"],
     )
 
 
 class AppCreate(DataModelBase):
@@ -283,14 +276,21 @@
         description="New display name (`title`) of the App in the App Registry.",
         example="Motor Speed Control",
         max_length=64,
         min_length=1,
     )
 
 
+class Status(Enum):
+    running = "running"
+    stopped = "stopped"
+    updating = "updating"
+    requires_attention = "requires_attention"
+
+
 class AppExtraField(DataModelBase):
     """
     AppExtraField object.
 
     Parameters
     ----------
     app_name: Optional[str]
@@ -336,37 +336,37 @@
 class AssetInsightsFilter(DataModelBase):
     """
     AssetInsightsFilter object.
 
     Parameters
     ----------
     operator: Optional[Operator]
-    value: Optional[type.AnyModel]
+    value: Optional[Any]
 
     """
 
     operator: Optional[Operator] = Field(
         None,
         description="Type of operation for the filter, allowed operators: '==', '!=', '<', '>', '>=', '<='",
         example="==",
     )
-    value: Optional[type.AnyModel] = Field(
+    value: Optional[Any] = Field(
         None, description="Value to use in association with the `operator` for the filter of the field.", example=500
     )
 
 
 class AssetPropertyExtraField(DataModelBase):
     """
     AssetPropertyExtraField object.
 
     Parameters
     ----------
     filters: Optional[List[AssetInsightsFilter]]
     name: Optional[str]
-    primitive_type: Optional[enum.PropertyTypeName]
+    primitive_type: Optional[enum.PropertyType]
     property_name: Optional[str]
 
     """
 
     filters: Optional[List[AssetInsightsFilter]] = Field(
         None,
         description="Optional to filter the returned Asset List based on an array of operator / value criteria relating to the Asset Property. Each filter is treated as `OR`. This will remove Assets from the returned Asset list that do not meet this criteria.",
@@ -374,15 +374,15 @@
     name: Optional[str] = Field(
         None,
         description="Unique identifier name for the key in the response, all keys in extra_fields object must be unique. Must contain only lowercase alphanumeric characters. The `.`, `_`, and `-` characters are allowed to separate words but cannot be at the beginning or end of the name.",
         example="motor-speed",
         max_length=64,
         min_length=1,
     )
-    primitive_type: Optional[enum.PropertyTypeName] = Field(
+    primitive_type: Optional[enum.PropertyType] = Field(
         None, description="Property data type of the new filtered Asset Property column."
     )
     property_name: Optional[str] = Field(
         None,
         description="Name of the Asset Property to include. This Asset Property column are custom filtered fields that can be created with the Asset listing.",
         example="motor-speed-control",
         max_length=64,
@@ -494,37 +494,25 @@
         description="Unique identifier name for the key in the response, all keys in extra_fields object must be unique. Must contain only lowercase alphanumeric characters. The `.`, `_`, and `-` characters are allowed to separate words but cannot be at the beginning or end of the name.",
         example="motor-speed-count",
         max_length=64,
         min_length=1,
     )
 
 
-class PrimitiveType(Enum):
-    raw_boolean = "raw.boolean"
-    boolean = "boolean"
-    raw_text = "raw.text"
-    string = "string"
-    raw_float32 = "raw.float32"
-    raw_float64 = "raw.float64"
-    raw_int32 = "raw.int32"
-    raw_uint32 = "raw.uint32"
-    number = "number"
-
-
 class ParameterExtraField(DataModelBase):
     """
     ParameterExtraField object.
 
     Parameters
     ----------
     app_name: Optional[str]
     filters: Optional[List[AssetInsightsFilter]]
     name: Optional[str]
     parameter_name: Optional[str]
-    primitive_type: Optional[PrimitiveType]
+    primitive_type: Optional[enum.ParameterType]
 
     """
 
     app_name: Optional[str] = Field(
         None,
         description="App Registry App key `name` to retrieve the Parameters. The string can only contain lowercase alphanumeric characters and `.`, `_` or `-` characters.",
         example="motor-speed-control",
@@ -545,17 +533,15 @@
     parameter_name: Optional[str] = Field(
         None,
         description="Parameter key `name` to retrieve the Parameters from the App for the Assets. The string can only contain lowercase alphanumeric characters and `.`, `_` or `-` characters.",
         example="motor-speed-set-point",
         max_length=64,
         min_length=1,
     )
-    primitive_type: Optional[PrimitiveType] = Field(
-        None, description="Primitive data type of the new filtered Parameter column.", example="number"
-    )
+    primitive_type: Optional[enum.ParameterType] = None
 
 
 class Type(BaseModelRoot[str]):
     """
     Type object.
 
     Parameters
@@ -692,20 +678,14 @@
     __root__: str = Field(..., max_length=64, min_length=1)
 
     """
 
     __root__: str = Field(..., max_length=64, min_length=1)
 
 
-class AssetState(Enum):
-    online = "online"
-    offline = "offline"
-    unknown = "unknown"
-
-
 class AssetType(BaseModelRoot[str]):
     """
     AssetType object.
 
     Parameters
     ----------
     __root__: str = Field(..., max_length=64, min_length=1)
@@ -744,30 +724,30 @@
 class AssetInsightsGet(DataModelBase):
     """
     AssetInsightsGet object.
 
     Parameters
     ----------
     asset_names: Optional[List[AssetName]]
-    asset_states: Optional[List[AssetState]]
+    asset_states: Optional[List[enum.AssetState]]
     asset_types: Optional[List[AssetType]]
     extra_fields: Optional[AssetInsightsExtraFields]
     force_parameters_refresh: Optional[bool]
     pinned_assets: Optional[List[PinnedAsset]]
     search: Optional[List[SearchItem]]
     sort_by: Optional[List[AssetInsightsSortBy]]
 
     """
 
     asset_names: Optional[List[AssetName]] = Field(
         None,
         description="Filter on the Asset parameter `name`. The filter is on the full name only. All strings in the array are treated as `OR`. Can only contain lowercase alphanumeric characters and `.`, `_` or `-` characters.",
         example=["beam", "MOTOR"],
     )
-    asset_states: Optional[List[AssetState]] = Field(
+    asset_states: Optional[List[enum.AssetState]] = Field(
         None,
         description="Filter by the asset `state`. The filter is on the full name only. All strings in the array are treated as `OR`.",
         example=["offline", "unknown"],
     )
     asset_types: Optional[List[AssetType]] = Field(
         None,
         description="Filter on the Asset Type parameter `name`. The filter is on the full name only. All strings in the array are treated as `OR`. Can only contain lowercase alphanumeric characters and `.`, `_` or `-` characters.",
@@ -794,15 +774,15 @@
     """
     AssetPropertyCreate object.
 
     Parameters
     ----------
     name: str
     title: Optional[str]
-    value: type.AnyModel
+    value: Any
 
     """
 
     name: str = Field(
         ...,
         description="Unique identifier `name` for the Asset Property. The string can only contain lowercase alphanumeric characters and `.`, `_` or `-` characters.",
         example="water-line-pressure",
@@ -812,15 +792,15 @@
     title: Optional[str] = Field(
         None,
         description="Title for this property. This title is ignored if the property with this `name` already exists.",
         example="Water Line Pressure",
         max_length=64,
         min_length=1,
     )
-    value: type.AnyModel = Field(
+    value: Any = Field(
         ..., description="Value for this Asset Property. This can be stored as a number, string or boolean."
     )
 
 
 class AssetCreate(DataModelBase):
     """
     AssetCreate object.
@@ -879,30 +859,24 @@
     __root__: str = Field(..., max_length=64, min_length=1)
 
     """
 
     __root__: str = Field(..., max_length=64, min_length=1)
 
 
-class StatusStateEnum(Enum):
-    online = "online"
-    offline = "offline"
-    unknown = "unknown"
-
-
 class AssetsAdvancedList(DataModelBase):
     """
     AssetsAdvancedList object.
 
     Parameters
     ----------
     asset_type_name: Optional[List[str]]
     names: Optional[List[Name]]
     search: Optional[List[SearchItem]]
-    status_state: Optional[List[StatusStateEnum]]
+    status_state: Optional[List[enum.AssetState]]
 
     """
 
     asset_type_name: Optional[List[str]] = Field(
         None,
         description="A filter on the list based on the key `asset_type_name`. The filter is on the full name only. All strings in the array are treated as `OR`. The string can only contain lowercase alphanumeric characters and `.`, `_` or `-` characters.",
         example=["beam_pump", "progressive_cavity_pump"],
@@ -913,59 +887,59 @@
         example=["well_1", "well_5"],
     )
     search: Optional[List[SearchItem]] = Field(
         None,
         description="Search and filter on the list based on the keys `title` (Display Name) or `name`. All strings in the array are treated as `OR`. The search is case insensitive and will find partial matches as well.",
         example=["well_1", "Well 3"],
     )
-    status_state: Optional[List[StatusStateEnum]] = Field(
+    status_state: Optional[List[enum.AssetState]] = Field(
         None,
         description="A filter on the list based on the key ['status']['state']. Multiple statuses can be given and will be filtered as `OR`.",
         example=["online"],
     )
 
 
 class AssetPropertyDefinitionsList(DataModelBase):
     """
     AssetPropertyDefinitionsList object.
 
     Parameters
     ----------
     names: Optional[List[Name]]
-    primitive_types: Optional[List[enum.PropertyTypeName]]
+    primitive_types: Optional[List[enum.PropertyType]]
     search: Optional[List[str]]
 
     """
 
     names: Optional[List[Name]] = Field(
         None,
         description="A filter on the list based on the key `name`. The filter is on the full name only. All strings in the array are treated as `OR`. The string can only contain lowercase alphanumeric characters and `.`, `_` or `-` characters.",
         example=["production_casing_depth", "rp-property"],
     )
-    primitive_types: Optional[List[enum.PropertyTypeName]] = Field(
+    primitive_types: Optional[List[enum.PropertyType]] = Field(
         None, description="A filter on the list based on the key `primitive_type`.", example=["number", "boolean"]
     )
     search: Optional[List[str]] = Field(
         None,
         description="Search and filter on the list based on the keys `title` (Display Name) or `name`. All strings in the array are treated as `OR`. The search is case insensitive and will find partial matches as well.",
     )
 
 
 class AssetPropertyValuesGet(DataModelBase):
     """
     AssetPropertyValuesGet object.
 
     Parameters
     ----------
-    primitive_types: Optional[List[enum.PropertyTypeName]]
+    primitive_types: Optional[List[enum.PropertyType]]
     property_names: Optional[List[str]]
 
     """
 
-    primitive_types: Optional[List[enum.PropertyTypeName]] = Field(
+    primitive_types: Optional[List[enum.PropertyType]] = Field(
         None, description="A filter on the list based on the key `primitive_type`.", example=["number", "boolean"]
     )
     property_names: Optional[List[str]] = Field(
         None,
         description="A filter on the list based on the key `name`. The filter is on the full name only. All strings in the array are treated as `OR`. The string can only contain lowercase alphanumeric characters and `.`, `_` or `-` characters.",
         example=["production_casing_depth", "rp-property"],
     )
@@ -1169,34 +1143,26 @@
     __root__: str = Field(..., max_length=256, min_length=1)
 
     """
 
     __root__: str = Field(..., max_length=256, min_length=1)
 
 
-class TimeBucket(Enum):
-    ns = "ns"
-    ms = "ms"
-    s = "s"
-    m = "m"
-    h = "h"
-
-
 class ControlChangeClusteringGet(DataModelBase):
     """
     ControlChangeClusteringGet object.
 
     Parameters
     ----------
     end_date: datetime
     resources: Optional[List[Resource]]
     sources: Optional[List[Source]]
     start_date: datetime
     states: Optional[List[enum.ControlChangeState]]
-    time_bucket: TimeBucket
+    time_bucket: str
 
     """
 
     end_date: datetime = Field(
         ...,
         description="Most recent (end) creation time for counting the number of Control Changes. Time is based on UTC timezone, formatted in RFC 3339.",
         example="2023-11-18T18:22:18.582724Z",
@@ -1217,39 +1183,41 @@
         example="2023-11-18T18:22:18.582724Z",
     )
     states: Optional[List[enum.ControlChangeState]] = Field(
         None,
         description="Filter to only count Control Changes associated with one or more `states`. The filter is on the full `state` name only. All strings in the array are treated as `OR`.",
         example=["sent", "applied"],
     )
-    time_bucket: TimeBucket = Field(
+    time_bucket: str = Field(
         ..., description="Defines the time range to use to group and count the Control Changes.", example="5m"
     )
 
 
 class ControlChangeCreate(DataModelBase):
     """
     ControlChangeCreate object.
 
     Parameters
     ----------
     expiration_date: datetime
-    payload: type.AnyModel
+    from_: Optional[type.ControlChangeFrom]
+    payload: Any
     resource: str
     retries: Optional[int]
     timeout: Optional[int]
 
     """
 
     expiration_date: datetime = Field(
         ...,
         description="UTC time when the Control Change will expire and the `status` automatically marked as `failed`, formatted in RFC 3339.",
         example="2023-11-18T18:22:18.582724Z",
     )
-    payload: type.AnyModel = Field(
+    from_: Optional[type.ControlChangeFrom] = Field(None, alias="from")
+    payload: Any = Field(
         ...,
         description="The new value payload to be applied to the Asset / Data Stream pair in `resource`.",
         example=2000,
     )
     resource: str = Field(
         ...,
         description="The asset / data stream pair that this Control Change will be applied to.",
@@ -1506,15 +1474,15 @@
     """
     DataStreamCreate object.
 
     Parameters
     ----------
     description: Optional[str]
     name: str
-    data_type_name: enum.DataTypeName
+    data_type_name: enum.DataType
     semantic_type_name: Optional[str]
     title: str
     type: TypeModel
     unit_name: Optional[str]
 
     """
 
@@ -1528,15 +1496,15 @@
     name: str = Field(
         ...,
         description="Unique identifier `name` for the new Data Stream. Can only contain lowercase alphanumeric characters and `.`, `_` or `-` characters.",
         example="gas_flow_rate",
         max_length=64,
         min_length=1,
     )
-    data_type_name: enum.DataTypeName = Field(..., description="Data type of the new Data Stream.")
+    data_type_name: enum.DataType = Field(..., description="Data type of the new Data Stream.")
     semantic_type_name: Optional[str] = Field(
         None,
         description="Unique identifier `name` of the Semantic Type that describes the nature, purpose or origin of the data.",
         example="volume_flow_rate",
         max_length=64,
         min_length=1,
     )
@@ -1862,17 +1830,17 @@
     __root__: str = Field(..., max_length=64, min_length=1)
 
     """
 
     __root__: str = Field(..., max_length=64, min_length=1)
 
 
-class DataTagsList(DataModelBase):
+class DataTagList(DataModelBase):
     """
-    DataTagsList object.
+    DataTagList object.
 
     Parameters
     ----------
     ids: Optional[List[UUID]]
     search: Optional[List[SearchItem]]
     tag_names: Optional[List[TagName]]
     resources: Optional[List[Resource]]
@@ -2291,15 +2259,15 @@
     """
     ParameterValueUpdate object.
 
     Parameters
     ----------
     comment: Optional[str]
     name: str
-    value: type.AnyModel
+    value: Any
 
     """
 
     comment: Optional[str] = Field(
         None,
         description="Any comments about the updates to the Parameter value.",
         example="Updating parameter for well operational optimization.",
@@ -2309,15 +2277,15 @@
     name: str = Field(
         ...,
         description="Unique identifier name for this Parameter.",
         example="gas_flow_rate_max_threshold",
         max_length=64,
         min_length=1,
     )
-    value: type.AnyModel = Field(
+    value: Any = Field(
         ...,
         description="New value for this parameter. The format of the value expected will depend on its Primitive Type.",
         example=160,
     )
 
 
 class ParametersUpdate(DataModelBase):
@@ -2386,40 +2354,33 @@
     __root__: str = Field(..., example='gas_flow_rate_max_threshold', max_length=64, min_length=1)
 
     """
 
     __root__: str = Field(..., example="gas_flow_rate_max_threshold", max_length=64, min_length=1)
 
 
-class PrimitiveTypeModel(Enum):
-    boolean = "boolean"
-    number = "number"
-    object = "object"
-    string = "string"
-
-
 class ParametersDefinitionsList(DataModelBase):
     """
     ParametersDefinitionsList object.
 
     Parameters
     ----------
     app_names: Optional[List[AppNameModel]]
     names: Optional[List[NameModel3]]
-    primitive_types: Optional[List[PrimitiveTypeModel]]
+    primitive_types: Optional[List[enum.ParameterType]]
     search: Optional[List[SearchItem]]
 
     """
 
     app_names: Optional[List[AppNameModel]] = Field(
         None,
         description="A filter on the list based on the key `app_name`. The filter is on the full name only. The string can only contain lowercase alphanumeric characters and `.`, `_` or `-` characters.",
     )
     names: Optional[List[NameModel3]] = Field(None, description="Unique identifier name for this Parameter.")
-    primitive_types: Optional[List[PrimitiveTypeModel]] = Field(
+    primitive_types: Optional[List[enum.ParameterType]] = Field(
         None,
         description="Filter on the list based on the Primitive data type key `primitive_type` of the Parameter.",
         example=["number", "boolean"],
     )
     search: Optional[List[SearchItem]] = Field(
         None,
         description="Search and filter on the list based on the keys `parameter_name`. The search is case insensitive and will find partial matches as well. All strings in the array are treated as `OR`. ",
@@ -2430,27 +2391,27 @@
 class ParameterAppVersion(DataModelBase):
     """
     ParameterAppVersion object.
 
     Parameters
     ----------
     name: str
-    version: str
+    version: Optional[str]
 
     """
 
     name: str = Field(
         ...,
         description="A filter on the list based on the key `app_name`. The filter is on the full name only. The string can only contain lowercase alphanumeric characters and `.`, `_` or `-` characters.",
         example="motor-speed-control",
         max_length=64,
         min_length=1,
     )
-    version: str = Field(
-        ...,
+    version: Optional[str] = Field(
+        None,
         description="A filter on the list based on the key `app_version`. The filter is on the full name only. The string can only contain lowercase alphanumeric characters and `.`, `_` or `-` characters.",
         example="1.2.0",
         max_length=64,
     )
 
 
 class ParameterName(BaseModelRoot[str]):
@@ -2462,28 +2423,69 @@
     __root__: str = Field(..., max_length=64, min_length=1)
 
     """
 
     __root__: str = Field(..., max_length=64, min_length=1)
 
 
-class ParametersResourcesList(DataModelBase):
+class ResourceParametersList(DataModelBase):
+    """
+    ResourceParametersList object.
+
+    Parameters
+    ----------
+    apps: Optional[List[ParameterAppVersion]]
+    resources: Optional[List[Resource]]
+    parameter_names: Optional[List[ParameterName]]
+    start_date: Optional[datetime]
+    end_date: Optional[datetime]
+
+    """
+
+    apps: Optional[List[ParameterAppVersion]] = Field(
+        None,
+        description="A filter on the list for Apps and its Versions. Multiple Apps and Versions can be given. All App Versions in the array are treated as `OR`.",
+    )
+    resources: Optional[List[Resource]] = Field(
+        None,
+        description="A filter on the list showing only current Parameter values associated with any Assets in the array. The filter is on the full name only. All strings in the array are treated as `OR`. Each Asset name can only contain lowercase alphanumeric characters and `.`, `_` or `-` characters.",
+        example=["krn:asset:bp_16", "krn:asset:bp_21"],
+    )
+    parameter_names: Optional[List[ParameterName]] = Field(
+        None,
+        description="A filter on the list for Parameters. The filter is on the full name only. All strings in the array are treated as `OR`. Each Parameter name can only contain lowercase alphanumeric characters and `.`, `_` or `-` characters.",
+        example=["motor-speed-control", "gas_flow_rate_max_threshold"],
+    )
+    start_date: Optional[datetime] = Field(
+        None,
+        description="Earliest `created` time for the list of Parameters. Time is based on UTC timezone, formatted in RFC 3339.",
+        example="2024-02-06T00:00:00.000000Z",
+    )
+    end_date: Optional[datetime] = Field(
+        None,
+        description="Most recent `created` time for the list of Parameters. Time is based on UTC timezone, formatted in RFC 3339.",
+        example="2024-02-07T00:00:00.000000Z",
+    )
+
+
+class LastParametersResourcesGet(DataModelBase):
     """
-    ParametersResourcesList object.
+    LastParametersResourcesGet object.
 
     Parameters
     ----------
     apps: Optional[List[ParameterAppVersion]]
     resources: Optional[List[Resource]]
     parameter_names: Optional[List[ParameterName]]
 
     """
 
     apps: Optional[List[ParameterAppVersion]] = Field(
-        None, description="A filter on the list for Apps and its Versions. Multiple Apps and Versions can be given."
+        None,
+        description="A filter on the list for Apps and its Versions. Multiple Apps and Versions can be given. All App Versions in the array are treated as `OR`.",
     )
     resources: Optional[List[Resource]] = Field(
         None,
         description="A filter on the list showing only current Parameter values associated with any Assets in the array. The filter is on the full name only. All strings in the array are treated as `OR`. Each Asset name can only contain lowercase alphanumeric characters and `.`, `_` or `-` characters.",
         example=["krn:asset:bp_16", "krn:asset:bp_21"],
     )
     parameter_names: Optional[List[ParameterName]] = Field(
@@ -2534,23 +2536,23 @@
 class ParametersValuesGet(DataModelBase):
     """
     ParametersValuesGet object.
 
     Parameters
     ----------
     app_parameters: Optional[List[AppParameter]]
-    primitive_types: Optional[List[enum.ParameterTypeName]]
+    primitive_types: Optional[List[enum.ParameterType]]
 
     """
 
     app_parameters: Optional[List[AppParameter]] = Field(
         None,
         description="Filter on the list based on the key `app_name` and wanted Parameter `name` per App. The filter is on the full name only. The string can only contain lowercase alphanumeric characters and `.`, `_` or `-` characters.",
     )
-    primitive_types: Optional[List[enum.ParameterTypeName]] = Field(
+    primitive_types: Optional[List[enum.ParameterType]] = Field(
         None,
         description="Filter on the list based on the Parameter data type key `primitive_type` of the Parameter.",
         example=["number", "boolean"],
     )
 
 
 class ResourceName(BaseModelRoot[str]):
@@ -2586,15 +2588,15 @@
     Parameters
     ----------
     end_date: datetime
     resource_names: Optional[List[ResourceName]]
     sources: Optional[List[Source]]
     start_date: datetime
     states: Optional[List[enum.RecommendationState]]
-    time_bucket: TimeBucket
+    time_bucket: str
     types: Optional[List[TypeModel1]]
 
     """
 
     end_date: datetime = Field(
         ...,
         description="Most recent (end) creation time for counting the number of Recommendations. Time is based on UTC timezone, formatted in RFC 3339.",
@@ -2616,15 +2618,15 @@
         example="2023-11-18T18:22:18.582724Z",
     )
     states: Optional[List[enum.RecommendationState]] = Field(
         None,
         description="A filter to only count Recommendations associated with one or more `states`. The filter is on the full `state` name only. All strings in the array are treated as `OR`.",
         example=["accepted", "applied"],
     )
-    time_bucket: TimeBucket = Field(
+    time_bucket: str = Field(
         ..., description="Defines the time range to use to group and count the Recommendations.", example="5m"
     )
     types: Optional[List[TypeModel1]] = Field(
         None,
         description="A filter to only count Recommendations associated with one or more `types`. The filter is on the full `state` name only. All strings in the array are treated as `OR`.",
         example=["decrease_speed", "increase_speed"],
     )
@@ -2661,16 +2663,14 @@
     custom_identifier: Optional[str] = Field(
         None, description="An optional custom identifier for any purpose.", example="model-aws-ltsm-anomaly"
     )
     description: Optional[str] = Field(
         None,
         description="Detailed description of the Recommendation.",
         example="Beam pump speed AI optimizer application recommends a new value for the speed setpoint of the controller.",
-        max_length=256,
-        min_length=1,
     )
     expiration_date: Optional[datetime] = Field(
         None,
         description="UTC time when the Recommendation will expire and the `status` automatically marked as `expired`, formatted in RFC 3339. The operator will not be able to take any further actions on this Recommendation. If no date is given, then the Recommendation will never expire.",
         example="2023-11-18T18:22:18.582724Z",
     )
     metadata: Optional[Dict[str, Any]] = Field(
@@ -2837,16 +2837,14 @@
 
     """
 
     description: Optional[str] = Field(
         None,
         description="Full description of the purpose for this Recommendation Type.",
         example="Recommendations that require a reduction in the speed set point.",
-        max_length=256,
-        min_length=1,
     )
     name: str = Field(
         ...,
         description="Recommendation Type key `name` to create. The string can only contain lowercase alphanumeric characters and `.`, `_` or `-` characters.",
         example="decrease_speed",
         max_length=64,
         min_length=1,
@@ -2871,16 +2869,14 @@
 
     """
 
     description: Optional[str] = Field(
         None,
         description="New fFull description of the purpose for this Recommendation Type.",
         example="Recommendations that require a reduction in the speed set point.",
-        max_length=256,
-        min_length=1,
     )
     title: Optional[str] = Field(
         None,
         description="New display name (`title`) of the Recommendation Type.",
         example="Decrease Speed",
         max_length=64,
         min_length=1,
@@ -2905,16 +2901,14 @@
         ge=-2147483648,
         le=2147483647,
     )
     message: Optional[str] = Field(
         None,
         description="Contains a message with any descriptions useful to be associated with the `accepted` state. This will be recorded in logs of the actual Recommendation.",
         example="Recommendation is accurate based on the current performance.",
-        max_length=256,
-        min_length=1,
     )
 
 
 class RecommendationLogCreate(DataModelBase):
     """
     RecommendationLogCreate object.
 
@@ -2924,16 +2918,14 @@
 
     """
 
     message: Optional[str] = Field(
         None,
         description="Contains a message with any descriptions useful to be recorded in logs of the actual Recommendation.",
         example="Need more time to assess Recommendation data before making a decision.",
-        max_length=256,
-        min_length=1,
     )
 
 
 class RecommendationRejectUpdate(DataModelBase):
     """
     RecommendationRejectUpdate object.
 
@@ -2951,16 +2943,14 @@
         ge=-2147483648,
         le=2147483647,
     )
     message: Optional[str] = Field(
         None,
         description="Contains a message with any descriptions useful to be associated with the `reject` state. This will be recorded in logs of the actual Recommendation.",
         example="Recommendation is not accurate based on the current performance.",
-        max_length=256,
-        min_length=1,
     )
 
 
 class SecretCreate(DataModelBase):
     """
     SecretCreate object.
 
@@ -3346,7 +3336,20 @@
     title: Optional[str] = Field(
         None,
         description="Display name (`title`) of the Workload.",
         example="Motor Speed Control",
         max_length=64,
         min_length=1,
     )
+
+
+class WorkloadConfigurationUpdate(DataModelBase):
+    """
+    WorkloadConfigurationUpdate object.
+
+    Parameters
+    ----------
+    configuration: Optional[Dict[str, Any]]
+
+    """
+
+    configuration: Optional[Dict[str, Any]] = None
```

## kelvin/api/client/model/response.py

```diff
@@ -1,10 +1,10 @@
 # generated by datamodel-codegen:
 #   filename:  openapi.json
-#   timestamp: 2024-04-08T09:50:50+00:00
+#   timestamp: 2024-04-24T09:43:45+00:00
 
 from __future__ import annotations
 
 from enum import Enum
 from typing import Any, Dict, List, Optional
 
 from pydantic import Field
```

## kelvin/api/client/model/responses.py

```diff
@@ -1,16 +1,16 @@
 # generated by datamodel-codegen:
 #   filename:  openapi.json
-#   timestamp: 2024-04-08T09:50:50+00:00
+#   timestamp: 2024-04-24T09:43:45+00:00
 
 from __future__ import annotations
 
 from datetime import datetime
 from enum import Enum
-from typing import Any, Dict, List, Optional
+from typing import Any, Dict, List, Optional, Union
 from uuid import UUID
 
 from pydantic import EmailStr, Field
 
 from kelvin.api.client.base_model import BaseModelRoot
 from kelvin.api.client.data_model import DataModelBase, PaginatorDataModel
 
@@ -122,42 +122,33 @@
     updated: Optional[datetime] = Field(
         None,
         description="UTC time when any Asset keys were last updated, formatted in RFC 3339.",
         example="2023-11-18T18:22:18.582724Z",
     )
 
 
-class Status(Enum):
-    running = "running"
-    stopped = "stopped"
-    updating = "updating"
-    requires_attention = "requires_attention"
-
-
 class AppManagerResourceAppStatus(DataModelBase):
     """
     AppManagerResourceAppStatus object.
 
     Parameters
     ----------
     last_seen: Optional[datetime]
-    status: Optional[Status]
+    status: Optional[enum.AppManagerAppStatus]
     updated: Optional[datetime]
     updated_by: Optional[str]
 
     """
 
     last_seen: Optional[datetime] = Field(
         None,
         description="UTC time when this the Application for this Asset was last seen online, formatted in RFC 3339.",
         example="2023-06-26T18:22:18.582724Z",
     )
-    status: Optional[Status] = Field(
-        None, description="Current `status` of the the Application for this Asset.", example="running"
-    )
+    status: Optional[enum.AppManagerAppStatus] = None
     updated: Optional[datetime] = Field(
         None,
         description="UTC time when any of the Asset keys for the Application were last updated, formatted in RFC 3339.",
         example="2023-06-26T18:22:18.582724Z",
     )
     updated_by: Optional[str] = Field(
         None,
@@ -281,15 +272,15 @@
     AppIO object.
 
     Parameters
     ----------
     control_change: Optional[bool]
     data_type_name: Optional[str]
     name: Optional[str]
-    primitive_type_name: Optional[enum.DataTypeName]
+    primitive_type_name: Optional[enum.DataType]
     semantic_type_name: Optional[str]
     unit_name: Optional[str]
 
     """
 
     control_change: Optional[bool] = Field(
         None, description="Variable is tagged as a control change variable.", example=False
@@ -304,17 +295,15 @@
     name: Optional[str] = Field(
         None,
         description="Unique identifier `name` of the Data Stream.",
         example="gas_flow_rate",
         max_length=64,
         min_length=1,
     )
-    primitive_type_name: Optional[enum.DataTypeName] = Field(
-        None, description="Primitive data type of the Sematic Type."
-    )
+    primitive_type_name: Optional[enum.DataType] = Field(None, description="Primitive data type of the Sematic Type.")
     semantic_type_name: Optional[str] = Field(
         None,
         description="Unique identifier `name` of the Semantic Type that describes the nature, purpose or origin of the variable.",
         example="volume_flow_rate",
     )
     unit_name: Optional[str] = Field(
         None,
@@ -1339,15 +1328,15 @@
 
     Parameters
     ----------
     created_by: Optional[str]
     created_type: Optional[str]
     id: UUID
     last_state: Optional[enum.ControlChangeState]
-    payload: Optional[type.AnyModel]
+    payload: Optional[Any]
     resource: Optional[str]
     source: Optional[str]
     timestamp: Optional[datetime]
     trace_id: UUID
 
     """
 
@@ -1365,15 +1354,15 @@
     )
     id: UUID = Field(
         ...,
         description="A unique random generated UUID as the key `id` for the Control Change.",
         example="0002bc79-b42f-461b-95d6-cf0a28ba87aa",
     )
     last_state: Optional[enum.ControlChangeState] = Field(None, description="Current state of the Control Change.")
-    payload: Optional[type.AnyModel] = Field(
+    payload: Optional[Any] = Field(
         None,
         description="The new value payload to be applied to the Asset / Data Stream pair in `resource`.",
         example=2000,
     )
     resource: Optional[str] = Field(
         None,
         description="The asset / data stream pair that this Control Change will be applied to.",
@@ -1438,15 +1427,15 @@
     last_message: Optional[str]
     last_state: Optional[enum.ControlChangeState]
     retries: Optional[int]
     timeout: Optional[int]
     expiration_date: Optional[datetime]
     from_: Optional[type.ControlChangeFrom]
     reported: Optional[type.ControlChangeReported]
-    payload: Optional[type.AnyModel]
+    payload: Optional[Any]
     resource: str
     status_log: Optional[List[ControlChangeGetStatus]]
     timestamp: Optional[datetime]
     updated: Optional[datetime]
 
     """
 
@@ -1490,15 +1479,15 @@
     )
     expiration_date: Optional[datetime] = Field(
         None,
         description="UTC time when the Control Change will expire and the `status` automatically marked as `failed`, formatted in RFC 3339..",
     )
     from_: Optional[type.ControlChangeFrom] = Field(None, alias="from")
     reported: Optional[type.ControlChangeReported] = None
-    payload: Optional[type.AnyModel] = Field(
+    payload: Optional[Any] = Field(
         None,
         description="The new value payload to be applied to the Asset / Data Stream pair in `resource`.",
         example=2000,
     )
     resource: str = Field(
         ...,
         description="The asset / data stream pair that this Control Change will be applied to.",
@@ -1903,15 +1892,15 @@
     DataStream object.
 
     Parameters
     ----------
     created: Optional[datetime]
     description: Optional[str]
     name: Optional[str]
-    data_type_name: Optional[enum.DataTypeName]
+    data_type_name: Optional[enum.DataType]
     semantic_type_name: Optional[str]
     title: Optional[str]
     type: Optional[TypeModel]
     unit_name: Optional[str]
     updated: Optional[datetime]
 
     """
@@ -1922,31 +1911,26 @@
         example="2023-06-26T18:22:18.582724Z",
     )
     description: Optional[str] = Field(
         None,
         description="Detailed description of the Data Stream.",
         example="The rate at which gas flows from the reservoir to the surface.",
         max_length=200,
-        min_length=1,
     )
     name: Optional[str] = Field(
         None, description="Unique identifier `name` of the Data Stream.", example="gas_flow_rate"
     )
-    data_type_name: Optional[enum.DataTypeName] = Field(None, description="Data type of the Data Stream.")
+    data_type_name: Optional[enum.DataType] = Field(None, description="Data type of the Data Stream.")
     semantic_type_name: Optional[str] = Field(
         None,
         description="Unique identifier `name` of the Semantic Type that describes the nature, purpose or origin of the data.",
         example="volume_flow_rate",
     )
     title: Optional[str] = Field(
-        None,
-        description="Display name (`title`) of the Data Stream.",
-        example="Gas Flow Rate",
-        max_length=64,
-        min_length=1,
+        None, description="Display name (`title`) of the Data Stream.", example="Gas Flow Rate", max_length=64
     )
     type: Optional[TypeModel] = Field(
         None, description="Specifies the technique used for generating data in the Data Stream.", example="measurement"
     )
     unit_name: Optional[str] = Field(
         None,
         description="Unique identifier `name` of the Units that describes the type or category of data represented by each unit. Only available if the Primitive Type is `number`.",
@@ -2210,17 +2194,17 @@
 
     Parameters
     ----------
 
     """
 
 
-class DataTagsListPaginatedResponseCursor(PaginatorDataModel[type.DataTag]):
+class DataTagListPaginatedResponseCursor(PaginatorDataModel[type.DataTag]):
     """
-    DataTagsListPaginatedResponseCursor object.
+    DataTagListPaginatedResponseCursor object.
 
     Parameters
     ----------
     data: Optional[List[type.DataTag]]
     pagination: Optional[pagination.PaginationCursor]
 
     """
@@ -2228,17 +2212,17 @@
     data: Optional[List[type.DataTag]] = Field(
         None,
         description="A dictionary with a data property that contains an array of up to `page_size` Data Tag objects, starting from the index specified by the pagination parameters, that matches the query parameters.",
     )
     pagination: Optional[pagination.PaginationCursor] = None
 
 
-class DataTagsListPaginatedResponseLimits(PaginatorDataModel[type.DataTag]):
+class DataTagListPaginatedResponseLimits(PaginatorDataModel[type.DataTag]):
     """
-    DataTagsListPaginatedResponseLimits object.
+    DataTagListPaginatedResponseLimits object.
 
     Parameters
     ----------
     data: Optional[List[type.DataTag]]
     pagination: Optional[pagination.PaginationLimits]
 
     """
@@ -2246,17 +2230,17 @@
     data: Optional[List[type.DataTag]] = Field(
         None,
         description="A dictionary with a data property that contains an array of up to `page_size` Data Tag objects for the page number specified by the pagination parameters, that matches the query parameters.",
     )
     pagination: Optional[pagination.PaginationLimits] = None
 
 
-class DataTagsListPaginatedResponseStream(DataModelBase):
+class DataTagListPaginatedResponseStream(DataModelBase):
     """
-    DataTagsListPaginatedResponseStream object.
+    DataTagListPaginatedResponseStream object.
 
     Parameters
     ----------
     data: Optional[List[type.DataTag]]
 
     """
 
@@ -2292,17 +2276,17 @@
 
     Parameters
     ----------
 
     """
 
 
-class TagsListPaginatedResponseCursor(PaginatorDataModel[type.Tag]):
+class TagListPaginatedResponseCursor(PaginatorDataModel[type.Tag]):
     """
-    TagsListPaginatedResponseCursor object.
+    TagListPaginatedResponseCursor object.
 
     Parameters
     ----------
     data: Optional[List[type.Tag]]
     pagination: Optional[pagination.PaginationCursor]
 
     """
@@ -2310,17 +2294,17 @@
     data: Optional[List[type.Tag]] = Field(
         None,
         description="A dictionary with a data property that contains an array of up to `page_size` Tag objects, starting from the index specified by the pagination parameters, that matches the query parameters.",
     )
     pagination: Optional[pagination.PaginationCursor] = None
 
 
-class TagsListPaginatedResponseLimits(PaginatorDataModel[type.Tag]):
+class TagListPaginatedResponseLimits(PaginatorDataModel[type.Tag]):
     """
-    TagsListPaginatedResponseLimits object.
+    TagListPaginatedResponseLimits object.
 
     Parameters
     ----------
     data: Optional[List[type.Tag]]
     pagination: Optional[pagination.PaginationLimits]
 
     """
@@ -2328,17 +2312,17 @@
     data: Optional[List[type.Tag]] = Field(
         None,
         description="A dictionary with a data property that contains an array of up to `page_size` Tag objects for the page number specified by the pagination parameters, that matches the query parameters.",
     )
     pagination: Optional[pagination.PaginationLimits] = None
 
 
-class TagsListPaginatedResponseStream(DataModelBase):
+class TagListPaginatedResponseStream(DataModelBase):
     """
-    TagsListPaginatedResponseStream object.
+    TagListPaginatedResponseStream object.
 
     Parameters
     ----------
     data: Optional[List[type.Tag]]
 
     """
 
@@ -2632,32 +2616,25 @@
 
     Parameters
     ----------
 
     """
 
 
-class StatusModel(Enum):
-    pending = "pending"
-    online = "online"
-    unreachable = "unreachable"
-    requires_attention = "requires_attention"
-
-
 class OrchestrationClustersCreateItem(DataModelBase):
     """
     OrchestrationClustersCreateItem object.
 
     Parameters
     ----------
     created: Optional[datetime]
     last_seen: Optional[datetime]
     name: Optional[str]
     ready: Optional[bool]
-    status: Optional[StatusModel]
+    status: Optional[enum.OrchestrationClusterStatus]
     title: Optional[str]
     type: Optional[enum.ClusterType]
     updated: Optional[datetime]
 
     """
 
     created: Optional[datetime] = Field(
@@ -2676,15 +2653,15 @@
         example="aws-cluster",
         max_length=64,
         min_length=1,
     )
     ready: Optional[bool] = Field(
         None, description="Setting to inform Kelvin UI if the Cluster is ready.", example=True
     )
-    status: Optional[StatusModel] = Field(None, description="Current status of the Cluster.", example="online")
+    status: Optional[enum.OrchestrationClusterStatus] = None
     title: Optional[str] = Field(
         None, description="Display name (`title`) of the Cluster.", example="AWS Cluster", max_length=64, min_length=1
     )
     type: Optional[enum.ClusterType] = Field(
         None, description="Type of Cluster deployed. `k3s` is managed by Kelvin, `kubernetes` is managed by client."
     )
     updated: Optional[datetime] = Field(
@@ -2828,33 +2805,27 @@
     )
     revision: Optional[str] = Field(
         None, description="Current Kelvin Software version installed on the Cluster.", example="4.0.0-rc2024.521"
     )
     upgrade: Optional[OrchestrationClustersCreateManifestUpgrade] = None
 
 
-class StatusModel1(Enum):
-    online = "online"
-    unreachable = "unreachable"
-    not_ready = "not_ready"
-
-
 class OrchestrationClustersNodesGetItem(DataModelBase):
     """
     OrchestrationClustersNodesGetItem object.
 
     Parameters
     ----------
     created: Optional[datetime]
     last_seen: Optional[datetime]
     main: Optional[bool]
     name: Optional[str]
-    status: Optional[StatusModel1]
+    status: Optional[enum.OrchestrationNodeStatus]
     updated: Optional[datetime]
-    warnings: Optional[type.AnyModel]
+    warnings: Optional[Any]
 
     """
 
     created: Optional[datetime] = Field(
         None,
         description="UTC time when the Node was created, formatted in RFC 3339.",
         example="2023-11-18T18:22:18.582724Z",
@@ -2868,21 +2839,21 @@
     name: Optional[str] = Field(
         None,
         description="Unique identifier key `name` of the Node.",
         example="internal-node-01",
         max_length=64,
         min_length=1,
     )
-    status: Optional[StatusModel1] = Field(None, description="Current status of the Node.", example="online")
+    status: Optional[enum.OrchestrationNodeStatus] = None
     updated: Optional[datetime] = Field(
         None,
         description="UTC time when any Node keys were last updated, formatted in RFC 3339.",
         example="2023-11-18T18:22:18.582724Z",
     )
-    warnings: Optional[type.AnyModel] = Field(
+    warnings: Optional[Any] = Field(
         None,
         description="Any warning messages received from Kubernetes.",
         example="container runtime network not ready: NetworkReady=false reason:NetworkPluginNotReady message:Network plugin returns error: cni plugin not initialized",
     )
 
 
 class OrchestrationClustersNodeListPaginatedResponseCursor(PaginatorDataModel[OrchestrationClustersNodesGetItem]):
@@ -3025,14 +2996,33 @@
         None, description="Operating system image used on the node.", example="Ubuntu 22.04.3 LTS"
     )
     system_uuid: Optional[str] = Field(
         None, description="Universal unique identifier of the system.", example="ec22bcec-e328-8e3a-08d7-b7ce4b0742c1"
     )
 
 
+class NetworkInfoItem(DataModelBase):
+    """
+    NetworkInfoItem object.
+
+    Parameters
+    ----------
+    interface: Optional[str]
+    ipv4: Optional[List[str]]
+    ipv6: Optional[List[str]]
+    dns: Optional[List[str]]
+
+    """
+
+    interface: Optional[str] = None
+    ipv4: Optional[List[str]] = None
+    ipv6: Optional[List[str]] = None
+    dns: Optional[List[str]] = None
+
+
 class OrchestrationClustersNodesGet(DataModelBase):
     """
     OrchestrationClustersNodesGet object.
 
     Parameters
     ----------
     capacity: Optional[Dict[str, Any]]
@@ -3041,16 +3031,16 @@
     hostname: Optional[str]
     internal_ip: Optional[str]
     k8s_version: Optional[str]
     labels: Optional[type.KeyValue]
     last_seen: Optional[datetime]
     main: Optional[bool]
     name: Optional[str]
-    network_info: Optional[Dict[str, Any]]
-    status: Optional[StatusModel1]
+    network_info: Optional[List[NetworkInfoItem]]
+    status: Optional[enum.OrchestrationNodeStatus]
     system_info: Optional[OrchestrationClustersNodesGetSystemInfo]
     updated: Optional[datetime]
     warnings: Optional[Dict[str, Any]]
 
     """
 
     capacity: Optional[Dict[str, Any]] = Field(
@@ -3109,20 +3099,20 @@
     name: Optional[str] = Field(
         None,
         description="Unique identifier key `name` of the Node.",
         example="aws-cluster-node-01",
         max_length=64,
         min_length=1,
     )
-    network_info: Optional[Dict[str, Any]] = Field(
+    network_info: Optional[List[NetworkInfoItem]] = Field(
         None,
         description="Details about the Node's current network settings.",
         example=[{"dns": [""], "interface": "ens5", "ipv4": ["172.31.40.200"], "ipv6": ["fe80::10d3:f3ff:fe1b:bea1"]}],
     )
-    status: Optional[StatusModel1] = Field(None, description="Current status of the Node.", example="online")
+    status: Optional[enum.OrchestrationNodeStatus] = None
     system_info: Optional[OrchestrationClustersNodesGetSystemInfo] = None
     updated: Optional[datetime] = Field(
         None,
         description="UTC time when any Node keys were last updated, formatted in RFC 3339.",
         example="2023-11-18T18:22:18.582724Z",
     )
     warnings: Optional[Dict[str, Any]] = Field(
@@ -3263,15 +3253,15 @@
     app_version: Optional[str]
     comment: Optional[str]
     created: Optional[datetime]
     parameter_name: Optional[str]
     resource: Optional[str]
     source: Optional[str]
     updated: Optional[datetime]
-    value: Optional[type.AnyModel]
+    value: Optional[Any]
 
     """
 
     app_name: Optional[str] = Field(
         None,
         description="Unique identifier `name` of the App in the App Registry linked to this Parameter.",
         example="motor-speed-control",
@@ -3315,15 +3305,15 @@
         min_length=1,
     )
     updated: Optional[datetime] = Field(
         None,
         description="UTC time when any Parameter keys were last updated, formatted in RFC 3339.",
         example="2023-06-26T18:22:18.582724Z",
     )
-    value: Optional[type.AnyModel] = Field(
+    value: Optional[Any] = Field(
         None,
         description="The current value of the Parameter. The format returned will depend on the Primitive Type of the Parameter.",
         example=100,
     )
 
 
 class ParametersAppVersionAssetListPaginatedResponseCursor(PaginatorDataModel[ParameterValueItem]):
@@ -3374,49 +3364,43 @@
 
     data: Optional[List[ParameterValueItem]] = Field(
         None,
         description="A dictionary with a data property that contains an array of all Parameter objects, that matches the query parameters.",
     )
 
 
-class TypeModel1(Enum):
-    boolean = "boolean"
-    number = "number"
-    object = "object"
-    string = "string"
-
-
 class ParameterJSONSchemaProperties(DataModelBase):
     """
     ParameterJSONSchemaProperties object.
 
     Parameters
     ----------
-    default: Optional[type.AnyModel]
+    default: Optional[Any]
     description: Optional[str]
-    examples: Optional[type.AnyModel]
+    examples: Optional[Any]
     maxLength: Optional[int]
     maximum: Optional[int]
     minLength: Optional[int]
     minimum: Optional[int]
     pattern: Optional[str]
     title: Optional[str]
-    type: Optional[TypeModel1]
+    type: Optional[enum.DataType]
+    enum: Optional[List[Union[float, str, bool]]]
 
     """
 
-    default: Optional[type.AnyModel] = Field(None, description="Default value or text for the Parameter in the App.")
+    default: Optional[Any] = Field(None, description="Default value or text for the Parameter in the App.")
     description: Optional[str] = Field(
         None,
         description="Detailed description for this Parameter in the App.",
         example="Maximum allowable threshold for the gas flow through the pump system.",
         max_length=200,
         min_length=1,
     )
-    examples: Optional[type.AnyModel] = None
+    examples: Optional[Any] = None
     maxLength: Optional[int] = Field(
         None,
         description="Maximum text length for the Parameter in the App. This ony applies to Parameters with a Primitive Type `string`.",
         example=64,
     )
     maximum: Optional[int] = Field(
         None,
@@ -3441,16 +3425,17 @@
     title: Optional[str] = Field(
         None,
         description="Display name (`title`) of the Parameter in the App.",
         example="Gas Flow Max Threshold",
         max_length=64,
         min_length=1,
     )
-    type: Optional[TypeModel1] = Field(
-        None, description="Primitive data type of the Parameter for the App.", example="number"
+    type: Optional[enum.DataType] = None
+    enum: Optional[List[Union[float, str, bool]]] = Field(
+        None, description="List of possible values for the Parameter in the App."
     )
 
 
 class RequiredItem(BaseModelRoot[str]):
     """
     RequiredItem object.
 
@@ -3511,32 +3496,25 @@
         description="Type of the key `properties` value. Currently it is always `object`.",
         example="object",
         max_length=64,
         min_length=1,
     )
 
 
-class PrimitiveType(Enum):
-    boolean = "boolean"
-    number = "number"
-    object = "object"
-    string = "string"
-
-
 class ParameterDefinitionItem(DataModelBase):
     """
     ParameterDefinitionItem object.
 
     Parameters
     ----------
     app_name: Optional[str]
     created: Optional[datetime]
     last_title: Optional[str]
     name: Optional[str]
-    primitive_type: Optional[PrimitiveType]
+    primitive_type: Optional[enum.ParameterType]
     updated: Optional[datetime]
 
     """
 
     app_name: Optional[str] = Field(
         None,
         description="Unique identifier `name` of the App in the App Registry linked to this Paramete Definition.",
@@ -3559,17 +3537,15 @@
     name: Optional[str] = Field(
         None,
         description="The name of the Parameter.",
         example="gas_flow_rate_max_threshold",
         max_length=64,
         min_length=1,
     )
-    primitive_type: Optional[PrimitiveType] = Field(
-        None, description="Primitive data type of the Parameter.", example="number"
-    )
+    primitive_type: Optional[enum.ParameterType] = None
     updated: Optional[datetime] = Field(
         None,
         description="UTC time when any Parameter Definition keys were last updated, formatted in RFC 3339.",
         example="2023-06-26T18:22:18.582724Z",
     )
 
 
@@ -3621,17 +3597,148 @@
 
     data: Optional[List[ParameterDefinitionItem]] = Field(
         None,
         description="A dictionary with a data property that contains an array of all Parameter Definition objects, that matches the query parameters.",
     )
 
 
-class ParametersResourcesListPaginatedResponseCursor(PaginatorDataModel[ParameterValueItem]):
+class ParameterValueHistorianItem(DataModelBase):
     """
-    ParametersResourcesListPaginatedResponseCursor object.
+    ParameterValueHistorianItem object.
+
+    Parameters
+    ----------
+    app_name: Optional[str]
+    app_version: Optional[str]
+    comment: Optional[str]
+    created: Optional[datetime]
+    parameter_name: Optional[str]
+    resource: Optional[str]
+    source: Optional[str]
+    updated: Optional[datetime]
+    value: Optional[Any]
+    invalidated: Optional[datetime]
+
+    """
+
+    app_name: Optional[str] = Field(
+        None,
+        description="Unique identifier `name` of the App in the App Registry linked to this Parameter.",
+        example="motor-speed-control",
+        max_length=64,
+        min_length=1,
+    )
+    app_version: Optional[str] = Field(
+        None, description="Version number of the App in the App Registry linked to this Parameter.", example="1.2.0"
+    )
+    comment: Optional[str] = Field(
+        None,
+        description="Latest information from user when creating or updating this Parameter.",
+        example="updating parameter for well operational optimization.",
+        max_length=200,
+        min_length=1,
+    )
+    created: Optional[datetime] = Field(
+        None,
+        description="UTC time when the Parameter was first created, formatted in RFC 3339.",
+        example="2023-06-26T18:22:18.582724Z",
+    )
+    parameter_name: Optional[str] = Field(
+        None,
+        description="The name of the Parameter.",
+        example="gas_flow_rate_max_threshold",
+        max_length=64,
+        min_length=1,
+    )
+    resource: Optional[str] = Field(
+        None,
+        description="KRN of the Asset associated with the Parameter.",
+        example="krn:asset:well_01",
+        max_length=256,
+        min_length=1,
+    )
+    source: Optional[str] = Field(
+        None,
+        description="KRN of the User or Service that last created or updated the Parameter.",
+        example="krn:user:richard.teo@kelvininc.com",
+        max_length=256,
+        min_length=1,
+    )
+    updated: Optional[datetime] = Field(
+        None,
+        description="UTC time when any Parameter keys were last updated, formatted in RFC 3339.",
+        example="2023-06-26T18:22:18.582724Z",
+    )
+    value: Optional[Any] = Field(
+        None,
+        description="The current value of the Parameter. The format returned will depend on the Primitive Type of the Parameter.",
+        example=100,
+    )
+    invalidated: Optional[datetime] = Field(
+        None,
+        description="UTC time when any Parameter value were invalidated, formatted in RFC 3339.",
+        example="2023-06-26T18:22:18.582724Z",
+    )
+
+
+class ResourceParametersListPaginatedResponseCursor(PaginatorDataModel[ParameterValueHistorianItem]):
+    """
+    ResourceParametersListPaginatedResponseCursor object.
+
+    Parameters
+    ----------
+    data: Optional[List[ParameterValueHistorianItem]]
+    pagination: Optional[pagination.PaginationCursor]
+
+    """
+
+    data: Optional[List[ParameterValueHistorianItem]] = Field(
+        None,
+        description="A dictionary with a data property that contains an array of up to `page_size` Parameter objects and its current value for the related Resource, starting from the index specified by the pagination parameters, that matches the query parameters.",
+    )
+    pagination: Optional[pagination.PaginationCursor] = None
+
+
+class ResourceParametersListPaginatedResponseLimits(PaginatorDataModel[ParameterValueHistorianItem]):
+    """
+    ResourceParametersListPaginatedResponseLimits object.
+
+    Parameters
+    ----------
+    data: Optional[List[ParameterValueHistorianItem]]
+    pagination: Optional[pagination.PaginationLimits]
+
+    """
+
+    data: Optional[List[ParameterValueHistorianItem]] = Field(
+        None,
+        description="A dictionary with a data property that contains an array of up to `page_size` Parameter objects and its current value for the related Resource for the page number specified by the pagination parameters, that matches the query parameters.",
+    )
+    pagination: Optional[pagination.PaginationLimits] = None
+
+
+class ResourceParametersListPaginatedResponseStream(DataModelBase):
+    """
+    ResourceParametersListPaginatedResponseStream object.
+
+    Parameters
+    ----------
+    data: Optional[List[ParameterValueHistorianItem]]
+
+    """
+
+    data: Optional[List[ParameterValueHistorianItem]] = Field(
+        None,
+        description="A dictionary with a data property that contains an array of all Parameter objects and its current value for the related Resource, that matches the query parameters.",
+    )
+
+
+class LastParametersResourcesGetPaginatedResponseCursor(PaginatorDataModel[ParameterValueItem]):
+    """
+    LastParametersResourcesGetPaginatedResponseCursor object.
 
     Parameters
     ----------
     data: Optional[List[ParameterValueItem]]
     pagination: Optional[pagination.PaginationCursor]
 
     """
@@ -3639,17 +3746,17 @@
     data: Optional[List[ParameterValueItem]] = Field(
         None,
         description="A dictionary with a data property that contains an array of up to `page_size` Parameter objects and its current value for the related Resource, starting from the index specified by the pagination parameters, that matches the query parameters.",
     )
     pagination: Optional[pagination.PaginationCursor] = None
 
 
-class ParametersResourcesListPaginatedResponseLimits(PaginatorDataModel[ParameterValueItem]):
+class LastParametersResourcesGetPaginatedResponseLimits(PaginatorDataModel[ParameterValueItem]):
     """
-    ParametersResourcesListPaginatedResponseLimits object.
+    LastParametersResourcesGetPaginatedResponseLimits object.
 
     Parameters
     ----------
     data: Optional[List[ParameterValueItem]]
     pagination: Optional[pagination.PaginationLimits]
 
     """
@@ -3657,17 +3764,17 @@
     data: Optional[List[ParameterValueItem]] = Field(
         None,
         description="A dictionary with a data property that contains an array of up to `page_size` Parameter objects and its current value for the related Resource for the page number specified by the pagination parameters, that matches the query parameters.",
     )
     pagination: Optional[pagination.PaginationLimits] = None
 
 
-class ParametersResourcesListPaginatedResponseStream(DataModelBase):
+class LastParametersResourcesGetPaginatedResponseStream(DataModelBase):
     """
-    ParametersResourcesListPaginatedResponseStream object.
+    LastParametersResourcesGetPaginatedResponseStream object.
 
     Parameters
     ----------
     data: Optional[List[ParameterValueItem]]
 
     """
 
@@ -3679,19 +3786,19 @@
 
 class ParametersValuesGet(DataModelBase):
     """
     ParametersValuesGet object.
 
     Parameters
     ----------
-    app_parameter_values: Optional[Dict[str, Dict[str, List[type.AnyModel]]]]
+    app_parameter_values: Optional[Dict[str, Dict[str, List[Any]]]]
 
     """
 
-    app_parameter_values: Optional[Dict[str, Dict[str, List[type.AnyModel]]]] = Field(
+    app_parameter_values: Optional[Dict[str, Dict[str, List[Any]]]] = Field(
         None,
         description="Collection of objects where each object is an App containing an array of values for each Parameter that meets the request filter definitions. Only unique Parameter Values are shown, default values will not be shown.",
         example={
             "cp-temperature-producer": {"temperature_max_in_celsius": [111], "temperature_min_in_celsius": [69]},
             "demo-model": {"recommended_speed_setpoint": [120, 150, 90]},
         },
     )
@@ -4168,21 +4275,21 @@
 
 class TimeseriesRangeGet(DataModelBase):
     """
     TimeseriesRangeGet object.
 
     Parameters
     ----------
-    payload: Optional[type.AnyModel]
+    payload: Optional[Any]
     resource: Optional[str]
     timestamp: Optional[datetime]
 
     """
 
-    payload: Optional[type.AnyModel] = Field(
+    payload: Optional[Any] = Field(
         None, description="Raw or aggregate value for `resource` at the specified `timestamp`."
     )
     resource: Optional[str] = Field(
         None,
         description="The `resource` (Asset / Data Stream pair) associated with the `payload`.",
         example="krn:ad:asset1/data_stream1",
         max_length=256,
@@ -4459,32 +4566,26 @@
 
     Parameters
     ----------
 
     """
 
 
-class DownloadStatus(Enum):
-    pending = "pending"
-    processing = "processing"
-    ready = "ready"
-
-
 class WorkloadItem(DataModelBase):
     """
     WorkloadItem object.
 
     Parameters
     ----------
     acp_name: Optional[str]
     app_name: Optional[str]
     app_version: Optional[str]
     cluster_name: Optional[str]
     created: Optional[datetime]
-    download_status: Optional[DownloadStatus]
+    download_status: Optional[enum.WorkloadDownloadStatus]
     enabled: Optional[bool]
     instantly_apply: Optional[bool]
     name: Optional[str]
     node_name: Optional[str]
     pre_download: Optional[bool]
     status: Optional[type.WorkloadStatus]
     title: Optional[str]
@@ -4517,17 +4618,15 @@
         min_length=1,
     )
     created: Optional[datetime] = Field(
         None,
         description="UTC time when the Workload was first created, formatted in RFC 3339.",
         example="2023-12-26T18:22:18.582724Z",
     )
-    download_status: Optional[DownloadStatus] = Field(
-        None, description="Current status of downloading Workload to the Edge System.", example="pending"
-    )
+    download_status: Optional[enum.WorkloadDownloadStatus] = None
     enabled: Optional[bool] = Field(
         None,
         description="If true, Workload `status` is set to `running` and will process I/O's. If false, Workload `status` is set to `stopped` but remains in Node on the Edge System.",
         example=True,
     )
     instantly_apply: Optional[bool] = Field(
         None,
@@ -4616,14 +4715,40 @@
 
     data: Optional[List[WorkloadItem]] = Field(
         None,
         description="A dictionary with a data property that contains an array of all Workload objects that matches the query parameters.",
     )
 
 
+class WorkloadConfigurationGet(DataModelBase):
+    """
+    WorkloadConfigurationGet object.
+
+    Parameters
+    ----------
+    configuration: Optional[Dict[str, Any]]
+
+    """
+
+    configuration: Optional[Dict[str, Any]] = None
+
+
+class WorkloadConfigurationUpdate(DataModelBase):
+    """
+    WorkloadConfigurationUpdate object.
+
+    Parameters
+    ----------
+    configuration: Optional[Dict[str, Any]]
+
+    """
+
+    configuration: Optional[Dict[str, Any]] = None
+
+
 class WorkloadGet(Workload):
     """
     WorkloadGet object.
 
     Parameters
     ----------
```

## kelvin/api/client/model/type.py

```diff
@@ -1,10 +1,10 @@
 # generated by datamodel-codegen:
 #   filename:  openapi.json
-#   timestamp: 2024-04-08T09:50:50+00:00
+#   timestamp: 2024-04-24T09:43:45+00:00
 
 from __future__ import annotations
 
 from datetime import datetime
 from enum import Enum
 from ipaddress import IPv4Address
 from typing import Any, Dict, List, Optional, Union
@@ -138,46 +138,35 @@
         example=8,
     )
     total: Optional[int] = Field(
         None, description="Total number of Applications of all versions together with any `status`.", example=10
     )
 
 
-class Status(Enum):
-    running = "running"
-    stopped = "stopped"
-    updating = "updating"
-    requires_attention = "requires_attention"
-
-
 class AppManagerAppStatus(DataModelBase):
     """
     AppManagerAppStatus object.
 
     Parameters
     ----------
     last_seen: Optional[datetime]
     resource_count: Optional[AppManagerAppStatusResourceCount]
-    status: Optional[Status]
+    status: Optional[enum.AppManagerAppStatus]
 
     """
 
     last_seen: Optional[datetime] = Field(
         None,
         description="UTC time when this version of the Application was last seen online, formatted in RFC 3339.",
         example="2023-06-26T18:22:18.582724Z",
     )
     resource_count: Optional[AppManagerAppStatusResourceCount] = Field(
         None, description="Information on the total running and total Assets added to the Application."
     )
-    status: Optional[Status] = Field(
-        None,
-        description="Current `status` of all versions of the Application together. If any one Asset is running, then the status is `running`. If any one Asset is updating, then the status is `updating`. If all are stopped, then the status is `stopped`.",
-        example="running",
-    )
+    status: Optional[enum.AppManagerAppStatus] = None
 
 
 class AppManagerApp(DataModelBase):
     """
     AppManagerApp object.
 
     Parameters
@@ -400,15 +389,15 @@
     """
     AssetProperty object.
 
     Parameters
     ----------
     name: Optional[str]
     title: Optional[str]
-    value: Optional[AnyModel]
+    value: Optional[Any]
 
     """
 
     name: Optional[str] = Field(
         None,
         description="Unique identifier `name` for the Asset Property. The string can only contain lowercase alphanumeric characters and `.`, `_` or `-` characters.",
         example="water-line-pressure",
@@ -418,44 +407,34 @@
     title: Optional[str] = Field(
         None,
         description="Display name (title) for the Asset Property. You can use any character, numeric, space and special character in this key.",
         example="Water Line Pressure",
         max_length=64,
         min_length=1,
     )
-    value: Optional[AnyModel] = Field(None, description="Value for this Asset Property.", example=87)
-
-
-class State(Enum):
-    online = "online"
-    offline = "offline"
-    unknown = "unknown"
+    value: Optional[Any] = Field(None, description="Value for this Asset Property.", example=87)
 
 
 class AssetStatusItem(DataModelBase):
     """
     AssetStatusItem object.
 
     Parameters
     ----------
     last_seen: Optional[datetime]
-    state: Optional[State]
+    state: Optional[enum.AssetState]
 
     """
 
     last_seen: Optional[datetime] = Field(
         None,
         description="UTC time when the Asset was last seen, formatted in RFC 3339.",
         example="2023-11-18T18:22:18.582724Z",
     )
-    state: Optional[State] = Field(
-        None,
-        description="Current status (`state`) of the Asset`. It is `online` if at least one of the Asset / Data Stream pairs is actively receiving data.",
-        example="offline",
-    )
+    state: Optional[enum.AssetState] = None
 
 
 class Asset(DataModelBase):
     """
     Asset object.
 
     Parameters
@@ -512,15 +491,15 @@
     """
     Property object.
 
     Parameters
     ----------
     created: Optional[datetime]
     name: Optional[str]
-    primitive_type: Optional[enum.PropertyTypeName]
+    primitive_type: Optional[enum.PropertyType]
     title: Optional[str]
     updated: Optional[datetime]
 
     """
 
     created: Optional[datetime] = Field(
         None,
@@ -530,15 +509,15 @@
     name: Optional[str] = Field(
         None,
         description="Unique identifier `name` for the Asset Property Definition. The string can only contain lowercase alphanumeric characters and `.`, `_` or `-` characters.",
         example="production_casing_depth",
         max_length=64,
         min_length=1,
     )
-    primitive_type: Optional[enum.PropertyTypeName] = Field(
+    primitive_type: Optional[enum.PropertyType] = Field(
         None, description="Property data type of the Asset Property Definition."
     )
     title: Optional[str] = Field(
         None,
         description="Display name (`title`) of the Asset Property Definition.",
         example="Production Casing Depth",
         max_length=64,
@@ -554,30 +533,26 @@
 class SimpleAsset(DataModelBase):
     """
     SimpleAsset object.
 
     Parameters
     ----------
     name: Optional[str]
-    state: Optional[State]
+    state: Optional[enum.AssetState]
 
     """
 
     name: Optional[str] = Field(
         None,
         description="Unique identifier `name` for the Asset. The string can only contain lowercase alphanumeric characters and `.`, `_` or `-` characters.",
         example="beam_pump",
         max_length=64,
         min_length=1,
     )
-    state: Optional[State] = Field(
-        None,
-        description="Current status (`state`) of the Asset`. It is `online` if at least one of the Asset / Data Stream pairs is actively receiving data.",
-        example="offline",
-    )
+    state: Optional[enum.AssetState] = None
 
 
 class AssetStatus(DataModelBase):
     """
     AssetStatus object.
 
     Parameters
@@ -751,36 +726,36 @@
 
 class ControlChangeFrom(DataModelBase):
     """
     ControlChangeFrom object.
 
     Parameters
     ----------
-    value: AnyModel
+    value: Any
     timestamp: datetime
 
     """
 
-    value: AnyModel
+    value: Any
     timestamp: datetime
 
 
 class ControlChangeReport(DataModelBase):
     """
     ControlChangeReport object.
 
     Parameters
     ----------
-    value: AnyModel
+    value: Any
     timestamp: datetime
     source: enum.ControlChangeSource
 
     """
 
-    value: AnyModel
+    value: Any
     timestamp: datetime
     source: enum.ControlChangeSource
 
 
 class ControlChangeReported(DataModelBase):
     """
     ControlChangeReported object.
@@ -1122,62 +1097,53 @@
     updated: Optional[datetime] = Field(
         None,
         description="UTC time when any Instance Settings keys were last updated, formatted in RFC 3339.",
         example="2023-11-18T18:22:18.582724Z",
     )
 
 
-class StateModel(Enum):
+class State(Enum):
+    idle = "idle"
     downloading = "downloading"
     ready = "ready"
 
 
 class UpgradeStatus(DataModelBase):
     """
     UpgradeStatus object.
 
     Parameters
     ----------
     message: Optional[str]
-    state: Optional[StateModel]
+    state: Optional[State]
 
     """
 
     message: Optional[str] = Field(
         None, description="Any feedback messages about the current upgrade process.", example=""
     )
-    state: Optional[StateModel] = Field(
-        None, description="Current state of the upgrade process.", example="downloading"
-    )
+    state: Optional[State] = Field(None, description="Current state of the upgrade process.", example="downloading")
 
 
 class VersionModel(DataModelBase):
     """
     VersionModel object.
 
     Parameters
     ----------
     k8s_version: Optional[str]
     kelvin_version: Optional[str]
 
     """
 
     k8s_version: Optional[str] = Field(
-        None,
-        description="Current version of k8s installed on the Cluster.",
-        example="v1.24.10+k3s1",
-        max_length=64,
-        min_length=1,
+        None, description="Current version of k8s installed on the Cluster.", example="v1.24.10+k3s1"
     )
     kelvin_version: Optional[str] = Field(
-        None,
-        description="Current version of Kelvin Software installed on the Cluster.",
-        example="4.0.0-rc2024.519",
-        max_length=64,
-        min_length=1,
+        None, description="Current version of Kelvin Software installed on the Cluster.", example="4.0.0-rc2024.519"
     )
 
 
 class OrchestrationCluster(DataModelBase):
     """
     OrchestrationCluster object.
 
@@ -1190,14 +1156,15 @@
     last_seen: Optional[datetime]
     manifests_scrape_enabled: Optional[bool]
     manifests_scrape_interval: Optional[int]
     name: Optional[str]
     provision_script: Optional[str]
     ready: Optional[bool]
     service_account_token: Optional[str]
+    status: Optional[enum.OrchestrationClusterStatus]
     sync_scrape_interval: Optional[int]
     telemetry_buffer_size: Optional[int]
     telemetry_enabled: Optional[bool]
     telemetry_scrape_interval: Optional[int]
     title: Optional[str]
     type: Optional[enum.ClusterType]
     updated: Optional[datetime]
@@ -1255,18 +1222,16 @@
     )
     ready: Optional[bool] = Field(
         None, description="Setting to inform Kelvin UI if the Cluster is ready.", example=True
     )
     service_account_token: Optional[str] = Field(
         None,
         description="Service account token for automated processes to authenticate with when performing actions in the Cluster.",
-        example="bm9kZS1jbGll ... Uk4wWFBqbTY3Rml2ejM=",
-        max_length=64,
-        min_length=1,
     )
+    status: Optional[enum.OrchestrationClusterStatus] = None
     sync_scrape_interval: Optional[int] = Field(
         30,
         description="Frequency in seconds that the Cluster checks for new changes to apply to Workloads or Applications (deploy, start, stop, etc.)",
         example=3600,
         ge=10,
         le=86400,
     )
@@ -1366,15 +1331,15 @@
     """
     RecommendationControlChange object.
 
     Parameters
     ----------
     control_change_id: Optional[UUID]
     expiration_date: Optional[datetime]
-    payload: Dict[str, Any]
+    payload: Any
     resource: str
     retries: Optional[int]
     timeout: Optional[int]
     trace_id: Optional[UUID]
     from_: Optional[ControlChangeFrom]
 
     """
@@ -1385,17 +1350,15 @@
         example="0002bc79-b42f-461b-95d6-cf0a28ba87aa",
     )
     expiration_date: Optional[datetime] = Field(
         None,
         description="UTC time when any the Control Change initiated will expire and the `status` automatically marked as `failed`, formatted in RFC 3339.",
         example="2023-11-18T18:22:18.582724Z",
     )
-    payload: Dict[str, Any] = Field(
-        ..., description="Control Change data to write to the Asset / Data Stream pair.</p>", example={"value": 88}
-    )
+    payload: Any
     resource: str = Field(
         ...,
         description="The asset / data stream pair that this Control Change will be applied to.",
         example="krn:ad:bp_16/motor_speed_setpoint",
         max_length=256,
         min_length=1,
     )
@@ -1444,16 +1407,14 @@
 
     """
 
     message: Optional[str] = Field(
         None,
         description="If `success` is `true`, this contains a message of the action that has been performed. If `success` is `false`, this contains information why it failed.",
         example="Recommendation actions implemented",
-        max_length=256,
-        min_length=1,
     )
     success: Optional[bool] = Field(
         None,
         description="Response to signify if the actions have been initiated. `true` means the actions have been initiated and `false` means the actions failed to be initialized. This does not mean the actions have been completed successfully and you still need to followup monitoring each initiated action separately.",
         example=True,
     )
 
@@ -1538,16 +1499,14 @@
     custom_identifier: Optional[str] = Field(
         None, description="An optional custom identifier for any purpose.", example="model-aws-ltsm-anomaly"
     )
     description: Optional[str] = Field(
         None,
         description="Detailed description of the Recommendation.",
         example="Beam pump speed AI optimizer application recommends a new value for the speed setpoint of the controller.",
-        max_length=256,
-        min_length=1,
     )
     expiration_date: Optional[datetime] = Field(
         None,
         description="UTC time when any the Recommendation will expire and the `status` automatically marked as `expired`, formatted in RFC 3339. The operator will not be able to take any further actions on this Recommendation. If no date is given, then the Recommendation will never expire.",
         example="2023-11-18T18:22:18.582724Z",
     )
     id: Optional[UUID] = Field(
@@ -1618,16 +1577,14 @@
         description="UTC time when the Recommendation Type was created, formatted in RFC 3339.",
         example="2023-11-18T18:22:18.582724Z",
     )
     description: Optional[str] = Field(
         None,
         description="Full description of the purpose for this Recommendation Type.",
         example="Recommendations that require a reduction in the speed set point.",
-        max_length=256,
-        min_length=1,
     )
     name: Optional[str] = Field(
         None,
         description="Unique identifier `name` for the Recommendation Type. The string can only contain lowercase alphanumeric characters and `.`, `_` or `-` characters.",
         example="decrease_speed",
         max_length=64,
         min_length=1,
@@ -1687,15 +1644,15 @@
     Parameters
     ----------
     id: UUID
     type: str
     resource: str
     source: str
     timestamp: datetime
-    payload: AnyModel
+    payload: Any
 
     """
 
     id: UUID = Field(
         ...,
         description="UUID string. It identifies the message itself, so it must be generated every time a new message is created, it can’t be copied to a new message.",
     )
@@ -1707,28 +1664,28 @@
         ...,
         description="Kelvin Resource Name representing the application that created the message, such as a KSDK app, a worker, the UI, etc.",
     )
     timestamp: datetime = Field(
         ...,
         description="UTC timestamp in RFC-3339 format. This is the time stamp of the data. In most cases, that means the current time stamp.",
     )
-    payload: AnyModel = Field(..., description="The value of the measurement.")
+    payload: Any = Field(..., description="The value of the measurement.")
 
 
 class TimeseriesData(DataModelBase):
     """
     TimeseriesData object.
 
     Parameters
     ----------
     created: Optional[datetime]
     data_type: Optional[str]
     fields: Optional[List[str]]
     last_timestamp: Optional[datetime]
-    last_value: Optional[AnyModel]
+    last_value: Optional[Any]
     resource: Optional[str]
     source: Optional[str]
     updated: Optional[datetime]
 
     """
 
     created: Optional[datetime] = Field(
@@ -1741,28 +1698,27 @@
         None, description="Data `field` element name of each value in `last_value`.", example=["value"]
     )
     last_timestamp: Optional[datetime] = Field(
         None,
         description="UTC time when the time series data was last accessed, formatted in RFC 3339.",
         example="2023-11-10T09:55:08.627924Z",
     )
-    last_value: Optional[AnyModel] = Field(None, description="Most recent value received for each `field`.")
+    last_value: Optional[Any] = Field(None, description="Most recent value received for each `field`.")
     resource: Optional[str] = Field(
         None,
         description="Asset / Data Stream associated with `last_value`.",
         example="krn:ad:asset/data_stream",
         max_length=256,
         min_length=1,
     )
     source: Optional[str] = Field(
         None,
         description="Specifies the user or workload source for `last_value`.",
         example="krn:wlappv:cluster1/app1/1.2.0",
         max_length=256,
-        min_length=1,
     )
     updated: Optional[datetime] = Field(
         None,
         description="UTC time when the time series data was last updated, formatted in RFC 3339.",
         example="2023-11-10T09:55:09.31857Z",
     )
 
@@ -1857,15 +1813,15 @@
     Parameters
     ----------
     acp_name: Optional[str]
     app_name: Optional[str]
     app_version: Optional[str]
     cluster_name: Optional[str]
     created: Optional[datetime]
-    download_status: Optional[str]
+    download_status: Optional[enum.WorkloadDownloadStatus]
     enabled: Optional[bool]
     instantly_apply: Optional[bool]
     name: Optional[str]
     networking: Optional[List[NetworkingItem]]
     node_name: Optional[str]
     payload: Optional[Dict[str, Any]]
     pre_download: Optional[bool]
@@ -1900,17 +1856,15 @@
         min_length=1,
     )
     created: Optional[datetime] = Field(
         None,
         description="UTC time when the Workload was first created, formatted in RFC 3339.",
         example="2023-12-26T18:22:18.582724Z",
     )
-    download_status: Optional[str] = Field(
-        None, description="Current status of downloading Workload to the Edge System.", example="pending"
-    )
+    download_status: Optional[enum.WorkloadDownloadStatus] = None
     enabled: Optional[bool] = Field(
         None,
         description="If true, Workload `status` is set to `running` and will process I/O's. If false, Workload `status` is set to `stopped` but remains in Node on the Edge System.",
         example=True,
     )
     instantly_apply: Optional[bool] = Field(
         None,
```

## Comparing `kelvin_python_api_client-0.0.1.dist-info/METADATA` & `kelvin_python_api_client-0.0.2.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 Metadata-Version: 2.1
 Name: kelvin-python-api-client
-Version: 0.0.1
+Version: 0.0.2
 Summary: Kelvin Python API Client
 Author-email: Kelvin Inc <engineering@kelvininc.com>
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python :: 3
 Requires-Python: >=3.8
 Description-Content-Type: text/markdown
 Requires-Dist: PyJWT ==2.8.*
 Requires-Dist: PyYAML ==6.0.*
 Requires-Dist: Jinja2 ==3.1.*
 Requires-Dist: keyring ==24.1.*
 Requires-Dist: keyrings.alt ==4.2.*
-Requires-Dist: filelock ==3.13.*
+Requires-Dist: filelock ==3.12.*
 Requires-Dist: pydantic[email] ==1.10.*,>=1.10.4
 Requires-Dist: python-keycloak ==3.6.*
 Requires-Dist: requests ==2.31.*
 Requires-Dist: ruamel.yaml ==0.18.*
 Requires-Dist: structlog ==23.1.*
 Requires-Dist: typing-extensions
 Requires-Dist: typing-inspect ==0.9.*
```

## Comparing `kelvin_python_api_client-0.0.1.dist-info/RECORD` & `kelvin_python_api_client-0.0.2.dist-info/RECORD`

 * *Files 17% similar despite different names*

```diff
@@ -1,43 +1,44 @@
 kelvin/api/client/__init__.py,sha256=d_wtR_hzuLvX9KUdeudCcdGXOgqc641NLNy5ZEkiYuU,366
-kelvin/api/client/base_client.py,sha256=ndmW4gsKzUkrUyEnkenYsFrbrDpfXWa4jhOKEQKuGVM,29854
-kelvin/api/client/base_model.py,sha256=weIezsm0lnKBly2aECu2d7YX7jzrqblIC0CxnOO2N5s,5120
-kelvin/api/client/client.py,sha256=lP9wCbcJ3guppUkuw1ZJ34LJjrMvzkcturPOcTcgCcc,5559
+kelvin/api/client/api_service_model.py,sha256=s2p-vV2_aZ3fQADQd01Cs4sotFJv7Aqry5iWR4v4Iug,12746
+kelvin/api/client/base_client.py,sha256=ym5RG8iNBzSRK3siTjv7Wx7Vnw7DbcNPDetyL3gDjPE,29864
+kelvin/api/client/base_model.py,sha256=-9RA7ts0iVxHKyZdEKprkKzzeFLieHaY_1ER_90J0x0,5195
+kelvin/api/client/client.py,sha256=NeCXakaV_Wr8YRrr60SG13QEctfqTg0ggup5WMCrDlc,5584
 kelvin/api/client/config.py,sha256=WEGdlSB8-HWo5DEdWSrr1YqEEtl_ngPaNyta0PptJjM,22575
-kelvin/api/client/data_model.py,sha256=ooraJR5uBLWhmwI4S9sxRT_DJASF2zG0wwG67vR88fg,17103
+kelvin/api/client/data_model.py,sha256=eq_ktoZFdSYc09OmAhJwVgBuLXU0EhAwOQx0LQMzme4,6532
 kelvin/api/client/dataframe_conversion.py,sha256=8Lz9D22J8D-0r5qPjjGHp7RZNbM_4xa8lu7WOSk5zvs,5130
 kelvin/api/client/deeplist.py,sha256=qLeXTqfnfhugpS6I8nrsJ-N_CkwNscosZSauGY05tWI,8635
 kelvin/api/client/error.py,sha256=2sADlY1dLRFJ396jIHuIdHE6XyxySgdLduOqLzOKzO0,2132
 kelvin/api/client/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 kelvin/api/client/retry.py,sha256=oS1B9EiNsSi9y-clpNer-oTtQIAlbLa2iaUZ1wF29M4,2677
-kelvin/api/client/serialize.py,sha256=u1qYSVYpRIyvOdCJK71XicuK9ZFlG5z6ryY_JqIxotc,6591
+kelvin/api/client/serialize.py,sha256=kZSqUS42rkue0FfLOr0xZWVql3kXj9-TfTbbJYFpwGs,6663
 kelvin/api/client/utils.py,sha256=_P7aINdQVD2ZncAie_99ZxjV7CLxKpWbZUsj7wmlJ4M,7940
-kelvin/api/client/version.py,sha256=pMnmqZnpVmaqR5nqHztNWzbbtb1oy5bPN_v7uhOH8K8,411
-kelvin/api/client/api/app_manager.py,sha256=egov556lXKNQOV1Hu0urzAwU4Af-hYGyEpnOqxnM-ig,23238
-kelvin/api/client/api/app_registry.py,sha256=VTL4cBCnV06F9_n9Hvt_zxIobkKiCReG9BapGtFlmzc,11529
-kelvin/api/client/api/asset.py,sha256=l_bMDrKOY1IQjxpoqw9-rm-NCGa_SbLL4o3WOx3sC_0,34959
-kelvin/api/client/api/asset_insights.py,sha256=orS1yNdsBfAnoK4lKdf9biRCZz5BKLhNYbdT-8y-y80,2258
-kelvin/api/client/api/bridge.py,sha256=Z58XRxqTUblwST3fF_PDB3MfPZH2CIUjqkHArzUzBFs,10510
-kelvin/api/client/api/control_change.py,sha256=GdddgWPjj-yc7nKbrMryneYFxzRjkNcNDRxFWm4swnA,15191
-kelvin/api/client/api/data_tag.py,sha256=Js7Zup0MuZ6LhbSQgVp7Zl66KPDkRurcMBSylctXOuw,15558
-kelvin/api/client/api/datastreams.py,sha256=LDwveFsKFemi_PD6GVXtZhYQX7ztNhHNSkTwUwguIKc,35358
-kelvin/api/client/api/filestorage.py,sha256=Q9ddXVN8ZlMRem1kRFn-WdOuMrQXwRfR6B2BkcqHIJ8,6846
-kelvin/api/client/api/instance.py,sha256=15ZXqW9WwgBg42cGMlvHGGBB2u19aa8q0HZ_FgcgDVA,19581
-kelvin/api/client/api/orchestration.py,sha256=CZputsvqdt1L17t9hg8MYvt0IsibFQbmTEa_YXJ2kAw,27445
-kelvin/api/client/api/parameters.py,sha256=YcThJNeAImkQ15avYFnaHFchel4GpvLhOBuMM1G_gYU,16054
-kelvin/api/client/api/recommendation.py,sha256=mtQcsh5Xdq8FYx5cMOw8RuFK0B5_aUe5H_C4PSmE35k,28980
-kelvin/api/client/api/secret.py,sha256=yHPhZKn60JGIoShKmA3FA-3QNqckoGHyfuWhTmp0OZ8,5694
-kelvin/api/client/api/thread.py,sha256=91wRZMwoR9XB41e1p_41kCeCJKooG5FZQxCOZdNdrWs,11253
-kelvin/api/client/api/timeseries.py,sha256=VLKhwmO4HU1gKWce49nehS5haqaOLd_-IiuCoxiK9WA,9022
-kelvin/api/client/api/user.py,sha256=oshuTa3gsaGr7imtuc8ad_H7v3qzKFCYDR5M5H548m4,13200
-kelvin/api/client/api/workload.py,sha256=c66HNrSjLtkRTJAL9zB0Z57QShkKvoI0Ls1Dco3k_Is,14840
-kelvin/api/client/model/__init__.py,sha256=OchKPZzfNoz_PaoLBl66scOvLvOWub8yGOOnCea9wcA,103
-kelvin/api/client/model/enum.py,sha256=iO7BuBs5kbu07DNmgpafl72KyQJK7wl_lU7kjWsyNVc,1671
-kelvin/api/client/model/pagination.py,sha256=j1B7jL2uxJuZlHTLkniO_Hjm_yx2xn1n5UkKM9bSX2M,1812
-kelvin/api/client/model/requests.py,sha256=n3ujHtkUzR0Wx_hg1Ojc38Lu7mqWyYCrNLhZWdBKLOE,110122
-kelvin/api/client/model/response.py,sha256=FXaxUGAC144eTQtT51DCO8YZd3Budlt-EnXJD78v4ro,2259
-kelvin/api/client/model/responses.py,sha256=GEapSOGebHoqnBslxQeniXpNjQc7SZe4s5gpDSZ3R-o,145363
-kelvin/api/client/model/type.py,sha256=uLnjPdtII3Pwhydn_6BKlJvNDT3Net4JpUin__qZbno,64135
-kelvin_python_api_client-0.0.1.dist-info/METADATA,sha256=2KVlDNLrlkxK0aWzaFjcKvo9BWN3Lw-Ggakm8_yXoRc,2881
-kelvin_python_api_client-0.0.1.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-kelvin_python_api_client-0.0.1.dist-info/top_level.txt,sha256=_6yecVlTrSwEnjc4lO27C8g1RL1Rey_1FVZgL4PjUYY,7
-kelvin_python_api_client-0.0.1.dist-info/RECORD,,
+kelvin/api/client/version.py,sha256=NDHlyIcJZjLz8wKlmD1-pr6me5FHBAYwO_ynLG-37N8,411
+kelvin/api/client/api/app_manager.py,sha256=ScHmwlmNZGD9omRkpRXD6Nq4Sw94WDzTzlCSINMJiE8,23883
+kelvin/api/client/api/app_registry.py,sha256=AK1t3mZVGjdGbqs6i7PJulkgaVdSwq0QuAJ5seFH9Rs,11747
+kelvin/api/client/api/asset.py,sha256=fMTwQrg4dIqw25LyqQnXmXCV9VXmbrUEdGknjgMth_c,35906
+kelvin/api/client/api/asset_insights.py,sha256=FloL-54DvociT5ZGxn72fMYqY1oVTEGAQ9DW4c4QEiA,2469
+kelvin/api/client/api/bridge.py,sha256=408q5bCfL4bKxYmPzYe5lmm6cxEvjeqKMdZXezbQkCI,10723
+kelvin/api/client/api/control_change.py,sha256=QuiuMmta4uZRW0c33oM_SkGTB9K8oAGMboNlu4-0g5A,15840
+kelvin/api/client/api/data_tag.py,sha256=GxgSW7yAYwWonAAJqkogDIxO-mB3Vzl5ehO6P2QZG0w,15920
+kelvin/api/client/api/datastreams.py,sha256=Yz2cLysqiOIljCxwc_wdv30kbpVJXT7UBZ9-Z8TBqzo,36415
+kelvin/api/client/api/filestorage.py,sha256=yuHS2A3KtH1IAb1-qPiYyAYPceOh5E_mWCFhUOzMRT8,7009
+kelvin/api/client/api/instance.py,sha256=baIpqTsOpV0E2Oplf8K7_c705u6JG3kH9kqGy6tn3uU,20019
+kelvin/api/client/api/orchestration.py,sha256=P9KLB3uh6Zmd7tM8BRejlbh-wIVWkCAZ-_xu3agI3mw,28191
+kelvin/api/client/api/parameters.py,sha256=N8kE_ZLM04OG5gY_uKVURuRLPi8hfI8-QkPnBUx-QYc,22415
+kelvin/api/client/api/recommendation.py,sha256=rbphiWUdBLQknymTJDkZAjctHdVlLuDQFfOkRFUuB4c,29814
+kelvin/api/client/api/secret.py,sha256=WfvqFiBSbsjavzzt1iJqovblvxG579-YauNmx5Tk_Yw,5907
+kelvin/api/client/api/thread.py,sha256=bzX2de-nez0EOVlNz8kiVnZFFfUhirxBNXu0qhcMn1I,11270
+kelvin/api/client/api/timeseries.py,sha256=xdmZlJHl5dkWbgTX9ONK5jP6VorPlgsMRn4CFkFNkXQ,9237
+kelvin/api/client/api/user.py,sha256=M20TsVMOH0lV3r4l9SVHzbMZKaDFEQxDMDSsg6FFXnE,13606
+kelvin/api/client/api/workload.py,sha256=ltNH1nnSAdjXDQXvu3a4U7jtUZF6Y1N1odr6W6jsWCc,17724
+kelvin/api/client/model/__init__.py,sha256=skobGA008kOYOEi3WBuI694d59Wkp17UbJhksMtlOtI,103
+kelvin/api/client/model/enum.py,sha256=6J_EzTx2pGhGzPF8alJJ6Zbfc3hV6egFsDg-umSo1SM,2433
+kelvin/api/client/model/pagination.py,sha256=ztpbc6BAtJNhQokHt_VFHpb_HYBBD2u9tftMix2X_rA,1812
+kelvin/api/client/model/requests.py,sha256=UQEHJiHRruWcwwei9tni2meCglmh24QDMQXoEnHyp7U,111310
+kelvin/api/client/model/response.py,sha256=PCJmhwLO8WazDfKqiwWJXGTn11pYCG7Jf-R4Kd27TLw,2259
+kelvin/api/client/model/responses.py,sha256=jwyN4wkMtHHWUyD68ptrSEy7yP78sJM7rnmODtex67g,149548
+kelvin/api/client/model/type.py,sha256=gNmqUPMoM4AzQlQxsrs0uHeZ8GPY69TKn9sHm8BllbU,62707
+kelvin_python_api_client-0.0.2.dist-info/METADATA,sha256=KOBFQ2nLF0B1x27V9LYpgaHgbvKuVEgAtaOrJexEwAg,2881
+kelvin_python_api_client-0.0.2.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+kelvin_python_api_client-0.0.2.dist-info/top_level.txt,sha256=_6yecVlTrSwEnjc4lO27C8g1RL1Rey_1FVZgL4PjUYY,7
+kelvin_python_api_client-0.0.2.dist-info/RECORD,,
```

