# Comparing `tmp/tidy3d-2.6.4.tar.gz` & `tmp/tidy3d-2.7.0rc1.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "tidy3d-2.6.4.tar", max compression
+gzip compressed data, was "tidy3d-2.7.0rc1.tar", max compression
```

## Comparing `tidy3d-2.6.4.tar` & `tidy3d-2.7.0rc1.tar`

### file list

```diff
@@ -1,163 +1,184 @@
--rw-r--r--   0        0        0    26526 2024-04-24 16:20:11.278678 tidy3d-2.6.4/LICENSE
--rw-r--r--   0        0        0     4867 2024-04-24 16:20:11.278678 tidy3d-2.6.4/README.md
--rw-r--r--   0        0        0     7564 2024-04-24 16:20:11.330678 tidy3d-2.6.4/pyproject.toml
--rw-r--r--   0        0        0     2978 2024-04-24 16:20:11.338678 tidy3d-2.6.4/tidy3d/README.md
--rw-r--r--   0        0        0    10818 2024-04-24 16:20:11.338678 tidy3d-2.6.4/tidy3d/__init__.py
--rw-r--r--   0        0        0     3085 2024-04-24 16:20:11.338678 tidy3d-2.6.4/tidy3d/__main__.py
--rw-r--r--   0        0        0    10303 2024-04-24 16:20:11.338678 tidy3d-2.6.4/tidy3d/components/README.md
--rw-r--r--   0        0        0        0 2024-04-24 16:20:11.338678 tidy3d-2.6.4/tidy3d/components/__init__.py
--rw-r--r--   0        0        0     3228 2024-04-24 16:20:11.338678 tidy3d-2.6.4/tidy3d/components/apodization.py
--rw-r--r--   0        0        0    35578 2024-04-24 16:20:11.338678 tidy3d-2.6.4/tidy3d/components/base.py
--rw-r--r--   0        0        0        0 2024-04-24 16:20:11.338678 tidy3d-2.6.4/tidy3d/components/base_sim/__init__.py
--rw-r--r--   0        0        0        0 2024-04-24 16:20:11.338678 tidy3d-2.6.4/tidy3d/components/base_sim/data/__init__.py
--rw-r--r--   0        0        0      666 2024-04-24 16:20:11.338678 tidy3d-2.6.4/tidy3d/components/base_sim/data/monitor_data.py
--rw-r--r--   0        0        0     4710 2024-04-24 16:20:11.338678 tidy3d-2.6.4/tidy3d/components/base_sim/data/sim_data.py
--rw-r--r--   0        0        0     3061 2024-04-24 16:20:11.338678 tidy3d-2.6.4/tidy3d/components/base_sim/monitor.py
--rw-r--r--   0        0        0    23738 2024-04-24 16:20:11.338678 tidy3d-2.6.4/tidy3d/components/base_sim/simulation.py
--rw-r--r--   0        0        0      633 2024-04-24 16:20:11.338678 tidy3d-2.6.4/tidy3d/components/base_sim/source.py
--rw-r--r--   0        0        0     3211 2024-04-24 16:20:11.338678 tidy3d-2.6.4/tidy3d/components/bc_placement.py
--rw-r--r--   0        0        0    33071 2024-04-24 16:20:11.338678 tidy3d-2.6.4/tidy3d/components/boundary.py
--rw-r--r--   0        0        0     9733 2024-04-24 16:20:11.338678 tidy3d-2.6.4/tidy3d/components/data/README.md
--rw-r--r--   0        0        0        0 2024-04-24 16:20:11.338678 tidy3d-2.6.4/tidy3d/components/data/__init__.py
--rw-r--r--   0        0        0    23366 2024-04-24 16:20:11.338678 tidy3d-2.6.4/tidy3d/components/data/data_array.py
--rw-r--r--   0        0        0    58738 2024-04-24 16:20:11.338678 tidy3d-2.6.4/tidy3d/components/data/dataset.py
--rw-r--r--   0        0        0   105026 2024-04-24 16:20:11.338678 tidy3d-2.6.4/tidy3d/components/data/monitor_data.py
--rw-r--r--   0        0        0    31485 2024-04-24 16:20:11.338678 tidy3d-2.6.4/tidy3d/components/data/sim_data.py
--rw-r--r--   0        0        0     2344 2024-04-24 16:20:11.338678 tidy3d-2.6.4/tidy3d/components/data/validators.py
--rw-r--r--   0        0        0    38186 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/field_projection.py
--rw-r--r--   0        0        0      823 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/file_util.py
--rw-r--r--   0        0        0        0 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/geometry/__init__.py
--rw-r--r--   0        0        0   103970 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/geometry/base.py
--rw-r--r--   0        0        0    17269 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/geometry/mesh.py
--rw-r--r--   0        0        0    62546 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/geometry/polyslab.py
--rw-r--r--   0        0        0    23375 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/geometry/primitives.py
--rw-r--r--   0        0        0     4013 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/geometry/triangulation.py
--rw-r--r--   0        0        0     7648 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/geometry/utils.py
--rw-r--r--   0        0        0     8383 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/geometry/utils_2d.py
--rw-r--r--   0        0        0        0 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/grid/__init__.py
--rw-r--r--   0        0        0    18411 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/grid/grid.py
--rw-r--r--   0        0        0    26013 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/grid/grid_spec.py
--rw-r--r--   0        0        0    50912 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/grid/mesher.py
--rw-r--r--   0        0        0        0 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/heat/__init__.py
--rw-r--r--   0        0        0     2340 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/heat/boundary.py
--rw-r--r--   0        0        0        0 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/heat/data/__init__.py
--rw-r--r--   0        0        0     3807 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/heat/data/monitor_data.py
--rw-r--r--   0        0        0    10737 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/heat/data/sim_data.py
--rw-r--r--   0        0        0     3871 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/heat/grid.py
--rw-r--r--   0        0        0     1629 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/heat/monitor.py
--rw-r--r--   0        0        0    35561 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/heat/simulation.py
--rw-r--r--   0        0        0     1579 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/heat/source.py
--rw-r--r--   0        0        0      347 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/heat/viz.py
--rw-r--r--   0        0        0     1135 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/heat_spec.py
--rw-r--r--   0        0        0   208534 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/medium.py
--rw-r--r--   0        0        0     9497 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/mode.py
--rw-r--r--   0        0        0    60115 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/monitor.py
--rw-r--r--   0        0        0    35480 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/parameter_perturbation.py
--rw-r--r--   0        0        0    51297 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/scene.py
--rw-r--r--   0        0        0   167277 2024-04-24 16:20:11.342678 tidy3d-2.6.4/tidy3d/components/simulation.py
--rw-r--r--   0        0        0    42331 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/components/source.py
--rw-r--r--   0        0        0    18017 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/components/structure.py
--rw-r--r--   0        0        0     7081 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/components/time.py
--rw-r--r--   0        0        0    10164 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/components/time_modulation.py
--rw-r--r--   0        0        0     3562 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/components/transformation.py
--rw-r--r--   0        0        0     7251 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/components/types.py
--rw-r--r--   0        0        0      362 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/components/types_extra.py
--rw-r--r--   0        0        0    15102 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/components/validators.py
--rw-r--r--   0        0        0    12649 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/components/viz.py
--rw-r--r--   0        0        0     1621 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/config.py
--rw-r--r--   0        0        0     2988 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/constants.py
--rw-r--r--   0        0        0     1265 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/exceptions.py
--rw-r--r--   0        0        0    15149 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/log.py
--rw-r--r--   0        0        0        0 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/material_library/__init__.py
--rw-r--r--   0        0        0    70598 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/material_library/material_library.py
--rw-r--r--   0        0        0     9498 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/material_library/material_reference.py
--rw-r--r--   0        0        0    15924 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/material_library/parametric_materials.py
--rw-r--r--   0        0        0     5708 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/packaging.py
--rw-r--r--   0        0        0       77 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/__init__.py
--rw-r--r--   0        0        0    33133 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/adjoint/README.md
--rw-r--r--   0        0        0     1416 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/adjoint/__init__.py
--rw-r--r--   0        0        0      898 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/adjoint/components/__init__.py
--rw-r--r--   0        0        0    10610 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/adjoint/components/base.py
--rw-r--r--   0        0        0        0 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/adjoint/components/data/__init__.py
--rw-r--r--   0        0        0    19097 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/adjoint/components/data/data_array.py
--rw-r--r--   0        0        0     1049 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/adjoint/components/data/dataset.py
--rw-r--r--   0        0        0    18604 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/adjoint/components/data/monitor_data.py
--rw-r--r--   0        0        0    10720 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/adjoint/components/data/sim_data.py
--rw-r--r--   0        0        0    26055 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/adjoint/components/geometry.py
--rw-r--r--   0        0        0    16767 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/adjoint/components/medium.py
--rw-r--r--   0        0        0    33012 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/adjoint/components/simulation.py
--rw-r--r--   0        0        0     8598 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/adjoint/components/structure.py
--rw-r--r--   0        0        0     2093 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/adjoint/components/types.py
--rw-r--r--   0        0        0        0 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/adjoint/utils/__init__.py
--rw-r--r--   0        0        0     8126 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/adjoint/utils/filter.py
--rw-r--r--   0        0        0     9065 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/adjoint/utils/penalty.py
--rw-r--r--   0        0        0    29641 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/adjoint/web.py
--rw-r--r--   0        0        0     6401 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/design/README.md
--rw-r--r--   0        0        0      441 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/design/__init__.py
--rw-r--r--   0        0        0     6596 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/design/design.py
--rw-r--r--   0        0        0    14226 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/design/method.py
--rw-r--r--   0        0        0     7087 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/design/parameter.py
--rw-r--r--   0        0        0    11780 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/design/result.py
--rw-r--r--   0        0        0      366 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/dispersion/__init__.py
--rw-r--r--   0        0        0    22651 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/dispersion/fit.py
--rw-r--r--   0        0        0    33833 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/dispersion/fit_fast.py
--rw-r--r--   0        0        0      213 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/dispersion/fit_web.py
--rw-r--r--   0        0        0    13282 2024-04-24 16:20:11.346678 tidy3d-2.6.4/tidy3d/plugins/dispersion/web.py
--rw-r--r--   0        0        0     1213 2024-04-24 16:20:11.350678 tidy3d-2.6.4/tidy3d/plugins/mode/LICENSE
--rw-r--r--   0        0        0       42 2024-04-24 16:20:11.350678 tidy3d-2.6.4/tidy3d/plugins/mode/README.md
--rw-r--r--   0        0        0      138 2024-04-24 16:20:11.350678 tidy3d-2.6.4/tidy3d/plugins/mode/__init__.py
--rw-r--r--   0        0        0     5733 2024-04-24 16:20:11.350678 tidy3d-2.6.4/tidy3d/plugins/mode/derivatives.py
--rw-r--r--   0        0        0    41403 2024-04-24 16:20:11.350678 tidy3d-2.6.4/tidy3d/plugins/mode/mode_solver.py
--rw-r--r--   0        0        0    29953 2024-04-24 16:20:11.350678 tidy3d-2.6.4/tidy3d/plugins/mode/solver.py
--rw-r--r--   0        0        0     4370 2024-04-24 16:20:11.350678 tidy3d-2.6.4/tidy3d/plugins/mode/transforms.py
--rw-r--r--   0        0        0       81 2024-04-24 16:20:11.350678 tidy3d-2.6.4/tidy3d/plugins/mode/web.py
--rw-r--r--   0        0        0      116 2024-04-24 16:20:11.350678 tidy3d-2.6.4/tidy3d/plugins/polyslab/__init__.py
--rw-r--r--   0        0        0     2705 2024-04-24 16:20:11.350678 tidy3d-2.6.4/tidy3d/plugins/polyslab/polyslab.py
--rw-r--r--   0        0        0      117 2024-04-24 16:20:11.350678 tidy3d-2.6.4/tidy3d/plugins/resonance/__init__.py
--rw-r--r--   0        0        0    17644 2024-04-24 16:20:11.350678 tidy3d-2.6.4/tidy3d/plugins/resonance/resonance.py
--rw-r--r--   0        0        0      170 2024-04-24 16:20:11.350678 tidy3d-2.6.4/tidy3d/plugins/smatrix/__init__.py
--rw-r--r--   0        0        0    20777 2024-04-24 16:20:11.350678 tidy3d-2.6.4/tidy3d/plugins/smatrix/smatrix.py
--rw-r--r--   0        0        0      129 2024-04-24 16:20:11.350678 tidy3d-2.6.4/tidy3d/plugins/waveguide/__init__.py
--rw-r--r--   0        0        0    36178 2024-04-24 16:20:11.350678 tidy3d-2.6.4/tidy3d/plugins/waveguide/rectangular_dielectric.py
--rw-r--r--   0        0        0   521876 2024-04-24 16:20:11.350678 tidy3d-2.6.4/tidy3d/schema.json
--rw-r--r--   0        0        0    10908 2024-04-24 16:20:11.350678 tidy3d-2.6.4/tidy3d/updater.py
--rw-r--r--   0        0        0       87 2024-04-24 16:20:11.350678 tidy3d-2.6.4/tidy3d/version.py
--rw-r--r--   0        0        0     1083 2024-04-24 16:20:11.350678 tidy3d-2.6.4/tidy3d/web/__init__.py
--rw-r--r--   0        0        0        0 2024-04-24 16:20:11.350678 tidy3d-2.6.4/tidy3d/web/api/__init__.py
--rw-r--r--   0        0        0     2669 2024-04-24 16:20:11.350678 tidy3d-2.6.4/tidy3d/web/api/asynchronous.py
--rw-r--r--   0        0        0   275233 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/api/cacert.pem
--rw-r--r--   0        0        0     2284 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/api/connect_util.py
--rw-r--r--   0        0        0    28266 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/api/container.py
--rw-r--r--   0        0        0     3792 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/api/material_fitter.py
--rw-r--r--   0        0        0     1449 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/api/material_libray.py
--rw-r--r--   0        0        0    18711 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/api/mode.py
--rw-r--r--   0        0        0     8109 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/api/tidy3d_stub.py
--rw-r--r--   0        0        0    32481 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/api/webapi.py
--rw-r--r--   0        0        0       88 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/cli/__init__.py
--rw-r--r--   0        0        0     3491 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/cli/app.py
--rw-r--r--   0        0        0      348 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/cli/constants.py
--rw-r--r--   0        0        0    63715 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/cli/converter.py
--rw-r--r--   0        0        0     1949 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/cli/develop/__init__.py
--rw-r--r--   0        0        0    12380 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/cli/develop/documentation.py
--rw-r--r--   0        0        0      400 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/cli/develop/index.py
--rw-r--r--   0        0        0    15383 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/cli/develop/install.py
--rw-r--r--   0        0        0     4159 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/cli/develop/packaging.py
--rw-r--r--   0        0        0     1961 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/cli/develop/tests.py
--rw-r--r--   0        0        0     1700 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/cli/develop/utils.py
--rw-r--r--   0        0        0     3590 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/cli/migrate.py
--rw-r--r--   0        0        0     3959 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/cli/readme.md
--rw-r--r--   0        0        0       35 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/core/__init__.py
--rw-r--r--   0        0        0       58 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/core/cache.py
--rw-r--r--   0        0        0      754 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/core/constants.py
--rw-r--r--   0        0        0      940 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/core/core_config.py
--rw-r--r--   0        0        0     4982 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/core/environment.py
--rw-r--r--   0        0        0      331 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/core/exceptions.py
--rw-r--r--   0        0        0     2235 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/core/file_util.py
--rw-r--r--   0        0        0     5917 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/core/http_util.py
--rw-r--r--   0        0        0    12450 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/core/s3utils.py
--rw-r--r--   0        0        0     2243 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/core/stub.py
--rw-r--r--   0        0        0    18838 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/core/task_core.py
--rw-r--r--   0        0        0     2188 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/core/task_info.py
--rw-r--r--   0        0        0     1435 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/core/types.py
--rw-r--r--   0        0        0      132 2024-04-24 16:20:11.354678 tidy3d-2.6.4/tidy3d/web/environment.py
--rw-r--r--   0        0        0     9720 1970-01-01 00:00:00.000000 tidy3d-2.6.4/PKG-INFO
+-rw-r--r--   0        0        0    26526 2024-04-22 21:06:22.038784 tidy3d-2.7.0rc1/LICENSE
+-rw-r--r--   0        0        0     4867 2024-04-22 21:06:22.038784 tidy3d-2.7.0rc1/README.md
+-rw-r--r--   0        0        0     7174 2024-04-22 21:06:22.090783 tidy3d-2.7.0rc1/pyproject.toml
+-rw-r--r--   0        0        0     2978 2024-04-22 21:06:22.098783 tidy3d-2.7.0rc1/tidy3d/README.md
+-rw-r--r--   0        0        0    12776 2024-04-22 21:06:22.098783 tidy3d-2.7.0rc1/tidy3d/__init__.py
+-rw-r--r--   0        0        0     3085 2024-04-22 21:06:22.098783 tidy3d-2.7.0rc1/tidy3d/__main__.py
+-rw-r--r--   0        0        0    10303 2024-04-22 21:06:22.098783 tidy3d-2.7.0rc1/tidy3d/components/README.md
+-rw-r--r--   0        0        0        0 2024-04-22 21:06:22.098783 tidy3d-2.7.0rc1/tidy3d/components/__init__.py
+-rw-r--r--   0        0        0     3228 2024-04-22 21:06:22.098783 tidy3d-2.7.0rc1/tidy3d/components/apodization.py
+-rw-r--r--   0        0        0    37727 2024-04-22 21:06:22.098783 tidy3d-2.7.0rc1/tidy3d/components/base.py
+-rw-r--r--   0        0        0        0 2024-04-22 21:06:22.098783 tidy3d-2.7.0rc1/tidy3d/components/base_sim/__init__.py
+-rw-r--r--   0        0        0        0 2024-04-22 21:06:22.098783 tidy3d-2.7.0rc1/tidy3d/components/base_sim/data/__init__.py
+-rw-r--r--   0        0        0      666 2024-04-22 21:06:22.098783 tidy3d-2.7.0rc1/tidy3d/components/base_sim/data/monitor_data.py
+-rw-r--r--   0        0        0     4710 2024-04-22 21:06:22.098783 tidy3d-2.7.0rc1/tidy3d/components/base_sim/data/sim_data.py
+-rw-r--r--   0        0        0     3061 2024-04-22 21:06:22.098783 tidy3d-2.7.0rc1/tidy3d/components/base_sim/monitor.py
+-rw-r--r--   0        0        0    23738 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/base_sim/simulation.py
+-rw-r--r--   0        0        0      633 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/base_sim/source.py
+-rw-r--r--   0        0        0     3211 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/bc_placement.py
+-rw-r--r--   0        0        0    33071 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/boundary.py
+-rw-r--r--   0        0        0     9733 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/data/README.md
+-rw-r--r--   0        0        0        0 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/data/__init__.py
+-rw-r--r--   0        0        0    27766 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/data/data_array.py
+-rw-r--r--   0        0        0   102019 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/data/dataset.py
+-rw-r--r--   0        0        0   105030 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/data/monitor_data.py
+-rw-r--r--   0        0        0    32494 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/data/sim_data.py
+-rw-r--r--   0        0        0     2344 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/data/validators.py
+-rw-r--r--   0        0        0        0 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/eme/__init__.py
+-rw-r--r--   0        0        0        0 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/eme/data/__init__.py
+-rw-r--r--   0        0        0     4343 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/eme/data/dataset.py
+-rw-r--r--   0        0        0     1404 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/eme/data/monitor_data.py
+-rw-r--r--   0        0        0    12601 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/eme/data/sim_data.py
+-rw-r--r--   0        0        0    19597 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/eme/grid.py
+-rw-r--r--   0        0        0     8711 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/eme/monitor.py
+-rw-r--r--   0        0        0    39773 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/eme/simulation.py
+-rw-r--r--   0        0        0     1590 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/eme/sweep.py
+-rw-r--r--   0        0        0    38186 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/field_projection.py
+-rw-r--r--   0        0        0      823 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/file_util.py
+-rw-r--r--   0        0        0        0 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/geometry/__init__.py
+-rw-r--r--   0        0        0   104460 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/geometry/base.py
+-rw-r--r--   0        0        0    17260 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/geometry/mesh.py
+-rw-r--r--   0        0        0    62537 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/geometry/polyslab.py
+-rw-r--r--   0        0        0    23366 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/geometry/primitives.py
+-rw-r--r--   0        0        0     4013 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/geometry/triangulation.py
+-rw-r--r--   0        0        0     7648 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/geometry/utils.py
+-rw-r--r--   0        0        0     9140 2024-04-22 21:06:22.102783 tidy3d-2.7.0rc1/tidy3d/components/geometry/utils_2d.py
+-rw-r--r--   0        0        0        0 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/grid/__init__.py
+-rw-r--r--   0        0        0    21892 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/grid/grid.py
+-rw-r--r--   0        0        0    28045 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/grid/grid_spec.py
+-rw-r--r--   0        0        0    50912 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/grid/mesher.py
+-rw-r--r--   0        0        0        0 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/heat/__init__.py
+-rw-r--r--   0        0        0     2340 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/heat/boundary.py
+-rw-r--r--   0        0        0        0 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/heat/data/__init__.py
+-rw-r--r--   0        0        0     3807 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/heat/data/monitor_data.py
+-rw-r--r--   0        0        0    10737 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/heat/data/sim_data.py
+-rw-r--r--   0        0        0     3871 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/heat/grid.py
+-rw-r--r--   0        0        0     1629 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/heat/monitor.py
+-rw-r--r--   0        0        0    35943 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/heat/simulation.py
+-rw-r--r--   0        0        0     1579 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/heat/source.py
+-rw-r--r--   0        0        0      347 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/heat/viz.py
+-rw-r--r--   0        0        0     1135 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/heat_spec.py
+-rw-r--r--   0        0        0     5451 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/lumped_element.py
+-rw-r--r--   0        0        0   216885 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/medium.py
+-rw-r--r--   0        0        0     9497 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/mode.py
+-rw-r--r--   0        0        0    60115 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/monitor.py
+-rw-r--r--   0        0        0    39999 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/parameter_perturbation.py
+-rw-r--r--   0        0        0    53836 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/scene.py
+-rw-r--r--   0        0        0   180638 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/simulation.py
+-rw-r--r--   0        0        0    42829 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/source.py
+-rw-r--r--   0        0        0    18102 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/structure.py
+-rw-r--r--   0        0        0     7081 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/time.py
+-rw-r--r--   0        0        0    10164 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/time_modulation.py
+-rw-r--r--   0        0        0     3562 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/transformation.py
+-rw-r--r--   0        0        0     7251 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/types.py
+-rw-r--r--   0        0        0      362 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/types_extra.py
+-rw-r--r--   0        0        0    15509 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/validators.py
+-rw-r--r--   0        0        0    12760 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/components/viz.py
+-rw-r--r--   0        0        0     1621 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/config.py
+-rw-r--r--   0        0        0     3033 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/constants.py
+-rw-r--r--   0        0        0     1265 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/exceptions.py
+-rw-r--r--   0        0        0    15149 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/log.py
+-rw-r--r--   0        0        0        0 2024-04-22 21:06:22.106783 tidy3d-2.7.0rc1/tidy3d/material_library/__init__.py
+-rw-r--r--   0        0        0    73628 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/material_library/material_library.py
+-rw-r--r--   0        0        0     9842 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/material_library/material_reference.py
+-rw-r--r--   0        0        0    15924 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/material_library/parametric_materials.py
+-rw-r--r--   0        0        0     5708 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/packaging.py
+-rw-r--r--   0        0        0       77 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/__init__.py
+-rw-r--r--   0        0        0    33133 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/README.md
+-rw-r--r--   0        0        0     1416 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/__init__.py
+-rw-r--r--   0        0        0      898 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/components/__init__.py
+-rw-r--r--   0        0        0    11473 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/components/base.py
+-rw-r--r--   0        0        0        0 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/components/data/__init__.py
+-rw-r--r--   0        0        0    19097 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/components/data/data_array.py
+-rw-r--r--   0        0        0     1049 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/components/data/dataset.py
+-rw-r--r--   0        0        0    18811 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/components/data/monitor_data.py
+-rw-r--r--   0        0        0    11881 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/components/data/sim_data.py
+-rw-r--r--   0        0        0    26241 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/components/geometry.py
+-rw-r--r--   0        0        0    16979 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/components/medium.py
+-rw-r--r--   0        0        0    35632 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/components/simulation.py
+-rw-r--r--   0        0        0     8930 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/components/structure.py
+-rw-r--r--   0        0        0     2093 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/components/types.py
+-rw-r--r--   0        0        0        0 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/utils/__init__.py
+-rw-r--r--   0        0        0     8126 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/utils/filter.py
+-rw-r--r--   0        0        0    10079 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/utils/penalty.py
+-rw-r--r--   0        0        0    29879 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/web.py
+-rw-r--r--   0        0        0     6401 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/design/README.md
+-rw-r--r--   0        0        0      441 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/design/__init__.py
+-rw-r--r--   0        0        0     6596 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/design/design.py
+-rw-r--r--   0        0        0    14226 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/design/method.py
+-rw-r--r--   0        0        0     7087 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/design/parameter.py
+-rw-r--r--   0        0        0    11780 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/design/result.py
+-rw-r--r--   0        0        0      366 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/dispersion/__init__.py
+-rw-r--r--   0        0        0    22651 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/dispersion/fit.py
+-rw-r--r--   0        0        0    33833 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/dispersion/fit_fast.py
+-rw-r--r--   0        0        0      213 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/dispersion/fit_web.py
+-rw-r--r--   0        0        0    13282 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/dispersion/web.py
+-rw-r--r--   0        0        0      395 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/microwave/__init__.py
+-rw-r--r--   0        0        0     3287 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/microwave/impedance_calculator.py
+-rw-r--r--   0        0        0      159 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/microwave/models/__init__.py
+-rw-r--r--   0        0        0     4130 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/microwave/models/coupled_microstrip.py
+-rw-r--r--   0        0        0     4795 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/microwave/models/microstrip.py
+-rw-r--r--   0        0        0    13499 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/microwave/path_integrals.py
+-rw-r--r--   0        0        0     1213 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/mode/LICENSE
+-rw-r--r--   0        0        0       42 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/mode/README.md
+-rw-r--r--   0        0        0      138 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/mode/__init__.py
+-rw-r--r--   0        0        0     5733 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/mode/derivatives.py
+-rw-r--r--   0        0        0    42914 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/mode/mode_solver.py
+-rw-r--r--   0        0        0    33294 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/mode/solver.py
+-rw-r--r--   0        0        0     4370 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/mode/transforms.py
+-rw-r--r--   0        0        0       81 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/mode/web.py
+-rw-r--r--   0        0        0      116 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/polyslab/__init__.py
+-rw-r--r--   0        0        0     2705 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/polyslab/polyslab.py
+-rw-r--r--   0        0        0      117 2024-04-22 21:06:22.110783 tidy3d-2.7.0rc1/tidy3d/plugins/resonance/__init__.py
+-rw-r--r--   0        0        0    17644 2024-04-22 21:06:22.114783 tidy3d-2.7.0rc1/tidy3d/plugins/resonance/resonance.py
+-rw-r--r--   0        0        0      526 2024-04-22 21:06:22.114783 tidy3d-2.7.0rc1/tidy3d/plugins/smatrix/__init__.py
+-rw-r--r--   0        0        0     8698 2024-04-22 21:06:22.114783 tidy3d-2.7.0rc1/tidy3d/plugins/smatrix/component_modelers/base.py
+-rw-r--r--   0        0        0    15613 2024-04-22 21:06:22.114783 tidy3d-2.7.0rc1/tidy3d/plugins/smatrix/component_modelers/modal.py
+-rw-r--r--   0        0        0    16530 2024-04-22 21:06:22.114783 tidy3d-2.7.0rc1/tidy3d/plugins/smatrix/component_modelers/terminal.py
+-rw-r--r--   0        0        0     6457 2024-04-22 21:06:22.114783 tidy3d-2.7.0rc1/tidy3d/plugins/smatrix/ports/lumped.py
+-rw-r--r--   0        0        0     1605 2024-04-22 21:06:22.114783 tidy3d-2.7.0rc1/tidy3d/plugins/smatrix/ports/modal.py
+-rw-r--r--   0        0        0      212 2024-04-22 21:06:22.114783 tidy3d-2.7.0rc1/tidy3d/plugins/smatrix/smatrix.py
+-rw-r--r--   0        0        0      129 2024-04-22 21:06:22.114783 tidy3d-2.7.0rc1/tidy3d/plugins/waveguide/__init__.py
+-rw-r--r--   0        0        0    36178 2024-04-22 21:06:22.114783 tidy3d-2.7.0rc1/tidy3d/plugins/waveguide/rectangular_dielectric.py
+-rw-r--r--   0        0        0   549925 2024-04-22 21:06:22.114783 tidy3d-2.7.0rc1/tidy3d/schema.json
+-rw-r--r--   0        0        0    10908 2024-04-22 21:06:22.114783 tidy3d-2.7.0rc1/tidy3d/updater.py
+-rw-r--r--   0        0        0       90 2024-04-22 21:06:22.114783 tidy3d-2.7.0rc1/tidy3d/version.py
+-rw-r--r--   0        0        0     1232 2024-04-22 21:06:22.114783 tidy3d-2.7.0rc1/tidy3d/web/__init__.py
+-rw-r--r--   0        0        0        0 2024-04-22 21:06:22.114783 tidy3d-2.7.0rc1/tidy3d/web/api/__init__.py
+-rw-r--r--   0        0        0     2773 2024-04-22 21:06:22.114783 tidy3d-2.7.0rc1/tidy3d/web/api/asynchronous.py
+-rw-r--r--   0        0        0   275233 2024-04-22 21:06:22.114783 tidy3d-2.7.0rc1/tidy3d/web/api/cacert.pem
+-rw-r--r--   0        0        0     2284 2024-04-22 21:06:22.114783 tidy3d-2.7.0rc1/tidy3d/web/api/connect_util.py
+-rw-r--r--   0        0        0    28521 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/api/container.py
+-rw-r--r--   0        0        0     3792 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/api/material_fitter.py
+-rw-r--r--   0        0        0     1449 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/api/material_libray.py
+-rw-r--r--   0        0        0    18711 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/api/mode.py
+-rw-r--r--   0        0        0     8933 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/api/tidy3d_stub.py
+-rw-r--r--   0        0        0    33124 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/api/webapi.py
+-rw-r--r--   0        0        0       88 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/cli/__init__.py
+-rw-r--r--   0        0        0     3491 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/cli/app.py
+-rw-r--r--   0        0        0      348 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/cli/constants.py
+-rw-r--r--   0        0        0    63715 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/cli/converter.py
+-rw-r--r--   0        0        0     1949 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/cli/develop/__init__.py
+-rw-r--r--   0        0        0    12380 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/cli/develop/documentation.py
+-rw-r--r--   0        0        0      400 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/cli/develop/index.py
+-rw-r--r--   0        0        0    15383 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/cli/develop/install.py
+-rw-r--r--   0        0        0     4159 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/cli/develop/packaging.py
+-rw-r--r--   0        0        0     1961 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/cli/develop/tests.py
+-rw-r--r--   0        0        0     1700 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/cli/develop/utils.py
+-rw-r--r--   0        0        0     3590 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/cli/migrate.py
+-rw-r--r--   0        0        0     3959 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/cli/readme.md
+-rw-r--r--   0        0        0       35 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/core/__init__.py
+-rw-r--r--   0        0        0       58 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/core/cache.py
+-rw-r--r--   0        0        0      754 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/core/constants.py
+-rw-r--r--   0        0        0      940 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/core/core_config.py
+-rw-r--r--   0        0        0     4982 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/core/environment.py
+-rw-r--r--   0        0        0      331 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/core/exceptions.py
+-rw-r--r--   0        0        0     2235 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/core/file_util.py
+-rw-r--r--   0        0        0     5917 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/core/http_util.py
+-rw-r--r--   0        0        0    12450 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/core/s3utils.py
+-rw-r--r--   0        0        0     2243 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/core/stub.py
+-rw-r--r--   0        0        0    18838 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/core/task_core.py
+-rw-r--r--   0        0        0     2188 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/core/task_info.py
+-rw-r--r--   0        0        0     1451 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/core/types.py
+-rw-r--r--   0        0        0      132 2024-04-22 21:06:22.118783 tidy3d-2.7.0rc1/tidy3d/web/environment.py
+-rw-r--r--   0        0        0     9233 1970-01-01 00:00:00.000000 tidy3d-2.7.0rc1/PKG-INFO
```

### Comparing `tidy3d-2.6.4/LICENSE` & `tidy3d-2.7.0rc1/LICENSE`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/README.md` & `tidy3d-2.7.0rc1/README.md`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/pyproject.toml` & `tidy3d-2.7.0rc1/pyproject.toml`

 * *Files 6% similar despite different names*

```diff
@@ -1,39 +1,41 @@
 [tool.poetry]
 name = "tidy3d"
-version = "2.6.4"
+version = "2.7.0rc1"
 description = "A fast FDTD solver"
 authors = ["Tyler Hughes <tyler@flexcompute.com>"]
 license = "LGPLv2+"
 readme = "README.md"
 homepage = "https://github.com/flexcompute/tidy3d"
 repository = "https://github.com/flexcompute/tidy3d"
 classifiers = [
     "License :: OSI Approved :: GNU Lesser General Public License v2 or later (LGPLv2+)",
     "Programming Language :: Python :: 3.9",
     "Programming Language :: Python :: 3.10",
     "Programming Language :: Python :: 3.11",
+    "Programming Language :: Python :: 3.12",
     "Operating System :: OS Independent",
 ]
 documentation = "https://docs.flexcompute.com/projects/tidy3d/en/latest/"
 
 [tool.poetry.urls]
 "Bug Tracker" = "https://github.com/flexcompute/tidy3d/issues"
 
 [tool.poetry.dependencies]
-python = ">=3.9,<3.12"
+python = ">=3.9,<4.0.0"
 pyroots = ">=0.5.0"
 xarray = ">=0.16.2"
 importlib-metadata = ">=6.0.0"
 h5netcdf = "1.0.2"
 h5py = "^3.0.0"
 rich = "<12.6.0"
 numpy = "<2"
 matplotlib = "*"
 shapely = "^2.0"
+pandas = "<=2.2.1"
 pydantic = "^2.0"
 PyYAML = "*"
 dask = "*"
 toml = "*"
 ### NOT CORE
 scipy = "*"
 boto3 = "1.28.*"
@@ -62,29 +64,21 @@
 # gdspy
 gdspy = {version="*", optional = true}
 
 # gdstk
 gdstk = {version=">=0.9.49", optional = true}
 
 # jax
-jaxlib = [
-    {version = ">=0.4.1,<=0.4.14", platform = "linux",  source="jaxsource", optional = true},
-    {version = ">=0.4.1,<=0.4.14", platform = "darwin",  source="jaxsource", optional = true},
-    {version = ">=0.4.13,<=0.4.14", platform = "win32", source="jaxsource", python = "^3.9", optional = true}
-]
-jax = [
-    {version = ">=0.4.1,<=0.4.14", extras = ["cpu"], platform = "linux", source="jaxsource", optional = true},
-    {version = ">=0.4.1,<=0.4.14", extras = ["cpu"], platform = "darwin",  source="jaxsource", optional = true},
-    {version = ">=0.4.13,<=0.4.14", extras = ["cpu"], platform = "win32", python = "^3.9", source="jaxsource", optional = true}
-]
+jaxlib = {version = "^0.4.13,<=0.4.26", source="jaxsource", optional = true}
+jax = {version = "^0.4.13,<=0.4.26", extras = ["cpu"], source="jaxsource", optional = true}
 
 # trimesh
 networkx = {version = "^2.6.3", optional = true}
-rtree = {version = "1.0.1", optional = true}
-trimesh = {version = "3.20.0", optional = true}
+rtree = {version = "1.2.0", optional = true}
+trimesh = {version = "^4", optional = true}
 
 # docs
 jupyter = {version="*", optional = true}
 jinja2 = {version = ">=3.1.2", optional = true}
 nbconvert = {version = ">=7.11.0", optional = true}
 sphinx = {version=">=6", optional = true}
 nbsphinx = {version = ">=0.8.7", optional = true}
@@ -96,18 +90,19 @@
 grcwa = {version="*", optional = true}
 sphinx-favicon = {version="*", optional = true}
 sphinx-sitemap = {version=">=2.5.1", optional = true}
 sphinx-notfound-page = {version="*", optional = true}
 sphinx-tabs = {version="*", optional = true}
 nbdime = {version="*", optional = true}
 myst-parser = {version="*", optional = true}
-optax = {version="*", optional = true}
+optax = {version=">=0.2.2", optional = true}
 signac = {version="*", optional = true}
+flax = {version=">=0.8.2", optional = true}
 sax = {version="*", optional = true}
-vtk = {version="<=9.2.6", optional = true}
+vtk = {version=">=9.2.6", optional = true}
 pyswarms = {version="*", optional = true}
 sphinxemoji = {version="*", optional = true}
 devsim = {version="*", optional = true}
 cma = {version="*", optional = true}
 
 [tool.poetry.extras]
 dev = ['bump-my-version', 'black', "coverage", 'dill', 'divparams', 'gdspy', 'gdstk', 'gdstk', 'grcwa', 'ipython', 'ipython', 'jax', 'jaxlib', 'jinja2',
@@ -182,15 +177,15 @@
   "C",  # flake8-comprehensions
   "B",  # flake8-bugbear
   "UP",
   "NPY201", # numpy 2.* compatibility check
 ]
 
 [tool.bumpversion]
-current_version = "2.6.4"
+current_version = "2.6.3"
 parse = """(?x)
     (?P<major>0|[1-9]\\d*)\\.
     (?P<minor>0|[1-9]\\d*)\\.
     (?P<patch>0|[1-9]\\d*)
     (?:
         -                             # dash seperator for pre-release section
         (?P<pre_l>[a-zA-Z-]+)         # pre-release label
```

### Comparing `tidy3d-2.6.4/tidy3d/README.md` & `tidy3d-2.7.0rc1/tidy3d/README.md`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/__init__.py` & `tidy3d-2.7.0rc1/tidy3d/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,12 +1,14 @@
 """ Tidy3d package imports"""
 
 # grid
 from .components.grid.grid import Grid, Coords
 from .components.grid.grid_spec import GridSpec, UniformGrid, CustomGrid, AutoGrid
+from .components.grid.grid_spec import BenklerConformalMeshSpec, StaircasingConformalMeshSpec
+from .components.grid.grid_spec import HeuristicConformalMeshSpec
 
 # geometry
 from .components.geometry.base import Box, Transformed, ClipOperation, GeometryGroup
 from .components.geometry.primitives import Sphere, Cylinder
 from .components.geometry.mesh import TriangleMesh
 from .components.geometry.polyslab import PolySlab
 
@@ -46,14 +48,17 @@
 # monitors
 from .components.monitor import FieldMonitor, FieldTimeMonitor, FluxMonitor, FluxTimeMonitor
 from .components.monitor import ModeMonitor, ModeSolverMonitor, PermittivityMonitor
 from .components.monitor import FieldProjectionAngleMonitor, FieldProjectionCartesianMonitor
 from .components.monitor import FieldProjectionKSpaceMonitor, FieldProjectionSurface
 from .components.monitor import DiffractionMonitor
 
+# lumped elements
+from .components.lumped_element import LumpedResistor
+
 # simulation
 from .components.simulation import Simulation
 
 # field projection
 
 from .components.field_projection import FieldProjector
 
@@ -129,14 +134,29 @@
 from .components.heat.data.sim_data import HeatSimulationData
 from .components.heat.data.monitor_data import TemperatureData
 from .components.heat.boundary import TemperatureBC, ConvectionBC, HeatFluxBC, HeatBoundarySpec
 from .components.heat.source import UniformHeatSource
 from .components.heat.monitor import TemperatureMonitor
 from .components.heat.grid import UniformUnstructuredGrid, DistanceUnstructuredGrid
 
+# EME
+from .components.eme.simulation import EMESimulation
+from .components.eme.data.sim_data import EMESimulationData
+from .components.eme.monitor import EMECoefficientMonitor, EMEModeSolverMonitor, EMEFieldMonitor
+from .components.eme.monitor import EMEMonitor
+from .components.data.data_array import EMESMatrixDataArray, EMEScalarFieldDataArray
+from .components.data.data_array import EMECoefficientDataArray
+from .components.data.data_array import EMEScalarModeFieldDataArray, EMEModeIndexDataArray
+from .components.eme.data.dataset import EMEFieldDataset, EMECoefficientDataset, EMESMatrixDataset
+from .components.eme.data.dataset import EMEModeSolverDataset
+from .components.eme.data.monitor_data import EMEModeSolverData, EMEFieldData, EMECoefficientData
+from .components.eme.grid import EMEUniformGrid, EMECompositeGrid, EMEExplicitGrid
+from .components.eme.grid import EMEGrid, EMEModeSpec
+from .components.eme.sweep import EMELengthSweep, EMEModeSweep
+
 
 def set_logging_level(level: str) -> None:
     """Raise a warning here instead of setting the logging level."""
     raise DeprecationWarning(
         "``set_logging_level`` no longer supported. "
         f"To set the logging level, call ``tidy3d.config.logging_level = {level}``."
     )
@@ -294,14 +314,15 @@
     "Coords1D",
     "log",
     "set_logging_file",
     "set_logging_console",
     "config",
     "__version__",
     "Updater",
+    "LumpedResistor",
     "Scene",
     "StructureStructureInterface",
     "StructureBoundary",
     "MediumMediumInterface",
     "StructureSimulationBoundary",
     "SimulationBoundary",
     "FluidSpec",
@@ -323,8 +344,37 @@
     "ModulationSpec",
     "PointDataArray",
     "CellDataArray",
     "IndexedDataArray",
     "TriangularGridDataset",
     "TetrahedralGridDataset",
     "medium_from_nk",
+    "BenklerConformalMeshSpec",
+    "StaircasingConformalMeshSpec",
+    "HeuristicConformalMeshSpec",
+    "EMESimulation",
+    "EMESimulationData",
+    "EMEMonitor",
+    "EMEModeSolverMonitor",
+    "EMEFieldMonitor",
+    "EMESMatrixDataArray",
+    "EMEFieldDataset",
+    "EMECoefficientDataset",
+    "EMESMatrixDataset",
+    "EMEModeSolverData",
+    "EMEFieldData",
+    "EMECoefficientData",
+    "EMECoefficientMonitor",
+    "EMEModeSpec",
+    "EMEGrid",
+    "EMEUniformGrid",
+    "EMECompositeGrid",
+    "EMEExplicitGrid",
+    "EMEScalarFieldDataArray",
+    "EMEScalarModeFieldDataArray",
+    "EMEModeIndexDataArray",
+    "EMECoefficientDataArray",
+    "EMEModeSolverDataset",
+    "EMESweepSpec",
+    "EMELengthSweep",
+    "EMEModeSweep",
 ]
```

### Comparing `tidy3d-2.6.4/tidy3d/__main__.py` & `tidy3d-2.7.0rc1/tidy3d/__main__.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/README.md` & `tidy3d-2.7.0rc1/tidy3d/components/README.md`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/apodization.py` & `tidy3d-2.7.0rc1/tidy3d/components/apodization.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/base.py` & `tidy3d-2.7.0rc1/tidy3d/components/base.py`

 * *Files 6% similar despite different names*

```diff
@@ -196,15 +196,69 @@
         """Copy a Tidy3dBaseModel.  With ``deep=True`` as default."""
         if "deep" in kwargs and kwargs["deep"] is False:
             raise ValueError("Can't do shallow copy of component, set `deep=True` in copy().")
         kwargs.update(dict(deep=True))
         new_copy = pydantic.BaseModel.copy(self, **kwargs)
         return self.validate(new_copy.dict())
 
-    def updated_copy(self, **kwargs) -> Tidy3dBaseModel:
+    def updated_copy(self, path: str = None, **kwargs) -> Tidy3dBaseModel:
+        """Make copy of a component instance with ``**kwargs`` indicating updated field values.
+
+        Note
+        ----
+        If ``path`` supplied, applies the updated copy with the update performed on the sub-
+        component corresponding to the path. For indexing into a tuple or list, use the integer
+        value.
+
+        Example
+        -------
+        >>> sim = simulation.updated_copy(size=new_size, path=f"structures/{i}/geometry") # doctest: +SKIP
+        """
+
+        if not path:
+            return self._updated_copy(**kwargs)
+
+        path_components = path.split("/")
+
+        field_name = path_components[0]
+
+        try:
+            sub_component = getattr(self, field_name)
+        except AttributeError as e:
+            raise AttributeError(
+                f"Could not field field '{field_name}' in the sub-component `path`. "
+                f"Found fields of '{tuple(self.__fields__.keys())}'. "
+                "Please double check the `path` passed to `.updated_copy()`."
+            ) from e
+
+        if isinstance(sub_component, (list, tuple)):
+            integer_index_path = path_components[1]
+
+            try:
+                index = int(integer_index_path)
+            except ValueError:
+                raise ValueError(
+                    f"Could not grab integer index from path '{path}'. "
+                    f"Please correct the sub path containing '{integer_index_path}' to be an "
+                    f"integer index into '{field_name}' (containing {len(sub_component)} elements)."
+                )
+
+            sub_component_list = list(sub_component)
+            sub_component = sub_component_list[index]
+            sub_path = "/".join(path_components[2:])
+
+            sub_component_list[index] = sub_component.updated_copy(path=sub_path, **kwargs)
+            new_component = tuple(sub_component_list)
+        else:
+            sub_path = "/".join(path_components[1:])
+            new_component = sub_component.updated_copy(path=sub_path, **kwargs)
+
+        return self._updated_copy(**{field_name: new_component})
+
+    def _updated_copy(self, **kwargs) -> Tidy3dBaseModel:
         """Make copy of a component instance with ``**kwargs`` indicating updated field values."""
         return self.copy(update=kwargs)
 
     def help(self, methods: bool = False) -> None:
         """Prints message describing the fields and methods of a :class:`Tidy3dBaseModel`.
 
         Parameters
```

### Comparing `tidy3d-2.6.4/tidy3d/components/base_sim/data/monitor_data.py` & `tidy3d-2.7.0rc1/tidy3d/components/base_sim/data/monitor_data.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/base_sim/data/sim_data.py` & `tidy3d-2.7.0rc1/tidy3d/components/base_sim/data/sim_data.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/base_sim/monitor.py` & `tidy3d-2.7.0rc1/tidy3d/components/base_sim/monitor.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/base_sim/simulation.py` & `tidy3d-2.7.0rc1/tidy3d/components/base_sim/simulation.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/base_sim/source.py` & `tidy3d-2.7.0rc1/tidy3d/components/base_sim/source.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/bc_placement.py` & `tidy3d-2.7.0rc1/tidy3d/components/bc_placement.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/boundary.py` & `tidy3d-2.7.0rc1/tidy3d/components/boundary.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/data/README.md` & `tidy3d-2.7.0rc1/tidy3d/components/data/README.md`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/data/data_array.py` & `tidy3d-2.7.0rc1/tidy3d/components/data/data_array.py`

 * *Files 10% similar despite different names*

```diff
@@ -24,14 +24,19 @@
     "x": {"units": MICROMETER, "long_name": "x position"},
     "y": {"units": MICROMETER, "long_name": "y position"},
     "z": {"units": MICROMETER, "long_name": "z position"},
     "f": {"units": HERTZ, "long_name": "frequency"},
     "t": {"units": SECOND, "long_name": "time"},
     "direction": {"long_name": "propagation direction"},
     "mode_index": {"long_name": "mode index"},
+    "eme_port_index": {"long_name": "EME port index"},
+    "eme_cell_index": {"long_name": "EME cell index"},
+    "mode_index_in": {"long_name": "mode index in"},
+    "mode_index_out": {"long_name": "mode index out"},
+    "sweep_index": {"long_name": "sweep index"},
     "theta": {"units": RADIAN, "long_name": "elevation angle"},
     "phi": {"units": RADIAN, "long_name": "azimuth angle"},
     "ux": {"long_name": "normalized kx"},
     "uy": {"long_name": "normalized ky"},
     "orders_x": {"long_name": "diffraction order"},
     "orders_y": {"long_name": "diffraction order"},
     "face_index": {"long_name": "face index"},
@@ -164,19 +169,19 @@
 
     @classmethod
     def from_hdf5(cls, fname: str, group_path: str) -> DataArray:
         """Load an DataArray from an hdf5 file with a given path to the group."""
         with h5py.File(fname, "r") as f:
             sub_group = f[group_path]
             values = np.array(sub_group[DATA_ARRAY_VALUE_NAME])
-            coords = {dim: np.array(sub_group[dim]) for dim in cls._dims}
+            coords = {dim: np.array(sub_group[dim]) for dim in cls._dims if dim in sub_group}
             for key, val in coords.items():
                 if val.dtype == "O":
                     coords[key] = [byte_string.decode() for byte_string in val.tolist()]
-            return cls(values, coords=coords)
+            return cls(values, coords=coords, dims=cls._dims)
 
     @classmethod
     def from_file(cls, fname: str, group_path: str) -> DataArray:
         """Load an DataArray from an hdf5 file with a given path to the group."""
         if ".hdf5" not in fname:
             raise FileError(
                 "DataArray objects must be written to '.hdf5' format. "
@@ -646,14 +651,138 @@
     >>> td = HeatDataArray((1+1j) * np.random.random((3,)), coords=dict(T=T))
     """
 
     __slots__ = ()
     _dims = "T"
 
 
+class EMEScalarModeFieldDataArray(AbstractSpatialDataArray):
+    """Spatial distribution of a mode in frequency-domain as a function of mode index
+    and EME cell index.
+
+    Example
+    -------
+    >>> x = [1,2]
+    >>> y = [2,3,4]
+    >>> z = [3]
+    >>> f = [2e14, 3e14]
+    >>> mode_index = np.arange(5)
+    >>> eme_cell_index = np.arange(5)
+    >>> coords = dict(x=x, y=y, z=z, f=f, mode_index=mode_index, eme_cell_index=eme_cell_index)
+    >>> fd = EMEScalarModeFieldDataArray((1+1j) * np.random.random((2,3,1,2,5,5)), coords=coords)
+    """
+
+    __slots__ = ()
+    _dims = ("x", "y", "z", "f", "mode_index", "eme_cell_index")
+
+
+class EMEFreqModeDataArray(DataArray):
+    """Array over frequency, mode index, and EME cell index.
+
+    Example
+    -------
+    >>> f = [2e14, 3e14]
+    >>> mode_index = np.arange(5)
+    >>> eme_cell_index = np.arange(5)
+    >>> coords = dict(f=f, mode_index=mode_index, eme_cell_index=eme_cell_index)
+    >>> fd = EMEFreqModeDataArray((1+1j) * np.random.random((2, 5, 5)), coords=coords)
+    """
+
+    __slots__ = ()
+    _dims = ("f", "mode_index", "eme_cell_index")
+
+
+class EMEScalarFieldDataArray(AbstractSpatialDataArray):
+    """Spatial distribution of a field excited from an EME port in frequency-domain as a
+    function of mode index at the EME port and the EME port index.
+
+    Example
+    -------
+    >>> x = [1,2]
+    >>> y = [2,3,4]
+    >>> z = [3,4,5,6]
+    >>> f = [2e14, 3e14]
+    >>> mode_index = np.arange(5)
+    >>> eme_port_index = [0, 1]
+    >>> coords = dict(x=x, y=y, z=z, f=f, mode_index=mode_index, eme_port_index=eme_port_index)
+    >>> fd = EMEScalarFieldDataArray((1+1j) * np.random.random((2,3,4,2,5,2)), coords=coords)
+    """
+
+    __slots__ = ()
+    _dims = ("x", "y", "z", "f", "mode_index", "eme_port_index")
+
+
+class EMECoefficientDataArray(DataArray):
+    """EME expansion coefficient of the mode `mode_index_out` in the EME cell
+    `eme_cell_index`, when excited from mode `mode_index_in` of EME port `eme_port_index`.
+
+    Example
+    -------
+    >>> mode_index_in = [0, 1]
+    >>> mode_index_out = [0, 1]
+    >>> eme_cell_index = np.arange(5)
+    >>> eme_port_index = [0, 1]
+    >>> f = [2e14]
+    >>> coords = dict(
+    ...     f=f,
+    ...     mode_index_out=mode_index_out,
+    ...     mode_index_in=mode_index_in,
+    ...     eme_cell_index=eme_cell_index,
+    ...     eme_port_index=eme_port_index
+    ... )
+    >>> fd = EMESMatrixDataArray((1 + 1j) * np.random.random((1, 2, 2, 5, 2)), coords=coords)
+    """
+
+    __slots__ = ()
+    _dims = ("f", "mode_index_out", "mode_index_in", "eme_cell_index", "eme_port_index")
+    _data_attrs = {"long_name": "mode expansion coefficient"}
+
+
+class EMESMatrixDataArray(DataArray):
+    """Scattering matrix elements for a fixed pair of ports, possibly with an extra
+    sweep index.
+
+    Example
+    -------
+    >>> mode_index_in = [0, 1]
+    >>> mode_index_out = [0, 1, 2]
+    >>> f = [2e14]
+    >>> sweep_index = np.arange(10)
+    >>> coords = dict(
+    ...     f=f,
+    ...     mode_index_out=mode_index_out,
+    ...     mode_index_in=mode_index_in,
+    ...     sweep_index=sweep_index
+    ... )
+    >>> fd = EMESMatrixDataArray((1 + 1j) * np.random.random((1, 3, 2, 10)), coords=coords)
+    """
+
+    __slots__ = ()
+    _dims = ("f", "mode_index_out", "mode_index_in", "sweep_index")
+    _data_attrs = {"long_name": "scattering matrix element"}
+
+
+class EMEModeIndexDataArray(DataArray):
+    """Complex-valued effective propagation index of an EME mode,
+    also indexed by EME cell.
+
+    Example
+    -------
+    >>> f = [2e14, 3e14]
+    >>> mode_index = np.arange(4)
+    >>> eme_cell_index = np.arange(5)
+    >>> coords = dict(f=f, mode_index=mode_index, eme_cell_index=eme_cell_index)
+    >>> data = EMEModeIndexDataArray((1+1j) * np.random.random((2,4,5)), coords=coords)
+    """
+
+    __slots__ = ()
+    _dims = ("f", "mode_index", "eme_cell_index")
+    _data_attrs = {"long_name": "Propagation index"}
+
+
 class ChargeDataArray(DataArray):
     """Charge data array.
 
     Example
     -------
     >>> n = [0, 1e-12, 2e-12]
     >>> p = [0, 3e-12, 4e-12]
@@ -740,13 +869,19 @@
     DiffractionDataArray,
     FreqModeDataArray,
     FreqDataArray,
     TimeDataArray,
     FreqModeDataArray,
     TriangleMeshDataArray,
     HeatDataArray,
+    EMEScalarFieldDataArray,
+    EMEScalarModeFieldDataArray,
+    EMESMatrixDataArray,
+    EMECoefficientDataArray,
+    EMEModeIndexDataArray,
+    EMEFreqModeDataArray,
     ChargeDataArray,
     PointDataArray,
     CellDataArray,
     IndexedDataArray,
 ]
 DATA_ARRAY_MAP = {data_array.__name__: data_array for data_array in DATA_ARRAY_TYPES}
```

### Comparing `tidy3d-2.6.4/tidy3d/components/data/dataset.py` & `tidy3d-2.7.0rc1/tidy3d/components/monitor.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,1680 +1,1410 @@
-"""Collections of DataArrays."""
-from __future__ import annotations
-
+"""Objects that define how data is recorded from simulation."""
 from abc import ABC, abstractmethod
-from typing import Union, Dict, Callable, Any
+from typing import Union, Tuple
 
-import xarray as xr
+import pydantic.v1 as pydantic
 import numpy as np
-import pydantic.v1 as pd
-from matplotlib.tri import Triangulation
-from matplotlib import pyplot as plt
-import numbers
-
-from .data_array import DataArray
-from .data_array import ScalarFieldDataArray, ScalarFieldTimeDataArray, ScalarModeFieldDataArray
-from .data_array import ModeIndexDataArray, GroupIndexDataArray, ModeDispersionDataArray
-from .data_array import TriangleMeshDataArray
-from .data_array import TimeDataArray
-from .data_array import PointDataArray, IndexedDataArray, CellDataArray, SpatialDataArray
-
-from ..viz import equal_aspect, add_ax_if_none, plot_params_grid
-from ..base import Tidy3dBaseModel, cached_property
-from ..base import skip_if_fields_missing
-from ..types import Axis, Bound, ArrayLike, Ax, Coordinate, Literal
-from ...packaging import vtk, requires_vtk
-from ...exceptions import DataError, ValidationError, Tidy3dNotImplementedError
-from ...constants import PICOSECOND_PER_NANOMETER_PER_KILOMETER
-from ...log import log
-
-
-class Dataset(Tidy3dBaseModel, ABC):
-    """Abstract base class for objects that store collections of `:class:`.DataArray`s."""
 
+from .types import Ax, EMField, ArrayFloat1D, FreqArray, FreqBound, Bound, Size
+from .types import Literal, Direction, Coordinate, Axis, ObsGridArray, BoxSurface
+from .validators import assert_plane, validate_freqs_not_empty, validate_freqs_min
+from .base import cached_property, Tidy3dBaseModel, skip_if_fields_missing
+from .mode import ModeSpec
+from .apodization import ApodizationSpec
+from .medium import MediumType
+from .viz import ARROW_COLOR_MONITOR, ARROW_ALPHA
+from ..constants import HERTZ, SECOND, MICROMETER, RADIAN, inf
+from ..exceptions import SetupError, ValidationError
+from ..log import log
+
+from .base_sim.monitor import AbstractMonitor
+
+BYTES_REAL = 4
+BYTES_COMPLEX = 8
+WARN_NUM_FREQS = 2000
+WARN_NUM_MODES = 100
+
+# Field projection windowing factor that determines field decay at the edges of surface field
+# projection monitors. A value of 15 leads to a decay of < 1e-3x in field amplitude.
+# This number relates directly to the standard deviation of the Gaussian function which is used
+# for windowing the monitor.
+WINDOW_FACTOR = 15
+
+
+class Monitor(AbstractMonitor):
+    """Abstract base class for monitors."""
+
+    interval_space: Tuple[Literal[1], Literal[1], Literal[1]] = pydantic.Field(
+        (1, 1, 1),
+        title="Spatial Interval",
+        description="Number of grid step intervals between monitor recordings. If equal to 1, "
+        "there will be no downsampling. If greater than 1, the step will be applied, but the "
+        "first and last point of the monitor grid are always included. "
+        "Not all monitors support values different from 1.",
+    )
+
+    colocate: Literal[True] = pydantic.Field(
+        True,
+        title="Colocate Fields",
+        description="Defines whether fields are colocated to grid cell boundaries (i.e. to the "
+        "primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors "
+        "and is hard-coded for other monitors depending on their specific function.",
+    )
 
-class AbstractFieldDataset(Dataset, ABC):
-    """Collection of scalar fields with some symmetry properties."""
-
-    @property
     @abstractmethod
-    def field_components(self) -> Dict[str, DataArray]:
-        """Maps the field components to their associated data."""
+    def storage_size(self, num_cells: int, tmesh: ArrayFloat1D) -> int:
+        """Size of monitor storage given the number of points after discretization."""
 
-    def apply_phase(self, phase: float) -> AbstractFieldDataset:
-        """Create a copy where all elements are phase-shifted by a value (in radians)."""
-        if phase == 0.0:
-            return self
-        phasor = np.exp(1j * phase)
-        field_components_shifted = {}
-        for fld_name, fld_cmp in self.field_components.items():
-            fld_cmp_shifted = phasor * fld_cmp
-            field_components_shifted[fld_name] = fld_cmp_shifted
-        return self.updated_copy(**field_components_shifted)
+    def _storage_size_solver(self, num_cells: int, tmesh: ArrayFloat1D) -> int:
+        """Size of intermediate data recorded by the monitor during a solver run."""
+        return self.storage_size(num_cells=num_cells, tmesh=tmesh)
 
-    @property
-    @abstractmethod
-    def grid_locations(self) -> Dict[str, str]:
-        """Maps field components to the string key of their grid locations on the yee lattice."""
 
-    @property
-    @abstractmethod
-    def symmetry_eigenvalues(self) -> Dict[str, Callable[[Axis], float]]:
-        """Maps field components to their (positive) symmetry eigenvalues."""
+class FreqMonitor(Monitor, ABC):
+    """:class:`Monitor` that records data in the frequency-domain."""
+
+    freqs: FreqArray = pydantic.Field(
+        ...,
+        title="Frequencies",
+        description="Array or list of frequencies stored by the field monitor.",
+        units=HERTZ,
+    )
+
+    apodization: ApodizationSpec = pydantic.Field(
+        ApodizationSpec(),
+        title="Apodization Specification",
+        description="Sets parameters of (optional) apodization. Apodization applies a windowing "
+        "function to the Fourier transform of the time-domain fields into frequency-domain ones, "
+        "and can be used to truncate the beginning and/or end of the time signal, for example "
+        "to eliminate the source pulse when studying the eigenmodes of a system. Note: apodization "
+        "affects the normalization of the frequency-domain fields.",
+    )
+
+    _freqs_not_empty = validate_freqs_not_empty()
+    _freqs_lower_bound = validate_freqs_min()
+
+    @pydantic.validator("freqs", always=True)
+    def _warn_num_freqs(cls, val, values):
+        """Warn if number of frequencies is too large."""
+        if len(val) > WARN_NUM_FREQS:
+            log.warning(
+                f"A large number ({len(val)}) of frequencies detected in monitor "
+                f"'{values['name']}'. This can lead to solver slow-down and increased cost. "
+                "Consider decreasing the number of frequencies in the monitor. This may become a "
+                "hard limit in future Tidy3D versions.",
+                custom_loc=["freqs"],
+            )
+        return val
 
-    def package_colocate_results(self, centered_fields: Dict[str, ScalarFieldDataArray]) -> Any:
-        """How to package the dictionary of fields computed via self.colocate()."""
-        return xr.Dataset(centered_fields)
-
-    def colocate(self, x=None, y=None, z=None) -> xr.Dataset:
-        """Colocate all of the data at a set of x, y, z coordinates.
-
-        Parameters
-        ----------
-        x : Optional[array-like] = None
-            x coordinates of locations.
-            If not supplied, does not try to colocate on this dimension.
-        y : Optional[array-like] = None
-            y coordinates of locations.
-            If not supplied, does not try to colocate on this dimension.
-        z : Optional[array-like] = None
-            z coordinates of locations.
-            If not supplied, does not try to colocate on this dimension.
+    @cached_property
+    def frequency_range(self) -> FreqBound:
+        """Frequency range of the array ``self.freqs``.
 
         Returns
         -------
-        xr.Dataset
-            Dataset containing all fields at the same spatial locations.
-            For more details refer to `xarray's Documentation <https://tinyurl.com/cyca3krz>`_.
-
-        Note
-        ----
-        For many operations (such as flux calculations and plotting),
-        it is important that the fields are colocated at the same spatial locations.
-        Be sure to apply this method to your field data in those cases.
+        Tuple[float, float]
+            Minimum and maximum frequencies of the frequency array.
         """
+        return (min(self.freqs), max(self.freqs))
 
-        if hasattr(self, "monitor") and self.monitor.colocate:
-            with log as consolidated_logger:
-                consolidated_logger.warning(
-                    "Colocating data that has already been colocated during the solver "
-                    "run. For most accurate results when colocating to custom coordinates set "
-                    "'Monitor.colocate' to 'False' to use the raw data on the Yee grid "
-                    "and avoid double interpolation. Note: the default value was changed to 'True' "
-                    "in Tidy3D version 2.4.0."
-                )
 
-        # convert supplied coordinates to array and assign string mapping to them
-        supplied_coord_map = {k: np.array(v) for k, v in zip("xyz", (x, y, z)) if v is not None}
+class TimeMonitor(Monitor, ABC):
+    """:class:`Monitor` that records data in the time-domain."""
 
-        # dict of data arrays to combine in dataset and return
-        centered_fields = {}
+    start: pydantic.NonNegativeFloat = pydantic.Field(
+        0.0,
+        title="Start Time",
+        description="Time at which to start monitor recording.",
+        units=SECOND,
+    )
 
-        # loop through field components
-        for field_name, field_data in self.field_components.items():
-            # loop through x, y, z dimensions and raise an error if only one element along dim
-            for coord_name, coords_supplied in supplied_coord_map.items():
-                coord_data = np.array(field_data.coords[coord_name])
-                if coord_data.size == 1:
-                    raise DataError(
-                        f"colocate given {coord_name}={coords_supplied}, but "
-                        f"data only has one coordinate at {coord_name}={coord_data[0]}. "
-                        "Therefore, can't colocate along this dimension. "
-                        f"supply {coord_name}=None to skip it."
-                    )
+    stop: pydantic.NonNegativeFloat = pydantic.Field(
+        None,
+        title="Stop Time",
+        description="Time at which to stop monitor recording.  "
+        "If not specified, record until end of simulation.",
+        units=SECOND,
+    )
 
-            centered_fields[field_name] = field_data.interp(
-                **supplied_coord_map, kwargs={"bounds_error": True}
-            )
+    interval: pydantic.PositiveInt = pydantic.Field(
+        None,
+        title="Time Interval",
+        description="Sampling rate of the monitor: number of time steps between each measurement. "
+        "Set ``interval`` to 1 for the highest possible resolution in time. "
+        "Higher integer values downsample the data by measuring every ``interval`` time steps. "
+        "This can be useful for reducing data storage as needed by the application.",
+    )
 
-        # combine all centered fields in a dataset
-        return self.package_colocate_results(centered_fields)
+    @pydantic.validator("interval", always=True)
+    @skip_if_fields_missing(["start", "stop"])
+    def _warn_interval_default(cls, val, values):
+        """If all defaults used for time sampler, warn and set ``interval=1`` internally."""
 
+        if val is None:
+            start = values.get("start")
+            stop = values.get("stop")
+            if start == 0.0 and stop is None:
+                log.warning(
+                    "The monitor 'interval' field was left as its default value, "
+                    "which will set it to 1 internally. "
+                    "A value of 1 means that the data will be sampled at every time step, "
+                    "which may potentially produce more data than desired, "
+                    "depending on the use case. "
+                    "To reduce data storage, one may downsample the data by setting 'interval > 1'"
+                    " or by choosing alternative 'start' and 'stop' values for the time sampling. "
+                    "If you intended to use the highest resolution time sampling, "
+                    "you may suppress this warning "
+                    "by explicitly setting 'interval=1' in the monitor."
+                )
 
-EMScalarFieldType = Union[ScalarFieldDataArray, ScalarFieldTimeDataArray, ScalarModeFieldDataArray]
+            # set 'interval = 1' for backwards compatibility
+            val = 1
 
+        return val
 
-class ElectromagneticFieldDataset(AbstractFieldDataset, ABC):
-    """Stores a collection of E and H fields with x, y, z components."""
+    @pydantic.validator("stop", always=True, allow_reuse=True)
+    @skip_if_fields_missing(["start"])
+    def stop_greater_than_start(cls, val, values):
+        """Ensure sure stop is greater than or equal to start."""
+        start = values.get("start")
+        if val and val < start:
+            raise SetupError("Monitor start time is greater than stop time.")
+        return val
 
-    Ex: EMScalarFieldType = pd.Field(
-        None,
-        title="Ex",
-        description="Spatial distribution of the x-component of the electric field.",
-    )
-    Ey: EMScalarFieldType = pd.Field(
-        None,
-        title="Ey",
-        description="Spatial distribution of the y-component of the electric field.",
-    )
-    Ez: EMScalarFieldType = pd.Field(
-        None,
-        title="Ez",
-        description="Spatial distribution of the z-component of the electric field.",
-    )
-    Hx: EMScalarFieldType = pd.Field(
-        None,
-        title="Hx",
-        description="Spatial distribution of the x-component of the magnetic field.",
-    )
-    Hy: EMScalarFieldType = pd.Field(
-        None,
-        title="Hy",
-        description="Spatial distribution of the y-component of the magnetic field.",
-    )
-    Hz: EMScalarFieldType = pd.Field(
-        None,
-        title="Hz",
-        description="Spatial distribution of the z-component of the magnetic field.",
-    )
+    def time_inds(self, tmesh: ArrayFloat1D) -> Tuple[int, int]:
+        """Compute the starting and stopping index of the monitor in a given discrete time mesh."""
 
-    @property
-    def field_components(self) -> Dict[str, DataArray]:
-        """Maps the field components to their associated data."""
-        fields = {
-            "Ex": self.Ex,
-            "Ey": self.Ey,
-            "Ez": self.Ez,
-            "Hx": self.Hx,
-            "Hy": self.Hy,
-            "Hz": self.Hz,
-        }
-        return {field_name: field for field_name, field in fields.items() if field is not None}
+        tmesh = np.array(tmesh)
+        tind_beg, tind_end = (0, 0)
 
-    @property
-    def grid_locations(self) -> Dict[str, str]:
-        """Maps field components to the string key of their grid locations on the yee lattice."""
-        return dict(Ex="Ex", Ey="Ey", Ez="Ez", Hx="Hx", Hy="Hy", Hz="Hz")
+        if tmesh.size == 0:
+            return (tind_beg, tind_end)
 
-    @property
-    def symmetry_eigenvalues(self) -> Dict[str, Callable[[Axis], float]]:
-        """Maps field components to their (positive) symmetry eigenvalues."""
+        # If monitor.stop is None, record until the end
+        t_stop = self.stop
+        if t_stop is None:
+            tind_end = int(tmesh.size)
+            t_stop = tmesh[-1]
+        else:
+            tend = np.nonzero(tmesh <= t_stop)[0]
+            if tend.size > 0:
+                tind_end = int(tend[-1] + 1)
+
+        # Step to compare to in order to handle t_start = t_stop
+        dt = 1e-20 if np.array(tmesh).size < 2 else tmesh[1] - tmesh[0]
+        # If equal start and stopping time, record one time step
+        if np.abs(self.start - t_stop) < dt and self.start <= tmesh[-1]:
+            tind_beg = max(tind_end - 1, 0)
+        else:
+            tbeg = np.nonzero(tmesh[:tind_end] >= self.start)[0]
+            tind_beg = tbeg[0] if tbeg.size > 0 else tind_end
+        return (tind_beg, tind_end)
 
-        return dict(
-            Ex=lambda dim: -1 if (dim == 0) else +1,
-            Ey=lambda dim: -1 if (dim == 1) else +1,
-            Ez=lambda dim: -1 if (dim == 2) else +1,
-            Hx=lambda dim: +1 if (dim == 0) else -1,
-            Hy=lambda dim: +1 if (dim == 1) else -1,
-            Hz=lambda dim: +1 if (dim == 2) else -1,
-        )
+    def num_steps(self, tmesh: ArrayFloat1D) -> int:
+        """Compute number of time steps for a time monitor."""
 
+        tind_beg, tind_end = self.time_inds(tmesh)
+        return int((tind_end - tind_beg) / self.interval)
 
-class FieldDataset(ElectromagneticFieldDataset):
-    """Dataset storing a collection of the scalar components of E and H fields in the freq. domain
 
-    Example
-    -------
-    >>> x = [-1,1]
-    >>> y = [-2,0,2]
-    >>> z = [-3,-1,1,3]
-    >>> f = [2e14, 3e14]
-    >>> coords = dict(x=x, y=y, z=z, f=f)
-    >>> scalar_field = ScalarFieldDataArray((1+1j) * np.random.random((2,3,4,2)), coords=coords)
-    >>> data = FieldDataset(Ex=scalar_field, Hz=scalar_field)
-    """
+class AbstractFieldMonitor(Monitor, ABC):
+    """:class:`Monitor` that records electromagnetic field data as a function of x,y,z."""
 
-    Ex: ScalarFieldDataArray = pd.Field(
-        None,
-        title="Ex",
-        description="Spatial distribution of the x-component of the electric field.",
-    )
-    Ey: ScalarFieldDataArray = pd.Field(
-        None,
-        title="Ey",
-        description="Spatial distribution of the y-component of the electric field.",
-    )
-    Ez: ScalarFieldDataArray = pd.Field(
-        None,
-        title="Ez",
-        description="Spatial distribution of the z-component of the electric field.",
-    )
-    Hx: ScalarFieldDataArray = pd.Field(
-        None,
-        title="Hx",
-        description="Spatial distribution of the x-component of the magnetic field.",
+    fields: Tuple[EMField, ...] = pydantic.Field(
+        ["Ex", "Ey", "Ez", "Hx", "Hy", "Hz"],
+        title="Field Components",
+        description="Collection of field components to store in the monitor.",
     )
-    Hy: ScalarFieldDataArray = pd.Field(
-        None,
-        title="Hy",
-        description="Spatial distribution of the y-component of the magnetic field.",
+
+    interval_space: Tuple[
+        pydantic.PositiveInt, pydantic.PositiveInt, pydantic.PositiveInt
+    ] = pydantic.Field(
+        (1, 1, 1),
+        title="Spatial Interval",
+        description="Number of grid step intervals between monitor recordings. If equal to 1, "
+        "there will be no downsampling. If greater than 1, the step will be applied, but the "
+        "first and last point of the monitor grid are always included.",
     )
-    Hz: ScalarFieldDataArray = pd.Field(
-        None,
-        title="Hz",
-        description="Spatial distribution of the z-component of the magnetic field.",
+
+    colocate: bool = pydantic.Field(
+        True,
+        title="Colocate Fields",
+        description="Toggle whether fields should be colocated to grid cell boundaries (i.e. "
+        "primal grid nodes).",
     )
 
+    def _storage_size_solver(self, num_cells: int, tmesh: ArrayFloat1D) -> int:
+        """Size of intermediate data recorded by the monitor during a solver run."""
+        final_data_size = self.storage_size(num_cells=num_cells, tmesh=tmesh)
+        if len(self.fields) == 0:
+            return 0
 
-class FieldTimeDataset(ElectromagneticFieldDataset):
-    """Dataset storing a collection of the scalar components of E and H fields in the time domain
+        # internally solver stores all E components if any one is requested, and same for H
+        field_components_factor = 0
+        if any(comp[0] == "E" for comp in self.fields):
+            field_components_factor += 3
+        if any(comp[0] == "H" for comp in self.fields):
+            field_components_factor += 3
 
-    Example
-    -------
-    >>> x = [-1,1]
-    >>> y = [-2,0,2]
-    >>> z = [-3,-1,1,3]
-    >>> t = [0, 1e-12, 2e-12]
-    >>> coords = dict(x=x, y=y, z=z, t=t)
-    >>> scalar_field = ScalarFieldTimeDataArray(np.random.random((2,3,4,3)), coords=coords)
-    >>> data = FieldTimeDataset(Ex=scalar_field, Hz=scalar_field)
-    """
+        # take out the stored field components factor and use the solver factor instead
+        solver_data_size = final_data_size / len(self.fields) * field_components_factor
+        return solver_data_size
 
-    Ex: ScalarFieldTimeDataArray = pd.Field(
-        None,
-        title="Ex",
-        description="Spatial distribution of the x-component of the electric field.",
-    )
-    Ey: ScalarFieldTimeDataArray = pd.Field(
-        None,
-        title="Ey",
-        description="Spatial distribution of the y-component of the electric field.",
-    )
-    Ez: ScalarFieldTimeDataArray = pd.Field(
-        None,
-        title="Ez",
-        description="Spatial distribution of the z-component of the electric field.",
-    )
-    Hx: ScalarFieldTimeDataArray = pd.Field(
-        None,
-        title="Hx",
-        description="Spatial distribution of the x-component of the magnetic field.",
-    )
-    Hy: ScalarFieldTimeDataArray = pd.Field(
-        None,
-        title="Hy",
-        description="Spatial distribution of the y-component of the magnetic field.",
+
+class PlanarMonitor(Monitor, ABC):
+    """:class:`Monitor` that has a planar geometry."""
+
+    _plane_validator = assert_plane()
+
+    @cached_property
+    def normal_axis(self) -> Axis:
+        """Axis normal to the monitor's plane."""
+        return self.size.index(0.0)
+
+
+class AbstractModeMonitor(PlanarMonitor, FreqMonitor):
+    """:class:`Monitor` that records mode-related data."""
+
+    mode_spec: ModeSpec = pydantic.Field(
+        ...,
+        title="Mode Specification",
+        description="Parameters to feed to mode solver which determine modes measured by monitor.",
     )
-    Hz: ScalarFieldTimeDataArray = pd.Field(
+
+    store_fields_direction: Direction = pydantic.Field(
         None,
-        title="Hz",
-        description="Spatial distribution of the z-component of the magnetic field.",
+        title="Store Fields",
+        description="Propagation direction for the mode field profiles stored from mode solving.",
     )
 
-    def apply_phase(self, phase: float) -> AbstractFieldDataset:
-        """Create a copy where all elements are phase-shifted by a value (in radians)."""
-
-        if phase != 0.0:
-            raise ValueError("Can't apply phase to time-domain field data, which is real-valued.")
+    def plot(
+        self,
+        x: float = None,
+        y: float = None,
+        z: float = None,
+        ax: Ax = None,
+        **patch_kwargs,
+    ) -> Ax:
+        """Plot this monitor."""
+        # call the monitor.plot() function first
+        ax = super().plot(x=x, y=y, z=z, ax=ax, **patch_kwargs)
+
+        kwargs_alpha = patch_kwargs.get("alpha")
+        arrow_alpha = ARROW_ALPHA if kwargs_alpha is None else kwargs_alpha
+
+        # and then add an arrow using the direction comuputed from `_dir_arrow`.
+        ax = self._plot_arrow(
+            x=x,
+            y=y,
+            z=z,
+            ax=ax,
+            direction=self._dir_arrow,
+            bend_radius=self.mode_spec.bend_radius,
+            bend_axis=self._bend_axis,
+            color=ARROW_COLOR_MONITOR,
+            alpha=arrow_alpha,
+            both_dirs=True,
+        )
+        return ax
 
-        return self
+    @cached_property
+    def _dir_arrow(self) -> Tuple[float, float, float]:
+        """Source direction normal vector in cartesian coordinates."""
+        dx = np.cos(self.mode_spec.angle_phi) * np.sin(self.mode_spec.angle_theta)
+        dy = np.sin(self.mode_spec.angle_phi) * np.sin(self.mode_spec.angle_theta)
+        dz = np.cos(self.mode_spec.angle_theta)
+        return self.unpop_axis(dz, (dx, dy), axis=self.normal_axis)
 
+    @cached_property
+    def _bend_axis(self) -> Axis:
+        if self.mode_spec.bend_radius is None:
+            return None
+        in_plane = [0, 0]
+        in_plane[self.mode_spec.bend_axis] = 1
+        direction = self.unpop_axis(0, in_plane, axis=self.normal_axis)
+        return direction.index(1)
+
+    @pydantic.validator("mode_spec", always=True)
+    def _warn_num_modes(cls, val, values):
+        """Warn if number of modes is too large."""
+        if val.num_modes > WARN_NUM_MODES:
+            log.warning(
+                f"A large number ({val.num_modes}) of modes requested in monitor "
+                f"'{values['name']}'. This can lead to solver slow-down and increased cost. "
+                "Consider decreasing the number of modes and using 'ModeSpec.target_neff' "
+                "to target the modes of interest. This may become a hard limit in future "
+                "Tidy3D versions.",
+                custom_loc=["mode_spec", "num_modes"],
+            )
+        return val
 
-class ModeSolverDataset(ElectromagneticFieldDataset):
-    """Dataset storing scalar components of E and H fields as a function of freq. and mode_index.
+    def _storage_size_solver(self, num_cells: int, tmesh: ArrayFloat1D) -> int:
+        """Size of intermediate data recorded by the monitor during a solver run."""
+        # Need to store all fields on the mode surface
+        bytes_single = BYTES_COMPLEX * num_cells * len(self.freqs) * self.mode_spec.num_modes * 6
+        if self.mode_spec.precision == "double":
+            return 2 * bytes_single
+        return bytes_single
+
+
+class FieldMonitor(AbstractFieldMonitor, FreqMonitor):
+    """:class:`Monitor` that records electromagnetic fields in the frequency domain.
+
+    Notes
+    -----
+
+        :class:`FieldMonitor` objects operate by running a discrete Fourier transform of the fields at a given set of
+        frequencies to perform the calculation in-place with the time stepping. :class:`FieldMonitor`  objects are
+        useful for investigating the steady-state field distribution in 2D and 3D regions of the simulation.
 
     Example
     -------
-    >>> from tidy3d import ModeSpec
-    >>> x = [-1,1]
-    >>> y = [0]
-    >>> z = [-3,-1,1,3]
-    >>> f = [2e14, 3e14]
-    >>> mode_index = np.arange(5)
-    >>> field_coords = dict(x=x, y=y, z=z, f=f, mode_index=mode_index)
-    >>> field = ScalarModeFieldDataArray((1+1j)*np.random.random((2,1,4,2,5)), coords=field_coords)
-    >>> index_coords = dict(f=f, mode_index=mode_index)
-    >>> index_data = ModeIndexDataArray((1+1j) * np.random.random((2,5)), coords=index_coords)
-    >>> data = ModeSolverDataset(
-    ...     Ex=field,
-    ...     Ey=field,
-    ...     Ez=field,
-    ...     Hx=field,
-    ...     Hy=field,
-    ...     Hz=field,
-    ...     n_complex=index_data
-    ... )
-    """
+    >>> monitor = FieldMonitor(
+    ...     center=(1,2,3),
+    ...     size=(2,2,2),
+    ...     fields=['Hx'],
+    ...     freqs=[250e12, 300e12],
+    ...     name='steady_state_monitor',
+    ...     colocate=True)
 
-    Ex: ScalarModeFieldDataArray = pd.Field(
-        None,
-        title="Ex",
-        description="Spatial distribution of the x-component of the electric field of the mode.",
-    )
-    Ey: ScalarModeFieldDataArray = pd.Field(
-        None,
-        title="Ey",
-        description="Spatial distribution of the y-component of the electric field of the mode.",
-    )
-    Ez: ScalarModeFieldDataArray = pd.Field(
-        None,
-        title="Ez",
-        description="Spatial distribution of the z-component of the electric field of the mode.",
-    )
-    Hx: ScalarModeFieldDataArray = pd.Field(
-        None,
-        title="Hx",
-        description="Spatial distribution of the x-component of the magnetic field of the mode.",
-    )
-    Hy: ScalarModeFieldDataArray = pd.Field(
-        None,
-        title="Hy",
-        description="Spatial distribution of the y-component of the magnetic field of the mode.",
-    )
-    Hz: ScalarModeFieldDataArray = pd.Field(
-        None,
-        title="Hz",
-        description="Spatial distribution of the z-component of the magnetic field of the mode.",
-    )
 
-    n_complex: ModeIndexDataArray = pd.Field(
-        ...,
-        title="Propagation Index",
-        description="Complex-valued effective propagation constants associated with the mode.",
-    )
+    See Also
+    --------
 
-    n_group_raw: GroupIndexDataArray = pd.Field(
-        None,
-        alias="n_group",  # This is for backwards compatibility only when loading old data
-        title="Group Index",
-        description="Index associated with group velocity of the mode.",
-    )
+    **Notebooks**
 
-    dispersion_raw: ModeDispersionDataArray = pd.Field(
-        None,
-        title="Dispersion",
-        description="Dispersion parameter for the mode.",
-        units=PICOSECOND_PER_NANOMETER_PER_KILOMETER,
-    )
+    * `Quickstart <../../notebooks/StartHere.html>`_: Usage in a basic simulation flow.
 
-    @property
-    def field_components(self) -> Dict[str, DataArray]:
-        """Maps the field components to their associated data."""
-        fields = {
-            "Ex": self.Ex,
-            "Ey": self.Ey,
-            "Ez": self.Ez,
-            "Hx": self.Hx,
-            "Hy": self.Hy,
-            "Hz": self.Hz,
-        }
-        return {field_name: field for field_name, field in fields.items() if field is not None}
+    **Lectures**
 
-    @property
-    def n_eff(self) -> ModeIndexDataArray:
-        """Real part of the propagation index."""
-        return self.n_complex.real
+    * `Introduction to FDTD Simulation <https://www.flexcompute.com/fdtd101/Lecture-1-Introduction-to-FDTD-Simulation/#presentation-slides>`_: Usage in a basic simulation flow.
 
-    @property
-    def k_eff(self) -> ModeIndexDataArray:
-        """Imaginary part of the propagation index."""
-        return self.n_complex.imag
+    """
 
-    @property
-    def n_group(self) -> GroupIndexDataArray:
-        """Group index."""
-        if self.n_group_raw is None:
-            log.warning(
-                "The group index was not computed. To calculate group index, pass "
-                "'group_index_step = True' in the 'ModeSpec'.",
-                log_once=True,
-            )
-        return self.n_group_raw
+    def storage_size(self, num_cells: int, tmesh: ArrayFloat1D) -> int:
+        """Size of monitor storage given the number of points after discretization."""
+        # stores 1 complex number per grid cell, per frequency, per field
+        return BYTES_COMPLEX * num_cells * len(self.freqs) * len(self.fields)
 
-    @property
-    def dispersion(self) -> ModeDispersionDataArray:
-        r"""Dispersion parameter.
 
-        .. math::
+class FieldTimeMonitor(AbstractFieldMonitor, TimeMonitor):
+    """:class:`Monitor` that records electromagnetic fields in the time domain.
 
-           D = -\frac{\lambda}{c_0} \frac{{\rm d}^2 n_{\text{eff}}}{{\rm d}\lambda^2}
-        """
-        if self.dispersion_raw is None:
-            log.warning(
-                "The dispersion was not computed. To calculate dispersion, pass "
-                "'group_index_step = True' in the 'ModeSpec'.",
-                log_once=True,
-            )
-        return self.dispersion_raw
+    Notes
+    -----
 
-    def plot_field(self, *args, **kwargs):
-        """Warn user to use the :class:`.ModeSolver` ``plot_field`` function now."""
-        raise DeprecationWarning(
-            "The 'plot_field()' method was moved to the 'ModeSolver' object."
-            "Once the 'ModeSolver' is constructed, one may call '.plot_field()' on the object and "
-            "the modes will be computed and displayed with 'Simulation' overlay."
-        )
+        :class:`FieldTimeMonitor` objects are best used to monitor the time dependence of the fields at a single
+        point, but they can also be used to create animations of the field pattern evolution.
 
+        To create an animation, we need to capture the frames at different time instances of the simulation. This can
+        be done by using a :class:`FieldTimeMonitor`. Usually a FDTD simulation contains a large number of time steps
+        and grid points. Recording the field at every time step and grid point will result in a large dataset. For
+        the purpose of making animations, this is usually unnecessary.
 
-class PermittivityDataset(AbstractFieldDataset):
-    """Dataset storing the diagonal components of the permittivity tensor.
 
     Example
     -------
-    >>> x = [-1,1]
-    >>> y = [-2,0,2]
-    >>> z = [-3,-1,1,3]
-    >>> f = [2e14, 3e14]
-    >>> coords = dict(x=x, y=y, z=z, f=f)
-    >>> sclr_fld = ScalarFieldDataArray((1+1j) * np.random.random((2,3,4,2)), coords=coords)
-    >>> data = PermittivityDataset(eps_xx=sclr_fld, eps_yy=sclr_fld, eps_zz=sclr_fld)
+    >>> monitor = FieldTimeMonitor(
+    ...     center=(1,2,3),
+    ...     size=(2,2,2),
+    ...     fields=['Hx'],
+    ...     start=1e-13,
+    ...     stop=5e-13,
+    ...     interval=2,
+    ...     colocate=True,
+    ...     name='movie_monitor')
+
+
+    See Also
+    --------
+
+    **Notebooks**
+        * `First walkthrough <../../notebooks/Simulation.html>`_: Usage in a basic simulation flow.
+        * `Creating FDTD animations <../../notebooks/AnimationTutorial.html>`_.
+
     """
 
-    @property
-    def field_components(self) -> Dict[str, ScalarFieldDataArray]:
-        """Maps the field components to their associated data."""
-        return dict(eps_xx=self.eps_xx, eps_yy=self.eps_yy, eps_zz=self.eps_zz)
+    def storage_size(self, num_cells: int, tmesh: ArrayFloat1D) -> int:
+        """Size of monitor storage given the number of points after discretization."""
+        # stores 1 real number per grid cell, per time step, per field
+        num_steps = self.num_steps(tmesh)
+        return BYTES_REAL * num_steps * num_cells * len(self.fields)
+
+
+class PermittivityMonitor(FreqMonitor):
+    """:class:`Monitor` that records the diagonal components of the complex-valued relative
+    permittivity tensor in the frequency domain. The recorded data has the same shape as a
+    :class:`.FieldMonitor` of the same geometry: the permittivity values are saved at the
+    Yee grid locations, and can be interpolated to any point inside the monitor.
 
-    @property
-    def grid_locations(self) -> Dict[str, str]:
-        """Maps field components to the string key of their grid locations on the yee lattice."""
-        return dict(eps_xx="Ex", eps_yy="Ey", eps_zz="Ez")
+    Notes
+    -----
 
-    @property
-    def symmetry_eigenvalues(self) -> Dict[str, Callable[[Axis], float]]:
-        """Maps field components to their (positive) symmetry eigenvalues."""
-        return dict(eps_xx=None, eps_yy=None, eps_zz=None)
+        If 2D materials are present, then the permittivity values correspond to the
+        volumetric equivalent of the 2D materials.
 
-    eps_xx: ScalarFieldDataArray = pd.Field(
-        ...,
-        title="Epsilon xx",
-        description="Spatial distribution of the xx-component of the relative permittivity.",
-    )
-    eps_yy: ScalarFieldDataArray = pd.Field(
-        ...,
-        title="Epsilon yy",
-        description="Spatial distribution of the yy-component of the relative permittivity.",
-    )
-    eps_zz: ScalarFieldDataArray = pd.Field(
-        ...,
-        title="Epsilon zz",
-        description="Spatial distribution of the zz-component of the relative permittivity.",
-    )
+        .. TODO add links to relevant areas
 
+    Example
+    -------
+    >>> monitor = PermittivityMonitor(
+    ...     center=(1,2,3),
+    ...     size=(2,2,2),
+    ...     freqs=[250e12, 300e12],
+    ...     name='eps_monitor')
+    """
 
-class TriangleMeshDataset(Dataset):
-    """Dataset for storing triangular surface data."""
-
-    surface_mesh: TriangleMeshDataArray = pd.Field(
-        ...,
-        title="Surface mesh data",
-        description="Dataset containing the surface triangles and corresponding face indices "
-        "for a surface mesh.",
+    colocate: Literal[False] = pydantic.Field(
+        False,
+        title="Colocate Fields",
+        description="Colocation turned off, since colocated permittivity values do not have a "
+        "physical meaning - they do not correspond to the subpixel-averaged ones.",
     )
 
+    interval_space: Tuple[
+        pydantic.PositiveInt, pydantic.PositiveInt, pydantic.PositiveInt
+    ] = pydantic.Field(
+        (1, 1, 1),
+        title="Spatial Interval",
+        description="Number of grid step intervals between monitor recordings. If equal to 1, "
+        "there will be no downsampling. If greater than 1, the step will be applied, but the "
+        "first and last point of the monitor grid are always included.",
+    )
 
-class TimeDataset(Dataset):
-    """Dataset for storing a function of time."""
-
-    values: TimeDataArray = pd.Field(
-        ..., title="Values", description="Values as a function of time."
+    apodization: ApodizationSpec = pydantic.Field(
+        ApodizationSpec(),
+        title="Apodization Specification",
+        description="This field is ignored in this monitor.",
     )
 
+    def storage_size(self, num_cells: int, tmesh: ArrayFloat1D) -> int:
+        """Size of monitor storage given the number of points after discretization."""
+        # stores 3 complex number per grid cell, per frequency
+        return BYTES_COMPLEX * num_cells * len(self.freqs) * 3
 
-class UnstructuredGridDataset(Dataset, np.lib.mixins.NDArrayOperatorsMixin, ABC):
-    """Abstract base for datasets that store unstructured grid data."""
 
-    points: PointDataArray = pd.Field(
-        ...,
-        title="Grid Points",
-        description="Coordinates of points composing the unstructured grid.",
-    )
+class SurfaceIntegrationMonitor(Monitor, ABC):
+    """Abstract class for monitors that perform surface integrals during the solver run, as in
+    flux and near to far transformations."""
 
-    values: IndexedDataArray = pd.Field(
-        ...,
-        title="Point Values",
-        description="Values stored at the grid points.",
+    normal_dir: Direction = pydantic.Field(
+        None,
+        title="Normal Vector Orientation",
+        description="Direction of the surface monitor's normal vector w.r.t. "
+        "the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. "
+        "Applies to surface monitors only, and defaults to ``'+'`` if not provided.",
     )
 
-    cells: CellDataArray = pd.Field(
-        ...,
-        title="Grid Cells",
-        description="Cells composing the unstructured grid specified as connections between grid "
-        "points.",
+    exclude_surfaces: Tuple[BoxSurface, ...] = pydantic.Field(
+        None,
+        title="Excluded Surfaces",
+        description="Surfaces to exclude in the integration, if a volume monitor.",
     )
 
     @property
-    def name(self) -> str:
-        """Dataset name."""
-        # we redirect name to values.name
-        return self.values.name
-
-    @pd.validator("cells", always=True)
-    def match_cells_to_vtk_type(cls, val):
-        """Check that cell connections does not have duplicate points."""
-        if vtk is None:
-            return val
-
-        # using val.astype(np.int32/64) directly causes issues when dataarray are later checked ==
-        return CellDataArray(val.data.astype(vtk["id_type"], copy=False), coords=val.coords)
-
-    @pd.validator("values", always=True)
-    @skip_if_fields_missing(["points"])
-    def number_of_values_matches_points(cls, val, values):
-        """Check that the number of data values matches the number of grid points."""
-        num_values = len(val)
+    def integration_surfaces(self):
+        """Surfaces of the monitor where fields will be recorded for subsequent integration."""
+        if self.size.count(0.0) == 0:
+            return self.surfaces_with_exclusion(**self.dict())
+        return [self]
 
-        points = values.get("points")
-        num_points = len(points)
+    @pydantic.root_validator(skip_on_failure=True)
+    def normal_dir_exists_for_surface(cls, values):
+        """If the monitor is a surface, set default ``normal_dir`` if not provided.
+        If the monitor is a box, warn that ``normal_dir`` is relevant only for surfaces."""
+        normal_dir = values.get("normal_dir")
+        name = values.get("name")
+        size = values.get("size")
+        if size.count(0.0) != 1:
+            if normal_dir is not None:
+                log.warning(
+                    "The ``normal_dir`` field is relevant only for surface monitors "
+                    f"and will be ignored for monitor {name}, which is a box."
+                )
+        else:
+            if normal_dir is None:
+                values["normal_dir"] = "+"
+        return values
 
-        if num_points != num_values:
-            raise ValidationError(
-                f"The number of data values ({num_values}) does not match the number of grid "
-                f"points ({num_points})."
+    @pydantic.root_validator(skip_on_failure=True)
+    def check_excluded_surfaces(cls, values):
+        """Error if ``exclude_surfaces`` is provided for a surface monitor."""
+        exclude_surfaces = values.get("exclude_surfaces")
+        if exclude_surfaces is None:
+            return values
+        name = values.get("name")
+        size = values.get("size")
+        if size.count(0.0) > 0:
+            raise SetupError(
+                f"Can't specify ``exclude_surfaces`` for surface monitor {name}; "
+                "valid for box monitors only."
             )
-        return val
+        return values
 
-    @pd.validator("points", always=True)
-    def points_right_dims(cls, val):
-        """Check that point coordinates have the right dimensionality."""
-        axis_coords_expected = np.arange(cls._point_dims())
-        axis_coords_given = val.axis.data
-        if np.any(axis_coords_given != axis_coords_expected):
-            raise ValidationError(
-                f"Points array is expected to have {axis_coords_expected} coord values along 'axis'"
-                f" (given: {axis_coords_given})."
-            )
-        return val
+    def _storage_size_solver(self, num_cells: int, tmesh: ArrayFloat1D) -> int:
+        """Size of intermediate data recorded by the monitor during a solver run."""
+        # Need to store all fields on the integration surface. Frequency-domain monitors store at
+        # all frequencies, time domain at the current time step only.
+        num_sample = len(getattr(self, "freqs", [0]))
+        return BYTES_COMPLEX * num_cells * num_sample * 6
 
-    @pd.validator("cells", always=True)
-    def cells_right_type(cls, val):
-        """Check that cell are of the right type."""
-        vertex_coords_expected = np.arange(cls._cell_num_vertices())
-        vertex_coords_given = val.vertex_index.data
-        if np.any(vertex_coords_given != vertex_coords_expected):
-            raise ValidationError(
-                f"Cell connections array is expected to have {vertex_coords_expected} coord values"
-                f" along 'vertex_index' (given: {vertex_coords_given})."
-            )
-        return val
 
-    @pd.validator("cells", always=True)
-    @skip_if_fields_missing(["points"])
-    def check_cell_vertex_range(cls, val, values):
-        """Check that cell connections use only defined points."""
-        all_point_indices_used = val.data.ravel()
-        min_index_used = np.min(all_point_indices_used)
-        max_index_used = np.max(all_point_indices_used)
+class AbstractFluxMonitor(SurfaceIntegrationMonitor, ABC):
+    """:class:`Monitor` that records flux during the solver run."""
 
-        points = values.get("points")
-        num_points = len(points)
 
-        if max_index_used != num_points - 1 or min_index_used != 0:
-            raise ValidationError(
-                "Cell connections array uses undefined point indices in the range "
-                f"[{min_index_used}, {max_index_used}]. The valid range of point indices is "
-                f"[0, {num_points-1}]."
-            )
-        return val
+class FluxMonitor(AbstractFluxMonitor, FreqMonitor):
+    """:class:`Monitor` that records power flux in the frequency domain.
 
-    @pd.validator("cells", always=True)
-    def check_valid_cells(cls, val):
-        """Check that cell connections does not have duplicate points."""
-        indices = val.data
-        for i in range(cls._cell_num_vertices() - 1):
-            for j in range(i + 1, cls._cell_num_vertices()):
-                if np.any(indices[:, i] == indices[:, j]):
-                    log.warning("Unstructured grid contains degenerate cells.")
-        return val
+    Notes
+    -----
 
-    def rename(self, name: str) -> UnstructuredGridDataset:
-        """Return a renamed array."""
-        return self.updated_copy(values=self.values.rename(name))
-
-    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):
-        """Override of numpy functions."""
-
-        out = kwargs.get("out", ())
-        for x in inputs + out:
-            # Only support operations with the same class or a scalar
-            if not isinstance(x, (numbers.Number, type(self))):
-                return Tidy3dNotImplementedError
-
-        # Defer to the implementation of the ufunc on unwrapped values.
-        inputs = tuple(x.values if isinstance(x, UnstructuredGridDataset) else x for x in inputs)
-        if out:
-            kwargs["out"] = tuple(
-                x.values if isinstance(x, UnstructuredGridDataset) else x for x in out
-            )
-        result = getattr(ufunc, method)(*inputs, **kwargs)
+        If the monitor geometry is a 2D box, the total flux through this plane is returned, with a
+        positive sign corresponding to power flow in the positive direction along the axis normal to
+        the plane. If the geometry is a 3D box, the total power coming out of the box is returned by
+        integrating the flux over all box surfaces (except the ones defined in ``exclude_surfaces``).
 
-        if type(result) is tuple:
-            # multiple return values
-            return tuple(self.updated_copy(values=x) for x in result)
-        elif method == "at":
-            # no return value
-            return None
-        else:
-            # one return value
-            return self.updated_copy(values=result)
+    Example
+    -------
+    >>> monitor = FluxMonitor(
+    ...     center=(1,2,3),
+    ...     size=(2,2,0),
+    ...     freqs=[200e12, 210e12],
+    ...     name='flux_monitor')
 
-    @property
-    def real(self) -> UnstructuredGridDataset:
-        """Real part of dataset."""
-        return self.updated_copy(values=self.values.real)
+    See Also
+    --------
 
-    @property
-    def imag(self) -> UnstructuredGridDataset:
-        """Imaginary part of dataset."""
-        return self.updated_copy(values=self.values.imag)
+    **Notebooks**
 
-    @property
-    def abs(self) -> UnstructuredGridDataset:
-        """Absolute value of dataset."""
-        return self.updated_copy(values=self.values.abs)
+    * `THz integrated demultiplexer/filter based on a ring resonator <../../notebooks/THzDemultiplexerFilter.html>`_
+    """
 
-    @cached_property
-    def bounds(self) -> Bound:
-        """Grid bounds."""
-        return tuple(np.min(self.points.data, axis=0)), tuple(np.max(self.points.data, axis=0))
+    def storage_size(self, num_cells: int, tmesh: ArrayFloat1D) -> int:
+        """Size of monitor storage given the number of points after discretization."""
+        # stores 1 real number per frequency
+        return BYTES_REAL * len(self.freqs)
+
+
+class FluxTimeMonitor(AbstractFluxMonitor, TimeMonitor):
+    """:class:`Monitor` that records power flux in the time domain.
+
+    Notes
+    -----
+
+        If the monitor geometry is a 2D box, the total flux through this plane is returned, with a
+        positive sign corresponding to power flow in the positive direction along the axis normal to
+        the plane. If the geometry is a 3D box, the total power coming out of the box is returned by
+        integrating the flux over all box surfaces (except the ones defined in ``exclude_surfaces``).
 
-    @classmethod
-    @abstractmethod
-    def _point_dims(cls) -> pd.PositiveInt:
-        """Dimensionality of stored grid point coordinates."""
+    Example
+    -------
+    >>> monitor = FluxTimeMonitor(
+    ...     center=(1,2,3),
+    ...     size=(2,2,0),
+    ...     start=1e-13,
+    ...     stop=5e-13,
+    ...     interval=2,
+    ...     name='flux_vs_time')
+    """
 
-    @cached_property
-    @abstractmethod
-    def _points_3d_array(self) -> Bound:
-        """3D coordinates of grid points."""
+    def storage_size(self, num_cells: int, tmesh: ArrayFloat1D) -> int:
+        """Size of monitor storage given the number of points after discretization."""
+        # stores 1 real number per time step
+        num_steps = self.num_steps(tmesh)
+        return BYTES_REAL * num_steps
 
-    @classmethod
-    @abstractmethod
-    def _cell_num_vertices(cls) -> pd.PositiveInt:
-        """Number of vertices in a cell."""
 
-    @classmethod
-    @abstractmethod
-    @requires_vtk
-    def _vtk_cell_type(cls):
-        """VTK cell type to use in the VTK representation."""
+class ModeMonitor(AbstractModeMonitor):
+    """:class:`Monitor` that records amplitudes from modal decomposition of fields on plane.
 
-    @cached_property
-    def _vtk_offsets(self) -> ArrayLike:
-        """Offsets array to use in the VTK representation."""
-        offsets = np.arange(len(self.cells) + 1) * self._cell_num_vertices()
-        if vtk is None:
-            return offsets
+    Notes
+    ------
 
-        return offsets.astype(vtk["id_type"], copy=False)
+        The fields recorded by frequency monitors (and hence also mode monitors) are automatically
+        normalized by the power amplitude spectrum of the source. For multiple sources, the user can
+        select which source to use for the normalization too.
 
-    @property
-    @requires_vtk
-    def _vtk_cells(self):
-        """VTK cell array to use in the VTK representation."""
-        cells = vtk["mod"].vtkCellArray()
-        cells.SetData(
-            vtk["numpy_to_vtkIdTypeArray"](self._vtk_offsets),
-            vtk["numpy_to_vtkIdTypeArray"](self.cells.data.ravel()),
-        )
-        return cells
+        We can also use the mode amplitudes recorded in the mode monitor to reveal the decomposition
+        of the radiated power into forward- and backward-propagating modes, respectively.
 
-    @property
-    @requires_vtk
-    def _vtk_points(self):
-        """VTK point array to use in the VTK representation."""
-        pts = vtk["mod"].vtkPoints()
-        pts.SetData(vtk["numpy_to_vtk"](self._points_3d_array))
-        return pts
+        .. TODO give an example of how to extract the data from this mode.
 
-    @property
-    @requires_vtk
-    def _vtk_obj(self):
-        """A VTK representation (vtkUnstructuredGrid) of the grid."""
-
-        grid = vtk["mod"].vtkUnstructuredGrid()
-
-        grid.SetPoints(self._vtk_points)
-        grid.SetCells(self._vtk_cell_type(), self._vtk_cells)
-        point_data_vtk = vtk["numpy_to_vtk"](self.values.data)
-        point_data_vtk.SetName(self.values.name)
-        grid.GetPointData().AddArray(point_data_vtk)
-
-        return grid
-
-    @requires_vtk
-    def _plane_slice_raw(self, axis: Axis, pos: float):
-        """Slice data with a plane and return the resulting VTK object."""
-
-        if pos > self.bounds[1][axis] or pos < self.bounds[0][axis]:
-            raise DataError(
-                f"Slicing plane (axis: {axis}, pos: {pos}) does not intersect the unstructured grid "
-                f"(extent along axis {axis}: {self.bounds[0][axis]}, {self.bounds[1][axis]})."
-            )
+        .. TODO add derivation in the notebook.
 
-        origin = [0, 0, 0]
-        origin[axis] = pos
+        .. TODO add link to method
 
-        normal = [0, 0, 0]
-        normal[axis] = 1
+        .. TODO add links to notebooks correspondingly
 
-        # create cutting plane
-        plane = vtk["mod"].vtkPlane()
-        plane.SetOrigin(origin[0], origin[1], origin[2])
-        plane.SetNormal(normal[0], normal[1], normal[2])
-
-        # create cutter
-        cutter = vtk["mod"].vtkPlaneCutter()
-        cutter.SetPlane(plane)
-        cutter.SetInputData(self._vtk_obj)
-        cutter.InterpolateAttributesOn()
-        cutter.Update()
-
-        # clean up the slice
-        cleaner = vtk["mod"].vtkCleanPolyData()
-        cleaner.SetInputData(cutter.GetOutput())
-        cleaner.Update()
+    Example
+    -------
+    >>> mode_spec = ModeSpec(num_modes=3)
+    >>> monitor = ModeMonitor(
+    ...     center=(1,2,3),
+    ...     size=(2,2,0),
+    ...     freqs=[200e12, 210e12],
+    ...     mode_spec=mode_spec,
+    ...     name='mode_monitor')
 
-        return cleaner.GetOutput()
+    See Also
+    --------
 
-    @abstractmethod
-    @requires_vtk
-    def plane_slice(
-        self, axis: Axis, pos: float
-    ) -> Union[SpatialDataArray, UnstructuredGridDataset]:
-        """Slice data with a plane and return the Tidy3D representation of the result
-        (``UnstructuredGridDataset``).
-
-        Parameters
-        ----------
-        axis : Axis
-            The normal direction of the slicing plane.
-        pos : float
-            Position of the slicing plane along its normal direction.
+    **Notebooks**:
+        * `ModalSourcesMonitors <../../notebooks/ModalSourcesMonitors.html>`_
+    """
 
-        Returns
-        -------
-        Union[SpatialDataArray, UnstructuredGridDataset]
-            The resulting slice.
-        """
+    colocate: Literal[False] = pydantic.Field(
+        False,
+        title="Colocate Fields",
+        description="Defines whether fields are colocated to grid cell boundaries (i.e. to the "
+        "primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors "
+        "and is hard-coded for other monitors depending on their specific function.",
+    )
+
+    def storage_size(self, num_cells: int, tmesh: int) -> int:
+        """Size of monitor storage given the number of points after discretization."""
+        amps_size = 3 * BYTES_COMPLEX * len(self.freqs) * self.mode_spec.num_modes
+        fields_size = 0
+        if self.store_fields_direction is not None:
+            fields_size = 6 * BYTES_COMPLEX * num_cells * len(self.freqs) * self.mode_spec.num_modes
+            if self.mode_spec.precision == "double":
+                fields_size *= 2
+        return amps_size + fields_size
+
+
+class ModeSolverMonitor(AbstractModeMonitor):
+    """:class:`Monitor` that stores the mode field profiles returned by the mode solver in the
+    monitor plane.
 
-    @staticmethod
-    @requires_vtk
-    def _read_vtkUnstructuredGrid(fname: str):
-        """Load a :class:`vtkUnstructuredGrid` from a file."""
-        reader = vtk["mod"].vtkXMLUnstructuredGridReader()
-        reader.SetFileName(fname)
-        reader.Update()
-        grid = reader.GetOutput()
+    Example
+    -------
+    >>> mode_spec = ModeSpec(num_modes=3)
+    >>> monitor = ModeSolverMonitor(
+    ...     center=(1,2,3),
+    ...     size=(2,2,0),
+    ...     freqs=[200e12, 210e12],
+    ...     mode_spec=mode_spec,
+    ...     name='mode_monitor')
+    """
 
-        return grid
+    direction: Direction = pydantic.Field(
+        "+",
+        title="Propagation Direction",
+        description="Direction of waveguide mode propagation along the axis defined by its normal "
+        "dimension.",
+    )
+
+    colocate: bool = pydantic.Field(
+        True,
+        title="Colocate Fields",
+        description="Toggle whether fields should be colocated to grid cell boundaries (i.e. "
+        "primal grid nodes).",
+    )
+
+    @pydantic.root_validator(skip_on_failure=True)
+    def set_store_fields(cls, values):
+        """Ensure 'store_fields_direction' is compatible with 'direction'."""
+        store_fields_direction = values["store_fields_direction"]
+        direction = values["direction"]
+        if store_fields_direction is None:
+            values["store_fields_direction"] = direction
+        elif store_fields_direction != direction:
+            raise ValidationError(
+                f"The values of 'direction' ({direction}) and 'store_fields_direction' "
+                f"({store_fields_direction}) must be equal."
+            )
+        return values
 
-    @classmethod
-    @abstractmethod
-    @requires_vtk
-    def _from_vtk_obj(cls, vtk_obj, field=None) -> UnstructuredGridDataset:
-        """Initialize from a vtk object."""
-
-    @classmethod
-    @requires_vtk
-    def from_vtu(cls, file: str, field: str = None) -> UnstructuredGridDataset:
-        """Load unstructured data from a vtu file.
-
-        Parameters
-        ----------
-        fname : str
-            Full path to the .vtu file to load the unstructured data from.
-        field : str = None
-            Name of the field to load.
+    def storage_size(self, num_cells: int, tmesh: int) -> int:
+        """Size of monitor storage given the number of points after discretization."""
+        bytes_single = 6 * BYTES_COMPLEX * num_cells * len(self.freqs) * self.mode_spec.num_modes
+        if self.mode_spec.precision == "double":
+            return 2 * bytes_single
+        return bytes_single
 
-        Returns
-        -------
-        UnstructuredGridDataset
-            Unstructured data.
-        """
-        grid = cls._read_vtkUnstructuredGrid(file)
-        return cls._from_vtk_obj(grid, field=field)
 
-    @requires_vtk
-    def to_vtu(self, fname: str):
-        """Exports unstructured grid data into a .vtu file.
-
-        Parameters
-        ----------
-        fname : str
-            Full path to the .vtu file to save the unstructured data to.
-        """
+class FieldProjectionSurface(Tidy3dBaseModel):
+    """
+    Data structure to store surface monitors where near fields are recorded for
+    field projections.
 
-        writer = vtk["mod"].vtkXMLUnstructuredGridWriter()
-        writer.SetFileName(fname)
-        writer.SetInputData(self._vtk_obj)
-        writer.Write()
-
-    @classmethod
-    @requires_vtk
-    def _get_values_from_vtk(
-        cls, vtk_obj, num_points: pd.PositiveInt, field: str = None
-    ) -> IndexedDataArray:
-        """Get point data values from a VTK object."""
+    .. TODO add example and derivation, and more relevant links.
 
-        point_data = vtk_obj.GetPointData()
-        num_point_arrays = point_data.GetNumberOfArrays()
+    See Also
+    --------
 
-        if num_point_arrays == 0:
-            log.warning(
-                "No point data is found in a VTK object. '.values' will be initialized to zeros."
-            )
-            values_numpy = np.zeros(num_points)
-            values_name = None
+    **Notebooks**:
+        * `Performing near field to far field projections <../../notebooks/FieldProjections.html>`_
+    """
 
-        else:
-            if field is not None:
-                array_vtk = point_data.GetAbstractArray(field)
-            else:
-                array_vtk = point_data.GetAbstractArray(0)
+    monitor: FieldMonitor = pydantic.Field(
+        ...,
+        title="Field Monitor",
+        description=":class:`.FieldMonitor` on which near fields will be sampled and integrated.",
+    )
 
-            # currently we assume there is only one point data array provided in the VTK object
-            if num_point_arrays > 1 and field is None:
-                array_name = array_vtk.GetName()
-                log.warning(
-                    f"{num_point_arrays} point data arrays are found in a VTK object. "
-                    f"Only the first array (name: {array_name}) will be used to initialize "
-                    "'.values' while the rest will be ignored."
-                )
+    normal_dir: Direction = pydantic.Field(
+        ...,
+        title="Normal Vector Orientation",
+        description=":class:`.Direction` of the surface monitor's normal vector w.r.t.\
+ the positive x, y or z unit vectors. Must be one of '+' or '-'.",
+    )
 
-            # currently we assume data is scalar
-            num_components = array_vtk.GetNumberOfComponents()
-            if num_components > 1:
-                raise DataError(
-                    f"Found point data array in a VTK object is expected to have only 1 component. Found {num_components} components."
-                )
+    @cached_property
+    def axis(self) -> Axis:
+        """Returns the :class:`.Axis` normal to this surface."""
+        # assume that the monitor's axis is in the direction where the monitor is thinnest
+        return self.monitor.size.index(0.0)
+
+    @pydantic.validator("monitor", always=True)
+    def is_plane(cls, val):
+        """Ensures that the monitor is a plane, i.e., its ``size`` attribute has exactly 1 zero"""
+        size = val.size
+        if size.count(0.0) != 1:
+            raise ValidationError(f"Monitor '{val.name}' must be planar, given size={size}")
+        return val
 
-            # check that number of values matches number of grid points
-            num_tuples = array_vtk.GetNumberOfTuples()
-            if num_tuples != num_points:
-                raise DataError(
-                    f"The length of found point data array ({num_tuples}) does not match the number of grid points ({num_points})."
-                )
 
-            values_numpy = vtk["vtk_to_numpy"](array_vtk)
-            values_name = array_vtk.GetName()
+class AbstractFieldProjectionMonitor(SurfaceIntegrationMonitor, FreqMonitor):
+    """:class:`Monitor` that samples electromagnetic near fields in the frequency domain
+    and projects them to a given set of observation points.
+    """
 
-        values = IndexedDataArray(
-            values_numpy, coords=dict(index=np.arange(len(values_numpy))), name=values_name
-        )
+    custom_origin: Coordinate = pydantic.Field(
+        None,
+        title="Local Origin",
+        description="Local origin used for defining observation points. If ``None``, uses the "
+        "monitor's center.",
+        units=MICROMETER,
+    )
+
+    far_field_approx: bool = pydantic.Field(
+        True,
+        title="Far Field Approximation",
+        description="Whether to enable the far field approximation when projecting fields. "
+        "If ``True``, terms that decay as O(1/r^2) are ignored, as are the radial components "
+        "of fields. Typically, this should be set to ``True`` only when the projection distance "
+        "is much larger than the size of the device being modeled, and the projected points are "
+        "in the far field of the device.",
+    )
+
+    interval_space: Tuple[
+        pydantic.PositiveInt, pydantic.PositiveInt, pydantic.PositiveInt
+    ] = pydantic.Field(
+        (1, 1, 1),
+        title="Spatial Interval",
+        description="Number of grid step intervals at which near fields are recorded for "
+        "projection to the far field, along each direction. If equal to 1, there will be no "
+        "downsampling. If greater than 1, the step will be applied, but the first and last "
+        "point of the monitor grid are always included. Using values greater than 1 can "
+        "help speed up server-side far field projections with minimal accuracy loss, "
+        "especially in cases where it is necessary for the grid resolution to be high for "
+        "the FDTD simulation, but such a high resolution is unnecessary for the purpose of "
+        "projecting the recorded near fields to the far field.",
+    )
+
+    window_size: Tuple[pydantic.NonNegativeFloat, pydantic.NonNegativeFloat] = pydantic.Field(
+        (0, 0),
+        title="Spatial filtering window size",
+        description="Size of the transition region of the windowing function used to ensure that "
+        "the recorded near fields decay to zero near the edges of the monitor. "
+        "The two components refer to the two tangential directions associated with each surface. "
+        "For surfaces with the normal along ``x``, the two components are (``y``, ``z``). "
+        "For surfaces with the normal along ``y``, the two components are (``x``, ``z``). "
+        "For surfaces with the normal along ``z``, the two components are (``x``, ``y``). "
+        "Each value must be between 0 and 1, inclusive, and denotes the size of the transition "
+        "region over which fields are scaled to less than a thousandth of the original amplitude, "
+        "relative to half the size of the monitor in that direction. A value of 0 turns windowing "
+        "off in that direction, while a value of 1 indicates that the window will be applied to "
+        "the entire monitor in that direction. This field is applicable for surface monitors only, "
+        "and otherwise must remain (0, 0).",
+    )
+
+    medium: MediumType = pydantic.Field(
+        None,
+        title="Projection medium",
+        description="Medium through which to project fields. Generally, the fields should be "
+        "projected through the same medium as the one in which this monitor is placed, and "
+        "this is the default behavior when ``medium=None``. A custom ``medium`` can be useful "
+        "in some situations for advanced users, but we recommend trying to avoid using a "
+        "non-default ``medium``.",
+    )
+
+    @pydantic.validator("window_size", always=True)
+    @skip_if_fields_missing(["size", "name"])
+    def window_size_for_surface(cls, val, values):
+        """Ensures that windowing is applied for surface monitors only."""
+        size = values.get("size")
+        name = values.get("name")
+
+        if size.count(0.0) != 1:
+            if val != (0, 0):
+                raise ValidationError(
+                    f"A non-zero 'window_size' cannot be used for projection monitor '{name}'. "
+                    "Windowing can be applied only for surface projection monitors."
+                )
+        return val
 
-        return values
+    @pydantic.validator("window_size", always=True)
+    @skip_if_fields_missing(["name"])
+    def window_size_leq_one(cls, val, values):
+        """Ensures that each component of the window size is less than or equal to 1."""
+        name = values.get("name")
+        if val[0] > 1 or val[1] > 1:
+            raise ValidationError(
+                f"Each component of 'window_size' for monitor '{name}' "
+                "must be less than or equal to 1."
+            )
+        return val
 
-    @requires_vtk
-    def box_clip(self, bounds: Bound) -> UnstructuredGridDataset:
-        """Clip the unstructured grid using a box defined by ``bounds``.
-
-        Parameters
-        ----------
-        bounds : Tuple[float, float, float], Tuple[float, float float]
-            Min and max bounds packaged as ``(minx, miny, minz), (maxx, maxy, maxz)``.
+    @property
+    def projection_surfaces(self) -> Tuple[FieldProjectionSurface, ...]:
+        """Surfaces of the monitor where near fields will be recorded for subsequent projection."""
+        surfaces = self.integration_surfaces
+        return [
+            FieldProjectionSurface(
+                monitor=FieldMonitor(
+                    center=surface.center,
+                    size=surface.size,
+                    freqs=self.freqs,
+                    name=surface.name,
+                    colocate=True,
+                ),
+                normal_dir=surface.normal_dir,
+            )
+            for surface in surfaces
+        ]
 
-        Returns
-        -------
-        UnstructuredGridDataset
-            Clipped grid.
-        """
+    @property
+    def local_origin(self) -> Coordinate:
+        """Returns the local origin associated with this monitor."""
+        if self.custom_origin is None:
+            return self.center
+        return self.custom_origin
+
+    def window_parameters(self, custom_bounds: Bound = None) -> Tuple[Size, Coordinate, Coordinate]:
+        """Return the physical size of the window transition region based on the monitor's size
+        and optional custom bounds (useful in case the monitor has infinite dimensions). The window
+        size is returned in 3D. Also returns the coordinate where the transition region beings on
+        the minus and plus side of the monitor."""
+
+        window_size = [0, 0, 0]
+        window_minus = [0, 0, 0]
+        window_plus = [0, 0, 0]
+
+        # windowing is for surface monitors only
+        if self.size.count(0.0) != 1:
+            return window_size, window_minus, window_plus
+
+        _, plane_inds = self.pop_axis([0, 1, 2], axis=self.size.index(0.0))
+
+        for i, ind in enumerate(plane_inds):
+            if custom_bounds:
+                size = min(self.size[ind], custom_bounds[1][ind] - custom_bounds[0][ind])
+                bound_min = max(self.bounds[0][ind], custom_bounds[0][ind])
+                bound_max = min(self.bounds[1][ind], custom_bounds[1][ind])
+            else:
+                size = self.size[ind]
+                bound_min = self.bounds[0][ind]
+                bound_max = self.bounds[1][ind]
+
+            window_size[ind] = self.window_size[i] * size / 2
+            window_minus[ind] = bound_min + window_size[ind]
+            window_plus[ind] = bound_max - window_size[ind]
 
-        # make and run a VTK clipper
-        clipper = vtk["mod"].vtkBoxClipDataSet()
-        clipper.SetOrientation(0)
-        clipper.SetBoxClip(
-            bounds[0][0], bounds[1][0], bounds[0][1], bounds[1][1], bounds[0][2], bounds[1][2]
-        )
-        clipper.SetInputData(self._vtk_obj)
-        clipper.GenerateClipScalarsOn()
-        clipper.GenerateClippedOutputOff()
-        clipper.Update()
-        clip = clipper.GetOutput()
-
-        # clean grid from unused points
-        grid_cleaner = vtk["mod"].vtkRemoveUnusedPoints()
-        grid_cleaner.SetInputData(clip)
-        grid_cleaner.GenerateOriginalPointIdsOff()
-        grid_cleaner.Update()
-        clean_clip = grid_cleaner.GetOutput()
-
-        # no intersection check
-        if clean_clip.GetNumberOfPoints() == 0:
-            raise DataError("Clipping box does not intersect the unstructured grid.")
+        return window_size, window_minus, window_plus
 
-        return self._from_vtk_obj(clean_clip)
+    @staticmethod
+    def window_function(
+        points: ArrayFloat1D,
+        window_size: Size,
+        window_minus: Coordinate,
+        window_plus: Coordinate,
+        dim: int,
+    ) -> ArrayFloat1D:
+        """Get the windowing function along a given direction for a given set of points."""
+        rising_window = np.exp(
+            -0.5
+            * WINDOW_FACTOR
+            * ((points[points < window_minus[dim]] - window_minus[dim]) / window_size[dim]) ** 2
+        )
+        falling_window = np.exp(
+            -0.5
+            * WINDOW_FACTOR
+            * ((points[points > window_plus[dim]] - window_plus[dim]) / window_size[dim]) ** 2
+        )
+        window_fn = np.ones_like(points)
+        window_fn[points < window_minus[dim]] = rising_window
+        window_fn[points > window_plus[dim]] = falling_window
+        return window_fn
 
-    @requires_vtk
-    def interp(
-        self,
-        x: Union[float, ArrayLike],
-        y: Union[float, ArrayLike],
-        z: Union[float, ArrayLike],
-        fill_value: float = 0,
-    ) -> SpatialDataArray:
-        """Interpolate data at provided x, y, and z.
-
-        Parameters
-        ----------
-        x : Union[float, ArrayLike]
-            x-coordinates of sampling points.
-        y : Union[float, ArrayLike]
-            y-coordinates of sampling points.
-        z : Union[float, ArrayLike]
-            z-coordinates of sampling points.
-        fill_value : float = 0
-            Value to use when filling points without interpolated values.
 
-        Returns
-        -------
-        SpatialDataArray
-            Interpolated data.
-        """
+class FieldProjectionAngleMonitor(AbstractFieldProjectionMonitor):
+    """:class:`Monitor` that samples electromagnetic near fields in the frequency domain
+    and projects them at given observation angles.
 
-        # calculate the resulting array shape
-        x = np.atleast_1d(x)
-        y = np.atleast_1d(y)
-        z = np.atleast_1d(z)
-        shape = (len(x), len(y), len(z))
-
-        # create a VTK rectilinear grid to sample onto
-        structured_grid = vtk["mod"].vtkRectilinearGrid()
-        structured_grid.SetDimensions(shape)
-        structured_grid.SetXCoordinates(vtk["numpy_to_vtk"](x))
-        structured_grid.SetYCoordinates(vtk["numpy_to_vtk"](y))
-        structured_grid.SetZCoordinates(vtk["numpy_to_vtk"](z))
-
-        # create and execute VTK interpolator
-        interpolator = vtk["mod"].vtkResampleWithDataSet()
-        interpolator.SetInputData(structured_grid)
-        interpolator.SetSourceData(self._vtk_obj)
-        interpolator.Update()
-        interpolated = interpolator.GetOutput()
-
-        # get results in a numpy representation
-        array_id = 0 if self.values.name is None else self.values.name
-        values_numpy = vtk["vtk_to_numpy"](interpolated.GetPointData().GetAbstractArray(array_id))
-
-        # fill points without interpolated values
-        if fill_value != 0:
-            mask = vtk["vtk_to_numpy"](
-                interpolated.GetPointData().GetAbstractArray("vtkValidPointMask")
-            )
-            values_numpy[mask != 1] = fill_value
+    Notes
+    -----
 
-        # VTK arrays are the z-y-x order, reorder interpolation results to x-y-z order
-        values_reordered = np.transpose(np.reshape(values_numpy, shape[::-1]), (2, 1, 0))
+        .. TODO this needs an illustration
 
-        return SpatialDataArray(values_reordered, coords=dict(x=x, y=y, z=z), name=self.values.name)
+        **Parameters Caveats**
 
-    @abstractmethod
-    @requires_vtk
-    def sel(
-        self,
-        x: Union[float, ArrayLike] = None,
-        y: Union[float, ArrayLike] = None,
-        z: Union[float, ArrayLike] = None,
-    ) -> Union[UnstructuredGridDataset, SpatialDataArray]:
-        """Extract/interpolate data along one or more Cartesian directions. At least of x, y, and z
-        must be provided.
-
-        Parameters
-        ----------
-        x : Union[float, ArrayLike] = None
-            x-coordinate of the slice.
-        y : Union[float, ArrayLike] = None
-            y-coordinate of the slice.
-        z : Union[float, ArrayLike] = None
-            z-coordinate of the slice.
+        The :attr:`center` and :attr:`size` parameters define
+        where the monitor will be placed in order to record near fields, typically very close
+        to the structure of interest. The near fields are then projected
+        to far-field locations defined by :attr:`phi`, :attr:`theta`, and :attr:`proj_distance`, relative
+        to the :attr:`custom_origin`.
 
-        Returns
-        -------
-        Union[TriangularGridDataset, SpatialDataArray]
-            Extracted data.
-        """
+        **Usage Caveats**
 
-    @requires_vtk
-    def reflect(
-        self, axis: Axis, center: float, reflection_only: bool = False
-    ) -> UnstructuredGridDataset:
-        """Reflect unstructured data across the plane define by parameters ``axis`` and ``center``.
-        By default the original data is preserved, setting ``reflection_only`` to ``True`` will
-        produce only deflected data.
-
-        Parameters
-        ----------
-        axis : Literal[0, 1, 2]
-            Normal direction of the reflection plane.
-        center : float
-            Location of the reflection plane along its normal direction.
-        reflection_only : bool = False
-            Return only reflected data.
+        The field projections make use of the analytical homogeneous medium Greens function, which assumes that the
+        fields are propagating in a homogeneous medium. Therefore, one should use :class:`PML` / :class:`Absorber` as
+        boundary conditions in the part of the domain where fields are projected.
 
-        Returns
-        -------
-        UnstructuredGridDataset
-            Data after reflextion is performed.
-        """
+        .. TODO why not add equation here
 
-        reflector = vtk["mod"].vtkReflectionFilter()
-        reflector.SetPlane([reflector.USE_X, reflector.USE_Y, reflector.USE_Z][axis])
-        reflector.SetCenter(center)
-        reflector.SetCopyInput(not reflection_only)
-        reflector.SetInputData(self._vtk_obj)
-        reflector.Update()
-
-        return self._from_vtk_obj(reflector.GetOutput())
-
-
-class TriangularGridDataset(UnstructuredGridDataset):
-    """Dataset for storing triangular grid data.
-
-    Note
-    ----
-    To use full functionality of unstructured datasets one must install ``vtk`` package (``pip
-    install tidy3d[vtk]`` or ``pip install vtk``). Otherwise the functionality of unstructured
-    datasets is limited to creation, writing to/loading from a file, and arithmetic manipulations.
+        Server-side field projections will add to the monetary cost of the simulation. However, typically the far field
+        projections have a very small computation cost compared to the FDTD simulation itself, so the increase in monetary
+        cost should be negligibly small in most cases. For applications where the monitor is an open surface rather than a box that
+        encloses the device, it is advisable to pick the size of the monitor such that the
+        recorded near fields decay to negligible values near the edges of the monitor.
 
-    Example
-    -------
-    >>> tri_grid_points = PointDataArray(
-    ...     [[0.0, 0.0], [1.0, 0.0], [0.0, 1.0], [1.0, 1.0]],
-    ...     coords=dict(index=np.arange(4), axis=np.arange(2)),
-    ... )
-    >>>
-    >>> tri_grid_cells = CellDataArray(
-    ...     [[0, 1, 2], [1, 2, 3]],
-    ...     coords=dict(cell_index=np.arange(2), vertex_index=np.arange(3)),
-    ... )
-    >>>
-    >>> tri_grid_values = IndexedDataArray(
-    ...     [1.0, 2.0, 3.0, 4.0], coords=dict(index=np.arange(4)),
-    ... )
-    >>>
-    >>> tri_grid = TriangularGridDataset(
-    ...     normal_axis=1,
-    ...     normal_pos=0,
-    ...     points=tri_grid_points,
-    ...     cells=tri_grid_cells,
-    ...     values=tri_grid_values,
-    ... )
-    """
+        .. TODO TYPO FIX o that the approximations are not used, and the projection is accurate even just a few wavelengths away from the near field locations.
 
-    normal_axis: Axis = pd.Field(
-        ...,
-        title="Grid Axis",
-        description="Orientation of the grid.",
-    )
+        By default, if no :attr:`proj_distance` was provided, the fields are projected to a distance of 1m.
 
-    normal_pos: float = pd.Field(
-        ...,
-        title="Position",
-        description="Coordinate of the grid along the normal direction.",
-    )
+        **Server-side field projection Application**
 
-    @cached_property
-    def bounds(self) -> Bound:
-        """Grid bounds."""
-        bounds_2d = super().bounds
-        bounds_3d = self._points_2d_to_3d(bounds_2d)
-        return tuple(bounds_3d[0]), tuple(bounds_3d[1])
-
-    @classmethod
-    def _point_dims(cls) -> pd.PositiveInt:
-        """Dimensionality of stored grid point coordinates."""
-        return 2
-
-    def _points_2d_to_3d(self, pts: ArrayLike) -> ArrayLike:
-        """Convert 2d points into 3d points."""
-        return np.insert(pts, obj=self.normal_axis, values=self.normal_pos, axis=1)
+        Provide the :class:`FieldProjectionAngleMonitor` monitor as an input to the
+        :class:`Simulation` object as one of its monitors. Now, we no longer need to provide a separate near-field
+        :class:`FieldMonitor` - the near fields will automatically be recorded based on the size and location of the
+        ``FieldProjectionAngleMonitor``. Note also that in some cases, the server-side computations may be slightly
+        more accurate than client-side ones, because on the server, the near fields are not downsampled at all.
 
-    @cached_property
-    def _points_3d_array(self) -> ArrayLike:
-        """3D representation of grid points."""
-        return self._points_2d_to_3d(self.points.data)
-
-    @classmethod
-    def _cell_num_vertices(cls) -> pd.PositiveInt:
-        """Number of vertices in a cell."""
-        return 3
-
-    @classmethod
-    @requires_vtk
-    def _vtk_cell_type(cls):
-        """VTK cell type to use in the VTK representation."""
-        return vtk["mod"].VTK_TRIANGLE
-
-    @classmethod
-    @requires_vtk
-    def _from_vtk_obj(cls, vtk_obj, field=None):
-        """Initialize from a vtkUnstructuredGrid instance."""
-
-        # get points cells data from vtk object
-        if isinstance(vtk_obj, vtk["mod"].vtkPolyData):
-            cells_vtk = vtk_obj.GetPolys()
-        elif isinstance(vtk_obj, vtk["mod"].vtkUnstructuredGrid):
-            cells_vtk = vtk_obj.GetCells()
-
-        cells_numpy = vtk["vtk_to_numpy"](cells_vtk.GetConnectivityArray())
-
-        cell_offsets = vtk["vtk_to_numpy"](cells_vtk.GetOffsetsArray())
-        if not np.all(np.diff(cell_offsets) == cls._cell_num_vertices()):
-            raise DataError(
-                "Only triangular 'vtkUnstructuredGrid' or 'vtkPolyData' can be converted into "
-                "'TriangularGridDataset'."
-            )
+        We can re-project the already-computed far fields to a different distance away from the structure - we
+        neither need to run another simulation nor re-run the :class:`FieldProjector`.
 
-        points_numpy = vtk["vtk_to_numpy"](vtk_obj.GetPoints().GetData())
+        **Far-Field Approximation Selection**
 
-        # data values are read directly into Tidy3D array
-        values = cls._get_values_from_vtk(vtk_obj, len(points_numpy), field)
+        .. TODO unsure if add on params?
 
-        # detect zero size dimension
-        bounds = np.max(points_numpy, axis=0) - np.min(points_numpy, axis=0)
-        zero_dims = np.where(np.isclose(bounds, 0))[0]
-
-        if len(zero_dims) != 1:
-            raise DataError(
-                f"Provided vtk grid does not represent a two dimensional grid. Found zero size dimensions are {zero_dims}."
-            )
+        If the distance between the near and far field locations is
+        much larger than the size of the device, one can typically set :attr:`far_field_approx` to
+        ``True``, which will make use of the far-field approximation to speed up calculations.
+        If the projection distance is comparable to the size of the device, we recommend setting
+        :attr:`far_field_approx` to ``False``.
 
-        normal_axis = zero_dims[0]
-        normal_pos = points_numpy[0][normal_axis]
-        tan_dims = [0, 1, 2]
-        tan_dims.remove(normal_axis)
-
-        # convert 3d coordinates into 2d
-        points_2d_numpy = points_numpy[:, tan_dims]
-
-        # create Tidy3D points and cells arrays
-        num_cells = len(cells_numpy) // cls._cell_num_vertices()
-        cells_numpy = np.reshape(cells_numpy, (num_cells, cls._cell_num_vertices()))
-
-        cells = CellDataArray(
-            cells_numpy,
-            coords=dict(
-                cell_index=np.arange(num_cells), vertex_index=np.arange(cls._cell_num_vertices())
-            ),
-        )
+        .. image:: ../../notebooks/img/n2f_diagram.png
 
-        points = PointDataArray(
-            points_2d_numpy,
-            coords=dict(index=np.arange(len(points_numpy)), axis=np.arange(cls._point_dims())),
-        )
+        .. TODO Fix that image so remove right irrelevant side
 
-        return cls(
-            normal_axis=normal_axis,
-            normal_pos=normal_pos,
-            points=points,
-            cells=cells,
-            values=values,
-        )
+        When selected, it is assumed that:
 
-    @requires_vtk
-    def plane_slice(self, axis: Axis, pos: float) -> SpatialDataArray:
-        """Slice data with a plane and return the resulting line as a SpatialDataArray.
-
-        Parameters
-        ----------
-        axis : Axis
-            The normal direction of the slicing plane.
-        pos : float
-            Position of the slicing plane along its normal direction.
+        -   The fields are measured at a distance much greater than the size of our simulation in the transverse
+            direction.
+        -   The geometric approximations imply that any quantity whose magnitude drops off as
+            :math:`\\frac{1}{r^2}` or faster is ignored.
 
-        Returns
-        -------
-        SpatialDataArray
-            The resulting slice.
-        """
+        The advantages of these approximations are:
 
-        if axis == self.normal_axis:
-            raise DataError(
-                f"Triangular grid (normal: {self.normal_axis}) cannot be sliced by a parallel "
-                "plane."
-            )
+        *   The projections are computed relatively fast.
+        *   The projections are cast in a simple mathematical form.
+            which allows re-projecting the fields to different distance without the need to re-run a simulation or to
+            re-run the :class:`FieldProjector`.
 
-        # perform slicing in vtk and get unprocessed points and values
-        slice_vtk = self._plane_slice_raw(axis=axis, pos=pos)
-        points_numpy = vtk["vtk_to_numpy"](slice_vtk.GetPoints().GetData())
-        values = self._get_values_from_vtk(slice_vtk, len(points_numpy))
-
-        # axis of the resulting line
-        slice_axis = 3 - self.normal_axis - axis
-
-        # sort found intersection in ascending order
-        sorting = np.argsort(points_numpy[:, slice_axis], kind="mergesort")
-
-        # assemble coords for SpatialDataArray
-        coords = [None, None, None]
-        coords[axis] = [pos]
-        coords[self.normal_axis] = [self.normal_pos]
-        coords[slice_axis] = points_numpy[sorting, slice_axis]
-        coords_dict = dict(zip("xyz", coords))
-
-        # reshape values from a 1d array into a 3d array
-        new_shape = [1, 1, 1]
-        new_shape[slice_axis] = len(values)
-        values_reshaped = np.reshape(values.data[sorting], new_shape)
+        In cases where we may want to project to intermediate distances where the far field approximation is no
+        longer valid, simply include the class definition parameter :attr:`far_field_approx` to ``False`` in the
+        ``FieldProjectionAngleMonitor`` instantiation. The resulting computations will be a bit slower,
+        but the results will be significantly more accurate.
 
-        return SpatialDataArray(values_reshaped, coords=coords_dict, name=self.values.name)
+        .. TODO include here inherited methods.
 
-    @property
-    def _triangulation_obj(self) -> Triangulation:
-        """Matplotlib triangular representation of the grid to use in plotting."""
-        return Triangulation(self.points[:, 0], self.points[:, 1], self.cells)
+    Example
+    -------
+    >>> monitor = FieldProjectionAngleMonitor(
+    ...     center=(1,2,3),
+    ...     size=(2,2,2),
+    ...     freqs=[250e12, 300e12],
+    ...     name='n2f_monitor',
+    ...     custom_origin=(1,2,3),
+    ...     phi=[0, np.pi/2],
+    ...     theta=np.linspace(-np.pi/2, np.pi/2, 100),
+    ...     far_field_approx=True,
+    ...     )
+
+    See Also
+    --------
+
+    **Notebooks**:
+
+        * `Performing near field to far field projections <../../notebooks/FieldProjections.html>`_
+        * `Field projection for a zone plate <../../notebooks/ZonePlateFieldProjection.html>`_: Realistic case study further demonstrating the accuracy of the field projections.
+        * `Metalens in the visible frequency range <../../notebooks/Metalens.html>`_: Realistic case study further demonstrating the accuracy of the field projections.
+        * `Multilevel blazed diffraction grating <../../notebooks/GratingEfficiency.html>`_: For far field projections in the context of perdiodic boundary conditions.
+    """
 
-    @equal_aspect
-    @add_ax_if_none
-    def plot(
-        self,
-        ax: Ax = None,
-        field: bool = True,
-        grid: bool = True,
-        cbar: bool = True,
-        cmap: str = "viridis",
-        vmin: float = None,
-        vmax: float = None,
-        shading: Literal["gourand", "flat"] = "gouraud",
-        cbar_kwargs: Dict = None,
-    ) -> Ax:
-        """Plot the data field and/or the unstructured grid.
+    proj_distance: float = pydantic.Field(
+        1e6,
+        title="Projection Distance",
+        description="Radial distance of the projection points from ``local_origin``.",
+        units=MICROMETER,
+    )
 
-        Parameters
-        ----------
-        ax : matplotlib.axes._subplots.Axes = None
-            matplotlib axes to plot on, if not specified, one is created.
-        field : bool = True
-            Whether to plot the data field.
-        grid : bool = True
-            Whether to plot the unstructured grid.
-        cbar : bool = True
-            Display colorbar (only if ``field == True``).
-        cmap : str = "viridis"
-            Color map to use for plotting.
-        vmin : float = None
-            The lower bound of data range that the colormap covers. If ``None``, they are
-            inferred from the data and other keyword arguments.
-        vmax : float = None
-            The upper bound of data range that the colormap covers. If ``None``, they are
-            inferred from the data and other keyword arguments.
-        shading : Literal["gourand", "flat"] = "gourand"
-            Type of shading to use when plotting the data field.
-        cbar_kwargs : Dict = {}
-            Additional parameters passed to colorbar object.
+    theta: ObsGridArray = pydantic.Field(
+        ...,
+        title="Polar Angles",
+        description="Polar angles with respect to the global z axis, relative to the location of "
+        "``local_origin``, at which to project fields.",
+        units=RADIAN,
+    )
 
-        Returns
-        -------
-        matplotlib.axes._subplots.Axes
-            The supplied or created matplotlib axes.
-        """
+    phi: ObsGridArray = pydantic.Field(
+        ...,
+        title="Azimuth Angles",
+        description="Azimuth angles with respect to the global z axis, relative to the location of "
+        "``local_origin``, at which to project fields.",
+        units=RADIAN,
+    )
 
-        if cbar_kwargs is None:
-            cbar_kwargs = {}
-        if not (field or grid):
-            raise DataError("Nothing to plot ('field == False', 'grid == False').")
-
-        # plot data field if requested
-        if field:
-            plot_obj = ax.tripcolor(
-                self._triangulation_obj,
-                self.values.data,
-                shading=shading,
-                cmap=cmap,
-                vmin=vmin,
-                vmax=vmax,
-            )
+    def storage_size(self, num_cells: int, tmesh: ArrayFloat1D) -> int:
+        """Size of monitor storage given the number of points after discretization."""
+        # stores 1 complex number per pair of angles, per frequency,
+        # for Er, Etheta, Ephi, Hr, Htheta, and Hphi (6 components)
+        return BYTES_COMPLEX * len(self.theta) * len(self.phi) * len(self.freqs) * 6
 
-            if cbar:
-                label_kwargs = {}
-                if "label" not in cbar_kwargs:
-                    label_kwargs["label"] = self.values.name
-                plt.colorbar(plot_obj, **cbar_kwargs, **label_kwargs)
-
-        # plot grid if requested
-        if grid:
-            ax.triplot(
-                self._triangulation_obj,
-                color=plot_params_grid.edgecolor,
-                linewidth=plot_params_grid.linewidth,
-            )
 
-        # set labels and titles
-        ax_labels = ["x", "y", "z"]
-        normal_axis_name = ax_labels.pop(self.normal_axis)
-        ax.set_xlabel(ax_labels[0])
-        ax.set_ylabel(ax_labels[1])
-        ax.set_title(f"{normal_axis_name} = {self.normal_pos}")
-        return ax
+class FieldProjectionCartesianMonitor(AbstractFieldProjectionMonitor):
+    """:class:`Monitor` that samples electromagnetic near fields in the frequency domain
+    and projects them on a Cartesian observation plane.
 
-    @requires_vtk
-    def interp(
-        self,
-        x: Union[float, ArrayLike],
-        y: Union[float, ArrayLike],
-        z: Union[float, ArrayLike],
-        fill_value: float = 0,
-        ignore_normal_pos: bool = True,
-    ) -> SpatialDataArray:
-        """Interpolate data at provided x, y, and z.
-
-        Parameters
-        ----------
-        x : Union[float, ArrayLike]
-            x-coordinates of sampling points.
-        y : Union[float, ArrayLike]
-            y-coordinates of sampling points.
-        z : Union[float, ArrayLike]
-            z-coordinates of sampling points.
-        fill_value : float = 0
-            Value to use when filling points without interpolated values.
-        ignore_normal_pos : bool = True
-            Assume data is invariant along the normal direction to the grid plane.
+    Notes
+    -----
 
-        Returns
-        -------
-        SpatialDataArray
-            Interpolated data.
-        """
+        **Parameters Caveats**
 
-        x = np.atleast_1d(x)
-        y = np.atleast_1d(y)
-        z = np.atleast_1d(z)
-
-        if ignore_normal_pos:
-            xyz = [x, y, z]
-            xyz[self.normal_axis] = [self.normal_pos]
-            interp_inplane = super().interp(**dict(zip("xyz", xyz)), fill_value=fill_value)
-            interp_broadcasted = np.broadcast_to(
-                interp_inplane, [len(np.atleast_1d(comp)) for comp in [x, y, z]]
-            )
+        The :attr:`center` and :attr:`size` fields define
+        where the monitor will be placed in order to record near fields, typically very close
+        to the structure of interest. The near fields are then projected
+        to far-field locations defined by :attr:`x`, :attr:`y`, and :attr:`proj_distance`, relative
+        to the :attr:`custom_origin`.
 
-            return SpatialDataArray(
-                interp_broadcasted, coords=dict(x=x, y=y, z=z), name=self.values.name
-            )
+        Here, :attr:`x` and :attr:`y`, correspond to a local coordinate system
+        where the local ``z`` axis is defined by :attr:`proj_axis`: which is the axis normal to this monitor.
 
-        return super().interp(x=x, y=y, z=z, fill_value=fill_value)
+        **Far-Field Approximation Selection**
 
-    @requires_vtk
-    def sel(
-        self,
-        x: Union[float, ArrayLike] = None,
-        y: Union[float, ArrayLike] = None,
-        z: Union[float, ArrayLike] = None,
-    ) -> SpatialDataArray:
-        """Extract/interpolate data along one or more Cartesian directions. At least of x, y, and z
-        must be provided.
-
-        Parameters
-        ----------
-        x : Union[float, ArrayLike] = None
-            x-coordinate of the slice.
-        y : Union[float, ArrayLike] = None
-            y-coordinate of the slice.
-        z : Union[float, ArrayLike] = None
-            z-coordinate of the slice.
+        If the distance between the near and far field locations is much larger than the size of the
+        device, one can typically set :attr:`far_field_approx` to ``True``, which will make use of the
+        far-field approximation to speed up calculations. If the projection distance is comparable
+        to the size of the device, we recommend setting :attr:`far_field_approx` to ``False``,
+        so that the approximations are not used, and the projection is accurate even just a few
+        wavelengths away from the near field locations.
 
-        Returns
-        -------
-        SpatialDataArray
-            Extracted data.
-        """
+        For applications where the monitor is an open surface rather than a box that
+        encloses the device, it is advisable to pick the size of the monitor such that the
+        recorded near fields decay to negligible values near the edges of the monitor.
 
-        xyz = [x, y, z]
-        axes = [ind for ind, comp in enumerate(xyz) if comp is not None]
-        num_provided = len(axes)
-
-        if self.normal_axis in axes:
-            if xyz[self.normal_axis] != self.normal_pos:
-                raise DataError(
-                    f"No data for {'xyz'[self.normal_axis]} = {xyz[self.normal_axis]} (unstructured"
-                    f" grid is defined at {'xyz'[self.normal_axis]} = {self.normal_pos})."
-                )
+        .. image:: ../../notebooks/img/n2f_diagram.png
 
-            if num_provided < 3:
-                num_provided -= 1
-                axes.remove(self.normal_axis)
-
-        if num_provided == 0:
-            raise DataError("At least one of 'x', 'y', and 'z' must be specified.")
-
-        if num_provided == 1:
-            axis = axes[0]
-            return self.plane_slice(axis=axis, pos=xyz[axis])
-
-        if num_provided == 2:
-            pos = [x, y, z]
-            pos[self.normal_axis] = [self.normal_pos]
-            return self.interp(x=pos[0], y=pos[1], z=pos[2])
-
-        if num_provided == 3:
-            return self.interp(x=x, y=y, z=z)
-
-    @requires_vtk
-    def reflect(
-        self, axis: Axis, center: float, reflection_only: bool = False
-    ) -> UnstructuredGridDataset:
-        """Reflect unstructured data across the plane define by parameters ``axis`` and ``center``.
-        By default the original data is preserved, setting ``reflection_only`` to ``True`` will
-        produce only deflected data.
-
-        Parameters
-        ----------
-        axis : Literal[0, 1, 2]
-            Normal direction of the reflection plane.
-        center : float
-            Location of the reflection plane along its normal direction.
-        reflection_only : bool = False
-            Return only reflected data.
+        .. TODO unsure if add on params?
 
-        Returns
-        -------
-        UnstructuredGridDataset
-            Data after reflextion is performed.
-        """
+        When selected, it is assumed that:
 
-        # disallow reflecting along normal direction
-        if axis == self.normal_axis:
-            raise DataError("Reflection in the normal direction to the grid is prohibited.")
+        -   The fields are measured at a distance much greater than the size of our simulation in the transverse
+            direction.
+        -   The geometric approximations imply that any quantity whose magnitude drops off as
+            :math:`\\frac{1}{r^2}` or faster is ignored.
 
-        return super().reflect(axis=axis, center=center, reflection_only=reflection_only)
+        The advantages of these approximations are:
 
+        *   The projections are computed relatively fast.
+        *   The projections are cast in a simple mathematical form.
+            which allows re-projecting the fields to different distance without the need to re-run a simulation or to
+            re-run the :class:`FieldProjector`.
 
-class TetrahedralGridDataset(UnstructuredGridDataset):
-    """Dataset for storing tetrahedral grid data.
 
-    Note
-    ----
-    To use full functionality of unstructured datasets one must install ``vtk`` package (``pip
-    install tidy3d[vtk]`` or ``pip install vtk``). Otherwise the functionality of unstructured
-    datasets is limited to creation, writing to/loading from a file, and arithmetic manipulations.
+        In cases where we may want to project to intermediate distances where the far field approximation is no
+        longer valid, simply include the class definition parameter ``far_field_approx=False`` in the
+        ``FieldProjectionCartesianMonitor`` instantiation. The resulting computations will be a bit slower,
+        but the results will be significantly more accurate.
 
-    Example
-    -------
-    >>> tet_grid_points = PointDataArray(
-    ...     [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]],
-    ...     coords=dict(index=np.arange(4), axis=np.arange(3)),
-    ... )
-    >>>
-    >>> tet_grid_cells = CellDataArray(
-    ...     [[0, 1, 2, 3]],
-    ...     coords=dict(cell_index=np.arange(1), vertex_index=np.arange(4)),
-    ... )
-    >>>
-    >>> tet_grid_values = IndexedDataArray(
-    ...     [1.0, 2.0, 3.0, 4.0], coords=dict(index=np.arange(4)),
-    ... )
-    >>>
-    >>> tet_grid = TetrahedralGridDataset(
-    ...     points=tet_grid_points,
-    ...     cells=tet_grid_cells,
-    ...     values=tet_grid_values,
-    ... )
-    """
+        .. TODO include this example
 
-    @classmethod
-    def _point_dims(cls) -> pd.PositiveInt:
-        """Dimensionality of stored grid point coordinates."""
-        return 3
+        **Usage Caveats**
 
-    @cached_property
-    def _points_3d_array(self) -> Bound:
-        """3D coordinates of grid points."""
-        return self.points.data
-
-    @classmethod
-    def _cell_num_vertices(cls) -> pd.PositiveInt:
-        """Number of vertices in a cell."""
-        return 4
-
-    @classmethod
-    @requires_vtk
-    def _vtk_cell_type(cls):
-        """VTK cell type to use in the VTK representation."""
-        return vtk["mod"].VTK_TETRA
-
-    @classmethod
-    @requires_vtk
-    def _from_vtk_obj(cls, grid, field=None) -> TetrahedralGridDataset:
-        """Initialize from a vtkUnstructuredGrid instance."""
-
-        # read point, cells, and values info from a vtk instance
-        cells_numpy = vtk["vtk_to_numpy"](grid.GetCells().GetConnectivityArray())
-        points_numpy = vtk["vtk_to_numpy"](grid.GetPoints().GetData())
-        values = cls._get_values_from_vtk(grid, len(points_numpy), field)
-
-        # verify cell_types
-        cells_types = vtk["vtk_to_numpy"](grid.GetCellTypesArray())
-        if not np.all(cells_types == cls._vtk_cell_type()):
-            raise DataError("Only tetrahedral 'vtkUnstructuredGrid' is currently supported")
-
-        # pack point and cell information into Tidy3D arrays
-        num_cells = len(cells_numpy) // cls._cell_num_vertices()
-        cells_numpy = np.reshape(cells_numpy, (num_cells, cls._cell_num_vertices()))
-
-        cells = CellDataArray(
-            cells_numpy,
-            coords=dict(
-                cell_index=np.arange(num_cells), vertex_index=np.arange(cls._cell_num_vertices())
-            ),
-        )
+        .. TODO I believe a little illustration here would be handy.
 
-        points = PointDataArray(
-            points_numpy,
-            coords=dict(index=np.arange(len(points_numpy)), axis=np.arange(cls._point_dims())),
-        )
+        Since field projections rely on the surface equivalence principle, we have assumed that the tangential near
+        fields recorded on the near field monitor serve as equivalent sources which generate the correct far fields.
+        However, this requires that the field strength decays nearly to zero near the edges of the near-field
+        monitor, which may not always be the case. For example, if we had used a larger aperture compared to the full
+        simulation size in the transverse direction, we may expect a degradation in accuracy of the field
+        projections. Despite this limitation, the field projections are still remarkably accurate in realistic
+        scenarios. For realistic case studies further demonstrating the accuracy of the field projections,
+        see our metalens and zone plate case studies.
 
-        return cls(points=points, cells=cells, values=values)
+        The field projections make use of the analytical homogeneous medium Greens function, which assumes that the fields
+        are propagating in a homogeneous medium. Therefore, one should use PMLs / absorbers as boundary conditions in the
+        part of the domain where fields are projected. For far field projections in the context of perdiodic boundary
+        conditions, see the diffraction efficiency example which demonstrates the use of a DiffractionMonitor.
 
-    @requires_vtk
-    def plane_slice(self, axis: Axis, pos: float) -> TriangularGridDataset:
-        """Slice data with a plane and return the resulting :class:.`TriangularGridDataset`.
-
-        Parameters
-        ----------
-        axis : Axis
-            The normal direction of the slicing plane.
-        pos : float
-            Position of the slicing plane along its normal direction.
+        Server-side field projections will add to the monetary cost of the simulation. However, typically the far field
+        projections have a very small computation cost compared to the FDTD simulation itself, so the increase in monetary
+        cost should be negligibly small in most cases.
 
-        Returns
-        -------
-        TriangularGridDataset
-            The resulting slice.
-        """
+    Example
+    -------
+    >>> monitor = FieldProjectionCartesianMonitor(
+    ...     center=(1,2,3),
+    ...     size=(2,2,2),
+    ...     freqs=[250e12, 300e12],
+    ...     name='n2f_monitor',
+    ...     custom_origin=(1,2,3),
+    ...     x=[-1, 0, 1],
+    ...     y=[-2, -1, 0, 1, 2],
+    ...     proj_axis=2,
+    ...     proj_distance=5,
+    ...     far_field_approx=True,
+    ...     )
+
+    See Also
+    --------
+
+    **Notebooks**:
+        * `Performing near field to far field projections <../../notebooks/FieldProjections.html>`_
+        * `Field projection for a zone plate <../../notebooks/ZonePlateFieldProjection.html>`_
+        * `Metalens in the visible frequency range <../../notebooks/Metalens.html>`_
+        * `Multilevel blazed diffraction grating <../../notebooks/GratingEfficiency.html>`_
+    """
 
-        slice_vtk = self._plane_slice_raw(axis=axis, pos=pos)
+    proj_axis: Axis = pydantic.Field(
+        ...,
+        title="Projection Plane Axis",
+        description="Axis along which the observation plane is oriented.",
+    )
 
-        return TriangularGridDataset._from_vtk_obj(slice_vtk)
+    proj_distance: float = pydantic.Field(
+        1e6,
+        title="Projection Distance",
+        description="Signed distance of the projection plane along ``proj_axis``. "
+        "from the plane containing ``local_origin``.",
+        units=MICROMETER,
+    )
 
-    @requires_vtk
-    def line_slice(self, axis: Axis, pos: Coordinate) -> SpatialDataArray:
-        """Slice data with a line and return the resulting :class:.`SpatialDataArray`.
-
-        Parameters
-        ----------
-        axis : Axis
-            The axis of the slicing line.
-        pos : Tuple[float, float, float]
-            Position of the slicing line.
+    x: ObsGridArray = pydantic.Field(
+        ...,
+        title="Local x Observation Coordinates",
+        description="Local x observation coordinates w.r.t. ``local_origin`` and ``proj_axis``. "
+        "When ``proj_axis`` is 0, this corresponds to the global y axis. "
+        "When ``proj_axis`` is 1, this corresponds to the global x axis. "
+        "When ``proj_axis`` is 2, this corresponds to the global x axis. ",
+        units=MICROMETER,
+    )
 
-        Returns
-        -------
-        SpatialDataArray
-            The resulting slice.
-        """
+    y: ObsGridArray = pydantic.Field(
+        ...,
+        title="Local y Observation Coordinates",
+        description="Local y observation coordinates w.r.t. ``local_origin`` and ``proj_axis``. "
+        "When ``proj_axis`` is 0, this corresponds to the global z axis. "
+        "When ``proj_axis`` is 1, this corresponds to the global z axis. "
+        "When ``proj_axis`` is 2, this corresponds to the global y axis. ",
+        units=MICROMETER,
+    )
+
+    def storage_size(self, num_cells: int, tmesh: ArrayFloat1D) -> int:
+        """Size of monitor storage given the number of points after discretization."""
+        # stores 1 complex number per pair of grid points, per frequency,
+        # for Er, Etheta, Ephi, Hr, Htheta, and Hphi (6 components)
+        return BYTES_COMPLEX * len(self.x) * len(self.y) * len(self.freqs) * 6
+
+
+class FieldProjectionKSpaceMonitor(AbstractFieldProjectionMonitor):
+    """:class:`Monitor` that samples electromagnetic near fields in the frequency domain
+    and projects them on an observation plane defined in k-space.
+
+     Notes
+     -----
+
+        The :attr:`center` and :attr:`size`
+        fields define where the monitor will be placed in order to record near fields, typically
+        very close to the structure of interest. The near fields are then
+        projected to far-field locations defined in k-space by ``ux``, ``uy``, and ``proj_distance``,
+        relative to the ``custom_origin``. Here, ``ux`` and ``uy`` are associated with a local
+        coordinate system where the local 'z' axis is defined by ``proj_axis``: which is the axis
+        normal to this monitor. If the distance between the near and far field locations is much
+        larger than the size of the device, one can typically set ``far_field_approx`` to ``True``,
+        which will make use of the far-field approximation to speed up calculations. If the
+        projection distance is comparable to the size of the device, we recommend setting
+        ``far_field_approx`` to ``False``, so that the approximations are not used, and the
+        projection is accurate even just a few wavelengths away from the near field locations.
+        For applications where the monitor is an open surface rather than a box that
+        encloses the device, it is advisable to pick the size of the monitor such that the
+        recorded near fields decay to negligible values near the edges of the monitor.
+
+        **Usage Caveats**
+
+        .. TODO I believe a little illustration here would be handy.
+
+        Since field projections rely on the surface equivalence principle, we have assumed that the tangential near
+        fields recorded on the near field monitor serve as equivalent sources which generate the correct far fields.
+        However, this requires that the field strength decays nearly to zero near the edges of the near-field
+        monitor, which may not always be the case. For example, if we had used a larger aperture compared to the full
+        simulation size in the transverse direction, we may expect a degradation in accuracy of the field
+        projections. Despite this limitation, the field projections are still remarkably accurate in realistic
+        scenarios. For realistic case studies further demonstrating the accuracy of the field projections,
+        see our metalens and zone plate case studies.
+
+        The field projections make use of the analytical homogeneous medium Greens function, which assumes that the fields
+        are propagating in a homogeneous medium. Therefore, one should use PMLs / absorbers as boundary conditions in the
+        part of the domain where fields are projected. For far field projections in the context of perdiodic boundary
+        conditions, see the diffraction efficiency example which demonstrates the use of a :class:`DiffractionMonitor`.
+
+        Server-side field projections will add to the monetary cost of the simulation. However, typically the far field
+        projections have a very small computation cost compared to the FDTD simulation itself, so the increase in monetary
+        cost should be negligibly small in most cases.
 
-        bounds = self.bounds
-        start = list(pos)
-        end = list(pos)
-
-        start[axis] = bounds[0][axis]
-        end[axis] = bounds[1][axis]
-
-        # create cutting plane
-        line = vtk["mod"].vtkLineSource()
-        line.SetPoint1(start)
-        line.SetPoint2(end)
-        line.SetResolution(1)
-
-        # this should be done using vtkProbeLineFilter
-        # but for some reason it crashes Python
-        # so, we use a workaround:
-        # 1) extract cells that are intersected by line (to speed up further slicing)
-        # 2) do plane slice along first direction
-        # 3) do second plane slice along second direction
-
-        prober = vtk["mod"].vtkExtractCellsAlongPolyLine()
-        prober.SetSourceConnection(line.GetOutputPort())
-        prober.SetInputData(self._vtk_obj)
-        prober.Update()
-
-        extracted_cells_vtk = prober.GetOutput()
-
-        if extracted_cells_vtk.GetNumberOfPoints() == 0:
-            raise DataError("Slicing line does not intersect the unstructured grid.")
-
-        extracted_cells = TetrahedralGridDataset._from_vtk_obj(extracted_cells_vtk)
-
-        tan_dims = [0, 1, 2]
-        tan_dims.remove(axis)
-
-        # first plane slice
-        plane_slice = extracted_cells.plane_slice(axis=tan_dims[0], pos=pos[tan_dims[0]])
-        # second plane slice
-        line_slice = plane_slice.plane_slice(axis=tan_dims[1], pos=pos[tan_dims[1]])
+    Example
+    -------
+    >>> monitor = FieldProjectionKSpaceMonitor(
+    ...     center=(1,2,3),
+    ...     size=(2,2,2),
+    ...     freqs=[250e12, 300e12],
+    ...     name='n2f_monitor',
+    ...     custom_origin=(1,2,3),
+    ...     proj_axis=2,
+    ...     ux=[0.1,0.2],
+    ...     uy=[0.3,0.4,0.5]
+    ...     )
+
+    See Also
+    --------
+
+    **Notebooks**:
+        * `Performing near field to far field projections <../../notebooks/FieldProjections.html>`_
+        * `Field projection for a zone plate <../../notebooks/ZonePlateFieldProjection.html>`_
+        * `Metalens in the visible frequency range <../../notebooks/Metalens.html>`_
+        * `Multilevel blazed diffraction grating <../../notebooks/GratingEfficiency.html>`_
+    """
 
-        return line_slice
+    proj_axis: Axis = pydantic.Field(
+        ...,
+        title="Projection Plane Axis",
+        description="Axis along which the observation plane is oriented.",
+    )
 
-    @requires_vtk
-    def sel(
-        self,
-        x: Union[float, ArrayLike] = None,
-        y: Union[float, ArrayLike] = None,
-        z: Union[float, ArrayLike] = None,
-    ) -> Union[TriangularGridDataset, SpatialDataArray]:
-        """Extract/interpolate data along one or more Cartesian directions. At least of x, y, and z
-        must be provided.
-
-        Parameters
-        ----------
-        x : Union[float, ArrayLike] = None
-            x-coordinate of the slice.
-        y : Union[float, ArrayLike] = None
-            y-coordinate of the slice.
-        z : Union[float, ArrayLike] = None
-            z-coordinate of the slice.
+    proj_distance: float = pydantic.Field(
+        1e6,
+        title="Projection Distance",
+        description="Radial distance of the projection points from ``local_origin``.",
+        units=MICROMETER,
+    )
 
-        Returns
-        -------
-        Union[TriangularGridDataset, SpatialDataArray]
-            Extracted data.
-        """
+    ux: ObsGridArray = pydantic.Field(
+        ...,
+        title="Normalized kx",
+        description="Local x component of wave vectors on the observation plane, "
+        "relative to ``local_origin`` and oriented with respect to ``proj_axis``, "
+        "normalized by (2*pi/lambda) where lambda is the wavelength "
+        "associated with the background medium. Must be in the range [-1, 1].",
+    )
 
-        xyz = [x, y, z]
-        axes = [ind for ind, comp in enumerate(xyz) if comp is not None]
+    uy: ObsGridArray = pydantic.Field(
+        ...,
+        title="Normalized ky",
+        description="Local y component of wave vectors on the observation plane, "
+        "relative to ``local_origin`` and oriented with respect to ``proj_axis``, "
+        "normalized by (2*pi/lambda) where lambda is the wavelength "
+        "associated with the background medium. Must be in the range [-1, 1].",
+    )
+
+    @pydantic.root_validator()
+    def reciprocal_vector_range(cls, values):
+        """Ensure that ux, uy are in [-1, 1]."""
+        maxabs_ux = max(list(values.get("ux")), key=abs)
+        maxabs_uy = max(list(values.get("uy")), key=abs)
+        name = values.get("name")
+        if maxabs_ux > 1:
+            raise SetupError(f"Entries of 'ux' must lie in the range [-1, 1] for monitor {name}.")
+        if maxabs_uy > 1:
+            raise SetupError(f"Entries of 'uy' must lie in the range [-1, 1] for monitor {name}.")
+        return values
 
-        num_provided = len(axes)
+    def storage_size(self, num_cells: int, tmesh: ArrayFloat1D) -> int:
+        """Size of monitor storage given the number of points after discretization."""
+        # stores 1 complex number per pair of grid points, per frequency,
+        # for Er, Etheta, Ephi, Hr, Htheta, and Hphi (6 components)
+        return BYTES_COMPLEX * len(self.ux) * len(self.uy) * len(self.freqs) * 6
 
-        if num_provided < 3 and any(not np.isscalar(comp) for comp in xyz if comp is not None):
-            raise DataError(
-                "Providing x, y, or z as array is only allowed for interpolation. That is, when all"
-                " three x, y, and z are provided or method '.interp()' is used explicitly."
-            )
 
-        if num_provided == 0:
-            raise DataError("At least one of 'x', 'y', and 'z' must be specified.")
+class DiffractionMonitor(PlanarMonitor, FreqMonitor):
+    """:class:`Monitor` that uses a 2D Fourier transform to compute the
+    diffraction amplitudes and efficiency for allowed diffraction orders.
 
-        if num_provided == 1:
-            axis = axes[0]
-            return self.plane_slice(axis=axis, pos=xyz[axis])
+    Example
+    -------
+    >>> monitor = DiffractionMonitor(
+    ...     center=(1,2,3),
+    ...     size=(inf,inf,0),
+    ...     freqs=[250e12, 300e12],
+    ...     name='diffraction_monitor',
+    ...     normal_dir='+',
+    ...     )
 
-        if num_provided == 2:
-            axis = 3 - axes[0] - axes[1]
-            xyz[axis] = 0
-            return self.line_slice(axis=axis, pos=xyz)
+    See Also
+    --------
 
-        if num_provided == 3:
-            return self.interp(x=x, y=y, z=z)
+    **Notebooks**
+        * `Multilevel blazed diffraction grating <../../notebooks/GratingEfficiency.html>`_
+    """
 
+    normal_dir: Direction = pydantic.Field(
+        "+",
+        title="Normal Vector Orientation",
+        description="Direction of the surface monitor's normal vector w.r.t. "
+        "the positive x, y or z unit vectors. Must be one of ``'+'`` or ``'-'``. "
+        "Defaults to ``'+'`` if not provided.",
+    )
+
+    colocate: Literal[False] = pydantic.Field(
+        False,
+        title="Colocate Fields",
+        description="Defines whether fields are colocated to grid cell boundaries (i.e. to the "
+        "primal grid) on-the-fly during a solver run. Can be toggled for field recording monitors "
+        "and is hard-coded for other monitors depending on their specific function.",
+    )
+
+    @pydantic.validator("size", always=True)
+    def diffraction_monitor_size(cls, val):
+        """Ensure that the monitor is infinite in the transverse direction."""
+        if val.count(inf) != 2:
+            raise SetupError(
+                "A 'DiffractionMonitor' must have a size of 'td.inf' along both "
+                f"transverse directions, given size={val}."
+            )
+        return val
 
-UnstructuredGridDatasetType = Union[TriangularGridDataset, TetrahedralGridDataset]
+    def storage_size(self, num_cells: int, tmesh: ArrayFloat1D) -> int:
+        """Size of monitor storage given the number of points after discretization."""
+        # assumes 1 diffraction order per frequency; actual size will be larger
+        return BYTES_COMPLEX * len(self.freqs)
+
+    def _storage_size_solver(self, num_cells: int, tmesh: ArrayFloat1D) -> int:
+        """Size of intermediate data recorded by the monitor during a solver run."""
+        return BYTES_COMPLEX * num_cells * len(self.freqs) * 6
+
+
+# types of monitors that are accepted by simulation
+MonitorType = Union[
+    FieldMonitor,
+    FieldTimeMonitor,
+    PermittivityMonitor,
+    FluxMonitor,
+    FluxTimeMonitor,
+    ModeMonitor,
+    ModeSolverMonitor,
+    FieldProjectionAngleMonitor,
+    FieldProjectionCartesianMonitor,
+    FieldProjectionKSpaceMonitor,
+    DiffractionMonitor,
+]
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `tidy3d-2.6.4/tidy3d/components/data/monitor_data.py` & `tidy3d-2.7.0rc1/tidy3d/components/data/monitor_data.py`

 * *Files 1% similar despite different names*

```diff
@@ -47,6519 +47,6519 @@
 000002e0: 7272 6179 2c20 5363 616c 6172 4669 656c  rray, ScalarFiel
 000002f0: 6454 696d 6544 6174 6141 7272 6179 0a66  dTimeDataArray.f
 00000300: 726f 6d20 2e64 6174 615f 6172 7261 7920  rom .data_array 
 00000310: 696d 706f 7274 2046 7265 7144 6174 6141  import FreqDataA
 00000320: 7272 6179 2c20 5469 6d65 4461 7461 4172  rray, TimeDataAr
 00000330: 7261 792c 2046 7265 714d 6f64 6544 6174  ray, FreqModeDat
 00000340: 6141 7272 6179 0a66 726f 6d20 2e64 6174  aArray.from .dat
-00000350: 6173 6574 2069 6d70 6f72 7420 4461 7461  aset import Data
-00000360: 7365 742c 2041 6273 7472 6163 7446 6965  set, AbstractFie
-00000370: 6c64 4461 7461 7365 742c 2045 6c65 6374  ldDataset, Elect
-00000380: 726f 6d61 676e 6574 6963 4669 656c 6444  romagneticFieldD
-00000390: 6174 6173 6574 0a66 726f 6d20 2e64 6174  ataset.from .dat
-000003a0: 6173 6574 2069 6d70 6f72 7420 4669 656c  aset import Fiel
-000003b0: 6444 6174 6173 6574 2c20 4669 656c 6454  dDataset, FieldT
-000003c0: 696d 6544 6174 6173 6574 2c20 4d6f 6465  imeDataset, Mode
-000003d0: 536f 6c76 6572 4461 7461 7365 742c 2050  SolverDataset, P
-000003e0: 6572 6d69 7474 6976 6974 7944 6174 6173  ermittivityDatas
-000003f0: 6574 0a66 726f 6d20 2e2e 6261 7365 2069  et.from ..base i
-00000400: 6d70 6f72 7420 5459 5045 5f54 4147 5f53  mport TYPE_TAG_S
-00000410: 5452 2c20 6361 6368 6564 5f70 726f 7065  TR, cached_prope
-00000420: 7274 792c 2073 6b69 705f 6966 5f66 6965  rty, skip_if_fie
-00000430: 6c64 735f 6d69 7373 696e 670a 6672 6f6d  lds_missing.from
-00000440: 202e 2e74 7970 6573 2069 6d70 6f72 7420   ..types import 
-00000450: 436f 6f72 6469 6e61 7465 2c20 5379 6d6d  Coordinate, Symm
-00000460: 6574 7279 2c20 4172 7261 7946 6c6f 6174  etry, ArrayFloat
-00000470: 3144 2c20 4172 7261 7946 6c6f 6174 3244  1D, ArrayFloat2D
-00000480: 2c20 5369 7a65 2c20 4e75 6d70 792c 2054  , Size, Numpy, T
-00000490: 7261 636b 4672 6571 0a66 726f 6d20 2e2e  rackFreq.from ..
-000004a0: 7479 7065 7320 696d 706f 7274 2045 7073  types import Eps
-000004b0: 5370 6563 5479 7065 2c20 4c69 7465 7261  SpecType, Litera
-000004c0: 6c0a 6672 6f6d 202e 2e67 7269 642e 6772  l.from ..grid.gr
-000004d0: 6964 2069 6d70 6f72 7420 4772 6964 2c20  id import Grid, 
-000004e0: 436f 6f72 6473 0a66 726f 6d20 2e2e 7661  Coords.from ..va
-000004f0: 6c69 6461 746f 7273 2069 6d70 6f72 7420  lidators import 
-00000500: 656e 666f 7263 655f 6d6f 6e69 746f 725f  enforce_monitor_
-00000510: 6669 656c 6473 5f70 7265 7365 6e74 2c20  fields_present, 
-00000520: 7265 7175 6972 6564 5f69 665f 7379 6d6d  required_if_symm
-00000530: 6574 7279 5f70 7265 7365 6e74 0a66 726f  etry_present.fro
-00000540: 6d20 2e2e 6d6f 6e69 746f 7220 696d 706f  m ..monitor impo
-00000550: 7274 204d 6f6e 6974 6f72 5479 7065 2c20  rt MonitorType, 
-00000560: 4669 656c 644d 6f6e 6974 6f72 2c20 4669  FieldMonitor, Fi
-00000570: 656c 6454 696d 654d 6f6e 6974 6f72 2c20  eldTimeMonitor, 
-00000580: 4d6f 6465 536f 6c76 6572 4d6f 6e69 746f  ModeSolverMonito
-00000590: 720a 6672 6f6d 202e 2e6d 6f6e 6974 6f72  r.from ..monitor
-000005a0: 2069 6d70 6f72 7420 4d6f 6465 4d6f 6e69   import ModeMoni
-000005b0: 746f 722c 2046 6c75 784d 6f6e 6974 6f72  tor, FluxMonitor
-000005c0: 2c20 466c 7578 5469 6d65 4d6f 6e69 746f  , FluxTimeMonito
-000005d0: 722c 2050 6572 6d69 7474 6976 6974 794d  r, PermittivityM
-000005e0: 6f6e 6974 6f72 0a66 726f 6d20 2e2e 6d6f  onitor.from ..mo
-000005f0: 6e69 746f 7220 696d 706f 7274 2046 6965  nitor import Fie
-00000600: 6c64 5072 6f6a 6563 7469 6f6e 416e 676c  ldProjectionAngl
-00000610: 654d 6f6e 6974 6f72 2c20 4669 656c 6450  eMonitor, FieldP
-00000620: 726f 6a65 6374 696f 6e43 6172 7465 7369  rojectionCartesi
-00000630: 616e 4d6f 6e69 746f 720a 6672 6f6d 202e  anMonitor.from .
-00000640: 2e6d 6f6e 6974 6f72 2069 6d70 6f72 7420  .monitor import 
-00000650: 4669 656c 6450 726f 6a65 6374 696f 6e4b  FieldProjectionK
-00000660: 5370 6163 654d 6f6e 6974 6f72 2c20 4669  SpaceMonitor, Fi
-00000670: 656c 6450 726f 6a65 6374 696f 6e53 7572  eldProjectionSur
-00000680: 6661 6365 0a66 726f 6d20 2e2e 6d6f 6e69  face.from ..moni
-00000690: 746f 7220 696d 706f 7274 2044 6966 6672  tor import Diffr
-000006a0: 6163 7469 6f6e 4d6f 6e69 746f 720a 6672  actionMonitor.fr
-000006b0: 6f6d 202e 2e73 6f75 7263 6520 696d 706f  om ..source impo
-000006c0: 7274 2053 6f75 7263 6554 696d 6554 7970  rt SourceTimeTyp
-000006d0: 652c 2043 7573 746f 6d46 6965 6c64 536f  e, CustomFieldSo
-000006e0: 7572 6365 0a66 726f 6d20 2e2e 6d65 6469  urce.from ..medi
-000006f0: 756d 2069 6d70 6f72 7420 4d65 6469 756d  um import Medium
-00000700: 2c20 4d65 6469 756d 5479 7065 0a66 726f  , MediumType.fro
-00000710: 6d20 2e2e 2e65 7863 6570 7469 6f6e 7320  m ...exceptions 
-00000720: 696d 706f 7274 2053 6574 7570 4572 726f  import SetupErro
-00000730: 722c 2044 6174 6145 7272 6f72 2c20 5469  r, DataError, Ti
-00000740: 6479 3364 4e6f 7449 6d70 6c65 6d65 6e74  dy3dNotImplement
-00000750: 6564 4572 726f 722c 2056 616c 6964 6174  edError, Validat
-00000760: 696f 6e45 7272 6f72 0a66 726f 6d20 2e2e  ionError.from ..
-00000770: 2e63 6f6e 7374 616e 7473 2069 6d70 6f72  .constants impor
-00000780: 7420 4554 415f 302c 2043 5f30 2c20 4d49  t ETA_0, C_0, MI
-00000790: 4352 4f4d 4554 4552 0a66 726f 6d20 2e2e  CROMETER.from ..
-000007a0: 2e6c 6f67 2069 6d70 6f72 7420 6c6f 670a  .log import log.
-000007b0: 0a66 726f 6d20 2e2e 6261 7365 5f73 696d  .from ..base_sim
-000007c0: 2e64 6174 612e 6d6f 6e69 746f 725f 6461  .data.monitor_da
-000007d0: 7461 2069 6d70 6f72 7420 4162 7374 7261  ta import Abstra
-000007e0: 6374 4d6f 6e69 746f 7244 6174 610a 0a43  ctMonitorData..C
-000007f0: 6f6f 7264 7331 4420 3d20 4172 7261 7946  oords1D = ArrayF
-00000800: 6c6f 6174 3144 0a0a 0a63 6c61 7373 204d  loat1D...class M
-00000810: 6f6e 6974 6f72 4461 7461 2841 6273 7472  onitorData(Abstr
-00000820: 6163 744d 6f6e 6974 6f72 4461 7461 2c20  actMonitorData, 
-00000830: 4142 4329 3a0a 2020 2020 2222 220a 2020  ABC):.    """.  
-00000840: 2020 4162 7374 7261 6374 2062 6173 6520    Abstract base 
-00000850: 636c 6173 7320 6f66 206f 626a 6563 7473  class of objects
-00000860: 2074 6861 7420 7374 6f72 6520 6461 7461   that store data
-00000870: 2070 6572 7461 696e 696e 6720 746f 2061   pertaining to a
-00000880: 2073 696e 676c 6520 3a63 6c61 7373 3a60   single :class:`
-00000890: 2e6d 6f6e 6974 6f72 602e 0a20 2020 2022  .monitor`..    "
-000008a0: 2222 0a0a 2020 2020 6d6f 6e69 746f 723a  ""..    monitor:
-000008b0: 204d 6f6e 6974 6f72 5479 7065 203d 2070   MonitorType = p
-000008c0: 642e 4669 656c 6428 0a20 2020 2020 2020  d.Field(.       
-000008d0: 202e 2e2e 2c0a 2020 2020 2020 2020 7469   ...,.        ti
-000008e0: 746c 653d 224d 6f6e 6974 6f72 222c 0a20  tle="Monitor",. 
-000008f0: 2020 2020 2020 2064 6573 6372 6970 7469         descripti
-00000900: 6f6e 3d22 4d6f 6e69 746f 7220 6173 736f  on="Monitor asso
-00000910: 6369 6174 6564 2077 6974 6820 7468 6520  ciated with the 
-00000920: 6461 7461 2e22 2c0a 2020 2020 2020 2020  data.",.        
-00000930: 6469 7363 7269 6d69 6e61 746f 723d 5459  discriminator=TY
-00000940: 5045 5f54 4147 5f53 5452 2c0a 2020 2020  PE_TAG_STR,.    
-00000950: 290a 0a20 2020 2040 7072 6f70 6572 7479  )..    @property
-00000960: 0a20 2020 2064 6566 2073 796d 6d65 7472  .    def symmetr
-00000970: 795f 6578 7061 6e64 6564 2873 656c 6629  y_expanded(self)
-00000980: 202d 3e20 4d6f 6e69 746f 7244 6174 613a   -> MonitorData:
-00000990: 0a20 2020 2020 2020 2022 2222 5265 7475  .        """Retu
-000009a0: 726e 2073 656c 6620 7769 7468 2073 796d  rn self with sym
-000009b0: 6d65 7472 7920 6170 706c 6965 642e 2222  metry applied.""
-000009c0: 220a 2020 2020 2020 2020 7265 7475 726e  ".        return
-000009d0: 2073 656c 660a 0a20 2020 2064 6566 206e   self..    def n
-000009e0: 6f72 6d61 6c69 7a65 2873 656c 662c 2073  ormalize(self, s
-000009f0: 6f75 7263 655f 7370 6563 7472 756d 5f66  ource_spectrum_f
-00000a00: 6e3a 2043 616c 6c61 626c 655b 5b66 6c6f  n: Callable[[flo
-00000a10: 6174 5d2c 2063 6f6d 706c 6578 5d29 202d  at], complex]) -
-00000a20: 3e20 4461 7461 7365 743a 0a20 2020 2020  > Dataset:.     
-00000a30: 2020 2022 2222 5265 7475 726e 2063 6f70     """Return cop
-00000a40: 7920 6f66 2073 656c 6620 6166 7465 7220  y of self after 
-00000a50: 6e6f 726d 616c 697a 6174 696f 6e20 6973  normalization is
-00000a60: 2061 7070 6c69 6564 2075 7369 6e67 2073   applied using s
-00000a70: 6f75 7263 6520 7370 6563 7472 756d 2066  ource spectrum f
-00000a80: 756e 6374 696f 6e2e 2222 220a 2020 2020  unction.""".    
-00000a90: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-00000aa0: 636f 7079 2829 0a0a 2020 2020 6465 6620  copy()..    def 
-00000ab0: 5f75 7064 6174 6564 2873 656c 662c 2075  _updated(self, u
-00000ac0: 7064 6174 653a 2044 6963 7429 202d 3e20  pdate: Dict) -> 
-00000ad0: 4d6f 6e69 746f 7244 6174 613a 0a20 2020  MonitorData:.   
-00000ae0: 2020 2020 2022 2222 5369 6d69 6c61 7220       """Similar 
-00000af0: 746f 2060 6075 7064 6174 6564 5f63 6f70  to ``updated_cop
-00000b00: 7960 602c 2062 7574 2064 6f65 7320 6e6f  y``, but does no
-00000b10: 7420 6163 7475 616c 6c79 2063 6f70 7920  t actually copy 
-00000b20: 636f 6d70 6f6e 656e 7473 2c20 666f 7220  components, for 
-00000b30: 7370 6565 642e 0a0a 2020 2020 2020 2020  speed...        
-00000b40: 4e6f 7465 0a20 2020 2020 2020 202d 2d2d  Note.        ---
-00000b50: 2d0a 2020 2020 2020 2020 2020 2020 5468  -.            Th
-00000b60: 6973 2064 6f65 7320 2a2a 6e6f 742a 2a20  is does **not** 
-00000b70: 7072 6f64 7563 6520 6120 636f 7079 206f  produce a copy o
-00000b80: 6620 6d75 7461 626c 6520 6f62 6a65 6374  f mutable object
-00000b90: 732c 2073 6f20 652e 672e 2069 6620 736f  s, so e.g. if so
-00000ba0: 6d65 206f 6620 7468 6520 6461 7461 2061  me of the data a
-00000bb0: 7272 6179 730a 2020 2020 2020 2020 2020  rrays.          
-00000bc0: 2020 6172 6520 6e6f 7420 7570 6461 7465    are not update
-00000bd0: 642c 2074 6865 7920 7769 6c6c 2070 6f69  d, they will poi
-00000be0: 6e74 2074 6f20 7468 6520 7661 6c75 6573  nt to the values
-00000bf0: 2069 6e20 7468 6520 6f72 6967 696e 616c   in the original
-00000c00: 2064 6174 612e 2054 6869 7320 6d65 7468   data. This meth
-00000c10: 6f64 2073 686f 756c 640a 2020 2020 2020  od should.      
-00000c20: 2020 2020 2020 7468 7573 2062 6520 7573        thus be us
-00000c30: 6564 2063 6172 6566 756c 6c79 2e0a 0a20  ed carefully... 
-00000c40: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00000c50: 2020 2064 6174 615f 6469 6374 203d 2073     data_dict = s
-00000c60: 656c 662e 6469 6374 2829 0a20 2020 2020  elf.dict().     
-00000c70: 2020 2064 6174 615f 6469 6374 2e75 7064     data_dict.upd
-00000c80: 6174 6528 7570 6461 7465 290a 2020 2020  ate(update).    
-00000c90: 2020 2020 7265 7475 726e 2074 7970 6528      return type(
-00000ca0: 7365 6c66 292e 7061 7273 655f 6f62 6a28  self).parse_obj(
-00000cb0: 6461 7461 5f64 6963 7429 0a0a 0a63 6c61  data_dict)...cla
-00000cc0: 7373 2041 6273 7472 6163 7446 6965 6c64  ss AbstractField
-00000cd0: 4461 7461 284d 6f6e 6974 6f72 4461 7461  Data(MonitorData
-00000ce0: 2c20 4162 7374 7261 6374 4669 656c 6444  , AbstractFieldD
-00000cf0: 6174 6173 6574 2c20 4142 4329 3a0a 2020  ataset, ABC):.  
-00000d00: 2020 2222 2243 6f6c 6c65 6374 696f 6e20    """Collection 
-00000d10: 6f66 2073 6361 6c61 7220 6669 656c 6473  of scalar fields
-00000d20: 2077 6974 6820 736f 6d65 2073 796d 6d65   with some symme
-00000d30: 7472 7920 7072 6f70 6572 7469 6573 2e22  try properties."
-00000d40: 2222 0a0a 2020 2020 6d6f 6e69 746f 723a  ""..    monitor:
-00000d50: 2055 6e69 6f6e 5b46 6965 6c64 4d6f 6e69   Union[FieldMoni
-00000d60: 746f 722c 2046 6965 6c64 5469 6d65 4d6f  tor, FieldTimeMo
-00000d70: 6e69 746f 722c 2050 6572 6d69 7474 6976  nitor, Permittiv
-00000d80: 6974 794d 6f6e 6974 6f72 2c20 4d6f 6465  ityMonitor, Mode
-00000d90: 4d6f 6e69 746f 725d 0a0a 2020 2020 7379  Monitor]..    sy
-00000da0: 6d6d 6574 7279 3a20 5475 706c 655b 5379  mmetry: Tuple[Sy
-00000db0: 6d6d 6574 7279 2c20 5379 6d6d 6574 7279  mmetry, Symmetry
-00000dc0: 2c20 5379 6d6d 6574 7279 5d20 3d20 7064  , Symmetry] = pd
-00000dd0: 2e46 6965 6c64 280a 2020 2020 2020 2020  .Field(.        
-00000de0: 2830 2c20 302c 2030 292c 0a20 2020 2020  (0, 0, 0),.     
-00000df0: 2020 2074 6974 6c65 3d22 5379 6d6d 6574     title="Symmet
-00000e00: 7279 222c 0a20 2020 2020 2020 2064 6573  ry",.        des
-00000e10: 6372 6970 7469 6f6e 3d22 5379 6d6d 6574  cription="Symmet
-00000e20: 7279 2065 6967 656e 7661 6c75 6573 206f  ry eigenvalues o
-00000e30: 6620 7468 6520 6f72 6967 696e 616c 2073  f the original s
-00000e40: 696d 756c 6174 696f 6e20 696e 2078 2c20  imulation in x, 
-00000e50: 792c 2061 6e64 207a 2e22 2c0a 2020 2020  y, and z.",.    
-00000e60: 290a 0a20 2020 2073 796d 6d65 7472 795f  )..    symmetry_
-00000e70: 6365 6e74 6572 3a20 436f 6f72 6469 6e61  center: Coordina
-00000e80: 7465 203d 2070 642e 4669 656c 6428 0a20  te = pd.Field(. 
-00000e90: 2020 2020 2020 204e 6f6e 652c 0a20 2020         None,.   
-00000ea0: 2020 2020 2074 6974 6c65 3d22 5379 6d6d       title="Symm
-00000eb0: 6574 7279 2043 656e 7465 7222 2c0a 2020  etry Center",.  
-00000ec0: 2020 2020 2020 6465 7363 7269 7074 696f        descriptio
-00000ed0: 6e3d 2243 656e 7465 7220 6f66 2074 6865  n="Center of the
-00000ee0: 2073 796d 6d65 7472 7920 706c 616e 6573   symmetry planes
-00000ef0: 206f 6620 7468 6520 6f72 6967 696e 616c   of the original
-00000f00: 2073 696d 756c 6174 696f 6e20 696e 2078   simulation in x
-00000f10: 2c20 792c 2061 6e64 207a 2e20 220a 2020  , y, and z. ".  
-00000f20: 2020 2020 2020 2252 6571 7569 7265 6420        "Required 
-00000f30: 6f6e 6c79 2069 6620 616e 7920 6f66 2074  only if any of t
-00000f40: 6865 2060 6073 796d 6d65 7472 7960 6020  he ``symmetry`` 
-00000f50: 6669 656c 6420 6172 6520 6e6f 6e2d 7a65  field are non-ze
-00000f60: 726f 2e22 2c0a 2020 2020 290a 2020 2020  ro.",.    ).    
-00000f70: 6772 6964 5f65 7870 616e 6465 643a 2047  grid_expanded: G
-00000f80: 7269 6420 3d20 7064 2e46 6965 6c64 280a  rid = pd.Field(.
-00000f90: 2020 2020 2020 2020 4e6f 6e65 2c0a 2020          None,.  
-00000fa0: 2020 2020 2020 7469 746c 653d 2245 7870        title="Exp
-00000fb0: 616e 6465 6420 4772 6964 222c 0a20 2020  anded Grid",.   
-00000fc0: 2020 2020 2064 6573 6372 6970 7469 6f6e       description
-00000fd0: 3d22 3a63 6c61 7373 3a60 2e47 7269 6460  =":class:`.Grid`
-00000fe0: 2064 6973 6372 6574 697a 6174 696f 6e20   discretization 
-00000ff0: 6f66 2074 6865 2061 7373 6f63 6961 7465  of the associate
-00001000: 6420 6d6f 6e69 746f 7220 696e 2074 6865  d monitor in the
-00001010: 2073 696d 756c 6174 696f 6e20 220a 2020   simulation ".  
-00001020: 2020 2020 2020 2277 6869 6368 2063 7265        "which cre
-00001030: 6174 6564 2074 6865 2064 6174 612e 2052  ated the data. R
-00001040: 6571 7569 7265 6420 6966 2073 796d 6d65  equired if symme
-00001050: 7472 6965 7320 6172 6520 7072 6573 656e  tries are presen
-00001060: 742c 2061 7320 220a 2020 2020 2020 2020  t, as ".        
-00001070: 2277 656c 6c20 6173 2069 6e20 6f72 6465  "well as in orde
-00001080: 7220 746f 2075 7365 2073 6f6d 6520 6675  r to use some fu
-00001090: 6e63 7469 6f6e 616c 6974 6965 7320 6c69  nctionalities li
-000010a0: 6b65 2067 6574 7469 6e67 2050 6f79 6e74  ke getting Poynt
-000010b0: 696e 6720 7665 6374 6f72 2061 6e64 2066  ing vector and f
-000010c0: 6c75 782e 222c 0a20 2020 2029 0a0a 2020  lux.",.    )..  
-000010d0: 2020 4070 642e 7661 6c69 6461 746f 7228    @pd.validator(
-000010e0: 2267 7269 645f 6578 7061 6e64 6564 222c  "grid_expanded",
-000010f0: 2061 6c77 6179 733d 5472 7565 290a 2020   always=True).  
-00001100: 2020 6465 6620 7761 726e 5f6d 6973 7369    def warn_missi
-00001110: 6e67 5f67 7269 645f 6578 7061 6e64 6564  ng_grid_expanded
-00001120: 2863 6c73 2c20 7661 6c2c 2076 616c 7565  (cls, val, value
-00001130: 7329 3a0a 2020 2020 2020 2020 2222 2249  s):.        """I
-00001140: 6620 6060 6772 6964 5f65 7870 616e 6465  f ``grid_expande
-00001150: 6460 6020 6e6f 7420 7072 6f76 6964 6564  d`` not provided
-00001160: 2061 6e64 2066 6965 6c64 7320 6461 7461   and fields data
-00001170: 2069 7320 7072 6573 656e 742c 2077 6172   is present, war
-00001180: 6e20 7468 6174 2073 6f6d 6520 6d65 7468  n that some meth
-00001190: 6f64 730a 2020 2020 2020 2020 7769 6c6c  ods.        will
-000011a0: 2062 7265 616b 2e22 2222 0a20 2020 2020   break.""".     
-000011b0: 2020 2066 6965 6c64 5f63 6f6d 7073 203d     field_comps =
-000011c0: 205b 2245 7822 2c20 2245 7922 2c20 2245   ["Ex", "Ey", "E
-000011d0: 7a22 2c20 2248 7822 2c20 2248 7922 2c20  z", "Hx", "Hy", 
-000011e0: 2248 7a22 5d0a 2020 2020 2020 2020 6966  "Hz"].        if
-000011f0: 2076 616c 2069 7320 4e6f 6e65 2061 6e64   val is None and
-00001200: 2061 6e79 2876 616c 7565 735b 636f 6d70   any(values[comp
-00001210: 5d20 6973 206e 6f74 204e 6f6e 6520 666f  ] is not None fo
-00001220: 7220 636f 6d70 2069 6e20 6669 656c 645f  r comp in field_
-00001230: 636f 6d70 7329 3a0a 2020 2020 2020 2020  comps):.        
-00001240: 2020 2020 6c6f 672e 7761 726e 696e 6728      log.warning(
-00001250: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00001260: 2022 4d6f 6e69 746f 7220 6461 7461 2072   "Monitor data r
-00001270: 6571 7569 7265 7320 2767 7269 645f 6578  equires 'grid_ex
-00001280: 7061 6e64 6564 2720 746f 2062 6520 6465  panded' to be de
-00001290: 6669 6e65 6420 746f 2063 6f6d 7075 7465  fined to compute
-000012a0: 2076 616c 7565 7320 6c69 6b65 2022 0a20   values like ". 
-000012b0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-000012c0: 666c 7578 2c20 506f 796e 7469 6e67 2061  flux, Poynting a
-000012d0: 6e64 2064 6f74 2070 726f 6475 6374 2077  nd dot product w
-000012e0: 6974 6820 6f74 6865 7220 6461 7461 2e22  ith other data."
-000012f0: 0a20 2020 2020 2020 2020 2020 2029 0a20  .            ). 
-00001300: 2020 2020 2020 2072 6574 7572 6e20 7661         return va
-00001310: 6c0a 0a20 2020 205f 7265 7175 6972 655f  l..    _require_
-00001320: 7379 6d5f 6365 6e74 6572 203d 2072 6571  sym_center = req
-00001330: 7569 7265 645f 6966 5f73 796d 6d65 7472  uired_if_symmetr
-00001340: 795f 7072 6573 656e 7428 2273 796d 6d65  y_present("symme
-00001350: 7472 795f 6365 6e74 6572 2229 0a20 2020  try_center").   
-00001360: 205f 7265 7175 6972 655f 6772 6964 5f65   _require_grid_e
-00001370: 7870 616e 6465 6420 3d20 7265 7175 6972  xpanded = requir
-00001380: 6564 5f69 665f 7379 6d6d 6574 7279 5f70  ed_if_symmetry_p
-00001390: 7265 7365 6e74 2822 6772 6964 5f65 7870  resent("grid_exp
-000013a0: 616e 6465 6422 290a 0a20 2020 2064 6566  anded")..    def
-000013b0: 205f 6578 7061 6e64 6564 5f67 7269 645f   _expanded_grid_
-000013c0: 6669 656c 645f 636f 6f72 6473 2873 656c  field_coords(sel
-000013d0: 662c 2066 6965 6c64 5f6e 616d 653a 2073  f, field_name: s
-000013e0: 7472 2920 2d3e 2043 6f6f 7264 733a 0a20  tr) -> Coords:. 
-000013f0: 2020 2020 2020 2022 2222 436f 6f72 6469         """Coordi
-00001400: 6e61 7465 7320 696e 2074 6865 2065 7870  nates in the exp
-00001410: 616e 6465 6420 6772 6964 2063 6f72 7265  anded grid corre
-00001420: 7370 6f6e 6469 6e67 2074 6f20 6120 6769  sponding to a gi
-00001430: 7665 6e20 6669 656c 6420 636f 6d70 6f6e  ven field compon
-00001440: 656e 742e 2222 220a 2020 2020 2020 2020  ent.""".        
-00001450: 7265 7475 726e 2073 656c 662e 6772 6964  return self.grid
-00001460: 5f65 7870 616e 6465 645b 7365 6c66 2e67  _expanded[self.g
-00001470: 7269 645f 6c6f 6361 7469 6f6e 735b 6669  rid_locations[fi
-00001480: 656c 645f 6e61 6d65 5d5d 0a0a 2020 2020  eld_name]]..    
-00001490: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
-000014a0: 6620 7379 6d6d 6574 7279 5f65 7870 616e  f symmetry_expan
-000014b0: 6465 6428 7365 6c66 293a 0a20 2020 2020  ded(self):.     
-000014c0: 2020 2022 2222 5265 7475 726e 2074 6865     """Return the
-000014d0: 203a 636c 6173 733a 602e 4162 7374 7261   :class:`.Abstra
-000014e0: 6374 4669 656c 6444 6174 6160 2077 6974  ctFieldData` wit
-000014f0: 6820 6669 656c 6473 2065 7870 616e 6465  h fields expande
-00001500: 6420 6261 7365 6420 6f6e 2073 796d 6d65  d based on symme
-00001510: 7472 792e 2049 660a 2020 2020 2020 2020  try. If.        
-00001520: 616e 7920 7379 6d6d 6574 7279 2069 7320  any symmetry is 
-00001530: 6e6f 6e7a 6572 6f20 2869 2e65 2e20 6578  nonzero (i.e. ex
-00001540: 7061 6e64 6564 292c 2074 6865 2069 6e74  panded), the int
-00001550: 6572 706f 6c61 7469 6f6e 2069 6d70 6c69  erpolation impli
-00001560: 6369 746c 7920 6372 6561 7465 7320 6120  citly creates a 
-00001570: 636f 7079 206f 6620 7468 650a 2020 2020  copy of the.    
-00001580: 2020 2020 6461 7461 2061 7272 6179 2e20      data array. 
-00001590: 486f 7765 7665 722c 2069 6620 7379 6d6d  However, if symm
-000015a0: 6574 7279 2069 7320 6e6f 7420 6578 7061  etry is not expa
-000015b0: 6e64 6564 2c20 7468 6520 7265 7475 726e  nded, the return
-000015c0: 6564 2061 7272 6179 2063 6f6e 7461 696e  ed array contain
-000015d0: 7320 6120 7669 6577 206f 660a 2020 2020  s a view of.    
-000015e0: 2020 2020 7468 6520 6461 7461 2c20 6e6f      the data, no
-000015f0: 7420 6120 636f 7079 2e0a 0a20 2020 2020  t a copy...     
-00001600: 2020 2052 6574 7572 6e73 0a20 2020 2020     Returns.     
-00001610: 2020 202d 2d2d 2d2d 2d2d 0a20 2020 2020     -------.     
-00001620: 2020 203a 636c 6173 733a 6041 6273 7472     :class:`Abstr
-00001630: 6163 7446 6965 6c64 4461 7461 600a 2020  actFieldData`.  
-00001640: 2020 2020 2020 2020 2020 4120 6461 7461            A data
-00001650: 206f 626a 6563 7420 7769 7468 2074 6865   object with the
-00001660: 2073 796d 6d65 7472 7920 6578 7061 6e64   symmetry expand
-00001670: 6564 2066 6965 6c64 732e 0a20 2020 2020  ed fields..     
-00001680: 2020 2022 2222 0a0a 2020 2020 2020 2020     """..        
-00001690: 6966 2061 6c6c 2873 796d 203d 3d20 3020  if all(sym == 0 
-000016a0: 666f 7220 7379 6d20 696e 2073 656c 662e  for sym in self.
-000016b0: 7379 6d6d 6574 7279 293a 0a20 2020 2020  symmetry):.     
-000016c0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-000016d0: 6c66 0a0a 2020 2020 2020 2020 7265 7475  lf..        retu
-000016e0: 726e 2073 656c 662e 5f75 7064 6174 6564  rn self._updated
-000016f0: 2873 656c 662e 5f73 796d 6d65 7472 795f  (self._symmetry_
-00001700: 7570 6461 7465 5f64 6963 7429 0a0a 2020  update_dict)..  
-00001710: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
-00001720: 6465 6620 7379 6d6d 6574 7279 5f65 7870  def symmetry_exp
-00001730: 616e 6465 645f 636f 7079 2873 656c 6629  anded_copy(self)
-00001740: 202d 3e20 4162 7374 7261 6374 4669 656c   -> AbstractFiel
-00001750: 6444 6174 613a 0a20 2020 2020 2020 2022  dData:.        "
-00001760: 2222 4372 6561 7465 2061 2063 6f70 7920  ""Create a copy 
-00001770: 6f66 2074 6865 203a 636c 6173 733a 602e  of the :class:`.
-00001780: 4162 7374 7261 6374 4669 656c 6444 6174  AbstractFieldDat
-00001790: 6160 2077 6974 6820 6669 656c 6473 2065  a` with fields e
-000017a0: 7870 616e 6465 6420 6261 7365 6420 6f6e  xpanded based on
-000017b0: 2073 796d 6d65 7472 792e 0a0a 2020 2020   symmetry...    
-000017c0: 2020 2020 5265 7475 726e 730a 2020 2020      Returns.    
-000017d0: 2020 2020 2d2d 2d2d 2d2d 2d0a 2020 2020      -------.    
-000017e0: 2020 2020 3a63 6c61 7373 3a60 4162 7374      :class:`Abst
-000017f0: 7261 6374 4669 656c 6444 6174 6160 0a20  ractFieldData`. 
-00001800: 2020 2020 2020 2020 2020 2041 2064 6174             A dat
-00001810: 6120 6f62 6a65 6374 2077 6974 6820 7468  a object with th
-00001820: 6520 7379 6d6d 6574 7279 2065 7870 616e  e symmetry expan
-00001830: 6465 6420 6669 656c 6473 2e0a 2020 2020  ded fields..    
-00001840: 2020 2020 2222 220a 0a20 2020 2020 2020      """..       
-00001850: 2069 6620 616c 6c28 7379 6d20 3d3d 2030   if all(sym == 0
-00001860: 2066 6f72 2073 796d 2069 6e20 7365 6c66   for sym in self
-00001870: 2e73 796d 6d65 7472 7929 3a0a 2020 2020  .symmetry):.    
-00001880: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-00001890: 656c 662e 636f 7079 2829 0a0a 2020 2020  elf.copy()..    
-000018a0: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-000018b0: 636f 7079 2875 7064 6174 653d 7365 6c66  copy(update=self
-000018c0: 2e5f 7379 6d6d 6574 7279 5f75 7064 6174  ._symmetry_updat
-000018d0: 655f 6469 6374 290a 0a20 2020 2040 7072  e_dict)..    @pr
-000018e0: 6f70 6572 7479 0a20 2020 2064 6566 205f  operty.    def _
-000018f0: 7379 6d6d 6574 7279 5f75 7064 6174 655f  symmetry_update_
-00001900: 6469 6374 2873 656c 6629 202d 3e20 4469  dict(self) -> Di
-00001910: 6374 3a0a 2020 2020 2020 2020 2222 2244  ct:.        """D
-00001920: 6963 7469 6f6e 6172 7920 6f66 2064 6174  ictionary of dat
-00001930: 6120 6669 656c 6473 2074 6f20 6372 6561  a fields to crea
-00001940: 7465 2064 6174 6120 7769 7468 2065 7870  te data with exp
-00001950: 616e 6465 6420 7379 6d6d 6574 7279 2e22  anded symmetry."
-00001960: 2222 0a0a 2020 2020 2020 2020 7570 6461  ""..        upda
-00001970: 7465 5f64 6963 7420 3d20 7b7d 0a20 2020  te_dict = {}.   
-00001980: 2020 2020 2066 6f72 2066 6965 6c64 5f6e       for field_n
-00001990: 616d 652c 2073 6361 6c61 725f 6461 7461  ame, scalar_data
-000019a0: 2069 6e20 7365 6c66 2e66 6965 6c64 5f63   in self.field_c
-000019b0: 6f6d 706f 6e65 6e74 732e 6974 656d 7328  omponents.items(
-000019c0: 293a 0a20 2020 2020 2020 2020 2020 2065  ):.            e
-000019d0: 6967 656e 7661 6c5f 666e 203d 2073 656c  igenval_fn = sel
-000019e0: 662e 7379 6d6d 6574 7279 5f65 6967 656e  f.symmetry_eigen
-000019f0: 7661 6c75 6573 5b66 6965 6c64 5f6e 616d  values[field_nam
-00001a00: 655d 0a0a 2020 2020 2020 2020 2020 2020  e]..            
-00001a10: 2320 6765 7420 6772 6964 206c 6f63 6174  # get grid locat
-00001a20: 696f 6e73 2066 6f72 2074 6869 7320 6669  ions for this fi
-00001a30: 656c 6420 636f 6d70 6f6e 656e 7420 6f6e  eld component on
-00001a40: 2074 6865 2065 7870 616e 6465 6420 6772   the expanded gr
-00001a50: 6964 0a20 2020 2020 2020 2020 2020 2066  id.            f
-00001a60: 6965 6c64 5f63 6f6f 7264 7320 3d20 7365  ield_coords = se
-00001a70: 6c66 2e5f 6578 7061 6e64 6564 5f67 7269  lf._expanded_gri
-00001a80: 645f 6669 656c 645f 636f 6f72 6473 2866  d_field_coords(f
-00001a90: 6965 6c64 5f6e 616d 6529 0a0a 2020 2020  ield_name)..    
-00001aa0: 2020 2020 2020 2020 666f 7220 7379 6d5f          for sym_
-00001ab0: 6469 6d2c 2028 7379 6d5f 7661 6c2c 2073  dim, (sym_val, s
-00001ac0: 796d 5f6c 6f63 2920 696e 2065 6e75 6d65  ym_loc) in enume
-00001ad0: 7261 7465 287a 6970 2873 656c 662e 7379  rate(zip(self.sy
-00001ae0: 6d6d 6574 7279 2c20 7365 6c66 2e73 796d  mmetry, self.sym
-00001af0: 6d65 7472 795f 6365 6e74 6572 2929 3a0a  metry_center)):.
-00001b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001b10: 6469 6d5f 6e61 6d65 203d 2022 7879 7a22  dim_name = "xyz"
-00001b20: 5b73 796d 5f64 696d 5d0a 0a20 2020 2020  [sym_dim]..     
-00001b30: 2020 2020 2020 2020 2020 2023 2043 6f6e             # Con
-00001b40: 7469 6e75 6520 6966 206e 6f20 7379 6d6d  tinue if no symm
-00001b50: 6574 7279 2061 6c6f 6e67 2074 6869 7320  etry along this 
-00001b60: 6469 6d65 6e73 696f 6e0a 2020 2020 2020  dimension.      
-00001b70: 2020 2020 2020 2020 2020 6966 2073 796d            if sym
-00001b80: 5f76 616c 203d 3d20 303a 0a20 2020 2020  _val == 0:.     
-00001b90: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-00001ba0: 6f6e 7469 6e75 650a 0a20 2020 2020 2020  ontinue..       
-00001bb0: 2020 2020 2020 2020 2023 2047 6574 2063           # Get c
-00001bc0: 6f6f 7264 696e 6174 6573 2066 6f72 2074  oordinates for t
-00001bd0: 6869 7320 6669 656c 6420 636f 6d70 6f6e  his field compon
-00001be0: 656e 7420 6f6e 2074 6865 2065 7870 616e  ent on the expan
-00001bf0: 6465 6420 6772 6964 0a20 2020 2020 2020  ded grid.       
-00001c00: 2020 2020 2020 2020 2063 6f6f 7264 7320           coords 
-00001c10: 3d20 6669 656c 645f 636f 6f72 6473 2e74  = field_coords.t
-00001c20: 6f5f 6c69 7374 5b73 796d 5f64 696d 5d0a  o_list[sym_dim].
-00001c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001c40: 636f 6f72 6473 203d 2073 656c 662e 6d6f  coords = self.mo
-00001c50: 6e69 746f 722e 646f 776e 7361 6d70 6c65  nitor.downsample
-00001c60: 2863 6f6f 7264 732c 2061 7869 733d 7379  (coords, axis=sy
-00001c70: 6d5f 6469 6d29 0a0a 2020 2020 2020 2020  m_dim)..        
-00001c80: 2020 2020 2020 2020 2320 4765 7420 696e          # Get in
-00001c90: 6465 7865 7320 6f66 2063 6f6f 7264 7320  dexes of coords 
-00001ca0: 7468 6174 206c 6965 206f 6e20 7468 6520  that lie on the 
-00001cb0: 6c65 6674 206f 6620 7468 6520 7379 6d6d  left of the symm
-00001cc0: 6574 7279 2063 656e 7465 720a 2020 2020  etry center.    
-00001cd0: 2020 2020 2020 2020 2020 2020 666c 6970              flip
-00001ce0: 5f69 6e64 7320 3d20 6e70 2e77 6865 7265  _inds = np.where
-00001cf0: 2863 6f6f 7264 7320 3c20 7379 6d5f 6c6f  (coords < sym_lo
-00001d00: 6329 5b30 5d0a 0a20 2020 2020 2020 2020  c)[0]..         
-00001d10: 2020 2020 2020 2023 2047 6574 2074 6865         # Get the
-00001d20: 2073 796d 6d65 7472 6963 2063 6f6f 7264   symmetric coord
-00001d30: 696e 6174 6573 206f 6e20 7468 6520 7269  inates on the ri
-00001d40: 6768 740a 2020 2020 2020 2020 2020 2020  ght.            
-00001d50: 2020 2020 636f 6f72 6473 5f69 6e74 6572      coords_inter
-00001d60: 7020 3d20 6e70 2e63 6f70 7928 636f 6f72  p = np.copy(coor
-00001d70: 6473 290a 2020 2020 2020 2020 2020 2020  ds).            
-00001d80: 2020 2020 636f 6f72 6473 5f69 6e74 6572      coords_inter
-00001d90: 705b 666c 6970 5f69 6e64 735d 203d 2032  p[flip_inds] = 2
-00001da0: 202a 2073 796d 5f6c 6f63 202d 2063 6f6f   * sym_loc - coo
-00001db0: 7264 735b 666c 6970 5f69 6e64 735d 0a0a  rds[flip_inds]..
-00001dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001dd0: 2320 496e 7465 7270 6f6c 6174 652e 2054  # Interpolate. T
-00001de0: 6865 7265 2067 656e 6572 616c 6c79 2073  here generally s
-00001df0: 686f 756c 646e 2774 2062 6520 7661 6c75  houldn't be valu
-00001e00: 6573 206f 7574 206f 6620 626f 756e 6473  es out of bounds
-00001e10: 2065 7863 6570 7420 706f 7465 6e74 6961   except potentia
-00001e20: 6c6c 790a 2020 2020 2020 2020 2020 2020  lly.            
-00001e30: 2020 2020 2320 7768 656e 2068 616e 646c      # when handl
-00001e40: 696e 6720 6d6f 6465 732c 2069 6e20 7768  ing modes, in wh
-00001e50: 6963 6820 6361 7365 2074 6865 7920 7368  ich case they sh
-00001e60: 6f75 6c64 2062 6520 6174 2074 6865 2062  ould be at the b
-00001e70: 6f75 6e64 6172 7920 616e 6420 636c 6f73  oundary and clos
-00001e80: 6520 746f 2030 2e0a 0a20 2020 2020 2020  e to 0...       
-00001e90: 2020 2020 2020 2020 2073 6361 6c61 725f           scalar_
-00001ea0: 6461 7461 203d 2073 6361 6c61 725f 6461  data = scalar_da
-00001eb0: 7461 2e73 656c 282a 2a7b 6469 6d5f 6e61  ta.sel(**{dim_na
-00001ec0: 6d65 3a20 636f 6f72 6473 5f69 6e74 6572  me: coords_inter
-00001ed0: 707d 2c20 6d65 7468 6f64 3d22 6e65 6172  p}, method="near
-00001ee0: 6573 7422 290a 2020 2020 2020 2020 2020  est").          
-00001ef0: 2020 2020 2020 7363 616c 6172 5f64 6174        scalar_dat
-00001f00: 6120 3d20 7363 616c 6172 5f64 6174 612e  a = scalar_data.
-00001f10: 6173 7369 676e 5f63 6f6f 7264 7328 7b64  assign_coords({d
-00001f20: 696d 5f6e 616d 653a 2063 6f6f 7264 737d  im_name: coords}
-00001f30: 290a 0a20 2020 2020 2020 2020 2020 2020  )..             
-00001f40: 2020 2023 2061 7070 6c79 2074 6865 2073     # apply the s
-00001f50: 796d 6d65 7472 7920 6569 6765 6e76 616c  ymmetry eigenval
-00001f60: 7565 2028 6966 2064 6566 696e 6564 2920  ue (if defined) 
-00001f70: 746f 2074 6865 2066 6c69 7070 6564 2076  to the flipped v
-00001f80: 616c 7565 730a 2020 2020 2020 2020 2020  alues.          
-00001f90: 2020 2020 2020 6966 2065 6967 656e 7661        if eigenva
-00001fa0: 6c5f 666e 2069 7320 6e6f 7420 4e6f 6e65  l_fn is not None
-00001fb0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00001fc0: 2020 2020 2020 7379 6d5f 6569 6765 6e76        sym_eigenv
-00001fd0: 616c 7565 203d 2065 6967 656e 7661 6c5f  alue = eigenval_
-00001fe0: 666e 2873 796d 5f64 696d 290a 2020 2020  fn(sym_dim).    
-00001ff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002000: 7363 616c 6172 5f64 6174 6120 3d20 7363  scalar_data = sc
-00002010: 616c 6172 5f64 6174 612e 6d75 6c74 6970  alar_data.multip
-00002020: 6c79 5f61 7428 0a20 2020 2020 2020 2020  ly_at(.         
-00002030: 2020 2020 2020 2020 2020 2020 2020 2076                 v
-00002040: 616c 7565 3d73 796d 5f76 616c 202a 2073  alue=sym_val * s
-00002050: 796d 5f65 6967 656e 7661 6c75 652c 2063  ym_eigenvalue, c
-00002060: 6f6f 7264 5f6e 616d 653d 6469 6d5f 6e61  oord_name=dim_na
-00002070: 6d65 2c20 696e 6469 6365 733d 666c 6970  me, indices=flip
-00002080: 5f69 6e64 730a 2020 2020 2020 2020 2020  _inds.          
-00002090: 2020 2020 2020 2020 2020 290a 0a20 2020            )..   
-000020a0: 2020 2020 2020 2020 2023 2061 7373 6967           # assig
-000020b0: 6e20 7468 6520 6669 6e61 6c20 7363 616c  n the final scal
-000020c0: 6172 2064 6174 6120 746f 2074 6865 2075  ar data to the u
-000020d0: 7064 6174 655f 6469 6374 0a20 2020 2020  pdate_dict.     
-000020e0: 2020 2020 2020 2075 7064 6174 655f 6469         update_di
-000020f0: 6374 5b66 6965 6c64 5f6e 616d 655d 203d  ct[field_name] =
-00002100: 2073 6361 6c61 725f 6461 7461 0a0a 2020   scalar_data..  
-00002110: 2020 2020 2020 7570 6461 7465 5f64 6963        update_dic
-00002120: 742e 7570 6461 7465 287b 2273 796d 6d65  t.update({"symme
-00002130: 7472 7922 3a20 2830 2c20 302c 2030 292c  try": (0, 0, 0),
-00002140: 2022 7379 6d6d 6574 7279 5f63 656e 7465   "symmetry_cente
-00002150: 7222 3a20 4e6f 6e65 7d29 0a0a 2020 2020  r": None})..    
-00002160: 2020 2020 7265 7475 726e 2075 7064 6174      return updat
-00002170: 655f 6469 6374 0a0a 2020 2020 6465 6620  e_dict..    def 
-00002180: 6174 5f63 6f6f 7264 7328 7365 6c66 2c20  at_coords(self, 
-00002190: 636f 6f72 6473 3a20 436f 6f72 6473 2920  coords: Coords) 
-000021a0: 2d3e 2078 722e 4461 7461 7365 743a 0a20  -> xr.Dataset:. 
-000021b0: 2020 2020 2020 2022 2222 436f 6c6f 6361         """Coloca
-000021c0: 7465 2064 6174 6120 746f 2073 6f6d 6520  te data to some 
-000021d0: 7375 7070 6c69 6564 2063 6f6f 7264 696e  supplied coordin
-000021e0: 6174 6573 2e20 5468 6973 2069 7320 6120  ates. This is a 
-000021f0: 636f 6e76 656e 6965 6e63 6520 6d65 7468  convenience meth
-00002200: 6f64 2074 6861 7420 7772 6170 730a 2020  od that wraps.  
-00002210: 2020 2020 2020 6060 636f 6c6f 6361 7465        ``colocate
-00002220: 6060 2c20 616e 6420 736b 6970 7320 6469  ``, and skips di
-00002230: 6d65 6e73 696f 6e73 2066 6f72 2077 6869  mensions for whi
-00002240: 6368 2074 6865 2064 6174 6120 6861 7320  ch the data has 
-00002250: 6120 7369 6e67 6c65 2064 6174 6120 706f  a single data po
-00002260: 696e 7420 6f6e 6c79 0a20 2020 2020 2020  int only.       
-00002270: 2028 6060 636f 6c6f 6361 7465 6060 2077   (``colocate`` w
-00002280: 696c 6c20 6572 726f 7220 696e 2074 6861  ill error in tha
-00002290: 7420 6361 7365 2e29 2049 6620 7468 6520  t case.) If the 
-000022a0: 636f 6f72 6473 2061 7265 206f 7574 206f  coords are out o
-000022b0: 6620 626f 756e 6473 2066 6f72 2074 6865  f bounds for the
-000022c0: 2064 6174 610a 2020 2020 2020 2020 6f74   data.        ot
-000022d0: 6865 7277 6973 652c 2061 6e20 6572 726f  herwise, an erro
-000022e0: 7220 7769 6c6c 2073 7469 6c6c 2062 6520  r will still be 
-000022f0: 7072 6f64 7563 6564 2e0a 0a20 2020 2020  produced...     
-00002300: 2020 2050 6172 616d 6574 6572 730a 2020     Parameters.  
-00002310: 2020 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d        ----------
-00002320: 0a20 2020 2020 2020 2063 6f6f 7264 7320  .        coords 
-00002330: 3a20 3a63 6c61 7373 3a60 436f 6f72 6473  : :class:`Coords
-00002340: 600a 2020 2020 2020 2020 2020 2020 436f  `.            Co
-00002350: 6f72 6469 6e61 7465 7320 696e 2078 2c20  ordinates in x, 
-00002360: 7920 616e 6420 7a20 746f 2063 6f6c 6f63  y and z to coloc
-00002370: 6174 6520 746f 2e0a 0a20 2020 2020 2020  ate to...       
-00002380: 2052 6574 7572 6e73 0a20 2020 2020 2020   Returns.       
-00002390: 202d 2d2d 2d2d 2d2d 0a20 2020 2020 2020   -------.       
-000023a0: 2078 6172 7261 792e 4461 7461 7365 740a   xarray.Dataset.
-000023b0: 2020 2020 2020 2020 2020 2020 4461 7461              Data
-000023c0: 7365 7420 636f 6e74 6169 6e69 6e67 2061  set containing a
-000023d0: 6c6c 206f 6620 7468 6520 6669 656c 6473  ll of the fields
-000023e0: 2069 6e20 7468 6520 6461 7461 2069 6e74   in the data int
-000023f0: 6572 706f 6c61 7465 6420 746f 2062 6f75  erpolated to bou
-00002400: 6e64 6172 7920 6c6f 6361 7469 6f6e 7320  ndary locations 
-00002410: 6f6e 0a20 2020 2020 2020 2020 2020 2074  on.            t
-00002420: 6865 2059 6565 2067 7269 642e 0a20 2020  he Yee grid..   
-00002430: 2020 2020 2022 2222 0a0a 2020 2020 2020       """..      
-00002440: 2020 2320 7061 7373 2063 6f6f 7264 7320    # pass coords 
-00002450: 6966 2065 6163 6820 6f66 2074 6865 2073  if each of the s
-00002460: 6361 6c61 7220 6669 656c 6420 6461 7461  calar field data
-00002470: 2068 6176 6520 6d6f 7265 2074 6861 6e20   have more than 
-00002480: 6f6e 6520 636f 6f72 6469 6e61 7465 2061  one coordinate a
-00002490: 6c6f 6e67 2061 2064 696d 0a20 2020 2020  long a dim.     
-000024a0: 2020 2078 797a 5f6b 7761 7267 7320 3d20     xyz_kwargs = 
-000024b0: 7b7d 0a20 2020 2020 2020 2066 6f72 2064  {}.        for d
-000024c0: 696d 2c20 636f 6f72 6473 5f64 696d 2069  im, coords_dim i
-000024d0: 6e20 7a69 7028 2278 797a 222c 2028 636f  n zip("xyz", (co
-000024e0: 6f72 6473 2e78 2c20 636f 6f72 6473 2e79  ords.x, coords.y
-000024f0: 2c20 636f 6f72 6473 2e7a 2929 3a0a 2020  , coords.z)):.  
-00002500: 2020 2020 2020 2020 2020 7363 616c 6172            scalar
-00002510: 5f64 6174 6120 3d20 6c69 7374 2873 656c  _data = list(sel
-00002520: 662e 6669 656c 645f 636f 6d70 6f6e 656e  f.field_componen
-00002530: 7473 2e76 616c 7565 7328 2929 0a20 2020  ts.values()).   
-00002540: 2020 2020 2020 2020 2063 6f6f 7264 5f6c           coord_l
-00002550: 656e 7320 3d20 5b6c 656e 2864 6174 612e  ens = [len(data.
-00002560: 636f 6f72 6473 5b64 696d 5d29 2066 6f72  coords[dim]) for
-00002570: 2064 6174 6120 696e 2073 6361 6c61 725f   data in scalar_
-00002580: 6461 7461 5d0a 2020 2020 2020 2020 2020  data].          
-00002590: 2020 6966 2061 6c6c 286e 636f 6f72 6473    if all(ncoords
-000025a0: 203e 2031 2066 6f72 206e 636f 6f72 6473   > 1 for ncoords
-000025b0: 2069 6e20 636f 6f72 645f 6c65 6e73 293a   in coord_lens):
-000025c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000025d0: 2078 797a 5f6b 7761 7267 735b 6469 6d5d   xyz_kwargs[dim]
-000025e0: 203d 2063 6f6f 7264 735f 6469 6d0a 0a20   = coords_dim.. 
-000025f0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-00002600: 6c66 2e63 6f6c 6f63 6174 6528 2a2a 7879  lf.colocate(**xy
-00002610: 7a5f 6b77 6172 6773 290a 0a0a 636c 6173  z_kwargs)...clas
-00002620: 7320 456c 6563 7472 6f6d 6167 6e65 7469  s Electromagneti
-00002630: 6346 6965 6c64 4461 7461 2841 6273 7472  cFieldData(Abstr
-00002640: 6163 7446 6965 6c64 4461 7461 2c20 456c  actFieldData, El
-00002650: 6563 7472 6f6d 6167 6e65 7469 6346 6965  ectromagneticFie
-00002660: 6c64 4461 7461 7365 742c 2041 4243 293a  ldDataset, ABC):
-00002670: 0a20 2020 2022 2222 436f 6c6c 6563 7469  .    """Collecti
-00002680: 6f6e 206f 6620 656c 6563 7472 6f6d 6167  on of electromag
-00002690: 6e65 7469 6320 6669 656c 6473 2e22 2222  netic fields."""
-000026a0: 0a0a 2020 2020 6772 6964 5f70 7269 6d61  ..    grid_prima
-000026b0: 6c5f 636f 7272 6563 7469 6f6e 3a20 556e  l_correction: Un
-000026c0: 696f 6e5b 0a20 2020 2020 2020 2066 6c6f  ion[.        flo
-000026d0: 6174 2c20 4672 6571 4461 7461 4172 7261  at, FreqDataArra
-000026e0: 792c 2054 696d 6544 6174 6141 7272 6179  y, TimeDataArray
-000026f0: 2c20 4672 6571 4d6f 6465 4461 7461 4172  , FreqModeDataAr
-00002700: 7261 790a 2020 2020 5d20 3d20 7064 2e46  ray.    ] = pd.F
-00002710: 6965 6c64 280a 2020 2020 2020 2020 312e  ield(.        1.
-00002720: 302c 0a20 2020 2020 2020 2074 6974 6c65  0,.        title
-00002730: 3d22 4669 656c 6420 636f 7272 6563 7469  ="Field correcti
-00002740: 6f6e 2066 6163 746f 7222 2c0a 2020 2020  on factor",.    
-00002750: 2020 2020 6465 7363 7269 7074 696f 6e3d      description=
-00002760: 2243 6f72 7265 6374 696f 6e20 6661 6374  "Correction fact
-00002770: 6f72 2074 6861 7420 6e65 6564 7320 746f  or that needs to
-00002780: 2062 6520 6170 706c 6965 6420 666f 7220   be applied for 
-00002790: 6461 7461 2063 6f72 7265 7370 6f6e 6469  data correspondi
-000027a0: 6e67 2074 6f20 6120 3244 2022 0a20 2020  ng to a 2D ".   
-000027b0: 2020 2020 2022 6d6f 6e69 746f 7220 746f       "monitor to
-000027c0: 2074 616b 6520 696e 746f 2061 6363 6f75   take into accou
-000027d0: 6e74 2074 6865 2066 696e 6974 6520 6772  nt the finite gr
-000027e0: 6964 2069 6e20 7468 6520 6e6f 726d 616c  id in the normal
-000027f0: 2064 6972 6563 7469 6f6e 2069 6e20 7468   direction in th
-00002800: 6520 7369 6d75 6c61 7469 6f6e 2069 6e20  e simulation in 
-00002810: 220a 2020 2020 2020 2020 2277 6869 6368  ".        "which
-00002820: 2074 6865 2064 6174 6120 7761 7320 636f   the data was co
-00002830: 6d70 7574 6564 2e20 5468 6520 6661 6374  mputed. The fact
-00002840: 6f72 2069 7320 6170 706c 6965 6420 746f  or is applied to
-00002850: 2066 6965 6c64 7320 6465 6669 6e65 6420   fields defined 
-00002860: 6f6e 2074 6865 2070 7269 6d61 6c20 6772  on the primal gr
-00002870: 6964 2022 0a20 2020 2020 2020 2022 6c6f  id ".        "lo
-00002880: 6361 7469 6f6e 7320 616c 6f6e 6720 7468  cations along th
-00002890: 6520 6e6f 726d 616c 2064 6972 6563 7469  e normal directi
-000028a0: 6f6e 2e22 2c0a 2020 2020 290a 2020 2020  on.",.    ).    
-000028b0: 6772 6964 5f64 7561 6c5f 636f 7272 6563  grid_dual_correc
-000028c0: 7469 6f6e 3a20 556e 696f 6e5b 666c 6f61  tion: Union[floa
-000028d0: 742c 2046 7265 7144 6174 6141 7272 6179  t, FreqDataArray
-000028e0: 2c20 5469 6d65 4461 7461 4172 7261 792c  , TimeDataArray,
-000028f0: 2046 7265 714d 6f64 6544 6174 6141 7272   FreqModeDataArr
-00002900: 6179 5d20 3d20 7064 2e46 6965 6c64 280a  ay] = pd.Field(.
-00002910: 2020 2020 2020 2020 312e 302c 0a20 2020          1.0,.   
-00002920: 2020 2020 2074 6974 6c65 3d22 4669 656c       title="Fiel
-00002930: 6420 636f 7272 6563 7469 6f6e 2066 6163  d correction fac
-00002940: 746f 7222 2c0a 2020 2020 2020 2020 6465  tor",.        de
-00002950: 7363 7269 7074 696f 6e3d 2243 6f72 7265  scription="Corre
-00002960: 6374 696f 6e20 6661 6374 6f72 2074 6861  ction factor tha
-00002970: 7420 6e65 6564 7320 746f 2062 6520 6170  t needs to be ap
-00002980: 706c 6965 6420 666f 7220 6461 7461 2063  plied for data c
-00002990: 6f72 7265 7370 6f6e 6469 6e67 2074 6f20  orresponding to 
-000029a0: 6120 3244 2022 0a20 2020 2020 2020 2022  a 2D ".        "
-000029b0: 6d6f 6e69 746f 7220 746f 2074 616b 6520  monitor to take 
-000029c0: 696e 746f 2061 6363 6f75 6e74 2074 6865  into account the
-000029d0: 2066 696e 6974 6520 6772 6964 2069 6e20   finite grid in 
-000029e0: 7468 6520 6e6f 726d 616c 2064 6972 6563  the normal direc
-000029f0: 7469 6f6e 2069 6e20 7468 6520 7369 6d75  tion in the simu
-00002a00: 6c61 7469 6f6e 2069 6e20 220a 2020 2020  lation in ".    
-00002a10: 2020 2020 2277 6869 6368 2074 6865 2064      "which the d
-00002a20: 6174 6120 7761 7320 636f 6d70 7574 6564  ata was computed
-00002a30: 2e20 5468 6520 6661 6374 6f72 2069 7320  . The factor is 
-00002a40: 6170 706c 6965 6420 746f 2066 6965 6c64  applied to field
-00002a50: 7320 6465 6669 6e65 6420 6f6e 2074 6865  s defined on the
-00002a60: 2064 7561 6c20 6772 6964 2022 0a20 2020   dual grid ".   
-00002a70: 2020 2020 2022 6c6f 6361 7469 6f6e 7320       "locations 
-00002a80: 616c 6f6e 6720 7468 6520 6e6f 726d 616c  along the normal
-00002a90: 2064 6972 6563 7469 6f6e 2e22 2c0a 2020   direction.",.  
-00002aa0: 2020 290a 0a20 2020 2064 6566 205f 6578    )..    def _ex
-00002ab0: 7061 6e64 6564 5f67 7269 645f 6669 656c  panded_grid_fiel
-00002ac0: 645f 636f 6f72 6473 2873 656c 662c 2066  d_coords(self, f
-00002ad0: 6965 6c64 5f6e 616d 653a 2073 7472 293a  ield_name: str):
-00002ae0: 0a20 2020 2020 2020 2022 2222 436f 6f72  .        """Coor
-00002af0: 6469 6e61 7465 7320 696e 2074 6865 2065  dinates in the e
-00002b00: 7870 616e 6465 6420 6772 6964 2063 6f72  xpanded grid cor
-00002b10: 7265 7370 6f6e 6469 6e67 2074 6f20 6120  responding to a 
-00002b20: 6769 7665 6e20 6669 656c 6420 636f 6d70  given field comp
-00002b30: 6f6e 656e 742e 2222 220a 2020 2020 2020  onent.""".      
-00002b40: 2020 6966 2073 656c 662e 6d6f 6e69 746f    if self.monito
-00002b50: 722e 636f 6c6f 6361 7465 3a0a 2020 2020  r.colocate:.    
-00002b60: 2020 2020 2020 2020 626f 756e 6473 5f64          bounds_d
-00002b70: 6963 7420 3d20 7365 6c66 2e67 7269 645f  ict = self.grid_
-00002b80: 6578 7061 6e64 6564 2e62 6f75 6e64 6172  expanded.boundar
-00002b90: 6965 732e 746f 5f64 6963 740a 2020 2020  ies.to_dict.    
-00002ba0: 2020 2020 2020 2020 7265 7475 726e 2043          return C
-00002bb0: 6f6f 7264 7328 2a2a 7b6b 6579 3a20 7661  oords(**{key: va
-00002bc0: 6c5b 3a2d 315d 2066 6f72 206b 6579 2c20  l[:-1] for key, 
-00002bd0: 7661 6c20 696e 2062 6f75 6e64 735f 6469  val in bounds_di
-00002be0: 6374 2e69 7465 6d73 2829 7d29 0a20 2020  ct.items()}).   
-00002bf0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-00002c00: 2e67 7269 645f 6578 7061 6e64 6564 5b73  .grid_expanded[s
-00002c10: 656c 662e 6772 6964 5f6c 6f63 6174 696f  elf.grid_locatio
-00002c20: 6e73 5b66 6965 6c64 5f6e 616d 655d 5d0a  ns[field_name]].
-00002c30: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
-00002c40: 2020 2064 6566 205f 6772 6964 5f63 6f72     def _grid_cor
-00002c50: 7265 6374 696f 6e5f 6469 6374 2873 656c  rection_dict(sel
-00002c60: 6629 3a0a 2020 2020 2020 2020 2222 2252  f):.        """R
-00002c70: 6574 7572 6e20 7468 6520 7072 696d 616c  eturn the primal
-00002c80: 2061 6e64 2064 7561 6c20 6669 6e69 7465   and dual finite
-00002c90: 2067 7269 6420 636f 7272 6563 7469 6f6e   grid correction
-00002ca0: 2066 6163 746f 7273 2061 7320 6120 6469   factors as a di
-00002cb0: 6374 696f 6e61 7279 2e22 2222 0a20 2020  ctionary.""".   
-00002cc0: 2020 2020 2072 6574 7572 6e20 7b0a 2020       return {.  
-00002cd0: 2020 2020 2020 2020 2020 2267 7269 645f            "grid_
-00002ce0: 7072 696d 616c 5f63 6f72 7265 6374 696f  primal_correctio
-00002cf0: 6e22 3a20 7365 6c66 2e67 7269 645f 7072  n": self.grid_pr
-00002d00: 696d 616c 5f63 6f72 7265 6374 696f 6e2c  imal_correction,
-00002d10: 0a20 2020 2020 2020 2020 2020 2022 6772  .            "gr
-00002d20: 6964 5f64 7561 6c5f 636f 7272 6563 7469  id_dual_correcti
-00002d30: 6f6e 223a 2073 656c 662e 6772 6964 5f64  on": self.grid_d
-00002d40: 7561 6c5f 636f 7272 6563 7469 6f6e 2c0a  ual_correction,.
-00002d50: 2020 2020 2020 2020 7d0a 0a20 2020 2040          }..    @
-00002d60: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
-00002d70: 205f 7461 6e67 656e 7469 616c 5f64 696d   _tangential_dim
-00002d80: 7328 7365 6c66 2920 2d3e 204c 6973 745b  s(self) -> List[
-00002d90: 7374 725d 3a0a 2020 2020 2020 2020 2222  str]:.        ""
-00002da0: 2246 6f72 2061 2032 4420 6d6f 6e69 746f  "For a 2D monito
-00002db0: 7220 6461 7461 2c20 7265 7475 726e 2074  r data, return t
-00002dc0: 6865 206e 616d 6573 206f 6620 7468 6520  he names of the 
-00002dd0: 7461 6e67 656e 7469 616c 2064 696d 656e  tangential dimen
-00002de0: 7369 6f6e 732e 2052 6169 7365 2069 6620  sions. Raise if 
-00002df0: 6361 6e6e 6f74 0a20 2020 2020 2020 2063  cannot.        c
-00002e00: 6f6e 6669 726d 2074 6861 7420 7468 6520  onfirm that the 
-00002e10: 6173 736f 6369 6174 6564 206d 6f6e 6974  associated monit
-00002e20: 6f72 2069 7320 3244 2e22 2222 0a20 2020  or is 2D.""".   
-00002e30: 2020 2020 2069 6620 6c65 6e28 7365 6c66       if len(self
-00002e40: 2e6d 6f6e 6974 6f72 2e7a 6572 6f5f 6469  .monitor.zero_di
-00002e50: 6d73 2920 213d 2031 3a0a 2020 2020 2020  ms) != 1:.      
-00002e60: 2020 2020 2020 7261 6973 6520 4461 7461        raise Data
-00002e70: 4572 726f 7228 2244 6174 6120 6d75 7374  Error("Data must
-00002e80: 2062 6520 3244 2074 6f20 6765 7420 7461   be 2D to get ta
-00002e90: 6e67 656e 7469 616c 2064 696d 656e 7369  ngential dimensi
-00002ea0: 6f6e 732e 2229 0a20 2020 2020 2020 2074  ons.").        t
-00002eb0: 616e 6765 6e74 6961 6c5f 6469 6d73 203d  angential_dims =
-00002ec0: 205b 2278 222c 2022 7922 2c20 227a 225d   ["x", "y", "z"]
-00002ed0: 0a20 2020 2020 2020 2074 616e 6765 6e74  .        tangent
-00002ee0: 6961 6c5f 6469 6d73 2e70 6f70 2873 656c  ial_dims.pop(sel
-00002ef0: 662e 6d6f 6e69 746f 722e 7a65 726f 5f64  f.monitor.zero_d
-00002f00: 696d 735b 305d 290a 0a20 2020 2020 2020  ims[0])..       
-00002f10: 2072 6574 7572 6e20 7461 6e67 656e 7469   return tangenti
-00002f20: 616c 5f64 696d 730a 0a20 2020 2040 7072  al_dims..    @pr
-00002f30: 6f70 6572 7479 0a20 2020 2064 6566 2063  operty.    def c
-00002f40: 6f6c 6f63 6174 696f 6e5f 626f 756e 6461  olocation_bounda
-00002f50: 7269 6573 2873 656c 6629 202d 3e20 436f  ries(self) -> Co
-00002f60: 6f72 6473 3a0a 2020 2020 2020 2020 2222  ords:.        ""
-00002f70: 2243 6f6f 7264 696e 6174 6573 2074 6f20  "Coordinates to 
-00002f80: 6265 2075 7365 6420 666f 7220 636f 6c6f  be used for colo
-00002f90: 6361 7469 6f6e 206f 6620 7468 6520 6461  cation of the da
-00002fa0: 7461 2074 6f20 6772 6964 2062 6f75 6e64  ta to grid bound
-00002fb0: 6172 6965 732e 2222 220a 0a20 2020 2020  aries."""..     
-00002fc0: 2020 2069 6620 6e6f 7420 7365 6c66 2e67     if not self.g
-00002fd0: 7269 645f 6578 7061 6e64 6564 3a0a 2020  rid_expanded:.  
-00002fe0: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
-00002ff0: 4461 7461 4572 726f 7228 0a20 2020 2020  DataError(.     
-00003000: 2020 2020 2020 2020 2020 2022 4d6f 6e69             "Moni
-00003010: 746f 7220 6461 7461 2072 6571 7569 7265  tor data require
-00003020: 7320 2767 7269 645f 6578 7061 6e64 6564  s 'grid_expanded
-00003030: 2720 746f 2062 6520 6465 6669 6e65 6420  ' to be defined 
-00003040: 696e 206f 7264 6572 2074 6f20 220a 2020  in order to ".  
-00003050: 2020 2020 2020 2020 2020 2020 2020 2263                "c
-00003060: 6f6d 7075 7465 2063 6f6c 6f63 6174 696f  ompute colocatio
-00003070: 6e20 636f 6f72 6469 6e61 7465 732e 220a  n coordinates.".
-00003080: 2020 2020 2020 2020 2020 2020 290a 0a20              ).. 
-00003090: 2020 2020 2020 2023 2047 6574 2062 6f75         # Get bou
-000030a0: 6e64 6172 6965 7320 6672 6f6d 2074 6865  ndaries from the
-000030b0: 2065 7870 616e 6465 6420 6772 6964 0a20   expanded grid. 
-000030c0: 2020 2020 2020 2067 7269 645f 626f 756e         grid_boun
-000030d0: 6473 203d 2073 656c 662e 6772 6964 5f65  ds = self.grid_e
-000030e0: 7870 616e 6465 642e 626f 756e 6461 7269  xpanded.boundari
-000030f0: 6573 2e74 6f5f 6469 6374 0a0a 2020 2020  es.to_dict..    
-00003100: 2020 2020 2320 4e6f 6e2d 636f 6c6f 6361      # Non-coloca
-00003110: 7469 6e67 206d 6f6e 6974 6f72 7320 6361  ting monitors ca
-00003120: 6e20 6f6e 6c79 2063 6f6c 6f63 6174 6520  n only colocate 
-00003130: 7374 6172 7469 6e67 2066 726f 6d20 7468  starting from th
-00003140: 6520 6669 7273 7420 626f 756e 6461 7279  e first boundary
-00003150: 0a20 2020 2020 2020 2023 2028 756e 6c65  .        # (unle
-00003160: 7373 2074 6865 7265 2773 2061 2073 696e  ss there's a sin
-00003170: 676c 6520 6461 7461 2070 6f69 6e74 2c20  gle data point, 
-00003180: 696e 2077 6869 6368 2063 6173 6520 6461  in which case da
-00003190: 7461 2068 6173 2061 6c72 6561 6479 2062  ta has already b
-000031a0: 6565 6e20 736e 6170 7065 6429 2e0a 2020  een snapped)..  
-000031b0: 2020 2020 2020 2320 5265 6761 7264 6c65        # Regardle
-000031c0: 7373 206f 6620 636f 6c6f 6361 7469 6f6e  ss of colocation
-000031d0: 2c20 7765 2061 6c73 6f20 6472 6f70 2074  , we also drop t
-000031e0: 6865 206c 6173 7420 626f 756e 6461 7279  he last boundary
-000031f0: 2e0a 2020 2020 2020 2020 636f 6c6f 6361  ..        coloca
-00003200: 7465 5f62 6f75 6e64 7320 3d20 7b7d 0a20  te_bounds = {}. 
-00003210: 2020 2020 2020 2066 6f72 2064 696d 2c20         for dim, 
-00003220: 626f 756e 6473 2069 6e20 6772 6964 5f62  bounds in grid_b
-00003230: 6f75 6e64 732e 6974 656d 7328 293a 0a20  ounds.items():. 
-00003240: 2020 2020 2020 2020 2020 2063 6273 203d             cbs =
-00003250: 2062 6f75 6e64 735b 3a2d 315d 0a20 2020   bounds[:-1].   
-00003260: 2020 2020 2020 2020 2069 6620 6e6f 7420           if not 
-00003270: 7365 6c66 2e6d 6f6e 6974 6f72 2e63 6f6c  self.monitor.col
-00003280: 6f63 6174 6520 616e 6420 6362 732e 7369  ocate and cbs.si
-00003290: 7a65 203e 2031 3a0a 2020 2020 2020 2020  ze > 1:.        
-000032a0: 2020 2020 2020 2020 6362 7320 3d20 6362          cbs = cb
-000032b0: 735b 313a 5d0a 2020 2020 2020 2020 2020  s[1:].          
-000032c0: 2020 636f 6c6f 6361 7465 5f62 6f75 6e64    colocate_bound
-000032d0: 735b 6469 6d5d 203d 2063 6273 0a0a 2020  s[dim] = cbs..  
-000032e0: 2020 2020 2020 7265 7475 726e 2043 6f6f        return Coo
-000032f0: 7264 7328 2a2a 636f 6c6f 6361 7465 5f62  rds(**colocate_b
-00003300: 6f75 6e64 7329 0a0a 2020 2020 4070 726f  ounds)..    @pro
-00003310: 7065 7274 790a 2020 2020 6465 6620 636f  perty.    def co
-00003320: 6c6f 6361 7469 6f6e 5f63 656e 7465 7273  location_centers
-00003330: 2873 656c 6629 202d 3e20 436f 6f72 6473  (self) -> Coords
-00003340: 3a0a 2020 2020 2020 2020 2222 2243 6f6f  :.        """Coo
-00003350: 7264 696e 6174 6573 2074 6f20 6265 2075  rdinates to be u
-00003360: 7365 6420 666f 7220 636f 6c6f 6361 7469  sed for colocati
-00003370: 6f6e 206f 6620 7468 6520 6461 7461 2074  on of the data t
-00003380: 6f20 6772 6964 2063 656e 7465 7273 2e22  o grid centers."
-00003390: 2222 0a20 2020 2020 2020 2063 6f6c 6f63  "".        coloc
-000033a0: 6174 655f 6365 6e74 6572 7320 3d20 7b7d  ate_centers = {}
-000033b0: 0a20 2020 2020 2020 2066 6f72 2064 696d  .        for dim
-000033c0: 2c20 636f 6f72 6473 2069 6e20 7365 6c66  , coords in self
-000033d0: 2e63 6f6c 6f63 6174 696f 6e5f 626f 756e  .colocation_boun
-000033e0: 6461 7269 6573 2e74 6f5f 6469 6374 2e69  daries.to_dict.i
-000033f0: 7465 6d73 2829 3a0a 2020 2020 2020 2020  tems():.        
-00003400: 2020 2020 636f 6c6f 6361 7465 5f63 656e      colocate_cen
-00003410: 7465 7273 5b64 696d 5d20 3d20 2863 6f6f  ters[dim] = (coo
-00003420: 7264 735b 313a 5d20 2b20 636f 6f72 6473  rds[1:] + coords
-00003430: 5b3a 2d31 5d29 202f 2032 0a0a 2020 2020  [:-1]) / 2..    
-00003440: 2020 2020 7265 7475 726e 2043 6f6f 7264      return Coord
-00003450: 7328 2a2a 636f 6c6f 6361 7465 5f63 656e  s(**colocate_cen
-00003460: 7465 7273 290a 0a20 2020 2040 7072 6f70  ters)..    @prop
-00003470: 6572 7479 0a20 2020 2064 6566 205f 706c  erty.    def _pl
-00003480: 616e 655f 6772 6964 5f62 6f75 6e64 6172  ane_grid_boundar
-00003490: 6965 7328 7365 6c66 2920 2d3e 2054 7570  ies(self) -> Tup
-000034a0: 6c65 5b43 6f6f 7264 7331 442c 2043 6f6f  le[Coords1D, Coo
-000034b0: 7264 7331 445d 3a0a 2020 2020 2020 2020  rds1D]:.        
-000034c0: 2222 2246 6f72 2061 2032 4420 6d6f 6e69  """For a 2D moni
-000034d0: 746f 7220 6461 7461 2c20 7265 7475 726e  tor data, return
-000034e0: 2074 6865 2062 6f75 6e64 6172 6965 7320   the boundaries 
-000034f0: 6f66 2074 6865 2069 6e2d 706c 616e 6520  of the in-plane 
-00003500: 6772 6964 2074 6f20 6265 2075 7365 6420  grid to be used 
-00003510: 746f 2063 6f6d 7075 7465 0a20 2020 2020  to compute.     
-00003520: 2020 2064 6966 6665 7265 6e74 6961 6c20     differential 
-00003530: 6172 6561 2061 6e64 2074 6f20 636f 6c6f  area and to colo
-00003540: 6361 7465 2066 6965 6c64 7320 6966 206e  cate fields if n
-00003550: 6565 6465 642e 2222 220a 2020 2020 2020  eeded.""".      
-00003560: 2020 6966 206e 702e 616e 7928 6e70 2e61    if np.any(np.a
-00003570: 7272 6179 2873 656c 662e 6d6f 6e69 746f  rray(self.monito
-00003580: 722e 696e 7465 7276 616c 5f73 7061 6365  r.interval_space
-00003590: 2920 3e20 3129 3a0a 2020 2020 2020 2020  ) > 1):.        
-000035a0: 2020 2020 7261 6973 6520 5469 6479 3364      raise Tidy3d
-000035b0: 4e6f 7449 6d70 6c65 6d65 6e74 6564 4572  NotImplementedEr
-000035c0: 726f 7228 0a20 2020 2020 2020 2020 2020  ror(.           
-000035d0: 2020 2020 2022 4361 6e6e 6f74 2064 6574       "Cannot det
-000035e0: 6572 6d69 6e65 2067 7269 6420 626f 756e  ermine grid boun
-000035f0: 6461 7269 6573 2063 6f72 7265 7370 6f6e  daries correspon
-00003600: 6469 6e67 2074 6f20 220a 2020 2020 2020  ding to ".      
-00003610: 2020 2020 2020 2020 2020 2264 6f77 6e2d            "down-
-00003620: 7361 6d70 6c65 6420 6d6f 6e69 746f 7220  sampled monitor 
-00003630: 6461 7461 2028 2769 6e74 6572 7661 6c5f  data ('interval_
-00003640: 7370 6163 6527 203e 2031 2061 6c6f 6e67  space' > 1 along
-00003650: 2061 2064 6972 6563 7469 6f6e 292e 220a   a direction).".
-00003660: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-00003670: 2020 2020 2020 6469 6d31 2c20 6469 6d32        dim1, dim2
-00003680: 203d 2073 656c 662e 5f74 616e 6765 6e74   = self._tangent
-00003690: 6961 6c5f 6469 6d73 0a20 2020 2020 2020  ial_dims.       
-000036a0: 2062 6f75 6e64 735f 6469 6374 203d 2073   bounds_dict = s
-000036b0: 656c 662e 636f 6c6f 6361 7469 6f6e 5f62  elf.colocation_b
-000036c0: 6f75 6e64 6172 6965 732e 746f 5f64 6963  oundaries.to_dic
-000036d0: 740a 2020 2020 2020 2020 7265 7475 726e  t.        return
-000036e0: 2028 626f 756e 6473 5f64 6963 745b 6469   (bounds_dict[di
-000036f0: 6d31 5d2c 2062 6f75 6e64 735f 6469 6374  m1], bounds_dict
-00003700: 5b64 696d 325d 290a 0a20 2020 2040 7072  [dim2])..    @pr
-00003710: 6f70 6572 7479 0a20 2020 2064 6566 205f  operty.    def _
-00003720: 706c 616e 655f 6772 6964 5f63 656e 7465  plane_grid_cente
-00003730: 7273 2873 656c 6629 202d 3e20 5475 706c  rs(self) -> Tupl
-00003740: 655b 436f 6f72 6473 3144 2c20 436f 6f72  e[Coords1D, Coor
-00003750: 6473 3144 5d3a 0a20 2020 2020 2020 2022  ds1D]:.        "
-00003760: 2222 466f 7220 3244 206d 6f6e 6974 6f72  ""For 2D monitor
-00003770: 2064 6174 612c 2072 6574 7572 6e20 7468   data, return th
-00003780: 6520 6365 6e74 6572 7320 6f66 2074 6865  e centers of the
-00003790: 2069 6e2d 706c 616e 6520 6772 6964 2222   in-plane grid""
-000037a0: 220a 2020 2020 2020 2020 7265 7475 726e  ".        return
-000037b0: 205b 2862 735b 313a 5d20 2b20 6273 5b3a   [(bs[1:] + bs[:
-000037c0: 2d31 5d29 202f 2032 2066 6f72 2062 7320  -1]) / 2 for bs 
-000037d0: 696e 2073 656c 662e 5f70 6c61 6e65 5f67  in self._plane_g
-000037e0: 7269 645f 626f 756e 6461 7269 6573 5d0a  rid_boundaries].
-000037f0: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
-00003800: 2020 2064 6566 205f 6469 6666 5f61 7265     def _diff_are
-00003810: 6128 7365 6c66 2920 2d3e 2078 722e 4461  a(self) -> xr.Da
-00003820: 7461 4172 7261 793a 0a20 2020 2020 2020  taArray:.       
-00003830: 2022 2222 466f 7220 6120 3244 206d 6f6e   """For a 2D mon
-00003840: 6974 6f72 2064 6174 612c 2072 6574 7572  itor data, retur
-00003850: 6e20 7468 6520 6172 6561 206f 6620 6561  n the area of ea
-00003860: 6368 2063 656c 6c20 696e 2074 6865 2070  ch cell in the p
-00003870: 6c61 6e65 2c20 666f 7220 7573 6520 696e  lane, for use in
-00003880: 206e 756d 6572 6963 616c 0a20 2020 2020   numerical.     
-00003890: 2020 2069 6e74 6567 7261 7469 6f6e 732e     integrations.
-000038a0: 2054 6869 7320 6173 7375 6d65 7320 7468   This assumes th
-000038b0: 6174 2064 6174 6120 6973 2063 6f6c 6f63  at data is coloc
-000038c0: 6174 6564 2074 6f20 6772 6964 2062 6f75  ated to grid bou
-000038d0: 6e64 6172 6965 732c 2061 6e64 2075 7365  ndaries, and use
-000038e0: 7320 7468 650a 2020 2020 2020 2020 6469  s the.        di
-000038f0: 6666 6572 656e 6365 2069 6e20 7468 6520  fference in the 
-00003900: 7375 7272 6f75 6e64 696e 6720 6772 6964  surrounding grid
-00003910: 2063 656e 7465 7273 2074 6f20 636f 6d70   centers to comp
-00003920: 7574 6520 7468 6520 6172 6561 2e0a 2020  ute the area..  
-00003930: 2020 2020 2020 2222 220a 0a20 2020 2020        """..     
-00003940: 2020 2023 204d 6f6e 6974 6f72 2076 616c     # Monitor val
-00003950: 7565 7320 6172 6520 696e 7465 7270 6f6c  ues are interpol
-00003960: 6174 6564 2074 6f20 626f 756e 6473 0a20  ated to bounds. 
-00003970: 2020 2020 2020 2062 6f75 6e64 7320 3d20         bounds = 
-00003980: 7365 6c66 2e5f 706c 616e 655f 6772 6964  self._plane_grid
-00003990: 5f62 6f75 6e64 6172 6965 730a 2020 2020  _boundaries.    
-000039a0: 2020 2020 2320 436f 6f72 6473 2074 6f20      # Coords to 
-000039b0: 636f 6d70 7574 6520 6365 6c6c 2073 697a  compute cell siz
-000039c0: 6573 2061 726f 756e 6420 7468 6520 696e  es around the in
-000039d0: 7465 7270 6f6c 6174 696f 6e20 6c6f 6361  terpolation loca
-000039e0: 7469 6f6e 730a 2020 2020 2020 2020 636f  tions.        co
-000039f0: 6f72 6473 203d 205b 6273 2e63 6f70 7928  ords = [bs.copy(
-00003a00: 2920 666f 7220 6273 2069 6e20 7365 6c66  ) for bs in self
-00003a10: 2e5f 706c 616e 655f 6772 6964 5f63 656e  ._plane_grid_cen
-00003a20: 7465 7273 5d0a 0a20 2020 2020 2020 2023  ters]..        #
-00003a30: 2041 7070 656e 6420 7468 6520 6669 7273   Append the firs
-00003a40: 7420 616e 6420 6c61 7374 2062 6f75 6e64  t and last bound
-00003a50: 6172 790a 2020 2020 2020 2020 5f2c 2070  ary.        _, p
-00003a60: 6c61 6e65 5f69 6e64 7320 3d20 7365 6c66  lane_inds = self
-00003a70: 2e6d 6f6e 6974 6f72 2e70 6f70 5f61 7869  .monitor.pop_axi
-00003a80: 7328 5b30 2c20 312c 2032 5d2c 2073 656c  s([0, 1, 2], sel
-00003a90: 662e 6d6f 6e69 746f 722e 7369 7a65 2e69  f.monitor.size.i
-00003aa0: 6e64 6578 2830 2e30 2929 0a20 2020 2020  ndex(0.0)).     
-00003ab0: 2020 2063 6f6f 7264 735b 305d 203d 206e     coords[0] = n
-00003ac0: 702e 6172 7261 7928 5b62 6f75 6e64 735b  p.array([bounds[
-00003ad0: 305d 5b30 5d5d 202b 2063 6f6f 7264 735b  0][0]] + coords[
-00003ae0: 305d 2e74 6f6c 6973 7428 2920 2b20 5b62  0].tolist() + [b
-00003af0: 6f75 6e64 735b 305d 5b2d 315d 5d29 0a20  ounds[0][-1]]). 
-00003b00: 2020 2020 2020 2063 6f6f 7264 735b 315d         coords[1]
-00003b10: 203d 206e 702e 6172 7261 7928 5b62 6f75   = np.array([bou
-00003b20: 6e64 735b 315d 5b30 5d5d 202b 2063 6f6f  nds[1][0]] + coo
-00003b30: 7264 735b 315d 2e74 6f6c 6973 7428 2920  rds[1].tolist() 
-00003b40: 2b20 5b62 6f75 6e64 735b 315d 5b2d 315d  + [bounds[1][-1]
-00003b50: 5d29 0a0a 2020 2020 2020 2020 2222 2254  ])..        """T
-00003b60: 7275 6e63 6174 6520 636f 6f72 6473 2074  runcate coords t
-00003b70: 6f20 6d6f 6e69 746f 7220 626f 756e 6461  o monitor bounda
-00003b80: 7269 6573 2e20 5468 6973 2069 6d70 6c69  ries. This impli
-00003b90: 6369 746c 7920 6d61 6b65 7320 6578 7472  citly makes extr
-00003ba0: 6120 7069 7865 6c73 2077 6869 6368 206d  a pixels which m
-00003bb0: 6179 2062 650a 2020 2020 2020 2020 7072  ay be.        pr
-00003bc0: 6573 656e 7420 6861 7665 2073 697a 6520  esent have size 
-00003bd0: 3020 616e 6420 736f 2077 6f6e 2774 2062  0 and so won't b
-00003be0: 6520 696e 636c 7564 6564 2069 6e20 7468  e included in th
-00003bf0: 6520 696e 7465 6772 6174 696f 6e2e 2046  e integration. F
-00003c00: 6f72 2070 6978 656c 7320 696e 7465 7273  or pixels inters
-00003c10: 6563 7465 640a 2020 2020 2020 2020 6279  ected.        by
-00003c20: 2074 6865 206d 6f6e 6974 6f72 2065 6467   the monitor edg
-00003c30: 652c 2074 6865 2073 697a 6520 6973 2074  e, the size is t
-00003c40: 7275 6e63 6174 6564 2074 6f20 7468 6520  runcated to the 
-00003c50: 7061 7274 2063 6f76 6572 6564 2062 7920  part covered by 
-00003c60: 7468 6520 6d6f 6e69 746f 722e 2057 6865  the monitor. Whe
-00003c70: 6e20 7573 696e 670a 2020 2020 2020 2020  n using.        
-00003c80: 7468 6520 6469 6666 6572 656e 7469 616c  the differential
-00003c90: 2061 7265 6120 7369 7a65 7320 6465 6669   area sizes defi
-00003ca0: 6e65 6420 696e 2074 6869 7320 7761 7920  ned in this way 
-00003cb0: 746f 6765 7468 6572 2077 6974 6820 696e  together with in
-00003cc0: 7465 6772 616e 6420 7661 6c75 6573 0a20  tegrand values. 
-00003cd0: 2020 2020 2020 2064 6566 696e 6564 2061         defined a
-00003ce0: 7420 6365 6c6c 2062 6f75 6e64 6172 6965  t cell boundarie
-00003cf0: 732c 2074 6865 2069 6e74 6567 7261 7469  s, the integrati
-00003d00: 6f6e 2069 7320 6571 7569 7661 6c65 6e74  on is equivalent
-00003d10: 2074 6f20 7472 6170 657a 6f69 6461 6c20   to trapezoidal 
-00003d20: 7275 6c65 2077 6974 6820 7468 6520 6669  rule with the fi
-00003d30: 7273 740a 2020 2020 2020 2020 616e 6420  rst.        and 
-00003d40: 6c61 7374 2076 616c 7565 7320 696e 7465  last values inte
-00003d50: 7270 6f6c 6174 6564 2074 6f20 7468 6520  rpolated to the 
-00003d60: 6578 6163 7420 6d6f 6e69 746f 7220 7374  exact monitor st
-00003d70: 6172 742f 656e 6420 6c6f 6361 7469 6f6e  art/end location
-00003d80: 2c20 6966 2074 6865 2069 6e74 6567 7261  , if the integra
-00003d90: 6e64 0a20 2020 2020 2020 2069 7320 7a65  nd.        is ze
-00003da0: 726f 206f 7574 7369 6465 206f 6620 7468  ro outside of th
-00003db0: 6520 6d6f 6e69 746f 7220 6765 6f6d 6574  e monitor geomet
-00003dc0: 7279 2e20 5468 6973 2073 686f 756c 6420  ry. This should 
-00003dd0: 7573 7561 6c6c 7920 6265 2074 6865 2063  usually be the c
-00003de0: 6173 6520 666f 7220 666c 7578 2061 6e64  ase for flux and
-00003df0: 2064 6f74 0a20 2020 2020 2020 2063 6f6d   dot.        com
-00003e00: 7075 7461 7469 6f6e 7322 2222 0a20 2020  putations""".   
-00003e10: 2020 2020 206d 6e74 5f62 6f75 6e64 7320       mnt_bounds 
-00003e20: 3d20 6e70 2e61 7272 6179 2873 656c 662e  = np.array(self.
-00003e30: 6d6f 6e69 746f 722e 626f 756e 6473 290a  monitor.bounds).
-00003e40: 2020 2020 2020 2020 6d6e 745f 626f 756e          mnt_boun
-00003e50: 6473 203d 206d 6e74 5f62 6f75 6e64 735b  ds = mnt_bounds[
-00003e60: 3a2c 2070 6c61 6e65 5f69 6e64 735d 2e54  :, plane_inds].T
-00003e70: 0a20 2020 2020 2020 2063 6f6f 7264 735b  .        coords[
-00003e80: 305d 5b6e 702e 6172 6777 6865 7265 2863  0][np.argwhere(c
-00003e90: 6f6f 7264 735b 305d 203c 206d 6e74 5f62  oords[0] < mnt_b
-00003ea0: 6f75 6e64 735b 302c 2030 5d29 5d20 3d20  ounds[0, 0])] = 
-00003eb0: 6d6e 745f 626f 756e 6473 5b30 2c20 305d  mnt_bounds[0, 0]
-00003ec0: 0a20 2020 2020 2020 2063 6f6f 7264 735b  .        coords[
-00003ed0: 305d 5b6e 702e 6172 6777 6865 7265 2863  0][np.argwhere(c
-00003ee0: 6f6f 7264 735b 305d 203e 206d 6e74 5f62  oords[0] > mnt_b
-00003ef0: 6f75 6e64 735b 302c 2031 5d29 5d20 3d20  ounds[0, 1])] = 
-00003f00: 6d6e 745f 626f 756e 6473 5b30 2c20 315d  mnt_bounds[0, 1]
-00003f10: 0a20 2020 2020 2020 2063 6f6f 7264 735b  .        coords[
-00003f20: 315d 5b6e 702e 6172 6777 6865 7265 2863  1][np.argwhere(c
-00003f30: 6f6f 7264 735b 315d 203c 206d 6e74 5f62  oords[1] < mnt_b
-00003f40: 6f75 6e64 735b 312c 2030 5d29 5d20 3d20  ounds[1, 0])] = 
-00003f50: 6d6e 745f 626f 756e 6473 5b31 2c20 305d  mnt_bounds[1, 0]
-00003f60: 0a20 2020 2020 2020 2063 6f6f 7264 735b  .        coords[
-00003f70: 315d 5b6e 702e 6172 6777 6865 7265 2863  1][np.argwhere(c
-00003f80: 6f6f 7264 735b 315d 203e 206d 6e74 5f62  oords[1] > mnt_b
-00003f90: 6f75 6e64 735b 312c 2031 5d29 5d20 3d20  ounds[1, 1])] = 
-00003fa0: 6d6e 745f 626f 756e 6473 5b31 2c20 315d  mnt_bounds[1, 1]
-00003fb0: 0a0a 2020 2020 2020 2020 2320 446f 206e  ..        # Do n
-00003fc0: 6f74 2061 7070 6c79 2074 6865 2073 7075  ot apply the spu
-00003fd0: 7269 6f75 7320 646c 2061 6c6f 6e67 2061  rious dl along a
-00003fe0: 2064 696d 656e 7369 6f6e 2077 6865 7265   dimension where
-00003ff0: 2074 6865 2073 696d 756c 6174 696f 6e20   the simulation 
-00004000: 6973 2032 442e 0a20 2020 2020 2020 2023  is 2D..        #
-00004010: 2049 6e73 7465 6164 2c20 7765 206a 7573   Instead, we jus
-00004020: 7420 7365 7420 7468 6520 626f 756e 6461  t set the bounda
-00004030: 7269 6573 2073 7563 6820 7468 6174 2074  ries such that t
-00004040: 6865 2063 656c 6c20 7369 7a65 2061 6c6f  he cell size alo
-00004050: 6e67 2074 6865 207a 6572 6f20 6469 6d65  ng the zero dime
-00004060: 6e73 696f 6e20 6973 2031 2c0a 2020 2020  nsion is 1,.    
-00004070: 2020 2020 2320 7375 6368 2074 6861 7420      # such that 
-00004080: 7175 616e 7469 7469 6573 206c 696b 6520  quantities like 
-00004090: 666c 7578 2077 696c 6c20 636f 6d65 206f  flux will come o
-000040a0: 7574 2069 6e20 756e 6974 7320 6f66 2057  ut in units of W
-000040b0: 202f 2075 6d2e 0a20 2020 2020 2020 2073   / um..        s
-000040c0: 697a 6573 5f64 696d 3020 3d20 636f 6f72  izes_dim0 = coor
-000040d0: 6473 5b30 5d5b 313a 5d20 2d20 636f 6f72  ds[0][1:] - coor
-000040e0: 6473 5b30 5d5b 3a2d 315d 2069 6620 626f  ds[0][:-1] if bo
-000040f0: 756e 6473 5b30 5d2e 7369 7a65 203e 2031  unds[0].size > 1
-00004100: 2065 6c73 6520 5b31 2e30 5d0a 2020 2020   else [1.0].    
-00004110: 2020 2020 7369 7a65 735f 6469 6d31 203d      sizes_dim1 =
-00004120: 2063 6f6f 7264 735b 315d 5b31 3a5d 202d   coords[1][1:] -
-00004130: 2063 6f6f 7264 735b 315d 5b3a 2d31 5d20   coords[1][:-1] 
-00004140: 6966 2062 6f75 6e64 735b 315d 2e73 697a  if bounds[1].siz
-00004150: 6520 3e20 3120 656c 7365 205b 312e 305d  e > 1 else [1.0]
-00004160: 0a0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-00004170: 2078 722e 4461 7461 4172 7261 7928 6e70   xr.DataArray(np
-00004180: 2e6f 7574 6572 2873 697a 6573 5f64 696d  .outer(sizes_dim
-00004190: 302c 2073 697a 6573 5f64 696d 3129 2c20  0, sizes_dim1), 
-000041a0: 6469 6d73 3d73 656c 662e 5f74 616e 6765  dims=self._tange
-000041b0: 6e74 6961 6c5f 6469 6d73 290a 0a20 2020  ntial_dims)..   
-000041c0: 2064 6566 205f 7461 6e67 656e 7469 616c   def _tangential
-000041d0: 5f63 6f72 7265 6374 6564 2873 656c 662c  _corrected(self,
-000041e0: 2066 6965 6c64 733a 2044 6963 745b 7374   fields: Dict[st
-000041f0: 722c 2044 6174 6141 7272 6179 5d29 202d  r, DataArray]) -
-00004200: 3e20 4469 6374 5b73 7472 2c20 4461 7461  > Dict[str, Data
-00004210: 4172 7261 795d 3a0a 2020 2020 2020 2020  Array]:.        
-00004220: 2222 2246 6f72 2061 2032 4420 6d6f 6e69  """For a 2D moni
-00004230: 746f 7220 6461 7461 2c20 6578 7472 6163  tor data, extrac
-00004240: 7420 7468 6520 7461 6e67 656e 7469 616c  t the tangential
-00004250: 2063 6f6d 706f 6e65 6e74 7320 6672 6f6d   components from
-00004260: 2066 6965 6c64 7320 616e 6420 6f72 6965   fields and orie
-00004270: 6e74 2074 6865 6d0a 2020 2020 2020 2020  nt them.        
-00004280: 7375 6368 2074 6861 7420 7468 6520 7468  such that the th
-00004290: 6972 6420 636f 6d70 6f6e 656e 7420 776f  ird component wo
-000042a0: 756c 6420 6265 2074 6865 206e 6f72 6d61  uld be the norma
-000042b0: 6c20 6178 6973 2e20 5468 6973 206a 7573  l axis. This jus
-000042c0: 7420 6d65 616e 7320 7468 6174 2074 6865  t means that the
-000042d0: 2048 2066 6965 6c64 0a20 2020 2020 2020   H field.       
-000042e0: 2067 6574 7320 616e 2065 7874 7261 206d   gets an extra m
-000042f0: 696e 7573 2073 6967 6e20 6966 2074 6865  inus sign if the
-00004300: 206e 6f72 6d61 6c20 6178 6973 2069 7320   normal axis is 
-00004310: 6060 2279 2260 602e 2052 6169 7365 2069  ``"y"``. Raise i
-00004320: 6620 616e 7920 6f66 2074 6865 2074 616e  f any of the tan
-00004330: 6765 6e74 6961 6c0a 2020 2020 2020 2020  gential.        
-00004340: 6669 656c 6420 636f 6d70 6f6e 656e 7473  field components
-00004350: 2069 7320 6d69 7373 696e 672e 0a0a 2020   is missing...  
-00004360: 2020 2020 2020 5468 6520 6669 6e69 7465        The finite
-00004370: 2067 7269 6420 636f 7272 6563 7469 6f6e   grid correction
-00004380: 2069 7320 616c 736f 2061 7070 6c69 6564   is also applied
-00004390: 2c20 736f 2074 6865 2069 6e74 656e 6465  , so the intende
-000043a0: 6420 7573 6520 6f66 2074 6865 7365 2066  d use of these f
-000043b0: 6965 6c64 7320 6973 2069 6e0a 2020 2020  ields is in.    
-000043c0: 2020 2020 706f 796e 7469 6e67 2c20 666c      poynting, fl
-000043d0: 7578 2c20 616e 6420 646f 742d 6c69 6b65  ux, and dot-like
-000043e0: 206d 6574 686f 6473 2e20 5468 6520 6e6f   methods. The no
-000043f0: 726d 616c 2063 6f6f 7264 696e 6174 6520  rmal coordinate 
-00004400: 6973 2064 726f 7070 6564 2066 726f 6d20  is dropped from 
-00004410: 7468 6520 6669 656c 6420 6461 7461 2e0a  the field data..
-00004420: 2020 2020 2020 2020 2222 220a 0a20 2020          """..   
-00004430: 2020 2020 2069 6620 6c65 6e28 7365 6c66       if len(self
-00004440: 2e6d 6f6e 6974 6f72 2e7a 6572 6f5f 6469  .monitor.zero_di
-00004450: 6d73 2920 213d 2031 3a0a 2020 2020 2020  ms) != 1:.      
-00004460: 2020 2020 2020 7261 6973 6520 4461 7461        raise Data
-00004470: 4572 726f 7228 2244 6174 6120 6d75 7374  Error("Data must
-00004480: 2062 6520 3244 2074 6f20 6765 7420 7461   be 2D to get ta
-00004490: 6e67 656e 7469 616c 2066 6965 6c64 732e  ngential fields.
-000044a0: 2229 0a0a 2020 2020 2020 2020 2320 5461  ")..        # Ta
-000044b0: 6e67 656e 7469 616c 2066 6965 6c64 2063  ngential field c
-000044c0: 6f6d 706f 6e65 6e74 730a 2020 2020 2020  omponents.      
-000044d0: 2020 7461 6e5f 6469 6d73 203d 2073 656c    tan_dims = sel
-000044e0: 662e 5f74 616e 6765 6e74 6961 6c5f 6469  f._tangential_di
-000044f0: 6d73 0a20 2020 2020 2020 2063 6f6d 706f  ms.        compo
-00004500: 6e65 6e74 7320 3d20 5b66 6e61 6d65 202b  nents = [fname +
-00004510: 2064 696d 2066 6f72 2066 6e61 6d65 2069   dim for fname i
-00004520: 6e20 2245 4822 2066 6f72 2064 696d 2069  n "EH" for dim i
-00004530: 6e20 7461 6e5f 6469 6d73 5d0a 0a20 2020  n tan_dims]..   
-00004540: 2020 2020 206e 6f72 6d61 6c5f 6469 6d20       normal_dim 
-00004550: 3d20 2278 797a 225b 7365 6c66 2e6d 6f6e  = "xyz"[self.mon
-00004560: 6974 6f72 2e73 697a 652e 696e 6465 7828  itor.size.index(
-00004570: 3029 5d0a 0a20 2020 2020 2020 2074 616e  0)]..        tan
-00004580: 5f66 6965 6c64 7320 3d20 7b7d 0a20 2020  _fields = {}.   
-00004590: 2020 2020 2066 6f72 2063 6f6d 706f 6e65       for compone
-000045a0: 6e74 2069 6e20 636f 6d70 6f6e 656e 7473  nt in components
-000045b0: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
-000045c0: 2063 6f6d 706f 6e65 6e74 206e 6f74 2069   component not i
-000045d0: 6e20 6669 656c 6473 3a0a 2020 2020 2020  n fields:.      
-000045e0: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
-000045f0: 4461 7461 4572 726f 7228 6622 5461 6e67  DataError(f"Tang
-00004600: 656e 7469 616c 2066 6965 6c64 2063 6f6d  ential field com
-00004610: 706f 6e65 6e74 2027 7b63 6f6d 706f 6e65  ponent '{compone
-00004620: 6e74 7d27 206d 6973 7369 6e67 2069 6e20  nt}' missing in 
-00004630: 6669 656c 6420 6461 7461 2e22 290a 0a20  field data.").. 
-00004640: 2020 2020 2020 2020 2020 2063 6f72 7265             corre
-00004650: 6374 696f 6e20 3d20 310a 0a20 2020 2020  ction = 1..     
-00004660: 2020 2020 2020 2023 2073 6967 6e20 636f         # sign co
-00004670: 7272 6563 7469 6f6e 2074 6f20 480a 2020  rrection to H.  
-00004680: 2020 2020 2020 2020 2020 6966 206e 6f72            if nor
-00004690: 6d61 6c5f 6469 6d20 3d3d 2022 7922 2061  mal_dim == "y" a
-000046a0: 6e64 2063 6f6d 706f 6e65 6e74 5b30 5d20  nd component[0] 
-000046b0: 3d3d 2022 4822 3a0a 2020 2020 2020 2020  == "H":.        
-000046c0: 2020 2020 2020 2020 636f 7272 6563 7469          correcti
-000046d0: 6f6e 202a 3d20 2d31 0a0a 2020 2020 2020  on *= -1..      
-000046e0: 2020 2020 2020 2320 6669 6e69 7465 2067        # finite g
-000046f0: 7269 6420 636f 7272 6563 7469 6f6e 2074  rid correction t
-00004700: 6f20 616c 6c20 6669 656c 6473 0a20 2020  o all fields.   
-00004710: 2020 2020 2020 2020 2065 6967 5f76 616c           eig_val
-00004720: 203d 2073 656c 662e 7379 6d6d 6574 7279   = self.symmetry
-00004730: 5f65 6967 656e 7661 6c75 6573 5b63 6f6d  _eigenvalues[com
-00004740: 706f 6e65 6e74 5d28 6e6f 726d 616c 5f64  ponent](normal_d
-00004750: 696d 290a 2020 2020 2020 2020 2020 2020  im).            
-00004760: 6966 2065 6967 5f76 616c 203c 2030 3a0a  if eig_val < 0:.
-00004770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004780: 636f 7272 6563 7469 6f6e 202a 3d20 7365  correction *= se
-00004790: 6c66 2e67 7269 645f 6475 616c 5f63 6f72  lf.grid_dual_cor
-000047a0: 7265 6374 696f 6e0a 2020 2020 2020 2020  rection.        
-000047b0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-000047c0: 2020 2020 2020 2020 2020 636f 7272 6563            correc
-000047d0: 7469 6f6e 202a 3d20 7365 6c66 2e67 7269  tion *= self.gri
-000047e0: 645f 7072 696d 616c 5f63 6f72 7265 6374  d_primal_correct
-000047f0: 696f 6e0a 0a20 2020 2020 2020 2020 2020  ion..           
-00004800: 2066 6965 6c64 5f73 7175 6565 7a65 6420   field_squeezed 
-00004810: 3d20 6669 656c 6473 5b63 6f6d 706f 6e65  = fields[compone
-00004820: 6e74 5d2e 7371 7565 657a 6528 6469 6d3d  nt].squeeze(dim=
-00004830: 6e6f 726d 616c 5f64 696d 2c20 6472 6f70  normal_dim, drop
-00004840: 3d54 7275 6529 0a20 2020 2020 2020 2020  =True).         
-00004850: 2020 2074 616e 5f66 6965 6c64 735b 636f     tan_fields[co
-00004860: 6d70 6f6e 656e 745d 203d 2066 6965 6c64  mponent] = field
-00004870: 5f73 7175 6565 7a65 6420 2a20 636f 7272  _squeezed * corr
-00004880: 6563 7469 6f6e 0a0a 2020 2020 2020 2020  ection..        
-00004890: 7265 7475 726e 2074 616e 5f66 6965 6c64  return tan_field
-000048a0: 730a 0a20 2020 2040 7072 6f70 6572 7479  s..    @property
-000048b0: 0a20 2020 2064 6566 205f 7461 6e67 656e  .    def _tangen
-000048c0: 7469 616c 5f66 6965 6c64 7328 7365 6c66  tial_fields(self
-000048d0: 2920 2d3e 2044 6963 745b 7374 722c 2044  ) -> Dict[str, D
-000048e0: 6174 6141 7272 6179 5d3a 0a20 2020 2020  ataArray]:.     
-000048f0: 2020 2022 2222 466f 7220 6120 3244 206d     """For a 2D m
-00004900: 6f6e 6974 6f72 2064 6174 612c 2067 6574  onitor data, get
-00004910: 2074 6865 2074 616e 6765 6e74 6961 6c20   the tangential 
-00004920: 4520 616e 6420 4820 6669 656c 6473 2069  E and H fields i
-00004930: 6e20 7468 6520 3244 2070 6c61 6e65 2067  n the 2D plane g
-00004940: 7269 642e 2020 4669 656c 6473 0a20 2020  rid.  Fields.   
-00004950: 2020 2020 2061 7265 206f 7269 656e 7465       are oriente
-00004960: 6420 7375 6368 2074 6861 7420 7468 6520  d such that the 
-00004970: 7468 6972 6420 636f 6d70 6f6e 656e 7420  third component 
-00004980: 776f 756c 6420 6265 2074 6865 206e 6f72  would be the nor
-00004990: 6d61 6c20 6178 6973 2e20 5468 6973 206a  mal axis. This j
-000049a0: 7573 7420 6d65 616e 7320 7468 6174 0a20  ust means that. 
-000049b0: 2020 2020 2020 2074 6865 2048 2066 6965         the H fie
-000049c0: 6c64 2067 6574 7320 616e 2065 7874 7261  ld gets an extra
-000049d0: 206d 696e 7573 2073 6967 6e20 6966 2074   minus sign if t
-000049e0: 6865 206e 6f72 6d61 6c20 6178 6973 2069  he normal axis i
-000049f0: 7320 6060 2279 2260 602e 0a0a 2020 2020  s ``"y"``...    
-00004a00: 2020 2020 4e6f 7465 0a20 2020 2020 2020      Note.       
-00004a10: 202d 2d2d 2d0a 2020 2020 2020 2020 2020   ----.          
-00004a20: 2020 5468 6520 6669 6e69 7465 2067 7269    The finite gri
-00004a30: 6420 636f 7272 6563 7469 6f6e 2066 6163  d correction fac
-00004a40: 746f 7273 2061 7265 2061 7070 6c69 6564  tors are applied
-00004a50: 2061 6e64 2073 796d 6d65 7472 7920 6973   and symmetry is
-00004a60: 2065 7870 616e 6465 642e 0a20 2020 2020   expanded..     
-00004a70: 2020 2022 2222 0a20 2020 2020 2020 2072     """.        r
-00004a80: 6574 7572 6e20 7365 6c66 2e5f 7461 6e67  eturn self._tang
-00004a90: 656e 7469 616c 5f63 6f72 7265 6374 6564  ential_corrected
-00004aa0: 2873 656c 662e 7379 6d6d 6574 7279 5f65  (self.symmetry_e
-00004ab0: 7870 616e 6465 642e 6669 656c 645f 636f  xpanded.field_co
-00004ac0: 6d70 6f6e 656e 7473 290a 0a20 2020 2040  mponents)..    @
-00004ad0: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
-00004ae0: 205f 636f 6c6f 6361 7465 645f 6669 656c   _colocated_fiel
-00004af0: 6473 2873 656c 6629 202d 3e20 4469 6374  ds(self) -> Dict
-00004b00: 5b73 7472 2c20 4461 7461 4172 7261 795d  [str, DataArray]
-00004b10: 3a0a 2020 2020 2020 2020 2222 2246 6f72  :.        """For
-00004b20: 2061 2032 4420 6d6f 6e69 746f 7220 6461   a 2D monitor da
-00004b30: 7461 2c20 6765 7420 616c 6c20 4520 616e  ta, get all E an
-00004b40: 6420 4820 6669 656c 6473 2063 6f6c 6f63  d H fields coloc
-00004b50: 6174 6564 2074 6f20 7468 6520 6365 6c6c  ated to the cell
-00004b60: 2062 6f75 6e64 6172 6965 7320 696e 2074   boundaries in t
-00004b70: 6865 2032 440a 2020 2020 2020 2020 706c  he 2D.        pl
-00004b80: 616e 6520 6772 6964 2c20 7769 7468 2073  ane grid, with s
-00004b90: 796d 6d65 7472 6965 7320 6578 7061 6e64  ymmetries expand
-00004ba0: 6564 2e0a 2020 2020 2020 2020 2222 220a  ed..        """.
-00004bb0: 0a20 2020 2020 2020 2066 6965 6c64 5f63  .        field_c
-00004bc0: 6f6d 706f 6e65 6e74 7320 3d20 7365 6c66  omponents = self
-00004bd0: 2e73 796d 6d65 7472 795f 6578 7061 6e64  .symmetry_expand
-00004be0: 6564 2e66 6965 6c64 5f63 6f6d 706f 6e65  ed.field_compone
-00004bf0: 6e74 730a 0a20 2020 2020 2020 2069 6620  nts..        if 
-00004c00: 7365 6c66 2e6d 6f6e 6974 6f72 2e63 6f6c  self.monitor.col
-00004c10: 6f63 6174 653a 0a20 2020 2020 2020 2020  ocate:.         
-00004c20: 2020 2072 6574 7572 6e20 6669 656c 645f     return field_
-00004c30: 636f 6d70 6f6e 656e 7473 0a0a 2020 2020  components..    
-00004c40: 2020 2020 2320 496e 7465 7270 6f6c 6174      # Interpolat
-00004c50: 6520 6669 656c 6420 636f 6d70 6f6e 656e  e field componen
-00004c60: 7473 2074 6f20 6365 6c6c 2062 6f75 6e64  ts to cell bound
-00004c70: 6172 6965 730a 2020 2020 2020 2020 696e  aries.        in
-00004c80: 7465 7270 5f64 6963 7420 3d20 7b22 6173  terp_dict = {"as
-00004c90: 7375 6d65 5f73 6f72 7465 6422 3a20 5472  sume_sorted": Tr
-00004ca0: 7565 7d0a 2020 2020 2020 2020 666f 7220  ue}.        for 
-00004cb0: 6469 6d2c 2062 6f75 6e64 7320 696e 207a  dim, bounds in z
-00004cc0: 6970 2873 656c 662e 5f74 616e 6765 6e74  ip(self._tangent
-00004cd0: 6961 6c5f 6469 6d73 2c20 7365 6c66 2e5f  ial_dims, self._
-00004ce0: 706c 616e 655f 6772 6964 5f62 6f75 6e64  plane_grid_bound
-00004cf0: 6172 6965 7329 3a0a 2020 2020 2020 2020  aries):.        
-00004d00: 2020 2020 6966 2062 6f75 6e64 732e 7369      if bounds.si
-00004d10: 7a65 203e 2031 3a0a 2020 2020 2020 2020  ze > 1:.        
-00004d20: 2020 2020 2020 2020 696e 7465 7270 5f64          interp_d
-00004d30: 6963 745b 6469 6d5d 203d 2062 6f75 6e64  ict[dim] = bound
-00004d40: 730a 0a20 2020 2020 2020 2063 6f6c 6f63  s..        coloc
-00004d50: 6174 6564 5f66 6965 6c64 7320 3d20 7b6b  ated_fields = {k
-00004d60: 6579 3a20 7661 6c2e 696e 7465 7270 282a  ey: val.interp(*
-00004d70: 2a69 6e74 6572 705f 6469 6374 2920 666f  *interp_dict) fo
-00004d80: 7220 6b65 792c 2076 616c 2069 6e20 6669  r key, val in fi
-00004d90: 656c 645f 636f 6d70 6f6e 656e 7473 2e69  eld_components.i
-00004da0: 7465 6d73 2829 7d0a 2020 2020 2020 2020  tems()}.        
-00004db0: 7265 7475 726e 2063 6f6c 6f63 6174 6564  return colocated
-00004dc0: 5f66 6965 6c64 730a 0a20 2020 2040 7072  _fields..    @pr
-00004dd0: 6f70 6572 7479 0a20 2020 2064 6566 205f  operty.    def _
-00004de0: 636f 6c6f 6361 7465 645f 7461 6e67 656e  colocated_tangen
-00004df0: 7469 616c 5f66 6965 6c64 7328 7365 6c66  tial_fields(self
-00004e00: 2920 2d3e 2044 6963 745b 7374 722c 2044  ) -> Dict[str, D
-00004e10: 6174 6141 7272 6179 5d3a 0a20 2020 2020  ataArray]:.     
-00004e20: 2020 2022 2222 466f 7220 6120 3244 206d     """For a 2D m
-00004e30: 6f6e 6974 6f72 2064 6174 612c 2067 6574  onitor data, get
-00004e40: 2074 6865 2074 616e 6765 6e74 6961 6c20   the tangential 
-00004e50: 4520 616e 6420 4820 6669 656c 6473 2063  E and H fields c
-00004e60: 6f6c 6f63 6174 6564 2074 6f20 7468 6520  olocated to the 
-00004e70: 6365 6c6c 2062 6f75 6e64 6172 6965 730a  cell boundaries.
-00004e80: 2020 2020 2020 2020 696e 2074 6865 2032          in the 2
-00004e90: 4420 706c 616e 6520 6772 6964 2e20 2046  D plane grid.  F
-00004ea0: 6965 6c64 7320 6172 6520 6f72 6965 6e74  ields are orient
-00004eb0: 6564 2073 7563 6820 7468 6174 2074 6865  ed such that the
-00004ec0: 2074 6869 7264 2063 6f6d 706f 6e65 6e74   third component
-00004ed0: 2077 6f75 6c64 2062 6520 7468 6520 6e6f   would be the no
-00004ee0: 726d 616c 0a20 2020 2020 2020 2061 7869  rmal.        axi
-00004ef0: 732e 2054 6869 7320 6a75 7374 206d 6561  s. This just mea
-00004f00: 6e73 2074 6861 7420 7468 6520 4820 6669  ns that the H fi
-00004f10: 656c 6420 6765 7473 2061 6e20 6578 7472  eld gets an extr
-00004f20: 6120 6d69 6e75 7320 7369 676e 2069 6620  a minus sign if 
-00004f30: 7468 6520 6e6f 726d 616c 2061 7869 7320  the normal axis 
-00004f40: 6973 0a20 2020 2020 2020 2060 6022 7922  is.        ``"y"
-00004f50: 6060 2e20 5261 6973 6520 6966 2061 6e79  ``. Raise if any
-00004f60: 206f 6620 7468 6520 7461 6e67 656e 7469   of the tangenti
-00004f70: 616c 2066 6965 6c64 2063 6f6d 706f 6e65  al field compone
-00004f80: 6e74 7320 6973 206d 6973 7369 6e67 2e0a  nts is missing..
-00004f90: 0a20 2020 2020 2020 204e 6f74 650a 2020  .        Note.  
-00004fa0: 2020 2020 2020 2d2d 2d2d 0a20 2020 2020        ----.     
-00004fb0: 2020 2020 2020 2054 6865 2066 696e 6974         The finit
-00004fc0: 6520 6772 6964 2063 6f72 7265 6374 696f  e grid correctio
-00004fd0: 6e20 6661 6374 6f72 7320 6172 6520 6170  n factors are ap
-00004fe0: 706c 6965 6420 616e 6420 7379 6d6d 6574  plied and symmet
-00004ff0: 7279 2069 7320 6578 7061 6e64 6564 2e0a  ry is expanded..
-00005000: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-00005010: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-00005020: 5f74 616e 6765 6e74 6961 6c5f 636f 7272  _tangential_corr
-00005030: 6563 7465 6428 7365 6c66 2e5f 636f 6c6f  ected(self._colo
-00005040: 6361 7465 645f 6669 656c 6473 290a 0a20  cated_fields).. 
-00005050: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
-00005060: 2064 6566 2067 7269 645f 636f 7272 6563   def grid_correc
-00005070: 7465 645f 636f 7079 2873 656c 6629 202d  ted_copy(self) -
-00005080: 3e20 456c 6563 7472 6f6d 6167 6e65 7469  > Electromagneti
-00005090: 6346 6965 6c64 4461 7461 3a0a 2020 2020  cFieldData:.    
-000050a0: 2020 2020 2222 2252 6574 7572 6e20 6120      """Return a 
-000050b0: 636f 7079 206f 6620 7365 6c66 2077 6974  copy of self wit
-000050c0: 6820 6772 6964 2063 6f72 7265 6374 696f  h grid correctio
-000050d0: 6e20 6661 6374 6f72 7320 6170 706c 6965  n factors applie
-000050e0: 6420 2869 6620 6e65 6365 7373 6172 7929  d (if necessary)
-000050f0: 2061 6e64 2073 796d 6d65 7472 790a 2020   and symmetry.  
-00005100: 2020 2020 2020 6578 7061 6e64 6564 2e22        expanded."
-00005110: 2222 0a20 2020 2020 2020 2066 6965 6c64  "".        field
-00005120: 5f64 6174 6120 3d20 7365 6c66 2e73 796d  _data = self.sym
-00005130: 6d65 7472 795f 6578 7061 6e64 6564 5f63  metry_expanded_c
-00005140: 6f70 790a 2020 2020 2020 2020 6966 206c  opy.        if l
-00005150: 656e 2873 656c 662e 6d6f 6e69 746f 722e  en(self.monitor.
-00005160: 7a65 726f 5f64 696d 7329 2021 3d20 313a  zero_dims) != 1:
-00005170: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00005180: 7572 6e20 6669 656c 645f 6461 7461 0a0a  urn field_data..
-00005190: 2020 2020 2020 2020 6e6f 726d 616c 5f64          normal_d
-000051a0: 696d 203d 2022 7879 7a22 5b73 656c 662e  im = "xyz"[self.
-000051b0: 6d6f 6e69 746f 722e 7a65 726f 5f64 696d  monitor.zero_dim
-000051c0: 735b 305d 5d0a 2020 2020 2020 2020 7570  s[0]].        up
-000051d0: 6461 7465 203d 207b 2267 7269 645f 7072  date = {"grid_pr
-000051e0: 696d 616c 5f63 6f72 7265 6374 696f 6e22  imal_correction"
-000051f0: 3a20 312e 302c 2022 6772 6964 5f64 7561  : 1.0, "grid_dua
-00005200: 6c5f 636f 7272 6563 7469 6f6e 223a 2031  l_correction": 1
-00005210: 2e30 7d0a 2020 2020 2020 2020 666f 7220  .0}.        for 
-00005220: 6669 656c 645f 6e61 6d65 2c20 6669 656c  field_name, fiel
-00005230: 6420 696e 2066 6965 6c64 5f64 6174 612e  d in field_data.
-00005240: 6669 656c 645f 636f 6d70 6f6e 656e 7473  field_components
-00005250: 2e69 7465 6d73 2829 3a0a 2020 2020 2020  .items():.      
-00005260: 2020 2020 2020 6569 675f 7661 6c20 3d20        eig_val = 
-00005270: 7365 6c66 2e73 796d 6d65 7472 795f 6569  self.symmetry_ei
-00005280: 6765 6e76 616c 7565 735b 6669 656c 645f  genvalues[field_
-00005290: 6e61 6d65 5d28 6e6f 726d 616c 5f64 696d  name](normal_dim
-000052a0: 290a 2020 2020 2020 2020 2020 2020 6966  ).            if
-000052b0: 2065 6967 5f76 616c 203c 2030 3a0a 2020   eig_val < 0:.  
-000052c0: 2020 2020 2020 2020 2020 2020 2020 7570                up
-000052d0: 6461 7465 5b66 6965 6c64 5f6e 616d 655d  date[field_name]
-000052e0: 203d 2066 6965 6c64 202a 2073 656c 662e   = field * self.
-000052f0: 6772 6964 5f64 7561 6c5f 636f 7272 6563  grid_dual_correc
-00005300: 7469 6f6e 0a20 2020 2020 2020 2020 2020  tion.           
-00005310: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-00005320: 2020 2020 2020 2075 7064 6174 655b 6669         update[fi
-00005330: 656c 645f 6e61 6d65 5d20 3d20 6669 656c  eld_name] = fiel
-00005340: 6420 2a20 7365 6c66 2e67 7269 645f 7072  d * self.grid_pr
-00005350: 696d 616c 5f63 6f72 7265 6374 696f 6e0a  imal_correction.
-00005360: 2020 2020 2020 2020 7265 7475 726e 2066          return f
-00005370: 6965 6c64 5f64 6174 612e 636f 7079 2875  ield_data.copy(u
-00005380: 7064 6174 653d 7570 6461 7465 290a 0a20  pdate=update).. 
-00005390: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
-000053a0: 2064 6566 2069 6e74 656e 7369 7479 2873   def intensity(s
-000053b0: 656c 6629 202d 3e20 5363 616c 6172 4669  elf) -> ScalarFi
-000053c0: 656c 6444 6174 6141 7272 6179 3a0a 2020  eldDataArray:.  
-000053d0: 2020 2020 2020 2222 2252 6574 7572 6e20        """Return 
-000053e0: 7468 6520 7375 6d20 6f66 2074 6865 2073  the sum of the s
-000053f0: 7175 6172 6564 2061 6273 6f6c 7574 6520  quared absolute 
-00005400: 656c 6563 7472 6963 2066 6965 6c64 2063  electric field c
-00005410: 6f6d 706f 6e65 6e74 732e 2222 220a 2020  omponents.""".  
-00005420: 2020 2020 2020 6e6f 726d 616c 5f64 696d        normal_dim
-00005430: 203d 2022 7879 7a22 5b73 656c 662e 6d6f   = "xyz"[self.mo
-00005440: 6e69 746f 722e 7369 7a65 2e69 6e64 6578  nitor.size.index
-00005450: 2830 295d 0a20 2020 2020 2020 2066 6965  (0)].        fie
-00005460: 6c64 7320 3d20 7365 6c66 2e5f 636f 6c6f  lds = self._colo
-00005470: 6361 7465 645f 6669 656c 6473 0a20 2020  cated_fields.   
-00005480: 2020 2020 2063 6f6d 706f 6e65 6e74 7320       components 
-00005490: 3d20 2822 4578 222c 2022 4579 222c 2022  = ("Ex", "Ey", "
-000054a0: 457a 2229 0a20 2020 2020 2020 2069 6620  Ez").        if 
-000054b0: 616e 7928 636d 7020 6e6f 7420 696e 2066  any(cmp not in f
-000054c0: 6965 6c64 7320 666f 7220 636d 7020 696e  ields for cmp in
-000054d0: 2063 6f6d 706f 6e65 6e74 7329 3a0a 2020   components):.  
-000054e0: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
-000054f0: 4b65 7945 7272 6f72 2822 4361 6e27 7420  KeyError("Can't 
-00005500: 636f 6d70 7574 6520 696e 7465 6e73 6974  compute intensit
-00005510: 792c 2061 6c6c 2045 2066 6965 6c64 2063  y, all E field c
-00005520: 6f6d 706f 6e65 6e74 7320 6d75 7374 2062  omponents must b
-00005530: 6520 7072 6573 656e 742e 2229 0a20 2020  e present.").   
-00005540: 2020 2020 2069 6e74 656e 7369 7479 203d       intensity =
-00005550: 2073 756d 2866 6965 6c64 735b 636d 705d   sum(fields[cmp]
-00005560: 2e61 6273 202a 2a20 3220 666f 7220 636d  .abs ** 2 for cm
-00005570: 7020 696e 2063 6f6d 706f 6e65 6e74 7329  p in components)
-00005580: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00005590: 696e 7465 6e73 6974 792e 7371 7565 657a  intensity.squeez
-000055a0: 6528 6469 6d3d 6e6f 726d 616c 5f64 696d  e(dim=normal_dim
-000055b0: 2c20 6472 6f70 3d54 7275 6529 0a0a 2020  , drop=True)..  
-000055c0: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
-000055d0: 6465 6620 706f 796e 7469 6e67 2873 656c  def poynting(sel
-000055e0: 6629 202d 3e20 5363 616c 6172 4669 656c  f) -> ScalarFiel
-000055f0: 6444 6174 6141 7272 6179 3a0a 2020 2020  dDataArray:.    
-00005600: 2020 2020 2222 2254 696d 652d 6176 6572      """Time-aver
-00005610: 6167 6564 2050 6f79 6e74 696e 6720 7665  aged Poynting ve
-00005620: 6374 6f72 2066 6f72 2066 7265 7175 656e  ctor for frequen
-00005630: 6379 2d64 6f6d 6169 6e20 6461 7461 2061  cy-domain data a
-00005640: 7373 6f63 6961 7465 6420 746f 2061 2032  ssociated to a 2
-00005650: 4420 6d6f 6e69 746f 722c 0a20 2020 2020  D monitor,.     
-00005660: 2020 2070 726f 6a65 6374 6564 2074 6f20     projected to 
-00005670: 7468 6520 6469 7265 6374 696f 6e20 6e6f  the direction no
-00005680: 726d 616c 2074 6f20 7468 6520 6d6f 6e69  rmal to the moni
-00005690: 746f 7220 706c 616e 652e 2222 220a 0a20  tor plane.""".. 
-000056a0: 2020 2020 2020 2023 2054 616e 6765 6e74         # Tangent
-000056b0: 6961 6c20 6669 656c 6473 2061 7265 206f  ial fields are o
-000056c0: 7264 6572 6564 2061 7320 4531 2c20 4532  rdered as E1, E2
-000056d0: 2c20 4831 2c20 4832 0a20 2020 2020 2020  , H1, H2.       
-000056e0: 2074 616e 5f66 6965 6c64 7320 3d20 7365   tan_fields = se
-000056f0: 6c66 2e5f 636f 6c6f 6361 7465 645f 7461  lf._colocated_ta
-00005700: 6e67 656e 7469 616c 5f66 6965 6c64 730a  ngential_fields.
-00005710: 2020 2020 2020 2020 6469 6d31 2c20 6469          dim1, di
-00005720: 6d32 203d 2073 656c 662e 5f74 616e 6765  m2 = self._tange
-00005730: 6e74 6961 6c5f 6469 6d73 0a0a 2020 2020  ntial_dims..    
-00005740: 2020 2020 655f 785f 685f 7374 6172 203d      e_x_h_star =
-00005750: 2074 616e 5f66 6965 6c64 735b 2245 2220   tan_fields["E" 
-00005760: 2b20 6469 6d31 5d20 2a20 7461 6e5f 6669  + dim1] * tan_fi
-00005770: 656c 6473 5b22 4822 202b 2064 696d 325d  elds["H" + dim2]
-00005780: 2e63 6f6e 6a28 290a 2020 2020 2020 2020  .conj().        
-00005790: 655f 785f 685f 7374 6172 202d 3d20 7461  e_x_h_star -= ta
-000057a0: 6e5f 6669 656c 6473 5b22 4522 202b 2064  n_fields["E" + d
-000057b0: 696d 325d 202a 2074 616e 5f66 6965 6c64  im2] * tan_field
-000057c0: 735b 2248 2220 2b20 6469 6d31 5d2e 636f  s["H" + dim1].co
-000057d0: 6e6a 2829 0a20 2020 2020 2020 2070 6f79  nj().        poy
-000057e0: 6e74 696e 6720 3d20 302e 3520 2a20 6e70  nting = 0.5 * np
-000057f0: 2e72 6561 6c28 655f 785f 685f 7374 6172  .real(e_x_h_star
-00005800: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
-00005810: 2070 6f79 6e74 696e 670a 0a20 2020 2064   poynting..    d
-00005820: 6566 2070 6163 6b61 6765 5f66 6c75 785f  ef package_flux_
-00005830: 7265 7375 6c74 7328 7365 6c66 2c20 666c  results(self, fl
-00005840: 7578 5f76 616c 7565 733a 2078 722e 4461  ux_values: xr.Da
-00005850: 7461 4172 7261 7929 202d 3e20 416e 793a  taArray) -> Any:
-00005860: 0a20 2020 2020 2020 2022 2222 486f 7720  .        """How 
-00005870: 746f 2070 6163 6b61 6765 2066 6c75 7822  to package flux"
-00005880: 2222 0a20 2020 2020 2020 2072 6574 7572  "".        retur
-00005890: 6e20 466c 7578 4461 7461 4172 7261 7928  n FluxDataArray(
-000058a0: 666c 7578 5f76 616c 7565 7329 0a0a 2020  flux_values)..  
-000058b0: 2020 4063 6163 6865 645f 7072 6f70 6572    @cached_proper
-000058c0: 7479 0a20 2020 2064 6566 2066 6c75 7828  ty.    def flux(
-000058d0: 7365 6c66 2920 2d3e 2046 6c75 7844 6174  self) -> FluxDat
-000058e0: 6141 7272 6179 3a0a 2020 2020 2020 2020  aArray:.        
-000058f0: 2222 2246 6c75 7820 666f 7220 6461 7461  """Flux for data
-00005900: 2063 6f72 7265 7370 6f6e 6469 6e67 2074   corresponding t
-00005910: 6f20 6120 3244 206d 6f6e 6974 6f72 2e22  o a 2D monitor."
-00005920: 2222 0a0a 2020 2020 2020 2020 2320 436f  ""..        # Co
-00005930: 6d70 7574 6520 666c 7578 2062 7920 696e  mpute flux by in
-00005940: 7465 6772 6174 696e 6720 506f 796e 7469  tegrating Poynti
-00005950: 6e67 2076 6563 746f 7220 696e 2d70 6c61  ng vector in-pla
-00005960: 6e65 0a20 2020 2020 2020 2064 5f61 7265  ne.        d_are
-00005970: 6120 3d20 7365 6c66 2e5f 6469 6666 5f61  a = self._diff_a
-00005980: 7265 610a 2020 2020 2020 2020 706f 796e  rea.        poyn
-00005990: 7469 6e67 203d 2073 656c 662e 706f 796e  ting = self.poyn
-000059a0: 7469 6e67 0a0a 2020 2020 2020 2020 666c  ting..        fl
-000059b0: 7578 5f76 616c 7565 7320 3d20 706f 796e  ux_values = poyn
-000059c0: 7469 6e67 202a 2064 5f61 7265 610a 2020  ting * d_area.  
-000059d0: 2020 2020 2020 666c 7578 5f76 616c 7565        flux_value
-000059e0: 7320 3d20 666c 7578 5f76 616c 7565 732e  s = flux_values.
-000059f0: 7375 6d28 6469 6d3d 645f 6172 6561 2e64  sum(dim=d_area.d
-00005a00: 696d 7329 0a0a 2020 2020 2020 2020 7265  ims)..        re
-00005a10: 7475 726e 2073 656c 662e 7061 636b 6167  turn self.packag
-00005a20: 655f 666c 7578 5f72 6573 756c 7473 2866  e_flux_results(f
-00005a30: 6c75 785f 7661 6c75 6573 290a 0a20 2020  lux_values)..   
-00005a40: 2040 6361 6368 6564 5f70 726f 7065 7274   @cached_propert
-00005a50: 790a 2020 2020 6465 6620 6d6f 6465 5f61  y.    def mode_a
-00005a60: 7265 6128 7365 6c66 2920 2d3e 2046 7265  rea(self) -> Fre
-00005a70: 714d 6f64 6544 6174 6141 7272 6179 3a0a  qModeDataArray:.
-00005a80: 2020 2020 2020 2020 7222 2222 4566 6665          r"""Effe
-00005a90: 6374 6976 6520 6d6f 6465 2061 7265 6120  ctive mode area 
-00005aa0: 636f 7272 6573 706f 6e64 696e 6720 746f  corresponding to
-00005ab0: 2061 2032 4420 6d6f 6e69 746f 722e 0a0a   a 2D monitor...
-00005ac0: 2020 2020 2020 2020 2e2e 206d 6174 683a          .. math:
-00005ad0: 0a0a 2020 2020 2020 2020 2020 205c 6672  ..           \fr
-00005ae0: 6163 7b5c 6c65 6674 285c 696e 7420 7c45  ac{\left(\int |E
-00005af0: 7c5e 3220 5c2c 207b 5c72 6d20 647d 535c  |^2 \, {\rm d}S\
-00005b00: 7269 6768 7429 5e32 7d7b 5c69 6e74 207c  right)^2}{\int |
-00005b10: 457c 5e34 205c 2c20 7b5c 726d 2064 7d53  E|^4 \, {\rm d}S
-00005b20: 7d0a 2020 2020 2020 2020 2222 220a 2020  }.        """.  
-00005b30: 2020 2020 2020 696e 7465 6e73 6974 7920        intensity 
-00005b40: 3d20 7365 6c66 2e69 6e74 656e 7369 7479  = self.intensity
-00005b50: 0a20 2020 2020 2020 2023 2069 6e74 6567  .        # integ
-00005b60: 7261 7465 206f 7665 7220 7468 6520 706c  rate over the pl
-00005b70: 616e 650a 2020 2020 2020 2020 645f 6172  ane.        d_ar
-00005b80: 6561 203d 2073 656c 662e 5f64 6966 665f  ea = self._diff_
-00005b90: 6172 6561 0a20 2020 2020 2020 206e 756d  area.        num
-00005ba0: 203d 2028 696e 7465 6e73 6974 7920 2a20   = (intensity * 
-00005bb0: 645f 6172 6561 292e 7375 6d28 6469 6d3d  d_area).sum(dim=
-00005bc0: 645f 6172 6561 2e64 696d 7329 202a 2a20  d_area.dims) ** 
-00005bd0: 320a 2020 2020 2020 2020 6465 6e20 3d20  2.        den = 
-00005be0: 2869 6e74 656e 7369 7479 2a2a 3220 2a20  (intensity**2 * 
-00005bf0: 645f 6172 6561 292e 7375 6d28 6469 6d3d  d_area).sum(dim=
-00005c00: 645f 6172 6561 2e64 696d 7329 0a0a 2020  d_area.dims)..  
-00005c10: 2020 2020 2020 6172 6561 203d 206e 756d        area = num
-00005c20: 202f 2064 656e 0a20 2020 2020 2020 2069   / den.        i
-00005c30: 6620 6861 7361 7474 7228 7365 6c66 2e6d  f hasattr(self.m
-00005c40: 6f6e 6974 6f72 2c20 226d 6f64 655f 7370  onitor, "mode_sp
-00005c50: 6563 2229 3a0a 2020 2020 2020 2020 2020  ec"):.          
-00005c60: 2020 6172 6561 202a 3d20 6e70 2e63 6f73    area *= np.cos
-00005c70: 2873 656c 662e 6d6f 6e69 746f 722e 6d6f  (self.monitor.mo
-00005c80: 6465 5f73 7065 632e 616e 676c 655f 7468  de_spec.angle_th
-00005c90: 6574 6129 0a0a 2020 2020 2020 2020 7265  eta)..        re
-00005ca0: 7475 726e 2046 7265 714d 6f64 6544 6174  turn FreqModeDat
-00005cb0: 6141 7272 6179 2861 7265 6129 0a0a 2020  aArray(area)..  
-00005cc0: 2020 6465 6620 646f 7428 0a20 2020 2020    def dot(.     
-00005cd0: 2020 2073 656c 662c 2066 6965 6c64 5f64     self, field_d
-00005ce0: 6174 613a 2055 6e69 6f6e 5b46 6965 6c64  ata: Union[Field
-00005cf0: 4461 7461 2c20 4d6f 6465 4461 7461 2c20  Data, ModeData, 
-00005d00: 4d6f 6465 536f 6c76 6572 4461 7461 5d2c  ModeSolverData],
-00005d10: 2063 6f6e 6a75 6761 7465 3a20 626f 6f6c   conjugate: bool
-00005d20: 203d 2054 7275 650a 2020 2020 2920 2d3e   = True.    ) ->
-00005d30: 204d 6f64 6541 6d70 7344 6174 6141 7272   ModeAmpsDataArr
-00005d40: 6179 3a0a 2020 2020 2020 2020 7222 2222  ay:.        r"""
-00005d50: 446f 7420 7072 6f64 7563 7420 286d 6f64  Dot product (mod
-00005d60: 616c 206f 7665 726c 6170 2920 7769 7468  al overlap) with
-00005d70: 2061 6e6f 7468 6572 203a 636c 6173 733a   another :class:
-00005d80: 602e 4669 656c 6444 6174 6160 206f 626a  `.FieldData` obj
-00005d90: 6563 742e 2042 6f74 6820 6461 7461 7365  ect. Both datase
-00005da0: 7473 2068 6176 650a 2020 2020 2020 2020  ts have.        
-00005db0: 746f 2062 6520 6672 6571 7565 6e63 792d  to be frequency-
-00005dc0: 646f 6d61 696e 2064 6174 6120 6173 736f  domain data asso
-00005dd0: 6369 6174 6564 2077 6974 6820 6120 3244  ciated with a 2D
-00005de0: 206d 6f6e 6974 6f72 2e20 416c 6f6e 6720   monitor. Along 
-00005df0: 7468 6520 7461 6e67 656e 7469 616c 2064  the tangential d
-00005e00: 6972 6563 7469 6f6e 732c 0a20 2020 2020  irections,.     
-00005e10: 2020 2074 6865 2064 6174 6173 6574 7320     the datasets 
-00005e20: 6861 7665 2074 6f20 6861 7665 2074 6865  have to have the
-00005e30: 2073 616d 6520 6469 7363 7265 7469 7a61   same discretiza
-00005e40: 7469 6f6e 2e20 416c 6f6e 6720 7468 6520  tion. Along the 
-00005e50: 6e6f 726d 616c 2064 6972 6563 7469 6f6e  normal direction
-00005e60: 2c20 7468 6520 6d6f 6e69 746f 720a 2020  , the monitor.  
-00005e70: 2020 2020 2020 706f 7369 7469 6f6e 206d        position m
-00005e80: 6179 2064 6966 6665 7220 616e 6420 6973  ay differ and is
-00005e90: 2069 676e 6f72 6564 2e20 4f74 6865 7220   ignored. Other 
-00005ea0: 636f 6f72 6469 6e61 7465 7320 2860 6066  coordinates (``f
-00005eb0: 7265 7175 656e 6379 6060 2c20 6060 6d6f  requency``, ``mo
-00005ec0: 6465 5f69 6e64 6578 6060 2920 6861 7665  de_index``) have
-00005ed0: 0a20 2020 2020 2020 2074 6f20 6265 2065  .        to be e
-00005ee0: 6974 6865 7220 6964 656e 7469 6361 6c20  ither identical 
-00005ef0: 6f72 2062 726f 6164 6361 7374 6162 6c65  or broadcastable
-00005f00: 2e20 4272 6f61 6463 6173 7469 6e67 2069  . Broadcasting i
-00005f10: 7320 616c 736f 2073 7570 706f 7274 6564  s also supported
-00005f20: 2069 6e20 7468 6520 6361 7365 2069 6e0a   in the case in.
-00005f30: 2020 2020 2020 2020 7768 6963 6820 7468          which th
-00005f40: 6520 6f74 6865 7220 6060 6669 656c 645f  e other ``field_
-00005f50: 6461 7461 6060 2068 6173 2061 2064 696d  data`` has a dim
-00005f60: 656e 7369 6f6e 206f 6620 7369 7a65 2031  ension of size 1
-00005f70: 2077 686f 7365 2063 6f6f 7264 696e 6174   whose coordinat
-00005f80: 6520 6973 206e 6f74 2069 6e20 7468 6520  e is not in the 
-00005f90: 6c69 7374 0a20 2020 2020 2020 206f 6620  list.        of 
-00005fa0: 636f 6f72 6469 6e61 7465 7320 696e 2074  coordinates in t
-00005fb0: 6865 2060 6073 656c 6660 6020 6461 7461  he ``self`` data
-00005fc0: 7365 7420 616c 6f6e 6720 7468 6520 636f  set along the co
-00005fd0: 7272 6573 706f 6e64 696e 6720 6469 6d65  rresponding dime
-00005fe0: 6e73 696f 6e2e 2049 6e20 7468 6174 2063  nsion. In that c
-00005ff0: 6173 652c 2074 6865 0a20 2020 2020 2020  ase, the.       
-00006000: 2063 6f6f 7264 696e 6174 6573 206f 6620   coordinates of 
-00006010: 7468 6520 6060 7365 6c66 6060 2064 6174  the ``self`` dat
-00006020: 6173 6574 2061 7265 2075 7365 6420 696e  aset are used in
-00006030: 2074 6865 206f 7574 7075 742e 0a0a 2020   the output...  
-00006040: 2020 2020 2020 5468 6520 646f 7420 7072        The dot pr
-00006050: 6f64 7563 7420 6973 2064 6566 696e 6564  oduct is defined
-00006060: 2061 733a 0a0a 2020 2020 2020 2020 2e2e   as:..        ..
-00006070: 206d 6174 683a 0a0a 2020 2020 2020 2020   math:..        
-00006080: 2020 205c 6672 6163 7b31 7d7b 347d 205c     \frac{1}{4} \
-00006090: 696e 7420 5c6c 6566 7428 2045 5f30 205c  int \left( E_0 \
-000060a0: 7469 6d65 7320 485f 315e 2a20 2b20 485f  times H_1^* + H_
-000060b0: 305e 2a20 5c74 696d 6573 2045 5f31 205c  0^* \times E_1 \
-000060c0: 2920 5c2c 207b 5c72 6d20 647d 530a 0a20  ) \, {\rm d}S.. 
-000060d0: 2020 2020 2020 2050 6172 616d 6574 6572         Parameter
-000060e0: 730a 2020 2020 2020 2020 2d2d 2d2d 2d2d  s.        ------
-000060f0: 2d2d 2d2d 0a20 2020 2020 2020 2066 6965  ----.        fie
-00006100: 6c64 5f64 6174 6120 3a20 3a63 6c61 7373  ld_data : :class
-00006110: 3a60 456c 6563 7472 6f6d 6167 6e65 7469  :`Electromagneti
-00006120: 6346 6965 6c64 4461 7461 600a 2020 2020  cFieldData`.    
-00006130: 2020 2020 2020 2020 4120 6461 7461 2069          A data i
-00006140: 6e73 7461 6e63 6520 746f 2063 6f6d 7075  nstance to compu
-00006150: 7465 2074 6865 2064 6f74 2070 726f 6475  te the dot produ
-00006160: 6374 2077 6974 682e 0a20 2020 2020 2020  ct with..       
-00006170: 2063 6f6e 6a75 6761 7465 203a 2062 6f6f   conjugate : boo
-00006180: 6c2c 206f 7074 696f 6e61 6c0a 2020 2020  l, optional.    
-00006190: 2020 2020 2020 2020 4966 2060 6054 7275          If ``Tru
-000061a0: 6560 6020 2864 6566 6175 6c74 292c 2074  e`` (default), t
-000061b0: 6865 2064 6f74 2070 726f 6475 6374 2069  he dot product i
-000061c0: 7320 6465 6669 6e65 6420 6173 2061 626f  s defined as abo
-000061d0: 7665 2e20 4966 2060 6046 616c 7365 6060  ve. If ``False``
-000061e0: 2c20 7468 6520 6465 6669 6e69 7469 6f6e  , the definition
-000061f0: 0a20 2020 2020 2020 2020 2020 2069 7320  .            is 
-00006200: 7369 6d69 6c61 722c 2062 7574 2077 6974  similar, but wit
-00006210: 686f 7574 2074 6865 2063 6f6d 706c 6578  hout the complex
-00006220: 2063 6f6e 6a75 6761 7469 6f6e 206f 6620   conjugation of 
-00006230: 7468 6520 2448 2420 6669 656c 6473 2e0a  the $H$ fields..
-00006240: 0a20 2020 2020 2020 204e 6f74 650a 2020  .        Note.  
-00006250: 2020 2020 2020 2d2d 2d2d 0a20 2020 2020        ----.     
-00006260: 2020 2020 2020 2054 6865 2064 6f74 2070         The dot p
-00006270: 726f 6475 6374 2077 6974 6820 616e 6420  roduct with and 
-00006280: 7769 7468 6f75 7420 636f 6e6a 7567 6174  without conjugat
-00006290: 696f 6e20 6973 2065 7175 6976 616c 656e  ion is equivalen
-000062a0: 7420 2875 7020 746f 2061 2070 6861 7365  t (up to a phase
-000062b0: 2920 666f 720a 2020 2020 2020 2020 2020  ) for.          
-000062c0: 2020 6d6f 6465 7320 696e 206c 6f73 736c    modes in lossl
-000062d0: 6573 7320 7761 7665 6775 6964 6573 2062  ess waveguides b
-000062e0: 7574 2064 6966 6665 7273 2066 6f72 206d  ut differs for m
-000062f0: 6f64 6573 2069 6e20 6c6f 7373 7920 6d61  odes in lossy ma
-00006300: 7465 7269 616c 732e 2049 6e20 7468 6174  terials. In that
-00006310: 2063 6173 652c 0a20 2020 2020 2020 2020   case,.         
-00006320: 2020 2074 6865 2063 6f6e 6a75 6761 7465     the conjugate
-00006330: 6420 646f 7420 7072 6f64 7563 7420 6361  d dot product ca
-00006340: 6e20 6265 2069 6e74 6572 7072 6574 6564  n be interpreted
-00006350: 2061 7320 7468 6520 6672 6163 7469 6f6e   as the fraction
-00006360: 206f 6620 7468 6520 706f 7765 7220 6f66   of the power of
-00006370: 2074 6865 2066 6972 7374 0a20 2020 2020   the first.     
-00006380: 2020 2020 2020 206d 6f64 6520 6361 7272         mode carr
-00006390: 6965 6420 6279 2074 6865 2073 6563 6f6e  ied by the secon
-000063a0: 642c 2062 7574 206d 6f64 6573 2061 7265  d, but modes are
-000063b0: 206e 6f74 206f 7274 686f 676f 6e61 6c20   not orthogonal 
-000063c0: 7769 7468 2072 6573 7065 6374 2074 6f20  with respect to 
-000063d0: 7468 6174 2070 726f 6475 6374 0a20 2020  that product.   
-000063e0: 2020 2020 2020 2020 2061 6e64 2074 6865           and the
-000063f0: 2073 756d 206f 6620 6361 7272 6965 6420   sum of carried 
-00006400: 706f 7765 7220 6672 6163 7469 6f6e 7320  power fractions 
-00006410: 6d61 7920 6265 2064 6966 6665 7265 6e74  may be different
-00006420: 2066 726f 6d20 7468 6520 746f 7461 6c20   from the total 
-00006430: 666c 7578 2e0a 2020 2020 2020 2020 2020  flux..          
-00006440: 2020 496e 2074 6865 206e 6f6e 2d63 6f6e    In the non-con
-00006450: 6a75 6761 7465 6420 6465 6669 6e69 7469  jugated definiti
-00006460: 6f6e 2c20 6d6f 6465 7320 6172 6520 6f72  on, modes are or
-00006470: 7468 6f67 6f6e 616c 2c20 6275 7420 7468  thogonal, but th
-00006480: 6520 696e 7465 7270 7265 7461 7469 6f6e  e interpretation
-00006490: 206f 6620 7468 650a 2020 2020 2020 2020   of the.        
-000064a0: 2020 2020 646f 7420 7072 6f64 7563 7420      dot product 
-000064b0: 706f 7765 7220 6361 7272 6965 6420 6279  power carried by
-000064c0: 2061 2067 6976 656e 206d 6f64 6520 6973   a given mode is
-000064d0: 206e 6f20 6c6f 6e67 6572 2076 616c 6964   no longer valid
-000064e0: 2e0a 2020 2020 2020 2020 2222 220a 0a20  ..        """.. 
-000064f0: 2020 2020 2020 2023 2054 616e 6765 6e74         # Tangent
-00006500: 6961 6c20 6669 656c 6473 2066 6f72 2063  ial fields for c
-00006510: 7572 7265 6e74 2061 6e64 206f 7468 6572  urrent and other
-00006520: 2066 6965 6c64 2064 6174 610a 2020 2020   field data.    
-00006530: 2020 2020 6669 656c 6473 5f73 656c 6620      fields_self 
-00006540: 3d20 7365 6c66 2e5f 636f 6c6f 6361 7465  = self._colocate
-00006550: 645f 7461 6e67 656e 7469 616c 5f66 6965  d_tangential_fie
-00006560: 6c64 730a 0a20 2020 2020 2020 2066 6965  lds..        fie
-00006570: 6c64 735f 6f74 6865 7220 3d20 6669 656c  lds_other = fiel
-00006580: 645f 6461 7461 2e5f 636f 6c6f 6361 7465  d_data._colocate
-00006590: 645f 7461 6e67 656e 7469 616c 5f66 6965  d_tangential_fie
-000065a0: 6c64 730a 2020 2020 2020 2020 6966 2063  lds.        if c
-000065b0: 6f6e 6a75 6761 7465 3a0a 2020 2020 2020  onjugate:.      
-000065c0: 2020 2020 2020 6669 656c 6473 5f73 656c        fields_sel
-000065d0: 6620 3d20 7b6b 6579 3a20 6669 656c 642e  f = {key: field.
-000065e0: 636f 6e6a 2829 2066 6f72 206b 6579 2c20  conj() for key, 
-000065f0: 6669 656c 6420 696e 2066 6965 6c64 735f  field in fields_
-00006600: 7365 6c66 2e69 7465 6d73 2829 7d0a 0a20  self.items()}.. 
-00006610: 2020 2020 2020 2023 2044 726f 7020 7369         # Drop si
-00006620: 7a65 2d31 2064 696d 656e 7369 6f6e 7320  ze-1 dimensions 
-00006630: 696e 2074 6865 206f 7468 6572 2064 6174  in the other dat
-00006640: 610a 2020 2020 2020 2020 6669 656c 6473  a.        fields
-00006650: 5f6f 7468 6572 203d 207b 6b65 793a 2066  _other = {key: f
-00006660: 6965 6c64 2e73 7175 6565 7a65 2864 726f  ield.squeeze(dro
-00006670: 703d 5472 7565 2920 666f 7220 6b65 792c  p=True) for key,
-00006680: 2066 6965 6c64 2069 6e20 6669 656c 6473   field in fields
-00006690: 5f6f 7468 6572 2e69 7465 6d73 2829 7d0a  _other.items()}.
-000066a0: 0a20 2020 2020 2020 2023 2043 726f 7373  .        # Cross
-000066b0: 2070 726f 6475 6374 7320 6f66 2066 6965   products of fie
-000066c0: 6c64 730a 2020 2020 2020 2020 6469 6d31  lds.        dim1
-000066d0: 2c20 6469 6d32 203d 2073 656c 662e 5f74  , dim2 = self._t
-000066e0: 616e 6765 6e74 6961 6c5f 6469 6d73 0a20  angential_dims. 
-000066f0: 2020 2020 2020 2065 5f73 656c 665f 785f         e_self_x_
-00006700: 685f 6f74 6865 7220 3d20 6669 656c 6473  h_other = fields
-00006710: 5f73 656c 665b 2245 2220 2b20 6469 6d31  _self["E" + dim1
-00006720: 5d20 2a20 6669 656c 6473 5f6f 7468 6572  ] * fields_other
-00006730: 5b22 4822 202b 2064 696d 325d 0a20 2020  ["H" + dim2].   
-00006740: 2020 2020 2065 5f73 656c 665f 785f 685f       e_self_x_h_
-00006750: 6f74 6865 7220 2d3d 2066 6965 6c64 735f  other -= fields_
-00006760: 7365 6c66 5b22 4522 202b 2064 696d 325d  self["E" + dim2]
-00006770: 202a 2066 6965 6c64 735f 6f74 6865 725b   * fields_other[
-00006780: 2248 2220 2b20 6469 6d31 5d0a 2020 2020  "H" + dim1].    
-00006790: 2020 2020 685f 7365 6c66 5f78 5f65 5f6f      h_self_x_e_o
-000067a0: 7468 6572 203d 2066 6965 6c64 735f 7365  ther = fields_se
-000067b0: 6c66 5b22 4822 202b 2064 696d 315d 202a  lf["H" + dim1] *
-000067c0: 2066 6965 6c64 735f 6f74 6865 725b 2245   fields_other["E
-000067d0: 2220 2b20 6469 6d32 5d0a 2020 2020 2020  " + dim2].      
-000067e0: 2020 685f 7365 6c66 5f78 5f65 5f6f 7468    h_self_x_e_oth
-000067f0: 6572 202d 3d20 6669 656c 6473 5f73 656c  er -= fields_sel
-00006800: 665b 2248 2220 2b20 6469 6d32 5d20 2a20  f["H" + dim2] * 
-00006810: 6669 656c 6473 5f6f 7468 6572 5b22 4522  fields_other["E"
-00006820: 202b 2064 696d 315d 0a0a 2020 2020 2020   + dim1]..      
-00006830: 2020 2320 496e 7465 6772 6174 6520 6f76    # Integrate ov
-00006840: 6572 2070 6c61 6e65 0a20 2020 2020 2020  er plane.       
-00006850: 2064 5f61 7265 6120 3d20 7365 6c66 2e5f   d_area = self._
-00006860: 6469 6666 5f61 7265 610a 2020 2020 2020  diff_area.      
-00006870: 2020 696e 7465 6772 616e 6420 3d20 2865    integrand = (e
-00006880: 5f73 656c 665f 785f 685f 6f74 6865 7220  _self_x_h_other 
-00006890: 2d20 685f 7365 6c66 5f78 5f65 5f6f 7468  - h_self_x_e_oth
-000068a0: 6572 2920 2a20 645f 6172 6561 0a20 2020  er) * d_area.   
-000068b0: 2020 2020 2072 6574 7572 6e20 4d6f 6465       return Mode
-000068c0: 416d 7073 4461 7461 4172 7261 7928 302e  AmpsDataArray(0.
-000068d0: 3235 202a 2069 6e74 6567 7261 6e64 2e73  25 * integrand.s
-000068e0: 756d 2864 696d 3d64 5f61 7265 612e 6469  um(dim=d_area.di
-000068f0: 6d73 2929 0a0a 2020 2020 6465 6620 5f69  ms))..    def _i
-00006900: 6e74 6572 706f 6c61 7465 645f 7461 6e67  nterpolated_tang
-00006910: 656e 7469 616c 5f66 6965 6c64 7328 7365  ential_fields(se
-00006920: 6c66 2c20 636f 6f72 6473 3a20 4172 7261  lf, coords: Arra
-00006930: 7946 6c6f 6174 3244 2920 2d3e 2044 6963  yFloat2D) -> Dic
-00006940: 745b 7374 722c 2044 6174 6141 7272 6179  t[str, DataArray
-00006950: 5d3a 0a20 2020 2020 2020 2022 2222 466f  ]:.        """Fo
-00006960: 7220 3244 206d 6f6e 6974 6f72 732c 2069  r 2D monitors, i
-00006970: 6e74 6572 706f 6c61 7465 2074 6869 7320  nterpolate this 
-00006980: 6669 656c 6473 2074 6f20 6769 7665 6e20  fields to given 
-00006990: 636f 6f72 6473 2069 6e20 7468 6520 7461  coords in the ta
-000069a0: 6e67 656e 7469 616c 2070 6c61 6e65 2e0a  ngential plane..
-000069b0: 0a20 2020 2020 2020 2050 6172 616d 6574  .        Paramet
-000069c0: 6572 730a 2020 2020 2020 2020 2d2d 2d2d  ers.        ----
-000069d0: 2d2d 2d2d 2d2d 0a20 2020 2020 2020 2063  ------.        c
-000069e0: 6f6f 7264 7320 3a20 4172 7261 7946 6c6f  oords : ArrayFlo
-000069f0: 6174 3244 0a20 2020 2020 2020 2020 2020  at2D.           
-00006a00: 2049 6e74 6572 706f 6c61 7469 6f6e 2063   Interpolation c
-00006a10: 6f6f 7264 7320 696e 2074 6865 206d 6f6e  oords in the mon
-00006a20: 6974 6f72 2773 2074 616e 6765 6e74 6961  itor's tangentia
-00006a30: 6c20 706c 616e 652e 0a0a 2020 2020 2020  l plane...      
-00006a40: 2020 5265 7475 726e 0a20 2020 2020 2020    Return.       
-00006a50: 202d 2d2d 2d2d 2d0a 2020 2020 2020 2020   ------.        
-00006a60: 2020 2020 4469 6374 696f 6e61 7279 2077      Dictionary w
-00006a70: 6974 6820 696e 7465 7270 6f6c 6174 6564  ith interpolated
-00006a80: 2066 6965 6c64 732e 0a20 2020 2020 2020   fields..       
-00006a90: 2022 2222 0a20 2020 2020 2020 2066 6965   """.        fie
-00006aa0: 6c64 7320 3d20 7365 6c66 2e5f 7461 6e67  lds = self._tang
-00006ab0: 656e 7469 616c 5f66 6965 6c64 730a 0a20  ential_fields.. 
-00006ac0: 2020 2020 2020 2069 6e74 6572 705f 6469         interp_di
-00006ad0: 6374 203d 207b 2261 7373 756d 655f 736f  ct = {"assume_so
-00006ae0: 7274 6564 223a 2054 7275 657d 0a20 2020  rted": True}.   
-00006af0: 2020 2020 2066 6f72 2064 696d 2c20 6365       for dim, ce
-00006b00: 6e74 7320 696e 207a 6970 2873 656c 662e  nts in zip(self.
-00006b10: 5f74 616e 6765 6e74 6961 6c5f 6469 6d73  _tangential_dims
-00006b20: 2c20 636f 6f72 6473 293a 0a20 2020 2020  , coords):.     
-00006b30: 2020 2020 2020 2069 6620 6365 6e74 732e         if cents.
-00006b40: 7369 7a65 203e 2030 3a0a 2020 2020 2020  size > 0:.      
-00006b50: 2020 2020 2020 2020 2020 696e 7465 7270            interp
-00006b60: 5f64 6963 745b 6469 6d5d 203d 2063 656e  _dict[dim] = cen
-00006b70: 7473 0a0a 2020 2020 2020 2020 6b77 6172  ts..        kwar
-00006b80: 6773 203d 207b 2262 6f75 6e64 735f 6572  gs = {"bounds_er
-00006b90: 726f 7222 3a20 4661 6c73 652c 2022 6669  ror": False, "fi
-00006ba0: 6c6c 5f76 616c 7565 223a 2030 2e30 7d0a  ll_value": 0.0}.
-00006bb0: 2020 2020 2020 2020 666f 7220 636f 6d70          for comp
-00006bc0: 6f6e 656e 742c 2066 6965 6c64 2069 6e20  onent, field in 
-00006bd0: 6669 656c 6473 2e69 7465 6d73 2829 3a0a  fields.items():.
-00006be0: 2020 2020 2020 2020 2020 2020 6669 656c              fiel
-00006bf0: 6473 5b63 6f6d 706f 6e65 6e74 5d20 3d20  ds[component] = 
-00006c00: 6669 656c 642e 696e 7465 7270 286b 7761  field.interp(kwa
-00006c10: 7267 733d 6b77 6172 6773 2c20 2a2a 696e  rgs=kwargs, **in
-00006c20: 7465 7270 5f64 6963 7429 0a0a 2020 2020  terp_dict)..    
-00006c30: 2020 2020 7265 7475 726e 2066 6965 6c64      return field
-00006c40: 730a 0a20 2020 2064 6566 206f 7574 6572  s..    def outer
-00006c50: 5f64 6f74 280a 2020 2020 2020 2020 7365  _dot(.        se
-00006c60: 6c66 2c20 6669 656c 645f 6461 7461 3a20  lf, field_data: 
-00006c70: 556e 696f 6e5b 4669 656c 6444 6174 612c  Union[FieldData,
-00006c80: 204d 6f64 6544 6174 615d 2c20 636f 6e6a   ModeData], conj
-00006c90: 7567 6174 653a 2062 6f6f 6c20 3d20 5472  ugate: bool = Tr
-00006ca0: 7565 0a20 2020 2029 202d 3e20 4d69 7865  ue.    ) -> Mixe
-00006cb0: 644d 6f64 6544 6174 6141 7272 6179 3a0a  dModeDataArray:.
-00006cc0: 2020 2020 2020 2020 7222 2222 446f 7420          r"""Dot 
-00006cd0: 7072 6f64 7563 7420 286d 6f64 616c 206f  product (modal o
-00006ce0: 7665 726c 6170 2920 7769 7468 2061 6e6f  verlap) with ano
-00006cf0: 7468 6572 203a 636c 6173 733a 602e 4669  ther :class:`.Fi
-00006d00: 656c 6444 6174 6160 206f 626a 6563 742e  eldData` object.
-00006d10: 0a0a 2020 2020 2020 2020 5468 6520 7461  ..        The ta
-00006d20: 6e67 656e 7469 616c 2066 6965 6c64 7320  ngential fields 
-00006d30: 6672 6f6d 2060 6066 6965 6c64 5f64 6174  from ``field_dat
-00006d40: 6160 6020 6172 6520 696e 7465 7270 6f6c  a`` are interpol
-00006d50: 6174 6564 2074 6f20 7468 6973 206f 626a  ated to this obj
-00006d60: 6563 7427 7320 6772 6964 2c20 736f 2074  ect's grid, so t
-00006d70: 6865 0a20 2020 2020 2020 2064 6174 6120  he.        data 
-00006d80: 6172 7261 7973 2064 6f6e 2774 206e 6565  arrays don't nee
-00006d90: 6420 746f 2068 6176 6520 7468 6520 7361  d to have the sa
-00006da0: 6d65 2064 6973 6372 6574 697a 6174 696f  me discretizatio
-00006db0: 6e2e 2020 5468 6520 6361 6c63 756c 6174  n.  The calculat
-00006dc0: 696f 6e20 6973 2070 6572 666f 726d 6564  ion is performed
-00006dd0: 2066 6f72 0a20 2020 2020 2020 2061 6c6c   for.        all
-00006de0: 2063 6f6d 6d6f 6e20 6672 6571 7565 6e63   common frequenc
-00006df0: 6965 7320 6265 7477 6565 6e20 6461 7461  ies between data
-00006e00: 2061 7272 6179 732e 2020 496e 2074 6865   arrays.  In the
-00006e10: 206f 7574 7075 742c 2060 606d 6f64 655f   output, ``mode_
-00006e20: 696e 6465 785f 3060 6020 616e 640a 2020  index_0`` and.  
-00006e30: 2020 2020 2020 6060 6d6f 6465 5f69 6e64        ``mode_ind
-00006e40: 6578 5f31 6060 2061 7265 2074 6865 206d  ex_1`` are the m
-00006e50: 6f64 6520 696e 6469 6365 7320 6672 6f6d  ode indices from
-00006e60: 2074 6869 7320 6f62 6a65 6374 2061 6e64   this object and
-00006e70: 2060 6066 6965 6c64 5f64 6174 6160 602c   ``field_data``,
-00006e80: 2072 6573 7065 6374 6976 656c 792c 2069   respectively, i
-00006e90: 660a 2020 2020 2020 2020 7468 6579 2061  f.        they a
-00006ea0: 7265 2069 6e73 7461 6e63 6573 206f 6620  re instances of 
-00006eb0: 6060 4d6f 6465 4461 7461 6060 2e0a 0a20  ``ModeData``... 
-00006ec0: 2020 2020 2020 2054 6865 2064 6f74 2070         The dot p
-00006ed0: 726f 6475 6374 2069 7320 6465 6669 6e65  roduct is define
-00006ee0: 6420 6173 3a0a 0a20 2020 2020 2020 202e  d as:..        .
-00006ef0: 2e20 6d61 7468 3a0a 0a20 2020 2020 2020  . math:..       
-00006f00: 2020 2020 5c66 7261 637b 317d 7b34 7d20      \frac{1}{4} 
-00006f10: 5c69 6e74 205c 6c65 6674 2820 455f 3020  \int \left( E_0 
-00006f20: 5c74 696d 6573 2048 5f31 5e2a 202b 2048  \times H_1^* + H
-00006f30: 5f30 5e2a 205c 7469 6d65 7320 455f 3120  _0^* \times E_1 
-00006f40: 5c29 205c 2c20 7b5c 726d 2064 7d53 0a0a  \) \, {\rm d}S..
-00006f50: 2020 2020 2020 2020 5061 7261 6d65 7465          Paramete
-00006f60: 7273 0a20 2020 2020 2020 202d 2d2d 2d2d  rs.        -----
-00006f70: 2d2d 2d2d 2d0a 2020 2020 2020 2020 6669  -----.        fi
-00006f80: 656c 645f 6461 7461 203a 203a 636c 6173  eld_data : :clas
-00006f90: 733a 6045 6c65 6374 726f 6d61 676e 6574  s:`Electromagnet
-00006fa0: 6963 4669 656c 6444 6174 6160 0a20 2020  icFieldData`.   
-00006fb0: 2020 2020 2020 2020 2041 2064 6174 6120           A data 
-00006fc0: 696e 7374 616e 6365 2074 6f20 636f 6d70  instance to comp
-00006fd0: 7574 6520 7468 6520 646f 7420 7072 6f64  ute the dot prod
-00006fe0: 7563 7420 7769 7468 2e0a 2020 2020 2020  uct with..      
-00006ff0: 2020 636f 6e6a 7567 6174 6520 3a20 626f    conjugate : bo
-00007000: 6f6c 203d 2054 7275 650a 2020 2020 2020  ol = True.      
-00007010: 2020 2020 2020 4966 2060 6054 7275 6560        If ``True`
-00007020: 6020 2864 6566 6175 6c74 292c 2074 6865  ` (default), the
-00007030: 2064 6f74 2070 726f 6475 6374 2069 7320   dot product is 
-00007040: 6465 6669 6e65 6420 6173 2061 626f 7665  defined as above
-00007050: 2e20 4966 2060 6046 616c 7365 6060 2c20  . If ``False``, 
-00007060: 7468 6520 6465 6669 6e69 7469 6f6e 0a20  the definition. 
-00007070: 2020 2020 2020 2020 2020 2069 7320 7369             is si
-00007080: 6d69 6c61 722c 2062 7574 2077 6974 686f  milar, but witho
-00007090: 7574 2074 6865 2063 6f6d 706c 6578 2063  ut the complex c
-000070a0: 6f6e 6a75 6761 7469 6f6e 206f 6620 7468  onjugation of th
-000070b0: 6520 2448 2420 6669 656c 6473 2e0a 0a20  e $H$ fields... 
-000070c0: 2020 2020 2020 2052 6574 7572 6e73 0a20         Returns. 
-000070d0: 2020 2020 2020 202d 2d2d 2d2d 2d2d 0a20         -------. 
-000070e0: 2020 2020 2020 203a 636c 6173 733a 6078         :class:`x
-000070f0: 6172 7261 792e 4461 7461 4172 7261 7960  array.DataArray`
-00007100: 0a20 2020 2020 2020 2020 2020 2044 6174  .            Dat
-00007110: 6120 6172 7261 7920 7769 7468 2074 6865  a array with the
-00007120: 2063 6f6d 706c 6578 2d76 616c 7565 6420   complex-valued 
-00007130: 6d6f 6461 6c20 6f76 6572 6c61 7073 2062  modal overlaps b
-00007140: 6574 7765 656e 2074 6865 2074 776f 206d  etween the two m
-00007150: 6f64 6520 6461 7461 2e0a 0a20 2020 2020  ode data...     
-00007160: 2020 2053 6565 2061 6c73 6f0a 2020 2020     See also.    
-00007170: 2020 2020 2d2d 2d2d 2d2d 2d2d 0a20 2020      --------.   
-00007180: 2020 2020 203a 6d65 6d62 6572 3a60 646f       :member:`do
-00007190: 7460 0a20 2020 2020 2020 2022 2222 0a0a  t`.        """..
-000071a0: 2020 2020 2020 2020 7461 6e5f 6469 6d73          tan_dims
-000071b0: 203d 2073 656c 662e 5f74 616e 6765 6e74   = self._tangent
-000071c0: 6961 6c5f 6469 6d73 0a0a 2020 2020 2020  ial_dims..      
-000071d0: 2020 6966 206e 6f74 2061 6c6c 2861 203d    if not all(a =
-000071e0: 3d20 6220 666f 7220 612c 2062 2069 6e20  = b for a, b in 
-000071f0: 7a69 7028 7461 6e5f 6469 6d73 2c20 6669  zip(tan_dims, fi
-00007200: 656c 645f 6461 7461 2e5f 7461 6e67 656e  eld_data._tangen
-00007210: 7469 616c 5f64 696d 7329 293a 0a20 2020  tial_dims)):.   
-00007220: 2020 2020 2020 2020 2072 6169 7365 2044           raise D
-00007230: 6174 6145 7272 6f72 2822 5461 6e67 656e  ataError("Tangen
-00007240: 7469 616c 2064 696d 656e 7369 6f6e 7320  tial dimensions 
-00007250: 6d75 7374 206d 6174 6368 2062 6574 7765  must match betwe
-00007260: 656e 2074 6865 2074 776f 206d 6f6e 6974  en the two monit
-00007270: 6f72 732e 2229 0a0a 2020 2020 2020 2020  ors.")..        
-00007280: 2320 5461 6e67 656e 7469 616c 2066 6965  # Tangential fie
-00007290: 6c64 7320 666f 7220 6375 7272 656e 740a  lds for current.
-000072a0: 2020 2020 2020 2020 6669 656c 6473 5f73          fields_s
-000072b0: 656c 6620 3d20 7365 6c66 2e5f 636f 6c6f  elf = self._colo
-000072c0: 6361 7465 645f 7461 6e67 656e 7469 616c  cated_tangential
-000072d0: 5f66 6965 6c64 730a 2020 2020 2020 2020  _fields.        
-000072e0: 6966 2063 6f6e 6a75 6761 7465 3a0a 2020  if conjugate:.  
-000072f0: 2020 2020 2020 2020 2020 6669 656c 6473            fields
-00007300: 5f73 656c 6620 3d20 7b63 6f6d 706f 6e65  _self = {compone
-00007310: 6e74 3a20 6669 656c 642e 636f 6e6a 2829  nt: field.conj()
-00007320: 2066 6f72 2063 6f6d 706f 6e65 6e74 2c20   for component, 
-00007330: 6669 656c 6420 696e 2066 6965 6c64 735f  field in fields_
-00007340: 7365 6c66 2e69 7465 6d73 2829 7d0a 0a20  self.items()}.. 
-00007350: 2020 2020 2020 2023 2054 616e 6765 6e74         # Tangent
-00007360: 6961 6c20 6669 656c 6473 2066 6f72 206f  ial fields for o
-00007370: 7468 6572 2064 6174 610a 0a20 2020 2020  ther data..     
-00007380: 2020 2066 6965 6c64 735f 6f74 6865 7220     fields_other 
-00007390: 3d20 6669 656c 645f 6461 7461 2e5f 696e  = field_data._in
-000073a0: 7465 7270 6f6c 6174 6564 5f74 616e 6765  terpolated_tange
-000073b0: 6e74 6961 6c5f 6669 656c 6473 2873 656c  ntial_fields(sel
-000073c0: 662e 5f70 6c61 6e65 5f67 7269 645f 626f  f._plane_grid_bo
-000073d0: 756e 6461 7269 6573 290a 0a20 2020 2020  undaries)..     
-000073e0: 2020 2023 2054 616e 6765 6e74 6961 6c20     # Tangential 
-000073f0: 6669 656c 6420 636f 6d70 6f6e 656e 7420  field component 
-00007400: 6e61 6d65 730a 2020 2020 2020 2020 6469  names.        di
-00007410: 6d31 2c20 6469 6d32 203d 2074 616e 5f64  m1, dim2 = tan_d
-00007420: 696d 730a 2020 2020 2020 2020 655f 3120  ims.        e_1 
-00007430: 3d20 2245 2220 2b20 6469 6d31 0a20 2020  = "E" + dim1.   
-00007440: 2020 2020 2065 5f32 203d 2022 4522 202b       e_2 = "E" +
-00007450: 2064 696d 320a 2020 2020 2020 2020 685f   dim2.        h_
-00007460: 3120 3d20 2248 2220 2b20 6469 6d31 0a20  1 = "H" + dim1. 
-00007470: 2020 2020 2020 2068 5f32 203d 2022 4822         h_2 = "H"
-00007480: 202b 2064 696d 320a 0a20 2020 2020 2020   + dim2..       
-00007490: 2023 2050 7265 7061 7265 2061 7272 6179   # Prepare array
-000074a0: 2077 6974 6820 7072 6f70 6572 2064 696d   with proper dim
-000074b0: 656e 7369 6f6e 7320 666f 7220 7468 6520  ensions for the 
-000074c0: 646f 7420 7072 6f64 7563 7420 6461 7461  dot product data
-000074d0: 0a20 2020 2020 2020 2061 7272 6179 7320  .        arrays 
-000074e0: 3d20 2866 6965 6c64 735f 7365 6c66 5b65  = (fields_self[e
-000074f0: 5f31 5d2c 2066 6965 6c64 735f 6f74 6865  _1], fields_othe
-00007500: 725b 655f 315d 290a 2020 2020 2020 2020  r[e_1]).        
-00007510: 636f 6f72 6473 203d 2028 6172 7261 7973  coords = (arrays
-00007520: 5b30 5d2e 636f 6f72 6473 2c20 6172 7261  [0].coords, arra
-00007530: 7973 5b31 5d2e 636f 6f72 6473 290a 0a20  ys[1].coords).. 
-00007540: 2020 2020 2020 2023 2043 6f6d 6d6f 6e20         # Common 
-00007550: 6672 6571 7565 6e63 6965 7320 746f 2062  frequencies to b
-00007560: 6f74 6820 6461 7461 2061 7272 6179 730a  oth data arrays.
-00007570: 2020 2020 2020 2020 6620 3d20 6e70 2e61          f = np.a
-00007580: 7272 6179 2873 6f72 7465 6428 7365 7428  rray(sorted(set(
-00007590: 636f 6f72 6473 5b30 5d5b 2266 225d 2e76  coords[0]["f"].v
-000075a0: 616c 7565 7329 2e69 6e74 6572 7365 6374  alues).intersect
-000075b0: 696f 6e28 636f 6f72 6473 5b31 5d5b 2266  ion(coords[1]["f
-000075c0: 225d 2e76 616c 7565 7329 2929 0a20 2020  "].values))).   
-000075d0: 2020 2020 2069 7365 6c31 203d 205b 6c69       isel1 = [li
-000075e0: 7374 2863 6f6f 7264 735b 305d 5b22 6622  st(coords[0]["f"
-000075f0: 5d2e 7661 6c75 6573 292e 696e 6465 7828  ].values).index(
-00007600: 6672 6571 2920 666f 7220 6672 6571 2069  freq) for freq i
-00007610: 6e20 665d 0a20 2020 2020 2020 2069 7365  n f].        ise
-00007620: 6c32 203d 205b 6c69 7374 2863 6f6f 7264  l2 = [list(coord
-00007630: 735b 315d 5b22 6622 5d2e 7661 6c75 6573  s[1]["f"].values
-00007640: 292e 696e 6465 7828 6672 6571 2920 666f  ).index(freq) fo
-00007650: 7220 6672 6571 2069 6e20 665d 0a0a 2020  r freq in f]..  
-00007660: 2020 2020 2020 2320 4d6f 6465 2069 6e64        # Mode ind
-00007670: 6963 6573 2c20 6966 2061 7661 696c 6162  ices, if availab
-00007680: 6c65 0a20 2020 2020 2020 206d 6f64 6573  le.        modes
-00007690: 5f69 6e5f 7365 6c66 203d 2022 6d6f 6465  _in_self = "mode
-000076a0: 5f69 6e64 6578 2220 696e 2063 6f6f 7264  _index" in coord
-000076b0: 735b 305d 0a20 2020 2020 2020 2063 6f6f  s[0].        coo
-000076c0: 7264 735b 305d 5b22 6d6f 6465 5f69 6e64  rds[0]["mode_ind
-000076d0: 6578 225d 2e76 616c 7565 7320 6966 206d  ex"].values if m
-000076e0: 6f64 6573 5f69 6e5f 7365 6c66 2065 6c73  odes_in_self els
-000076f0: 6520 6e70 2e7a 6572 6f73 2831 2c20 6474  e np.zeros(1, dt
-00007700: 7970 653d 696e 7429 0a20 2020 2020 2020  ype=int).       
-00007710: 206d 6f64 6573 5f69 6e5f 6f74 6865 7220   modes_in_other 
-00007720: 3d20 226d 6f64 655f 696e 6465 7822 2069  = "mode_index" i
-00007730: 6e20 636f 6f72 6473 5b31 5d0a 2020 2020  n coords[1].    
-00007740: 2020 2020 636f 6f72 6473 5b31 5d5b 226d      coords[1]["m
-00007750: 6f64 655f 696e 6465 7822 5d2e 7661 6c75  ode_index"].valu
-00007760: 6573 2069 6620 6d6f 6465 735f 696e 5f6f  es if modes_in_o
-00007770: 7468 6572 2065 6c73 6520 6e70 2e7a 6572  ther else np.zer
-00007780: 6f73 2831 2c20 6474 7970 653d 696e 7429  os(1, dtype=int)
-00007790: 0a0a 2020 2020 2020 2020 6b65 7973 203d  ..        keys =
-000077a0: 2028 655f 312c 2065 5f32 2c20 685f 312c   (e_1, e_2, h_1,
-000077b0: 2068 5f32 290a 2020 2020 2020 2020 666f   h_2).        fo
-000077c0: 7220 6b65 7920 696e 206b 6579 733a 0a20  r key in keys:. 
-000077d0: 2020 2020 2020 2020 2020 2066 6965 6c64             field
-000077e0: 735f 7365 6c66 5b6b 6579 5d20 3d20 6669  s_self[key] = fi
-000077f0: 656c 6473 5f73 656c 665b 6b65 795d 2e69  elds_self[key].i
-00007800: 7365 6c28 663d 6973 656c 3129 0a20 2020  sel(f=isel1).   
-00007810: 2020 2020 2020 2020 2069 6620 6d6f 6465           if mode
-00007820: 735f 696e 5f73 656c 663a 0a20 2020 2020  s_in_self:.     
-00007830: 2020 2020 2020 2020 2020 2066 6965 6c64             field
-00007840: 735f 7365 6c66 5b6b 6579 5d20 3d20 6669  s_self[key] = fi
-00007850: 656c 6473 5f73 656c 665b 6b65 795d 2e72  elds_self[key].r
-00007860: 656e 616d 6528 6d6f 6465 5f69 6e64 6578  ename(mode_index
-00007870: 3d22 6d6f 6465 5f69 6e64 6578 5f30 2229  ="mode_index_0")
-00007880: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
-00007890: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-000078a0: 2020 2066 6965 6c64 735f 7365 6c66 5b6b     fields_self[k
-000078b0: 6579 5d20 3d20 6669 656c 6473 5f73 656c  ey] = fields_sel
-000078c0: 665b 6b65 795d 2e65 7870 616e 645f 6469  f[key].expand_di
-000078d0: 6d73 280a 2020 2020 2020 2020 2020 2020  ms(.            
-000078e0: 2020 2020 2020 2020 6469 6d3d 7b22 6d6f          dim={"mo
-000078f0: 6465 5f69 6e64 6578 5f30 223a 205b 305d  de_index_0": [0]
-00007900: 7d2c 2061 7869 733d 6c65 6e28 6669 656c  }, axis=len(fiel
-00007910: 6473 5f73 656c 665b 6b65 795d 2e73 6861  ds_self[key].sha
-00007920: 7065 290a 2020 2020 2020 2020 2020 2020  pe).            
-00007930: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
-00007940: 2020 6669 656c 6473 5f6f 7468 6572 5b6b    fields_other[k
-00007950: 6579 5d20 3d20 6669 656c 6473 5f6f 7468  ey] = fields_oth
-00007960: 6572 5b6b 6579 5d2e 6973 656c 2866 3d69  er[key].isel(f=i
-00007970: 7365 6c32 290a 2020 2020 2020 2020 2020  sel2).          
-00007980: 2020 6966 206d 6f64 6573 5f69 6e5f 6f74    if modes_in_ot
-00007990: 6865 723a 0a20 2020 2020 2020 2020 2020  her:.           
-000079a0: 2020 2020 2066 6965 6c64 735f 6f74 6865       fields_othe
-000079b0: 725b 6b65 795d 203d 2066 6965 6c64 735f  r[key] = fields_
-000079c0: 6f74 6865 725b 6b65 795d 2e72 656e 616d  other[key].renam
-000079d0: 6528 6d6f 6465 5f69 6e64 6578 3d22 6d6f  e(mode_index="mo
-000079e0: 6465 5f69 6e64 6578 5f31 2229 0a20 2020  de_index_1").   
-000079f0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-00007a00: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-00007a10: 6965 6c64 735f 6f74 6865 725b 6b65 795d  ields_other[key]
-00007a20: 203d 2066 6965 6c64 735f 6f74 6865 725b   = fields_other[
-00007a30: 6b65 795d 2e65 7870 616e 645f 6469 6d73  key].expand_dims
-00007a40: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-00007a50: 2020 2020 2020 6469 6d3d 7b22 6d6f 6465        dim={"mode
-00007a60: 5f69 6e64 6578 5f31 223a 205b 305d 7d2c  _index_1": [0]},
-00007a70: 2061 7869 733d 6c65 6e28 6669 656c 6473   axis=len(fields
-00007a80: 5f6f 7468 6572 5b6b 6579 5d2e 7368 6170  _other[key].shap
-00007a90: 6529 0a20 2020 2020 2020 2020 2020 2020  e).             
-00007aa0: 2020 2029 0a0a 2020 2020 2020 2020 645f     )..        d_
-00007ab0: 6172 6561 203d 2073 656c 662e 5f64 6966  area = self._dif
-00007ac0: 665f 6172 6561 2e65 7870 616e 645f 6469  f_area.expand_di
-00007ad0: 6d73 2864 696d 3d7b 2266 223a 2066 7d2c  ms(dim={"f": f},
-00007ae0: 2061 7869 733d 3229 2e74 6f5f 6e75 6d70   axis=2).to_nump
-00007af0: 7928 290a 0a20 2020 2020 2020 2023 2066  y()..        # f
-00007b00: 756e 6374 696f 6e20 746f 2061 7070 6c79  unction to apply
-00007b10: 2061 7420 6561 6368 2070 6169 7220 6f66   at each pair of
-00007b20: 206d 6f64 6520 696e 6469 6365 7320 6265   mode indices be
-00007b30: 666f 7265 2069 6e74 6567 7261 7469 6e67  fore integrating
-00007b40: 0a20 2020 2020 2020 2064 6566 2066 6e28  .        def fn(
-00007b50: 6669 656c 6473 5f31 2c20 6669 656c 6473  fields_1, fields
-00007b60: 5f32 293a 0a20 2020 2020 2020 2020 2020  _2):.           
-00007b70: 2065 5f73 656c 665f 3120 3d20 6669 656c   e_self_1 = fiel
-00007b80: 6473 5f31 5b65 5f31 5d0a 2020 2020 2020  ds_1[e_1].      
-00007b90: 2020 2020 2020 655f 7365 6c66 5f32 203d        e_self_2 =
-00007ba0: 2066 6965 6c64 735f 315b 655f 325d 0a20   fields_1[e_2]. 
-00007bb0: 2020 2020 2020 2020 2020 2068 5f73 656c             h_sel
-00007bc0: 665f 3120 3d20 6669 656c 6473 5f31 5b68  f_1 = fields_1[h
-00007bd0: 5f31 5d0a 2020 2020 2020 2020 2020 2020  _1].            
-00007be0: 685f 7365 6c66 5f32 203d 2066 6965 6c64  h_self_2 = field
-00007bf0: 735f 315b 685f 325d 0a20 2020 2020 2020  s_1[h_2].       
-00007c00: 2020 2020 2065 5f6f 7468 6572 5f31 203d       e_other_1 =
-00007c10: 2066 6965 6c64 735f 325b 655f 315d 0a20   fields_2[e_1]. 
-00007c20: 2020 2020 2020 2020 2020 2065 5f6f 7468             e_oth
-00007c30: 6572 5f32 203d 2066 6965 6c64 735f 325b  er_2 = fields_2[
-00007c40: 655f 325d 0a20 2020 2020 2020 2020 2020  e_2].           
-00007c50: 2068 5f6f 7468 6572 5f31 203d 2066 6965   h_other_1 = fie
-00007c60: 6c64 735f 325b 685f 315d 0a20 2020 2020  lds_2[h_1].     
-00007c70: 2020 2020 2020 2068 5f6f 7468 6572 5f32         h_other_2
-00007c80: 203d 2066 6965 6c64 735f 325b 685f 325d   = fields_2[h_2]
-00007c90: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-00007ca0: 4372 6f73 7320 7072 6f64 7563 7473 206f  Cross products o
-00007cb0: 6620 6669 656c 6473 0a20 2020 2020 2020  f fields.       
-00007cc0: 2020 2020 2065 5f73 656c 665f 785f 685f       e_self_x_h_
-00007cd0: 6f74 6865 7220 3d20 655f 7365 6c66 5f31  other = e_self_1
-00007ce0: 202a 2068 5f6f 7468 6572 5f32 202d 2065   * h_other_2 - e
-00007cf0: 5f73 656c 665f 3220 2a20 685f 6f74 6865  _self_2 * h_othe
-00007d00: 725f 310a 2020 2020 2020 2020 2020 2020  r_1.            
-00007d10: 685f 7365 6c66 5f78 5f65 5f6f 7468 6572  h_self_x_e_other
-00007d20: 203d 2068 5f73 656c 665f 3120 2a20 655f   = h_self_1 * e_
-00007d30: 6f74 6865 725f 3220 2d20 685f 7365 6c66  other_2 - h_self
-00007d40: 5f32 202a 2065 5f6f 7468 6572 5f31 0a0a  _2 * e_other_1..
-00007d50: 2020 2020 2020 2020 2020 2020 7375 6d6d              summ
-00007d60: 616e 6420 3d20 302e 3235 202a 2028 655f  and = 0.25 * (e_
-00007d70: 7365 6c66 5f78 5f68 5f6f 7468 6572 202d  self_x_h_other -
-00007d80: 2068 5f73 656c 665f 785f 655f 6f74 6865   h_self_x_e_othe
-00007d90: 7229 202a 2064 5f61 7265 610a 2020 2020  r) * d_area.    
-00007da0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-00007db0: 756d 6d61 6e64 0a0a 2020 2020 2020 2020  ummand..        
-00007dc0: 7265 7375 6c74 203d 2073 656c 662e 5f6f  result = self._o
-00007dd0: 7574 6572 5f66 6e5f 7375 6d6d 6174 696f  uter_fn_summatio
-00007de0: 6e28 0a20 2020 2020 2020 2020 2020 2066  n(.            f
-00007df0: 6965 6c64 735f 313d 6669 656c 6473 5f73  ields_1=fields_s
-00007e00: 656c 662c 0a20 2020 2020 2020 2020 2020  elf,.           
-00007e10: 2066 6965 6c64 735f 323d 6669 656c 6473   fields_2=fields
-00007e20: 5f6f 7468 6572 2c0a 2020 2020 2020 2020  _other,.        
-00007e30: 2020 2020 6f75 7465 725f 6469 6d5f 313d      outer_dim_1=
-00007e40: 226d 6f64 655f 696e 6465 785f 3022 2c0a  "mode_index_0",.
-00007e50: 2020 2020 2020 2020 2020 2020 6f75 7465              oute
-00007e60: 725f 6469 6d5f 323d 226d 6f64 655f 696e  r_dim_2="mode_in
-00007e70: 6465 785f 3122 2c0a 2020 2020 2020 2020  dex_1",.        
-00007e80: 2020 2020 7375 6d5f 6469 6d73 3d74 616e      sum_dims=tan
-00007e90: 5f64 696d 732c 0a20 2020 2020 2020 2020  _dims,.         
-00007ea0: 2020 2066 6e3d 666e 2c0a 2020 2020 2020     fn=fn,.      
-00007eb0: 2020 290a 0a20 2020 2020 2020 2023 2052    )..        # R
-00007ec0: 656d 6f76 6520 6d6f 6465 2069 6e64 6578  emove mode index
-00007ed0: 2063 6f6f 7264 696e 6174 6520 6966 2074   coordinate if t
-00007ee0: 6865 2069 6e70 7574 2064 6964 206e 6f74  he input did not
-00007ef0: 2068 6176 6520 6974 0a20 2020 2020 2020   have it.       
-00007f00: 2069 6620 6e6f 7420 6d6f 6465 735f 696e   if not modes_in
-00007f10: 5f73 656c 663a 0a20 2020 2020 2020 2020  _self:.         
-00007f20: 2020 2072 6573 756c 7420 3d20 7265 7375     result = resu
-00007f30: 6c74 2e69 7365 6c28 6d6f 6465 5f69 6e64  lt.isel(mode_ind
-00007f40: 6578 5f30 3d30 2c20 6472 6f70 3d54 7275  ex_0=0, drop=Tru
-00007f50: 6529 0a20 2020 2020 2020 2069 6620 6e6f  e).        if no
-00007f60: 7420 6d6f 6465 735f 696e 5f6f 7468 6572  t modes_in_other
-00007f70: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-00007f80: 7375 6c74 203d 2072 6573 756c 742e 6973  sult = result.is
-00007f90: 656c 286d 6f64 655f 696e 6465 785f 313d  el(mode_index_1=
-00007fa0: 302c 2064 726f 703d 5472 7565 290a 0a20  0, drop=True).. 
-00007fb0: 2020 2020 2020 2072 6574 7572 6e20 7265         return re
-00007fc0: 7375 6c74 0a0a 2020 2020 4073 7461 7469  sult..    @stati
-00007fd0: 636d 6574 686f 640a 2020 2020 6465 6620  cmethod.    def 
-00007fe0: 5f6f 7574 6572 5f66 6e5f 7375 6d6d 6174  _outer_fn_summat
-00007ff0: 696f 6e28 0a20 2020 2020 2020 2066 6965  ion(.        fie
-00008000: 6c64 735f 313a 2044 6963 745b 7374 722c  lds_1: Dict[str,
-00008010: 2078 722e 4461 7461 4172 7261 795d 2c0a   xr.DataArray],.
-00008020: 2020 2020 2020 2020 6669 656c 6473 5f32          fields_2
-00008030: 3a20 4469 6374 5b73 7472 2c20 7872 2e44  : Dict[str, xr.D
-00008040: 6174 6141 7272 6179 5d2c 0a20 2020 2020  ataArray],.     
-00008050: 2020 206f 7574 6572 5f64 696d 5f31 3a20     outer_dim_1: 
-00008060: 7374 722c 0a20 2020 2020 2020 206f 7574  str,.        out
-00008070: 6572 5f64 696d 5f32 3a20 7374 722c 0a20  er_dim_2: str,. 
-00008080: 2020 2020 2020 2073 756d 5f64 696d 733a         sum_dims:
-00008090: 204c 6973 745b 7374 725d 2c0a 2020 2020   List[str],.    
-000080a0: 2020 2020 666e 3a20 4361 6c6c 6162 6c65      fn: Callable
-000080b0: 2c0a 2020 2020 2920 2d3e 2078 722e 4461  ,.    ) -> xr.Da
-000080c0: 7461 4172 7261 793a 0a20 2020 2020 2020  taArray:.       
-000080d0: 2022 2222 0a20 2020 2020 2020 204c 6f6f   """.        Loo
-000080e0: 7020 6f76 6572 2060 606f 7574 6572 5f64  p over ``outer_d
-000080f0: 696d 5f31 6060 2061 6e64 2060 606f 7574  im_1`` and ``out
-00008100: 6572 5f64 696d 5f32 6060 2c20 6170 706c  er_dim_2``, appl
-00008110: 7920 6060 666e 6060 2074 6f20 6060 6669  y ``fn`` to ``fi
-00008120: 656c 6473 5f31 6060 2061 6e64 2060 6066  elds_1`` and ``f
-00008130: 6965 6c64 735f 3260 602c 2061 6e64 2073  ields_2``, and s
-00008140: 756d 206f 7665 7220 6060 7375 6d5f 6469  um over ``sum_di
-00008150: 6d73 6060 2e0a 2020 2020 2020 2020 5468  ms``..        Th
-00008160: 6520 7265 7375 6c74 696e 6720 6060 7872  e resulting ``xr
-00008170: 2e44 6174 6141 7272 6179 6060 2068 6173  .DataArray`` has
-00008180: 2068 6173 2064 696d 656e 7369 6f6e 7320   has dimensions 
-00008190: 616e 7920 6469 6d65 6e73 696f 6e73 2069  any dimensions i
-000081a0: 6e20 7468 6520 6669 656c 6473 2077 6869  n the fields whi
-000081b0: 6368 2061 7265 206e 6f74 2063 6f6e 7461  ch are not conta
-000081c0: 696e 6564 2069 6e20 7375 6d5f 6469 6d73  ined in sum_dims
-000081d0: 2e0a 2020 2020 2020 2020 5468 6973 2063  ..        This c
-000081e0: 616e 2062 6520 6d6f 7265 206d 656d 6f72  an be more memor
-000081f0: 7920 6566 6669 6369 656e 7420 7468 616e  y efficient than
-00008200: 2076 6563 746f 7269 7a69 6e67 206f 7665   vectorizing ove
-00008210: 7220 7468 6520 6060 6f75 7465 725f 6469  r the ``outer_di
-00008220: 6d73 6060 2c20 7768 6963 6820 6361 6e20  ms``, which can 
-00008230: 696e 766f 6c76 6520 6272 6f61 6463 6173  involve broadcas
-00008240: 7469 6e67 2061 6e64 2072 6573 6861 7069  ting and reshapi
-00008250: 6e67 2064 6174 612e 0a20 2020 2020 2020  ng data..       
-00008260: 2049 7420 616c 736f 2063 6f6e 7665 7274   It also convert
-00008270: 7320 746f 206e 756d 7079 2061 7272 6179  s to numpy array
-00008280: 7320 6f75 7473 6964 6520 7468 6520 6c6f  s outside the lo
-00008290: 6f70 7320 746f 206d 696e 696d 697a 6520  ops to minimize 
-000082a0: 7861 7272 6179 206f 7665 7268 6561 642e  xarray overhead.
-000082b0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-000082c0: 2020 2020 2023 2066 6972 7374 2c20 636f       # first, co
-000082d0: 6e76 6572 7420 746f 206e 756d 7079 206f  nvert to numpy o
-000082e0: 7574 7369 6465 2074 6865 206c 6f6f 7020  utside the loop 
-000082f0: 746f 2072 6564 7563 6520 7861 7272 6179  to reduce xarray
-00008300: 206f 7665 7268 6561 640a 2020 2020 2020   overhead.      
-00008310: 2020 6669 656c 6473 5f31 5f6e 756d 7079    fields_1_numpy
-00008320: 203d 207b 6b65 793a 2076 616c 2e74 6f5f   = {key: val.to_
-00008330: 6e75 6d70 7928 2920 666f 7220 6b65 792c  numpy() for key,
-00008340: 2076 616c 2069 6e20 6669 656c 6473 5f31   val in fields_1
-00008350: 2e69 7465 6d73 2829 7d0a 2020 2020 2020  .items()}.      
-00008360: 2020 6669 656c 6473 5f32 5f6e 756d 7079    fields_2_numpy
-00008370: 203d 207b 6b65 793a 2076 616c 2e74 6f5f   = {key: val.to_
-00008380: 6e75 6d70 7928 2920 666f 7220 6b65 792c  numpy() for key,
-00008390: 2076 616c 2069 6e20 6669 656c 6473 5f32   val in fields_2
-000083a0: 2e69 7465 6d73 2829 7d0a 0a20 2020 2020  .items()}..     
-000083b0: 2020 2023 2067 6574 206f 6e65 206f 6620     # get one of 
-000083c0: 7468 6520 6461 7461 2061 7272 6179 7320  the data arrays 
-000083d0: 746f 206c 6f6f 6b20 6174 2066 6f72 2069  to look at for i
-000083e0: 6e64 6578 696e 670a 2020 2020 2020 2020  ndexing.        
-000083f0: 2320 6173 7375 6d69 6e67 2061 6c6c 2064  # assuming all d
-00008400: 6174 6120 6172 7261 7973 2068 6176 6520  ata arrays have 
-00008410: 7468 6520 7361 6d65 2073 7472 7563 7475  the same structu
-00008420: 7265 0a20 2020 2020 2020 2064 6174 615f  re.        data_
-00008430: 6172 7261 795f 7465 6d70 5f31 203d 206c  array_temp_1 = l
-00008440: 6973 7428 6669 656c 6473 5f31 2e76 616c  ist(fields_1.val
-00008450: 7565 7328 2929 5b30 5d0a 2020 2020 2020  ues())[0].      
-00008460: 2020 6461 7461 5f61 7272 6179 5f74 656d    data_array_tem
-00008470: 705f 3220 3d20 6c69 7374 2866 6965 6c64  p_2 = list(field
-00008480: 735f 322e 7661 6c75 6573 2829 295b 305d  s_2.values())[0]
-00008490: 0a20 2020 2020 2020 206e 756d 7079 5f74  .        numpy_t
-000084a0: 656d 705f 3120 3d20 6461 7461 5f61 7272  emp_1 = data_arr
-000084b0: 6179 5f74 656d 705f 312e 746f 5f6e 756d  ay_temp_1.to_num
-000084c0: 7079 2829 0a20 2020 2020 2020 206e 756d  py().        num
-000084d0: 7079 5f74 656d 705f 3220 3d20 6461 7461  py_temp_2 = data
-000084e0: 5f61 7272 6179 5f74 656d 705f 322e 746f  _array_temp_2.to
-000084f0: 5f6e 756d 7079 2829 0a0a 2020 2020 2020  _numpy()..      
-00008500: 2020 2320 6669 6e64 2074 6865 206e 756d    # find the num
-00008510: 7079 2061 7865 7320 6173 736f 6369 6174  py axes associat
-00008520: 6564 2077 6974 6820 7468 6520 7072 6f76  ed with the prov
-00008530: 6964 6564 2064 696d 656e 7369 6f6e 730a  ided dimensions.
-00008540: 2020 2020 2020 2020 6f75 7465 725f 6178          outer_ax
-00008550: 6973 5f31 203d 2064 6174 615f 6172 7261  is_1 = data_arra
-00008560: 795f 7465 6d70 5f31 2e67 6574 5f61 7869  y_temp_1.get_axi
-00008570: 735f 6e75 6d28 6f75 7465 725f 6469 6d5f  s_num(outer_dim_
-00008580: 3129 0a20 2020 2020 2020 206f 7574 6572  1).        outer
-00008590: 5f61 7869 735f 3220 3d20 6461 7461 5f61  _axis_2 = data_a
-000085a0: 7272 6179 5f74 656d 705f 322e 6765 745f  rray_temp_2.get_
-000085b0: 6178 6973 5f6e 756d 286f 7574 6572 5f64  axis_num(outer_d
-000085c0: 696d 5f32 290a 2020 2020 2020 2020 7375  im_2).        su
-000085d0: 6d5f 6178 6573 203d 205b 6461 7461 5f61  m_axes = [data_a
-000085e0: 7272 6179 5f74 656d 705f 312e 6765 745f  rray_temp_1.get_
-000085f0: 6178 6973 5f6e 756d 2864 696d 2920 666f  axis_num(dim) fo
-00008600: 7220 6469 6d20 696e 2073 756d 5f64 696d  r dim in sum_dim
-00008610: 735d 0a0a 2020 2020 2020 2020 2320 636f  s]..        # co
-00008620: 6f72 6473 2061 6e64 2061 7272 6179 2066  ords and array f
-00008630: 6f72 2072 6573 756c 7420 6f66 2063 616c  or result of cal
-00008640: 6375 6c61 7469 6f6e 0a20 2020 2020 2020  culation.       
-00008650: 2063 6f6f 7264 7320 3d20 7b6b 6579 3a20   coords = {key: 
-00008660: 7661 6c2e 746f 5f6e 756d 7079 2829 2066  val.to_numpy() f
-00008670: 6f72 206b 6579 2c20 7661 6c20 696e 2064  or key, val in d
-00008680: 6174 615f 6172 7261 795f 7465 6d70 5f31  ata_array_temp_1
-00008690: 2e63 6f6f 7264 732e 6974 656d 7328 297d  .coords.items()}
-000086a0: 0a20 2020 2020 2020 2066 6f72 2064 696d  .        for dim
-000086b0: 2069 6e20 7375 6d5f 6469 6d73 3a0a 2020   in sum_dims:.  
-000086c0: 2020 2020 2020 2020 2020 636f 6f72 6473            coords
-000086d0: 2e70 6f70 2864 696d 290a 2020 2020 2020  .pop(dim).      
-000086e0: 2020 2320 6c61 7374 2074 776f 2069 6e64    # last two ind
-000086f0: 7320 6172 6520 7468 6520 6f75 7465 725f  s are the outer_
-00008700: 6469 6d73 0a20 2020 2020 2020 2063 6f6f  dims.        coo
-00008710: 7264 732e 706f 7028 6f75 7465 725f 6469  rds.pop(outer_di
-00008720: 6d5f 3129 0a20 2020 2020 2020 2063 6f6f  m_1).        coo
-00008730: 7264 735b 6f75 7465 725f 6469 6d5f 315d  rds[outer_dim_1]
-00008740: 203d 2064 6174 615f 6172 7261 795f 7465   = data_array_te
-00008750: 6d70 5f31 2e63 6f6f 7264 735b 6f75 7465  mp_1.coords[oute
-00008760: 725f 6469 6d5f 315d 2e74 6f5f 6e75 6d70  r_dim_1].to_nump
-00008770: 7928 290a 2020 2020 2020 2020 636f 6f72  y().        coor
-00008780: 6473 5b6f 7574 6572 5f64 696d 5f32 5d20  ds[outer_dim_2] 
-00008790: 3d20 6461 7461 5f61 7272 6179 5f74 656d  = data_array_tem
-000087a0: 705f 322e 636f 6f72 6473 5b6f 7574 6572  p_2.coords[outer
-000087b0: 5f64 696d 5f32 5d2e 746f 5f6e 756d 7079  _dim_2].to_numpy
-000087c0: 2829 0a20 2020 2020 2020 2023 2064 726f  ().        # dro
-000087d0: 7020 7363 616c 6172 206e 6f6e 2d69 6e64  p scalar non-ind
-000087e0: 6578 696e 6720 6469 6d65 6e73 696f 6e73  exing dimensions
-000087f0: 0a20 2020 2020 2020 2063 6f6f 7264 7320  .        coords 
-00008800: 3d20 7b6b 6579 3a20 7661 6c20 666f 7220  = {key: val for 
-00008810: 6b65 792c 2076 616c 2069 6e20 636f 6f72  key, val in coor
-00008820: 6473 2e69 7465 6d73 2829 2069 6620 6c65  ds.items() if le
-00008830: 6e28 7661 6c2e 7368 6170 6529 2021 3d20  n(val.shape) != 
-00008840: 307d 0a20 2020 2020 2020 2073 6861 7065  0}.        shape
-00008850: 203d 205b 6c65 6e28 7661 6c29 2066 6f72   = [len(val) for
-00008860: 2076 616c 2069 6e20 636f 6f72 6473 2e76   val in coords.v
-00008870: 616c 7565 7328 295d 0a20 2020 2020 2020  alues()].       
-00008880: 2064 7479 7065 203d 206e 702e 7072 6f6d   dtype = np.prom
-00008890: 6f74 655f 7479 7065 7328 6e75 6d70 795f  ote_types(numpy_
-000088a0: 7465 6d70 5f31 2e64 7479 7065 2c20 6e75  temp_1.dtype, nu
-000088b0: 6d70 795f 7465 6d70 5f32 2e64 7479 7065  mpy_temp_2.dtype
-000088c0: 290a 2020 2020 2020 2020 6461 7461 203d  ).        data =
-000088d0: 206e 702e 7a65 726f 7328 7368 6170 652c   np.zeros(shape,
-000088e0: 2064 7479 7065 3d64 7479 7065 290a 0a20   dtype=dtype).. 
-000088f0: 2020 2020 2020 2023 2069 6e64 6578 696e         # indexin
-00008900: 6720 7475 706c 6573 0a20 2020 2020 2020  g tuples.       
-00008910: 2069 6478 5f31 203d 205b 736c 6963 6528   idx_1 = [slice(
-00008920: 4e6f 6e65 295d 202a 206e 756d 7079 5f74  None)] * numpy_t
-00008930: 656d 705f 312e 6e64 696d 0a20 2020 2020  emp_1.ndim.     
-00008940: 2020 2069 6478 5f32 203d 205b 736c 6963     idx_2 = [slic
-00008950: 6528 4e6f 6e65 295d 202a 206e 756d 7079  e(None)] * numpy
-00008960: 5f74 656d 705f 322e 6e64 696d 0a20 2020  _temp_2.ndim.   
-00008970: 2020 2020 2069 6478 5f64 6174 6120 3d20       idx_data = 
-00008980: 5b73 6c69 6365 284e 6f6e 6529 5d20 2a20  [slice(None)] * 
-00008990: 6461 7461 2e6e 6469 6d0a 0a20 2020 2020  data.ndim..     
-000089a0: 2020 2023 2063 616c 6375 6c61 7465 2074     # calculate t
-000089b0: 6865 2073 756d 7320 6f66 2070 726f 6475  he sums of produ
-000089c0: 6374 730a 2020 2020 2020 2020 666f 7220  cts.        for 
-000089d0: 6f75 7465 725f 3120 696e 2072 616e 6765  outer_1 in range
-000089e0: 286e 756d 7079 5f74 656d 705f 312e 7368  (numpy_temp_1.sh
-000089f0: 6170 655b 6f75 7465 725f 6178 6973 5f31  ape[outer_axis_1
-00008a00: 5d29 3a0a 2020 2020 2020 2020 2020 2020  ]):.            
-00008a10: 666f 7220 6f75 7465 725f 3220 696e 2072  for outer_2 in r
-00008a20: 616e 6765 286e 756d 7079 5f74 656d 705f  ange(numpy_temp_
-00008a30: 322e 7368 6170 655b 6f75 7465 725f 6178  2.shape[outer_ax
-00008a40: 6973 5f32 5d29 3a0a 2020 2020 2020 2020  is_2]):.        
-00008a50: 2020 2020 2020 2020 6964 785f 315b 6f75          idx_1[ou
-00008a60: 7465 725f 6178 6973 5f31 5d20 3d20 6f75  ter_axis_1] = ou
-00008a70: 7465 725f 310a 2020 2020 2020 2020 2020  ter_1.          
-00008a80: 2020 2020 2020 6964 785f 325b 6f75 7465        idx_2[oute
-00008a90: 725f 6178 6973 5f32 5d20 3d20 6f75 7465  r_axis_2] = oute
-00008aa0: 725f 320a 2020 2020 2020 2020 2020 2020  r_2.            
-00008ab0: 2020 2020 6964 785f 6461 7461 5b2d 325d      idx_data[-2]
-00008ac0: 203d 206f 7574 6572 5f31 0a20 2020 2020   = outer_1.     
-00008ad0: 2020 2020 2020 2020 2020 2069 6478 5f64             idx_d
-00008ae0: 6174 615b 2d31 5d20 3d20 6f75 7465 725f  ata[-1] = outer_
-00008af0: 320a 2020 2020 2020 2020 2020 2020 2020  2.              
-00008b00: 2020 6669 656c 6473 5f31 5f63 7572 7220    fields_1_curr 
-00008b10: 3d20 7b6b 6579 3a20 7661 6c5b 7475 706c  = {key: val[tupl
-00008b20: 6528 6964 785f 3129 5d20 666f 7220 6b65  e(idx_1)] for ke
-00008b30: 792c 2076 616c 2069 6e20 6669 656c 6473  y, val in fields
-00008b40: 5f31 5f6e 756d 7079 2e69 7465 6d73 2829  _1_numpy.items()
-00008b50: 7d0a 2020 2020 2020 2020 2020 2020 2020  }.              
-00008b60: 2020 6669 656c 6473 5f32 5f63 7572 7220    fields_2_curr 
-00008b70: 3d20 7b6b 6579 3a20 7661 6c5b 7475 706c  = {key: val[tupl
-00008b80: 6528 6964 785f 3229 5d20 666f 7220 6b65  e(idx_2)] for ke
-00008b90: 792c 2076 616c 2069 6e20 6669 656c 6473  y, val in fields
-00008ba0: 5f32 5f6e 756d 7079 2e69 7465 6d73 2829  _2_numpy.items()
-00008bb0: 7d0a 2020 2020 2020 2020 2020 2020 2020  }.              
-00008bc0: 2020 7375 6d6d 616e 645f 6375 7272 203d    summand_curr =
-00008bd0: 2066 6e28 6669 656c 6473 5f31 5f63 7572   fn(fields_1_cur
-00008be0: 722c 2066 6965 6c64 735f 325f 6375 7272  r, fields_2_curr
-00008bf0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00008c00: 2020 6461 7461 5f63 7572 7220 3d20 6e70    data_curr = np
-00008c10: 2e73 756d 2873 756d 6d61 6e64 5f63 7572  .sum(summand_cur
-00008c20: 722c 2061 7869 733d 7475 706c 6528 7375  r, axis=tuple(su
-00008c30: 6d5f 6178 6573 2929 0a20 2020 2020 2020  m_axes)).       
-00008c40: 2020 2020 2020 2020 2064 6174 615b 7475           data[tu
-00008c50: 706c 6528 6964 785f 6461 7461 295d 203d  ple(idx_data)] =
-00008c60: 2064 6174 615f 6375 7272 0a0a 2020 2020   data_curr..    
-00008c70: 2020 2020 7265 7475 726e 2078 722e 4461      return xr.Da
-00008c80: 7461 4172 7261 7928 6461 7461 2c20 636f  taArray(data, co
-00008c90: 6f72 6473 3d63 6f6f 7264 7329 0a0a 2020  ords=coords)..  
-00008ca0: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
-00008cb0: 6465 6620 7469 6d65 5f72 6576 6572 7365  def time_reverse
-00008cc0: 645f 636f 7079 2873 656c 6629 202d 3e20  d_copy(self) -> 
-00008cd0: 4669 656c 6444 6174 613a 0a20 2020 2020  FieldData:.     
-00008ce0: 2020 2022 2222 4d61 6b65 2061 2063 6f70     """Make a cop
-00008cf0: 7920 6f66 2074 6865 2064 6174 6120 7769  y of the data wi
-00008d00: 7468 2074 696d 652d 7265 7665 7273 6564  th time-reversed
-00008d10: 2066 6965 6c64 732e 2222 220a 0a20 2020   fields."""..   
-00008d20: 2020 2020 2023 2054 696d 6520 7265 7665       # Time reve
-00008d30: 7273 616c 2066 6f72 2066 7265 7175 656e  rsal for frequen
-00008d40: 6379 2d64 6f6d 6169 6e20 6669 656c 6473  cy-domain fields
-00008d50: 3b20 6f76 6572 7772 6974 7465 6e20 696e  ; overwritten in
-00008d60: 203a 636c 6173 733a 6046 6965 6c64 5469   :class:`FieldTi
-00008d70: 6d65 4461 7461 602c 0a20 2020 2020 2020  meData`,.       
-00008d80: 2023 203a 636c 6173 733a 604d 6f64 6544   # :class:`ModeD
-00008d90: 6174 6160 2c20 616e 6420 3a63 6c61 7373  ata`, and :class
-00008da0: 3a60 4d6f 6465 536f 6c76 6572 4461 7461  :`ModeSolverData
-00008db0: 602e 0a20 2020 2020 2020 206e 6577 5f64  `..        new_d
-00008dc0: 6174 6120 3d20 7b7d 0a20 2020 2020 2020  ata = {}.       
-00008dd0: 2066 6f72 2063 6f6d 702c 2066 6965 6c64   for comp, field
-00008de0: 2069 6e20 7365 6c66 2e66 6965 6c64 5f63   in self.field_c
-00008df0: 6f6d 706f 6e65 6e74 732e 6974 656d 7328  omponents.items(
-00008e00: 293a 0a20 2020 2020 2020 2020 2020 2069  ):.            i
-00008e10: 6620 636f 6d70 5b30 5d20 3d3d 2022 4822  f comp[0] == "H"
-00008e20: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00008e30: 2020 6e65 775f 6461 7461 5b63 6f6d 705d    new_data[comp]
-00008e40: 203d 202d 6e70 2e63 6f6e 6a28 6669 656c   = -np.conj(fiel
-00008e50: 6429 0a20 2020 2020 2020 2020 2020 2065  d).            e
-00008e60: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00008e70: 2020 2020 206e 6577 5f64 6174 615b 636f       new_data[co
-00008e80: 6d70 5d20 3d20 6e70 2e63 6f6e 6a28 6669  mp] = np.conj(fi
-00008e90: 656c 6429 0a20 2020 2020 2020 2072 6574  eld).        ret
-00008ea0: 7572 6e20 7365 6c66 2e63 6f70 7928 7570  urn self.copy(up
-00008eb0: 6461 7465 3d6e 6577 5f64 6174 6129 0a0a  date=new_data)..
-00008ec0: 0a63 6c61 7373 2046 6965 6c64 4461 7461  .class FieldData
-00008ed0: 2846 6965 6c64 4461 7461 7365 742c 2045  (FieldDataset, E
-00008ee0: 6c65 6374 726f 6d61 676e 6574 6963 4669  lectromagneticFi
-00008ef0: 656c 6444 6174 6129 3a0a 2020 2020 2222  eldData):.    ""
-00008f00: 220a 2020 2020 4461 7461 2061 7373 6f63  ".    Data assoc
-00008f10: 6961 7465 6420 7769 7468 2061 203a 636c  iated with a :cl
-00008f20: 6173 733a 602e 4669 656c 644d 6f6e 6974  ass:`.FieldMonit
-00008f30: 6f72 603a 2073 6361 6c61 7220 636f 6d70  or`: scalar comp
-00008f40: 6f6e 656e 7473 206f 6620 4520 616e 6420  onents of E and 
-00008f50: 4820 6669 656c 6473 2e0a 0a20 2020 204e  H fields...    N
-00008f60: 6f74 6573 0a20 2020 202d 2d2d 2d2d 0a0a  otes.    -----..
-00008f70: 2020 2020 2020 2020 5468 6520 6461 7461          The data
-00008f80: 2069 7320 7374 6f72 6564 2061 7320 6120   is stored as a 
-00008f90: 6044 6174 6141 7272 6179 203c 6874 7470  `DataArray <http
-00008fa0: 733a 2f2f 646f 6373 2e78 6172 7261 792e  s://docs.xarray.
-00008fb0: 6465 762f 656e 2f73 7461 626c 652f 6765  dev/en/stable/ge
-00008fc0: 6e65 7261 7465 642f 7861 7272 6179 2e44  nerated/xarray.D
-00008fd0: 6174 6141 7272 6179 2e68 746d 6c3e 605f  ataArray.html>`_
-00008fe0: 0a20 2020 2020 2020 206f 626a 6563 7420  .        object 
-00008ff0: 7573 696e 6720 7468 6520 6078 6172 7261  using the `xarra
-00009000: 7920 3c68 7474 7073 3a2f 2f64 6f63 732e  y <https://docs.
-00009010: 7861 7272 6179 2e64 6576 2f65 6e2f 7374  xarray.dev/en/st
-00009020: 6162 6c65 2f69 6e64 6578 2e68 746d 6c3e  able/index.html>
-00009030: 605f 2070 6163 6b61 6765 2e0a 0a20 2020  `_ package...   
-00009040: 2020 2020 2054 6869 7320 6461 7461 7365       This datase
-00009050: 7420 6361 6e20 636f 6e74 6169 6e20 616c  t can contain al
-00009060: 6c20 656c 6563 7472 6963 2061 6e64 206d  l electric and m
-00009070: 6167 6e65 7469 6320 6669 656c 6420 636f  agnetic field co
-00009080: 6d70 6f6e 656e 7473 3a20 6060 4578 6060  mponents: ``Ex``
-00009090: 2c20 6060 4579 6060 2c20 6060 457a 6060  , ``Ey``, ``Ez``
-000090a0: 2c20 6060 4878 6060 2c20 6060 4879 6060  , ``Hx``, ``Hy``
-000090b0: 2c0a 2020 2020 2020 2020 616e 6420 6060  ,.        and ``
-000090c0: 487a 6060 2e0a 0a20 2020 2045 7861 6d70  Hz``...    Examp
-000090d0: 6c65 0a20 2020 202d 2d2d 2d2d 2d2d 0a20  le.    -------. 
-000090e0: 2020 203e 3e3e 2066 726f 6d20 7469 6479     >>> from tidy
-000090f0: 3364 2069 6d70 6f72 7420 5363 616c 6172  3d import Scalar
-00009100: 4669 656c 6444 6174 6141 7272 6179 0a20  FieldDataArray. 
-00009110: 2020 203e 3e3e 2078 203d 205b 2d31 2c31     >>> x = [-1,1
-00009120: 2c33 5d0a 2020 2020 3e3e 3e20 7920 3d20  ,3].    >>> y = 
-00009130: 5b2d 322c 302c 322c 345d 0a20 2020 203e  [-2,0,2,4].    >
-00009140: 3e3e 207a 203d 205b 2d33 2c2d 312c 312c  >> z = [-3,-1,1,
-00009150: 332c 355d 0a20 2020 203e 3e3e 2066 203d  3,5].    >>> f =
-00009160: 205b 3265 3134 2c20 3365 3134 5d0a 2020   [2e14, 3e14].  
-00009170: 2020 3e3e 3e20 636f 6f72 6473 203d 2064    >>> coords = d
-00009180: 6963 7428 783d 785b 3a2d 315d 2c20 793d  ict(x=x[:-1], y=
-00009190: 795b 3a2d 315d 2c20 7a3d 7a5b 3a2d 315d  y[:-1], z=z[:-1]
-000091a0: 2c20 663d 6629 0a20 2020 203e 3e3e 2067  , f=f).    >>> g
-000091b0: 7269 6420 3d20 4772 6964 2862 6f75 6e64  rid = Grid(bound
-000091c0: 6172 6965 733d 436f 6f72 6473 2878 3d78  aries=Coords(x=x
-000091d0: 2c20 793d 792c 207a 3d7a 2929 0a20 2020  , y=y, z=z)).   
-000091e0: 203e 3e3e 2073 6361 6c61 725f 6669 656c   >>> scalar_fiel
-000091f0: 6420 3d20 5363 616c 6172 4669 656c 6444  d = ScalarFieldD
-00009200: 6174 6141 7272 6179 2828 312b 316a 2920  ataArray((1+1j) 
-00009210: 2a20 6e70 2e72 616e 646f 6d2e 7261 6e64  * np.random.rand
-00009220: 6f6d 2828 322c 332c 342c 3229 292c 2063  om((2,3,4,2)), c
-00009230: 6f6f 7264 733d 636f 6f72 6473 290a 2020  oords=coords).  
-00009240: 2020 3e3e 3e20 6d6f 6e69 746f 7220 3d20    >>> monitor = 
-00009250: 4669 656c 644d 6f6e 6974 6f72 280a 2020  FieldMonitor(.  
-00009260: 2020 2e2e 2e20 2020 2020 7369 7a65 3d28    ...     size=(
-00009270: 322c 342c 3629 2c20 6672 6571 733d 5b32  2,4,6), freqs=[2
-00009280: 6531 342c 2033 6531 345d 2c20 6e61 6d65  e14, 3e14], name
-00009290: 3d27 6669 656c 6427 2c20 6669 656c 6473  ='field', fields
-000092a0: 3d5b 2745 7827 2c20 2748 7a27 5d2c 2063  =['Ex', 'Hz'], c
-000092b0: 6f6c 6f63 6174 653d 5472 7565 0a20 2020  olocate=True.   
-000092c0: 202e 2e2e 2029 0a20 2020 203e 3e3e 2064   ... ).    >>> d
-000092d0: 6174 6120 3d20 4669 656c 6444 6174 6128  ata = FieldData(
-000092e0: 6d6f 6e69 746f 723d 6d6f 6e69 746f 722c  monitor=monitor,
-000092f0: 2045 783d 7363 616c 6172 5f66 6965 6c64   Ex=scalar_field
-00009300: 2c20 487a 3d73 6361 6c61 725f 6669 656c  , Hz=scalar_fiel
-00009310: 642c 2067 7269 645f 6578 7061 6e64 6564  d, grid_expanded
-00009320: 3d67 7269 6429 0a0a 2020 2020 2e2e 2054  =grid)..    .. T
-00009330: 4f44 4f20 736f 7274 206f 7574 2073 7461  ODO sort out sta
-00009340: 6e64 616c 6f6e 6520 6461 7461 2065 7861  ndalone data exa
-00009350: 6d70 6c65 2e0a 0a20 2020 2053 6565 2041  mple...    See A
-00009360: 6c73 6f0a 2020 2020 2d2d 2d2d 2d2d 2d2d  lso.    --------
-00009370: 0a0a 2020 2020 2a2a 4e6f 7465 626f 6f6b  ..    **Notebook
-00009380: 733a 2a2a 0a20 2020 2020 2020 202a 2060  s:**.        * `
-00009390: 5175 6963 6b73 7461 7274 203c 2e2e 2f2e  Quickstart <../.
-000093a0: 2e2f 6e6f 7465 626f 6f6b 732f 5374 6172  ./notebooks/Star
-000093b0: 7448 6572 652e 6874 6d6c 3e60 5f3a 2055  tHere.html>`_: U
-000093c0: 7361 6765 2069 6e20 6120 6261 7369 6320  sage in a basic 
-000093d0: 7369 6d75 6c61 7469 6f6e 2066 6c6f 772e  simulation flow.
-000093e0: 0a20 2020 2020 2020 202a 2060 5065 7266  .        * `Perf
-000093f0: 6f72 6d69 6e67 2076 6973 7561 6c69 7a61  orming visualiza
-00009400: 7469 6f6e 206f 6620 7369 6d75 6c61 7469  tion of simulati
-00009410: 6f6e 2064 6174 6120 3c2e 2e2f 2e2e 2f6e  on data <../../n
-00009420: 6f74 6562 6f6f 6b73 2f56 697a 4461 7461  otebooks/VizData
-00009430: 2e68 746d 6c3e 605f 0a20 2020 2020 2020  .html>`_.       
-00009440: 202a 2060 4164 7661 6e63 6564 206d 6f6e   * `Advanced mon
-00009450: 6974 6f72 2064 6174 6120 6d61 6e69 7075  itor data manipu
-00009460: 6c61 7469 6f6e 2061 6e64 2076 6973 7561  lation and visua
-00009470: 6c69 7a61 7469 6f6e 203c 2e2e 2f2e 2e2f  lization <../../
-00009480: 6e6f 7465 626f 6f6b 732f 5861 7272 6179  notebooks/Xarray
-00009490: 5475 746f 7269 616c 2e68 746d 6c3e 605f  Tutorial.html>`_
-000094a0: 0a20 2020 2022 2222 0a0a 2020 2020 6d6f  .    """..    mo
-000094b0: 6e69 746f 723a 2046 6965 6c64 4d6f 6e69  nitor: FieldMoni
-000094c0: 746f 7220 3d20 7064 2e46 6965 6c64 280a  tor = pd.Field(.
-000094d0: 2020 2020 2020 2020 2e2e 2e2c 2074 6974          ..., tit
-000094e0: 6c65 3d22 4d6f 6e69 746f 7222 2c20 6465  le="Monitor", de
-000094f0: 7363 7269 7074 696f 6e3d 2246 7265 7175  scription="Frequ
-00009500: 656e 6379 2d64 6f6d 6169 6e20 6669 656c  ency-domain fiel
-00009510: 6420 6d6f 6e69 746f 7220 6173 736f 6369  d monitor associ
-00009520: 6174 6564 2077 6974 6820 7468 6520 6461  ated with the da
-00009530: 7461 2e22 0a20 2020 2029 0a0a 2020 2020  ta.".    )..    
-00009540: 5f63 6f6e 7461 696e 735f 6d6f 6e69 746f  _contains_monito
-00009550: 725f 6669 656c 6473 203d 2065 6e66 6f72  r_fields = enfor
-00009560: 6365 5f6d 6f6e 6974 6f72 5f66 6965 6c64  ce_monitor_field
-00009570: 735f 7072 6573 656e 7428 290a 0a20 2020  s_present()..   
-00009580: 2064 6566 206e 6f72 6d61 6c69 7a65 2873   def normalize(s
-00009590: 656c 662c 2073 6f75 7263 655f 7370 6563  elf, source_spec
-000095a0: 7472 756d 5f66 6e3a 2043 616c 6c61 626c  trum_fn: Callabl
-000095b0: 655b 5b66 6c6f 6174 5d2c 2063 6f6d 706c  e[[float], compl
-000095c0: 6578 5d29 202d 3e20 4669 656c 6444 6174  ex]) -> FieldDat
-000095d0: 6173 6574 3a0a 2020 2020 2020 2020 2222  aset:.        ""
-000095e0: 2252 6574 7572 6e20 636f 7079 206f 6620  "Return copy of 
-000095f0: 7365 6c66 2061 6674 6572 206e 6f72 6d61  self after norma
-00009600: 6c69 7a61 7469 6f6e 2069 7320 6170 706c  lization is appl
-00009610: 6965 6420 7573 696e 6720 736f 7572 6365  ied using source
-00009620: 2073 7065 6374 7275 6d20 6675 6e63 7469   spectrum functi
-00009630: 6f6e 2e22 2222 0a20 2020 2020 2020 2066  on.""".        f
-00009640: 6965 6c64 735f 6e6f 726d 203d 207b 7d0a  ields_norm = {}.
-00009650: 2020 2020 2020 2020 666f 7220 6669 656c          for fiel
-00009660: 645f 6e61 6d65 2c20 6669 656c 645f 6461  d_name, field_da
-00009670: 7461 2069 6e20 7365 6c66 2e66 6965 6c64  ta in self.field
-00009680: 5f63 6f6d 706f 6e65 6e74 732e 6974 656d  _components.item
-00009690: 7328 293a 0a20 2020 2020 2020 2020 2020  s():.           
-000096a0: 2073 7263 5f61 6d70 7320 3d20 736f 7572   src_amps = sour
-000096b0: 6365 5f73 7065 6374 7275 6d5f 666e 2866  ce_spectrum_fn(f
-000096c0: 6965 6c64 5f64 6174 612e 6629 0a20 2020  ield_data.f).   
-000096d0: 2020 2020 2020 2020 2066 6965 6c64 735f           fields_
-000096e0: 6e6f 726d 5b66 6965 6c64 5f6e 616d 655d  norm[field_name]
-000096f0: 203d 2028 6669 656c 645f 6461 7461 202f   = (field_data /
-00009700: 2073 7263 5f61 6d70 7329 2e61 7374 7970   src_amps).astyp
-00009710: 6528 6669 656c 645f 6461 7461 2e64 7479  e(field_data.dty
-00009720: 7065 290a 0a20 2020 2020 2020 2072 6574  pe)..        ret
-00009730: 7572 6e20 7365 6c66 2e63 6f70 7928 7570  urn self.copy(up
-00009740: 6461 7465 3d66 6965 6c64 735f 6e6f 726d  date=fields_norm
-00009750: 290a 0a20 2020 2064 6566 2074 6f5f 736f  )..    def to_so
-00009760: 7572 6365 280a 2020 2020 2020 2020 7365  urce(.        se
-00009770: 6c66 2c20 736f 7572 6365 5f74 696d 653a  lf, source_time:
-00009780: 2053 6f75 7263 6554 696d 6554 7970 652c   SourceTimeType,
-00009790: 2063 656e 7465 723a 2043 6f6f 7264 696e   center: Coordin
-000097a0: 6174 652c 2073 697a 653a 2053 697a 6520  ate, size: Size 
-000097b0: 3d20 4e6f 6e65 2c20 2a2a 6b77 6172 6773  = None, **kwargs
-000097c0: 0a20 2020 2029 202d 3e20 4375 7374 6f6d  .    ) -> Custom
-000097d0: 4669 656c 6453 6f75 7263 653a 0a20 2020  FieldSource:.   
-000097e0: 2020 2020 2022 2222 4372 6561 7465 2061       """Create a
-000097f0: 203a 636c 6173 733a 602e 4375 7374 6f6d   :class:`.Custom
-00009800: 4669 656c 6453 6f75 7263 6560 2066 726f  FieldSource` fro
-00009810: 6d20 7468 6520 6669 656c 6473 2073 746f  m the fields sto
-00009820: 7265 6420 696e 2074 6865 203a 636c 6173  red in the :clas
-00009830: 733a 602e 4669 656c 6444 6174 6160 2e0a  s:`.FieldData`..
-00009840: 0a20 2020 2020 2020 2050 6172 616d 6574  .        Paramet
-00009850: 6572 730a 2020 2020 2020 2020 2d2d 2d2d  ers.        ----
-00009860: 2d2d 2d2d 2d2d 0a20 2020 2020 2020 2073  ------.        s
-00009870: 6f75 7263 655f 7469 6d65 3a20 3a63 6c61  ource_time: :cla
-00009880: 7373 3a60 2e53 6f75 7263 6554 696d 6560  ss:`.SourceTime`
-00009890: 0a20 2020 2020 2020 2020 2020 2053 7065  .            Spe
-000098a0: 6369 6669 6361 7469 6f6e 206f 6620 7468  cification of th
-000098b0: 6520 736f 7572 6365 2074 696d 652d 6465  e source time-de
-000098c0: 7065 6e64 656e 6365 2e0a 2020 2020 2020  pendence..      
-000098d0: 2020 6365 6e74 6572 3a20 5475 706c 655b    center: Tuple[
-000098e0: 666c 6f61 742c 2066 6c6f 6174 2c20 666c  float, float, fl
-000098f0: 6f61 745d 0a20 2020 2020 2020 2020 2020  oat].           
-00009900: 2053 6f75 7263 6520 6365 6e74 6572 2069   Source center i
-00009910: 6e20 782c 2079 2061 6e64 207a 2e0a 2020  n x, y and z..  
-00009920: 2020 2020 2020 7369 7a65 3a20 5475 706c        size: Tupl
-00009930: 655b 666c 6f61 742c 2066 6c6f 6174 2c20  e[float, float, 
-00009940: 666c 6f61 745d 0a20 2020 2020 2020 2020  float].         
-00009950: 2020 2053 6f75 7263 6520 7369 7a65 2069     Source size i
-00009960: 6e20 782c 2079 2c20 616e 6420 7a2e 2049  n x, y, and z. I
-00009970: 6620 6e6f 7420 7072 6f76 6964 6564 2c20  f not provided, 
-00009980: 7468 6520 7369 7a65 206f 6620 7468 6520  the size of the 
-00009990: 6d6f 6e69 746f 7220 6173 736f 6369 6174  monitor associat
-000099a0: 6564 2074 6f20 7468 650a 2020 2020 2020  ed to the.      
-000099b0: 2020 2020 2020 6461 7461 2069 7320 7573        data is us
-000099c0: 6564 2e0a 2020 2020 2020 2020 2a2a 6b77  ed..        **kw
-000099d0: 6172 6773 0a20 2020 2020 2020 2020 2020  args.           
-000099e0: 2045 7874 7261 206b 6579 776f 7264 2061   Extra keyword a
-000099f0: 7267 756d 656e 7473 2070 6173 7365 6420  rguments passed 
-00009a00: 746f 203a 636c 6173 733a 602e 4375 7374  to :class:`.Cust
-00009a10: 6f6d 4669 656c 6453 6f75 7263 6560 2e0a  omFieldSource`..
-00009a20: 0a20 2020 2020 2020 2052 6574 7572 6e73  .        Returns
-00009a30: 0a20 2020 2020 2020 202d 2d2d 2d2d 2d2d  .        -------
-00009a40: 0a20 2020 2020 2020 203a 636c 6173 733a  .        :class:
-00009a50: 602e 4375 7374 6f6d 4669 656c 6453 6f75  `.CustomFieldSou
-00009a60: 7263 6560 0a20 2020 2020 2020 2020 2020  rce`.           
-00009a70: 2053 6f75 7263 6520 696e 6a65 6374 696e   Source injectin
-00009a80: 6720 7468 6520 6669 656c 6473 2073 746f  g the fields sto
-00009a90: 7265 6420 696e 2074 6865 203a 636c 6173  red in the :clas
-00009aa0: 733a 602e 4669 656c 6444 6174 6160 2c20  s:`.FieldData`, 
-00009ab0: 7769 7468 206f 7468 6572 2073 6574 7469  with other setti
-00009ac0: 6e67 7320 6173 0a20 2020 2020 2020 2020  ngs as.         
-00009ad0: 2020 2070 726f 7669 6465 6420 696e 2074     provided in t
-00009ae0: 6865 2069 6e70 7574 2061 7267 756d 656e  he input argumen
-00009af0: 7473 2e0a 2020 2020 2020 2020 2222 220a  ts..        """.
-00009b00: 0a20 2020 2020 2020 2069 6620 6e6f 7420  .        if not 
-00009b10: 7369 7a65 3a0a 2020 2020 2020 2020 2020  size:.          
-00009b20: 2020 7369 7a65 203d 2073 656c 662e 6d6f    size = self.mo
-00009b30: 6e69 746f 722e 7369 7a65 0a0a 2020 2020  nitor.size..    
-00009b40: 2020 2020 6669 656c 6473 203d 207b 7d0a      fields = {}.
-00009b50: 2020 2020 2020 2020 666f 7220 6e61 6d65          for name
-00009b60: 2c20 6669 656c 6420 696e 2073 656c 662e  , field in self.
-00009b70: 7379 6d6d 6574 7279 5f65 7870 616e 6465  symmetry_expande
-00009b80: 645f 636f 7079 2e66 6965 6c64 5f63 6f6d  d_copy.field_com
-00009b90: 706f 6e65 6e74 732e 6974 656d 7328 293a  ponents.items():
-00009ba0: 0a20 2020 2020 2020 2020 2020 2066 6965  .            fie
-00009bb0: 6c64 735b 6e61 6d65 5d20 3d20 6669 656c  lds[name] = fiel
-00009bc0: 642e 636f 7079 2829 0a20 2020 2020 2020  d.copy().       
-00009bd0: 2020 2020 2066 6f72 2064 696d 2c20 6469       for dim, di
-00009be0: 6d5f 6e61 6d65 2069 6e20 656e 756d 6572  m_name in enumer
-00009bf0: 6174 6528 2278 797a 2229 3a0a 2020 2020  ate("xyz"):.    
-00009c00: 2020 2020 2020 2020 2020 2020 636f 6f72              coor
-00009c10: 6473 5f73 6869 6674 203d 2066 6965 6c64  ds_shift = field
-00009c20: 2e63 6f6f 7264 735b 6469 6d5f 6e61 6d65  .coords[dim_name
-00009c30: 5d20 2d20 7365 6c66 2e6d 6f6e 6974 6f72  ] - self.monitor
-00009c40: 2e63 656e 7465 725b 6469 6d5d 0a20 2020  .center[dim].   
-00009c50: 2020 2020 2020 2020 2020 2020 2066 6965               fie
-00009c60: 6c64 735b 6e61 6d65 5d2e 636f 6f72 6473  lds[name].coords
-00009c70: 5b64 696d 5f6e 616d 655d 203d 2063 6f6f  [dim_name] = coo
-00009c80: 7264 735f 7368 6966 740a 0a20 2020 2020  rds_shift..     
-00009c90: 2020 2064 6174 6173 6574 203d 2046 6965     dataset = Fie
-00009ca0: 6c64 4461 7461 7365 7428 2a2a 6669 656c  ldDataset(**fiel
-00009cb0: 6473 290a 2020 2020 2020 2020 7265 7475  ds).        retu
-00009cc0: 726e 2043 7573 746f 6d46 6965 6c64 536f  rn CustomFieldSo
-00009cd0: 7572 6365 280a 2020 2020 2020 2020 2020  urce(.          
-00009ce0: 2020 6669 656c 645f 6461 7461 7365 743d    field_dataset=
-00009cf0: 6461 7461 7365 742c 2073 6f75 7263 655f  dataset, source_
-00009d00: 7469 6d65 3d73 6f75 7263 655f 7469 6d65  time=source_time
-00009d10: 2c20 6365 6e74 6572 3d63 656e 7465 722c  , center=center,
-00009d20: 2073 697a 653d 7369 7a65 2c20 2a2a 6b77   size=size, **kw
-00009d30: 6172 6773 0a20 2020 2020 2020 2029 0a0a  args.        )..
-00009d40: 0a63 6c61 7373 2046 6965 6c64 5469 6d65  .class FieldTime
-00009d50: 4461 7461 2846 6965 6c64 5469 6d65 4461  Data(FieldTimeDa
-00009d60: 7461 7365 742c 2045 6c65 6374 726f 6d61  taset, Electroma
-00009d70: 676e 6574 6963 4669 656c 6444 6174 6129  gneticFieldData)
-00009d80: 3a0a 2020 2020 2222 220a 2020 2020 4461  :.    """.    Da
-00009d90: 7461 2061 7373 6f63 6961 7465 6420 7769  ta associated wi
-00009da0: 7468 2061 203a 636c 6173 733a 602e 4669  th a :class:`.Fi
-00009db0: 656c 6454 696d 654d 6f6e 6974 6f72 603a  eldTimeMonitor`:
-00009dc0: 2073 6361 6c61 7220 636f 6d70 6f6e 656e   scalar componen
-00009dd0: 7473 206f 6620 4520 616e 6420 4820 6669  ts of E and H fi
-00009de0: 656c 6473 2e0a 0a20 2020 204e 6f74 6573  elds...    Notes
-00009df0: 0a20 2020 202d 2d2d 2d2d 0a0a 2020 2020  .    -----..    
-00009e00: 2020 2020 5468 6520 6461 7461 2069 7320      The data is 
-00009e10: 7374 6f72 6564 2061 7320 6120 6044 6174  stored as a `Dat
-00009e20: 6141 7272 6179 203c 6874 7470 733a 2f2f  aArray <https://
-00009e30: 646f 6373 2e78 6172 7261 792e 6465 762f  docs.xarray.dev/
-00009e40: 656e 2f73 7461 626c 652f 6765 6e65 7261  en/stable/genera
-00009e50: 7465 642f 7861 7272 6179 2e44 6174 6141  ted/xarray.DataA
-00009e60: 7272 6179 2e68 746d 6c3e 605f 0a20 2020  rray.html>`_.   
-00009e70: 2020 2020 206f 626a 6563 7420 7573 696e       object usin
-00009e80: 6720 7468 6520 6078 6172 7261 7920 3c68  g the `xarray <h
-00009e90: 7474 7073 3a2f 2f64 6f63 732e 7861 7272  ttps://docs.xarr
-00009ea0: 6179 2e64 6576 2f65 6e2f 7374 6162 6c65  ay.dev/en/stable
-00009eb0: 2f69 6e64 6578 2e68 746d 6c3e 605f 2070  /index.html>`_ p
-00009ec0: 6163 6b61 6765 2e0a 0a20 2020 2045 7861  ackage...    Exa
-00009ed0: 6d70 6c65 0a20 2020 202d 2d2d 2d2d 2d2d  mple.    -------
-00009ee0: 0a20 2020 203e 3e3e 2066 726f 6d20 7469  .    >>> from ti
-00009ef0: 6479 3364 2069 6d70 6f72 7420 5363 616c  dy3d import Scal
-00009f00: 6172 4669 656c 6454 696d 6544 6174 6141  arFieldTimeDataA
-00009f10: 7272 6179 0a20 2020 203e 3e3e 2078 203d  rray.    >>> x =
-00009f20: 205b 2d31 2c31 2c33 5d0a 2020 2020 3e3e   [-1,1,3].    >>
-00009f30: 3e20 7920 3d20 5b2d 322c 302c 322c 345d  > y = [-2,0,2,4]
-00009f40: 0a20 2020 203e 3e3e 207a 203d 205b 2d33  .    >>> z = [-3
-00009f50: 2c2d 312c 312c 332c 355d 0a20 2020 203e  ,-1,1,3,5].    >
-00009f60: 3e3e 2074 203d 205b 302c 2031 652d 3132  >> t = [0, 1e-12
-00009f70: 2c20 3265 2d31 325d 0a20 2020 203e 3e3e  , 2e-12].    >>>
-00009f80: 2063 6f6f 7264 7320 3d20 6469 6374 2878   coords = dict(x
-00009f90: 3d78 5b3a 2d31 5d2c 2079 3d79 5b3a 2d31  =x[:-1], y=y[:-1
-00009fa0: 5d2c 207a 3d7a 5b3a 2d31 5d2c 2074 3d74  ], z=z[:-1], t=t
-00009fb0: 290a 2020 2020 3e3e 3e20 6772 6964 203d  ).    >>> grid =
-00009fc0: 2047 7269 6428 626f 756e 6461 7269 6573   Grid(boundaries
-00009fd0: 3d43 6f6f 7264 7328 783d 782c 2079 3d79  =Coords(x=x, y=y
-00009fe0: 2c20 7a3d 7a29 290a 2020 2020 3e3e 3e20  , z=z)).    >>> 
-00009ff0: 7363 616c 6172 5f66 6965 6c64 203d 2053  scalar_field = S
-0000a000: 6361 6c61 7246 6965 6c64 5469 6d65 4461  calarFieldTimeDa
-0000a010: 7461 4172 7261 7928 6e70 2e72 616e 646f  taArray(np.rando
-0000a020: 6d2e 7261 6e64 6f6d 2828 322c 332c 342c  m.random((2,3,4,
-0000a030: 3329 292c 2063 6f6f 7264 733d 636f 6f72  3)), coords=coor
-0000a040: 6473 290a 2020 2020 3e3e 3e20 6d6f 6e69  ds).    >>> moni
-0000a050: 746f 7220 3d20 4669 656c 6454 696d 654d  tor = FieldTimeM
-0000a060: 6f6e 6974 6f72 280a 2020 2020 2e2e 2e20  onitor(.    ... 
-0000a070: 2020 2020 7369 7a65 3d28 322c 342c 3629      size=(2,4,6)
-0000a080: 2c20 696e 7465 7276 616c 3d31 3030 2c20  , interval=100, 
-0000a090: 6e61 6d65 3d27 6669 656c 6427 2c20 6669  name='field', fi
-0000a0a0: 656c 6473 3d5b 2745 7827 2c20 2748 7a27  elds=['Ex', 'Hz'
-0000a0b0: 5d2c 2063 6f6c 6f63 6174 653d 5472 7565  ], colocate=True
-0000a0c0: 0a20 2020 202e 2e2e 2029 0a20 2020 203e  .    ... ).    >
-0000a0d0: 3e3e 2064 6174 6120 3d20 4669 656c 6454  >> data = FieldT
-0000a0e0: 696d 6544 6174 6128 6d6f 6e69 746f 723d  imeData(monitor=
-0000a0f0: 6d6f 6e69 746f 722c 2045 783d 7363 616c  monitor, Ex=scal
-0000a100: 6172 5f66 6965 6c64 2c20 487a 3d73 6361  ar_field, Hz=sca
-0000a110: 6c61 725f 6669 656c 642c 2067 7269 645f  lar_field, grid_
-0000a120: 6578 7061 6e64 6564 3d67 7269 6429 0a20  expanded=grid). 
-0000a130: 2020 2022 2222 0a0a 2020 2020 6d6f 6e69     """..    moni
-0000a140: 746f 723a 2046 6965 6c64 5469 6d65 4d6f  tor: FieldTimeMo
-0000a150: 6e69 746f 7220 3d20 7064 2e46 6965 6c64  nitor = pd.Field
-0000a160: 280a 2020 2020 2020 2020 2e2e 2e2c 2074  (.        ..., t
-0000a170: 6974 6c65 3d22 4d6f 6e69 746f 7222 2c20  itle="Monitor", 
-0000a180: 6465 7363 7269 7074 696f 6e3d 2254 696d  description="Tim
-0000a190: 652d 646f 6d61 696e 2066 6965 6c64 206d  e-domain field m
-0000a1a0: 6f6e 6974 6f72 2061 7373 6f63 6961 7465  onitor associate
-0000a1b0: 6420 7769 7468 2074 6865 2064 6174 612e  d with the data.
-0000a1c0: 220a 2020 2020 290a 0a20 2020 205f 636f  ".    )..    _co
-0000a1d0: 6e74 6169 6e73 5f6d 6f6e 6974 6f72 5f66  ntains_monitor_f
-0000a1e0: 6965 6c64 7320 3d20 656e 666f 7263 655f  ields = enforce_
-0000a1f0: 6d6f 6e69 746f 725f 6669 656c 6473 5f70  monitor_fields_p
-0000a200: 7265 7365 6e74 2829 0a0a 2020 2020 4070  resent()..    @p
-0000a210: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
-0000a220: 706f 796e 7469 6e67 2873 656c 6629 202d  poynting(self) -
-0000a230: 3e20 5363 616c 6172 4669 656c 6454 696d  > ScalarFieldTim
-0000a240: 6544 6174 6141 7272 6179 3a0a 2020 2020  eDataArray:.    
-0000a250: 2020 2020 2222 2249 6e73 7461 6e74 616e      """Instantan
-0000a260: 656f 7573 2050 6f79 6e74 696e 6720 7665  eous Poynting ve
-0000a270: 6374 6f72 2066 6f72 2074 696d 652d 646f  ctor for time-do
-0000a280: 6d61 696e 2064 6174 6120 6173 736f 6369  main data associ
-0000a290: 6174 6564 2074 6f20 6120 3244 206d 6f6e  ated to a 2D mon
-0000a2a0: 6974 6f72 2c20 7072 6f6a 6563 7465 640a  itor, projected.
-0000a2b0: 2020 2020 2020 2020 746f 2074 6865 2064          to the d
-0000a2c0: 6972 6563 7469 6f6e 206e 6f72 6d61 6c20  irection normal 
-0000a2d0: 746f 2074 6865 206d 6f6e 6974 6f72 2070  to the monitor p
-0000a2e0: 6c61 6e65 2e22 2222 0a0a 2020 2020 2020  lane."""..      
-0000a2f0: 2020 2320 5461 6e67 656e 7469 616c 2066    # Tangential f
-0000a300: 6965 6c64 7320 6172 6520 6f72 6465 7265  ields are ordere
-0000a310: 6420 6173 2045 312c 2045 322c 2048 312c  d as E1, E2, H1,
-0000a320: 2048 320a 2020 2020 2020 2020 7461 6e5f   H2.        tan_
-0000a330: 6669 656c 6473 203d 2073 656c 662e 5f63  fields = self._c
-0000a340: 6f6c 6f63 6174 6564 5f74 616e 6765 6e74  olocated_tangent
-0000a350: 6961 6c5f 6669 656c 6473 0a20 2020 2020  ial_fields.     
-0000a360: 2020 2064 696d 312c 2064 696d 3220 3d20     dim1, dim2 = 
-0000a370: 7365 6c66 2e5f 7461 6e67 656e 7469 616c  self._tangential
-0000a380: 5f64 696d 730a 2020 2020 2020 2020 655f  _dims.        e_
-0000a390: 785f 6820 3d20 6e70 2e72 6561 6c28 7461  x_h = np.real(ta
-0000a3a0: 6e5f 6669 656c 6473 5b22 4522 202b 2064  n_fields["E" + d
-0000a3b0: 696d 315d 2920 2a20 6e70 2e72 6561 6c28  im1]) * np.real(
-0000a3c0: 7461 6e5f 6669 656c 6473 5b22 4822 202b  tan_fields["H" +
-0000a3d0: 2064 696d 325d 290a 2020 2020 2020 2020   dim2]).        
-0000a3e0: 655f 785f 6820 2d3d 206e 702e 7265 616c  e_x_h -= np.real
-0000a3f0: 2874 616e 5f66 6965 6c64 735b 2245 2220  (tan_fields["E" 
-0000a400: 2b20 6469 6d32 5d29 202a 206e 702e 7265  + dim2]) * np.re
-0000a410: 616c 2874 616e 5f66 6965 6c64 735b 2248  al(tan_fields["H
-0000a420: 2220 2b20 6469 6d31 5d29 0a20 2020 2020  " + dim1]).     
-0000a430: 2020 2072 6574 7572 6e20 655f 785f 680a     return e_x_h.
-0000a440: 0a20 2020 2040 6361 6368 6564 5f70 726f  .    @cached_pro
-0000a450: 7065 7274 790a 2020 2020 6465 6620 666c  perty.    def fl
-0000a460: 7578 2873 656c 6629 202d 3e20 466c 7578  ux(self) -> Flux
-0000a470: 5469 6d65 4461 7461 4172 7261 793a 0a20  TimeDataArray:. 
-0000a480: 2020 2020 2020 2022 2222 466c 7578 2066         """Flux f
-0000a490: 6f72 2064 6174 6120 636f 7272 6573 706f  or data correspo
-0000a4a0: 6e64 696e 6720 746f 2061 2032 4420 6d6f  nding to a 2D mo
-0000a4b0: 6e69 746f 722e 2222 220a 0a20 2020 2020  nitor."""..     
-0000a4c0: 2020 2023 2043 6f6d 7075 7465 2066 6c75     # Compute flu
-0000a4d0: 7820 6279 2069 6e74 6567 7261 7469 6e67  x by integrating
-0000a4e0: 2050 6f79 6e74 696e 6720 7665 6374 6f72   Poynting vector
-0000a4f0: 2069 6e2d 706c 616e 650a 2020 2020 2020   in-plane.      
-0000a500: 2020 645f 6172 6561 203d 2073 656c 662e    d_area = self.
-0000a510: 5f64 6966 665f 6172 6561 0a20 2020 2020  _diff_area.     
-0000a520: 2020 2072 6574 7572 6e20 466c 7578 5469     return FluxTi
-0000a530: 6d65 4461 7461 4172 7261 7928 2873 656c  meDataArray((sel
-0000a540: 662e 706f 796e 7469 6e67 202a 2064 5f61  f.poynting * d_a
-0000a550: 7265 6129 2e73 756d 2864 696d 3d64 5f61  rea).sum(dim=d_a
-0000a560: 7265 612e 6469 6d73 2929 0a0a 2020 2020  rea.dims))..    
-0000a570: 6465 6620 646f 7428 7365 6c66 2c20 6669  def dot(self, fi
-0000a580: 656c 645f 6461 7461 3a20 456c 6563 7472  eld_data: Electr
-0000a590: 6f6d 6167 6e65 7469 6346 6965 6c64 4461  omagneticFieldDa
-0000a5a0: 7461 2c20 636f 6e6a 7567 6174 653a 2062  ta, conjugate: b
-0000a5b0: 6f6f 6c20 3d20 5472 7565 2920 2d3e 2078  ool = True) -> x
-0000a5c0: 722e 4461 7461 4172 7261 793a 0a20 2020  r.DataArray:.   
-0000a5d0: 2020 2020 2022 2222 496e 6e65 7220 7072       """Inner pr
-0000a5e0: 6f64 7563 7420 6973 206e 6f74 2064 6566  oduct is not def
-0000a5f0: 696e 6564 2066 6f72 2074 696d 652d 646f  ined for time-do
-0000a600: 6d61 696e 2064 6174 612e 2222 220a 2020  main data.""".  
-0000a610: 2020 2020 2020 7261 6973 6520 4461 7461        raise Data
-0000a620: 4572 726f 7228 2249 6e6e 6572 2070 726f  Error("Inner pro
-0000a630: 6475 6374 2069 7320 6e6f 7420 6465 6669  duct is not defi
-0000a640: 6e65 6420 666f 7220 7469 6d65 2d64 6f6d  ned for time-dom
-0000a650: 6169 6e20 6461 7461 2e22 290a 0a20 2020  ain data.")..   
-0000a660: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
-0000a670: 6566 2074 696d 655f 7265 7665 7273 6564  ef time_reversed
-0000a680: 5f63 6f70 7928 7365 6c66 2920 2d3e 2046  _copy(self) -> F
-0000a690: 6965 6c64 5469 6d65 4461 7461 3a0a 2020  ieldTimeData:.  
-0000a6a0: 2020 2020 2020 2222 224d 616b 6520 6120        """Make a 
-0000a6b0: 636f 7079 206f 6620 7468 6520 6461 7461  copy of the data
-0000a6c0: 2077 6974 6820 7469 6d65 2d72 6576 6572   with time-rever
-0000a6d0: 7365 6420 6669 656c 6473 2e20 5468 6520  sed fields. The 
-0000a6e0: 7369 676e 206f 6620 7468 6520 6d61 676e  sign of the magn
-0000a6f0: 6574 6963 2066 6965 6c64 7320 6973 0a20  etic fields is. 
-0000a700: 2020 2020 2020 2066 6c69 7070 6564 2c20         flipped, 
-0000a710: 616e 6420 7468 6520 6461 7461 2069 7320  and the data is 
-0000a720: 7265 7665 7273 6564 2061 6c6f 6e67 2074  reversed along t
-0000a730: 6865 2060 6074 6060 2064 696d 656e 7369  he ``t`` dimensi
-0000a740: 6f6e 2c20 7375 6368 2074 6861 7420 666f  on, such that fo
-0000a750: 7220 6120 6769 7665 6e20 6669 656c 642c  r a given field,
-0000a760: 0a20 2020 2020 2020 2060 6066 6965 6c64  .        ``field
-0000a770: 5b74 5f62 6567 202b 2074 5d20 2d3e 2066  [t_beg + t] -> f
-0000a780: 6965 6c64 5b74 5f65 6e64 202d 2074 5d60  ield[t_end - t]`
-0000a790: 602c 2077 6865 7265 2060 6074 5f62 6567  `, where ``t_beg
-0000a7a0: 6060 2061 6e64 2060 6074 5f65 6e64 6060  `` and ``t_end``
-0000a7b0: 2061 7265 2074 6865 2066 6972 7374 2061   are the first a
-0000a7c0: 6e64 0a20 2020 2020 2020 206c 6173 7420  nd.        last 
-0000a7d0: 636f 6f72 6469 6e61 7465 7320 616c 6f6e  coordinates alon
-0000a7e0: 6720 7468 6520 6060 7460 6020 6469 6d65  g the ``t`` dime
-0000a7f0: 6e73 696f 6e2e 0a20 2020 2020 2020 2022  nsion..        "
-0000a800: 2222 0a20 2020 2020 2020 206e 6577 5f64  "".        new_d
-0000a810: 6174 6120 3d20 7b7d 0a20 2020 2020 2020  ata = {}.       
-0000a820: 2066 6f72 2063 6f6d 702c 2066 6965 6c64   for comp, field
-0000a830: 2069 6e20 7365 6c66 2e66 6965 6c64 5f63   in self.field_c
-0000a840: 6f6d 706f 6e65 6e74 732e 6974 656d 7328  omponents.items(
-0000a850: 293a 0a20 2020 2020 2020 2020 2020 2069  ):.            i
-0000a860: 6620 636f 6d70 5b30 5d20 3d3d 2022 4822  f comp[0] == "H"
-0000a870: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000a880: 2020 6e65 775f 6461 7461 5b63 6f6d 705d    new_data[comp]
-0000a890: 203d 202d 6669 656c 640a 2020 2020 2020   = -field.      
-0000a8a0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-0000a8b0: 2020 2020 2020 2020 2020 2020 6e65 775f              new_
-0000a8c0: 6461 7461 5b63 6f6d 705d 203d 2066 6965  data[comp] = fie
-0000a8d0: 6c64 0a20 2020 2020 2020 2020 2020 2023  ld.            #
-0000a8e0: 2052 6576 6572 7365 2074 696d 6520 636f   Reverse time co
-0000a8f0: 6f72 6469 6e61 7465 730a 2020 2020 2020  ordinates.      
-0000a900: 2020 2020 2020 6e65 775f 6461 7461 5b63        new_data[c
-0000a910: 6f6d 705d 203d 206e 6577 5f64 6174 615b  omp] = new_data[
-0000a920: 636f 6d70 5d2e 6173 7369 676e 5f63 6f6f  comp].assign_coo
-0000a930: 7264 7328 7b22 7422 3a20 6669 656c 642e  rds({"t": field.
-0000a940: 745b 3a3a 2d31 5d7d 292e 736f 7274 6279  t[::-1]}).sortby
-0000a950: 2822 7422 290a 2020 2020 2020 2020 7265  ("t").        re
-0000a960: 7475 726e 2073 656c 662e 636f 7079 2875  turn self.copy(u
-0000a970: 7064 6174 653d 6e65 775f 6461 7461 290a  pdate=new_data).
-0000a980: 0a0a 636c 6173 7320 5065 726d 6974 7469  ..class Permitti
-0000a990: 7669 7479 4461 7461 2850 6572 6d69 7474  vityData(Permitt
-0000a9a0: 6976 6974 7944 6174 6173 6574 2c20 4162  ivityDataset, Ab
-0000a9b0: 7374 7261 6374 4669 656c 6444 6174 6129  stractFieldData)
-0000a9c0: 3a0a 2020 2020 2222 2244 6174 6120 666f  :.    """Data fo
-0000a9d0: 7220 6120 3a63 6c61 7373 3a60 2e50 6572  r a :class:`.Per
-0000a9e0: 6d69 7474 6976 6974 794d 6f6e 6974 6f72  mittivityMonitor
-0000a9f0: 603a 2064 6961 676f 6e61 6c20 636f 6d70  `: diagonal comp
-0000aa00: 6f6e 656e 7473 206f 6620 7468 6520 7065  onents of the pe
-0000aa10: 726d 6974 7469 7669 7479 2074 656e 736f  rmittivity tenso
-0000aa20: 722e 0a0a 2020 2020 4e6f 7465 730a 2020  r...    Notes.  
-0000aa30: 2020 2d2d 2d2d 2d0a 0a20 2020 2020 2020    -----..       
-0000aa40: 2054 6865 2064 6174 6120 6973 2073 746f   The data is sto
-0000aa50: 7265 6420 6173 2061 2060 4461 7461 4172  red as a `DataAr
-0000aa60: 7261 7920 3c68 7474 7073 3a2f 2f64 6f63  ray <https://doc
-0000aa70: 732e 7861 7272 6179 2e64 6576 2f65 6e2f  s.xarray.dev/en/
-0000aa80: 7374 6162 6c65 2f67 656e 6572 6174 6564  stable/generated
-0000aa90: 2f78 6172 7261 792e 4461 7461 4172 7261  /xarray.DataArra
-0000aaa0: 792e 6874 6d6c 3e60 5f0a 2020 2020 2020  y.html>`_.      
-0000aab0: 2020 6f62 6a65 6374 2075 7369 6e67 2074    object using t
-0000aac0: 6865 2060 7861 7272 6179 203c 6874 7470  he `xarray <http
-0000aad0: 733a 2f2f 646f 6373 2e78 6172 7261 792e  s://docs.xarray.
-0000aae0: 6465 762f 656e 2f73 7461 626c 652f 696e  dev/en/stable/in
-0000aaf0: 6465 782e 6874 6d6c 3e60 5f20 7061 636b  dex.html>`_ pack
-0000ab00: 6167 652e 0a0a 2020 2020 4578 616d 706c  age...    Exampl
-0000ab10: 650a 2020 2020 2d2d 2d2d 2d2d 2d0a 2020  e.    -------.  
-0000ab20: 2020 3e3e 3e20 6672 6f6d 2074 6964 7933    >>> from tidy3
-0000ab30: 6420 696d 706f 7274 2053 6361 6c61 7246  d import ScalarF
-0000ab40: 6965 6c64 4461 7461 4172 7261 790a 2020  ieldDataArray.  
-0000ab50: 2020 3e3e 3e20 7820 3d20 5b2d 312c 312c    >>> x = [-1,1,
-0000ab60: 335d 0a20 2020 203e 3e3e 2079 203d 205b  3].    >>> y = [
-0000ab70: 2d32 2c30 2c32 2c34 5d0a 2020 2020 3e3e  -2,0,2,4].    >>
-0000ab80: 3e20 7a20 3d20 5b2d 332c 2d31 2c31 2c33  > z = [-3,-1,1,3
-0000ab90: 2c35 5d0a 2020 2020 3e3e 3e20 6620 3d20  ,5].    >>> f = 
-0000aba0: 5b32 6531 342c 2033 6531 345d 0a20 2020  [2e14, 3e14].   
-0000abb0: 203e 3e3e 2063 6f6f 7264 7320 3d20 6469   >>> coords = di
-0000abc0: 6374 2878 3d78 5b3a 2d31 5d2c 2079 3d79  ct(x=x[:-1], y=y
-0000abd0: 5b3a 2d31 5d2c 207a 3d7a 5b3a 2d31 5d2c  [:-1], z=z[:-1],
-0000abe0: 2066 3d66 290a 2020 2020 3e3e 3e20 6772   f=f).    >>> gr
-0000abf0: 6964 203d 2047 7269 6428 626f 756e 6461  id = Grid(bounda
-0000ac00: 7269 6573 3d43 6f6f 7264 7328 783d 782c  ries=Coords(x=x,
-0000ac10: 2079 3d79 2c20 7a3d 7a29 290a 2020 2020   y=y, z=z)).    
-0000ac20: 3e3e 3e20 7363 6c72 5f66 6c64 203d 2053  >>> sclr_fld = S
-0000ac30: 6361 6c61 7246 6965 6c64 4461 7461 4172  calarFieldDataAr
-0000ac40: 7261 7928 2831 2b31 6a29 202a 206e 702e  ray((1+1j) * np.
-0000ac50: 7261 6e64 6f6d 2e72 616e 646f 6d28 2832  random.random((2
-0000ac60: 2c33 2c34 2c32 2929 2c20 636f 6f72 6473  ,3,4,2)), coords
-0000ac70: 3d63 6f6f 7264 7329 0a20 2020 203e 3e3e  =coords).    >>>
-0000ac80: 206d 6f6e 6974 6f72 203d 2050 6572 6d69   monitor = Permi
-0000ac90: 7474 6976 6974 794d 6f6e 6974 6f72 2873  ttivityMonitor(s
-0000aca0: 697a 653d 2832 2c34 2c36 292c 2066 7265  ize=(2,4,6), fre
-0000acb0: 7173 3d5b 3265 3134 2c20 3365 3134 5d2c  qs=[2e14, 3e14],
-0000acc0: 206e 616d 653d 2765 7073 2729 0a20 2020   name='eps').   
-0000acd0: 203e 3e3e 2064 6174 6120 3d20 5065 726d   >>> data = Perm
-0000ace0: 6974 7469 7669 7479 4461 7461 280a 2020  ittivityData(.  
-0000acf0: 2020 2e2e 2e20 2020 2020 6d6f 6e69 746f    ...     monito
-0000ad00: 723d 6d6f 6e69 746f 722c 2065 7073 5f78  r=monitor, eps_x
-0000ad10: 783d 7363 6c72 5f66 6c64 2c20 6570 735f  x=sclr_fld, eps_
-0000ad20: 7979 3d73 636c 725f 666c 642c 2065 7073  yy=sclr_fld, eps
-0000ad30: 5f7a 7a3d 7363 6c72 5f66 6c64 2c20 6772  _zz=sclr_fld, gr
-0000ad40: 6964 5f65 7870 616e 6465 643d 6772 6964  id_expanded=grid
-0000ad50: 0a20 2020 202e 2e2e 2029 0a20 2020 2022  .    ... ).    "
-0000ad60: 2222 0a0a 2020 2020 6d6f 6e69 746f 723a  ""..    monitor:
-0000ad70: 2050 6572 6d69 7474 6976 6974 794d 6f6e   PermittivityMon
-0000ad80: 6974 6f72 203d 2070 642e 4669 656c 6428  itor = pd.Field(
-0000ad90: 0a20 2020 2020 2020 202e 2e2e 2c20 7469  .        ..., ti
-0000ada0: 746c 653d 224d 6f6e 6974 6f72 222c 2064  tle="Monitor", d
-0000adb0: 6573 6372 6970 7469 6f6e 3d22 5065 726d  escription="Perm
-0000adc0: 6974 7469 7669 7479 206d 6f6e 6974 6f72  ittivity monitor
-0000add0: 2061 7373 6f63 6961 7465 6420 7769 7468   associated with
-0000ade0: 2074 6865 2064 6174 612e 220a 2020 2020   the data.".    
-0000adf0: 290a 0a0a 636c 6173 7320 4d6f 6465 4461  )...class ModeDa
-0000ae00: 7461 284d 6f64 6553 6f6c 7665 7244 6174  ta(ModeSolverDat
-0000ae10: 6173 6574 2c20 456c 6563 7472 6f6d 6167  aset, Electromag
-0000ae20: 6e65 7469 6346 6965 6c64 4461 7461 293a  neticFieldData):
-0000ae30: 0a20 2020 2022 2222 0a20 2020 2044 6174  .    """.    Dat
-0000ae40: 6120 6173 736f 6369 6174 6564 2077 6974  a associated wit
-0000ae50: 6820 6120 3a63 6c61 7373 3a60 2e4d 6f64  h a :class:`.Mod
-0000ae60: 654d 6f6e 6974 6f72 603a 206d 6f64 616c  eMonitor`: modal
-0000ae70: 2061 6d70 6c69 7475 6465 732c 2070 726f   amplitudes, pro
-0000ae80: 7061 6761 7469 6f6e 2069 6e64 6963 6573  pagation indices
-0000ae90: 2061 6e64 206d 6f64 6520 7072 6f66 696c   and mode profil
-0000aea0: 6573 2e0a 0a20 2020 204e 6f74 6573 0a20  es...    Notes. 
-0000aeb0: 2020 202d 2d2d 2d2d 0a0a 2020 2020 2020     -----..      
-0000aec0: 2020 5468 6520 6461 7461 2069 7320 7374    The data is st
-0000aed0: 6f72 6564 2061 7320 6120 6044 6174 6141  ored as a `DataA
-0000aee0: 7272 6179 203c 6874 7470 733a 2f2f 646f  rray <https://do
-0000aef0: 6373 2e78 6172 7261 792e 6465 762f 656e  cs.xarray.dev/en
-0000af00: 2f73 7461 626c 652f 6765 6e65 7261 7465  /stable/generate
-0000af10: 642f 7861 7272 6179 2e44 6174 6141 7272  d/xarray.DataArr
-0000af20: 6179 2e68 746d 6c3e 605f 0a20 2020 2020  ay.html>`_.     
-0000af30: 2020 206f 626a 6563 7420 7573 696e 6720     object using 
-0000af40: 7468 6520 6078 6172 7261 7920 3c68 7474  the `xarray <htt
-0000af50: 7073 3a2f 2f64 6f63 732e 7861 7272 6179  ps://docs.xarray
-0000af60: 2e64 6576 2f65 6e2f 7374 6162 6c65 2f69  .dev/en/stable/i
-0000af70: 6e64 6578 2e68 746d 6c3e 605f 2070 6163  ndex.html>`_ pac
-0000af80: 6b61 6765 2e0a 0a20 2020 2020 2020 2054  kage...        T
-0000af90: 6865 206d 6f64 6520 6d6f 6e69 746f 7220  he mode monitor 
-0000afa0: 6461 7461 2063 6f6e 7461 696e 7320 7468  data contains th
-0000afb0: 6520 636f 6d70 6c65 7820 6566 6665 6374  e complex effect
-0000afc0: 6976 6520 696e 6469 6365 7320 616e 6420  ive indices and 
-0000afd0: 7468 6520 636f 6d70 6c65 7820 6d6f 6465  the complex mode
-0000afe0: 2061 6d70 6c69 7475 6465 7320 6174 2074   amplitudes at t
-0000aff0: 6865 206d 6f6e 6974 6f72 0a20 2020 2020  he monitor.     
-0000b000: 2020 2070 6f73 6974 696f 6e20 6361 6c63     position calc
-0000b010: 756c 6174 6564 2062 7920 6d6f 6465 2064  ulated by mode d
-0000b020: 6563 6f6d 706f 7369 7469 6f6e 2e20 5468  ecomposition. Th
-0000b030: 6520 6461 7461 2073 7472 7563 7475 7265  e data structure
-0000b040: 206f 6620 7468 6520 636f 6d70 6c65 7820   of the complex 
-0000b050: 6566 6665 6374 6976 650a 2020 2020 2020  effective.      
-0000b060: 2020 696e 6469 6365 7320 3a61 7474 7260    indices :attr`
-0000b070: 6e5f 636f 6d70 6c65 7860 2063 6f6e 7461  n_complex` conta
-0000b080: 696e 7320 7477 6f20 636f 6f72 6469 6e61  ins two coordina
-0000b090: 7465 733a 2060 6066 6060 2061 6e64 2060  tes: ``f`` and `
-0000b0a0: 606d 6f64 655f 696e 6465 7860 602c 2062  `mode_index``, b
-0000b0b0: 6f74 6820 6f66 2077 6869 6368 2061 7265  oth of which are
-0000b0c0: 2073 7065 6369 6669 6564 2077 6865 6e0a   specified when.
-0000b0d0: 2020 2020 2020 2020 6465 6669 6e69 6e67          defining
-0000b0e0: 2074 6865 203a 636c 6173 733a 6060 4d6f   the :class:``Mo
-0000b0f0: 6465 4d6f 6e69 746f 7260 6020 696e 2074  deMonitor`` in t
-0000b100: 6865 2073 696d 756c 6174 696f 6e2e 0a0a  he simulation...
-0000b110: 2020 2020 2020 2020 4265 7369 6465 7320          Besides 
-0000b120: 7468 6520 6566 6665 6374 6976 6520 696e  the effective in
-0000b130: 6465 782c 203a 636c 6173 733a 6060 4d6f  dex, :class:``Mo
-0000b140: 6465 4d6f 6e69 746f 7260 6020 6973 2070  deMonitor`` is p
-0000b150: 7269 6d61 7269 6c79 2075 7365 6420 746f  rimarily used to
-0000b160: 2063 616c 6375 6c61 7465 2074 6865 2074   calculate the t
-0000b170: 7261 6e73 6d69 7373 696f 6e20 6f66 0a20  ransmission of. 
-0000b180: 2020 2020 2020 2063 6572 7461 696e 206d         certain m
-0000b190: 6f64 6573 2069 6e20 6365 7274 6169 6e20  odes in certain 
-0000b1a0: 6469 7265 6374 696f 6e73 2e20 5765 2063  directions. We c
-0000b1b0: 616e 2065 7874 7261 6374 2074 6865 2063  an extract the c
-0000b1c0: 6f6d 706c 6578 2061 6d70 6c69 7475 6465  omplex amplitude
-0000b1d0: 2061 6e64 2073 7175 6172 6520 6974 2074   and square it t
-0000b1e0: 6f20 636f 6d70 7574 6520 7468 6520 6d6f  o compute the mo
-0000b1f0: 6465 0a20 2020 2020 2020 2074 7261 6e73  de.        trans
-0000b200: 6d69 7373 696f 6e20 706f 7765 722e 0a0a  mission power...
-0000b210: 2020 2020 4578 616d 706c 650a 2020 2020      Example.    
-0000b220: 2d2d 2d2d 2d2d 2d0a 2020 2020 3e3e 3e20  -------.    >>> 
-0000b230: 6672 6f6d 2074 6964 7933 6420 696d 706f  from tidy3d impo
-0000b240: 7274 204d 6f64 6553 7065 630a 2020 2020  rt ModeSpec.    
-0000b250: 3e3e 3e20 6672 6f6d 2074 6964 7933 6420  >>> from tidy3d 
-0000b260: 696d 706f 7274 204d 6f64 6541 6d70 7344  import ModeAmpsD
-0000b270: 6174 6141 7272 6179 2c20 4d6f 6465 496e  ataArray, ModeIn
-0000b280: 6465 7844 6174 6141 7272 6179 0a20 2020  dexDataArray.   
-0000b290: 203e 3e3e 2064 6972 6563 7469 6f6e 203d   >>> direction =
-0000b2a0: 205b 222b 222c 2022 2d22 5d0a 2020 2020   ["+", "-"].    
-0000b2b0: 3e3e 3e20 6620 3d20 5b31 6531 342c 2032  >>> f = [1e14, 2
-0000b2c0: 6531 342c 2033 6531 345d 0a20 2020 203e  e14, 3e14].    >
-0000b2d0: 3e3e 206d 6f64 655f 696e 6465 7820 3d20  >> mode_index = 
-0000b2e0: 6e70 2e61 7261 6e67 6528 3529 0a20 2020  np.arange(5).   
-0000b2f0: 203e 3e3e 2069 6e64 6578 5f63 6f6f 7264   >>> index_coord
-0000b300: 7320 3d20 6469 6374 2866 3d66 2c20 6d6f  s = dict(f=f, mo
-0000b310: 6465 5f69 6e64 6578 3d6d 6f64 655f 696e  de_index=mode_in
-0000b320: 6465 7829 0a20 2020 203e 3e3e 2069 6e64  dex).    >>> ind
-0000b330: 6578 5f64 6174 6120 3d20 4d6f 6465 496e  ex_data = ModeIn
-0000b340: 6465 7844 6174 6141 7272 6179 2828 312b  dexDataArray((1+
-0000b350: 316a 2920 2a20 6e70 2e72 616e 646f 6d2e  1j) * np.random.
-0000b360: 7261 6e64 6f6d 2828 332c 2035 2929 2c20  random((3, 5)), 
-0000b370: 636f 6f72 6473 3d69 6e64 6578 5f63 6f6f  coords=index_coo
-0000b380: 7264 7329 0a20 2020 203e 3e3e 2061 6d70  rds).    >>> amp
-0000b390: 5f63 6f6f 7264 7320 3d20 6469 6374 2864  _coords = dict(d
-0000b3a0: 6972 6563 7469 6f6e 3d64 6972 6563 7469  irection=directi
-0000b3b0: 6f6e 2c20 663d 662c 206d 6f64 655f 696e  on, f=f, mode_in
-0000b3c0: 6465 783d 6d6f 6465 5f69 6e64 6578 290a  dex=mode_index).
-0000b3d0: 2020 2020 3e3e 3e20 616d 705f 6461 7461      >>> amp_data
-0000b3e0: 203d 204d 6f64 6541 6d70 7344 6174 6141   = ModeAmpsDataA
-0000b3f0: 7272 6179 2828 312b 316a 2920 2a20 6e70  rray((1+1j) * np
-0000b400: 2e72 616e 646f 6d2e 7261 6e64 6f6d 2828  .random.random((
-0000b410: 322c 2033 2c20 3529 292c 2063 6f6f 7264  2, 3, 5)), coord
-0000b420: 733d 616d 705f 636f 6f72 6473 290a 2020  s=amp_coords).  
-0000b430: 2020 3e3e 3e20 6d6f 6e69 746f 7220 3d20    >>> monitor = 
-0000b440: 4d6f 6465 4d6f 6e69 746f 7228 0a20 2020  ModeMonitor(.   
-0000b450: 202e 2e2e 2020 2020 7369 7a65 3d28 322c   ...    size=(2,
-0000b460: 302c 3629 2c0a 2020 2020 2e2e 2e20 2020  0,6),.    ...   
-0000b470: 2066 7265 7173 3d5b 3265 3134 2c20 3365   freqs=[2e14, 3e
-0000b480: 3134 5d2c 0a20 2020 202e 2e2e 2020 2020  14],.    ...    
-0000b490: 6d6f 6465 5f73 7065 633d 4d6f 6465 5370  mode_spec=ModeSp
-0000b4a0: 6563 286e 756d 5f6d 6f64 6573 3d35 292c  ec(num_modes=5),
-0000b4b0: 0a20 2020 202e 2e2e 2020 2020 6e61 6d65  .    ...    name
-0000b4c0: 3d27 6d6f 6465 272c 0a20 2020 202e 2e2e  ='mode',.    ...
-0000b4d0: 2029 0a20 2020 203e 3e3e 2064 6174 6120   ).    >>> data 
-0000b4e0: 3d20 4d6f 6465 4461 7461 286d 6f6e 6974  = ModeData(monit
-0000b4f0: 6f72 3d6d 6f6e 6974 6f72 2c20 616d 7073  or=monitor, amps
-0000b500: 3d61 6d70 5f64 6174 612c 206e 5f63 6f6d  =amp_data, n_com
-0000b510: 706c 6578 3d69 6e64 6578 5f64 6174 6129  plex=index_data)
-0000b520: 0a20 2020 2022 2222 0a0a 2020 2020 6d6f  .    """..    mo
-0000b530: 6e69 746f 723a 204d 6f64 654d 6f6e 6974  nitor: ModeMonit
-0000b540: 6f72 203d 2070 642e 4669 656c 6428 0a20  or = pd.Field(. 
-0000b550: 2020 2020 2020 202e 2e2e 2c20 7469 746c         ..., titl
-0000b560: 653d 224d 6f6e 6974 6f72 222c 2064 6573  e="Monitor", des
-0000b570: 6372 6970 7469 6f6e 3d22 4d6f 6465 206d  cription="Mode m
-0000b580: 6f6e 6974 6f72 2061 7373 6f63 6961 7465  onitor associate
-0000b590: 6420 7769 7468 2074 6865 2064 6174 612e  d with the data.
-0000b5a0: 220a 2020 2020 290a 0a20 2020 2061 6d70  ".    )..    amp
-0000b5b0: 733a 204d 6f64 6541 6d70 7344 6174 6141  s: ModeAmpsDataA
-0000b5c0: 7272 6179 203d 2070 642e 4669 656c 6428  rray = pd.Field(
-0000b5d0: 0a20 2020 2020 2020 202e 2e2e 2c20 7469  .        ..., ti
-0000b5e0: 746c 653d 2241 6d70 6c69 7475 6465 7322  tle="Amplitudes"
-0000b5f0: 2c20 6465 7363 7269 7074 696f 6e3d 2243  , description="C
-0000b600: 6f6d 706c 6578 2d76 616c 7565 6420 616d  omplex-valued am
-0000b610: 706c 6974 7564 6573 2061 7373 6f63 6961  plitudes associa
-0000b620: 7465 6420 7769 7468 2074 6865 206d 6f64  ted with the mod
-0000b630: 652e 220a 2020 2020 290a 0a20 2020 2065  e.".    )..    e
-0000b640: 7073 5f73 7065 633a 204c 6973 745b 4570  ps_spec: List[Ep
-0000b650: 7353 7065 6354 7970 655d 203d 2070 642e  sSpecType] = pd.
-0000b660: 4669 656c 6428 0a20 2020 2020 2020 204e  Field(.        N
-0000b670: 6f6e 652c 0a20 2020 2020 2020 2074 6974  one,.        tit
-0000b680: 6c65 3d22 5065 726d 6574 7469 7669 7479  le="Permettivity
-0000b690: 2053 7065 6369 6669 6361 7469 6f6e 222c   Specification",
-0000b6a0: 0a20 2020 2020 2020 2064 6573 6372 6970  .        descrip
-0000b6b0: 7469 6f6e 3d22 4368 6172 6163 7465 7269  tion="Characteri
-0000b6c0: 7a61 7469 6f6e 206f 6620 7468 6520 7065  zation of the pe
-0000b6d0: 726d 6974 7469 7669 7479 2070 726f 6669  rmittivity profi
-0000b6e0: 6c65 206f 6e20 7468 6520 706c 616e 6520  le on the plane 
-0000b6f0: 7768 6572 6520 6d6f 6465 7320 6172 6520  where modes are 
-0000b700: 220a 2020 2020 2020 2020 2263 6f6d 7075  ".        "compu
-0000b710: 7465 642e 2050 6f73 7369 626c 6520 7661  ted. Possible va
-0000b720: 6c75 6573 2061 7265 2027 6469 6167 6f6e  lues are 'diagon
-0000b730: 616c 272c 2027 7465 6e73 6f72 6961 6c5f  al', 'tensorial_
-0000b740: 7265 616c 272c 2027 7465 6e73 6f72 6961  real', 'tensoria
-0000b750: 6c5f 636f 6d70 6c65 7827 2e22 2c0a 2020  l_complex'.",.  
-0000b760: 2020 290a 0a20 2020 2040 7064 2e76 616c    )..    @pd.val
-0000b770: 6964 6174 6f72 2822 6570 735f 7370 6563  idator("eps_spec
-0000b780: 222c 2061 6c77 6179 733d 5472 7565 290a  ", always=True).
-0000b790: 2020 2020 4073 6b69 705f 6966 5f66 6965      @skip_if_fie
-0000b7a0: 6c64 735f 6d69 7373 696e 6728 5b22 6d6f  lds_missing(["mo
-0000b7b0: 6e69 746f 7222 5d29 0a20 2020 2064 6566  nitor"]).    def
-0000b7c0: 2065 7073 5f73 7065 635f 6d61 7463 685f   eps_spec_match_
-0000b7d0: 6d6f 6465 5f73 7065 6328 636c 732c 2076  mode_spec(cls, v
-0000b7e0: 616c 2c20 7661 6c75 6573 293a 0a20 2020  al, values):.   
-0000b7f0: 2020 2020 2022 2222 5261 6973 6520 7661       """Raise va
-0000b800: 6c69 6461 7469 6f6e 2065 7272 6f72 2069  lidation error i
-0000b810: 6620 6672 6571 7565 6e63 6965 7320 696e  f frequencies in
-0000b820: 2065 7073 5f73 7065 6320 646f 6573 206e   eps_spec does n
-0000b830: 6f74 206d 6174 6368 2066 7265 7175 656e  ot match frequen
-0000b840: 6379 206c 6973 7422 2222 0a20 2020 2020  cy list""".     
-0000b850: 2020 2069 6620 7661 6c3a 0a20 2020 2020     if val:.     
-0000b860: 2020 2020 2020 206d 6f64 655f 6461 7461         mode_data
-0000b870: 5f66 7265 7173 203d 2076 616c 7565 735b  _freqs = values[
-0000b880: 226d 6f6e 6974 6f72 225d 2e66 7265 7173  "monitor"].freqs
-0000b890: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-0000b8a0: 6c65 6e28 7661 6c29 2021 3d20 6c65 6e28  len(val) != len(
-0000b8b0: 6d6f 6465 5f64 6174 615f 6672 6571 7329  mode_data_freqs)
-0000b8c0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000b8d0: 2020 7261 6973 6520 5661 6c69 6461 7469    raise Validati
-0000b8e0: 6f6e 4572 726f 7228 0a20 2020 2020 2020  onError(.       
-0000b8f0: 2020 2020 2020 2020 2020 2020 2022 6570               "ep
-0000b900: 735f 7370 6563 206d 7573 7420 6265 2070  s_spec must be p
-0000b910: 726f 7669 6465 6420 6174 2074 6865 2073  rovided at the s
-0000b920: 616d 6520 6672 6571 7565 6e63 6965 7320  ame frequencies 
-0000b930: 6173 206d 6f64 6520 736f 6c76 6572 2064  as mode solver d
-0000b940: 6174 612e 220a 2020 2020 2020 2020 2020  ata.".          
-0000b950: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
-0000b960: 7265 7475 726e 2076 616c 0a0a 2020 2020  return val..    
-0000b970: 6465 6620 6e6f 726d 616c 697a 6528 7365  def normalize(se
-0000b980: 6c66 2c20 736f 7572 6365 5f73 7065 6374  lf, source_spect
-0000b990: 7275 6d5f 666e 2920 2d3e 204d 6f64 6544  rum_fn) -> ModeD
-0000b9a0: 6174 613a 0a20 2020 2020 2020 2022 2222  ata:.        """
-0000b9b0: 5265 7475 726e 2063 6f70 7920 6f66 2073  Return copy of s
-0000b9c0: 656c 6620 6166 7465 7220 6e6f 726d 616c  elf after normal
-0000b9d0: 697a 6174 696f 6e20 6973 2061 7070 6c69  ization is appli
-0000b9e0: 6564 2075 7369 6e67 2073 6f75 7263 6520  ed using source 
-0000b9f0: 7370 6563 7472 756d 2066 756e 6374 696f  spectrum functio
-0000ba00: 6e2e 2222 220a 2020 2020 2020 2020 736f  n.""".        so
-0000ba10: 7572 6365 5f66 7265 715f 616d 7073 203d  urce_freq_amps =
-0000ba20: 2073 6f75 7263 655f 7370 6563 7472 756d   source_spectrum
-0000ba30: 5f66 6e28 7365 6c66 2e61 6d70 732e 6629  _fn(self.amps.f)
-0000ba40: 5b4e 6f6e 652c 203a 2c20 4e6f 6e65 5d0a  [None, :, None].
-0000ba50: 2020 2020 2020 2020 6e65 775f 616d 7073          new_amps
-0000ba60: 203d 2028 7365 6c66 2e61 6d70 7320 2f20   = (self.amps / 
-0000ba70: 736f 7572 6365 5f66 7265 715f 616d 7073  source_freq_amps
-0000ba80: 292e 6173 7479 7065 2873 656c 662e 616d  ).astype(self.am
-0000ba90: 7073 2e64 7479 7065 290a 2020 2020 2020  ps.dtype).      
-0000baa0: 2020 7265 7475 726e 2073 656c 662e 636f    return self.co
-0000bab0: 7079 2875 7064 6174 653d 6469 6374 2861  py(update=dict(a
-0000bac0: 6d70 733d 6e65 775f 616d 7073 2929 0a0a  mps=new_amps))..
-0000bad0: 2020 2020 6465 6620 6f76 6572 6c61 705f      def overlap_
-0000bae0: 736f 7274 280a 2020 2020 2020 2020 7365  sort(.        se
-0000baf0: 6c66 2c0a 2020 2020 2020 2020 7472 6163  lf,.        trac
-0000bb00: 6b5f 6672 6571 3a20 5472 6163 6b46 7265  k_freq: TrackFre
-0000bb10: 712c 0a20 2020 2020 2020 206f 7665 726c  q,.        overl
-0000bb20: 6170 5f74 6872 6573 683a 2066 6c6f 6174  ap_thresh: float
-0000bb30: 203d 2030 2e39 2c0a 2020 2020 2920 2d3e   = 0.9,.    ) ->
-0000bb40: 204d 6f64 6544 6174 613a 0a20 2020 2020   ModeData:.     
-0000bb50: 2020 2022 2222 5374 6172 7469 6e67 2066     """Starting f
-0000bb60: 726f 6d20 7468 6520 6261 7365 2066 7265  rom the base fre
-0000bb70: 7175 656e 6379 2064 6566 696e 6564 2062  quency defined b
-0000bb80: 7920 7061 7261 6d65 7465 7220 6060 7472  y parameter ``tr
-0000bb90: 6163 6b5f 6672 6571 6060 2c20 736f 7274  ack_freq``, sort
-0000bba0: 206d 6f64 6573 2061 7420 6561 6368 0a20   modes at each. 
-0000bbb0: 2020 2020 2020 2066 7265 7175 656e 6379         frequency
-0000bbc0: 2061 6363 6f72 6469 6e67 2074 6f20 7468   according to th
-0000bbd0: 6569 7220 6f76 6572 6c61 7020 7661 6c75  eir overlap valu
-0000bbe0: 6573 2077 6974 6820 7468 6520 6d6f 6465  es with the mode
-0000bbf0: 7320 6174 2074 6865 2070 7265 7669 6f75  s at the previou
-0000bc00: 7320 6672 6571 7565 6e63 792e 0a20 2020  s frequency..   
-0000bc10: 2020 2020 2054 6861 7420 6973 2c20 6974       That is, it
-0000bc20: 2061 7474 656d 7074 7320 746f 2072 6561   attempts to rea
-0000bc30: 7272 616e 6765 206d 6f64 6573 2069 6e20  rrange modes in 
-0000bc40: 7375 6368 2061 2077 6179 2074 6861 7420  such a way that 
-0000bc50: 6120 6769 7665 6e20 6060 6d6f 6465 5f69  a given ``mode_i
-0000bc60: 6e64 6578 6060 0a20 2020 2020 2020 2063  ndex``.        c
-0000bc70: 6f72 7265 7370 6f6e 6473 2074 6f20 7068  orresponds to ph
-0000bc80: 7973 6963 616c 6c79 2074 6865 2073 616d  ysically the sam
-0000bc90: 6520 6d6f 6465 2061 7420 616c 6c20 6672  e mode at all fr
-0000bca0: 6571 7565 6e63 6965 732e 204d 6f64 6573  equencies. Modes
-0000bcb0: 2077 6974 6820 6f76 6572 6c61 7020 7661   with overlap va
-0000bcc0: 6c75 6573 206f 7665 720a 2020 2020 2020  lues over.      
-0000bcd0: 2020 6060 6f76 6572 6c61 705f 7472 6573    ``overlap_tres
-0000bce0: 6860 6020 6172 6520 636f 6e73 6964 6572  h`` are consider
-0000bcf0: 6564 206d 6174 6368 696e 6720 616e 6420  ed matching and 
-0000bd00: 6e6f 7420 7265 6172 7261 6e67 6564 2e0a  not rearranged..
-0000bd10: 0a20 2020 2020 2020 2050 6172 616d 6574  .        Paramet
-0000bd20: 6572 730a 2020 2020 2020 2020 2d2d 2d2d  ers.        ----
-0000bd30: 2d2d 2d2d 2d2d 0a20 2020 2020 2020 2074  ------.        t
-0000bd40: 7261 636b 5f66 7265 7120 3a20 4c69 7465  rack_freq : Lite
-0000bd50: 7261 6c5b 2263 656e 7472 616c 222c 2022  ral["central", "
-0000bd60: 6c6f 7765 7374 222c 2022 6869 6768 6573  lowest", "highes
-0000bd70: 7422 5d0a 2020 2020 2020 2020 2020 2020  t"].            
-0000bd80: 5061 7261 6d65 7465 7220 7468 6174 2073  Parameter that s
-0000bd90: 7065 6369 6669 6573 2077 6869 6368 2066  pecifies which f
-0000bda0: 7265 7175 656e 6379 2077 696c 6c20 7365  requency will se
-0000bdb0: 7276 6520 6173 2061 2073 7461 7274 696e  rve as a startin
-0000bdc0: 6720 706f 696e 7420 696e 0a20 2020 2020  g point in.     
-0000bdd0: 2020 2020 2020 2074 6865 2072 656f 7264         the reord
-0000bde0: 6572 696e 6720 7072 6f63 6573 732e 0a20  ering process.. 
-0000bdf0: 2020 2020 2020 206f 7665 726c 6170 5f74         overlap_t
-0000be00: 6872 6573 6820 3a20 666c 6f61 7420 3d20  hresh : float = 
-0000be10: 302e 390a 2020 2020 2020 2020 2020 2020  0.9.            
-0000be20: 4d6f 6461 6c20 6f76 6572 6c61 7020 7468  Modal overlap th
-0000be30: 7265 7368 6f6c 6420 6162 6f76 6520 7768  reshold above wh
-0000be40: 6963 6820 7477 6f20 6d6f 6465 7320 6172  ich two modes ar
-0000be50: 6520 636f 6e73 6964 6572 6564 2074 6f20  e considered to 
-0000be60: 6265 2074 6865 2073 616d 6520 616e 6420  be the same and 
-0000be70: 6172 6520 6e6f 740a 2020 2020 2020 2020  are not.        
-0000be80: 2020 2020 7265 6172 7261 6e67 6564 2e20      rearranged. 
-0000be90: 4966 2061 6674 6572 2074 6865 2073 6f72  If after the sor
-0000bea0: 7469 6e67 2070 726f 6365 6475 7265 2074  ting procedure t
-0000beb0: 6865 206f 7665 726c 6170 2076 616c 7565  he overlap value
-0000bec0: 2062 6574 7765 656e 2074 776f 2063 6f72   between two cor
-0000bed0: 7265 7370 6f6e 6469 6e67 0a20 2020 2020  responding.     
-0000bee0: 2020 2020 2020 206d 6f64 6573 2069 7320         modes is 
-0000bef0: 6c65 7373 2074 6861 6e20 7468 6973 2074  less than this t
-0000bf00: 6872 6573 686f 6c64 2c20 6120 7761 726e  hreshold, a warn
-0000bf10: 696e 6720 6162 6f75 7420 6120 706f 7373  ing about a poss
-0000bf20: 6962 6c65 2064 6973 636f 6e74 696e 7569  ible discontinui
-0000bf30: 7479 2069 730a 2020 2020 2020 2020 2020  ty is.          
-0000bf40: 2020 6469 7370 6c61 7965 642e 0a20 2020    displayed..   
-0000bf50: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-0000bf60: 2069 6620 6c65 6e28 7365 6c66 2e66 6965   if len(self.fie
-0000bf70: 6c64 5f63 6f6d 706f 6e65 6e74 7329 203d  ld_components) =
-0000bf80: 3d20 303a 0a20 2020 2020 2020 2020 2020  = 0:.           
-0000bf90: 2072 6574 7572 6e20 7365 6c66 2e63 6f70   return self.cop
-0000bfa0: 7928 290a 2020 2020 2020 2020 6e75 6d5f  y().        num_
-0000bfb0: 6672 6571 7320 3d20 6c65 6e28 7365 6c66  freqs = len(self
-0000bfc0: 2e6d 6f6e 6974 6f72 2e66 7265 7173 290a  .monitor.freqs).
-0000bfd0: 2020 2020 2020 2020 6e75 6d5f 6d6f 6465          num_mode
-0000bfe0: 7320 3d20 7365 6c66 2e6d 6f6e 6974 6f72  s = self.monitor
-0000bff0: 2e6d 6f64 655f 7370 6563 2e6e 756d 5f6d  .mode_spec.num_m
-0000c000: 6f64 6573 0a0a 2020 2020 2020 2020 6966  odes..        if
-0000c010: 2074 7261 636b 5f66 7265 7120 3d3d 2022   track_freq == "
-0000c020: 6c6f 7765 7374 223a 0a20 2020 2020 2020  lowest":.       
-0000c030: 2020 2020 2066 305f 696e 6420 3d20 300a       f0_ind = 0.
-0000c040: 2020 2020 2020 2020 656c 6966 2074 7261          elif tra
-0000c050: 636b 5f66 7265 7120 3d3d 2022 6869 6768  ck_freq == "high
-0000c060: 6573 7422 3a0a 2020 2020 2020 2020 2020  est":.          
-0000c070: 2020 6630 5f69 6e64 203d 206e 756d 5f66    f0_ind = num_f
-0000c080: 7265 7173 202d 2031 0a20 2020 2020 2020  reqs - 1.       
-0000c090: 2065 6c69 6620 7472 6163 6b5f 6672 6571   elif track_freq
-0000c0a0: 203d 3d20 2263 656e 7472 616c 223a 0a20   == "central":. 
-0000c0b0: 2020 2020 2020 2020 2020 2066 305f 696e             f0_in
-0000c0c0: 6420 3d20 6e75 6d5f 6672 6571 7320 2f2f  d = num_freqs //
-0000c0d0: 2032 0a0a 2020 2020 2020 2020 2320 436f   2..        # Co
-0000c0e0: 6d70 7574 6520 736f 7274 696e 6720 6f72  mpute sorting or
-0000c0f0: 6465 7220 616e 6420 6f76 6572 6c61 7073  der and overlaps
-0000c100: 2077 6974 6820 6e65 6967 6862 6f72 696e   with neighborin
-0000c110: 6720 6672 6571 7565 6e63 6965 730a 2020  g frequencies.  
-0000c120: 2020 2020 2020 736f 7274 696e 6720 3d20        sorting = 
-0000c130: 2d6e 702e 6f6e 6573 2828 6e75 6d5f 6672  -np.ones((num_fr
-0000c140: 6571 732c 206e 756d 5f6d 6f64 6573 292c  eqs, num_modes),
-0000c150: 2064 7479 7065 3d69 6e74 290a 2020 2020   dtype=int).    
-0000c160: 2020 2020 6f76 6572 6c61 7020 3d20 6e70      overlap = np
-0000c170: 2e7a 6572 6f73 2828 6e75 6d5f 6672 6571  .zeros((num_freq
-0000c180: 732c 206e 756d 5f6d 6f64 6573 2929 0a20  s, num_modes)). 
-0000c190: 2020 2020 2020 2070 6861 7365 203d 206e         phase = n
-0000c1a0: 702e 7a65 726f 7328 286e 756d 5f66 7265  p.zeros((num_fre
-0000c1b0: 7173 2c20 6e75 6d5f 6d6f 6465 7329 290a  qs, num_modes)).
-0000c1c0: 2020 2020 2020 2020 736f 7274 696e 675b          sorting[
-0000c1d0: 6630 5f69 6e64 2c20 3a5d 203d 206e 702e  f0_ind, :] = np.
-0000c1e0: 6172 616e 6765 286e 756d 5f6d 6f64 6573  arange(num_modes
-0000c1f0: 2920 2023 2062 6173 6520 6672 6571 7565  )  # base freque
-0000c200: 6e63 7920 776f 6e27 7420 6368 616e 6765  ncy won't change
-0000c210: 0a20 2020 2020 2020 206f 7665 726c 6170  .        overlap
-0000c220: 5b66 305f 696e 642c 203a 5d20 3d20 6e70  [f0_ind, :] = np
-0000c230: 2e6f 6e65 7328 6e75 6d5f 6d6f 6465 7329  .ones(num_modes)
-0000c240: 0a0a 2020 2020 2020 2020 2320 536f 7274  ..        # Sort
-0000c250: 2069 6e20 7477 6f20 6469 7265 6374 696f   in two directio
-0000c260: 6e73 2066 726f 6d20 7468 6520 6261 7365  ns from the base
-0000c270: 2066 7265 7175 656e 6379 0a20 2020 2020   frequency.     
-0000c280: 2020 2066 6f72 2073 7465 702c 206c 6173     for step, las
-0000c290: 745f 696e 6420 696e 207a 6970 285b 2d31  t_ind in zip([-1
-0000c2a0: 2c20 315d 2c20 5b2d 312c 206e 756d 5f66  , 1], [-1, num_f
-0000c2b0: 7265 7173 5d29 3a0a 2020 2020 2020 2020  reqs]):.        
-0000c2c0: 2020 2020 2320 5374 6172 7420 7769 7468      # Start with
-0000c2d0: 2074 6865 2062 6173 6520 6672 6571 7565   the base freque
-0000c2e0: 6e63 790a 2020 2020 2020 2020 2020 2020  ncy.            
-0000c2f0: 6461 7461 5f74 656d 706c 6174 6520 3d20  data_template = 
-0000c300: 7365 6c66 2e5f 6973 656c 2866 3d5b 6630  self._isel(f=[f0
-0000c310: 5f69 6e64 5d29 0a0a 2020 2020 2020 2020  _ind])..        
-0000c320: 2020 2020 2320 4d61 7263 6820 746f 206c      # March to l
-0000c330: 6f77 6572 2f68 6967 6865 7220 6672 6571  ower/higher freq
-0000c340: 7565 6e63 6965 730a 2020 2020 2020 2020  uencies.        
-0000c350: 2020 2020 666f 7220 6672 6571 5f69 6420      for freq_id 
-0000c360: 696e 2072 616e 6765 2866 305f 696e 6420  in range(f0_ind 
-0000c370: 2b20 7374 6570 2c20 6c61 7374 5f69 6e64  + step, last_ind
-0000c380: 2c20 7374 6570 293a 0a20 2020 2020 2020  , step):.       
-0000c390: 2020 2020 2020 2020 2023 2047 6574 206e           # Get n
-0000c3a0: 6578 7420 6672 6571 7565 6e63 7920 746f  ext frequency to
-0000c3b0: 2073 6f72 740a 2020 2020 2020 2020 2020   sort.          
-0000c3c0: 2020 2020 2020 6461 7461 5f74 6f5f 736f        data_to_so
-0000c3d0: 7274 203d 2073 656c 662e 5f69 7365 6c28  rt = self._isel(
-0000c3e0: 663d 5b66 7265 715f 6964 5d29 0a20 2020  f=[freq_id]).   
-0000c3f0: 2020 2020 2020 2020 2020 2020 2023 2041               # A
-0000c400: 7373 6967 6e20 746f 2074 6865 2062 6173  ssign to the bas
-0000c410: 6520 6672 6571 7565 6e63 7920 736f 2074  e frequency so t
-0000c420: 6861 7420 6f75 7465 725f 646f 7420 7769  hat outer_dot wi
-0000c430: 6c6c 2063 6f6d 7061 7265 2074 6865 6d0a  ll compare them.
-0000c440: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c450: 6461 7461 5f74 6f5f 736f 7274 203d 2064  data_to_sort = d
-0000c460: 6174 615f 746f 5f73 6f72 742e 5f61 7373  ata_to_sort._ass
-0000c470: 6967 6e5f 636f 6f72 6473 2866 3d5b 7365  ign_coords(f=[se
-0000c480: 6c66 2e6d 6f6e 6974 6f72 2e66 7265 7173  lf.monitor.freqs
-0000c490: 5b66 305f 696e 645d 5d29 0a0a 2020 2020  [f0_ind]])..    
-0000c4a0: 2020 2020 2020 2020 2020 2020 2320 436f              # Co
-0000c4b0: 6d70 7574 6520 2273 6f72 7469 6e67 2077  mpute "sorting w
-0000c4c0: 2e72 2e74 2e20 746f 206e 6569 6768 626f  .r.t. to neighbo
-0000c4d0: 7222 2061 6e64 206f 7665 726c 6170 2076  r" and overlap v
-0000c4e0: 616c 7565 730a 0a20 2020 2020 2020 2020  alues..         
-0000c4f0: 2020 2020 2020 2073 6f72 7469 6e67 5f6f         sorting_o
-0000c500: 6e65 5f6d 6f64 652c 2061 6d70 735f 6f6e  ne_mode, amps_on
-0000c510: 655f 6d6f 6465 203d 2064 6174 615f 7465  e_mode = data_te
-0000c520: 6d70 6c61 7465 2e5f 6669 6e64 5f6f 7264  mplate._find_ord
-0000c530: 6572 696e 675f 6f6e 655f 6672 6571 280a  ering_one_freq(.
-0000c540: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c550: 2020 2020 6461 7461 5f74 6f5f 736f 7274      data_to_sort
-0000c560: 2c20 6f76 6572 6c61 705f 7468 7265 7368  , overlap_thresh
-0000c570: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000c580: 2029 0a0a 2020 2020 2020 2020 2020 2020   )..            
-0000c590: 2020 2020 2320 5472 616e 7366 6f72 6d20      # Transform 
-0000c5a0: 2273 6f72 7469 6e67 2077 2e72 2e74 2e20  "sorting w.r.t. 
-0000c5b0: 6e65 6967 6862 6f72 2220 746f 2022 736f  neighbor" to "so
-0000c5c0: 7274 696e 6720 772e 722e 742e 2074 6f20  rting w.r.t. to 
-0000c5d0: 6630 5f69 6e64 220a 2020 2020 2020 2020  f0_ind".        
-0000c5e0: 2020 2020 2020 2020 736f 7274 696e 675b          sorting[
-0000c5f0: 6672 6571 5f69 642c 203a 5d20 3d20 736f  freq_id, :] = so
-0000c600: 7274 696e 675f 6f6e 655f 6d6f 6465 5b73  rting_one_mode[s
-0000c610: 6f72 7469 6e67 5b66 7265 715f 6964 202d  orting[freq_id -
-0000c620: 2073 7465 702c 203a 5d5d 0a20 2020 2020   step, :]].     
-0000c630: 2020 2020 2020 2020 2020 206f 7665 726c             overl
-0000c640: 6170 5b66 7265 715f 6964 2c20 3a5d 203d  ap[freq_id, :] =
-0000c650: 206e 702e 6162 7328 616d 7073 5f6f 6e65   np.abs(amps_one
-0000c660: 5f6d 6f64 655b 736f 7274 696e 675b 6672  _mode[sorting[fr
-0000c670: 6571 5f69 6420 2d20 7374 6570 2c20 3a5d  eq_id - step, :]
-0000c680: 5d29 0a20 2020 2020 2020 2020 2020 2020  ]).             
-0000c690: 2020 2070 6861 7365 5b66 7265 715f 6964     phase[freq_id
-0000c6a0: 2c20 3a5d 203d 2070 6861 7365 5b66 7265  , :] = phase[fre
-0000c6b0: 715f 6964 202d 2073 7465 702c 203a 5d20  q_id - step, :] 
-0000c6c0: 2b20 6e70 2e61 6e67 6c65 280a 2020 2020  + np.angle(.    
+00000350: 615f 6172 7261 7920 696d 706f 7274 2045  a_array import E
+00000360: 4d45 4672 6571 4d6f 6465 4461 7461 4172  MEFreqModeDataAr
+00000370: 7261 790a 6672 6f6d 202e 6461 7461 7365  ray.from .datase
+00000380: 7420 696d 706f 7274 2044 6174 6173 6574  t import Dataset
+00000390: 2c20 4162 7374 7261 6374 4669 656c 6444  , AbstractFieldD
+000003a0: 6174 6173 6574 2c20 456c 6563 7472 6f6d  ataset, Electrom
+000003b0: 6167 6e65 7469 6346 6965 6c64 4461 7461  agneticFieldData
+000003c0: 7365 740a 6672 6f6d 202e 6461 7461 7365  set.from .datase
+000003d0: 7420 696d 706f 7274 2046 6965 6c64 4461  t import FieldDa
+000003e0: 7461 7365 742c 2046 6965 6c64 5469 6d65  taset, FieldTime
+000003f0: 4461 7461 7365 742c 204d 6f64 6553 6f6c  Dataset, ModeSol
+00000400: 7665 7244 6174 6173 6574 2c20 5065 726d  verDataset, Perm
+00000410: 6974 7469 7669 7479 4461 7461 7365 740a  ittivityDataset.
+00000420: 6672 6f6d 202e 2e62 6173 6520 696d 706f  from ..base impo
+00000430: 7274 2054 5950 455f 5441 475f 5354 522c  rt TYPE_TAG_STR,
+00000440: 2063 6163 6865 645f 7072 6f70 6572 7479   cached_property
+00000450: 2c20 736b 6970 5f69 665f 6669 656c 6473  , skip_if_fields
+00000460: 5f6d 6973 7369 6e67 0a66 726f 6d20 2e2e  _missing.from ..
+00000470: 7479 7065 7320 696d 706f 7274 2043 6f6f  types import Coo
+00000480: 7264 696e 6174 652c 2053 796d 6d65 7472  rdinate, Symmetr
+00000490: 792c 2041 7272 6179 466c 6f61 7431 442c  y, ArrayFloat1D,
+000004a0: 2041 7272 6179 466c 6f61 7432 442c 2053   ArrayFloat2D, S
+000004b0: 697a 652c 204e 756d 7079 2c20 5472 6163  ize, Numpy, Trac
+000004c0: 6b46 7265 710a 6672 6f6d 202e 2e74 7970  kFreq.from ..typ
+000004d0: 6573 2069 6d70 6f72 7420 4570 7353 7065  es import EpsSpe
+000004e0: 6354 7970 652c 204c 6974 6572 616c 0a66  cType, Literal.f
+000004f0: 726f 6d20 2e2e 6772 6964 2e67 7269 6420  rom ..grid.grid 
+00000500: 696d 706f 7274 2047 7269 642c 2043 6f6f  import Grid, Coo
+00000510: 7264 730a 6672 6f6d 202e 2e76 616c 6964  rds.from ..valid
+00000520: 6174 6f72 7320 696d 706f 7274 2065 6e66  ators import enf
+00000530: 6f72 6365 5f6d 6f6e 6974 6f72 5f66 6965  orce_monitor_fie
+00000540: 6c64 735f 7072 6573 656e 742c 2072 6571  lds_present, req
+00000550: 7569 7265 645f 6966 5f73 796d 6d65 7472  uired_if_symmetr
+00000560: 795f 7072 6573 656e 740a 6672 6f6d 202e  y_present.from .
+00000570: 2e6d 6f6e 6974 6f72 2069 6d70 6f72 7420  .monitor import 
+00000580: 4d6f 6e69 746f 7254 7970 652c 2046 6965  MonitorType, Fie
+00000590: 6c64 4d6f 6e69 746f 722c 2046 6965 6c64  ldMonitor, Field
+000005a0: 5469 6d65 4d6f 6e69 746f 722c 204d 6f64  TimeMonitor, Mod
+000005b0: 6553 6f6c 7665 724d 6f6e 6974 6f72 0a66  eSolverMonitor.f
+000005c0: 726f 6d20 2e2e 6d6f 6e69 746f 7220 696d  rom ..monitor im
+000005d0: 706f 7274 204d 6f64 654d 6f6e 6974 6f72  port ModeMonitor
+000005e0: 2c20 466c 7578 4d6f 6e69 746f 722c 2046  , FluxMonitor, F
+000005f0: 6c75 7854 696d 654d 6f6e 6974 6f72 2c20  luxTimeMonitor, 
+00000600: 5065 726d 6974 7469 7669 7479 4d6f 6e69  PermittivityMoni
+00000610: 746f 720a 6672 6f6d 202e 2e6d 6f6e 6974  tor.from ..monit
+00000620: 6f72 2069 6d70 6f72 7420 4669 656c 6450  or import FieldP
+00000630: 726f 6a65 6374 696f 6e41 6e67 6c65 4d6f  rojectionAngleMo
+00000640: 6e69 746f 722c 2046 6965 6c64 5072 6f6a  nitor, FieldProj
+00000650: 6563 7469 6f6e 4361 7274 6573 6961 6e4d  ectionCartesianM
+00000660: 6f6e 6974 6f72 0a66 726f 6d20 2e2e 6d6f  onitor.from ..mo
+00000670: 6e69 746f 7220 696d 706f 7274 2046 6965  nitor import Fie
+00000680: 6c64 5072 6f6a 6563 7469 6f6e 4b53 7061  ldProjectionKSpa
+00000690: 6365 4d6f 6e69 746f 722c 2046 6965 6c64  ceMonitor, Field
+000006a0: 5072 6f6a 6563 7469 6f6e 5375 7266 6163  ProjectionSurfac
+000006b0: 650a 6672 6f6d 202e 2e6d 6f6e 6974 6f72  e.from ..monitor
+000006c0: 2069 6d70 6f72 7420 4469 6666 7261 6374   import Diffract
+000006d0: 696f 6e4d 6f6e 6974 6f72 0a66 726f 6d20  ionMonitor.from 
+000006e0: 2e2e 736f 7572 6365 2069 6d70 6f72 7420  ..source import 
+000006f0: 536f 7572 6365 5469 6d65 5479 7065 2c20  SourceTimeType, 
+00000700: 4375 7374 6f6d 4669 656c 6453 6f75 7263  CustomFieldSourc
+00000710: 650a 6672 6f6d 202e 2e6d 6564 6975 6d20  e.from ..medium 
+00000720: 696d 706f 7274 204d 6564 6975 6d2c 204d  import Medium, M
+00000730: 6564 6975 6d54 7970 650a 6672 6f6d 202e  ediumType.from .
+00000740: 2e2e 6578 6365 7074 696f 6e73 2069 6d70  ..exceptions imp
+00000750: 6f72 7420 5365 7475 7045 7272 6f72 2c20  ort SetupError, 
+00000760: 4461 7461 4572 726f 722c 2054 6964 7933  DataError, Tidy3
+00000770: 644e 6f74 496d 706c 656d 656e 7465 6445  dNotImplementedE
+00000780: 7272 6f72 2c20 5661 6c69 6461 7469 6f6e  rror, Validation
+00000790: 4572 726f 720a 6672 6f6d 202e 2e2e 636f  Error.from ...co
+000007a0: 6e73 7461 6e74 7320 696d 706f 7274 2045  nstants import E
+000007b0: 5441 5f30 2c20 435f 302c 204d 4943 524f  TA_0, C_0, MICRO
+000007c0: 4d45 5445 520a 6672 6f6d 202e 2e2e 6c6f  METER.from ...lo
+000007d0: 6720 696d 706f 7274 206c 6f67 0a0a 6672  g import log..fr
+000007e0: 6f6d 202e 2e62 6173 655f 7369 6d2e 6461  om ..base_sim.da
+000007f0: 7461 2e6d 6f6e 6974 6f72 5f64 6174 6120  ta.monitor_data 
+00000800: 696d 706f 7274 2041 6273 7472 6163 744d  import AbstractM
+00000810: 6f6e 6974 6f72 4461 7461 0a0a 436f 6f72  onitorData..Coor
+00000820: 6473 3144 203d 2041 7272 6179 466c 6f61  ds1D = ArrayFloa
+00000830: 7431 440a 0a0a 636c 6173 7320 4d6f 6e69  t1D...class Moni
+00000840: 746f 7244 6174 6128 4162 7374 7261 6374  torData(Abstract
+00000850: 4d6f 6e69 746f 7244 6174 612c 2041 4243  MonitorData, ABC
+00000860: 293a 0a20 2020 2022 2222 0a20 2020 2041  ):.    """.    A
+00000870: 6273 7472 6163 7420 6261 7365 2063 6c61  bstract base cla
+00000880: 7373 206f 6620 6f62 6a65 6374 7320 7468  ss of objects th
+00000890: 6174 2073 746f 7265 2064 6174 6120 7065  at store data pe
+000008a0: 7274 6169 6e69 6e67 2074 6f20 6120 7369  rtaining to a si
+000008b0: 6e67 6c65 203a 636c 6173 733a 602e 6d6f  ngle :class:`.mo
+000008c0: 6e69 746f 7260 2e0a 2020 2020 2222 220a  nitor`..    """.
+000008d0: 0a20 2020 206d 6f6e 6974 6f72 3a20 4d6f  .    monitor: Mo
+000008e0: 6e69 746f 7254 7970 6520 3d20 7064 2e46  nitorType = pd.F
+000008f0: 6965 6c64 280a 2020 2020 2020 2020 2e2e  ield(.        ..
+00000900: 2e2c 0a20 2020 2020 2020 2074 6974 6c65  .,.        title
+00000910: 3d22 4d6f 6e69 746f 7222 2c0a 2020 2020  ="Monitor",.    
+00000920: 2020 2020 6465 7363 7269 7074 696f 6e3d      description=
+00000930: 224d 6f6e 6974 6f72 2061 7373 6f63 6961  "Monitor associa
+00000940: 7465 6420 7769 7468 2074 6865 2064 6174  ted with the dat
+00000950: 612e 222c 0a20 2020 2020 2020 2064 6973  a.",.        dis
+00000960: 6372 696d 696e 6174 6f72 3d54 5950 455f  criminator=TYPE_
+00000970: 5441 475f 5354 522c 0a20 2020 2029 0a0a  TAG_STR,.    )..
+00000980: 2020 2020 4070 726f 7065 7274 790a 2020      @property.  
+00000990: 2020 6465 6620 7379 6d6d 6574 7279 5f65    def symmetry_e
+000009a0: 7870 616e 6465 6428 7365 6c66 2920 2d3e  xpanded(self) ->
+000009b0: 204d 6f6e 6974 6f72 4461 7461 3a0a 2020   MonitorData:.  
+000009c0: 2020 2020 2020 2222 2252 6574 7572 6e20        """Return 
+000009d0: 7365 6c66 2077 6974 6820 7379 6d6d 6574  self with symmet
+000009e0: 7279 2061 7070 6c69 6564 2e22 2222 0a20  ry applied.""". 
+000009f0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+00000a00: 6c66 0a0a 2020 2020 6465 6620 6e6f 726d  lf..    def norm
+00000a10: 616c 697a 6528 7365 6c66 2c20 736f 7572  alize(self, sour
+00000a20: 6365 5f73 7065 6374 7275 6d5f 666e 3a20  ce_spectrum_fn: 
+00000a30: 4361 6c6c 6162 6c65 5b5b 666c 6f61 745d  Callable[[float]
+00000a40: 2c20 636f 6d70 6c65 785d 2920 2d3e 2044  , complex]) -> D
+00000a50: 6174 6173 6574 3a0a 2020 2020 2020 2020  ataset:.        
+00000a60: 2222 2252 6574 7572 6e20 636f 7079 206f  """Return copy o
+00000a70: 6620 7365 6c66 2061 6674 6572 206e 6f72  f self after nor
+00000a80: 6d61 6c69 7a61 7469 6f6e 2069 7320 6170  malization is ap
+00000a90: 706c 6965 6420 7573 696e 6720 736f 7572  plied using sour
+00000aa0: 6365 2073 7065 6374 7275 6d20 6675 6e63  ce spectrum func
+00000ab0: 7469 6f6e 2e22 2222 0a20 2020 2020 2020  tion.""".       
+00000ac0: 2072 6574 7572 6e20 7365 6c66 2e63 6f70   return self.cop
+00000ad0: 7928 290a 0a20 2020 2064 6566 205f 7570  y()..    def _up
+00000ae0: 6461 7465 6428 7365 6c66 2c20 7570 6461  dated(self, upda
+00000af0: 7465 3a20 4469 6374 2920 2d3e 204d 6f6e  te: Dict) -> Mon
+00000b00: 6974 6f72 4461 7461 3a0a 2020 2020 2020  itorData:.      
+00000b10: 2020 2222 2253 696d 696c 6172 2074 6f20    """Similar to 
+00000b20: 6060 7570 6461 7465 645f 636f 7079 6060  ``updated_copy``
+00000b30: 2c20 6275 7420 646f 6573 206e 6f74 2061  , but does not a
+00000b40: 6374 7561 6c6c 7920 636f 7079 2063 6f6d  ctually copy com
+00000b50: 706f 6e65 6e74 732c 2066 6f72 2073 7065  ponents, for spe
+00000b60: 6564 2e0a 0a20 2020 2020 2020 204e 6f74  ed...        Not
+00000b70: 650a 2020 2020 2020 2020 2d2d 2d2d 0a20  e.        ----. 
+00000b80: 2020 2020 2020 2020 2020 2054 6869 7320             This 
+00000b90: 646f 6573 202a 2a6e 6f74 2a2a 2070 726f  does **not** pro
+00000ba0: 6475 6365 2061 2063 6f70 7920 6f66 206d  duce a copy of m
+00000bb0: 7574 6162 6c65 206f 626a 6563 7473 2c20  utable objects, 
+00000bc0: 736f 2065 2e67 2e20 6966 2073 6f6d 6520  so e.g. if some 
+00000bd0: 6f66 2074 6865 2064 6174 6120 6172 7261  of the data arra
+00000be0: 7973 0a20 2020 2020 2020 2020 2020 2061  ys.            a
+00000bf0: 7265 206e 6f74 2075 7064 6174 6564 2c20  re not updated, 
+00000c00: 7468 6579 2077 696c 6c20 706f 696e 7420  they will point 
+00000c10: 746f 2074 6865 2076 616c 7565 7320 696e  to the values in
+00000c20: 2074 6865 206f 7269 6769 6e61 6c20 6461   the original da
+00000c30: 7461 2e20 5468 6973 206d 6574 686f 6420  ta. This method 
+00000c40: 7368 6f75 6c64 0a20 2020 2020 2020 2020  should.         
+00000c50: 2020 2074 6875 7320 6265 2075 7365 6420     thus be used 
+00000c60: 6361 7265 6675 6c6c 792e 0a0a 2020 2020  carefully...    
+00000c70: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00000c80: 6461 7461 5f64 6963 7420 3d20 7365 6c66  data_dict = self
+00000c90: 2e64 6963 7428 290a 2020 2020 2020 2020  .dict().        
+00000ca0: 6461 7461 5f64 6963 742e 7570 6461 7465  data_dict.update
+00000cb0: 2875 7064 6174 6529 0a20 2020 2020 2020  (update).       
+00000cc0: 2072 6574 7572 6e20 7479 7065 2873 656c   return type(sel
+00000cd0: 6629 2e70 6172 7365 5f6f 626a 2864 6174  f).parse_obj(dat
+00000ce0: 615f 6469 6374 290a 0a0a 636c 6173 7320  a_dict)...class 
+00000cf0: 4162 7374 7261 6374 4669 656c 6444 6174  AbstractFieldDat
+00000d00: 6128 4d6f 6e69 746f 7244 6174 612c 2041  a(MonitorData, A
+00000d10: 6273 7472 6163 7446 6965 6c64 4461 7461  bstractFieldData
+00000d20: 7365 742c 2041 4243 293a 0a20 2020 2022  set, ABC):.    "
+00000d30: 2222 436f 6c6c 6563 7469 6f6e 206f 6620  ""Collection of 
+00000d40: 7363 616c 6172 2066 6965 6c64 7320 7769  scalar fields wi
+00000d50: 7468 2073 6f6d 6520 7379 6d6d 6574 7279  th some symmetry
+00000d60: 2070 726f 7065 7274 6965 732e 2222 220a   properties.""".
+00000d70: 0a20 2020 206d 6f6e 6974 6f72 3a20 556e  .    monitor: Un
+00000d80: 696f 6e5b 4669 656c 644d 6f6e 6974 6f72  ion[FieldMonitor
+00000d90: 2c20 4669 656c 6454 696d 654d 6f6e 6974  , FieldTimeMonit
+00000da0: 6f72 2c20 5065 726d 6974 7469 7669 7479  or, Permittivity
+00000db0: 4d6f 6e69 746f 722c 204d 6f64 654d 6f6e  Monitor, ModeMon
+00000dc0: 6974 6f72 5d0a 0a20 2020 2073 796d 6d65  itor]..    symme
+00000dd0: 7472 793a 2054 7570 6c65 5b53 796d 6d65  try: Tuple[Symme
+00000de0: 7472 792c 2053 796d 6d65 7472 792c 2053  try, Symmetry, S
+00000df0: 796d 6d65 7472 795d 203d 2070 642e 4669  ymmetry] = pd.Fi
+00000e00: 656c 6428 0a20 2020 2020 2020 2028 302c  eld(.        (0,
+00000e10: 2030 2c20 3029 2c0a 2020 2020 2020 2020   0, 0),.        
+00000e20: 7469 746c 653d 2253 796d 6d65 7472 7922  title="Symmetry"
+00000e30: 2c0a 2020 2020 2020 2020 6465 7363 7269  ,.        descri
+00000e40: 7074 696f 6e3d 2253 796d 6d65 7472 7920  ption="Symmetry 
+00000e50: 6569 6765 6e76 616c 7565 7320 6f66 2074  eigenvalues of t
+00000e60: 6865 206f 7269 6769 6e61 6c20 7369 6d75  he original simu
+00000e70: 6c61 7469 6f6e 2069 6e20 782c 2079 2c20  lation in x, y, 
+00000e80: 616e 6420 7a2e 222c 0a20 2020 2029 0a0a  and z.",.    )..
+00000e90: 2020 2020 7379 6d6d 6574 7279 5f63 656e      symmetry_cen
+00000ea0: 7465 723a 2043 6f6f 7264 696e 6174 6520  ter: Coordinate 
+00000eb0: 3d20 7064 2e46 6965 6c64 280a 2020 2020  = pd.Field(.    
+00000ec0: 2020 2020 4e6f 6e65 2c0a 2020 2020 2020      None,.      
+00000ed0: 2020 7469 746c 653d 2253 796d 6d65 7472    title="Symmetr
+00000ee0: 7920 4365 6e74 6572 222c 0a20 2020 2020  y Center",.     
+00000ef0: 2020 2064 6573 6372 6970 7469 6f6e 3d22     description="
+00000f00: 4365 6e74 6572 206f 6620 7468 6520 7379  Center of the sy
+00000f10: 6d6d 6574 7279 2070 6c61 6e65 7320 6f66  mmetry planes of
+00000f20: 2074 6865 206f 7269 6769 6e61 6c20 7369   the original si
+00000f30: 6d75 6c61 7469 6f6e 2069 6e20 782c 2079  mulation in x, y
+00000f40: 2c20 616e 6420 7a2e 2022 0a20 2020 2020  , and z. ".     
+00000f50: 2020 2022 5265 7175 6972 6564 206f 6e6c     "Required onl
+00000f60: 7920 6966 2061 6e79 206f 6620 7468 6520  y if any of the 
+00000f70: 6060 7379 6d6d 6574 7279 6060 2066 6965  ``symmetry`` fie
+00000f80: 6c64 2061 7265 206e 6f6e 2d7a 6572 6f2e  ld are non-zero.
+00000f90: 222c 0a20 2020 2029 0a20 2020 2067 7269  ",.    ).    gri
+00000fa0: 645f 6578 7061 6e64 6564 3a20 4772 6964  d_expanded: Grid
+00000fb0: 203d 2070 642e 4669 656c 6428 0a20 2020   = pd.Field(.   
+00000fc0: 2020 2020 204e 6f6e 652c 0a20 2020 2020       None,.     
+00000fd0: 2020 2074 6974 6c65 3d22 4578 7061 6e64     title="Expand
+00000fe0: 6564 2047 7269 6422 2c0a 2020 2020 2020  ed Grid",.      
+00000ff0: 2020 6465 7363 7269 7074 696f 6e3d 223a    description=":
+00001000: 636c 6173 733a 602e 4772 6964 6020 6469  class:`.Grid` di
+00001010: 7363 7265 7469 7a61 7469 6f6e 206f 6620  scretization of 
+00001020: 7468 6520 6173 736f 6369 6174 6564 206d  the associated m
+00001030: 6f6e 6974 6f72 2069 6e20 7468 6520 7369  onitor in the si
+00001040: 6d75 6c61 7469 6f6e 2022 0a20 2020 2020  mulation ".     
+00001050: 2020 2022 7768 6963 6820 6372 6561 7465     "which create
+00001060: 6420 7468 6520 6461 7461 2e20 5265 7175  d the data. Requ
+00001070: 6972 6564 2069 6620 7379 6d6d 6574 7269  ired if symmetri
+00001080: 6573 2061 7265 2070 7265 7365 6e74 2c20  es are present, 
+00001090: 6173 2022 0a20 2020 2020 2020 2022 7765  as ".        "we
+000010a0: 6c6c 2061 7320 696e 206f 7264 6572 2074  ll as in order t
+000010b0: 6f20 7573 6520 736f 6d65 2066 756e 6374  o use some funct
+000010c0: 696f 6e61 6c69 7469 6573 206c 696b 6520  ionalities like 
+000010d0: 6765 7474 696e 6720 506f 796e 7469 6e67  getting Poynting
+000010e0: 2076 6563 746f 7220 616e 6420 666c 7578   vector and flux
+000010f0: 2e22 2c0a 2020 2020 290a 0a20 2020 2040  .",.    )..    @
+00001100: 7064 2e76 616c 6964 6174 6f72 2822 6772  pd.validator("gr
+00001110: 6964 5f65 7870 616e 6465 6422 2c20 616c  id_expanded", al
+00001120: 7761 7973 3d54 7275 6529 0a20 2020 2064  ways=True).    d
+00001130: 6566 2077 6172 6e5f 6d69 7373 696e 675f  ef warn_missing_
+00001140: 6772 6964 5f65 7870 616e 6465 6428 636c  grid_expanded(cl
+00001150: 732c 2076 616c 2c20 7661 6c75 6573 293a  s, val, values):
+00001160: 0a20 2020 2020 2020 2022 2222 4966 2060  .        """If `
+00001170: 6067 7269 645f 6578 7061 6e64 6564 6060  `grid_expanded``
+00001180: 206e 6f74 2070 726f 7669 6465 6420 616e   not provided an
+00001190: 6420 6669 656c 6473 2064 6174 6120 6973  d fields data is
+000011a0: 2070 7265 7365 6e74 2c20 7761 726e 2074   present, warn t
+000011b0: 6861 7420 736f 6d65 206d 6574 686f 6473  hat some methods
+000011c0: 0a20 2020 2020 2020 2077 696c 6c20 6272  .        will br
+000011d0: 6561 6b2e 2222 220a 2020 2020 2020 2020  eak.""".        
+000011e0: 6669 656c 645f 636f 6d70 7320 3d20 5b22  field_comps = ["
+000011f0: 4578 222c 2022 4579 222c 2022 457a 222c  Ex", "Ey", "Ez",
+00001200: 2022 4878 222c 2022 4879 222c 2022 487a   "Hx", "Hy", "Hz
+00001210: 225d 0a20 2020 2020 2020 2069 6620 7661  "].        if va
+00001220: 6c20 6973 204e 6f6e 6520 616e 6420 616e  l is None and an
+00001230: 7928 7661 6c75 6573 2e67 6574 2863 6f6d  y(values.get(com
+00001240: 7029 2069 7320 6e6f 7420 4e6f 6e65 2066  p) is not None f
+00001250: 6f72 2063 6f6d 7020 696e 2066 6965 6c64  or comp in field
+00001260: 5f63 6f6d 7073 293a 0a20 2020 2020 2020  _comps):.       
+00001270: 2020 2020 206c 6f67 2e77 6172 6e69 6e67       log.warning
+00001280: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00001290: 2020 224d 6f6e 6974 6f72 2064 6174 6120    "Monitor data 
+000012a0: 7265 7175 6972 6573 2027 6772 6964 5f65  requires 'grid_e
+000012b0: 7870 616e 6465 6427 2074 6f20 6265 2064  xpanded' to be d
+000012c0: 6566 696e 6564 2074 6f20 636f 6d70 7574  efined to comput
+000012d0: 6520 7661 6c75 6573 206c 696b 6520 220a  e values like ".
+000012e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000012f0: 2266 6c75 782c 2050 6f79 6e74 696e 6720  "flux, Poynting 
+00001300: 616e 6420 646f 7420 7072 6f64 7563 7420  and dot product 
+00001310: 7769 7468 206f 7468 6572 2064 6174 612e  with other data.
+00001320: 220a 2020 2020 2020 2020 2020 2020 290a  ".            ).
+00001330: 2020 2020 2020 2020 7265 7475 726e 2076          return v
+00001340: 616c 0a0a 2020 2020 5f72 6571 7569 7265  al..    _require
+00001350: 5f73 796d 5f63 656e 7465 7220 3d20 7265  _sym_center = re
+00001360: 7175 6972 6564 5f69 665f 7379 6d6d 6574  quired_if_symmet
+00001370: 7279 5f70 7265 7365 6e74 2822 7379 6d6d  ry_present("symm
+00001380: 6574 7279 5f63 656e 7465 7222 290a 2020  etry_center").  
+00001390: 2020 5f72 6571 7569 7265 5f67 7269 645f    _require_grid_
+000013a0: 6578 7061 6e64 6564 203d 2072 6571 7569  expanded = requi
+000013b0: 7265 645f 6966 5f73 796d 6d65 7472 795f  red_if_symmetry_
+000013c0: 7072 6573 656e 7428 2267 7269 645f 6578  present("grid_ex
+000013d0: 7061 6e64 6564 2229 0a0a 2020 2020 6465  panded")..    de
+000013e0: 6620 5f65 7870 616e 6465 645f 6772 6964  f _expanded_grid
+000013f0: 5f66 6965 6c64 5f63 6f6f 7264 7328 7365  _field_coords(se
+00001400: 6c66 2c20 6669 656c 645f 6e61 6d65 3a20  lf, field_name: 
+00001410: 7374 7229 202d 3e20 436f 6f72 6473 3a0a  str) -> Coords:.
+00001420: 2020 2020 2020 2020 2222 2243 6f6f 7264          """Coord
+00001430: 696e 6174 6573 2069 6e20 7468 6520 6578  inates in the ex
+00001440: 7061 6e64 6564 2067 7269 6420 636f 7272  panded grid corr
+00001450: 6573 706f 6e64 696e 6720 746f 2061 2067  esponding to a g
+00001460: 6976 656e 2066 6965 6c64 2063 6f6d 706f  iven field compo
+00001470: 6e65 6e74 2e22 2222 0a20 2020 2020 2020  nent.""".       
+00001480: 2072 6574 7572 6e20 7365 6c66 2e67 7269   return self.gri
+00001490: 645f 6578 7061 6e64 6564 5b73 656c 662e  d_expanded[self.
+000014a0: 6772 6964 5f6c 6f63 6174 696f 6e73 5b66  grid_locations[f
+000014b0: 6965 6c64 5f6e 616d 655d 5d0a 0a20 2020  ield_name]]..   
+000014c0: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
+000014d0: 6566 2073 796d 6d65 7472 795f 6578 7061  ef symmetry_expa
+000014e0: 6e64 6564 2873 656c 6629 3a0a 2020 2020  nded(self):.    
+000014f0: 2020 2020 2222 2252 6574 7572 6e20 7468      """Return th
+00001500: 6520 3a63 6c61 7373 3a60 2e41 6273 7472  e :class:`.Abstr
+00001510: 6163 7446 6965 6c64 4461 7461 6020 7769  actFieldData` wi
+00001520: 7468 2066 6965 6c64 7320 6578 7061 6e64  th fields expand
+00001530: 6564 2062 6173 6564 206f 6e20 7379 6d6d  ed based on symm
+00001540: 6574 7279 2e20 4966 0a20 2020 2020 2020  etry. If.       
+00001550: 2061 6e79 2073 796d 6d65 7472 7920 6973   any symmetry is
+00001560: 206e 6f6e 7a65 726f 2028 692e 652e 2065   nonzero (i.e. e
+00001570: 7870 616e 6465 6429 2c20 7468 6520 696e  xpanded), the in
+00001580: 7465 7270 6f6c 6174 696f 6e20 696d 706c  terpolation impl
+00001590: 6963 6974 6c79 2063 7265 6174 6573 2061  icitly creates a
+000015a0: 2063 6f70 7920 6f66 2074 6865 0a20 2020   copy of the.   
+000015b0: 2020 2020 2064 6174 6120 6172 7261 792e       data array.
+000015c0: 2048 6f77 6576 6572 2c20 6966 2073 796d   However, if sym
+000015d0: 6d65 7472 7920 6973 206e 6f74 2065 7870  metry is not exp
+000015e0: 616e 6465 642c 2074 6865 2072 6574 7572  anded, the retur
+000015f0: 6e65 6420 6172 7261 7920 636f 6e74 6169  ned array contai
+00001600: 6e73 2061 2076 6965 7720 6f66 0a20 2020  ns a view of.   
+00001610: 2020 2020 2074 6865 2064 6174 612c 206e       the data, n
+00001620: 6f74 2061 2063 6f70 792e 0a0a 2020 2020  ot a copy...    
+00001630: 2020 2020 5265 7475 726e 730a 2020 2020      Returns.    
+00001640: 2020 2020 2d2d 2d2d 2d2d 2d0a 2020 2020      -------.    
+00001650: 2020 2020 3a63 6c61 7373 3a60 4162 7374      :class:`Abst
+00001660: 7261 6374 4669 656c 6444 6174 6160 0a20  ractFieldData`. 
+00001670: 2020 2020 2020 2020 2020 2041 2064 6174             A dat
+00001680: 6120 6f62 6a65 6374 2077 6974 6820 7468  a object with th
+00001690: 6520 7379 6d6d 6574 7279 2065 7870 616e  e symmetry expan
+000016a0: 6465 6420 6669 656c 6473 2e0a 2020 2020  ded fields..    
+000016b0: 2020 2020 2222 220a 0a20 2020 2020 2020      """..       
+000016c0: 2069 6620 616c 6c28 7379 6d20 3d3d 2030   if all(sym == 0
+000016d0: 2066 6f72 2073 796d 2069 6e20 7365 6c66   for sym in self
+000016e0: 2e73 796d 6d65 7472 7929 3a0a 2020 2020  .symmetry):.    
+000016f0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+00001700: 656c 660a 0a20 2020 2020 2020 2072 6574  elf..        ret
+00001710: 7572 6e20 7365 6c66 2e5f 7570 6461 7465  urn self._update
+00001720: 6428 7365 6c66 2e5f 7379 6d6d 6574 7279  d(self._symmetry
+00001730: 5f75 7064 6174 655f 6469 6374 290a 0a20  _update_dict).. 
+00001740: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
+00001750: 2064 6566 2073 796d 6d65 7472 795f 6578   def symmetry_ex
+00001760: 7061 6e64 6564 5f63 6f70 7928 7365 6c66  panded_copy(self
+00001770: 2920 2d3e 2041 6273 7472 6163 7446 6965  ) -> AbstractFie
+00001780: 6c64 4461 7461 3a0a 2020 2020 2020 2020  ldData:.        
+00001790: 2222 2243 7265 6174 6520 6120 636f 7079  """Create a copy
+000017a0: 206f 6620 7468 6520 3a63 6c61 7373 3a60   of the :class:`
+000017b0: 2e41 6273 7472 6163 7446 6965 6c64 4461  .AbstractFieldDa
+000017c0: 7461 6020 7769 7468 2066 6965 6c64 7320  ta` with fields 
+000017d0: 6578 7061 6e64 6564 2062 6173 6564 206f  expanded based o
+000017e0: 6e20 7379 6d6d 6574 7279 2e0a 0a20 2020  n symmetry...   
+000017f0: 2020 2020 2052 6574 7572 6e73 0a20 2020       Returns.   
+00001800: 2020 2020 202d 2d2d 2d2d 2d2d 0a20 2020       -------.   
+00001810: 2020 2020 203a 636c 6173 733a 6041 6273       :class:`Abs
+00001820: 7472 6163 7446 6965 6c64 4461 7461 600a  tractFieldData`.
+00001830: 2020 2020 2020 2020 2020 2020 4120 6461              A da
+00001840: 7461 206f 626a 6563 7420 7769 7468 2074  ta object with t
+00001850: 6865 2073 796d 6d65 7472 7920 6578 7061  he symmetry expa
+00001860: 6e64 6564 2066 6965 6c64 732e 0a20 2020  nded fields..   
+00001870: 2020 2020 2022 2222 0a0a 2020 2020 2020       """..      
+00001880: 2020 6966 2061 6c6c 2873 796d 203d 3d20    if all(sym == 
+00001890: 3020 666f 7220 7379 6d20 696e 2073 656c  0 for sym in sel
+000018a0: 662e 7379 6d6d 6574 7279 293a 0a20 2020  f.symmetry):.   
+000018b0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+000018c0: 7365 6c66 2e63 6f70 7928 290a 0a20 2020  self.copy()..   
+000018d0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+000018e0: 2e63 6f70 7928 7570 6461 7465 3d73 656c  .copy(update=sel
+000018f0: 662e 5f73 796d 6d65 7472 795f 7570 6461  f._symmetry_upda
+00001900: 7465 5f64 6963 7429 0a0a 2020 2020 4070  te_dict)..    @p
+00001910: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
+00001920: 5f73 796d 6d65 7472 795f 7570 6461 7465  _symmetry_update
+00001930: 5f64 6963 7428 7365 6c66 2920 2d3e 2044  _dict(self) -> D
+00001940: 6963 743a 0a20 2020 2020 2020 2022 2222  ict:.        """
+00001950: 4469 6374 696f 6e61 7279 206f 6620 6461  Dictionary of da
+00001960: 7461 2066 6965 6c64 7320 746f 2063 7265  ta fields to cre
+00001970: 6174 6520 6461 7461 2077 6974 6820 6578  ate data with ex
+00001980: 7061 6e64 6564 2073 796d 6d65 7472 792e  panded symmetry.
+00001990: 2222 220a 0a20 2020 2020 2020 2075 7064  """..        upd
+000019a0: 6174 655f 6469 6374 203d 207b 7d0a 2020  ate_dict = {}.  
+000019b0: 2020 2020 2020 666f 7220 6669 656c 645f        for field_
+000019c0: 6e61 6d65 2c20 7363 616c 6172 5f64 6174  name, scalar_dat
+000019d0: 6120 696e 2073 656c 662e 6669 656c 645f  a in self.field_
+000019e0: 636f 6d70 6f6e 656e 7473 2e69 7465 6d73  components.items
+000019f0: 2829 3a0a 2020 2020 2020 2020 2020 2020  ():.            
+00001a00: 6569 6765 6e76 616c 5f66 6e20 3d20 7365  eigenval_fn = se
+00001a10: 6c66 2e73 796d 6d65 7472 795f 6569 6765  lf.symmetry_eige
+00001a20: 6e76 616c 7565 735b 6669 656c 645f 6e61  nvalues[field_na
+00001a30: 6d65 5d0a 0a20 2020 2020 2020 2020 2020  me]..           
+00001a40: 2023 2067 6574 2067 7269 6420 6c6f 6361   # get grid loca
+00001a50: 7469 6f6e 7320 666f 7220 7468 6973 2066  tions for this f
+00001a60: 6965 6c64 2063 6f6d 706f 6e65 6e74 206f  ield component o
+00001a70: 6e20 7468 6520 6578 7061 6e64 6564 2067  n the expanded g
+00001a80: 7269 640a 2020 2020 2020 2020 2020 2020  rid.            
+00001a90: 6669 656c 645f 636f 6f72 6473 203d 2073  field_coords = s
+00001aa0: 656c 662e 5f65 7870 616e 6465 645f 6772  elf._expanded_gr
+00001ab0: 6964 5f66 6965 6c64 5f63 6f6f 7264 7328  id_field_coords(
+00001ac0: 6669 656c 645f 6e61 6d65 290a 0a20 2020  field_name)..   
+00001ad0: 2020 2020 2020 2020 2066 6f72 2073 796d           for sym
+00001ae0: 5f64 696d 2c20 2873 796d 5f76 616c 2c20  _dim, (sym_val, 
+00001af0: 7379 6d5f 6c6f 6329 2069 6e20 656e 756d  sym_loc) in enum
+00001b00: 6572 6174 6528 7a69 7028 7365 6c66 2e73  erate(zip(self.s
+00001b10: 796d 6d65 7472 792c 2073 656c 662e 7379  ymmetry, self.sy
+00001b20: 6d6d 6574 7279 5f63 656e 7465 7229 293a  mmetry_center)):
+00001b30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00001b40: 2064 696d 5f6e 616d 6520 3d20 2278 797a   dim_name = "xyz
+00001b50: 225b 7379 6d5f 6469 6d5d 0a0a 2020 2020  "[sym_dim]..    
+00001b60: 2020 2020 2020 2020 2020 2020 2320 436f              # Co
+00001b70: 6e74 696e 7565 2069 6620 6e6f 2073 796d  ntinue if no sym
+00001b80: 6d65 7472 7920 616c 6f6e 6720 7468 6973  metry along this
+00001b90: 2064 696d 656e 7369 6f6e 0a20 2020 2020   dimension.     
+00001ba0: 2020 2020 2020 2020 2020 2069 6620 7379             if sy
+00001bb0: 6d5f 7661 6c20 3d3d 2030 3a0a 2020 2020  m_val == 0:.    
+00001bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001bd0: 636f 6e74 696e 7565 0a0a 2020 2020 2020  continue..      
+00001be0: 2020 2020 2020 2020 2020 2320 4765 7420            # Get 
+00001bf0: 636f 6f72 6469 6e61 7465 7320 666f 7220  coordinates for 
+00001c00: 7468 6973 2066 6965 6c64 2063 6f6d 706f  this field compo
+00001c10: 6e65 6e74 206f 6e20 7468 6520 6578 7061  nent on the expa
+00001c20: 6e64 6564 2067 7269 640a 2020 2020 2020  nded grid.      
+00001c30: 2020 2020 2020 2020 2020 636f 6f72 6473            coords
+00001c40: 203d 2066 6965 6c64 5f63 6f6f 7264 732e   = field_coords.
+00001c50: 746f 5f6c 6973 745b 7379 6d5f 6469 6d5d  to_list[sym_dim]
+00001c60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00001c70: 2063 6f6f 7264 7320 3d20 7365 6c66 2e6d   coords = self.m
+00001c80: 6f6e 6974 6f72 2e64 6f77 6e73 616d 706c  onitor.downsampl
+00001c90: 6528 636f 6f72 6473 2c20 6178 6973 3d73  e(coords, axis=s
+00001ca0: 796d 5f64 696d 290a 0a20 2020 2020 2020  ym_dim)..       
+00001cb0: 2020 2020 2020 2020 2023 2047 6574 2069           # Get i
+00001cc0: 6e64 6578 6573 206f 6620 636f 6f72 6473  ndexes of coords
+00001cd0: 2074 6861 7420 6c69 6520 6f6e 2074 6865   that lie on the
+00001ce0: 206c 6566 7420 6f66 2074 6865 2073 796d   left of the sym
+00001cf0: 6d65 7472 7920 6365 6e74 6572 0a20 2020  metry center.   
+00001d00: 2020 2020 2020 2020 2020 2020 2066 6c69               fli
+00001d10: 705f 696e 6473 203d 206e 702e 7768 6572  p_inds = np.wher
+00001d20: 6528 636f 6f72 6473 203c 2073 796d 5f6c  e(coords < sym_l
+00001d30: 6f63 295b 305d 0a0a 2020 2020 2020 2020  oc)[0]..        
+00001d40: 2020 2020 2020 2020 2320 4765 7420 7468          # Get th
+00001d50: 6520 7379 6d6d 6574 7269 6320 636f 6f72  e symmetric coor
+00001d60: 6469 6e61 7465 7320 6f6e 2074 6865 2072  dinates on the r
+00001d70: 6967 6874 0a20 2020 2020 2020 2020 2020  ight.           
+00001d80: 2020 2020 2063 6f6f 7264 735f 696e 7465       coords_inte
+00001d90: 7270 203d 206e 702e 636f 7079 2863 6f6f  rp = np.copy(coo
+00001da0: 7264 7329 0a20 2020 2020 2020 2020 2020  rds).           
+00001db0: 2020 2020 2063 6f6f 7264 735f 696e 7465       coords_inte
+00001dc0: 7270 5b66 6c69 705f 696e 6473 5d20 3d20  rp[flip_inds] = 
+00001dd0: 3220 2a20 7379 6d5f 6c6f 6320 2d20 636f  2 * sym_loc - co
+00001de0: 6f72 6473 5b66 6c69 705f 696e 6473 5d0a  ords[flip_inds].
+00001df0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00001e00: 2023 2049 6e74 6572 706f 6c61 7465 2e20   # Interpolate. 
+00001e10: 5468 6572 6520 6765 6e65 7261 6c6c 7920  There generally 
+00001e20: 7368 6f75 6c64 6e27 7420 6265 2076 616c  shouldn't be val
+00001e30: 7565 7320 6f75 7420 6f66 2062 6f75 6e64  ues out of bound
+00001e40: 7320 6578 6365 7074 2070 6f74 656e 7469  s except potenti
+00001e50: 616c 6c79 0a20 2020 2020 2020 2020 2020  ally.           
+00001e60: 2020 2020 2023 2077 6865 6e20 6861 6e64       # when hand
+00001e70: 6c69 6e67 206d 6f64 6573 2c20 696e 2077  ling modes, in w
+00001e80: 6869 6368 2063 6173 6520 7468 6579 2073  hich case they s
+00001e90: 686f 756c 6420 6265 2061 7420 7468 6520  hould be at the 
+00001ea0: 626f 756e 6461 7279 2061 6e64 2063 6c6f  boundary and clo
+00001eb0: 7365 2074 6f20 302e 0a0a 2020 2020 2020  se to 0...      
+00001ec0: 2020 2020 2020 2020 2020 7363 616c 6172            scalar
+00001ed0: 5f64 6174 6120 3d20 7363 616c 6172 5f64  _data = scalar_d
+00001ee0: 6174 612e 7365 6c28 2a2a 7b64 696d 5f6e  ata.sel(**{dim_n
+00001ef0: 616d 653a 2063 6f6f 7264 735f 696e 7465  ame: coords_inte
+00001f00: 7270 7d2c 206d 6574 686f 643d 226e 6561  rp}, method="nea
+00001f10: 7265 7374 2229 0a20 2020 2020 2020 2020  rest").         
+00001f20: 2020 2020 2020 2073 6361 6c61 725f 6461         scalar_da
+00001f30: 7461 203d 2073 6361 6c61 725f 6461 7461  ta = scalar_data
+00001f40: 2e61 7373 6967 6e5f 636f 6f72 6473 287b  .assign_coords({
+00001f50: 6469 6d5f 6e61 6d65 3a20 636f 6f72 6473  dim_name: coords
+00001f60: 7d29 0a0a 2020 2020 2020 2020 2020 2020  })..            
+00001f70: 2020 2020 2320 6170 706c 7920 7468 6520      # apply the 
+00001f80: 7379 6d6d 6574 7279 2065 6967 656e 7661  symmetry eigenva
+00001f90: 6c75 6520 2869 6620 6465 6669 6e65 6429  lue (if defined)
+00001fa0: 2074 6f20 7468 6520 666c 6970 7065 6420   to the flipped 
+00001fb0: 7661 6c75 6573 0a20 2020 2020 2020 2020  values.         
+00001fc0: 2020 2020 2020 2069 6620 6569 6765 6e76         if eigenv
+00001fd0: 616c 5f66 6e20 6973 206e 6f74 204e 6f6e  al_fn is not Non
+00001fe0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00001ff0: 2020 2020 2020 2073 796d 5f65 6967 656e         sym_eigen
+00002000: 7661 6c75 6520 3d20 6569 6765 6e76 616c  value = eigenval
+00002010: 5f66 6e28 7379 6d5f 6469 6d29 0a20 2020  _fn(sym_dim).   
+00002020: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002030: 2073 6361 6c61 725f 6461 7461 203d 2073   scalar_data = s
+00002040: 6361 6c61 725f 6461 7461 2e6d 756c 7469  calar_data.multi
+00002050: 706c 795f 6174 280a 2020 2020 2020 2020  ply_at(.        
+00002060: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002070: 7661 6c75 653d 7379 6d5f 7661 6c20 2a20  value=sym_val * 
+00002080: 7379 6d5f 6569 6765 6e76 616c 7565 2c20  sym_eigenvalue, 
+00002090: 636f 6f72 645f 6e61 6d65 3d64 696d 5f6e  coord_name=dim_n
+000020a0: 616d 652c 2069 6e64 6963 6573 3d66 6c69  ame, indices=fli
+000020b0: 705f 696e 6473 0a20 2020 2020 2020 2020  p_inds.         
+000020c0: 2020 2020 2020 2020 2020 2029 0a0a 2020             )..  
+000020d0: 2020 2020 2020 2020 2020 2320 6173 7369            # assi
+000020e0: 676e 2074 6865 2066 696e 616c 2073 6361  gn the final sca
+000020f0: 6c61 7220 6461 7461 2074 6f20 7468 6520  lar data to the 
+00002100: 7570 6461 7465 5f64 6963 740a 2020 2020  update_dict.    
+00002110: 2020 2020 2020 2020 7570 6461 7465 5f64          update_d
+00002120: 6963 745b 6669 656c 645f 6e61 6d65 5d20  ict[field_name] 
+00002130: 3d20 7363 616c 6172 5f64 6174 610a 0a20  = scalar_data.. 
+00002140: 2020 2020 2020 2075 7064 6174 655f 6469         update_di
+00002150: 6374 2e75 7064 6174 6528 7b22 7379 6d6d  ct.update({"symm
+00002160: 6574 7279 223a 2028 302c 2030 2c20 3029  etry": (0, 0, 0)
+00002170: 2c20 2273 796d 6d65 7472 795f 6365 6e74  , "symmetry_cent
+00002180: 6572 223a 204e 6f6e 657d 290a 0a20 2020  er": None})..   
+00002190: 2020 2020 2072 6574 7572 6e20 7570 6461       return upda
+000021a0: 7465 5f64 6963 740a 0a20 2020 2064 6566  te_dict..    def
+000021b0: 2061 745f 636f 6f72 6473 2873 656c 662c   at_coords(self,
+000021c0: 2063 6f6f 7264 733a 2043 6f6f 7264 7329   coords: Coords)
+000021d0: 202d 3e20 7872 2e44 6174 6173 6574 3a0a   -> xr.Dataset:.
+000021e0: 2020 2020 2020 2020 2222 2243 6f6c 6f63          """Coloc
+000021f0: 6174 6520 6461 7461 2074 6f20 736f 6d65  ate data to some
+00002200: 2073 7570 706c 6965 6420 636f 6f72 6469   supplied coordi
+00002210: 6e61 7465 732e 2054 6869 7320 6973 2061  nates. This is a
+00002220: 2063 6f6e 7665 6e69 656e 6365 206d 6574   convenience met
+00002230: 686f 6420 7468 6174 2077 7261 7073 0a20  hod that wraps. 
+00002240: 2020 2020 2020 2060 6063 6f6c 6f63 6174         ``colocat
+00002250: 6560 602c 2061 6e64 2073 6b69 7073 2064  e``, and skips d
+00002260: 696d 656e 7369 6f6e 7320 666f 7220 7768  imensions for wh
+00002270: 6963 6820 7468 6520 6461 7461 2068 6173  ich the data has
+00002280: 2061 2073 696e 676c 6520 6461 7461 2070   a single data p
+00002290: 6f69 6e74 206f 6e6c 790a 2020 2020 2020  oint only.      
+000022a0: 2020 2860 6063 6f6c 6f63 6174 6560 6020    (``colocate`` 
+000022b0: 7769 6c6c 2065 7272 6f72 2069 6e20 7468  will error in th
+000022c0: 6174 2063 6173 652e 2920 4966 2074 6865  at case.) If the
+000022d0: 2063 6f6f 7264 7320 6172 6520 6f75 7420   coords are out 
+000022e0: 6f66 2062 6f75 6e64 7320 666f 7220 7468  of bounds for th
+000022f0: 6520 6461 7461 0a20 2020 2020 2020 206f  e data.        o
+00002300: 7468 6572 7769 7365 2c20 616e 2065 7272  therwise, an err
+00002310: 6f72 2077 696c 6c20 7374 696c 6c20 6265  or will still be
+00002320: 2070 726f 6475 6365 642e 0a0a 2020 2020   produced...    
+00002330: 2020 2020 5061 7261 6d65 7465 7273 0a20      Parameters. 
+00002340: 2020 2020 2020 202d 2d2d 2d2d 2d2d 2d2d         ---------
+00002350: 2d0a 2020 2020 2020 2020 636f 6f72 6473  -.        coords
+00002360: 203a 203a 636c 6173 733a 6043 6f6f 7264   : :class:`Coord
+00002370: 7360 0a20 2020 2020 2020 2020 2020 2043  s`.            C
+00002380: 6f6f 7264 696e 6174 6573 2069 6e20 782c  oordinates in x,
+00002390: 2079 2061 6e64 207a 2074 6f20 636f 6c6f   y and z to colo
+000023a0: 6361 7465 2074 6f2e 0a0a 2020 2020 2020  cate to...      
+000023b0: 2020 5265 7475 726e 730a 2020 2020 2020    Returns.      
+000023c0: 2020 2d2d 2d2d 2d2d 2d0a 2020 2020 2020    -------.      
+000023d0: 2020 7861 7272 6179 2e44 6174 6173 6574    xarray.Dataset
+000023e0: 0a20 2020 2020 2020 2020 2020 2044 6174  .            Dat
+000023f0: 6173 6574 2063 6f6e 7461 696e 696e 6720  aset containing 
+00002400: 616c 6c20 6f66 2074 6865 2066 6965 6c64  all of the field
+00002410: 7320 696e 2074 6865 2064 6174 6120 696e  s in the data in
+00002420: 7465 7270 6f6c 6174 6564 2074 6f20 626f  terpolated to bo
+00002430: 756e 6461 7279 206c 6f63 6174 696f 6e73  undary locations
+00002440: 206f 6e0a 2020 2020 2020 2020 2020 2020   on.            
+00002450: 7468 6520 5965 6520 6772 6964 2e0a 2020  the Yee grid..  
+00002460: 2020 2020 2020 2222 220a 0a20 2020 2020        """..     
+00002470: 2020 2023 2070 6173 7320 636f 6f72 6473     # pass coords
+00002480: 2069 6620 6561 6368 206f 6620 7468 6520   if each of the 
+00002490: 7363 616c 6172 2066 6965 6c64 2064 6174  scalar field dat
+000024a0: 6120 6861 7665 206d 6f72 6520 7468 616e  a have more than
+000024b0: 206f 6e65 2063 6f6f 7264 696e 6174 6520   one coordinate 
+000024c0: 616c 6f6e 6720 6120 6469 6d0a 2020 2020  along a dim.    
+000024d0: 2020 2020 7879 7a5f 6b77 6172 6773 203d      xyz_kwargs =
+000024e0: 207b 7d0a 2020 2020 2020 2020 666f 7220   {}.        for 
+000024f0: 6469 6d2c 2063 6f6f 7264 735f 6469 6d20  dim, coords_dim 
+00002500: 696e 207a 6970 2822 7879 7a22 2c20 2863  in zip("xyz", (c
+00002510: 6f6f 7264 732e 782c 2063 6f6f 7264 732e  oords.x, coords.
+00002520: 792c 2063 6f6f 7264 732e 7a29 293a 0a20  y, coords.z)):. 
+00002530: 2020 2020 2020 2020 2020 2073 6361 6c61             scala
+00002540: 725f 6461 7461 203d 206c 6973 7428 7365  r_data = list(se
+00002550: 6c66 2e66 6965 6c64 5f63 6f6d 706f 6e65  lf.field_compone
+00002560: 6e74 732e 7661 6c75 6573 2829 290a 2020  nts.values()).  
+00002570: 2020 2020 2020 2020 2020 636f 6f72 645f            coord_
+00002580: 6c65 6e73 203d 205b 6c65 6e28 6461 7461  lens = [len(data
+00002590: 2e63 6f6f 7264 735b 6469 6d5d 2920 666f  .coords[dim]) fo
+000025a0: 7220 6461 7461 2069 6e20 7363 616c 6172  r data in scalar
+000025b0: 5f64 6174 615d 0a20 2020 2020 2020 2020  _data].         
+000025c0: 2020 2069 6620 616c 6c28 6e63 6f6f 7264     if all(ncoord
+000025d0: 7320 3e20 3120 666f 7220 6e63 6f6f 7264  s > 1 for ncoord
+000025e0: 7320 696e 2063 6f6f 7264 5f6c 656e 7329  s in coord_lens)
+000025f0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00002600: 2020 7879 7a5f 6b77 6172 6773 5b64 696d    xyz_kwargs[dim
+00002610: 5d20 3d20 636f 6f72 6473 5f64 696d 0a0a  ] = coords_dim..
+00002620: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+00002630: 656c 662e 636f 6c6f 6361 7465 282a 2a78  elf.colocate(**x
+00002640: 797a 5f6b 7761 7267 7329 0a0a 0a63 6c61  yz_kwargs)...cla
+00002650: 7373 2045 6c65 6374 726f 6d61 676e 6574  ss Electromagnet
+00002660: 6963 4669 656c 6444 6174 6128 4162 7374  icFieldData(Abst
+00002670: 7261 6374 4669 656c 6444 6174 612c 2045  ractFieldData, E
+00002680: 6c65 6374 726f 6d61 676e 6574 6963 4669  lectromagneticFi
+00002690: 656c 6444 6174 6173 6574 2c20 4142 4329  eldDataset, ABC)
+000026a0: 3a0a 2020 2020 2222 2243 6f6c 6c65 6374  :.    """Collect
+000026b0: 696f 6e20 6f66 2065 6c65 6374 726f 6d61  ion of electroma
+000026c0: 676e 6574 6963 2066 6965 6c64 732e 2222  gnetic fields.""
+000026d0: 220a 0a20 2020 2067 7269 645f 7072 696d  "..    grid_prim
+000026e0: 616c 5f63 6f72 7265 6374 696f 6e3a 2055  al_correction: U
+000026f0: 6e69 6f6e 5b0a 2020 2020 2020 2020 666c  nion[.        fl
+00002700: 6f61 742c 0a20 2020 2020 2020 2046 7265  oat,.        Fre
+00002710: 7144 6174 6141 7272 6179 2c0a 2020 2020  qDataArray,.    
+00002720: 2020 2020 5469 6d65 4461 7461 4172 7261      TimeDataArra
+00002730: 792c 0a20 2020 2020 2020 2046 7265 714d  y,.        FreqM
+00002740: 6f64 6544 6174 6141 7272 6179 2c0a 2020  odeDataArray,.  
+00002750: 2020 2020 2020 454d 4546 7265 714d 6f64        EMEFreqMod
+00002760: 6544 6174 6141 7272 6179 2c0a 2020 2020  eDataArray,.    
+00002770: 5d20 3d20 7064 2e46 6965 6c64 280a 2020  ] = pd.Field(.  
+00002780: 2020 2020 2020 312e 302c 0a20 2020 2020        1.0,.     
+00002790: 2020 2074 6974 6c65 3d22 4669 656c 6420     title="Field 
+000027a0: 636f 7272 6563 7469 6f6e 2066 6163 746f  correction facto
+000027b0: 7222 2c0a 2020 2020 2020 2020 6465 7363  r",.        desc
+000027c0: 7269 7074 696f 6e3d 2243 6f72 7265 6374  ription="Correct
+000027d0: 696f 6e20 6661 6374 6f72 2074 6861 7420  ion factor that 
+000027e0: 6e65 6564 7320 746f 2062 6520 6170 706c  needs to be appl
+000027f0: 6965 6420 666f 7220 6461 7461 2063 6f72  ied for data cor
+00002800: 7265 7370 6f6e 6469 6e67 2074 6f20 6120  responding to a 
+00002810: 3244 2022 0a20 2020 2020 2020 2022 6d6f  2D ".        "mo
+00002820: 6e69 746f 7220 746f 2074 616b 6520 696e  nitor to take in
+00002830: 746f 2061 6363 6f75 6e74 2074 6865 2066  to account the f
+00002840: 696e 6974 6520 6772 6964 2069 6e20 7468  inite grid in th
+00002850: 6520 6e6f 726d 616c 2064 6972 6563 7469  e normal directi
+00002860: 6f6e 2069 6e20 7468 6520 7369 6d75 6c61  on in the simula
+00002870: 7469 6f6e 2069 6e20 220a 2020 2020 2020  tion in ".      
+00002880: 2020 2277 6869 6368 2074 6865 2064 6174    "which the dat
+00002890: 6120 7761 7320 636f 6d70 7574 6564 2e20  a was computed. 
+000028a0: 5468 6520 6661 6374 6f72 2069 7320 6170  The factor is ap
+000028b0: 706c 6965 6420 746f 2066 6965 6c64 7320  plied to fields 
+000028c0: 6465 6669 6e65 6420 6f6e 2074 6865 2070  defined on the p
+000028d0: 7269 6d61 6c20 6772 6964 2022 0a20 2020  rimal grid ".   
+000028e0: 2020 2020 2022 6c6f 6361 7469 6f6e 7320       "locations 
+000028f0: 616c 6f6e 6720 7468 6520 6e6f 726d 616c  along the normal
+00002900: 2064 6972 6563 7469 6f6e 2e22 2c0a 2020   direction.",.  
+00002910: 2020 290a 2020 2020 6772 6964 5f64 7561    ).    grid_dua
+00002920: 6c5f 636f 7272 6563 7469 6f6e 3a20 556e  l_correction: Un
+00002930: 696f 6e5b 0a20 2020 2020 2020 2066 6c6f  ion[.        flo
+00002940: 6174 2c0a 2020 2020 2020 2020 4672 6571  at,.        Freq
+00002950: 4461 7461 4172 7261 792c 0a20 2020 2020  DataArray,.     
+00002960: 2020 2054 696d 6544 6174 6141 7272 6179     TimeDataArray
+00002970: 2c0a 2020 2020 2020 2020 4672 6571 4d6f  ,.        FreqMo
+00002980: 6465 4461 7461 4172 7261 792c 0a20 2020  deDataArray,.   
+00002990: 2020 2020 2045 4d45 4672 6571 4d6f 6465       EMEFreqMode
+000029a0: 4461 7461 4172 7261 792c 0a20 2020 205d  DataArray,.    ]
+000029b0: 203d 2070 642e 4669 656c 6428 0a20 2020   = pd.Field(.   
+000029c0: 2020 2020 2031 2e30 2c0a 2020 2020 2020       1.0,.      
+000029d0: 2020 7469 746c 653d 2246 6965 6c64 2063    title="Field c
+000029e0: 6f72 7265 6374 696f 6e20 6661 6374 6f72  orrection factor
+000029f0: 222c 0a20 2020 2020 2020 2064 6573 6372  ",.        descr
+00002a00: 6970 7469 6f6e 3d22 436f 7272 6563 7469  iption="Correcti
+00002a10: 6f6e 2066 6163 746f 7220 7468 6174 206e  on factor that n
+00002a20: 6565 6473 2074 6f20 6265 2061 7070 6c69  eeds to be appli
+00002a30: 6564 2066 6f72 2064 6174 6120 636f 7272  ed for data corr
+00002a40: 6573 706f 6e64 696e 6720 746f 2061 2032  esponding to a 2
+00002a50: 4420 220a 2020 2020 2020 2020 226d 6f6e  D ".        "mon
+00002a60: 6974 6f72 2074 6f20 7461 6b65 2069 6e74  itor to take int
+00002a70: 6f20 6163 636f 756e 7420 7468 6520 6669  o account the fi
+00002a80: 6e69 7465 2067 7269 6420 696e 2074 6865  nite grid in the
+00002a90: 206e 6f72 6d61 6c20 6469 7265 6374 696f   normal directio
+00002aa0: 6e20 696e 2074 6865 2073 696d 756c 6174  n in the simulat
+00002ab0: 696f 6e20 696e 2022 0a20 2020 2020 2020  ion in ".       
+00002ac0: 2022 7768 6963 6820 7468 6520 6461 7461   "which the data
+00002ad0: 2077 6173 2063 6f6d 7075 7465 642e 2054   was computed. T
+00002ae0: 6865 2066 6163 746f 7220 6973 2061 7070  he factor is app
+00002af0: 6c69 6564 2074 6f20 6669 656c 6473 2064  lied to fields d
+00002b00: 6566 696e 6564 206f 6e20 7468 6520 6475  efined on the du
+00002b10: 616c 2067 7269 6420 220a 2020 2020 2020  al grid ".      
+00002b20: 2020 226c 6f63 6174 696f 6e73 2061 6c6f    "locations alo
+00002b30: 6e67 2074 6865 206e 6f72 6d61 6c20 6469  ng the normal di
+00002b40: 7265 6374 696f 6e2e 222c 0a20 2020 2029  rection.",.    )
+00002b50: 0a0a 2020 2020 6465 6620 5f65 7870 616e  ..    def _expan
+00002b60: 6465 645f 6772 6964 5f66 6965 6c64 5f63  ded_grid_field_c
+00002b70: 6f6f 7264 7328 7365 6c66 2c20 6669 656c  oords(self, fiel
+00002b80: 645f 6e61 6d65 3a20 7374 7229 3a0a 2020  d_name: str):.  
+00002b90: 2020 2020 2020 2222 2243 6f6f 7264 696e        """Coordin
+00002ba0: 6174 6573 2069 6e20 7468 6520 6578 7061  ates in the expa
+00002bb0: 6e64 6564 2067 7269 6420 636f 7272 6573  nded grid corres
+00002bc0: 706f 6e64 696e 6720 746f 2061 2067 6976  ponding to a giv
+00002bd0: 656e 2066 6965 6c64 2063 6f6d 706f 6e65  en field compone
+00002be0: 6e74 2e22 2222 0a20 2020 2020 2020 2069  nt.""".        i
+00002bf0: 6620 7365 6c66 2e6d 6f6e 6974 6f72 2e63  f self.monitor.c
+00002c00: 6f6c 6f63 6174 653a 0a20 2020 2020 2020  olocate:.       
+00002c10: 2020 2020 2062 6f75 6e64 735f 6469 6374       bounds_dict
+00002c20: 203d 2073 656c 662e 6772 6964 5f65 7870   = self.grid_exp
+00002c30: 616e 6465 642e 626f 756e 6461 7269 6573  anded.boundaries
+00002c40: 2e74 6f5f 6469 6374 0a20 2020 2020 2020  .to_dict.       
+00002c50: 2020 2020 2072 6574 7572 6e20 436f 6f72       return Coor
+00002c60: 6473 282a 2a7b 6b65 793a 2076 616c 5b3a  ds(**{key: val[:
+00002c70: 2d31 5d20 666f 7220 6b65 792c 2076 616c  -1] for key, val
+00002c80: 2069 6e20 626f 756e 6473 5f64 6963 742e   in bounds_dict.
+00002c90: 6974 656d 7328 297d 290a 2020 2020 2020  items()}).      
+00002ca0: 2020 7265 7475 726e 2073 656c 662e 6772    return self.gr
+00002cb0: 6964 5f65 7870 616e 6465 645b 7365 6c66  id_expanded[self
+00002cc0: 2e67 7269 645f 6c6f 6361 7469 6f6e 735b  .grid_locations[
+00002cd0: 6669 656c 645f 6e61 6d65 5d5d 0a0a 2020  field_name]]..  
+00002ce0: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
+00002cf0: 6465 6620 5f67 7269 645f 636f 7272 6563  def _grid_correc
+00002d00: 7469 6f6e 5f64 6963 7428 7365 6c66 293a  tion_dict(self):
+00002d10: 0a20 2020 2020 2020 2022 2222 5265 7475  .        """Retu
+00002d20: 726e 2074 6865 2070 7269 6d61 6c20 616e  rn the primal an
+00002d30: 6420 6475 616c 2066 696e 6974 6520 6772  d dual finite gr
+00002d40: 6964 2063 6f72 7265 6374 696f 6e20 6661  id correction fa
+00002d50: 6374 6f72 7320 6173 2061 2064 6963 7469  ctors as a dicti
+00002d60: 6f6e 6172 792e 2222 220a 2020 2020 2020  onary.""".      
+00002d70: 2020 7265 7475 726e 207b 0a20 2020 2020    return {.     
+00002d80: 2020 2020 2020 2022 6772 6964 5f70 7269         "grid_pri
+00002d90: 6d61 6c5f 636f 7272 6563 7469 6f6e 223a  mal_correction":
+00002da0: 2073 656c 662e 6772 6964 5f70 7269 6d61   self.grid_prima
+00002db0: 6c5f 636f 7272 6563 7469 6f6e 2c0a 2020  l_correction,.  
+00002dc0: 2020 2020 2020 2020 2020 2267 7269 645f            "grid_
+00002dd0: 6475 616c 5f63 6f72 7265 6374 696f 6e22  dual_correction"
+00002de0: 3a20 7365 6c66 2e67 7269 645f 6475 616c  : self.grid_dual
+00002df0: 5f63 6f72 7265 6374 696f 6e2c 0a20 2020  _correction,.   
+00002e00: 2020 2020 207d 0a0a 2020 2020 4070 726f       }..    @pro
+00002e10: 7065 7274 790a 2020 2020 6465 6620 5f74  perty.    def _t
+00002e20: 616e 6765 6e74 6961 6c5f 6469 6d73 2873  angential_dims(s
+00002e30: 656c 6629 202d 3e20 4c69 7374 5b73 7472  elf) -> List[str
+00002e40: 5d3a 0a20 2020 2020 2020 2022 2222 466f  ]:.        """Fo
+00002e50: 7220 6120 3244 206d 6f6e 6974 6f72 2064  r a 2D monitor d
+00002e60: 6174 612c 2072 6574 7572 6e20 7468 6520  ata, return the 
+00002e70: 6e61 6d65 7320 6f66 2074 6865 2074 616e  names of the tan
+00002e80: 6765 6e74 6961 6c20 6469 6d65 6e73 696f  gential dimensio
+00002e90: 6e73 2e20 5261 6973 6520 6966 2063 616e  ns. Raise if can
+00002ea0: 6e6f 740a 2020 2020 2020 2020 636f 6e66  not.        conf
+00002eb0: 6972 6d20 7468 6174 2074 6865 2061 7373  irm that the ass
+00002ec0: 6f63 6961 7465 6420 6d6f 6e69 746f 7220  ociated monitor 
+00002ed0: 6973 2032 442e 2222 220a 2020 2020 2020  is 2D.""".      
+00002ee0: 2020 6966 206c 656e 2873 656c 662e 6d6f    if len(self.mo
+00002ef0: 6e69 746f 722e 7a65 726f 5f64 696d 7329  nitor.zero_dims)
+00002f00: 2021 3d20 313a 0a20 2020 2020 2020 2020   != 1:.         
+00002f10: 2020 2072 6169 7365 2044 6174 6145 7272     raise DataErr
+00002f20: 6f72 2822 4461 7461 206d 7573 7420 6265  or("Data must be
+00002f30: 2032 4420 746f 2067 6574 2074 616e 6765   2D to get tange
+00002f40: 6e74 6961 6c20 6469 6d65 6e73 696f 6e73  ntial dimensions
+00002f50: 2e22 290a 2020 2020 2020 2020 7461 6e67  .").        tang
+00002f60: 656e 7469 616c 5f64 696d 7320 3d20 5b22  ential_dims = ["
+00002f70: 7822 2c20 2279 222c 2022 7a22 5d0a 2020  x", "y", "z"].  
+00002f80: 2020 2020 2020 7461 6e67 656e 7469 616c        tangential
+00002f90: 5f64 696d 732e 706f 7028 7365 6c66 2e6d  _dims.pop(self.m
+00002fa0: 6f6e 6974 6f72 2e7a 6572 6f5f 6469 6d73  onitor.zero_dims
+00002fb0: 5b30 5d29 0a0a 2020 2020 2020 2020 7265  [0])..        re
+00002fc0: 7475 726e 2074 616e 6765 6e74 6961 6c5f  turn tangential_
+00002fd0: 6469 6d73 0a0a 2020 2020 4070 726f 7065  dims..    @prope
+00002fe0: 7274 790a 2020 2020 6465 6620 636f 6c6f  rty.    def colo
+00002ff0: 6361 7469 6f6e 5f62 6f75 6e64 6172 6965  cation_boundarie
+00003000: 7328 7365 6c66 2920 2d3e 2043 6f6f 7264  s(self) -> Coord
+00003010: 733a 0a20 2020 2020 2020 2022 2222 436f  s:.        """Co
+00003020: 6f72 6469 6e61 7465 7320 746f 2062 6520  ordinates to be 
+00003030: 7573 6564 2066 6f72 2063 6f6c 6f63 6174  used for colocat
+00003040: 696f 6e20 6f66 2074 6865 2064 6174 6120  ion of the data 
+00003050: 746f 2067 7269 6420 626f 756e 6461 7269  to grid boundari
+00003060: 6573 2e22 2222 0a0a 2020 2020 2020 2020  es."""..        
+00003070: 6966 206e 6f74 2073 656c 662e 6772 6964  if not self.grid
+00003080: 5f65 7870 616e 6465 643a 0a20 2020 2020  _expanded:.     
+00003090: 2020 2020 2020 2072 6169 7365 2044 6174         raise Dat
+000030a0: 6145 7272 6f72 280a 2020 2020 2020 2020  aError(.        
+000030b0: 2020 2020 2020 2020 224d 6f6e 6974 6f72          "Monitor
+000030c0: 2064 6174 6120 7265 7175 6972 6573 2027   data requires '
+000030d0: 6772 6964 5f65 7870 616e 6465 6427 2074  grid_expanded' t
+000030e0: 6f20 6265 2064 6566 696e 6564 2069 6e20  o be defined in 
+000030f0: 6f72 6465 7220 746f 2022 0a20 2020 2020  order to ".     
+00003100: 2020 2020 2020 2020 2020 2022 636f 6d70             "comp
+00003110: 7574 6520 636f 6c6f 6361 7469 6f6e 2063  ute colocation c
+00003120: 6f6f 7264 696e 6174 6573 2e22 0a20 2020  oordinates.".   
+00003130: 2020 2020 2020 2020 2029 0a0a 2020 2020           )..    
+00003140: 2020 2020 2320 4765 7420 626f 756e 6461      # Get bounda
+00003150: 7269 6573 2066 726f 6d20 7468 6520 6578  ries from the ex
+00003160: 7061 6e64 6564 2067 7269 640a 2020 2020  panded grid.    
+00003170: 2020 2020 6772 6964 5f62 6f75 6e64 7320      grid_bounds 
+00003180: 3d20 7365 6c66 2e67 7269 645f 6578 7061  = self.grid_expa
+00003190: 6e64 6564 2e62 6f75 6e64 6172 6965 732e  nded.boundaries.
+000031a0: 746f 5f64 6963 740a 0a20 2020 2020 2020  to_dict..       
+000031b0: 2023 204e 6f6e 2d63 6f6c 6f63 6174 696e   # Non-colocatin
+000031c0: 6720 6d6f 6e69 746f 7273 2063 616e 206f  g monitors can o
+000031d0: 6e6c 7920 636f 6c6f 6361 7465 2073 7461  nly colocate sta
+000031e0: 7274 696e 6720 6672 6f6d 2074 6865 2066  rting from the f
+000031f0: 6972 7374 2062 6f75 6e64 6172 790a 2020  irst boundary.  
+00003200: 2020 2020 2020 2320 2875 6e6c 6573 7320        # (unless 
+00003210: 7468 6572 6527 7320 6120 7369 6e67 6c65  there's a single
+00003220: 2064 6174 6120 706f 696e 742c 2069 6e20   data point, in 
+00003230: 7768 6963 6820 6361 7365 2064 6174 6120  which case data 
+00003240: 6861 7320 616c 7265 6164 7920 6265 656e  has already been
+00003250: 2073 6e61 7070 6564 292e 0a20 2020 2020   snapped)..     
+00003260: 2020 2023 2052 6567 6172 646c 6573 7320     # Regardless 
+00003270: 6f66 2063 6f6c 6f63 6174 696f 6e2c 2077  of colocation, w
+00003280: 6520 616c 736f 2064 726f 7020 7468 6520  e also drop the 
+00003290: 6c61 7374 2062 6f75 6e64 6172 792e 0a20  last boundary.. 
+000032a0: 2020 2020 2020 2063 6f6c 6f63 6174 655f         colocate_
+000032b0: 626f 756e 6473 203d 207b 7d0a 2020 2020  bounds = {}.    
+000032c0: 2020 2020 666f 7220 6469 6d2c 2062 6f75      for dim, bou
+000032d0: 6e64 7320 696e 2067 7269 645f 626f 756e  nds in grid_boun
+000032e0: 6473 2e69 7465 6d73 2829 3a0a 2020 2020  ds.items():.    
+000032f0: 2020 2020 2020 2020 6362 7320 3d20 626f          cbs = bo
+00003300: 756e 6473 5b3a 2d31 5d0a 2020 2020 2020  unds[:-1].      
+00003310: 2020 2020 2020 6966 206e 6f74 2073 656c        if not sel
+00003320: 662e 6d6f 6e69 746f 722e 636f 6c6f 6361  f.monitor.coloca
+00003330: 7465 2061 6e64 2063 6273 2e73 697a 6520  te and cbs.size 
+00003340: 3e20 313a 0a20 2020 2020 2020 2020 2020  > 1:.           
+00003350: 2020 2020 2063 6273 203d 2063 6273 5b31       cbs = cbs[1
+00003360: 3a5d 0a20 2020 2020 2020 2020 2020 2063  :].            c
+00003370: 6f6c 6f63 6174 655f 626f 756e 6473 5b64  olocate_bounds[d
+00003380: 696d 5d20 3d20 6362 730a 0a20 2020 2020  im] = cbs..     
+00003390: 2020 2072 6574 7572 6e20 436f 6f72 6473     return Coords
+000033a0: 282a 2a63 6f6c 6f63 6174 655f 626f 756e  (**colocate_boun
+000033b0: 6473 290a 0a20 2020 2040 7072 6f70 6572  ds)..    @proper
+000033c0: 7479 0a20 2020 2064 6566 2063 6f6c 6f63  ty.    def coloc
+000033d0: 6174 696f 6e5f 6365 6e74 6572 7328 7365  ation_centers(se
+000033e0: 6c66 2920 2d3e 2043 6f6f 7264 733a 0a20  lf) -> Coords:. 
+000033f0: 2020 2020 2020 2022 2222 436f 6f72 6469         """Coordi
+00003400: 6e61 7465 7320 746f 2062 6520 7573 6564  nates to be used
+00003410: 2066 6f72 2063 6f6c 6f63 6174 696f 6e20   for colocation 
+00003420: 6f66 2074 6865 2064 6174 6120 746f 2067  of the data to g
+00003430: 7269 6420 6365 6e74 6572 732e 2222 220a  rid centers.""".
+00003440: 2020 2020 2020 2020 636f 6c6f 6361 7465          colocate
+00003450: 5f63 656e 7465 7273 203d 207b 7d0a 2020  _centers = {}.  
+00003460: 2020 2020 2020 666f 7220 6469 6d2c 2063        for dim, c
+00003470: 6f6f 7264 7320 696e 2073 656c 662e 636f  oords in self.co
+00003480: 6c6f 6361 7469 6f6e 5f62 6f75 6e64 6172  location_boundar
+00003490: 6965 732e 746f 5f64 6963 742e 6974 656d  ies.to_dict.item
+000034a0: 7328 293a 0a20 2020 2020 2020 2020 2020  s():.           
+000034b0: 2063 6f6c 6f63 6174 655f 6365 6e74 6572   colocate_center
+000034c0: 735b 6469 6d5d 203d 2028 636f 6f72 6473  s[dim] = (coords
+000034d0: 5b31 3a5d 202b 2063 6f6f 7264 735b 3a2d  [1:] + coords[:-
+000034e0: 315d 2920 2f20 320a 0a20 2020 2020 2020  1]) / 2..       
+000034f0: 2072 6574 7572 6e20 436f 6f72 6473 282a   return Coords(*
+00003500: 2a63 6f6c 6f63 6174 655f 6365 6e74 6572  *colocate_center
+00003510: 7329 0a0a 2020 2020 4070 726f 7065 7274  s)..    @propert
+00003520: 790a 2020 2020 6465 6620 5f70 6c61 6e65  y.    def _plane
+00003530: 5f67 7269 645f 626f 756e 6461 7269 6573  _grid_boundaries
+00003540: 2873 656c 6629 202d 3e20 5475 706c 655b  (self) -> Tuple[
+00003550: 436f 6f72 6473 3144 2c20 436f 6f72 6473  Coords1D, Coords
+00003560: 3144 5d3a 0a20 2020 2020 2020 2022 2222  1D]:.        """
+00003570: 466f 7220 6120 3244 206d 6f6e 6974 6f72  For a 2D monitor
+00003580: 2064 6174 612c 2072 6574 7572 6e20 7468   data, return th
+00003590: 6520 626f 756e 6461 7269 6573 206f 6620  e boundaries of 
+000035a0: 7468 6520 696e 2d70 6c61 6e65 2067 7269  the in-plane gri
+000035b0: 6420 746f 2062 6520 7573 6564 2074 6f20  d to be used to 
+000035c0: 636f 6d70 7574 650a 2020 2020 2020 2020  compute.        
+000035d0: 6469 6666 6572 656e 7469 616c 2061 7265  differential are
+000035e0: 6120 616e 6420 746f 2063 6f6c 6f63 6174  a and to colocat
+000035f0: 6520 6669 656c 6473 2069 6620 6e65 6564  e fields if need
+00003600: 6564 2e22 2222 0a20 2020 2020 2020 2069  ed.""".        i
+00003610: 6620 6e70 2e61 6e79 286e 702e 6172 7261  f np.any(np.arra
+00003620: 7928 7365 6c66 2e6d 6f6e 6974 6f72 2e69  y(self.monitor.i
+00003630: 6e74 6572 7661 6c5f 7370 6163 6529 203e  nterval_space) >
+00003640: 2031 293a 0a20 2020 2020 2020 2020 2020   1):.           
+00003650: 2072 6169 7365 2054 6964 7933 644e 6f74   raise Tidy3dNot
+00003660: 496d 706c 656d 656e 7465 6445 7272 6f72  ImplementedError
+00003670: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00003680: 2020 2243 616e 6e6f 7420 6465 7465 726d    "Cannot determ
+00003690: 696e 6520 6772 6964 2062 6f75 6e64 6172  ine grid boundar
+000036a0: 6965 7320 636f 7272 6573 706f 6e64 696e  ies correspondin
+000036b0: 6720 746f 2022 0a20 2020 2020 2020 2020  g to ".         
+000036c0: 2020 2020 2020 2022 646f 776e 2d73 616d         "down-sam
+000036d0: 706c 6564 206d 6f6e 6974 6f72 2064 6174  pled monitor dat
+000036e0: 6120 2827 696e 7465 7276 616c 5f73 7061  a ('interval_spa
+000036f0: 6365 2720 3e20 3120 616c 6f6e 6720 6120  ce' > 1 along a 
+00003700: 6469 7265 6374 696f 6e29 2e22 0a20 2020  direction).".   
+00003710: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+00003720: 2020 2064 696d 312c 2064 696d 3220 3d20     dim1, dim2 = 
+00003730: 7365 6c66 2e5f 7461 6e67 656e 7469 616c  self._tangential
+00003740: 5f64 696d 730a 2020 2020 2020 2020 626f  _dims.        bo
+00003750: 756e 6473 5f64 6963 7420 3d20 7365 6c66  unds_dict = self
+00003760: 2e63 6f6c 6f63 6174 696f 6e5f 626f 756e  .colocation_boun
+00003770: 6461 7269 6573 2e74 6f5f 6469 6374 0a20  daries.to_dict. 
+00003780: 2020 2020 2020 2072 6574 7572 6e20 2862         return (b
+00003790: 6f75 6e64 735f 6469 6374 5b64 696d 315d  ounds_dict[dim1]
+000037a0: 2c20 626f 756e 6473 5f64 6963 745b 6469  , bounds_dict[di
+000037b0: 6d32 5d29 0a0a 2020 2020 4070 726f 7065  m2])..    @prope
+000037c0: 7274 790a 2020 2020 6465 6620 5f70 6c61  rty.    def _pla
+000037d0: 6e65 5f67 7269 645f 6365 6e74 6572 7328  ne_grid_centers(
+000037e0: 7365 6c66 2920 2d3e 2054 7570 6c65 5b43  self) -> Tuple[C
+000037f0: 6f6f 7264 7331 442c 2043 6f6f 7264 7331  oords1D, Coords1
+00003800: 445d 3a0a 2020 2020 2020 2020 2222 2246  D]:.        """F
+00003810: 6f72 2032 4420 6d6f 6e69 746f 7220 6461  or 2D monitor da
+00003820: 7461 2c20 7265 7475 726e 2074 6865 2063  ta, return the c
+00003830: 656e 7465 7273 206f 6620 7468 6520 696e  enters of the in
+00003840: 2d70 6c61 6e65 2067 7269 6422 2222 0a20  -plane grid""". 
+00003850: 2020 2020 2020 2072 6574 7572 6e20 5b28         return [(
+00003860: 6273 5b31 3a5d 202b 2062 735b 3a2d 315d  bs[1:] + bs[:-1]
+00003870: 2920 2f20 3220 666f 7220 6273 2069 6e20  ) / 2 for bs in 
+00003880: 7365 6c66 2e5f 706c 616e 655f 6772 6964  self._plane_grid
+00003890: 5f62 6f75 6e64 6172 6965 735d 0a0a 2020  _boundaries]..  
+000038a0: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
+000038b0: 6465 6620 5f64 6966 665f 6172 6561 2873  def _diff_area(s
+000038c0: 656c 6629 202d 3e20 7872 2e44 6174 6141  elf) -> xr.DataA
+000038d0: 7272 6179 3a0a 2020 2020 2020 2020 2222  rray:.        ""
+000038e0: 2246 6f72 2061 2032 4420 6d6f 6e69 746f  "For a 2D monito
+000038f0: 7220 6461 7461 2c20 7265 7475 726e 2074  r data, return t
+00003900: 6865 2061 7265 6120 6f66 2065 6163 6820  he area of each 
+00003910: 6365 6c6c 2069 6e20 7468 6520 706c 616e  cell in the plan
+00003920: 652c 2066 6f72 2075 7365 2069 6e20 6e75  e, for use in nu
+00003930: 6d65 7269 6361 6c0a 2020 2020 2020 2020  merical.        
+00003940: 696e 7465 6772 6174 696f 6e73 2e20 5468  integrations. Th
+00003950: 6973 2061 7373 756d 6573 2074 6861 7420  is assumes that 
+00003960: 6461 7461 2069 7320 636f 6c6f 6361 7465  data is colocate
+00003970: 6420 746f 2067 7269 6420 626f 756e 6461  d to grid bounda
+00003980: 7269 6573 2c20 616e 6420 7573 6573 2074  ries, and uses t
+00003990: 6865 0a20 2020 2020 2020 2064 6966 6665  he.        diffe
+000039a0: 7265 6e63 6520 696e 2074 6865 2073 7572  rence in the sur
+000039b0: 726f 756e 6469 6e67 2067 7269 6420 6365  rounding grid ce
+000039c0: 6e74 6572 7320 746f 2063 6f6d 7075 7465  nters to compute
+000039d0: 2074 6865 2061 7265 612e 0a20 2020 2020   the area..     
+000039e0: 2020 2022 2222 0a0a 2020 2020 2020 2020     """..        
+000039f0: 2320 4d6f 6e69 746f 7220 7661 6c75 6573  # Monitor values
+00003a00: 2061 7265 2069 6e74 6572 706f 6c61 7465   are interpolate
+00003a10: 6420 746f 2062 6f75 6e64 730a 2020 2020  d to bounds.    
+00003a20: 2020 2020 626f 756e 6473 203d 2073 656c      bounds = sel
+00003a30: 662e 5f70 6c61 6e65 5f67 7269 645f 626f  f._plane_grid_bo
+00003a40: 756e 6461 7269 6573 0a20 2020 2020 2020  undaries.       
+00003a50: 2023 2043 6f6f 7264 7320 746f 2063 6f6d   # Coords to com
+00003a60: 7075 7465 2063 656c 6c20 7369 7a65 7320  pute cell sizes 
+00003a70: 6172 6f75 6e64 2074 6865 2069 6e74 6572  around the inter
+00003a80: 706f 6c61 7469 6f6e 206c 6f63 6174 696f  polation locatio
+00003a90: 6e73 0a20 2020 2020 2020 2063 6f6f 7264  ns.        coord
+00003aa0: 7320 3d20 5b62 732e 636f 7079 2829 2066  s = [bs.copy() f
+00003ab0: 6f72 2062 7320 696e 2073 656c 662e 5f70  or bs in self._p
+00003ac0: 6c61 6e65 5f67 7269 645f 6365 6e74 6572  lane_grid_center
+00003ad0: 735d 0a0a 2020 2020 2020 2020 2320 4170  s]..        # Ap
+00003ae0: 7065 6e64 2074 6865 2066 6972 7374 2061  pend the first a
+00003af0: 6e64 206c 6173 7420 626f 756e 6461 7279  nd last boundary
+00003b00: 0a20 2020 2020 2020 205f 2c20 706c 616e  .        _, plan
+00003b10: 655f 696e 6473 203d 2073 656c 662e 6d6f  e_inds = self.mo
+00003b20: 6e69 746f 722e 706f 705f 6178 6973 285b  nitor.pop_axis([
+00003b30: 302c 2031 2c20 325d 2c20 7365 6c66 2e6d  0, 1, 2], self.m
+00003b40: 6f6e 6974 6f72 2e73 697a 652e 696e 6465  onitor.size.inde
+00003b50: 7828 302e 3029 290a 2020 2020 2020 2020  x(0.0)).        
+00003b60: 636f 6f72 6473 5b30 5d20 3d20 6e70 2e61  coords[0] = np.a
+00003b70: 7272 6179 285b 626f 756e 6473 5b30 5d5b  rray([bounds[0][
+00003b80: 305d 5d20 2b20 636f 6f72 6473 5b30 5d2e  0]] + coords[0].
+00003b90: 746f 6c69 7374 2829 202b 205b 626f 756e  tolist() + [boun
+00003ba0: 6473 5b30 5d5b 2d31 5d5d 290a 2020 2020  ds[0][-1]]).    
+00003bb0: 2020 2020 636f 6f72 6473 5b31 5d20 3d20      coords[1] = 
+00003bc0: 6e70 2e61 7272 6179 285b 626f 756e 6473  np.array([bounds
+00003bd0: 5b31 5d5b 305d 5d20 2b20 636f 6f72 6473  [1][0]] + coords
+00003be0: 5b31 5d2e 746f 6c69 7374 2829 202b 205b  [1].tolist() + [
+00003bf0: 626f 756e 6473 5b31 5d5b 2d31 5d5d 290a  bounds[1][-1]]).
+00003c00: 0a20 2020 2020 2020 2022 2222 5472 756e  .        """Trun
+00003c10: 6361 7465 2063 6f6f 7264 7320 746f 206d  cate coords to m
+00003c20: 6f6e 6974 6f72 2062 6f75 6e64 6172 6965  onitor boundarie
+00003c30: 732e 2054 6869 7320 696d 706c 6963 6974  s. This implicit
+00003c40: 6c79 206d 616b 6573 2065 7874 7261 2070  ly makes extra p
+00003c50: 6978 656c 7320 7768 6963 6820 6d61 7920  ixels which may 
+00003c60: 6265 0a20 2020 2020 2020 2070 7265 7365  be.        prese
+00003c70: 6e74 2068 6176 6520 7369 7a65 2030 2061  nt have size 0 a
+00003c80: 6e64 2073 6f20 776f 6e27 7420 6265 2069  nd so won't be i
+00003c90: 6e63 6c75 6465 6420 696e 2074 6865 2069  ncluded in the i
+00003ca0: 6e74 6567 7261 7469 6f6e 2e20 466f 7220  ntegration. For 
+00003cb0: 7069 7865 6c73 2069 6e74 6572 7365 6374  pixels intersect
+00003cc0: 6564 0a20 2020 2020 2020 2062 7920 7468  ed.        by th
+00003cd0: 6520 6d6f 6e69 746f 7220 6564 6765 2c20  e monitor edge, 
+00003ce0: 7468 6520 7369 7a65 2069 7320 7472 756e  the size is trun
+00003cf0: 6361 7465 6420 746f 2074 6865 2070 6172  cated to the par
+00003d00: 7420 636f 7665 7265 6420 6279 2074 6865  t covered by the
+00003d10: 206d 6f6e 6974 6f72 2e20 5768 656e 2075   monitor. When u
+00003d20: 7369 6e67 0a20 2020 2020 2020 2074 6865  sing.        the
+00003d30: 2064 6966 6665 7265 6e74 6961 6c20 6172   differential ar
+00003d40: 6561 2073 697a 6573 2064 6566 696e 6564  ea sizes defined
+00003d50: 2069 6e20 7468 6973 2077 6179 2074 6f67   in this way tog
+00003d60: 6574 6865 7220 7769 7468 2069 6e74 6567  ether with integ
+00003d70: 7261 6e64 2076 616c 7565 730a 2020 2020  rand values.    
+00003d80: 2020 2020 6465 6669 6e65 6420 6174 2063      defined at c
+00003d90: 656c 6c20 626f 756e 6461 7269 6573 2c20  ell boundaries, 
+00003da0: 7468 6520 696e 7465 6772 6174 696f 6e20  the integration 
+00003db0: 6973 2065 7175 6976 616c 656e 7420 746f  is equivalent to
+00003dc0: 2074 7261 7065 7a6f 6964 616c 2072 756c   trapezoidal rul
+00003dd0: 6520 7769 7468 2074 6865 2066 6972 7374  e with the first
+00003de0: 0a20 2020 2020 2020 2061 6e64 206c 6173  .        and las
+00003df0: 7420 7661 6c75 6573 2069 6e74 6572 706f  t values interpo
+00003e00: 6c61 7465 6420 746f 2074 6865 2065 7861  lated to the exa
+00003e10: 6374 206d 6f6e 6974 6f72 2073 7461 7274  ct monitor start
+00003e20: 2f65 6e64 206c 6f63 6174 696f 6e2c 2069  /end location, i
+00003e30: 6620 7468 6520 696e 7465 6772 616e 640a  f the integrand.
+00003e40: 2020 2020 2020 2020 6973 207a 6572 6f20          is zero 
+00003e50: 6f75 7473 6964 6520 6f66 2074 6865 206d  outside of the m
+00003e60: 6f6e 6974 6f72 2067 656f 6d65 7472 792e  onitor geometry.
+00003e70: 2054 6869 7320 7368 6f75 6c64 2075 7375   This should usu
+00003e80: 616c 6c79 2062 6520 7468 6520 6361 7365  ally be the case
+00003e90: 2066 6f72 2066 6c75 7820 616e 6420 646f   for flux and do
+00003ea0: 740a 2020 2020 2020 2020 636f 6d70 7574  t.        comput
+00003eb0: 6174 696f 6e73 2222 220a 2020 2020 2020  ations""".      
+00003ec0: 2020 6d6e 745f 626f 756e 6473 203d 206e    mnt_bounds = n
+00003ed0: 702e 6172 7261 7928 7365 6c66 2e6d 6f6e  p.array(self.mon
+00003ee0: 6974 6f72 2e62 6f75 6e64 7329 0a20 2020  itor.bounds).   
+00003ef0: 2020 2020 206d 6e74 5f62 6f75 6e64 7320       mnt_bounds 
+00003f00: 3d20 6d6e 745f 626f 756e 6473 5b3a 2c20  = mnt_bounds[:, 
+00003f10: 706c 616e 655f 696e 6473 5d2e 540a 2020  plane_inds].T.  
+00003f20: 2020 2020 2020 636f 6f72 6473 5b30 5d5b        coords[0][
+00003f30: 6e70 2e61 7267 7768 6572 6528 636f 6f72  np.argwhere(coor
+00003f40: 6473 5b30 5d20 3c20 6d6e 745f 626f 756e  ds[0] < mnt_boun
+00003f50: 6473 5b30 2c20 305d 295d 203d 206d 6e74  ds[0, 0])] = mnt
+00003f60: 5f62 6f75 6e64 735b 302c 2030 5d0a 2020  _bounds[0, 0].  
+00003f70: 2020 2020 2020 636f 6f72 6473 5b30 5d5b        coords[0][
+00003f80: 6e70 2e61 7267 7768 6572 6528 636f 6f72  np.argwhere(coor
+00003f90: 6473 5b30 5d20 3e20 6d6e 745f 626f 756e  ds[0] > mnt_boun
+00003fa0: 6473 5b30 2c20 315d 295d 203d 206d 6e74  ds[0, 1])] = mnt
+00003fb0: 5f62 6f75 6e64 735b 302c 2031 5d0a 2020  _bounds[0, 1].  
+00003fc0: 2020 2020 2020 636f 6f72 6473 5b31 5d5b        coords[1][
+00003fd0: 6e70 2e61 7267 7768 6572 6528 636f 6f72  np.argwhere(coor
+00003fe0: 6473 5b31 5d20 3c20 6d6e 745f 626f 756e  ds[1] < mnt_boun
+00003ff0: 6473 5b31 2c20 305d 295d 203d 206d 6e74  ds[1, 0])] = mnt
+00004000: 5f62 6f75 6e64 735b 312c 2030 5d0a 2020  _bounds[1, 0].  
+00004010: 2020 2020 2020 636f 6f72 6473 5b31 5d5b        coords[1][
+00004020: 6e70 2e61 7267 7768 6572 6528 636f 6f72  np.argwhere(coor
+00004030: 6473 5b31 5d20 3e20 6d6e 745f 626f 756e  ds[1] > mnt_boun
+00004040: 6473 5b31 2c20 315d 295d 203d 206d 6e74  ds[1, 1])] = mnt
+00004050: 5f62 6f75 6e64 735b 312c 2031 5d0a 0a20  _bounds[1, 1].. 
+00004060: 2020 2020 2020 2023 2044 6f20 6e6f 7420         # Do not 
+00004070: 6170 706c 7920 7468 6520 7370 7572 696f  apply the spurio
+00004080: 7573 2064 6c20 616c 6f6e 6720 6120 6469  us dl along a di
+00004090: 6d65 6e73 696f 6e20 7768 6572 6520 7468  mension where th
+000040a0: 6520 7369 6d75 6c61 7469 6f6e 2069 7320  e simulation is 
+000040b0: 3244 2e0a 2020 2020 2020 2020 2320 496e  2D..        # In
+000040c0: 7374 6561 642c 2077 6520 6a75 7374 2073  stead, we just s
+000040d0: 6574 2074 6865 2062 6f75 6e64 6172 6965  et the boundarie
+000040e0: 7320 7375 6368 2074 6861 7420 7468 6520  s such that the 
+000040f0: 6365 6c6c 2073 697a 6520 616c 6f6e 6720  cell size along 
+00004100: 7468 6520 7a65 726f 2064 696d 656e 7369  the zero dimensi
+00004110: 6f6e 2069 7320 312c 0a20 2020 2020 2020  on is 1,.       
+00004120: 2023 2073 7563 6820 7468 6174 2071 7561   # such that qua
+00004130: 6e74 6974 6965 7320 6c69 6b65 2066 6c75  ntities like flu
+00004140: 7820 7769 6c6c 2063 6f6d 6520 6f75 7420  x will come out 
+00004150: 696e 2075 6e69 7473 206f 6620 5720 2f20  in units of W / 
+00004160: 756d 2e0a 2020 2020 2020 2020 7369 7a65  um..        size
+00004170: 735f 6469 6d30 203d 2063 6f6f 7264 735b  s_dim0 = coords[
+00004180: 305d 5b31 3a5d 202d 2063 6f6f 7264 735b  0][1:] - coords[
+00004190: 305d 5b3a 2d31 5d20 6966 2062 6f75 6e64  0][:-1] if bound
+000041a0: 735b 305d 2e73 697a 6520 3e20 3120 656c  s[0].size > 1 el
+000041b0: 7365 205b 312e 305d 0a20 2020 2020 2020  se [1.0].       
+000041c0: 2073 697a 6573 5f64 696d 3120 3d20 636f   sizes_dim1 = co
+000041d0: 6f72 6473 5b31 5d5b 313a 5d20 2d20 636f  ords[1][1:] - co
+000041e0: 6f72 6473 5b31 5d5b 3a2d 315d 2069 6620  ords[1][:-1] if 
+000041f0: 626f 756e 6473 5b31 5d2e 7369 7a65 203e  bounds[1].size >
+00004200: 2031 2065 6c73 6520 5b31 2e30 5d0a 0a20   1 else [1.0].. 
+00004210: 2020 2020 2020 2072 6574 7572 6e20 7872         return xr
+00004220: 2e44 6174 6141 7272 6179 286e 702e 6f75  .DataArray(np.ou
+00004230: 7465 7228 7369 7a65 735f 6469 6d30 2c20  ter(sizes_dim0, 
+00004240: 7369 7a65 735f 6469 6d31 292c 2064 696d  sizes_dim1), dim
+00004250: 733d 7365 6c66 2e5f 7461 6e67 656e 7469  s=self._tangenti
+00004260: 616c 5f64 696d 7329 0a0a 2020 2020 6465  al_dims)..    de
+00004270: 6620 5f74 616e 6765 6e74 6961 6c5f 636f  f _tangential_co
+00004280: 7272 6563 7465 6428 7365 6c66 2c20 6669  rrected(self, fi
+00004290: 656c 6473 3a20 4469 6374 5b73 7472 2c20  elds: Dict[str, 
+000042a0: 4461 7461 4172 7261 795d 2920 2d3e 2044  DataArray]) -> D
+000042b0: 6963 745b 7374 722c 2044 6174 6141 7272  ict[str, DataArr
+000042c0: 6179 5d3a 0a20 2020 2020 2020 2022 2222  ay]:.        """
+000042d0: 466f 7220 6120 3244 206d 6f6e 6974 6f72  For a 2D monitor
+000042e0: 2064 6174 612c 2065 7874 7261 6374 2074   data, extract t
+000042f0: 6865 2074 616e 6765 6e74 6961 6c20 636f  he tangential co
+00004300: 6d70 6f6e 656e 7473 2066 726f 6d20 6669  mponents from fi
+00004310: 656c 6473 2061 6e64 206f 7269 656e 7420  elds and orient 
+00004320: 7468 656d 0a20 2020 2020 2020 2073 7563  them.        suc
+00004330: 6820 7468 6174 2074 6865 2074 6869 7264  h that the third
+00004340: 2063 6f6d 706f 6e65 6e74 2077 6f75 6c64   component would
+00004350: 2062 6520 7468 6520 6e6f 726d 616c 2061   be the normal a
+00004360: 7869 732e 2054 6869 7320 6a75 7374 206d  xis. This just m
+00004370: 6561 6e73 2074 6861 7420 7468 6520 4820  eans that the H 
+00004380: 6669 656c 640a 2020 2020 2020 2020 6765  field.        ge
+00004390: 7473 2061 6e20 6578 7472 6120 6d69 6e75  ts an extra minu
+000043a0: 7320 7369 676e 2069 6620 7468 6520 6e6f  s sign if the no
+000043b0: 726d 616c 2061 7869 7320 6973 2060 6022  rmal axis is ``"
+000043c0: 7922 6060 2e20 5261 6973 6520 6966 2061  y"``. Raise if a
+000043d0: 6e79 206f 6620 7468 6520 7461 6e67 656e  ny of the tangen
+000043e0: 7469 616c 0a20 2020 2020 2020 2066 6965  tial.        fie
+000043f0: 6c64 2063 6f6d 706f 6e65 6e74 7320 6973  ld components is
+00004400: 206d 6973 7369 6e67 2e0a 0a20 2020 2020   missing...     
+00004410: 2020 2054 6865 2066 696e 6974 6520 6772     The finite gr
+00004420: 6964 2063 6f72 7265 6374 696f 6e20 6973  id correction is
+00004430: 2061 6c73 6f20 6170 706c 6965 642c 2073   also applied, s
+00004440: 6f20 7468 6520 696e 7465 6e64 6564 2075  o the intended u
+00004450: 7365 206f 6620 7468 6573 6520 6669 656c  se of these fiel
+00004460: 6473 2069 7320 696e 0a20 2020 2020 2020  ds is in.       
+00004470: 2070 6f79 6e74 696e 672c 2066 6c75 782c   poynting, flux,
+00004480: 2061 6e64 2064 6f74 2d6c 696b 6520 6d65   and dot-like me
+00004490: 7468 6f64 732e 2054 6865 206e 6f72 6d61  thods. The norma
+000044a0: 6c20 636f 6f72 6469 6e61 7465 2069 7320  l coordinate is 
+000044b0: 6472 6f70 7065 6420 6672 6f6d 2074 6865  dropped from the
+000044c0: 2066 6965 6c64 2064 6174 612e 0a20 2020   field data..   
+000044d0: 2020 2020 2022 2222 0a0a 2020 2020 2020       """..      
+000044e0: 2020 6966 206c 656e 2873 656c 662e 6d6f    if len(self.mo
+000044f0: 6e69 746f 722e 7a65 726f 5f64 696d 7329  nitor.zero_dims)
+00004500: 2021 3d20 313a 0a20 2020 2020 2020 2020   != 1:.         
+00004510: 2020 2072 6169 7365 2044 6174 6145 7272     raise DataErr
+00004520: 6f72 2822 4461 7461 206d 7573 7420 6265  or("Data must be
+00004530: 2032 4420 746f 2067 6574 2074 616e 6765   2D to get tange
+00004540: 6e74 6961 6c20 6669 656c 6473 2e22 290a  ntial fields.").
+00004550: 0a20 2020 2020 2020 2023 2054 616e 6765  .        # Tange
+00004560: 6e74 6961 6c20 6669 656c 6420 636f 6d70  ntial field comp
+00004570: 6f6e 656e 7473 0a20 2020 2020 2020 2074  onents.        t
+00004580: 616e 5f64 696d 7320 3d20 7365 6c66 2e5f  an_dims = self._
+00004590: 7461 6e67 656e 7469 616c 5f64 696d 730a  tangential_dims.
+000045a0: 2020 2020 2020 2020 636f 6d70 6f6e 656e          componen
+000045b0: 7473 203d 205b 666e 616d 6520 2b20 6469  ts = [fname + di
+000045c0: 6d20 666f 7220 666e 616d 6520 696e 2022  m for fname in "
+000045d0: 4548 2220 666f 7220 6469 6d20 696e 2074  EH" for dim in t
+000045e0: 616e 5f64 696d 735d 0a0a 2020 2020 2020  an_dims]..      
+000045f0: 2020 6e6f 726d 616c 5f64 696d 203d 2022    normal_dim = "
+00004600: 7879 7a22 5b73 656c 662e 6d6f 6e69 746f  xyz"[self.monito
+00004610: 722e 7369 7a65 2e69 6e64 6578 2830 295d  r.size.index(0)]
+00004620: 0a0a 2020 2020 2020 2020 7461 6e5f 6669  ..        tan_fi
+00004630: 656c 6473 203d 207b 7d0a 2020 2020 2020  elds = {}.      
+00004640: 2020 666f 7220 636f 6d70 6f6e 656e 7420    for component 
+00004650: 696e 2063 6f6d 706f 6e65 6e74 733a 0a20  in components:. 
+00004660: 2020 2020 2020 2020 2020 2069 6620 636f             if co
+00004670: 6d70 6f6e 656e 7420 6e6f 7420 696e 2066  mponent not in f
+00004680: 6965 6c64 733a 0a20 2020 2020 2020 2020  ields:.         
+00004690: 2020 2020 2020 2072 6169 7365 2044 6174         raise Dat
+000046a0: 6145 7272 6f72 2866 2254 616e 6765 6e74  aError(f"Tangent
+000046b0: 6961 6c20 6669 656c 6420 636f 6d70 6f6e  ial field compon
+000046c0: 656e 7420 277b 636f 6d70 6f6e 656e 747d  ent '{component}
+000046d0: 2720 6d69 7373 696e 6720 696e 2066 6965  ' missing in fie
+000046e0: 6c64 2064 6174 612e 2229 0a0a 2020 2020  ld data.")..    
+000046f0: 2020 2020 2020 2020 636f 7272 6563 7469          correcti
+00004700: 6f6e 203d 2031 0a0a 2020 2020 2020 2020  on = 1..        
+00004710: 2020 2020 2320 7369 676e 2063 6f72 7265      # sign corre
+00004720: 6374 696f 6e20 746f 2048 0a20 2020 2020  ction to H.     
+00004730: 2020 2020 2020 2069 6620 6e6f 726d 616c         if normal
+00004740: 5f64 696d 203d 3d20 2279 2220 616e 6420  _dim == "y" and 
+00004750: 636f 6d70 6f6e 656e 745b 305d 203d 3d20  component[0] == 
+00004760: 2248 223a 0a20 2020 2020 2020 2020 2020  "H":.           
+00004770: 2020 2020 2063 6f72 7265 6374 696f 6e20       correction 
+00004780: 2a3d 202d 310a 0a20 2020 2020 2020 2020  *= -1..         
+00004790: 2020 2023 2066 696e 6974 6520 6772 6964     # finite grid
+000047a0: 2063 6f72 7265 6374 696f 6e20 746f 2061   correction to a
+000047b0: 6c6c 2066 6965 6c64 730a 2020 2020 2020  ll fields.      
+000047c0: 2020 2020 2020 6569 675f 7661 6c20 3d20        eig_val = 
+000047d0: 7365 6c66 2e73 796d 6d65 7472 795f 6569  self.symmetry_ei
+000047e0: 6765 6e76 616c 7565 735b 636f 6d70 6f6e  genvalues[compon
+000047f0: 656e 745d 286e 6f72 6d61 6c5f 6469 6d29  ent](normal_dim)
+00004800: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00004810: 6569 675f 7661 6c20 3c20 303a 0a20 2020  eig_val < 0:.   
+00004820: 2020 2020 2020 2020 2020 2020 2063 6f72               cor
+00004830: 7265 6374 696f 6e20 2a3d 2073 656c 662e  rection *= self.
+00004840: 6772 6964 5f64 7561 6c5f 636f 7272 6563  grid_dual_correc
+00004850: 7469 6f6e 0a20 2020 2020 2020 2020 2020  tion.           
+00004860: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00004870: 2020 2020 2020 2063 6f72 7265 6374 696f         correctio
+00004880: 6e20 2a3d 2073 656c 662e 6772 6964 5f70  n *= self.grid_p
+00004890: 7269 6d61 6c5f 636f 7272 6563 7469 6f6e  rimal_correction
+000048a0: 0a0a 2020 2020 2020 2020 2020 2020 6669  ..            fi
+000048b0: 656c 645f 7371 7565 657a 6564 203d 2066  eld_squeezed = f
+000048c0: 6965 6c64 735b 636f 6d70 6f6e 656e 745d  ields[component]
+000048d0: 2e73 7175 6565 7a65 2864 696d 3d6e 6f72  .squeeze(dim=nor
+000048e0: 6d61 6c5f 6469 6d2c 2064 726f 703d 5472  mal_dim, drop=Tr
+000048f0: 7565 290a 2020 2020 2020 2020 2020 2020  ue).            
+00004900: 7461 6e5f 6669 656c 6473 5b63 6f6d 706f  tan_fields[compo
+00004910: 6e65 6e74 5d20 3d20 6669 656c 645f 7371  nent] = field_sq
+00004920: 7565 657a 6564 202a 2063 6f72 7265 6374  ueezed * correct
+00004930: 696f 6e0a 0a20 2020 2020 2020 2072 6574  ion..        ret
+00004940: 7572 6e20 7461 6e5f 6669 656c 6473 0a0a  urn tan_fields..
+00004950: 2020 2020 4070 726f 7065 7274 790a 2020      @property.  
+00004960: 2020 6465 6620 5f74 616e 6765 6e74 6961    def _tangentia
+00004970: 6c5f 6669 656c 6473 2873 656c 6629 202d  l_fields(self) -
+00004980: 3e20 4469 6374 5b73 7472 2c20 4461 7461  > Dict[str, Data
+00004990: 4172 7261 795d 3a0a 2020 2020 2020 2020  Array]:.        
+000049a0: 2222 2246 6f72 2061 2032 4420 6d6f 6e69  """For a 2D moni
+000049b0: 746f 7220 6461 7461 2c20 6765 7420 7468  tor data, get th
+000049c0: 6520 7461 6e67 656e 7469 616c 2045 2061  e tangential E a
+000049d0: 6e64 2048 2066 6965 6c64 7320 696e 2074  nd H fields in t
+000049e0: 6865 2032 4420 706c 616e 6520 6772 6964  he 2D plane grid
+000049f0: 2e20 2046 6965 6c64 730a 2020 2020 2020  .  Fields.      
+00004a00: 2020 6172 6520 6f72 6965 6e74 6564 2073    are oriented s
+00004a10: 7563 6820 7468 6174 2074 6865 2074 6869  uch that the thi
+00004a20: 7264 2063 6f6d 706f 6e65 6e74 2077 6f75  rd component wou
+00004a30: 6c64 2062 6520 7468 6520 6e6f 726d 616c  ld be the normal
+00004a40: 2061 7869 732e 2054 6869 7320 6a75 7374   axis. This just
+00004a50: 206d 6561 6e73 2074 6861 740a 2020 2020   means that.    
+00004a60: 2020 2020 7468 6520 4820 6669 656c 6420      the H field 
+00004a70: 6765 7473 2061 6e20 6578 7472 6120 6d69  gets an extra mi
+00004a80: 6e75 7320 7369 676e 2069 6620 7468 6520  nus sign if the 
+00004a90: 6e6f 726d 616c 2061 7869 7320 6973 2060  normal axis is `
+00004aa0: 6022 7922 6060 2e0a 0a20 2020 2020 2020  `"y"``...       
+00004ab0: 204e 6f74 650a 2020 2020 2020 2020 2d2d   Note.        --
+00004ac0: 2d2d 0a20 2020 2020 2020 2020 2020 2054  --.            T
+00004ad0: 6865 2066 696e 6974 6520 6772 6964 2063  he finite grid c
+00004ae0: 6f72 7265 6374 696f 6e20 6661 6374 6f72  orrection factor
+00004af0: 7320 6172 6520 6170 706c 6965 6420 616e  s are applied an
+00004b00: 6420 7379 6d6d 6574 7279 2069 7320 6578  d symmetry is ex
+00004b10: 7061 6e64 6564 2e0a 2020 2020 2020 2020  panded..        
+00004b20: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
+00004b30: 726e 2073 656c 662e 5f74 616e 6765 6e74  rn self._tangent
+00004b40: 6961 6c5f 636f 7272 6563 7465 6428 7365  ial_corrected(se
+00004b50: 6c66 2e73 796d 6d65 7472 795f 6578 7061  lf.symmetry_expa
+00004b60: 6e64 6564 2e66 6965 6c64 5f63 6f6d 706f  nded.field_compo
+00004b70: 6e65 6e74 7329 0a0a 2020 2020 4070 726f  nents)..    @pro
+00004b80: 7065 7274 790a 2020 2020 6465 6620 5f63  perty.    def _c
+00004b90: 6f6c 6f63 6174 6564 5f66 6965 6c64 7328  olocated_fields(
+00004ba0: 7365 6c66 2920 2d3e 2044 6963 745b 7374  self) -> Dict[st
+00004bb0: 722c 2044 6174 6141 7272 6179 5d3a 0a20  r, DataArray]:. 
+00004bc0: 2020 2020 2020 2022 2222 466f 7220 6120         """For a 
+00004bd0: 3244 206d 6f6e 6974 6f72 2064 6174 612c  2D monitor data,
+00004be0: 2067 6574 2061 6c6c 2045 2061 6e64 2048   get all E and H
+00004bf0: 2066 6965 6c64 7320 636f 6c6f 6361 7465   fields colocate
+00004c00: 6420 746f 2074 6865 2063 656c 6c20 626f  d to the cell bo
+00004c10: 756e 6461 7269 6573 2069 6e20 7468 6520  undaries in the 
+00004c20: 3244 0a20 2020 2020 2020 2070 6c61 6e65  2D.        plane
+00004c30: 2067 7269 642c 2077 6974 6820 7379 6d6d   grid, with symm
+00004c40: 6574 7269 6573 2065 7870 616e 6465 642e  etries expanded.
+00004c50: 0a20 2020 2020 2020 2022 2222 0a0a 2020  .        """..  
+00004c60: 2020 2020 2020 6669 656c 645f 636f 6d70        field_comp
+00004c70: 6f6e 656e 7473 203d 2073 656c 662e 7379  onents = self.sy
+00004c80: 6d6d 6574 7279 5f65 7870 616e 6465 642e  mmetry_expanded.
+00004c90: 6669 656c 645f 636f 6d70 6f6e 656e 7473  field_components
+00004ca0: 0a0a 2020 2020 2020 2020 6966 2073 656c  ..        if sel
+00004cb0: 662e 6d6f 6e69 746f 722e 636f 6c6f 6361  f.monitor.coloca
+00004cc0: 7465 3a0a 2020 2020 2020 2020 2020 2020  te:.            
+00004cd0: 7265 7475 726e 2066 6965 6c64 5f63 6f6d  return field_com
+00004ce0: 706f 6e65 6e74 730a 0a20 2020 2020 2020  ponents..       
+00004cf0: 2023 2049 6e74 6572 706f 6c61 7465 2066   # Interpolate f
+00004d00: 6965 6c64 2063 6f6d 706f 6e65 6e74 7320  ield components 
+00004d10: 746f 2063 656c 6c20 626f 756e 6461 7269  to cell boundari
+00004d20: 6573 0a20 2020 2020 2020 2069 6e74 6572  es.        inter
+00004d30: 705f 6469 6374 203d 207b 2261 7373 756d  p_dict = {"assum
+00004d40: 655f 736f 7274 6564 223a 2054 7275 657d  e_sorted": True}
+00004d50: 0a20 2020 2020 2020 2066 6f72 2064 696d  .        for dim
+00004d60: 2c20 626f 756e 6473 2069 6e20 7a69 7028  , bounds in zip(
+00004d70: 7365 6c66 2e5f 7461 6e67 656e 7469 616c  self._tangential
+00004d80: 5f64 696d 732c 2073 656c 662e 5f70 6c61  _dims, self._pla
+00004d90: 6e65 5f67 7269 645f 626f 756e 6461 7269  ne_grid_boundari
+00004da0: 6573 293a 0a20 2020 2020 2020 2020 2020  es):.           
+00004db0: 2069 6620 626f 756e 6473 2e73 697a 6520   if bounds.size 
+00004dc0: 3e20 313a 0a20 2020 2020 2020 2020 2020  > 1:.           
+00004dd0: 2020 2020 2069 6e74 6572 705f 6469 6374       interp_dict
+00004de0: 5b64 696d 5d20 3d20 626f 756e 6473 0a0a  [dim] = bounds..
+00004df0: 2020 2020 2020 2020 636f 6c6f 6361 7465          colocate
+00004e00: 645f 6669 656c 6473 203d 207b 6b65 793a  d_fields = {key:
+00004e10: 2076 616c 2e69 6e74 6572 7028 2a2a 696e   val.interp(**in
+00004e20: 7465 7270 5f64 6963 7429 2066 6f72 206b  terp_dict) for k
+00004e30: 6579 2c20 7661 6c20 696e 2066 6965 6c64  ey, val in field
+00004e40: 5f63 6f6d 706f 6e65 6e74 732e 6974 656d  _components.item
+00004e50: 7328 297d 0a20 2020 2020 2020 2072 6574  s()}.        ret
+00004e60: 7572 6e20 636f 6c6f 6361 7465 645f 6669  urn colocated_fi
+00004e70: 656c 6473 0a0a 2020 2020 4070 726f 7065  elds..    @prope
+00004e80: 7274 790a 2020 2020 6465 6620 5f63 6f6c  rty.    def _col
+00004e90: 6f63 6174 6564 5f74 616e 6765 6e74 6961  ocated_tangentia
+00004ea0: 6c5f 6669 656c 6473 2873 656c 6629 202d  l_fields(self) -
+00004eb0: 3e20 4469 6374 5b73 7472 2c20 4461 7461  > Dict[str, Data
+00004ec0: 4172 7261 795d 3a0a 2020 2020 2020 2020  Array]:.        
+00004ed0: 2222 2246 6f72 2061 2032 4420 6d6f 6e69  """For a 2D moni
+00004ee0: 746f 7220 6461 7461 2c20 6765 7420 7468  tor data, get th
+00004ef0: 6520 7461 6e67 656e 7469 616c 2045 2061  e tangential E a
+00004f00: 6e64 2048 2066 6965 6c64 7320 636f 6c6f  nd H fields colo
+00004f10: 6361 7465 6420 746f 2074 6865 2063 656c  cated to the cel
+00004f20: 6c20 626f 756e 6461 7269 6573 0a20 2020  l boundaries.   
+00004f30: 2020 2020 2069 6e20 7468 6520 3244 2070       in the 2D p
+00004f40: 6c61 6e65 2067 7269 642e 2020 4669 656c  lane grid.  Fiel
+00004f50: 6473 2061 7265 206f 7269 656e 7465 6420  ds are oriented 
+00004f60: 7375 6368 2074 6861 7420 7468 6520 7468  such that the th
+00004f70: 6972 6420 636f 6d70 6f6e 656e 7420 776f  ird component wo
+00004f80: 756c 6420 6265 2074 6865 206e 6f72 6d61  uld be the norma
+00004f90: 6c0a 2020 2020 2020 2020 6178 6973 2e20  l.        axis. 
+00004fa0: 5468 6973 206a 7573 7420 6d65 616e 7320  This just means 
+00004fb0: 7468 6174 2074 6865 2048 2066 6965 6c64  that the H field
+00004fc0: 2067 6574 7320 616e 2065 7874 7261 206d   gets an extra m
+00004fd0: 696e 7573 2073 6967 6e20 6966 2074 6865  inus sign if the
+00004fe0: 206e 6f72 6d61 6c20 6178 6973 2069 730a   normal axis is.
+00004ff0: 2020 2020 2020 2020 6060 2279 2260 602e          ``"y"``.
+00005000: 2052 6169 7365 2069 6620 616e 7920 6f66   Raise if any of
+00005010: 2074 6865 2074 616e 6765 6e74 6961 6c20   the tangential 
+00005020: 6669 656c 6420 636f 6d70 6f6e 656e 7473  field components
+00005030: 2069 7320 6d69 7373 696e 672e 0a0a 2020   is missing...  
+00005040: 2020 2020 2020 4e6f 7465 0a20 2020 2020        Note.     
+00005050: 2020 202d 2d2d 2d0a 2020 2020 2020 2020     ----.        
+00005060: 2020 2020 5468 6520 6669 6e69 7465 2067      The finite g
+00005070: 7269 6420 636f 7272 6563 7469 6f6e 2066  rid correction f
+00005080: 6163 746f 7273 2061 7265 2061 7070 6c69  actors are appli
+00005090: 6564 2061 6e64 2073 796d 6d65 7472 7920  ed and symmetry 
+000050a0: 6973 2065 7870 616e 6465 642e 0a20 2020  is expanded..   
+000050b0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+000050c0: 2072 6574 7572 6e20 7365 6c66 2e5f 7461   return self._ta
+000050d0: 6e67 656e 7469 616c 5f63 6f72 7265 6374  ngential_correct
+000050e0: 6564 2873 656c 662e 5f63 6f6c 6f63 6174  ed(self._colocat
+000050f0: 6564 5f66 6965 6c64 7329 0a0a 2020 2020  ed_fields)..    
+00005100: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
+00005110: 6620 6772 6964 5f63 6f72 7265 6374 6564  f grid_corrected
+00005120: 5f63 6f70 7928 7365 6c66 2920 2d3e 2045  _copy(self) -> E
+00005130: 6c65 6374 726f 6d61 676e 6574 6963 4669  lectromagneticFi
+00005140: 656c 6444 6174 613a 0a20 2020 2020 2020  eldData:.       
+00005150: 2022 2222 5265 7475 726e 2061 2063 6f70   """Return a cop
+00005160: 7920 6f66 2073 656c 6620 7769 7468 2067  y of self with g
+00005170: 7269 6420 636f 7272 6563 7469 6f6e 2066  rid correction f
+00005180: 6163 746f 7273 2061 7070 6c69 6564 2028  actors applied (
+00005190: 6966 206e 6563 6573 7361 7279 2920 616e  if necessary) an
+000051a0: 6420 7379 6d6d 6574 7279 0a20 2020 2020  d symmetry.     
+000051b0: 2020 2065 7870 616e 6465 642e 2222 220a     expanded.""".
+000051c0: 2020 2020 2020 2020 6669 656c 645f 6461          field_da
+000051d0: 7461 203d 2073 656c 662e 7379 6d6d 6574  ta = self.symmet
+000051e0: 7279 5f65 7870 616e 6465 645f 636f 7079  ry_expanded_copy
+000051f0: 0a20 2020 2020 2020 2069 6620 6c65 6e28  .        if len(
+00005200: 7365 6c66 2e6d 6f6e 6974 6f72 2e7a 6572  self.monitor.zer
+00005210: 6f5f 6469 6d73 2920 213d 2031 3a0a 2020  o_dims) != 1:.  
+00005220: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00005230: 2066 6965 6c64 5f64 6174 610a 0a20 2020   field_data..   
+00005240: 2020 2020 206e 6f72 6d61 6c5f 6469 6d20       normal_dim 
+00005250: 3d20 2278 797a 225b 7365 6c66 2e6d 6f6e  = "xyz"[self.mon
+00005260: 6974 6f72 2e7a 6572 6f5f 6469 6d73 5b30  itor.zero_dims[0
+00005270: 5d5d 0a20 2020 2020 2020 2075 7064 6174  ]].        updat
+00005280: 6520 3d20 7b22 6772 6964 5f70 7269 6d61  e = {"grid_prima
+00005290: 6c5f 636f 7272 6563 7469 6f6e 223a 2031  l_correction": 1
+000052a0: 2e30 2c20 2267 7269 645f 6475 616c 5f63  .0, "grid_dual_c
+000052b0: 6f72 7265 6374 696f 6e22 3a20 312e 307d  orrection": 1.0}
+000052c0: 0a20 2020 2020 2020 2066 6f72 2066 6965  .        for fie
+000052d0: 6c64 5f6e 616d 652c 2066 6965 6c64 2069  ld_name, field i
+000052e0: 6e20 6669 656c 645f 6461 7461 2e66 6965  n field_data.fie
+000052f0: 6c64 5f63 6f6d 706f 6e65 6e74 732e 6974  ld_components.it
+00005300: 656d 7328 293a 0a20 2020 2020 2020 2020  ems():.         
+00005310: 2020 2065 6967 5f76 616c 203d 2073 656c     eig_val = sel
+00005320: 662e 7379 6d6d 6574 7279 5f65 6967 656e  f.symmetry_eigen
+00005330: 7661 6c75 6573 5b66 6965 6c64 5f6e 616d  values[field_nam
+00005340: 655d 286e 6f72 6d61 6c5f 6469 6d29 0a20  e](normal_dim). 
+00005350: 2020 2020 2020 2020 2020 2069 6620 6569             if ei
+00005360: 675f 7661 6c20 3c20 303a 0a20 2020 2020  g_val < 0:.     
+00005370: 2020 2020 2020 2020 2020 2075 7064 6174             updat
+00005380: 655b 6669 656c 645f 6e61 6d65 5d20 3d20  e[field_name] = 
+00005390: 6669 656c 6420 2a20 7365 6c66 2e67 7269  field * self.gri
+000053a0: 645f 6475 616c 5f63 6f72 7265 6374 696f  d_dual_correctio
+000053b0: 6e0a 2020 2020 2020 2020 2020 2020 656c  n.            el
+000053c0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+000053d0: 2020 2020 7570 6461 7465 5b66 6965 6c64      update[field
+000053e0: 5f6e 616d 655d 203d 2066 6965 6c64 202a  _name] = field *
+000053f0: 2073 656c 662e 6772 6964 5f70 7269 6d61   self.grid_prima
+00005400: 6c5f 636f 7272 6563 7469 6f6e 0a20 2020  l_correction.   
+00005410: 2020 2020 2072 6574 7572 6e20 6669 656c       return fiel
+00005420: 645f 6461 7461 2e63 6f70 7928 7570 6461  d_data.copy(upda
+00005430: 7465 3d75 7064 6174 6529 0a0a 2020 2020  te=update)..    
+00005440: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
+00005450: 6620 696e 7465 6e73 6974 7928 7365 6c66  f intensity(self
+00005460: 2920 2d3e 2053 6361 6c61 7246 6965 6c64  ) -> ScalarField
+00005470: 4461 7461 4172 7261 793a 0a20 2020 2020  DataArray:.     
+00005480: 2020 2022 2222 5265 7475 726e 2074 6865     """Return the
+00005490: 2073 756d 206f 6620 7468 6520 7371 7561   sum of the squa
+000054a0: 7265 6420 6162 736f 6c75 7465 2065 6c65  red absolute ele
+000054b0: 6374 7269 6320 6669 656c 6420 636f 6d70  ctric field comp
+000054c0: 6f6e 656e 7473 2e22 2222 0a20 2020 2020  onents.""".     
+000054d0: 2020 206e 6f72 6d61 6c5f 6469 6d20 3d20     normal_dim = 
+000054e0: 2278 797a 225b 7365 6c66 2e6d 6f6e 6974  "xyz"[self.monit
+000054f0: 6f72 2e73 697a 652e 696e 6465 7828 3029  or.size.index(0)
+00005500: 5d0a 2020 2020 2020 2020 6669 656c 6473  ].        fields
+00005510: 203d 2073 656c 662e 5f63 6f6c 6f63 6174   = self._colocat
+00005520: 6564 5f66 6965 6c64 730a 2020 2020 2020  ed_fields.      
+00005530: 2020 636f 6d70 6f6e 656e 7473 203d 2028    components = (
+00005540: 2245 7822 2c20 2245 7922 2c20 2245 7a22  "Ex", "Ey", "Ez"
+00005550: 290a 2020 2020 2020 2020 6966 2061 6e79  ).        if any
+00005560: 2863 6d70 206e 6f74 2069 6e20 6669 656c  (cmp not in fiel
+00005570: 6473 2066 6f72 2063 6d70 2069 6e20 636f  ds for cmp in co
+00005580: 6d70 6f6e 656e 7473 293a 0a20 2020 2020  mponents):.     
+00005590: 2020 2020 2020 2072 6169 7365 204b 6579         raise Key
+000055a0: 4572 726f 7228 2243 616e 2774 2063 6f6d  Error("Can't com
+000055b0: 7075 7465 2069 6e74 656e 7369 7479 2c20  pute intensity, 
+000055c0: 616c 6c20 4520 6669 656c 6420 636f 6d70  all E field comp
+000055d0: 6f6e 656e 7473 206d 7573 7420 6265 2070  onents must be p
+000055e0: 7265 7365 6e74 2e22 290a 2020 2020 2020  resent.").      
+000055f0: 2020 696e 7465 6e73 6974 7920 3d20 7375    intensity = su
+00005600: 6d28 6669 656c 6473 5b63 6d70 5d2e 6162  m(fields[cmp].ab
+00005610: 7320 2a2a 2032 2066 6f72 2063 6d70 2069  s ** 2 for cmp i
+00005620: 6e20 636f 6d70 6f6e 656e 7473 290a 2020  n components).  
+00005630: 2020 2020 2020 7265 7475 726e 2069 6e74        return int
+00005640: 656e 7369 7479 2e73 7175 6565 7a65 2864  ensity.squeeze(d
+00005650: 696d 3d6e 6f72 6d61 6c5f 6469 6d2c 2064  im=normal_dim, d
+00005660: 726f 703d 5472 7565 290a 0a20 2020 2040  rop=True)..    @
+00005670: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
+00005680: 2070 6f79 6e74 696e 6728 7365 6c66 2920   poynting(self) 
+00005690: 2d3e 2053 6361 6c61 7246 6965 6c64 4461  -> ScalarFieldDa
+000056a0: 7461 4172 7261 793a 0a20 2020 2020 2020  taArray:.       
+000056b0: 2022 2222 5469 6d65 2d61 7665 7261 6765   """Time-average
+000056c0: 6420 506f 796e 7469 6e67 2076 6563 746f  d Poynting vecto
+000056d0: 7220 666f 7220 6672 6571 7565 6e63 792d  r for frequency-
+000056e0: 646f 6d61 696e 2064 6174 6120 6173 736f  domain data asso
+000056f0: 6369 6174 6564 2074 6f20 6120 3244 206d  ciated to a 2D m
+00005700: 6f6e 6974 6f72 2c0a 2020 2020 2020 2020  onitor,.        
+00005710: 7072 6f6a 6563 7465 6420 746f 2074 6865  projected to the
+00005720: 2064 6972 6563 7469 6f6e 206e 6f72 6d61   direction norma
+00005730: 6c20 746f 2074 6865 206d 6f6e 6974 6f72  l to the monitor
+00005740: 2070 6c61 6e65 2e22 2222 0a0a 2020 2020   plane."""..    
+00005750: 2020 2020 2320 5461 6e67 656e 7469 616c      # Tangential
+00005760: 2066 6965 6c64 7320 6172 6520 6f72 6465   fields are orde
+00005770: 7265 6420 6173 2045 312c 2045 322c 2048  red as E1, E2, H
+00005780: 312c 2048 320a 2020 2020 2020 2020 7461  1, H2.        ta
+00005790: 6e5f 6669 656c 6473 203d 2073 656c 662e  n_fields = self.
+000057a0: 5f63 6f6c 6f63 6174 6564 5f74 616e 6765  _colocated_tange
+000057b0: 6e74 6961 6c5f 6669 656c 6473 0a20 2020  ntial_fields.   
+000057c0: 2020 2020 2064 696d 312c 2064 696d 3220       dim1, dim2 
+000057d0: 3d20 7365 6c66 2e5f 7461 6e67 656e 7469  = self._tangenti
+000057e0: 616c 5f64 696d 730a 0a20 2020 2020 2020  al_dims..       
+000057f0: 2065 5f78 5f68 5f73 7461 7220 3d20 7461   e_x_h_star = ta
+00005800: 6e5f 6669 656c 6473 5b22 4522 202b 2064  n_fields["E" + d
+00005810: 696d 315d 202a 2074 616e 5f66 6965 6c64  im1] * tan_field
+00005820: 735b 2248 2220 2b20 6469 6d32 5d2e 636f  s["H" + dim2].co
+00005830: 6e6a 2829 0a20 2020 2020 2020 2065 5f78  nj().        e_x
+00005840: 5f68 5f73 7461 7220 2d3d 2074 616e 5f66  _h_star -= tan_f
+00005850: 6965 6c64 735b 2245 2220 2b20 6469 6d32  ields["E" + dim2
+00005860: 5d20 2a20 7461 6e5f 6669 656c 6473 5b22  ] * tan_fields["
+00005870: 4822 202b 2064 696d 315d 2e63 6f6e 6a28  H" + dim1].conj(
+00005880: 290a 2020 2020 2020 2020 706f 796e 7469  ).        poynti
+00005890: 6e67 203d 2030 2e35 202a 206e 702e 7265  ng = 0.5 * np.re
+000058a0: 616c 2865 5f78 5f68 5f73 7461 7229 0a20  al(e_x_h_star). 
+000058b0: 2020 2020 2020 2072 6574 7572 6e20 706f         return po
+000058c0: 796e 7469 6e67 0a0a 2020 2020 6465 6620  ynting..    def 
+000058d0: 7061 636b 6167 655f 666c 7578 5f72 6573  package_flux_res
+000058e0: 756c 7473 2873 656c 662c 2066 6c75 785f  ults(self, flux_
+000058f0: 7661 6c75 6573 3a20 7872 2e44 6174 6141  values: xr.DataA
+00005900: 7272 6179 2920 2d3e 2041 6e79 3a0a 2020  rray) -> Any:.  
+00005910: 2020 2020 2020 2222 2248 6f77 2074 6f20        """How to 
+00005920: 7061 636b 6167 6520 666c 7578 2222 220a  package flux""".
+00005930: 2020 2020 2020 2020 7265 7475 726e 2046          return F
+00005940: 6c75 7844 6174 6141 7272 6179 2866 6c75  luxDataArray(flu
+00005950: 785f 7661 6c75 6573 290a 0a20 2020 2040  x_values)..    @
+00005960: 6361 6368 6564 5f70 726f 7065 7274 790a  cached_property.
+00005970: 2020 2020 6465 6620 666c 7578 2873 656c      def flux(sel
+00005980: 6629 202d 3e20 466c 7578 4461 7461 4172  f) -> FluxDataAr
+00005990: 7261 793a 0a20 2020 2020 2020 2022 2222  ray:.        """
+000059a0: 466c 7578 2066 6f72 2064 6174 6120 636f  Flux for data co
+000059b0: 7272 6573 706f 6e64 696e 6720 746f 2061  rresponding to a
+000059c0: 2032 4420 6d6f 6e69 746f 722e 2222 220a   2D monitor.""".
+000059d0: 0a20 2020 2020 2020 2023 2043 6f6d 7075  .        # Compu
+000059e0: 7465 2066 6c75 7820 6279 2069 6e74 6567  te flux by integ
+000059f0: 7261 7469 6e67 2050 6f79 6e74 696e 6720  rating Poynting 
+00005a00: 7665 6374 6f72 2069 6e2d 706c 616e 650a  vector in-plane.
+00005a10: 2020 2020 2020 2020 645f 6172 6561 203d          d_area =
+00005a20: 2073 656c 662e 5f64 6966 665f 6172 6561   self._diff_area
+00005a30: 0a20 2020 2020 2020 2070 6f79 6e74 696e  .        poyntin
+00005a40: 6720 3d20 7365 6c66 2e70 6f79 6e74 696e  g = self.poyntin
+00005a50: 670a 0a20 2020 2020 2020 2066 6c75 785f  g..        flux_
+00005a60: 7661 6c75 6573 203d 2070 6f79 6e74 696e  values = poyntin
+00005a70: 6720 2a20 645f 6172 6561 0a20 2020 2020  g * d_area.     
+00005a80: 2020 2066 6c75 785f 7661 6c75 6573 203d     flux_values =
+00005a90: 2066 6c75 785f 7661 6c75 6573 2e73 756d   flux_values.sum
+00005aa0: 2864 696d 3d64 5f61 7265 612e 6469 6d73  (dim=d_area.dims
+00005ab0: 290a 0a20 2020 2020 2020 2072 6574 7572  )..        retur
+00005ac0: 6e20 7365 6c66 2e70 6163 6b61 6765 5f66  n self.package_f
+00005ad0: 6c75 785f 7265 7375 6c74 7328 666c 7578  lux_results(flux
+00005ae0: 5f76 616c 7565 7329 0a0a 2020 2020 4063  _values)..    @c
+00005af0: 6163 6865 645f 7072 6f70 6572 7479 0a20  ached_property. 
+00005b00: 2020 2064 6566 206d 6f64 655f 6172 6561     def mode_area
+00005b10: 2873 656c 6629 202d 3e20 4672 6571 4d6f  (self) -> FreqMo
+00005b20: 6465 4461 7461 4172 7261 793a 0a20 2020  deDataArray:.   
+00005b30: 2020 2020 2072 2222 2245 6666 6563 7469       r"""Effecti
+00005b40: 7665 206d 6f64 6520 6172 6561 2063 6f72  ve mode area cor
+00005b50: 7265 7370 6f6e 6469 6e67 2074 6f20 6120  responding to a 
+00005b60: 3244 206d 6f6e 6974 6f72 2e0a 0a20 2020  2D monitor...   
+00005b70: 2020 2020 202e 2e20 6d61 7468 3a0a 0a20       .. math:.. 
+00005b80: 2020 2020 2020 2020 2020 5c66 7261 637b            \frac{
+00005b90: 5c6c 6566 7428 5c69 6e74 207c 457c 5e32  \left(\int |E|^2
+00005ba0: 205c 2c20 7b5c 726d 2064 7d53 5c72 6967   \, {\rm d}S\rig
+00005bb0: 6874 295e 327d 7b5c 696e 7420 7c45 7c5e  ht)^2}{\int |E|^
+00005bc0: 3420 5c2c 207b 5c72 6d20 647d 537d 0a20  4 \, {\rm d}S}. 
+00005bd0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+00005be0: 2020 2069 6e74 656e 7369 7479 203d 2073     intensity = s
+00005bf0: 656c 662e 696e 7465 6e73 6974 790a 2020  elf.intensity.  
+00005c00: 2020 2020 2020 2320 696e 7465 6772 6174        # integrat
+00005c10: 6520 6f76 6572 2074 6865 2070 6c61 6e65  e over the plane
+00005c20: 0a20 2020 2020 2020 2064 5f61 7265 6120  .        d_area 
+00005c30: 3d20 7365 6c66 2e5f 6469 6666 5f61 7265  = self._diff_are
+00005c40: 610a 2020 2020 2020 2020 6e75 6d20 3d20  a.        num = 
+00005c50: 2869 6e74 656e 7369 7479 202a 2064 5f61  (intensity * d_a
+00005c60: 7265 6129 2e73 756d 2864 696d 3d64 5f61  rea).sum(dim=d_a
+00005c70: 7265 612e 6469 6d73 2920 2a2a 2032 0a20  rea.dims) ** 2. 
+00005c80: 2020 2020 2020 2064 656e 203d 2028 696e         den = (in
+00005c90: 7465 6e73 6974 792a 2a32 202a 2064 5f61  tensity**2 * d_a
+00005ca0: 7265 6129 2e73 756d 2864 696d 3d64 5f61  rea).sum(dim=d_a
+00005cb0: 7265 612e 6469 6d73 290a 0a20 2020 2020  rea.dims)..     
+00005cc0: 2020 2061 7265 6120 3d20 6e75 6d20 2f20     area = num / 
+00005cd0: 6465 6e0a 2020 2020 2020 2020 6966 2068  den.        if h
+00005ce0: 6173 6174 7472 2873 656c 662e 6d6f 6e69  asattr(self.moni
+00005cf0: 746f 722c 2022 6d6f 6465 5f73 7065 6322  tor, "mode_spec"
+00005d00: 293a 0a20 2020 2020 2020 2020 2020 2061  ):.            a
+00005d10: 7265 6120 2a3d 206e 702e 636f 7328 7365  rea *= np.cos(se
+00005d20: 6c66 2e6d 6f6e 6974 6f72 2e6d 6f64 655f  lf.monitor.mode_
+00005d30: 7370 6563 2e61 6e67 6c65 5f74 6865 7461  spec.angle_theta
+00005d40: 290a 0a20 2020 2020 2020 2072 6574 7572  )..        retur
+00005d50: 6e20 4672 6571 4d6f 6465 4461 7461 4172  n FreqModeDataAr
+00005d60: 7261 7928 6172 6561 290a 0a20 2020 2064  ray(area)..    d
+00005d70: 6566 2064 6f74 280a 2020 2020 2020 2020  ef dot(.        
+00005d80: 7365 6c66 2c20 6669 656c 645f 6461 7461  self, field_data
+00005d90: 3a20 556e 696f 6e5b 4669 656c 6444 6174  : Union[FieldDat
+00005da0: 612c 204d 6f64 6544 6174 612c 204d 6f64  a, ModeData, Mod
+00005db0: 6553 6f6c 7665 7244 6174 615d 2c20 636f  eSolverData], co
+00005dc0: 6e6a 7567 6174 653a 2062 6f6f 6c20 3d20  njugate: bool = 
+00005dd0: 5472 7565 0a20 2020 2029 202d 3e20 4d6f  True.    ) -> Mo
+00005de0: 6465 416d 7073 4461 7461 4172 7261 793a  deAmpsDataArray:
+00005df0: 0a20 2020 2020 2020 2072 2222 2244 6f74  .        r"""Dot
+00005e00: 2070 726f 6475 6374 2028 6d6f 6461 6c20   product (modal 
+00005e10: 6f76 6572 6c61 7029 2077 6974 6820 616e  overlap) with an
+00005e20: 6f74 6865 7220 3a63 6c61 7373 3a60 2e46  other :class:`.F
+00005e30: 6965 6c64 4461 7461 6020 6f62 6a65 6374  ieldData` object
+00005e40: 2e20 426f 7468 2064 6174 6173 6574 7320  . Both datasets 
+00005e50: 6861 7665 0a20 2020 2020 2020 2074 6f20  have.        to 
+00005e60: 6265 2066 7265 7175 656e 6379 2d64 6f6d  be frequency-dom
+00005e70: 6169 6e20 6461 7461 2061 7373 6f63 6961  ain data associa
+00005e80: 7465 6420 7769 7468 2061 2032 4420 6d6f  ted with a 2D mo
+00005e90: 6e69 746f 722e 2041 6c6f 6e67 2074 6865  nitor. Along the
+00005ea0: 2074 616e 6765 6e74 6961 6c20 6469 7265   tangential dire
+00005eb0: 6374 696f 6e73 2c0a 2020 2020 2020 2020  ctions,.        
+00005ec0: 7468 6520 6461 7461 7365 7473 2068 6176  the datasets hav
+00005ed0: 6520 746f 2068 6176 6520 7468 6520 7361  e to have the sa
+00005ee0: 6d65 2064 6973 6372 6574 697a 6174 696f  me discretizatio
+00005ef0: 6e2e 2041 6c6f 6e67 2074 6865 206e 6f72  n. Along the nor
+00005f00: 6d61 6c20 6469 7265 6374 696f 6e2c 2074  mal direction, t
+00005f10: 6865 206d 6f6e 6974 6f72 0a20 2020 2020  he monitor.     
+00005f20: 2020 2070 6f73 6974 696f 6e20 6d61 7920     position may 
+00005f30: 6469 6666 6572 2061 6e64 2069 7320 6967  differ and is ig
+00005f40: 6e6f 7265 642e 204f 7468 6572 2063 6f6f  nored. Other coo
+00005f50: 7264 696e 6174 6573 2028 6060 6672 6571  rdinates (``freq
+00005f60: 7565 6e63 7960 602c 2060 606d 6f64 655f  uency``, ``mode_
+00005f70: 696e 6465 7860 6029 2068 6176 650a 2020  index``) have.  
+00005f80: 2020 2020 2020 746f 2062 6520 6569 7468        to be eith
+00005f90: 6572 2069 6465 6e74 6963 616c 206f 7220  er identical or 
+00005fa0: 6272 6f61 6463 6173 7461 626c 652e 2042  broadcastable. B
+00005fb0: 726f 6164 6361 7374 696e 6720 6973 2061  roadcasting is a
+00005fc0: 6c73 6f20 7375 7070 6f72 7465 6420 696e  lso supported in
+00005fd0: 2074 6865 2063 6173 6520 696e 0a20 2020   the case in.   
+00005fe0: 2020 2020 2077 6869 6368 2074 6865 206f       which the o
+00005ff0: 7468 6572 2060 6066 6965 6c64 5f64 6174  ther ``field_dat
+00006000: 6160 6020 6861 7320 6120 6469 6d65 6e73  a`` has a dimens
+00006010: 696f 6e20 6f66 2073 697a 6520 3120 7768  ion of size 1 wh
+00006020: 6f73 6520 636f 6f72 6469 6e61 7465 2069  ose coordinate i
+00006030: 7320 6e6f 7420 696e 2074 6865 206c 6973  s not in the lis
+00006040: 740a 2020 2020 2020 2020 6f66 2063 6f6f  t.        of coo
+00006050: 7264 696e 6174 6573 2069 6e20 7468 6520  rdinates in the 
+00006060: 6060 7365 6c66 6060 2064 6174 6173 6574  ``self`` dataset
+00006070: 2061 6c6f 6e67 2074 6865 2063 6f72 7265   along the corre
+00006080: 7370 6f6e 6469 6e67 2064 696d 656e 7369  sponding dimensi
+00006090: 6f6e 2e20 496e 2074 6861 7420 6361 7365  on. In that case
+000060a0: 2c20 7468 650a 2020 2020 2020 2020 636f  , the.        co
+000060b0: 6f72 6469 6e61 7465 7320 6f66 2074 6865  ordinates of the
+000060c0: 2060 6073 656c 6660 6020 6461 7461 7365   ``self`` datase
+000060d0: 7420 6172 6520 7573 6564 2069 6e20 7468  t are used in th
+000060e0: 6520 6f75 7470 7574 2e0a 0a20 2020 2020  e output...     
+000060f0: 2020 2054 6865 2064 6f74 2070 726f 6475     The dot produ
+00006100: 6374 2069 7320 6465 6669 6e65 6420 6173  ct is defined as
+00006110: 3a0a 0a20 2020 2020 2020 202e 2e20 6d61  :..        .. ma
+00006120: 7468 3a0a 0a20 2020 2020 2020 2020 2020  th:..           
+00006130: 5c66 7261 637b 317d 7b34 7d20 5c69 6e74  \frac{1}{4} \int
+00006140: 205c 6c65 6674 2820 455f 3020 5c74 696d   \left( E_0 \tim
+00006150: 6573 2048 5f31 5e2a 202b 2048 5f30 5e2a  es H_1^* + H_0^*
+00006160: 205c 7469 6d65 7320 455f 3120 5c29 205c   \times E_1 \) \
+00006170: 2c20 7b5c 726d 2064 7d53 0a0a 2020 2020  , {\rm d}S..    
+00006180: 2020 2020 5061 7261 6d65 7465 7273 0a20      Parameters. 
+00006190: 2020 2020 2020 202d 2d2d 2d2d 2d2d 2d2d         ---------
+000061a0: 2d0a 2020 2020 2020 2020 6669 656c 645f  -.        field_
+000061b0: 6461 7461 203a 203a 636c 6173 733a 6045  data : :class:`E
+000061c0: 6c65 6374 726f 6d61 676e 6574 6963 4669  lectromagneticFi
+000061d0: 656c 6444 6174 6160 0a20 2020 2020 2020  eldData`.       
+000061e0: 2020 2020 2041 2064 6174 6120 696e 7374       A data inst
+000061f0: 616e 6365 2074 6f20 636f 6d70 7574 6520  ance to compute 
+00006200: 7468 6520 646f 7420 7072 6f64 7563 7420  the dot product 
+00006210: 7769 7468 2e0a 2020 2020 2020 2020 636f  with..        co
+00006220: 6e6a 7567 6174 6520 3a20 626f 6f6c 2c20  njugate : bool, 
+00006230: 6f70 7469 6f6e 616c 0a20 2020 2020 2020  optional.       
+00006240: 2020 2020 2049 6620 6060 5472 7565 6060       If ``True``
+00006250: 2028 6465 6661 756c 7429 2c20 7468 6520   (default), the 
+00006260: 646f 7420 7072 6f64 7563 7420 6973 2064  dot product is d
+00006270: 6566 696e 6564 2061 7320 6162 6f76 652e  efined as above.
+00006280: 2049 6620 6060 4661 6c73 6560 602c 2074   If ``False``, t
+00006290: 6865 2064 6566 696e 6974 696f 6e0a 2020  he definition.  
+000062a0: 2020 2020 2020 2020 2020 6973 2073 696d            is sim
+000062b0: 696c 6172 2c20 6275 7420 7769 7468 6f75  ilar, but withou
+000062c0: 7420 7468 6520 636f 6d70 6c65 7820 636f  t the complex co
+000062d0: 6e6a 7567 6174 696f 6e20 6f66 2074 6865  njugation of the
+000062e0: 2024 4824 2066 6965 6c64 732e 0a0a 2020   $H$ fields...  
+000062f0: 2020 2020 2020 4e6f 7465 0a20 2020 2020        Note.     
+00006300: 2020 202d 2d2d 2d0a 2020 2020 2020 2020     ----.        
+00006310: 2020 2020 5468 6520 646f 7420 7072 6f64      The dot prod
+00006320: 7563 7420 7769 7468 2061 6e64 2077 6974  uct with and wit
+00006330: 686f 7574 2063 6f6e 6a75 6761 7469 6f6e  hout conjugation
+00006340: 2069 7320 6571 7569 7661 6c65 6e74 2028   is equivalent (
+00006350: 7570 2074 6f20 6120 7068 6173 6529 2066  up to a phase) f
+00006360: 6f72 0a20 2020 2020 2020 2020 2020 206d  or.            m
+00006370: 6f64 6573 2069 6e20 6c6f 7373 6c65 7373  odes in lossless
+00006380: 2077 6176 6567 7569 6465 7320 6275 7420   waveguides but 
+00006390: 6469 6666 6572 7320 666f 7220 6d6f 6465  differs for mode
+000063a0: 7320 696e 206c 6f73 7379 206d 6174 6572  s in lossy mater
+000063b0: 6961 6c73 2e20 496e 2074 6861 7420 6361  ials. In that ca
+000063c0: 7365 2c0a 2020 2020 2020 2020 2020 2020  se,.            
+000063d0: 7468 6520 636f 6e6a 7567 6174 6564 2064  the conjugated d
+000063e0: 6f74 2070 726f 6475 6374 2063 616e 2062  ot product can b
+000063f0: 6520 696e 7465 7270 7265 7465 6420 6173  e interpreted as
+00006400: 2074 6865 2066 7261 6374 696f 6e20 6f66   the fraction of
+00006410: 2074 6865 2070 6f77 6572 206f 6620 7468   the power of th
+00006420: 6520 6669 7273 740a 2020 2020 2020 2020  e first.        
+00006430: 2020 2020 6d6f 6465 2063 6172 7269 6564      mode carried
+00006440: 2062 7920 7468 6520 7365 636f 6e64 2c20   by the second, 
+00006450: 6275 7420 6d6f 6465 7320 6172 6520 6e6f  but modes are no
+00006460: 7420 6f72 7468 6f67 6f6e 616c 2077 6974  t orthogonal wit
+00006470: 6820 7265 7370 6563 7420 746f 2074 6861  h respect to tha
+00006480: 7420 7072 6f64 7563 740a 2020 2020 2020  t product.      
+00006490: 2020 2020 2020 616e 6420 7468 6520 7375        and the su
+000064a0: 6d20 6f66 2063 6172 7269 6564 2070 6f77  m of carried pow
+000064b0: 6572 2066 7261 6374 696f 6e73 206d 6179  er fractions may
+000064c0: 2062 6520 6469 6666 6572 656e 7420 6672   be different fr
+000064d0: 6f6d 2074 6865 2074 6f74 616c 2066 6c75  om the total flu
+000064e0: 782e 0a20 2020 2020 2020 2020 2020 2049  x..            I
+000064f0: 6e20 7468 6520 6e6f 6e2d 636f 6e6a 7567  n the non-conjug
+00006500: 6174 6564 2064 6566 696e 6974 696f 6e2c  ated definition,
+00006510: 206d 6f64 6573 2061 7265 206f 7274 686f   modes are ortho
+00006520: 676f 6e61 6c2c 2062 7574 2074 6865 2069  gonal, but the i
+00006530: 6e74 6572 7072 6574 6174 696f 6e20 6f66  nterpretation of
+00006540: 2074 6865 0a20 2020 2020 2020 2020 2020   the.           
+00006550: 2064 6f74 2070 726f 6475 6374 2070 6f77   dot product pow
+00006560: 6572 2063 6172 7269 6564 2062 7920 6120  er carried by a 
+00006570: 6769 7665 6e20 6d6f 6465 2069 7320 6e6f  given mode is no
+00006580: 206c 6f6e 6765 7220 7661 6c69 642e 0a20   longer valid.. 
+00006590: 2020 2020 2020 2022 2222 0a0a 2020 2020         """..    
+000065a0: 2020 2020 2320 5461 6e67 656e 7469 616c      # Tangential
+000065b0: 2066 6965 6c64 7320 666f 7220 6375 7272   fields for curr
+000065c0: 656e 7420 616e 6420 6f74 6865 7220 6669  ent and other fi
+000065d0: 656c 6420 6461 7461 0a20 2020 2020 2020  eld data.       
+000065e0: 2066 6965 6c64 735f 7365 6c66 203d 2073   fields_self = s
+000065f0: 656c 662e 5f63 6f6c 6f63 6174 6564 5f74  elf._colocated_t
+00006600: 616e 6765 6e74 6961 6c5f 6669 656c 6473  angential_fields
+00006610: 0a0a 2020 2020 2020 2020 6669 656c 6473  ..        fields
+00006620: 5f6f 7468 6572 203d 2066 6965 6c64 5f64  _other = field_d
+00006630: 6174 612e 5f63 6f6c 6f63 6174 6564 5f74  ata._colocated_t
+00006640: 616e 6765 6e74 6961 6c5f 6669 656c 6473  angential_fields
+00006650: 0a20 2020 2020 2020 2069 6620 636f 6e6a  .        if conj
+00006660: 7567 6174 653a 0a20 2020 2020 2020 2020  ugate:.         
+00006670: 2020 2066 6965 6c64 735f 7365 6c66 203d     fields_self =
+00006680: 207b 6b65 793a 2066 6965 6c64 2e63 6f6e   {key: field.con
+00006690: 6a28 2920 666f 7220 6b65 792c 2066 6965  j() for key, fie
+000066a0: 6c64 2069 6e20 6669 656c 6473 5f73 656c  ld in fields_sel
+000066b0: 662e 6974 656d 7328 297d 0a0a 2020 2020  f.items()}..    
+000066c0: 2020 2020 2320 4472 6f70 2073 697a 652d      # Drop size-
+000066d0: 3120 6469 6d65 6e73 696f 6e73 2069 6e20  1 dimensions in 
+000066e0: 7468 6520 6f74 6865 7220 6461 7461 0a20  the other data. 
+000066f0: 2020 2020 2020 2066 6965 6c64 735f 6f74         fields_ot
+00006700: 6865 7220 3d20 7b6b 6579 3a20 6669 656c  her = {key: fiel
+00006710: 642e 7371 7565 657a 6528 6472 6f70 3d54  d.squeeze(drop=T
+00006720: 7275 6529 2066 6f72 206b 6579 2c20 6669  rue) for key, fi
+00006730: 656c 6420 696e 2066 6965 6c64 735f 6f74  eld in fields_ot
+00006740: 6865 722e 6974 656d 7328 297d 0a0a 2020  her.items()}..  
+00006750: 2020 2020 2020 2320 4372 6f73 7320 7072        # Cross pr
+00006760: 6f64 7563 7473 206f 6620 6669 656c 6473  oducts of fields
+00006770: 0a20 2020 2020 2020 2064 696d 312c 2064  .        dim1, d
+00006780: 696d 3220 3d20 7365 6c66 2e5f 7461 6e67  im2 = self._tang
+00006790: 656e 7469 616c 5f64 696d 730a 2020 2020  ential_dims.    
+000067a0: 2020 2020 655f 7365 6c66 5f78 5f68 5f6f      e_self_x_h_o
+000067b0: 7468 6572 203d 2066 6965 6c64 735f 7365  ther = fields_se
+000067c0: 6c66 5b22 4522 202b 2064 696d 315d 202a  lf["E" + dim1] *
+000067d0: 2066 6965 6c64 735f 6f74 6865 725b 2248   fields_other["H
+000067e0: 2220 2b20 6469 6d32 5d0a 2020 2020 2020  " + dim2].      
+000067f0: 2020 655f 7365 6c66 5f78 5f68 5f6f 7468    e_self_x_h_oth
+00006800: 6572 202d 3d20 6669 656c 6473 5f73 656c  er -= fields_sel
+00006810: 665b 2245 2220 2b20 6469 6d32 5d20 2a20  f["E" + dim2] * 
+00006820: 6669 656c 6473 5f6f 7468 6572 5b22 4822  fields_other["H"
+00006830: 202b 2064 696d 315d 0a20 2020 2020 2020   + dim1].       
+00006840: 2068 5f73 656c 665f 785f 655f 6f74 6865   h_self_x_e_othe
+00006850: 7220 3d20 6669 656c 6473 5f73 656c 665b  r = fields_self[
+00006860: 2248 2220 2b20 6469 6d31 5d20 2a20 6669  "H" + dim1] * fi
+00006870: 656c 6473 5f6f 7468 6572 5b22 4522 202b  elds_other["E" +
+00006880: 2064 696d 325d 0a20 2020 2020 2020 2068   dim2].        h
+00006890: 5f73 656c 665f 785f 655f 6f74 6865 7220  _self_x_e_other 
+000068a0: 2d3d 2066 6965 6c64 735f 7365 6c66 5b22  -= fields_self["
+000068b0: 4822 202b 2064 696d 325d 202a 2066 6965  H" + dim2] * fie
+000068c0: 6c64 735f 6f74 6865 725b 2245 2220 2b20  lds_other["E" + 
+000068d0: 6469 6d31 5d0a 0a20 2020 2020 2020 2023  dim1]..        #
+000068e0: 2049 6e74 6567 7261 7465 206f 7665 7220   Integrate over 
+000068f0: 706c 616e 650a 2020 2020 2020 2020 645f  plane.        d_
+00006900: 6172 6561 203d 2073 656c 662e 5f64 6966  area = self._dif
+00006910: 665f 6172 6561 0a20 2020 2020 2020 2069  f_area.        i
+00006920: 6e74 6567 7261 6e64 203d 2028 655f 7365  ntegrand = (e_se
+00006930: 6c66 5f78 5f68 5f6f 7468 6572 202d 2068  lf_x_h_other - h
+00006940: 5f73 656c 665f 785f 655f 6f74 6865 7229  _self_x_e_other)
+00006950: 202a 2064 5f61 7265 610a 2020 2020 2020   * d_area.      
+00006960: 2020 7265 7475 726e 204d 6f64 6541 6d70    return ModeAmp
+00006970: 7344 6174 6141 7272 6179 2830 2e32 3520  sDataArray(0.25 
+00006980: 2a20 696e 7465 6772 616e 642e 7375 6d28  * integrand.sum(
+00006990: 6469 6d3d 645f 6172 6561 2e64 696d 7329  dim=d_area.dims)
+000069a0: 290a 0a20 2020 2064 6566 205f 696e 7465  )..    def _inte
+000069b0: 7270 6f6c 6174 6564 5f74 616e 6765 6e74  rpolated_tangent
+000069c0: 6961 6c5f 6669 656c 6473 2873 656c 662c  ial_fields(self,
+000069d0: 2063 6f6f 7264 733a 2041 7272 6179 466c   coords: ArrayFl
+000069e0: 6f61 7432 4429 202d 3e20 4469 6374 5b73  oat2D) -> Dict[s
+000069f0: 7472 2c20 4461 7461 4172 7261 795d 3a0a  tr, DataArray]:.
+00006a00: 2020 2020 2020 2020 2222 2246 6f72 2032          """For 2
+00006a10: 4420 6d6f 6e69 746f 7273 2c20 696e 7465  D monitors, inte
+00006a20: 7270 6f6c 6174 6520 7468 6973 2066 6965  rpolate this fie
+00006a30: 6c64 7320 746f 2067 6976 656e 2063 6f6f  lds to given coo
+00006a40: 7264 7320 696e 2074 6865 2074 616e 6765  rds in the tange
+00006a50: 6e74 6961 6c20 706c 616e 652e 0a0a 2020  ntial plane...  
+00006a60: 2020 2020 2020 5061 7261 6d65 7465 7273        Parameters
+00006a70: 0a20 2020 2020 2020 202d 2d2d 2d2d 2d2d  .        -------
+00006a80: 2d2d 2d0a 2020 2020 2020 2020 636f 6f72  ---.        coor
+00006a90: 6473 203a 2041 7272 6179 466c 6f61 7432  ds : ArrayFloat2
+00006aa0: 440a 2020 2020 2020 2020 2020 2020 496e  D.            In
+00006ab0: 7465 7270 6f6c 6174 696f 6e20 636f 6f72  terpolation coor
+00006ac0: 6473 2069 6e20 7468 6520 6d6f 6e69 746f  ds in the monito
+00006ad0: 7227 7320 7461 6e67 656e 7469 616c 2070  r's tangential p
+00006ae0: 6c61 6e65 2e0a 0a20 2020 2020 2020 2052  lane...        R
+00006af0: 6574 7572 6e0a 2020 2020 2020 2020 2d2d  eturn.        --
+00006b00: 2d2d 2d2d 0a20 2020 2020 2020 2020 2020  ----.           
+00006b10: 2044 6963 7469 6f6e 6172 7920 7769 7468   Dictionary with
+00006b20: 2069 6e74 6572 706f 6c61 7465 6420 6669   interpolated fi
+00006b30: 656c 6473 2e0a 2020 2020 2020 2020 2222  elds..        ""
+00006b40: 220a 2020 2020 2020 2020 6669 656c 6473  ".        fields
+00006b50: 203d 2073 656c 662e 5f74 616e 6765 6e74   = self._tangent
+00006b60: 6961 6c5f 6669 656c 6473 0a0a 2020 2020  ial_fields..    
+00006b70: 2020 2020 696e 7465 7270 5f64 6963 7420      interp_dict 
+00006b80: 3d20 7b22 6173 7375 6d65 5f73 6f72 7465  = {"assume_sorte
+00006b90: 6422 3a20 5472 7565 7d0a 2020 2020 2020  d": True}.      
+00006ba0: 2020 666f 7220 6469 6d2c 2063 656e 7473    for dim, cents
+00006bb0: 2069 6e20 7a69 7028 7365 6c66 2e5f 7461   in zip(self._ta
+00006bc0: 6e67 656e 7469 616c 5f64 696d 732c 2063  ngential_dims, c
+00006bd0: 6f6f 7264 7329 3a0a 2020 2020 2020 2020  oords):.        
+00006be0: 2020 2020 6966 2063 656e 7473 2e73 697a      if cents.siz
+00006bf0: 6520 3e20 303a 0a20 2020 2020 2020 2020  e > 0:.         
+00006c00: 2020 2020 2020 2069 6e74 6572 705f 6469         interp_di
+00006c10: 6374 5b64 696d 5d20 3d20 6365 6e74 730a  ct[dim] = cents.
+00006c20: 0a20 2020 2020 2020 206b 7761 7267 7320  .        kwargs 
+00006c30: 3d20 7b22 626f 756e 6473 5f65 7272 6f72  = {"bounds_error
+00006c40: 223a 2046 616c 7365 2c20 2266 696c 6c5f  ": False, "fill_
+00006c50: 7661 6c75 6522 3a20 302e 307d 0a20 2020  value": 0.0}.   
+00006c60: 2020 2020 2066 6f72 2063 6f6d 706f 6e65       for compone
+00006c70: 6e74 2c20 6669 656c 6420 696e 2066 6965  nt, field in fie
+00006c80: 6c64 732e 6974 656d 7328 293a 0a20 2020  lds.items():.   
+00006c90: 2020 2020 2020 2020 2066 6965 6c64 735b           fields[
+00006ca0: 636f 6d70 6f6e 656e 745d 203d 2066 6965  component] = fie
+00006cb0: 6c64 2e69 6e74 6572 7028 6b77 6172 6773  ld.interp(kwargs
+00006cc0: 3d6b 7761 7267 732c 202a 2a69 6e74 6572  =kwargs, **inter
+00006cd0: 705f 6469 6374 290a 0a20 2020 2020 2020  p_dict)..       
+00006ce0: 2072 6574 7572 6e20 6669 656c 6473 0a0a   return fields..
+00006cf0: 2020 2020 6465 6620 6f75 7465 725f 646f      def outer_do
+00006d00: 7428 0a20 2020 2020 2020 2073 656c 662c  t(.        self,
+00006d10: 2066 6965 6c64 5f64 6174 613a 2055 6e69   field_data: Uni
+00006d20: 6f6e 5b46 6965 6c64 4461 7461 2c20 4d6f  on[FieldData, Mo
+00006d30: 6465 4461 7461 5d2c 2063 6f6e 6a75 6761  deData], conjuga
+00006d40: 7465 3a20 626f 6f6c 203d 2054 7275 650a  te: bool = True.
+00006d50: 2020 2020 2920 2d3e 204d 6978 6564 4d6f      ) -> MixedMo
+00006d60: 6465 4461 7461 4172 7261 793a 0a20 2020  deDataArray:.   
+00006d70: 2020 2020 2072 2222 2244 6f74 2070 726f       r"""Dot pro
+00006d80: 6475 6374 2028 6d6f 6461 6c20 6f76 6572  duct (modal over
+00006d90: 6c61 7029 2077 6974 6820 616e 6f74 6865  lap) with anothe
+00006da0: 7220 3a63 6c61 7373 3a60 2e46 6965 6c64  r :class:`.Field
+00006db0: 4461 7461 6020 6f62 6a65 6374 2e0a 0a20  Data` object... 
+00006dc0: 2020 2020 2020 2054 6865 2074 616e 6765         The tange
+00006dd0: 6e74 6961 6c20 6669 656c 6473 2066 726f  ntial fields fro
+00006de0: 6d20 6060 6669 656c 645f 6461 7461 6060  m ``field_data``
+00006df0: 2061 7265 2069 6e74 6572 706f 6c61 7465   are interpolate
+00006e00: 6420 746f 2074 6869 7320 6f62 6a65 6374  d to this object
+00006e10: 2773 2067 7269 642c 2073 6f20 7468 650a  's grid, so the.
+00006e20: 2020 2020 2020 2020 6461 7461 2061 7272          data arr
+00006e30: 6179 7320 646f 6e27 7420 6e65 6564 2074  ays don't need t
+00006e40: 6f20 6861 7665 2074 6865 2073 616d 6520  o have the same 
+00006e50: 6469 7363 7265 7469 7a61 7469 6f6e 2e20  discretization. 
+00006e60: 2054 6865 2063 616c 6375 6c61 7469 6f6e   The calculation
+00006e70: 2069 7320 7065 7266 6f72 6d65 6420 666f   is performed fo
+00006e80: 720a 2020 2020 2020 2020 616c 6c20 636f  r.        all co
+00006e90: 6d6d 6f6e 2066 7265 7175 656e 6369 6573  mmon frequencies
+00006ea0: 2062 6574 7765 656e 2064 6174 6120 6172   between data ar
+00006eb0: 7261 7973 2e20 2049 6e20 7468 6520 6f75  rays.  In the ou
+00006ec0: 7470 7574 2c20 6060 6d6f 6465 5f69 6e64  tput, ``mode_ind
+00006ed0: 6578 5f30 6060 2061 6e64 0a20 2020 2020  ex_0`` and.     
+00006ee0: 2020 2060 606d 6f64 655f 696e 6465 785f     ``mode_index_
+00006ef0: 3160 6020 6172 6520 7468 6520 6d6f 6465  1`` are the mode
+00006f00: 2069 6e64 6963 6573 2066 726f 6d20 7468   indices from th
+00006f10: 6973 206f 626a 6563 7420 616e 6420 6060  is object and ``
+00006f20: 6669 656c 645f 6461 7461 6060 2c20 7265  field_data``, re
+00006f30: 7370 6563 7469 7665 6c79 2c20 6966 0a20  spectively, if. 
+00006f40: 2020 2020 2020 2074 6865 7920 6172 6520         they are 
+00006f50: 696e 7374 616e 6365 7320 6f66 2060 604d  instances of ``M
+00006f60: 6f64 6544 6174 6160 602e 0a0a 2020 2020  odeData``...    
+00006f70: 2020 2020 5468 6520 646f 7420 7072 6f64      The dot prod
+00006f80: 7563 7420 6973 2064 6566 696e 6564 2061  uct is defined a
+00006f90: 733a 0a0a 2020 2020 2020 2020 2e2e 206d  s:..        .. m
+00006fa0: 6174 683a 0a0a 2020 2020 2020 2020 2020  ath:..          
+00006fb0: 205c 6672 6163 7b31 7d7b 347d 205c 696e   \frac{1}{4} \in
+00006fc0: 7420 5c6c 6566 7428 2045 5f30 205c 7469  t \left( E_0 \ti
+00006fd0: 6d65 7320 485f 315e 2a20 2b20 485f 305e  mes H_1^* + H_0^
+00006fe0: 2a20 5c74 696d 6573 2045 5f31 205c 2920  * \times E_1 \) 
+00006ff0: 5c2c 207b 5c72 6d20 647d 530a 0a20 2020  \, {\rm d}S..   
+00007000: 2020 2020 2050 6172 616d 6574 6572 730a       Parameters.
+00007010: 2020 2020 2020 2020 2d2d 2d2d 2d2d 2d2d          --------
+00007020: 2d2d 0a20 2020 2020 2020 2066 6965 6c64  --.        field
+00007030: 5f64 6174 6120 3a20 3a63 6c61 7373 3a60  _data : :class:`
+00007040: 456c 6563 7472 6f6d 6167 6e65 7469 6346  ElectromagneticF
+00007050: 6965 6c64 4461 7461 600a 2020 2020 2020  ieldData`.      
+00007060: 2020 2020 2020 4120 6461 7461 2069 6e73        A data ins
+00007070: 7461 6e63 6520 746f 2063 6f6d 7075 7465  tance to compute
+00007080: 2074 6865 2064 6f74 2070 726f 6475 6374   the dot product
+00007090: 2077 6974 682e 0a20 2020 2020 2020 2063   with..        c
+000070a0: 6f6e 6a75 6761 7465 203a 2062 6f6f 6c20  onjugate : bool 
+000070b0: 3d20 5472 7565 0a20 2020 2020 2020 2020  = True.         
+000070c0: 2020 2049 6620 6060 5472 7565 6060 2028     If ``True`` (
+000070d0: 6465 6661 756c 7429 2c20 7468 6520 646f  default), the do
+000070e0: 7420 7072 6f64 7563 7420 6973 2064 6566  t product is def
+000070f0: 696e 6564 2061 7320 6162 6f76 652e 2049  ined as above. I
+00007100: 6620 6060 4661 6c73 6560 602c 2074 6865  f ``False``, the
+00007110: 2064 6566 696e 6974 696f 6e0a 2020 2020   definition.    
+00007120: 2020 2020 2020 2020 6973 2073 696d 696c          is simil
+00007130: 6172 2c20 6275 7420 7769 7468 6f75 7420  ar, but without 
+00007140: 7468 6520 636f 6d70 6c65 7820 636f 6e6a  the complex conj
+00007150: 7567 6174 696f 6e20 6f66 2074 6865 2024  ugation of the $
+00007160: 4824 2066 6965 6c64 732e 0a0a 2020 2020  H$ fields...    
+00007170: 2020 2020 5265 7475 726e 730a 2020 2020      Returns.    
+00007180: 2020 2020 2d2d 2d2d 2d2d 2d0a 2020 2020      -------.    
+00007190: 2020 2020 3a63 6c61 7373 3a60 7861 7272      :class:`xarr
+000071a0: 6179 2e44 6174 6141 7272 6179 600a 2020  ay.DataArray`.  
+000071b0: 2020 2020 2020 2020 2020 4461 7461 2061            Data a
+000071c0: 7272 6179 2077 6974 6820 7468 6520 636f  rray with the co
+000071d0: 6d70 6c65 782d 7661 6c75 6564 206d 6f64  mplex-valued mod
+000071e0: 616c 206f 7665 726c 6170 7320 6265 7477  al overlaps betw
+000071f0: 6565 6e20 7468 6520 7477 6f20 6d6f 6465  een the two mode
+00007200: 2064 6174 612e 0a0a 2020 2020 2020 2020   data...        
+00007210: 5365 6520 616c 736f 0a20 2020 2020 2020  See also.       
+00007220: 202d 2d2d 2d2d 2d2d 2d0a 2020 2020 2020   --------.      
+00007230: 2020 3a6d 656d 6265 723a 6064 6f74 600a    :member:`dot`.
+00007240: 2020 2020 2020 2020 2222 220a 0a20 2020          """..   
+00007250: 2020 2020 2074 616e 5f64 696d 7320 3d20       tan_dims = 
+00007260: 7365 6c66 2e5f 7461 6e67 656e 7469 616c  self._tangential
+00007270: 5f64 696d 730a 0a20 2020 2020 2020 2069  _dims..        i
+00007280: 6620 6e6f 7420 616c 6c28 6120 3d3d 2062  f not all(a == b
+00007290: 2066 6f72 2061 2c20 6220 696e 207a 6970   for a, b in zip
+000072a0: 2874 616e 5f64 696d 732c 2066 6965 6c64  (tan_dims, field
+000072b0: 5f64 6174 612e 5f74 616e 6765 6e74 6961  _data._tangentia
+000072c0: 6c5f 6469 6d73 2929 3a0a 2020 2020 2020  l_dims)):.      
+000072d0: 2020 2020 2020 7261 6973 6520 4461 7461        raise Data
+000072e0: 4572 726f 7228 2254 616e 6765 6e74 6961  Error("Tangentia
+000072f0: 6c20 6469 6d65 6e73 696f 6e73 206d 7573  l dimensions mus
+00007300: 7420 6d61 7463 6820 6265 7477 6565 6e20  t match between 
+00007310: 7468 6520 7477 6f20 6d6f 6e69 746f 7273  the two monitors
+00007320: 2e22 290a 0a20 2020 2020 2020 2023 2054  .")..        # T
+00007330: 616e 6765 6e74 6961 6c20 6669 656c 6473  angential fields
+00007340: 2066 6f72 2063 7572 7265 6e74 0a20 2020   for current.   
+00007350: 2020 2020 2066 6965 6c64 735f 7365 6c66       fields_self
+00007360: 203d 2073 656c 662e 5f63 6f6c 6f63 6174   = self._colocat
+00007370: 6564 5f74 616e 6765 6e74 6961 6c5f 6669  ed_tangential_fi
+00007380: 656c 6473 0a20 2020 2020 2020 2069 6620  elds.        if 
+00007390: 636f 6e6a 7567 6174 653a 0a20 2020 2020  conjugate:.     
+000073a0: 2020 2020 2020 2066 6965 6c64 735f 7365         fields_se
+000073b0: 6c66 203d 207b 636f 6d70 6f6e 656e 743a  lf = {component:
+000073c0: 2066 6965 6c64 2e63 6f6e 6a28 2920 666f   field.conj() fo
+000073d0: 7220 636f 6d70 6f6e 656e 742c 2066 6965  r component, fie
+000073e0: 6c64 2069 6e20 6669 656c 6473 5f73 656c  ld in fields_sel
+000073f0: 662e 6974 656d 7328 297d 0a0a 2020 2020  f.items()}..    
+00007400: 2020 2020 2320 5461 6e67 656e 7469 616c      # Tangential
+00007410: 2066 6965 6c64 7320 666f 7220 6f74 6865   fields for othe
+00007420: 7220 6461 7461 0a0a 2020 2020 2020 2020  r data..        
+00007430: 6669 656c 6473 5f6f 7468 6572 203d 2066  fields_other = f
+00007440: 6965 6c64 5f64 6174 612e 5f69 6e74 6572  ield_data._inter
+00007450: 706f 6c61 7465 645f 7461 6e67 656e 7469  polated_tangenti
+00007460: 616c 5f66 6965 6c64 7328 7365 6c66 2e5f  al_fields(self._
+00007470: 706c 616e 655f 6772 6964 5f62 6f75 6e64  plane_grid_bound
+00007480: 6172 6965 7329 0a0a 2020 2020 2020 2020  aries)..        
+00007490: 2320 5461 6e67 656e 7469 616c 2066 6965  # Tangential fie
+000074a0: 6c64 2063 6f6d 706f 6e65 6e74 206e 616d  ld component nam
+000074b0: 6573 0a20 2020 2020 2020 2064 696d 312c  es.        dim1,
+000074c0: 2064 696d 3220 3d20 7461 6e5f 6469 6d73   dim2 = tan_dims
+000074d0: 0a20 2020 2020 2020 2065 5f31 203d 2022  .        e_1 = "
+000074e0: 4522 202b 2064 696d 310a 2020 2020 2020  E" + dim1.      
+000074f0: 2020 655f 3220 3d20 2245 2220 2b20 6469    e_2 = "E" + di
+00007500: 6d32 0a20 2020 2020 2020 2068 5f31 203d  m2.        h_1 =
+00007510: 2022 4822 202b 2064 696d 310a 2020 2020   "H" + dim1.    
+00007520: 2020 2020 685f 3220 3d20 2248 2220 2b20      h_2 = "H" + 
+00007530: 6469 6d32 0a0a 2020 2020 2020 2020 2320  dim2..        # 
+00007540: 5072 6570 6172 6520 6172 7261 7920 7769  Prepare array wi
+00007550: 7468 2070 726f 7065 7220 6469 6d65 6e73  th proper dimens
+00007560: 696f 6e73 2066 6f72 2074 6865 2064 6f74  ions for the dot
+00007570: 2070 726f 6475 6374 2064 6174 610a 2020   product data.  
+00007580: 2020 2020 2020 6172 7261 7973 203d 2028        arrays = (
+00007590: 6669 656c 6473 5f73 656c 665b 655f 315d  fields_self[e_1]
+000075a0: 2c20 6669 656c 6473 5f6f 7468 6572 5b65  , fields_other[e
+000075b0: 5f31 5d29 0a20 2020 2020 2020 2063 6f6f  _1]).        coo
+000075c0: 7264 7320 3d20 2861 7272 6179 735b 305d  rds = (arrays[0]
+000075d0: 2e63 6f6f 7264 732c 2061 7272 6179 735b  .coords, arrays[
+000075e0: 315d 2e63 6f6f 7264 7329 0a0a 2020 2020  1].coords)..    
+000075f0: 2020 2020 2320 436f 6d6d 6f6e 2066 7265      # Common fre
+00007600: 7175 656e 6369 6573 2074 6f20 626f 7468  quencies to both
+00007610: 2064 6174 6120 6172 7261 7973 0a20 2020   data arrays.   
+00007620: 2020 2020 2066 203d 206e 702e 6172 7261       f = np.arra
+00007630: 7928 736f 7274 6564 2873 6574 2863 6f6f  y(sorted(set(coo
+00007640: 7264 735b 305d 5b22 6622 5d2e 7661 6c75  rds[0]["f"].valu
+00007650: 6573 292e 696e 7465 7273 6563 7469 6f6e  es).intersection
+00007660: 2863 6f6f 7264 735b 315d 5b22 6622 5d2e  (coords[1]["f"].
+00007670: 7661 6c75 6573 2929 290a 2020 2020 2020  values))).      
+00007680: 2020 6973 656c 3120 3d20 5b6c 6973 7428    isel1 = [list(
+00007690: 636f 6f72 6473 5b30 5d5b 2266 225d 2e76  coords[0]["f"].v
+000076a0: 616c 7565 7329 2e69 6e64 6578 2866 7265  alues).index(fre
+000076b0: 7129 2066 6f72 2066 7265 7120 696e 2066  q) for freq in f
+000076c0: 5d0a 2020 2020 2020 2020 6973 656c 3220  ].        isel2 
+000076d0: 3d20 5b6c 6973 7428 636f 6f72 6473 5b31  = [list(coords[1
+000076e0: 5d5b 2266 225d 2e76 616c 7565 7329 2e69  ]["f"].values).i
+000076f0: 6e64 6578 2866 7265 7129 2066 6f72 2066  ndex(freq) for f
+00007700: 7265 7120 696e 2066 5d0a 0a20 2020 2020  req in f]..     
+00007710: 2020 2023 204d 6f64 6520 696e 6469 6365     # Mode indice
+00007720: 732c 2069 6620 6176 6169 6c61 626c 650a  s, if available.
+00007730: 2020 2020 2020 2020 6d6f 6465 735f 696e          modes_in
+00007740: 5f73 656c 6620 3d20 226d 6f64 655f 696e  _self = "mode_in
+00007750: 6465 7822 2069 6e20 636f 6f72 6473 5b30  dex" in coords[0
+00007760: 5d0a 2020 2020 2020 2020 6d6f 6465 735f  ].        modes_
+00007770: 696e 5f6f 7468 6572 203d 2022 6d6f 6465  in_other = "mode
+00007780: 5f69 6e64 6578 2220 696e 2063 6f6f 7264  _index" in coord
+00007790: 735b 315d 0a0a 2020 2020 2020 2020 6b65  s[1]..        ke
+000077a0: 7973 203d 2028 655f 312c 2065 5f32 2c20  ys = (e_1, e_2, 
+000077b0: 685f 312c 2068 5f32 290a 2020 2020 2020  h_1, h_2).      
+000077c0: 2020 666f 7220 6b65 7920 696e 206b 6579    for key in key
+000077d0: 733a 0a20 2020 2020 2020 2020 2020 2066  s:.            f
+000077e0: 6965 6c64 735f 7365 6c66 5b6b 6579 5d20  ields_self[key] 
+000077f0: 3d20 6669 656c 6473 5f73 656c 665b 6b65  = fields_self[ke
+00007800: 795d 2e69 7365 6c28 663d 6973 656c 3129  y].isel(f=isel1)
+00007810: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00007820: 6d6f 6465 735f 696e 5f73 656c 663a 0a20  modes_in_self:. 
+00007830: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00007840: 6965 6c64 735f 7365 6c66 5b6b 6579 5d20  ields_self[key] 
+00007850: 3d20 6669 656c 6473 5f73 656c 665b 6b65  = fields_self[ke
+00007860: 795d 2e72 656e 616d 6528 6d6f 6465 5f69  y].rename(mode_i
+00007870: 6e64 6578 3d22 6d6f 6465 5f69 6e64 6578  ndex="mode_index
+00007880: 5f30 2229 0a20 2020 2020 2020 2020 2020  _0").           
+00007890: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+000078a0: 2020 2020 2020 2066 6965 6c64 735f 7365         fields_se
+000078b0: 6c66 5b6b 6579 5d20 3d20 6669 656c 6473  lf[key] = fields
+000078c0: 5f73 656c 665b 6b65 795d 2e65 7870 616e  _self[key].expan
+000078d0: 645f 6469 6d73 280a 2020 2020 2020 2020  d_dims(.        
+000078e0: 2020 2020 2020 2020 2020 2020 6469 6d3d              dim=
+000078f0: 7b22 6d6f 6465 5f69 6e64 6578 5f30 223a  {"mode_index_0":
+00007900: 205b 305d 7d2c 2061 7869 733d 6c65 6e28   [0]}, axis=len(
+00007910: 6669 656c 6473 5f73 656c 665b 6b65 795d  fields_self[key]
+00007920: 2e73 6861 7065 290a 2020 2020 2020 2020  .shape).        
+00007930: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+00007940: 2020 2020 2020 6669 656c 6473 5f6f 7468        fields_oth
+00007950: 6572 5b6b 6579 5d20 3d20 6669 656c 6473  er[key] = fields
+00007960: 5f6f 7468 6572 5b6b 6579 5d2e 6973 656c  _other[key].isel
+00007970: 2866 3d69 7365 6c32 290a 2020 2020 2020  (f=isel2).      
+00007980: 2020 2020 2020 6966 206d 6f64 6573 5f69        if modes_i
+00007990: 6e5f 6f74 6865 723a 0a20 2020 2020 2020  n_other:.       
+000079a0: 2020 2020 2020 2020 2066 6965 6c64 735f           fields_
+000079b0: 6f74 6865 725b 6b65 795d 203d 2066 6965  other[key] = fie
+000079c0: 6c64 735f 6f74 6865 725b 6b65 795d 2e72  lds_other[key].r
+000079d0: 656e 616d 6528 6d6f 6465 5f69 6e64 6578  ename(mode_index
+000079e0: 3d22 6d6f 6465 5f69 6e64 6578 5f31 2229  ="mode_index_1")
+000079f0: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
+00007a00: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00007a10: 2020 2066 6965 6c64 735f 6f74 6865 725b     fields_other[
+00007a20: 6b65 795d 203d 2066 6965 6c64 735f 6f74  key] = fields_ot
+00007a30: 6865 725b 6b65 795d 2e65 7870 616e 645f  her[key].expand_
+00007a40: 6469 6d73 280a 2020 2020 2020 2020 2020  dims(.          
+00007a50: 2020 2020 2020 2020 2020 6469 6d3d 7b22            dim={"
+00007a60: 6d6f 6465 5f69 6e64 6578 5f31 223a 205b  mode_index_1": [
+00007a70: 305d 7d2c 2061 7869 733d 6c65 6e28 6669  0]}, axis=len(fi
+00007a80: 656c 6473 5f6f 7468 6572 5b6b 6579 5d2e  elds_other[key].
+00007a90: 7368 6170 6529 0a20 2020 2020 2020 2020  shape).         
+00007aa0: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
+00007ab0: 2020 645f 6172 6561 203d 2073 656c 662e    d_area = self.
+00007ac0: 5f64 6966 665f 6172 6561 2e65 7870 616e  _diff_area.expan
+00007ad0: 645f 6469 6d73 2864 696d 3d7b 2266 223a  d_dims(dim={"f":
+00007ae0: 2066 7d2c 2061 7869 733d 3229 2e74 6f5f   f}, axis=2).to_
+00007af0: 6e75 6d70 7928 290a 0a20 2020 2020 2020  numpy()..       
+00007b00: 2023 2066 756e 6374 696f 6e20 746f 2061   # function to a
+00007b10: 7070 6c79 2061 7420 6561 6368 2070 6169  pply at each pai
+00007b20: 7220 6f66 206d 6f64 6520 696e 6469 6365  r of mode indice
+00007b30: 7320 6265 666f 7265 2069 6e74 6567 7261  s before integra
+00007b40: 7469 6e67 0a20 2020 2020 2020 2064 6566  ting.        def
+00007b50: 2066 6e28 6669 656c 6473 5f31 2c20 6669   fn(fields_1, fi
+00007b60: 656c 6473 5f32 293a 0a20 2020 2020 2020  elds_2):.       
+00007b70: 2020 2020 2065 5f73 656c 665f 3120 3d20       e_self_1 = 
+00007b80: 6669 656c 6473 5f31 5b65 5f31 5d0a 2020  fields_1[e_1].  
+00007b90: 2020 2020 2020 2020 2020 655f 7365 6c66            e_self
+00007ba0: 5f32 203d 2066 6965 6c64 735f 315b 655f  _2 = fields_1[e_
+00007bb0: 325d 0a20 2020 2020 2020 2020 2020 2068  2].            h
+00007bc0: 5f73 656c 665f 3120 3d20 6669 656c 6473  _self_1 = fields
+00007bd0: 5f31 5b68 5f31 5d0a 2020 2020 2020 2020  _1[h_1].        
+00007be0: 2020 2020 685f 7365 6c66 5f32 203d 2066      h_self_2 = f
+00007bf0: 6965 6c64 735f 315b 685f 325d 0a20 2020  ields_1[h_2].   
+00007c00: 2020 2020 2020 2020 2065 5f6f 7468 6572           e_other
+00007c10: 5f31 203d 2066 6965 6c64 735f 325b 655f  _1 = fields_2[e_
+00007c20: 315d 0a20 2020 2020 2020 2020 2020 2065  1].            e
+00007c30: 5f6f 7468 6572 5f32 203d 2066 6965 6c64  _other_2 = field
+00007c40: 735f 325b 655f 325d 0a20 2020 2020 2020  s_2[e_2].       
+00007c50: 2020 2020 2068 5f6f 7468 6572 5f31 203d       h_other_1 =
+00007c60: 2066 6965 6c64 735f 325b 685f 315d 0a20   fields_2[h_1]. 
+00007c70: 2020 2020 2020 2020 2020 2068 5f6f 7468             h_oth
+00007c80: 6572 5f32 203d 2066 6965 6c64 735f 325b  er_2 = fields_2[
+00007c90: 685f 325d 0a0a 2020 2020 2020 2020 2020  h_2]..          
+00007ca0: 2020 2320 4372 6f73 7320 7072 6f64 7563    # Cross produc
+00007cb0: 7473 206f 6620 6669 656c 6473 0a20 2020  ts of fields.   
+00007cc0: 2020 2020 2020 2020 2065 5f73 656c 665f           e_self_
+00007cd0: 785f 685f 6f74 6865 7220 3d20 655f 7365  x_h_other = e_se
+00007ce0: 6c66 5f31 202a 2068 5f6f 7468 6572 5f32  lf_1 * h_other_2
+00007cf0: 202d 2065 5f73 656c 665f 3220 2a20 685f   - e_self_2 * h_
+00007d00: 6f74 6865 725f 310a 2020 2020 2020 2020  other_1.        
+00007d10: 2020 2020 685f 7365 6c66 5f78 5f65 5f6f      h_self_x_e_o
+00007d20: 7468 6572 203d 2068 5f73 656c 665f 3120  ther = h_self_1 
+00007d30: 2a20 655f 6f74 6865 725f 3220 2d20 685f  * e_other_2 - h_
+00007d40: 7365 6c66 5f32 202a 2065 5f6f 7468 6572  self_2 * e_other
+00007d50: 5f31 0a0a 2020 2020 2020 2020 2020 2020  _1..            
+00007d60: 7375 6d6d 616e 6420 3d20 302e 3235 202a  summand = 0.25 *
+00007d70: 2028 655f 7365 6c66 5f78 5f68 5f6f 7468   (e_self_x_h_oth
+00007d80: 6572 202d 2068 5f73 656c 665f 785f 655f  er - h_self_x_e_
+00007d90: 6f74 6865 7229 202a 2064 5f61 7265 610a  other) * d_area.
+00007da0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00007db0: 726e 2073 756d 6d61 6e64 0a0a 2020 2020  rn summand..    
+00007dc0: 2020 2020 7265 7375 6c74 203d 2073 656c      result = sel
+00007dd0: 662e 5f6f 7574 6572 5f66 6e5f 7375 6d6d  f._outer_fn_summ
+00007de0: 6174 696f 6e28 0a20 2020 2020 2020 2020  ation(.         
+00007df0: 2020 2066 6965 6c64 735f 313d 6669 656c     fields_1=fiel
+00007e00: 6473 5f73 656c 662c 0a20 2020 2020 2020  ds_self,.       
+00007e10: 2020 2020 2066 6965 6c64 735f 323d 6669       fields_2=fi
+00007e20: 656c 6473 5f6f 7468 6572 2c0a 2020 2020  elds_other,.    
+00007e30: 2020 2020 2020 2020 6f75 7465 725f 6469          outer_di
+00007e40: 6d5f 313d 226d 6f64 655f 696e 6465 785f  m_1="mode_index_
+00007e50: 3022 2c0a 2020 2020 2020 2020 2020 2020  0",.            
+00007e60: 6f75 7465 725f 6469 6d5f 323d 226d 6f64  outer_dim_2="mod
+00007e70: 655f 696e 6465 785f 3122 2c0a 2020 2020  e_index_1",.    
+00007e80: 2020 2020 2020 2020 7375 6d5f 6469 6d73          sum_dims
+00007e90: 3d74 616e 5f64 696d 732c 0a20 2020 2020  =tan_dims,.     
+00007ea0: 2020 2020 2020 2066 6e3d 666e 2c0a 2020         fn=fn,.  
+00007eb0: 2020 2020 2020 290a 0a20 2020 2020 2020        )..       
+00007ec0: 2023 2052 656d 6f76 6520 6d6f 6465 2069   # Remove mode i
+00007ed0: 6e64 6578 2063 6f6f 7264 696e 6174 6520  ndex coordinate 
+00007ee0: 6966 2074 6865 2069 6e70 7574 2064 6964  if the input did
+00007ef0: 206e 6f74 2068 6176 6520 6974 0a20 2020   not have it.   
+00007f00: 2020 2020 2069 6620 6e6f 7420 6d6f 6465       if not mode
+00007f10: 735f 696e 5f73 656c 663a 0a20 2020 2020  s_in_self:.     
+00007f20: 2020 2020 2020 2072 6573 756c 7420 3d20         result = 
+00007f30: 7265 7375 6c74 2e69 7365 6c28 6d6f 6465  result.isel(mode
+00007f40: 5f69 6e64 6578 5f30 3d30 2c20 6472 6f70  _index_0=0, drop
+00007f50: 3d54 7275 6529 0a20 2020 2020 2020 2069  =True).        i
+00007f60: 6620 6e6f 7420 6d6f 6465 735f 696e 5f6f  f not modes_in_o
+00007f70: 7468 6572 3a0a 2020 2020 2020 2020 2020  ther:.          
+00007f80: 2020 7265 7375 6c74 203d 2072 6573 756c    result = resul
+00007f90: 742e 6973 656c 286d 6f64 655f 696e 6465  t.isel(mode_inde
+00007fa0: 785f 313d 302c 2064 726f 703d 5472 7565  x_1=0, drop=True
+00007fb0: 290a 0a20 2020 2020 2020 2072 6574 7572  )..        retur
+00007fc0: 6e20 7265 7375 6c74 0a0a 2020 2020 4073  n result..    @s
+00007fd0: 7461 7469 636d 6574 686f 640a 2020 2020  taticmethod.    
+00007fe0: 6465 6620 5f6f 7574 6572 5f66 6e5f 7375  def _outer_fn_su
+00007ff0: 6d6d 6174 696f 6e28 0a20 2020 2020 2020  mmation(.       
+00008000: 2066 6965 6c64 735f 313a 2044 6963 745b   fields_1: Dict[
+00008010: 7374 722c 2078 722e 4461 7461 4172 7261  str, xr.DataArra
+00008020: 795d 2c0a 2020 2020 2020 2020 6669 656c  y],.        fiel
+00008030: 6473 5f32 3a20 4469 6374 5b73 7472 2c20  ds_2: Dict[str, 
+00008040: 7872 2e44 6174 6141 7272 6179 5d2c 0a20  xr.DataArray],. 
+00008050: 2020 2020 2020 206f 7574 6572 5f64 696d         outer_dim
+00008060: 5f31 3a20 7374 722c 0a20 2020 2020 2020  _1: str,.       
+00008070: 206f 7574 6572 5f64 696d 5f32 3a20 7374   outer_dim_2: st
+00008080: 722c 0a20 2020 2020 2020 2073 756d 5f64  r,.        sum_d
+00008090: 696d 733a 204c 6973 745b 7374 725d 2c0a  ims: List[str],.
+000080a0: 2020 2020 2020 2020 666e 3a20 4361 6c6c          fn: Call
+000080b0: 6162 6c65 2c0a 2020 2020 2920 2d3e 2078  able,.    ) -> x
+000080c0: 722e 4461 7461 4172 7261 793a 0a20 2020  r.DataArray:.   
+000080d0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+000080e0: 204c 6f6f 7020 6f76 6572 2060 606f 7574   Loop over ``out
+000080f0: 6572 5f64 696d 5f31 6060 2061 6e64 2060  er_dim_1`` and `
+00008100: 606f 7574 6572 5f64 696d 5f32 6060 2c20  `outer_dim_2``, 
+00008110: 6170 706c 7920 6060 666e 6060 2074 6f20  apply ``fn`` to 
+00008120: 6060 6669 656c 6473 5f31 6060 2061 6e64  ``fields_1`` and
+00008130: 2060 6066 6965 6c64 735f 3260 602c 2061   ``fields_2``, a
+00008140: 6e64 2073 756d 206f 7665 7220 6060 7375  nd sum over ``su
+00008150: 6d5f 6469 6d73 6060 2e0a 2020 2020 2020  m_dims``..      
+00008160: 2020 5468 6520 7265 7375 6c74 696e 6720    The resulting 
+00008170: 6060 7872 2e44 6174 6141 7272 6179 6060  ``xr.DataArray``
+00008180: 2068 6173 2068 6173 2064 696d 656e 7369   has has dimensi
+00008190: 6f6e 7320 616e 7920 6469 6d65 6e73 696f  ons any dimensio
+000081a0: 6e73 2069 6e20 7468 6520 6669 656c 6473  ns in the fields
+000081b0: 2077 6869 6368 2061 7265 206e 6f74 2063   which are not c
+000081c0: 6f6e 7461 696e 6564 2069 6e20 7375 6d5f  ontained in sum_
+000081d0: 6469 6d73 2e0a 2020 2020 2020 2020 5468  dims..        Th
+000081e0: 6973 2063 616e 2062 6520 6d6f 7265 206d  is can be more m
+000081f0: 656d 6f72 7920 6566 6669 6369 656e 7420  emory efficient 
+00008200: 7468 616e 2076 6563 746f 7269 7a69 6e67  than vectorizing
+00008210: 206f 7665 7220 7468 6520 6060 6f75 7465   over the ``oute
+00008220: 725f 6469 6d73 6060 2c20 7768 6963 6820  r_dims``, which 
+00008230: 6361 6e20 696e 766f 6c76 6520 6272 6f61  can involve broa
+00008240: 6463 6173 7469 6e67 2061 6e64 2072 6573  dcasting and res
+00008250: 6861 7069 6e67 2064 6174 612e 0a20 2020  haping data..   
+00008260: 2020 2020 2049 7420 616c 736f 2063 6f6e       It also con
+00008270: 7665 7274 7320 746f 206e 756d 7079 2061  verts to numpy a
+00008280: 7272 6179 7320 6f75 7473 6964 6520 7468  rrays outside th
+00008290: 6520 6c6f 6f70 7320 746f 206d 696e 696d  e loops to minim
+000082a0: 697a 6520 7861 7272 6179 206f 7665 7268  ize xarray overh
+000082b0: 6561 642e 0a20 2020 2020 2020 2022 2222  ead..        """
+000082c0: 0a20 2020 2020 2020 2023 2066 6972 7374  .        # first
+000082d0: 2c20 636f 6e76 6572 7420 746f 206e 756d  , convert to num
+000082e0: 7079 206f 7574 7369 6465 2074 6865 206c  py outside the l
+000082f0: 6f6f 7020 746f 2072 6564 7563 6520 7861  oop to reduce xa
+00008300: 7272 6179 206f 7665 7268 6561 640a 2020  rray overhead.  
+00008310: 2020 2020 2020 6669 656c 6473 5f31 5f6e        fields_1_n
+00008320: 756d 7079 203d 207b 6b65 793a 2076 616c  umpy = {key: val
+00008330: 2e74 6f5f 6e75 6d70 7928 2920 666f 7220  .to_numpy() for 
+00008340: 6b65 792c 2076 616c 2069 6e20 6669 656c  key, val in fiel
+00008350: 6473 5f31 2e69 7465 6d73 2829 7d0a 2020  ds_1.items()}.  
+00008360: 2020 2020 2020 6669 656c 6473 5f32 5f6e        fields_2_n
+00008370: 756d 7079 203d 207b 6b65 793a 2076 616c  umpy = {key: val
+00008380: 2e74 6f5f 6e75 6d70 7928 2920 666f 7220  .to_numpy() for 
+00008390: 6b65 792c 2076 616c 2069 6e20 6669 656c  key, val in fiel
+000083a0: 6473 5f32 2e69 7465 6d73 2829 7d0a 0a20  ds_2.items()}.. 
+000083b0: 2020 2020 2020 2023 2067 6574 206f 6e65         # get one
+000083c0: 206f 6620 7468 6520 6461 7461 2061 7272   of the data arr
+000083d0: 6179 7320 746f 206c 6f6f 6b20 6174 2066  ays to look at f
+000083e0: 6f72 2069 6e64 6578 696e 670a 2020 2020  or indexing.    
+000083f0: 2020 2020 2320 6173 7375 6d69 6e67 2061      # assuming a
+00008400: 6c6c 2064 6174 6120 6172 7261 7973 2068  ll data arrays h
+00008410: 6176 6520 7468 6520 7361 6d65 2073 7472  ave the same str
+00008420: 7563 7475 7265 0a20 2020 2020 2020 2064  ucture.        d
+00008430: 6174 615f 6172 7261 795f 7465 6d70 5f31  ata_array_temp_1
+00008440: 203d 206c 6973 7428 6669 656c 6473 5f31   = list(fields_1
+00008450: 2e76 616c 7565 7328 2929 5b30 5d0a 2020  .values())[0].  
+00008460: 2020 2020 2020 6461 7461 5f61 7272 6179        data_array
+00008470: 5f74 656d 705f 3220 3d20 6c69 7374 2866  _temp_2 = list(f
+00008480: 6965 6c64 735f 322e 7661 6c75 6573 2829  ields_2.values()
+00008490: 295b 305d 0a20 2020 2020 2020 206e 756d  )[0].        num
+000084a0: 7079 5f74 656d 705f 3120 3d20 6461 7461  py_temp_1 = data
+000084b0: 5f61 7272 6179 5f74 656d 705f 312e 746f  _array_temp_1.to
+000084c0: 5f6e 756d 7079 2829 0a20 2020 2020 2020  _numpy().       
+000084d0: 206e 756d 7079 5f74 656d 705f 3220 3d20   numpy_temp_2 = 
+000084e0: 6461 7461 5f61 7272 6179 5f74 656d 705f  data_array_temp_
+000084f0: 322e 746f 5f6e 756d 7079 2829 0a0a 2020  2.to_numpy()..  
+00008500: 2020 2020 2020 2320 6669 6e64 2074 6865        # find the
+00008510: 206e 756d 7079 2061 7865 7320 6173 736f   numpy axes asso
+00008520: 6369 6174 6564 2077 6974 6820 7468 6520  ciated with the 
+00008530: 7072 6f76 6964 6564 2064 696d 656e 7369  provided dimensi
+00008540: 6f6e 730a 2020 2020 2020 2020 6f75 7465  ons.        oute
+00008550: 725f 6178 6973 5f31 203d 2064 6174 615f  r_axis_1 = data_
+00008560: 6172 7261 795f 7465 6d70 5f31 2e67 6574  array_temp_1.get
+00008570: 5f61 7869 735f 6e75 6d28 6f75 7465 725f  _axis_num(outer_
+00008580: 6469 6d5f 3129 0a20 2020 2020 2020 206f  dim_1).        o
+00008590: 7574 6572 5f61 7869 735f 3220 3d20 6461  uter_axis_2 = da
+000085a0: 7461 5f61 7272 6179 5f74 656d 705f 322e  ta_array_temp_2.
+000085b0: 6765 745f 6178 6973 5f6e 756d 286f 7574  get_axis_num(out
+000085c0: 6572 5f64 696d 5f32 290a 2020 2020 2020  er_dim_2).      
+000085d0: 2020 7375 6d5f 6178 6573 203d 205b 6461    sum_axes = [da
+000085e0: 7461 5f61 7272 6179 5f74 656d 705f 312e  ta_array_temp_1.
+000085f0: 6765 745f 6178 6973 5f6e 756d 2864 696d  get_axis_num(dim
+00008600: 2920 666f 7220 6469 6d20 696e 2073 756d  ) for dim in sum
+00008610: 5f64 696d 735d 0a0a 2020 2020 2020 2020  _dims]..        
+00008620: 2320 636f 6f72 6473 2061 6e64 2061 7272  # coords and arr
+00008630: 6179 2066 6f72 2072 6573 756c 7420 6f66  ay for result of
+00008640: 2063 616c 6375 6c61 7469 6f6e 0a20 2020   calculation.   
+00008650: 2020 2020 2063 6f6f 7264 7320 3d20 7b6b       coords = {k
+00008660: 6579 3a20 7661 6c2e 746f 5f6e 756d 7079  ey: val.to_numpy
+00008670: 2829 2066 6f72 206b 6579 2c20 7661 6c20  () for key, val 
+00008680: 696e 2064 6174 615f 6172 7261 795f 7465  in data_array_te
+00008690: 6d70 5f31 2e63 6f6f 7264 732e 6974 656d  mp_1.coords.item
+000086a0: 7328 297d 0a20 2020 2020 2020 2066 6f72  s()}.        for
+000086b0: 2064 696d 2069 6e20 7375 6d5f 6469 6d73   dim in sum_dims
+000086c0: 3a0a 2020 2020 2020 2020 2020 2020 636f  :.            co
+000086d0: 6f72 6473 2e70 6f70 2864 696d 290a 2020  ords.pop(dim).  
+000086e0: 2020 2020 2020 2320 6c61 7374 2074 776f        # last two
+000086f0: 2069 6e64 7320 6172 6520 7468 6520 6f75   inds are the ou
+00008700: 7465 725f 6469 6d73 0a20 2020 2020 2020  ter_dims.       
+00008710: 2063 6f6f 7264 732e 706f 7028 6f75 7465   coords.pop(oute
+00008720: 725f 6469 6d5f 3129 0a20 2020 2020 2020  r_dim_1).       
+00008730: 2063 6f6f 7264 735b 6f75 7465 725f 6469   coords[outer_di
+00008740: 6d5f 315d 203d 2064 6174 615f 6172 7261  m_1] = data_arra
+00008750: 795f 7465 6d70 5f31 2e63 6f6f 7264 735b  y_temp_1.coords[
+00008760: 6f75 7465 725f 6469 6d5f 315d 2e74 6f5f  outer_dim_1].to_
+00008770: 6e75 6d70 7928 290a 2020 2020 2020 2020  numpy().        
+00008780: 636f 6f72 6473 5b6f 7574 6572 5f64 696d  coords[outer_dim
+00008790: 5f32 5d20 3d20 6461 7461 5f61 7272 6179  _2] = data_array
+000087a0: 5f74 656d 705f 322e 636f 6f72 6473 5b6f  _temp_2.coords[o
+000087b0: 7574 6572 5f64 696d 5f32 5d2e 746f 5f6e  uter_dim_2].to_n
+000087c0: 756d 7079 2829 0a20 2020 2020 2020 2023  umpy().        #
+000087d0: 2064 726f 7020 7363 616c 6172 206e 6f6e   drop scalar non
+000087e0: 2d69 6e64 6578 696e 6720 6469 6d65 6e73  -indexing dimens
+000087f0: 696f 6e73 0a20 2020 2020 2020 2063 6f6f  ions.        coo
+00008800: 7264 7320 3d20 7b6b 6579 3a20 7661 6c20  rds = {key: val 
+00008810: 666f 7220 6b65 792c 2076 616c 2069 6e20  for key, val in 
+00008820: 636f 6f72 6473 2e69 7465 6d73 2829 2069  coords.items() i
+00008830: 6620 6c65 6e28 7661 6c2e 7368 6170 6529  f len(val.shape)
+00008840: 2021 3d20 307d 0a20 2020 2020 2020 2073   != 0}.        s
+00008850: 6861 7065 203d 205b 6c65 6e28 7661 6c29  hape = [len(val)
+00008860: 2066 6f72 2076 616c 2069 6e20 636f 6f72   for val in coor
+00008870: 6473 2e76 616c 7565 7328 295d 0a20 2020  ds.values()].   
+00008880: 2020 2020 2064 7479 7065 203d 206e 702e       dtype = np.
+00008890: 7072 6f6d 6f74 655f 7479 7065 7328 6e75  promote_types(nu
+000088a0: 6d70 795f 7465 6d70 5f31 2e64 7479 7065  mpy_temp_1.dtype
+000088b0: 2c20 6e75 6d70 795f 7465 6d70 5f32 2e64  , numpy_temp_2.d
+000088c0: 7479 7065 290a 2020 2020 2020 2020 6461  type).        da
+000088d0: 7461 203d 206e 702e 7a65 726f 7328 7368  ta = np.zeros(sh
+000088e0: 6170 652c 2064 7479 7065 3d64 7479 7065  ape, dtype=dtype
+000088f0: 290a 0a20 2020 2020 2020 2023 2069 6e64  )..        # ind
+00008900: 6578 696e 6720 7475 706c 6573 0a20 2020  exing tuples.   
+00008910: 2020 2020 2069 6478 5f31 203d 205b 736c       idx_1 = [sl
+00008920: 6963 6528 4e6f 6e65 295d 202a 206e 756d  ice(None)] * num
+00008930: 7079 5f74 656d 705f 312e 6e64 696d 0a20  py_temp_1.ndim. 
+00008940: 2020 2020 2020 2069 6478 5f32 203d 205b         idx_2 = [
+00008950: 736c 6963 6528 4e6f 6e65 295d 202a 206e  slice(None)] * n
+00008960: 756d 7079 5f74 656d 705f 322e 6e64 696d  umpy_temp_2.ndim
+00008970: 0a20 2020 2020 2020 2069 6478 5f64 6174  .        idx_dat
+00008980: 6120 3d20 5b73 6c69 6365 284e 6f6e 6529  a = [slice(None)
+00008990: 5d20 2a20 6461 7461 2e6e 6469 6d0a 0a20  ] * data.ndim.. 
+000089a0: 2020 2020 2020 2023 2063 616c 6375 6c61         # calcula
+000089b0: 7465 2074 6865 2073 756d 7320 6f66 2070  te the sums of p
+000089c0: 726f 6475 6374 730a 2020 2020 2020 2020  roducts.        
+000089d0: 666f 7220 6f75 7465 725f 3120 696e 2072  for outer_1 in r
+000089e0: 616e 6765 286e 756d 7079 5f74 656d 705f  ange(numpy_temp_
+000089f0: 312e 7368 6170 655b 6f75 7465 725f 6178  1.shape[outer_ax
+00008a00: 6973 5f31 5d29 3a0a 2020 2020 2020 2020  is_1]):.        
+00008a10: 2020 2020 666f 7220 6f75 7465 725f 3220      for outer_2 
+00008a20: 696e 2072 616e 6765 286e 756d 7079 5f74  in range(numpy_t
+00008a30: 656d 705f 322e 7368 6170 655b 6f75 7465  emp_2.shape[oute
+00008a40: 725f 6178 6973 5f32 5d29 3a0a 2020 2020  r_axis_2]):.    
+00008a50: 2020 2020 2020 2020 2020 2020 6964 785f              idx_
+00008a60: 315b 6f75 7465 725f 6178 6973 5f31 5d20  1[outer_axis_1] 
+00008a70: 3d20 6f75 7465 725f 310a 2020 2020 2020  = outer_1.      
+00008a80: 2020 2020 2020 2020 2020 6964 785f 325b            idx_2[
+00008a90: 6f75 7465 725f 6178 6973 5f32 5d20 3d20  outer_axis_2] = 
+00008aa0: 6f75 7465 725f 320a 2020 2020 2020 2020  outer_2.        
+00008ab0: 2020 2020 2020 2020 6964 785f 6461 7461          idx_data
+00008ac0: 5b2d 325d 203d 206f 7574 6572 5f31 0a20  [-2] = outer_1. 
+00008ad0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00008ae0: 6478 5f64 6174 615b 2d31 5d20 3d20 6f75  dx_data[-1] = ou
+00008af0: 7465 725f 320a 2020 2020 2020 2020 2020  ter_2.          
+00008b00: 2020 2020 2020 6669 656c 6473 5f31 5f63        fields_1_c
+00008b10: 7572 7220 3d20 7b6b 6579 3a20 7661 6c5b  urr = {key: val[
+00008b20: 7475 706c 6528 6964 785f 3129 5d20 666f  tuple(idx_1)] fo
+00008b30: 7220 6b65 792c 2076 616c 2069 6e20 6669  r key, val in fi
+00008b40: 656c 6473 5f31 5f6e 756d 7079 2e69 7465  elds_1_numpy.ite
+00008b50: 6d73 2829 7d0a 2020 2020 2020 2020 2020  ms()}.          
+00008b60: 2020 2020 2020 6669 656c 6473 5f32 5f63        fields_2_c
+00008b70: 7572 7220 3d20 7b6b 6579 3a20 7661 6c5b  urr = {key: val[
+00008b80: 7475 706c 6528 6964 785f 3229 5d20 666f  tuple(idx_2)] fo
+00008b90: 7220 6b65 792c 2076 616c 2069 6e20 6669  r key, val in fi
+00008ba0: 656c 6473 5f32 5f6e 756d 7079 2e69 7465  elds_2_numpy.ite
+00008bb0: 6d73 2829 7d0a 2020 2020 2020 2020 2020  ms()}.          
+00008bc0: 2020 2020 2020 7375 6d6d 616e 645f 6375        summand_cu
+00008bd0: 7272 203d 2066 6e28 6669 656c 6473 5f31  rr = fn(fields_1
+00008be0: 5f63 7572 722c 2066 6965 6c64 735f 325f  _curr, fields_2_
+00008bf0: 6375 7272 290a 2020 2020 2020 2020 2020  curr).          
+00008c00: 2020 2020 2020 6461 7461 5f63 7572 7220        data_curr 
+00008c10: 3d20 6e70 2e73 756d 2873 756d 6d61 6e64  = np.sum(summand
+00008c20: 5f63 7572 722c 2061 7869 733d 7475 706c  _curr, axis=tupl
+00008c30: 6528 7375 6d5f 6178 6573 2929 0a20 2020  e(sum_axes)).   
+00008c40: 2020 2020 2020 2020 2020 2020 2064 6174               dat
+00008c50: 615b 7475 706c 6528 6964 785f 6461 7461  a[tuple(idx_data
+00008c60: 295d 203d 2064 6174 615f 6375 7272 0a0a  )] = data_curr..
+00008c70: 2020 2020 2020 2020 7265 7475 726e 2078          return x
+00008c80: 722e 4461 7461 4172 7261 7928 6461 7461  r.DataArray(data
+00008c90: 2c20 636f 6f72 6473 3d63 6f6f 7264 7329  , coords=coords)
+00008ca0: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
+00008cb0: 2020 2020 6465 6620 7469 6d65 5f72 6576      def time_rev
+00008cc0: 6572 7365 645f 636f 7079 2873 656c 6629  ersed_copy(self)
+00008cd0: 202d 3e20 4669 656c 6444 6174 613a 0a20   -> FieldData:. 
+00008ce0: 2020 2020 2020 2022 2222 4d61 6b65 2061         """Make a
+00008cf0: 2063 6f70 7920 6f66 2074 6865 2064 6174   copy of the dat
+00008d00: 6120 7769 7468 2074 696d 652d 7265 7665  a with time-reve
+00008d10: 7273 6564 2066 6965 6c64 732e 2222 220a  rsed fields.""".
+00008d20: 0a20 2020 2020 2020 2023 2054 696d 6520  .        # Time 
+00008d30: 7265 7665 7273 616c 2066 6f72 2066 7265  reversal for fre
+00008d40: 7175 656e 6379 2d64 6f6d 6169 6e20 6669  quency-domain fi
+00008d50: 656c 6473 3b20 6f76 6572 7772 6974 7465  elds; overwritte
+00008d60: 6e20 696e 203a 636c 6173 733a 6046 6965  n in :class:`Fie
+00008d70: 6c64 5469 6d65 4461 7461 602c 0a20 2020  ldTimeData`,.   
+00008d80: 2020 2020 2023 203a 636c 6173 733a 604d       # :class:`M
+00008d90: 6f64 6544 6174 6160 2c20 616e 6420 3a63  odeData`, and :c
+00008da0: 6c61 7373 3a60 4d6f 6465 536f 6c76 6572  lass:`ModeSolver
+00008db0: 4461 7461 602e 0a20 2020 2020 2020 206e  Data`..        n
+00008dc0: 6577 5f64 6174 6120 3d20 7b7d 0a20 2020  ew_data = {}.   
+00008dd0: 2020 2020 2066 6f72 2063 6f6d 702c 2066       for comp, f
+00008de0: 6965 6c64 2069 6e20 7365 6c66 2e66 6965  ield in self.fie
+00008df0: 6c64 5f63 6f6d 706f 6e65 6e74 732e 6974  ld_components.it
+00008e00: 656d 7328 293a 0a20 2020 2020 2020 2020  ems():.         
+00008e10: 2020 2069 6620 636f 6d70 5b30 5d20 3d3d     if comp[0] ==
+00008e20: 2022 4822 3a0a 2020 2020 2020 2020 2020   "H":.          
+00008e30: 2020 2020 2020 6e65 775f 6461 7461 5b63        new_data[c
+00008e40: 6f6d 705d 203d 202d 6e70 2e63 6f6e 6a28  omp] = -np.conj(
+00008e50: 6669 656c 6429 0a20 2020 2020 2020 2020  field).         
+00008e60: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00008e70: 2020 2020 2020 2020 206e 6577 5f64 6174           new_dat
+00008e80: 615b 636f 6d70 5d20 3d20 6e70 2e63 6f6e  a[comp] = np.con
+00008e90: 6a28 6669 656c 6429 0a20 2020 2020 2020  j(field).       
+00008ea0: 2072 6574 7572 6e20 7365 6c66 2e63 6f70   return self.cop
+00008eb0: 7928 7570 6461 7465 3d6e 6577 5f64 6174  y(update=new_dat
+00008ec0: 6129 0a0a 0a63 6c61 7373 2046 6965 6c64  a)...class Field
+00008ed0: 4461 7461 2846 6965 6c64 4461 7461 7365  Data(FieldDatase
+00008ee0: 742c 2045 6c65 6374 726f 6d61 676e 6574  t, Electromagnet
+00008ef0: 6963 4669 656c 6444 6174 6129 3a0a 2020  icFieldData):.  
+00008f00: 2020 2222 220a 2020 2020 4461 7461 2061    """.    Data a
+00008f10: 7373 6f63 6961 7465 6420 7769 7468 2061  ssociated with a
+00008f20: 203a 636c 6173 733a 602e 4669 656c 644d   :class:`.FieldM
+00008f30: 6f6e 6974 6f72 603a 2073 6361 6c61 7220  onitor`: scalar 
+00008f40: 636f 6d70 6f6e 656e 7473 206f 6620 4520  components of E 
+00008f50: 616e 6420 4820 6669 656c 6473 2e0a 0a20  and H fields... 
+00008f60: 2020 204e 6f74 6573 0a20 2020 202d 2d2d     Notes.    ---
+00008f70: 2d2d 0a0a 2020 2020 2020 2020 5468 6520  --..        The 
+00008f80: 6461 7461 2069 7320 7374 6f72 6564 2061  data is stored a
+00008f90: 7320 6120 6044 6174 6141 7272 6179 203c  s a `DataArray <
+00008fa0: 6874 7470 733a 2f2f 646f 6373 2e78 6172  https://docs.xar
+00008fb0: 7261 792e 6465 762f 656e 2f73 7461 626c  ray.dev/en/stabl
+00008fc0: 652f 6765 6e65 7261 7465 642f 7861 7272  e/generated/xarr
+00008fd0: 6179 2e44 6174 6141 7272 6179 2e68 746d  ay.DataArray.htm
+00008fe0: 6c3e 605f 0a20 2020 2020 2020 206f 626a  l>`_.        obj
+00008ff0: 6563 7420 7573 696e 6720 7468 6520 6078  ect using the `x
+00009000: 6172 7261 7920 3c68 7474 7073 3a2f 2f64  array <https://d
+00009010: 6f63 732e 7861 7272 6179 2e64 6576 2f65  ocs.xarray.dev/e
+00009020: 6e2f 7374 6162 6c65 2f69 6e64 6578 2e68  n/stable/index.h
+00009030: 746d 6c3e 605f 2070 6163 6b61 6765 2e0a  tml>`_ package..
+00009040: 0a20 2020 2020 2020 2054 6869 7320 6461  .        This da
+00009050: 7461 7365 7420 6361 6e20 636f 6e74 6169  taset can contai
+00009060: 6e20 616c 6c20 656c 6563 7472 6963 2061  n all electric a
+00009070: 6e64 206d 6167 6e65 7469 6320 6669 656c  nd magnetic fiel
+00009080: 6420 636f 6d70 6f6e 656e 7473 3a20 6060  d components: ``
+00009090: 4578 6060 2c20 6060 4579 6060 2c20 6060  Ex``, ``Ey``, ``
+000090a0: 457a 6060 2c20 6060 4878 6060 2c20 6060  Ez``, ``Hx``, ``
+000090b0: 4879 6060 2c0a 2020 2020 2020 2020 616e  Hy``,.        an
+000090c0: 6420 6060 487a 6060 2e0a 0a20 2020 2045  d ``Hz``...    E
+000090d0: 7861 6d70 6c65 0a20 2020 202d 2d2d 2d2d  xample.    -----
+000090e0: 2d2d 0a20 2020 203e 3e3e 2066 726f 6d20  --.    >>> from 
+000090f0: 7469 6479 3364 2069 6d70 6f72 7420 5363  tidy3d import Sc
+00009100: 616c 6172 4669 656c 6444 6174 6141 7272  alarFieldDataArr
+00009110: 6179 0a20 2020 203e 3e3e 2078 203d 205b  ay.    >>> x = [
+00009120: 2d31 2c31 2c33 5d0a 2020 2020 3e3e 3e20  -1,1,3].    >>> 
+00009130: 7920 3d20 5b2d 322c 302c 322c 345d 0a20  y = [-2,0,2,4]. 
+00009140: 2020 203e 3e3e 207a 203d 205b 2d33 2c2d     >>> z = [-3,-
+00009150: 312c 312c 332c 355d 0a20 2020 203e 3e3e  1,1,3,5].    >>>
+00009160: 2066 203d 205b 3265 3134 2c20 3365 3134   f = [2e14, 3e14
+00009170: 5d0a 2020 2020 3e3e 3e20 636f 6f72 6473  ].    >>> coords
+00009180: 203d 2064 6963 7428 783d 785b 3a2d 315d   = dict(x=x[:-1]
+00009190: 2c20 793d 795b 3a2d 315d 2c20 7a3d 7a5b  , y=y[:-1], z=z[
+000091a0: 3a2d 315d 2c20 663d 6629 0a20 2020 203e  :-1], f=f).    >
+000091b0: 3e3e 2067 7269 6420 3d20 4772 6964 2862  >> grid = Grid(b
+000091c0: 6f75 6e64 6172 6965 733d 436f 6f72 6473  oundaries=Coords
+000091d0: 2878 3d78 2c20 793d 792c 207a 3d7a 2929  (x=x, y=y, z=z))
+000091e0: 0a20 2020 203e 3e3e 2073 6361 6c61 725f  .    >>> scalar_
+000091f0: 6669 656c 6420 3d20 5363 616c 6172 4669  field = ScalarFi
+00009200: 656c 6444 6174 6141 7272 6179 2828 312b  eldDataArray((1+
+00009210: 316a 2920 2a20 6e70 2e72 616e 646f 6d2e  1j) * np.random.
+00009220: 7261 6e64 6f6d 2828 322c 332c 342c 3229  random((2,3,4,2)
+00009230: 292c 2063 6f6f 7264 733d 636f 6f72 6473  ), coords=coords
+00009240: 290a 2020 2020 3e3e 3e20 6d6f 6e69 746f  ).    >>> monito
+00009250: 7220 3d20 4669 656c 644d 6f6e 6974 6f72  r = FieldMonitor
+00009260: 280a 2020 2020 2e2e 2e20 2020 2020 7369  (.    ...     si
+00009270: 7a65 3d28 322c 342c 3629 2c20 6672 6571  ze=(2,4,6), freq
+00009280: 733d 5b32 6531 342c 2033 6531 345d 2c20  s=[2e14, 3e14], 
+00009290: 6e61 6d65 3d27 6669 656c 6427 2c20 6669  name='field', fi
+000092a0: 656c 6473 3d5b 2745 7827 2c20 2748 7a27  elds=['Ex', 'Hz'
+000092b0: 5d2c 2063 6f6c 6f63 6174 653d 5472 7565  ], colocate=True
+000092c0: 0a20 2020 202e 2e2e 2029 0a20 2020 203e  .    ... ).    >
+000092d0: 3e3e 2064 6174 6120 3d20 4669 656c 6444  >> data = FieldD
+000092e0: 6174 6128 6d6f 6e69 746f 723d 6d6f 6e69  ata(monitor=moni
+000092f0: 746f 722c 2045 783d 7363 616c 6172 5f66  tor, Ex=scalar_f
+00009300: 6965 6c64 2c20 487a 3d73 6361 6c61 725f  ield, Hz=scalar_
+00009310: 6669 656c 642c 2067 7269 645f 6578 7061  field, grid_expa
+00009320: 6e64 6564 3d67 7269 6429 0a0a 2020 2020  nded=grid)..    
+00009330: 2e2e 2054 4f44 4f20 736f 7274 206f 7574  .. TODO sort out
+00009340: 2073 7461 6e64 616c 6f6e 6520 6461 7461   standalone data
+00009350: 2065 7861 6d70 6c65 2e0a 0a20 2020 2053   example...    S
+00009360: 6565 2041 6c73 6f0a 2020 2020 2d2d 2d2d  ee Also.    ----
+00009370: 2d2d 2d2d 0a0a 2020 2020 2a2a 4e6f 7465  ----..    **Note
+00009380: 626f 6f6b 733a 2a2a 0a20 2020 2020 2020  books:**.       
+00009390: 202a 2060 5175 6963 6b73 7461 7274 203c   * `Quickstart <
+000093a0: 2e2e 2f2e 2e2f 6e6f 7465 626f 6f6b 732f  ../../notebooks/
+000093b0: 5374 6172 7448 6572 652e 6874 6d6c 3e60  StartHere.html>`
+000093c0: 5f3a 2055 7361 6765 2069 6e20 6120 6261  _: Usage in a ba
+000093d0: 7369 6320 7369 6d75 6c61 7469 6f6e 2066  sic simulation f
+000093e0: 6c6f 772e 0a20 2020 2020 2020 202a 2060  low..        * `
+000093f0: 5065 7266 6f72 6d69 6e67 2076 6973 7561  Performing visua
+00009400: 6c69 7a61 7469 6f6e 206f 6620 7369 6d75  lization of simu
+00009410: 6c61 7469 6f6e 2064 6174 6120 3c2e 2e2f  lation data <../
+00009420: 2e2e 2f6e 6f74 6562 6f6f 6b73 2f56 697a  ../notebooks/Viz
+00009430: 4461 7461 2e68 746d 6c3e 605f 0a20 2020  Data.html>`_.   
+00009440: 2020 2020 202a 2060 4164 7661 6e63 6564       * `Advanced
+00009450: 206d 6f6e 6974 6f72 2064 6174 6120 6d61   monitor data ma
+00009460: 6e69 7075 6c61 7469 6f6e 2061 6e64 2076  nipulation and v
+00009470: 6973 7561 6c69 7a61 7469 6f6e 203c 2e2e  isualization <..
+00009480: 2f2e 2e2f 6e6f 7465 626f 6f6b 732f 5861  /../notebooks/Xa
+00009490: 7272 6179 5475 746f 7269 616c 2e68 746d  rrayTutorial.htm
+000094a0: 6c3e 605f 0a20 2020 2022 2222 0a0a 2020  l>`_.    """..  
+000094b0: 2020 6d6f 6e69 746f 723a 2046 6965 6c64    monitor: Field
+000094c0: 4d6f 6e69 746f 7220 3d20 7064 2e46 6965  Monitor = pd.Fie
+000094d0: 6c64 280a 2020 2020 2020 2020 2e2e 2e2c  ld(.        ...,
+000094e0: 2074 6974 6c65 3d22 4d6f 6e69 746f 7222   title="Monitor"
+000094f0: 2c20 6465 7363 7269 7074 696f 6e3d 2246  , description="F
+00009500: 7265 7175 656e 6379 2d64 6f6d 6169 6e20  requency-domain 
+00009510: 6669 656c 6420 6d6f 6e69 746f 7220 6173  field monitor as
+00009520: 736f 6369 6174 6564 2077 6974 6820 7468  sociated with th
+00009530: 6520 6461 7461 2e22 0a20 2020 2029 0a0a  e data.".    )..
+00009540: 2020 2020 5f63 6f6e 7461 696e 735f 6d6f      _contains_mo
+00009550: 6e69 746f 725f 6669 656c 6473 203d 2065  nitor_fields = e
+00009560: 6e66 6f72 6365 5f6d 6f6e 6974 6f72 5f66  nforce_monitor_f
+00009570: 6965 6c64 735f 7072 6573 656e 7428 290a  ields_present().
+00009580: 0a20 2020 2064 6566 206e 6f72 6d61 6c69  .    def normali
+00009590: 7a65 2873 656c 662c 2073 6f75 7263 655f  ze(self, source_
+000095a0: 7370 6563 7472 756d 5f66 6e3a 2043 616c  spectrum_fn: Cal
+000095b0: 6c61 626c 655b 5b66 6c6f 6174 5d2c 2063  lable[[float], c
+000095c0: 6f6d 706c 6578 5d29 202d 3e20 4669 656c  omplex]) -> Fiel
+000095d0: 6444 6174 6173 6574 3a0a 2020 2020 2020  dDataset:.      
+000095e0: 2020 2222 2252 6574 7572 6e20 636f 7079    """Return copy
+000095f0: 206f 6620 7365 6c66 2061 6674 6572 206e   of self after n
+00009600: 6f72 6d61 6c69 7a61 7469 6f6e 2069 7320  ormalization is 
+00009610: 6170 706c 6965 6420 7573 696e 6720 736f  applied using so
+00009620: 7572 6365 2073 7065 6374 7275 6d20 6675  urce spectrum fu
+00009630: 6e63 7469 6f6e 2e22 2222 0a20 2020 2020  nction.""".     
+00009640: 2020 2066 6965 6c64 735f 6e6f 726d 203d     fields_norm =
+00009650: 207b 7d0a 2020 2020 2020 2020 666f 7220   {}.        for 
+00009660: 6669 656c 645f 6e61 6d65 2c20 6669 656c  field_name, fiel
+00009670: 645f 6461 7461 2069 6e20 7365 6c66 2e66  d_data in self.f
+00009680: 6965 6c64 5f63 6f6d 706f 6e65 6e74 732e  ield_components.
+00009690: 6974 656d 7328 293a 0a20 2020 2020 2020  items():.       
+000096a0: 2020 2020 2073 7263 5f61 6d70 7320 3d20       src_amps = 
+000096b0: 736f 7572 6365 5f73 7065 6374 7275 6d5f  source_spectrum_
+000096c0: 666e 2866 6965 6c64 5f64 6174 612e 6629  fn(field_data.f)
+000096d0: 0a20 2020 2020 2020 2020 2020 2066 6965  .            fie
+000096e0: 6c64 735f 6e6f 726d 5b66 6965 6c64 5f6e  lds_norm[field_n
+000096f0: 616d 655d 203d 2028 6669 656c 645f 6461  ame] = (field_da
+00009700: 7461 202f 2073 7263 5f61 6d70 7329 2e61  ta / src_amps).a
+00009710: 7374 7970 6528 6669 656c 645f 6461 7461  stype(field_data
+00009720: 2e64 7479 7065 290a 0a20 2020 2020 2020  .dtype)..       
+00009730: 2072 6574 7572 6e20 7365 6c66 2e63 6f70   return self.cop
+00009740: 7928 7570 6461 7465 3d66 6965 6c64 735f  y(update=fields_
+00009750: 6e6f 726d 290a 0a20 2020 2064 6566 2074  norm)..    def t
+00009760: 6f5f 736f 7572 6365 280a 2020 2020 2020  o_source(.      
+00009770: 2020 7365 6c66 2c20 736f 7572 6365 5f74    self, source_t
+00009780: 696d 653a 2053 6f75 7263 6554 696d 6554  ime: SourceTimeT
+00009790: 7970 652c 2063 656e 7465 723a 2043 6f6f  ype, center: Coo
+000097a0: 7264 696e 6174 652c 2073 697a 653a 2053  rdinate, size: S
+000097b0: 697a 6520 3d20 4e6f 6e65 2c20 2a2a 6b77  ize = None, **kw
+000097c0: 6172 6773 0a20 2020 2029 202d 3e20 4375  args.    ) -> Cu
+000097d0: 7374 6f6d 4669 656c 6453 6f75 7263 653a  stomFieldSource:
+000097e0: 0a20 2020 2020 2020 2022 2222 4372 6561  .        """Crea
+000097f0: 7465 2061 203a 636c 6173 733a 602e 4375  te a :class:`.Cu
+00009800: 7374 6f6d 4669 656c 6453 6f75 7263 6560  stomFieldSource`
+00009810: 2066 726f 6d20 7468 6520 6669 656c 6473   from the fields
+00009820: 2073 746f 7265 6420 696e 2074 6865 203a   stored in the :
+00009830: 636c 6173 733a 602e 4669 656c 6444 6174  class:`.FieldDat
+00009840: 6160 2e0a 0a20 2020 2020 2020 2050 6172  a`...        Par
+00009850: 616d 6574 6572 730a 2020 2020 2020 2020  ameters.        
+00009860: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2020  ----------.     
+00009870: 2020 2073 6f75 7263 655f 7469 6d65 3a20     source_time: 
+00009880: 3a63 6c61 7373 3a60 2e53 6f75 7263 6554  :class:`.SourceT
+00009890: 696d 6560 0a20 2020 2020 2020 2020 2020  ime`.           
+000098a0: 2053 7065 6369 6669 6361 7469 6f6e 206f   Specification o
+000098b0: 6620 7468 6520 736f 7572 6365 2074 696d  f the source tim
+000098c0: 652d 6465 7065 6e64 656e 6365 2e0a 2020  e-dependence..  
+000098d0: 2020 2020 2020 6365 6e74 6572 3a20 5475        center: Tu
+000098e0: 706c 655b 666c 6f61 742c 2066 6c6f 6174  ple[float, float
+000098f0: 2c20 666c 6f61 745d 0a20 2020 2020 2020  , float].       
+00009900: 2020 2020 2053 6f75 7263 6520 6365 6e74       Source cent
+00009910: 6572 2069 6e20 782c 2079 2061 6e64 207a  er in x, y and z
+00009920: 2e0a 2020 2020 2020 2020 7369 7a65 3a20  ..        size: 
+00009930: 5475 706c 655b 666c 6f61 742c 2066 6c6f  Tuple[float, flo
+00009940: 6174 2c20 666c 6f61 745d 0a20 2020 2020  at, float].     
+00009950: 2020 2020 2020 2053 6f75 7263 6520 7369         Source si
+00009960: 7a65 2069 6e20 782c 2079 2c20 616e 6420  ze in x, y, and 
+00009970: 7a2e 2049 6620 6e6f 7420 7072 6f76 6964  z. If not provid
+00009980: 6564 2c20 7468 6520 7369 7a65 206f 6620  ed, the size of 
+00009990: 7468 6520 6d6f 6e69 746f 7220 6173 736f  the monitor asso
+000099a0: 6369 6174 6564 2074 6f20 7468 650a 2020  ciated to the.  
+000099b0: 2020 2020 2020 2020 2020 6461 7461 2069            data i
+000099c0: 7320 7573 6564 2e0a 2020 2020 2020 2020  s used..        
+000099d0: 2a2a 6b77 6172 6773 0a20 2020 2020 2020  **kwargs.       
+000099e0: 2020 2020 2045 7874 7261 206b 6579 776f       Extra keywo
+000099f0: 7264 2061 7267 756d 656e 7473 2070 6173  rd arguments pas
+00009a00: 7365 6420 746f 203a 636c 6173 733a 602e  sed to :class:`.
+00009a10: 4375 7374 6f6d 4669 656c 6453 6f75 7263  CustomFieldSourc
+00009a20: 6560 2e0a 0a20 2020 2020 2020 2052 6574  e`...        Ret
+00009a30: 7572 6e73 0a20 2020 2020 2020 202d 2d2d  urns.        ---
+00009a40: 2d2d 2d2d 0a20 2020 2020 2020 203a 636c  ----.        :cl
+00009a50: 6173 733a 602e 4375 7374 6f6d 4669 656c  ass:`.CustomFiel
+00009a60: 6453 6f75 7263 6560 0a20 2020 2020 2020  dSource`.       
+00009a70: 2020 2020 2053 6f75 7263 6520 696e 6a65       Source inje
+00009a80: 6374 696e 6720 7468 6520 6669 656c 6473  cting the fields
+00009a90: 2073 746f 7265 6420 696e 2074 6865 203a   stored in the :
+00009aa0: 636c 6173 733a 602e 4669 656c 6444 6174  class:`.FieldDat
+00009ab0: 6160 2c20 7769 7468 206f 7468 6572 2073  a`, with other s
+00009ac0: 6574 7469 6e67 7320 6173 0a20 2020 2020  ettings as.     
+00009ad0: 2020 2020 2020 2070 726f 7669 6465 6420         provided 
+00009ae0: 696e 2074 6865 2069 6e70 7574 2061 7267  in the input arg
+00009af0: 756d 656e 7473 2e0a 2020 2020 2020 2020  uments..        
+00009b00: 2222 220a 0a20 2020 2020 2020 2069 6620  """..        if 
+00009b10: 6e6f 7420 7369 7a65 3a0a 2020 2020 2020  not size:.      
+00009b20: 2020 2020 2020 7369 7a65 203d 2073 656c        size = sel
+00009b30: 662e 6d6f 6e69 746f 722e 7369 7a65 0a0a  f.monitor.size..
+00009b40: 2020 2020 2020 2020 6669 656c 6473 203d          fields =
+00009b50: 207b 7d0a 2020 2020 2020 2020 666f 7220   {}.        for 
+00009b60: 6e61 6d65 2c20 6669 656c 6420 696e 2073  name, field in s
+00009b70: 656c 662e 7379 6d6d 6574 7279 5f65 7870  elf.symmetry_exp
+00009b80: 616e 6465 645f 636f 7079 2e66 6965 6c64  anded_copy.field
+00009b90: 5f63 6f6d 706f 6e65 6e74 732e 6974 656d  _components.item
+00009ba0: 7328 293a 0a20 2020 2020 2020 2020 2020  s():.           
+00009bb0: 2066 6965 6c64 735b 6e61 6d65 5d20 3d20   fields[name] = 
+00009bc0: 6669 656c 642e 636f 7079 2829 0a20 2020  field.copy().   
+00009bd0: 2020 2020 2020 2020 2066 6f72 2064 696d           for dim
+00009be0: 2c20 6469 6d5f 6e61 6d65 2069 6e20 656e  , dim_name in en
+00009bf0: 756d 6572 6174 6528 2278 797a 2229 3a0a  umerate("xyz"):.
+00009c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009c10: 636f 6f72 6473 5f73 6869 6674 203d 2066  coords_shift = f
+00009c20: 6965 6c64 2e63 6f6f 7264 735b 6469 6d5f  ield.coords[dim_
+00009c30: 6e61 6d65 5d20 2d20 7365 6c66 2e6d 6f6e  name] - self.mon
+00009c40: 6974 6f72 2e63 656e 7465 725b 6469 6d5d  itor.center[dim]
+00009c50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00009c60: 2066 6965 6c64 735b 6e61 6d65 5d2e 636f   fields[name].co
+00009c70: 6f72 6473 5b64 696d 5f6e 616d 655d 203d  ords[dim_name] =
+00009c80: 2063 6f6f 7264 735f 7368 6966 740a 0a20   coords_shift.. 
+00009c90: 2020 2020 2020 2064 6174 6173 6574 203d         dataset =
+00009ca0: 2046 6965 6c64 4461 7461 7365 7428 2a2a   FieldDataset(**
+00009cb0: 6669 656c 6473 290a 2020 2020 2020 2020  fields).        
+00009cc0: 7265 7475 726e 2043 7573 746f 6d46 6965  return CustomFie
+00009cd0: 6c64 536f 7572 6365 280a 2020 2020 2020  ldSource(.      
+00009ce0: 2020 2020 2020 6669 656c 645f 6461 7461        field_data
+00009cf0: 7365 743d 6461 7461 7365 742c 2073 6f75  set=dataset, sou
+00009d00: 7263 655f 7469 6d65 3d73 6f75 7263 655f  rce_time=source_
+00009d10: 7469 6d65 2c20 6365 6e74 6572 3d63 656e  time, center=cen
+00009d20: 7465 722c 2073 697a 653d 7369 7a65 2c20  ter, size=size, 
+00009d30: 2a2a 6b77 6172 6773 0a20 2020 2020 2020  **kwargs.       
+00009d40: 2029 0a0a 0a63 6c61 7373 2046 6965 6c64   )...class Field
+00009d50: 5469 6d65 4461 7461 2846 6965 6c64 5469  TimeData(FieldTi
+00009d60: 6d65 4461 7461 7365 742c 2045 6c65 6374  meDataset, Elect
+00009d70: 726f 6d61 676e 6574 6963 4669 656c 6444  romagneticFieldD
+00009d80: 6174 6129 3a0a 2020 2020 2222 220a 2020  ata):.    """.  
+00009d90: 2020 4461 7461 2061 7373 6f63 6961 7465    Data associate
+00009da0: 6420 7769 7468 2061 203a 636c 6173 733a  d with a :class:
+00009db0: 602e 4669 656c 6454 696d 654d 6f6e 6974  `.FieldTimeMonit
+00009dc0: 6f72 603a 2073 6361 6c61 7220 636f 6d70  or`: scalar comp
+00009dd0: 6f6e 656e 7473 206f 6620 4520 616e 6420  onents of E and 
+00009de0: 4820 6669 656c 6473 2e0a 0a20 2020 204e  H fields...    N
+00009df0: 6f74 6573 0a20 2020 202d 2d2d 2d2d 0a0a  otes.    -----..
+00009e00: 2020 2020 2020 2020 5468 6520 6461 7461          The data
+00009e10: 2069 7320 7374 6f72 6564 2061 7320 6120   is stored as a 
+00009e20: 6044 6174 6141 7272 6179 203c 6874 7470  `DataArray <http
+00009e30: 733a 2f2f 646f 6373 2e78 6172 7261 792e  s://docs.xarray.
+00009e40: 6465 762f 656e 2f73 7461 626c 652f 6765  dev/en/stable/ge
+00009e50: 6e65 7261 7465 642f 7861 7272 6179 2e44  nerated/xarray.D
+00009e60: 6174 6141 7272 6179 2e68 746d 6c3e 605f  ataArray.html>`_
+00009e70: 0a20 2020 2020 2020 206f 626a 6563 7420  .        object 
+00009e80: 7573 696e 6720 7468 6520 6078 6172 7261  using the `xarra
+00009e90: 7920 3c68 7474 7073 3a2f 2f64 6f63 732e  y <https://docs.
+00009ea0: 7861 7272 6179 2e64 6576 2f65 6e2f 7374  xarray.dev/en/st
+00009eb0: 6162 6c65 2f69 6e64 6578 2e68 746d 6c3e  able/index.html>
+00009ec0: 605f 2070 6163 6b61 6765 2e0a 0a20 2020  `_ package...   
+00009ed0: 2045 7861 6d70 6c65 0a20 2020 202d 2d2d   Example.    ---
+00009ee0: 2d2d 2d2d 0a20 2020 203e 3e3e 2066 726f  ----.    >>> fro
+00009ef0: 6d20 7469 6479 3364 2069 6d70 6f72 7420  m tidy3d import 
+00009f00: 5363 616c 6172 4669 656c 6454 696d 6544  ScalarFieldTimeD
+00009f10: 6174 6141 7272 6179 0a20 2020 203e 3e3e  ataArray.    >>>
+00009f20: 2078 203d 205b 2d31 2c31 2c33 5d0a 2020   x = [-1,1,3].  
+00009f30: 2020 3e3e 3e20 7920 3d20 5b2d 322c 302c    >>> y = [-2,0,
+00009f40: 322c 345d 0a20 2020 203e 3e3e 207a 203d  2,4].    >>> z =
+00009f50: 205b 2d33 2c2d 312c 312c 332c 355d 0a20   [-3,-1,1,3,5]. 
+00009f60: 2020 203e 3e3e 2074 203d 205b 302c 2031     >>> t = [0, 1
+00009f70: 652d 3132 2c20 3265 2d31 325d 0a20 2020  e-12, 2e-12].   
+00009f80: 203e 3e3e 2063 6f6f 7264 7320 3d20 6469   >>> coords = di
+00009f90: 6374 2878 3d78 5b3a 2d31 5d2c 2079 3d79  ct(x=x[:-1], y=y
+00009fa0: 5b3a 2d31 5d2c 207a 3d7a 5b3a 2d31 5d2c  [:-1], z=z[:-1],
+00009fb0: 2074 3d74 290a 2020 2020 3e3e 3e20 6772   t=t).    >>> gr
+00009fc0: 6964 203d 2047 7269 6428 626f 756e 6461  id = Grid(bounda
+00009fd0: 7269 6573 3d43 6f6f 7264 7328 783d 782c  ries=Coords(x=x,
+00009fe0: 2079 3d79 2c20 7a3d 7a29 290a 2020 2020   y=y, z=z)).    
+00009ff0: 3e3e 3e20 7363 616c 6172 5f66 6965 6c64  >>> scalar_field
+0000a000: 203d 2053 6361 6c61 7246 6965 6c64 5469   = ScalarFieldTi
+0000a010: 6d65 4461 7461 4172 7261 7928 6e70 2e72  meDataArray(np.r
+0000a020: 616e 646f 6d2e 7261 6e64 6f6d 2828 322c  andom.random((2,
+0000a030: 332c 342c 3329 292c 2063 6f6f 7264 733d  3,4,3)), coords=
+0000a040: 636f 6f72 6473 290a 2020 2020 3e3e 3e20  coords).    >>> 
+0000a050: 6d6f 6e69 746f 7220 3d20 4669 656c 6454  monitor = FieldT
+0000a060: 696d 654d 6f6e 6974 6f72 280a 2020 2020  imeMonitor(.    
+0000a070: 2e2e 2e20 2020 2020 7369 7a65 3d28 322c  ...     size=(2,
+0000a080: 342c 3629 2c20 696e 7465 7276 616c 3d31  4,6), interval=1
+0000a090: 3030 2c20 6e61 6d65 3d27 6669 656c 6427  00, name='field'
+0000a0a0: 2c20 6669 656c 6473 3d5b 2745 7827 2c20  , fields=['Ex', 
+0000a0b0: 2748 7a27 5d2c 2063 6f6c 6f63 6174 653d  'Hz'], colocate=
+0000a0c0: 5472 7565 0a20 2020 202e 2e2e 2029 0a20  True.    ... ). 
+0000a0d0: 2020 203e 3e3e 2064 6174 6120 3d20 4669     >>> data = Fi
+0000a0e0: 656c 6454 696d 6544 6174 6128 6d6f 6e69  eldTimeData(moni
+0000a0f0: 746f 723d 6d6f 6e69 746f 722c 2045 783d  tor=monitor, Ex=
+0000a100: 7363 616c 6172 5f66 6965 6c64 2c20 487a  scalar_field, Hz
+0000a110: 3d73 6361 6c61 725f 6669 656c 642c 2067  =scalar_field, g
+0000a120: 7269 645f 6578 7061 6e64 6564 3d67 7269  rid_expanded=gri
+0000a130: 6429 0a20 2020 2022 2222 0a0a 2020 2020  d).    """..    
+0000a140: 6d6f 6e69 746f 723a 2046 6965 6c64 5469  monitor: FieldTi
+0000a150: 6d65 4d6f 6e69 746f 7220 3d20 7064 2e46  meMonitor = pd.F
+0000a160: 6965 6c64 280a 2020 2020 2020 2020 2e2e  ield(.        ..
+0000a170: 2e2c 2074 6974 6c65 3d22 4d6f 6e69 746f  ., title="Monito
+0000a180: 7222 2c20 6465 7363 7269 7074 696f 6e3d  r", description=
+0000a190: 2254 696d 652d 646f 6d61 696e 2066 6965  "Time-domain fie
+0000a1a0: 6c64 206d 6f6e 6974 6f72 2061 7373 6f63  ld monitor assoc
+0000a1b0: 6961 7465 6420 7769 7468 2074 6865 2064  iated with the d
+0000a1c0: 6174 612e 220a 2020 2020 290a 0a20 2020  ata.".    )..   
+0000a1d0: 205f 636f 6e74 6169 6e73 5f6d 6f6e 6974   _contains_monit
+0000a1e0: 6f72 5f66 6965 6c64 7320 3d20 656e 666f  or_fields = enfo
+0000a1f0: 7263 655f 6d6f 6e69 746f 725f 6669 656c  rce_monitor_fiel
+0000a200: 6473 5f70 7265 7365 6e74 2829 0a0a 2020  ds_present()..  
+0000a210: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
+0000a220: 6465 6620 706f 796e 7469 6e67 2873 656c  def poynting(sel
+0000a230: 6629 202d 3e20 5363 616c 6172 4669 656c  f) -> ScalarFiel
+0000a240: 6454 696d 6544 6174 6141 7272 6179 3a0a  dTimeDataArray:.
+0000a250: 2020 2020 2020 2020 2222 2249 6e73 7461          """Insta
+0000a260: 6e74 616e 656f 7573 2050 6f79 6e74 696e  ntaneous Poyntin
+0000a270: 6720 7665 6374 6f72 2066 6f72 2074 696d  g vector for tim
+0000a280: 652d 646f 6d61 696e 2064 6174 6120 6173  e-domain data as
+0000a290: 736f 6369 6174 6564 2074 6f20 6120 3244  sociated to a 2D
+0000a2a0: 206d 6f6e 6974 6f72 2c20 7072 6f6a 6563   monitor, projec
+0000a2b0: 7465 640a 2020 2020 2020 2020 746f 2074  ted.        to t
+0000a2c0: 6865 2064 6972 6563 7469 6f6e 206e 6f72  he direction nor
+0000a2d0: 6d61 6c20 746f 2074 6865 206d 6f6e 6974  mal to the monit
+0000a2e0: 6f72 2070 6c61 6e65 2e22 2222 0a0a 2020  or plane."""..  
+0000a2f0: 2020 2020 2020 2320 5461 6e67 656e 7469        # Tangenti
+0000a300: 616c 2066 6965 6c64 7320 6172 6520 6f72  al fields are or
+0000a310: 6465 7265 6420 6173 2045 312c 2045 322c  dered as E1, E2,
+0000a320: 2048 312c 2048 320a 2020 2020 2020 2020   H1, H2.        
+0000a330: 7461 6e5f 6669 656c 6473 203d 2073 656c  tan_fields = sel
+0000a340: 662e 5f63 6f6c 6f63 6174 6564 5f74 616e  f._colocated_tan
+0000a350: 6765 6e74 6961 6c5f 6669 656c 6473 0a20  gential_fields. 
+0000a360: 2020 2020 2020 2064 696d 312c 2064 696d         dim1, dim
+0000a370: 3220 3d20 7365 6c66 2e5f 7461 6e67 656e  2 = self._tangen
+0000a380: 7469 616c 5f64 696d 730a 2020 2020 2020  tial_dims.      
+0000a390: 2020 655f 785f 6820 3d20 6e70 2e72 6561    e_x_h = np.rea
+0000a3a0: 6c28 7461 6e5f 6669 656c 6473 5b22 4522  l(tan_fields["E"
+0000a3b0: 202b 2064 696d 315d 2920 2a20 6e70 2e72   + dim1]) * np.r
+0000a3c0: 6561 6c28 7461 6e5f 6669 656c 6473 5b22  eal(tan_fields["
+0000a3d0: 4822 202b 2064 696d 325d 290a 2020 2020  H" + dim2]).    
+0000a3e0: 2020 2020 655f 785f 6820 2d3d 206e 702e      e_x_h -= np.
+0000a3f0: 7265 616c 2874 616e 5f66 6965 6c64 735b  real(tan_fields[
+0000a400: 2245 2220 2b20 6469 6d32 5d29 202a 206e  "E" + dim2]) * n
+0000a410: 702e 7265 616c 2874 616e 5f66 6965 6c64  p.real(tan_field
+0000a420: 735b 2248 2220 2b20 6469 6d31 5d29 0a20  s["H" + dim1]). 
+0000a430: 2020 2020 2020 2072 6574 7572 6e20 655f         return e_
+0000a440: 785f 680a 0a20 2020 2040 6361 6368 6564  x_h..    @cached
+0000a450: 5f70 726f 7065 7274 790a 2020 2020 6465  _property.    de
+0000a460: 6620 666c 7578 2873 656c 6629 202d 3e20  f flux(self) -> 
+0000a470: 466c 7578 5469 6d65 4461 7461 4172 7261  FluxTimeDataArra
+0000a480: 793a 0a20 2020 2020 2020 2022 2222 466c  y:.        """Fl
+0000a490: 7578 2066 6f72 2064 6174 6120 636f 7272  ux for data corr
+0000a4a0: 6573 706f 6e64 696e 6720 746f 2061 2032  esponding to a 2
+0000a4b0: 4420 6d6f 6e69 746f 722e 2222 220a 0a20  D monitor.""".. 
+0000a4c0: 2020 2020 2020 2023 2043 6f6d 7075 7465         # Compute
+0000a4d0: 2066 6c75 7820 6279 2069 6e74 6567 7261   flux by integra
+0000a4e0: 7469 6e67 2050 6f79 6e74 696e 6720 7665  ting Poynting ve
+0000a4f0: 6374 6f72 2069 6e2d 706c 616e 650a 2020  ctor in-plane.  
+0000a500: 2020 2020 2020 645f 6172 6561 203d 2073        d_area = s
+0000a510: 656c 662e 5f64 6966 665f 6172 6561 0a20  elf._diff_area. 
+0000a520: 2020 2020 2020 2072 6574 7572 6e20 466c         return Fl
+0000a530: 7578 5469 6d65 4461 7461 4172 7261 7928  uxTimeDataArray(
+0000a540: 2873 656c 662e 706f 796e 7469 6e67 202a  (self.poynting *
+0000a550: 2064 5f61 7265 6129 2e73 756d 2864 696d   d_area).sum(dim
+0000a560: 3d64 5f61 7265 612e 6469 6d73 2929 0a0a  =d_area.dims))..
+0000a570: 2020 2020 6465 6620 646f 7428 7365 6c66      def dot(self
+0000a580: 2c20 6669 656c 645f 6461 7461 3a20 456c  , field_data: El
+0000a590: 6563 7472 6f6d 6167 6e65 7469 6346 6965  ectromagneticFie
+0000a5a0: 6c64 4461 7461 2c20 636f 6e6a 7567 6174  ldData, conjugat
+0000a5b0: 653a 2062 6f6f 6c20 3d20 5472 7565 2920  e: bool = True) 
+0000a5c0: 2d3e 2078 722e 4461 7461 4172 7261 793a  -> xr.DataArray:
+0000a5d0: 0a20 2020 2020 2020 2022 2222 496e 6e65  .        """Inne
+0000a5e0: 7220 7072 6f64 7563 7420 6973 206e 6f74  r product is not
+0000a5f0: 2064 6566 696e 6564 2066 6f72 2074 696d   defined for tim
+0000a600: 652d 646f 6d61 696e 2064 6174 612e 2222  e-domain data.""
+0000a610: 220a 2020 2020 2020 2020 7261 6973 6520  ".        raise 
+0000a620: 4461 7461 4572 726f 7228 2249 6e6e 6572  DataError("Inner
+0000a630: 2070 726f 6475 6374 2069 7320 6e6f 7420   product is not 
+0000a640: 6465 6669 6e65 6420 666f 7220 7469 6d65  defined for time
+0000a650: 2d64 6f6d 6169 6e20 6461 7461 2e22 290a  -domain data.").
+0000a660: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
+0000a670: 2020 2064 6566 2074 696d 655f 7265 7665     def time_reve
+0000a680: 7273 6564 5f63 6f70 7928 7365 6c66 2920  rsed_copy(self) 
+0000a690: 2d3e 2046 6965 6c64 5469 6d65 4461 7461  -> FieldTimeData
+0000a6a0: 3a0a 2020 2020 2020 2020 2222 224d 616b  :.        """Mak
+0000a6b0: 6520 6120 636f 7079 206f 6620 7468 6520  e a copy of the 
+0000a6c0: 6461 7461 2077 6974 6820 7469 6d65 2d72  data with time-r
+0000a6d0: 6576 6572 7365 6420 6669 656c 6473 2e20  eversed fields. 
+0000a6e0: 5468 6520 7369 676e 206f 6620 7468 6520  The sign of the 
+0000a6f0: 6d61 676e 6574 6963 2066 6965 6c64 7320  magnetic fields 
+0000a700: 6973 0a20 2020 2020 2020 2066 6c69 7070  is.        flipp
+0000a710: 6564 2c20 616e 6420 7468 6520 6461 7461  ed, and the data
+0000a720: 2069 7320 7265 7665 7273 6564 2061 6c6f   is reversed alo
+0000a730: 6e67 2074 6865 2060 6074 6060 2064 696d  ng the ``t`` dim
+0000a740: 656e 7369 6f6e 2c20 7375 6368 2074 6861  ension, such tha
+0000a750: 7420 666f 7220 6120 6769 7665 6e20 6669  t for a given fi
+0000a760: 656c 642c 0a20 2020 2020 2020 2060 6066  eld,.        ``f
+0000a770: 6965 6c64 5b74 5f62 6567 202b 2074 5d20  ield[t_beg + t] 
+0000a780: 2d3e 2066 6965 6c64 5b74 5f65 6e64 202d  -> field[t_end -
+0000a790: 2074 5d60 602c 2077 6865 7265 2060 6074   t]``, where ``t
+0000a7a0: 5f62 6567 6060 2061 6e64 2060 6074 5f65  _beg`` and ``t_e
+0000a7b0: 6e64 6060 2061 7265 2074 6865 2066 6972  nd`` are the fir
+0000a7c0: 7374 2061 6e64 0a20 2020 2020 2020 206c  st and.        l
+0000a7d0: 6173 7420 636f 6f72 6469 6e61 7465 7320  ast coordinates 
+0000a7e0: 616c 6f6e 6720 7468 6520 6060 7460 6020  along the ``t`` 
+0000a7f0: 6469 6d65 6e73 696f 6e2e 0a20 2020 2020  dimension..     
+0000a800: 2020 2022 2222 0a20 2020 2020 2020 206e     """.        n
+0000a810: 6577 5f64 6174 6120 3d20 7b7d 0a20 2020  ew_data = {}.   
+0000a820: 2020 2020 2066 6f72 2063 6f6d 702c 2066       for comp, f
+0000a830: 6965 6c64 2069 6e20 7365 6c66 2e66 6965  ield in self.fie
+0000a840: 6c64 5f63 6f6d 706f 6e65 6e74 732e 6974  ld_components.it
+0000a850: 656d 7328 293a 0a20 2020 2020 2020 2020  ems():.         
+0000a860: 2020 2069 6620 636f 6d70 5b30 5d20 3d3d     if comp[0] ==
+0000a870: 2022 4822 3a0a 2020 2020 2020 2020 2020   "H":.          
+0000a880: 2020 2020 2020 6e65 775f 6461 7461 5b63        new_data[c
+0000a890: 6f6d 705d 203d 202d 6669 656c 640a 2020  omp] = -field.  
+0000a8a0: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+0000a8b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a8c0: 6e65 775f 6461 7461 5b63 6f6d 705d 203d  new_data[comp] =
+0000a8d0: 2066 6965 6c64 0a20 2020 2020 2020 2020   field.         
+0000a8e0: 2020 2023 2052 6576 6572 7365 2074 696d     # Reverse tim
+0000a8f0: 6520 636f 6f72 6469 6e61 7465 730a 2020  e coordinates.  
+0000a900: 2020 2020 2020 2020 2020 6e65 775f 6461            new_da
+0000a910: 7461 5b63 6f6d 705d 203d 206e 6577 5f64  ta[comp] = new_d
+0000a920: 6174 615b 636f 6d70 5d2e 6173 7369 676e  ata[comp].assign
+0000a930: 5f63 6f6f 7264 7328 7b22 7422 3a20 6669  _coords({"t": fi
+0000a940: 656c 642e 745b 3a3a 2d31 5d7d 292e 736f  eld.t[::-1]}).so
+0000a950: 7274 6279 2822 7422 290a 2020 2020 2020  rtby("t").      
+0000a960: 2020 7265 7475 726e 2073 656c 662e 636f    return self.co
+0000a970: 7079 2875 7064 6174 653d 6e65 775f 6461  py(update=new_da
+0000a980: 7461 290a 0a0a 636c 6173 7320 5065 726d  ta)...class Perm
+0000a990: 6974 7469 7669 7479 4461 7461 2850 6572  ittivityData(Per
+0000a9a0: 6d69 7474 6976 6974 7944 6174 6173 6574  mittivityDataset
+0000a9b0: 2c20 4162 7374 7261 6374 4669 656c 6444  , AbstractFieldD
+0000a9c0: 6174 6129 3a0a 2020 2020 2222 2244 6174  ata):.    """Dat
+0000a9d0: 6120 666f 7220 6120 3a63 6c61 7373 3a60  a for a :class:`
+0000a9e0: 2e50 6572 6d69 7474 6976 6974 794d 6f6e  .PermittivityMon
+0000a9f0: 6974 6f72 603a 2064 6961 676f 6e61 6c20  itor`: diagonal 
+0000aa00: 636f 6d70 6f6e 656e 7473 206f 6620 7468  components of th
+0000aa10: 6520 7065 726d 6974 7469 7669 7479 2074  e permittivity t
+0000aa20: 656e 736f 722e 0a0a 2020 2020 4e6f 7465  ensor...    Note
+0000aa30: 730a 2020 2020 2d2d 2d2d 2d0a 0a20 2020  s.    -----..   
+0000aa40: 2020 2020 2054 6865 2064 6174 6120 6973       The data is
+0000aa50: 2073 746f 7265 6420 6173 2061 2060 4461   stored as a `Da
+0000aa60: 7461 4172 7261 7920 3c68 7474 7073 3a2f  taArray <https:/
+0000aa70: 2f64 6f63 732e 7861 7272 6179 2e64 6576  /docs.xarray.dev
+0000aa80: 2f65 6e2f 7374 6162 6c65 2f67 656e 6572  /en/stable/gener
+0000aa90: 6174 6564 2f78 6172 7261 792e 4461 7461  ated/xarray.Data
+0000aaa0: 4172 7261 792e 6874 6d6c 3e60 5f0a 2020  Array.html>`_.  
+0000aab0: 2020 2020 2020 6f62 6a65 6374 2075 7369        object usi
+0000aac0: 6e67 2074 6865 2060 7861 7272 6179 203c  ng the `xarray <
+0000aad0: 6874 7470 733a 2f2f 646f 6373 2e78 6172  https://docs.xar
+0000aae0: 7261 792e 6465 762f 656e 2f73 7461 626c  ray.dev/en/stabl
+0000aaf0: 652f 696e 6465 782e 6874 6d6c 3e60 5f20  e/index.html>`_ 
+0000ab00: 7061 636b 6167 652e 0a0a 2020 2020 4578  package...    Ex
+0000ab10: 616d 706c 650a 2020 2020 2d2d 2d2d 2d2d  ample.    ------
+0000ab20: 2d0a 2020 2020 3e3e 3e20 6672 6f6d 2074  -.    >>> from t
+0000ab30: 6964 7933 6420 696d 706f 7274 2053 6361  idy3d import Sca
+0000ab40: 6c61 7246 6965 6c64 4461 7461 4172 7261  larFieldDataArra
+0000ab50: 790a 2020 2020 3e3e 3e20 7820 3d20 5b2d  y.    >>> x = [-
+0000ab60: 312c 312c 335d 0a20 2020 203e 3e3e 2079  1,1,3].    >>> y
+0000ab70: 203d 205b 2d32 2c30 2c32 2c34 5d0a 2020   = [-2,0,2,4].  
+0000ab80: 2020 3e3e 3e20 7a20 3d20 5b2d 332c 2d31    >>> z = [-3,-1
+0000ab90: 2c31 2c33 2c35 5d0a 2020 2020 3e3e 3e20  ,1,3,5].    >>> 
+0000aba0: 6620 3d20 5b32 6531 342c 2033 6531 345d  f = [2e14, 3e14]
+0000abb0: 0a20 2020 203e 3e3e 2063 6f6f 7264 7320  .    >>> coords 
+0000abc0: 3d20 6469 6374 2878 3d78 5b3a 2d31 5d2c  = dict(x=x[:-1],
+0000abd0: 2079 3d79 5b3a 2d31 5d2c 207a 3d7a 5b3a   y=y[:-1], z=z[:
+0000abe0: 2d31 5d2c 2066 3d66 290a 2020 2020 3e3e  -1], f=f).    >>
+0000abf0: 3e20 6772 6964 203d 2047 7269 6428 626f  > grid = Grid(bo
+0000ac00: 756e 6461 7269 6573 3d43 6f6f 7264 7328  undaries=Coords(
+0000ac10: 783d 782c 2079 3d79 2c20 7a3d 7a29 290a  x=x, y=y, z=z)).
+0000ac20: 2020 2020 3e3e 3e20 7363 6c72 5f66 6c64      >>> sclr_fld
+0000ac30: 203d 2053 6361 6c61 7246 6965 6c64 4461   = ScalarFieldDa
+0000ac40: 7461 4172 7261 7928 2831 2b31 6a29 202a  taArray((1+1j) *
+0000ac50: 206e 702e 7261 6e64 6f6d 2e72 616e 646f   np.random.rando
+0000ac60: 6d28 2832 2c33 2c34 2c32 2929 2c20 636f  m((2,3,4,2)), co
+0000ac70: 6f72 6473 3d63 6f6f 7264 7329 0a20 2020  ords=coords).   
+0000ac80: 203e 3e3e 206d 6f6e 6974 6f72 203d 2050   >>> monitor = P
+0000ac90: 6572 6d69 7474 6976 6974 794d 6f6e 6974  ermittivityMonit
+0000aca0: 6f72 2873 697a 653d 2832 2c34 2c36 292c  or(size=(2,4,6),
+0000acb0: 2066 7265 7173 3d5b 3265 3134 2c20 3365   freqs=[2e14, 3e
+0000acc0: 3134 5d2c 206e 616d 653d 2765 7073 2729  14], name='eps')
+0000acd0: 0a20 2020 203e 3e3e 2064 6174 6120 3d20  .    >>> data = 
+0000ace0: 5065 726d 6974 7469 7669 7479 4461 7461  PermittivityData
+0000acf0: 280a 2020 2020 2e2e 2e20 2020 2020 6d6f  (.    ...     mo
+0000ad00: 6e69 746f 723d 6d6f 6e69 746f 722c 2065  nitor=monitor, e
+0000ad10: 7073 5f78 783d 7363 6c72 5f66 6c64 2c20  ps_xx=sclr_fld, 
+0000ad20: 6570 735f 7979 3d73 636c 725f 666c 642c  eps_yy=sclr_fld,
+0000ad30: 2065 7073 5f7a 7a3d 7363 6c72 5f66 6c64   eps_zz=sclr_fld
+0000ad40: 2c20 6772 6964 5f65 7870 616e 6465 643d  , grid_expanded=
+0000ad50: 6772 6964 0a20 2020 202e 2e2e 2029 0a20  grid.    ... ). 
+0000ad60: 2020 2022 2222 0a0a 2020 2020 6d6f 6e69     """..    moni
+0000ad70: 746f 723a 2050 6572 6d69 7474 6976 6974  tor: Permittivit
+0000ad80: 794d 6f6e 6974 6f72 203d 2070 642e 4669  yMonitor = pd.Fi
+0000ad90: 656c 6428 0a20 2020 2020 2020 202e 2e2e  eld(.        ...
+0000ada0: 2c20 7469 746c 653d 224d 6f6e 6974 6f72  , title="Monitor
+0000adb0: 222c 2064 6573 6372 6970 7469 6f6e 3d22  ", description="
+0000adc0: 5065 726d 6974 7469 7669 7479 206d 6f6e  Permittivity mon
+0000add0: 6974 6f72 2061 7373 6f63 6961 7465 6420  itor associated 
+0000ade0: 7769 7468 2074 6865 2064 6174 612e 220a  with the data.".
+0000adf0: 2020 2020 290a 0a0a 636c 6173 7320 4d6f      )...class Mo
+0000ae00: 6465 4461 7461 284d 6f64 6553 6f6c 7665  deData(ModeSolve
+0000ae10: 7244 6174 6173 6574 2c20 456c 6563 7472  rDataset, Electr
+0000ae20: 6f6d 6167 6e65 7469 6346 6965 6c64 4461  omagneticFieldDa
+0000ae30: 7461 293a 0a20 2020 2022 2222 0a20 2020  ta):.    """.   
+0000ae40: 2044 6174 6120 6173 736f 6369 6174 6564   Data associated
+0000ae50: 2077 6974 6820 6120 3a63 6c61 7373 3a60   with a :class:`
+0000ae60: 2e4d 6f64 654d 6f6e 6974 6f72 603a 206d  .ModeMonitor`: m
+0000ae70: 6f64 616c 2061 6d70 6c69 7475 6465 732c  odal amplitudes,
+0000ae80: 2070 726f 7061 6761 7469 6f6e 2069 6e64   propagation ind
+0000ae90: 6963 6573 2061 6e64 206d 6f64 6520 7072  ices and mode pr
+0000aea0: 6f66 696c 6573 2e0a 0a20 2020 204e 6f74  ofiles...    Not
+0000aeb0: 6573 0a20 2020 202d 2d2d 2d2d 0a0a 2020  es.    -----..  
+0000aec0: 2020 2020 2020 5468 6520 6461 7461 2069        The data i
+0000aed0: 7320 7374 6f72 6564 2061 7320 6120 6044  s stored as a `D
+0000aee0: 6174 6141 7272 6179 203c 6874 7470 733a  ataArray <https:
+0000aef0: 2f2f 646f 6373 2e78 6172 7261 792e 6465  //docs.xarray.de
+0000af00: 762f 656e 2f73 7461 626c 652f 6765 6e65  v/en/stable/gene
+0000af10: 7261 7465 642f 7861 7272 6179 2e44 6174  rated/xarray.Dat
+0000af20: 6141 7272 6179 2e68 746d 6c3e 605f 0a20  aArray.html>`_. 
+0000af30: 2020 2020 2020 206f 626a 6563 7420 7573         object us
+0000af40: 696e 6720 7468 6520 6078 6172 7261 7920  ing the `xarray 
+0000af50: 3c68 7474 7073 3a2f 2f64 6f63 732e 7861  <https://docs.xa
+0000af60: 7272 6179 2e64 6576 2f65 6e2f 7374 6162  rray.dev/en/stab
+0000af70: 6c65 2f69 6e64 6578 2e68 746d 6c3e 605f  le/index.html>`_
+0000af80: 2070 6163 6b61 6765 2e0a 0a20 2020 2020   package...     
+0000af90: 2020 2054 6865 206d 6f64 6520 6d6f 6e69     The mode moni
+0000afa0: 746f 7220 6461 7461 2063 6f6e 7461 696e  tor data contain
+0000afb0: 7320 7468 6520 636f 6d70 6c65 7820 6566  s the complex ef
+0000afc0: 6665 6374 6976 6520 696e 6469 6365 7320  fective indices 
+0000afd0: 616e 6420 7468 6520 636f 6d70 6c65 7820  and the complex 
+0000afe0: 6d6f 6465 2061 6d70 6c69 7475 6465 7320  mode amplitudes 
+0000aff0: 6174 2074 6865 206d 6f6e 6974 6f72 0a20  at the monitor. 
+0000b000: 2020 2020 2020 2070 6f73 6974 696f 6e20         position 
+0000b010: 6361 6c63 756c 6174 6564 2062 7920 6d6f  calculated by mo
+0000b020: 6465 2064 6563 6f6d 706f 7369 7469 6f6e  de decomposition
+0000b030: 2e20 5468 6520 6461 7461 2073 7472 7563  . The data struc
+0000b040: 7475 7265 206f 6620 7468 6520 636f 6d70  ture of the comp
+0000b050: 6c65 7820 6566 6665 6374 6976 650a 2020  lex effective.  
+0000b060: 2020 2020 2020 696e 6469 6365 7320 3a61        indices :a
+0000b070: 7474 7260 6e5f 636f 6d70 6c65 7860 2063  ttr`n_complex` c
+0000b080: 6f6e 7461 696e 7320 7477 6f20 636f 6f72  ontains two coor
+0000b090: 6469 6e61 7465 733a 2060 6066 6060 2061  dinates: ``f`` a
+0000b0a0: 6e64 2060 606d 6f64 655f 696e 6465 7860  nd ``mode_index`
+0000b0b0: 602c 2062 6f74 6820 6f66 2077 6869 6368  `, both of which
+0000b0c0: 2061 7265 2073 7065 6369 6669 6564 2077   are specified w
+0000b0d0: 6865 6e0a 2020 2020 2020 2020 6465 6669  hen.        defi
+0000b0e0: 6e69 6e67 2074 6865 203a 636c 6173 733a  ning the :class:
+0000b0f0: 6060 4d6f 6465 4d6f 6e69 746f 7260 6020  ``ModeMonitor`` 
+0000b100: 696e 2074 6865 2073 696d 756c 6174 696f  in the simulatio
+0000b110: 6e2e 0a0a 2020 2020 2020 2020 4265 7369  n...        Besi
+0000b120: 6465 7320 7468 6520 6566 6665 6374 6976  des the effectiv
+0000b130: 6520 696e 6465 782c 203a 636c 6173 733a  e index, :class:
+0000b140: 6060 4d6f 6465 4d6f 6e69 746f 7260 6020  ``ModeMonitor`` 
+0000b150: 6973 2070 7269 6d61 7269 6c79 2075 7365  is primarily use
+0000b160: 6420 746f 2063 616c 6375 6c61 7465 2074  d to calculate t
+0000b170: 6865 2074 7261 6e73 6d69 7373 696f 6e20  he transmission 
+0000b180: 6f66 0a20 2020 2020 2020 2063 6572 7461  of.        certa
+0000b190: 696e 206d 6f64 6573 2069 6e20 6365 7274  in modes in cert
+0000b1a0: 6169 6e20 6469 7265 6374 696f 6e73 2e20  ain directions. 
+0000b1b0: 5765 2063 616e 2065 7874 7261 6374 2074  We can extract t
+0000b1c0: 6865 2063 6f6d 706c 6578 2061 6d70 6c69  he complex ampli
+0000b1d0: 7475 6465 2061 6e64 2073 7175 6172 6520  tude and square 
+0000b1e0: 6974 2074 6f20 636f 6d70 7574 6520 7468  it to compute th
+0000b1f0: 6520 6d6f 6465 0a20 2020 2020 2020 2074  e mode.        t
+0000b200: 7261 6e73 6d69 7373 696f 6e20 706f 7765  ransmission powe
+0000b210: 722e 0a0a 2020 2020 4578 616d 706c 650a  r...    Example.
+0000b220: 2020 2020 2d2d 2d2d 2d2d 2d0a 2020 2020      -------.    
+0000b230: 3e3e 3e20 6672 6f6d 2074 6964 7933 6420  >>> from tidy3d 
+0000b240: 696d 706f 7274 204d 6f64 6553 7065 630a  import ModeSpec.
+0000b250: 2020 2020 3e3e 3e20 6672 6f6d 2074 6964      >>> from tid
+0000b260: 7933 6420 696d 706f 7274 204d 6f64 6541  y3d import ModeA
+0000b270: 6d70 7344 6174 6141 7272 6179 2c20 4d6f  mpsDataArray, Mo
+0000b280: 6465 496e 6465 7844 6174 6141 7272 6179  deIndexDataArray
+0000b290: 0a20 2020 203e 3e3e 2064 6972 6563 7469  .    >>> directi
+0000b2a0: 6f6e 203d 205b 222b 222c 2022 2d22 5d0a  on = ["+", "-"].
+0000b2b0: 2020 2020 3e3e 3e20 6620 3d20 5b31 6531      >>> f = [1e1
+0000b2c0: 342c 2032 6531 342c 2033 6531 345d 0a20  4, 2e14, 3e14]. 
+0000b2d0: 2020 203e 3e3e 206d 6f64 655f 696e 6465     >>> mode_inde
+0000b2e0: 7820 3d20 6e70 2e61 7261 6e67 6528 3529  x = np.arange(5)
+0000b2f0: 0a20 2020 203e 3e3e 2069 6e64 6578 5f63  .    >>> index_c
+0000b300: 6f6f 7264 7320 3d20 6469 6374 2866 3d66  oords = dict(f=f
+0000b310: 2c20 6d6f 6465 5f69 6e64 6578 3d6d 6f64  , mode_index=mod
+0000b320: 655f 696e 6465 7829 0a20 2020 203e 3e3e  e_index).    >>>
+0000b330: 2069 6e64 6578 5f64 6174 6120 3d20 4d6f   index_data = Mo
+0000b340: 6465 496e 6465 7844 6174 6141 7272 6179  deIndexDataArray
+0000b350: 2828 312b 316a 2920 2a20 6e70 2e72 616e  ((1+1j) * np.ran
+0000b360: 646f 6d2e 7261 6e64 6f6d 2828 332c 2035  dom.random((3, 5
+0000b370: 2929 2c20 636f 6f72 6473 3d69 6e64 6578  )), coords=index
+0000b380: 5f63 6f6f 7264 7329 0a20 2020 203e 3e3e  _coords).    >>>
+0000b390: 2061 6d70 5f63 6f6f 7264 7320 3d20 6469   amp_coords = di
+0000b3a0: 6374 2864 6972 6563 7469 6f6e 3d64 6972  ct(direction=dir
+0000b3b0: 6563 7469 6f6e 2c20 663d 662c 206d 6f64  ection, f=f, mod
+0000b3c0: 655f 696e 6465 783d 6d6f 6465 5f69 6e64  e_index=mode_ind
+0000b3d0: 6578 290a 2020 2020 3e3e 3e20 616d 705f  ex).    >>> amp_
+0000b3e0: 6461 7461 203d 204d 6f64 6541 6d70 7344  data = ModeAmpsD
+0000b3f0: 6174 6141 7272 6179 2828 312b 316a 2920  ataArray((1+1j) 
+0000b400: 2a20 6e70 2e72 616e 646f 6d2e 7261 6e64  * np.random.rand
+0000b410: 6f6d 2828 322c 2033 2c20 3529 292c 2063  om((2, 3, 5)), c
+0000b420: 6f6f 7264 733d 616d 705f 636f 6f72 6473  oords=amp_coords
+0000b430: 290a 2020 2020 3e3e 3e20 6d6f 6e69 746f  ).    >>> monito
+0000b440: 7220 3d20 4d6f 6465 4d6f 6e69 746f 7228  r = ModeMonitor(
+0000b450: 0a20 2020 202e 2e2e 2020 2020 7369 7a65  .    ...    size
+0000b460: 3d28 322c 302c 3629 2c0a 2020 2020 2e2e  =(2,0,6),.    ..
+0000b470: 2e20 2020 2066 7265 7173 3d5b 3265 3134  .    freqs=[2e14
+0000b480: 2c20 3365 3134 5d2c 0a20 2020 202e 2e2e  , 3e14],.    ...
+0000b490: 2020 2020 6d6f 6465 5f73 7065 633d 4d6f      mode_spec=Mo
+0000b4a0: 6465 5370 6563 286e 756d 5f6d 6f64 6573  deSpec(num_modes
+0000b4b0: 3d35 292c 0a20 2020 202e 2e2e 2020 2020  =5),.    ...    
+0000b4c0: 6e61 6d65 3d27 6d6f 6465 272c 0a20 2020  name='mode',.   
+0000b4d0: 202e 2e2e 2029 0a20 2020 203e 3e3e 2064   ... ).    >>> d
+0000b4e0: 6174 6120 3d20 4d6f 6465 4461 7461 286d  ata = ModeData(m
+0000b4f0: 6f6e 6974 6f72 3d6d 6f6e 6974 6f72 2c20  onitor=monitor, 
+0000b500: 616d 7073 3d61 6d70 5f64 6174 612c 206e  amps=amp_data, n
+0000b510: 5f63 6f6d 706c 6578 3d69 6e64 6578 5f64  _complex=index_d
+0000b520: 6174 6129 0a20 2020 2022 2222 0a0a 2020  ata).    """..  
+0000b530: 2020 6d6f 6e69 746f 723a 204d 6f64 654d    monitor: ModeM
+0000b540: 6f6e 6974 6f72 203d 2070 642e 4669 656c  onitor = pd.Fiel
+0000b550: 6428 0a20 2020 2020 2020 202e 2e2e 2c20  d(.        ..., 
+0000b560: 7469 746c 653d 224d 6f6e 6974 6f72 222c  title="Monitor",
+0000b570: 2064 6573 6372 6970 7469 6f6e 3d22 4d6f   description="Mo
+0000b580: 6465 206d 6f6e 6974 6f72 2061 7373 6f63  de monitor assoc
+0000b590: 6961 7465 6420 7769 7468 2074 6865 2064  iated with the d
+0000b5a0: 6174 612e 220a 2020 2020 290a 0a20 2020  ata.".    )..   
+0000b5b0: 2061 6d70 733a 204d 6f64 6541 6d70 7344   amps: ModeAmpsD
+0000b5c0: 6174 6141 7272 6179 203d 2070 642e 4669  ataArray = pd.Fi
+0000b5d0: 656c 6428 0a20 2020 2020 2020 202e 2e2e  eld(.        ...
+0000b5e0: 2c20 7469 746c 653d 2241 6d70 6c69 7475  , title="Amplitu
+0000b5f0: 6465 7322 2c20 6465 7363 7269 7074 696f  des", descriptio
+0000b600: 6e3d 2243 6f6d 706c 6578 2d76 616c 7565  n="Complex-value
+0000b610: 6420 616d 706c 6974 7564 6573 2061 7373  d amplitudes ass
+0000b620: 6f63 6961 7465 6420 7769 7468 2074 6865  ociated with the
+0000b630: 206d 6f64 652e 220a 2020 2020 290a 0a20   mode.".    ).. 
+0000b640: 2020 2065 7073 5f73 7065 633a 204c 6973     eps_spec: Lis
+0000b650: 745b 4570 7353 7065 6354 7970 655d 203d  t[EpsSpecType] =
+0000b660: 2070 642e 4669 656c 6428 0a20 2020 2020   pd.Field(.     
+0000b670: 2020 204e 6f6e 652c 0a20 2020 2020 2020     None,.       
+0000b680: 2074 6974 6c65 3d22 5065 726d 6574 7469   title="Permetti
+0000b690: 7669 7479 2053 7065 6369 6669 6361 7469  vity Specificati
+0000b6a0: 6f6e 222c 0a20 2020 2020 2020 2064 6573  on",.        des
+0000b6b0: 6372 6970 7469 6f6e 3d22 4368 6172 6163  cription="Charac
+0000b6c0: 7465 7269 7a61 7469 6f6e 206f 6620 7468  terization of th
+0000b6d0: 6520 7065 726d 6974 7469 7669 7479 2070  e permittivity p
+0000b6e0: 726f 6669 6c65 206f 6e20 7468 6520 706c  rofile on the pl
+0000b6f0: 616e 6520 7768 6572 6520 6d6f 6465 7320  ane where modes 
+0000b700: 6172 6520 220a 2020 2020 2020 2020 2263  are ".        "c
+0000b710: 6f6d 7075 7465 642e 2050 6f73 7369 626c  omputed. Possibl
+0000b720: 6520 7661 6c75 6573 2061 7265 2027 6469  e values are 'di
+0000b730: 6167 6f6e 616c 272c 2027 7465 6e73 6f72  agonal', 'tensor
+0000b740: 6961 6c5f 7265 616c 272c 2027 7465 6e73  ial_real', 'tens
+0000b750: 6f72 6961 6c5f 636f 6d70 6c65 7827 2e22  orial_complex'."
+0000b760: 2c0a 2020 2020 290a 0a20 2020 2040 7064  ,.    )..    @pd
+0000b770: 2e76 616c 6964 6174 6f72 2822 6570 735f  .validator("eps_
+0000b780: 7370 6563 222c 2061 6c77 6179 733d 5472  spec", always=Tr
+0000b790: 7565 290a 2020 2020 4073 6b69 705f 6966  ue).    @skip_if
+0000b7a0: 5f66 6965 6c64 735f 6d69 7373 696e 6728  _fields_missing(
+0000b7b0: 5b22 6d6f 6e69 746f 7222 5d29 0a20 2020  ["monitor"]).   
+0000b7c0: 2064 6566 2065 7073 5f73 7065 635f 6d61   def eps_spec_ma
+0000b7d0: 7463 685f 6d6f 6465 5f73 7065 6328 636c  tch_mode_spec(cl
+0000b7e0: 732c 2076 616c 2c20 7661 6c75 6573 293a  s, val, values):
+0000b7f0: 0a20 2020 2020 2020 2022 2222 5261 6973  .        """Rais
+0000b800: 6520 7661 6c69 6461 7469 6f6e 2065 7272  e validation err
+0000b810: 6f72 2069 6620 6672 6571 7565 6e63 6965  or if frequencie
+0000b820: 7320 696e 2065 7073 5f73 7065 6320 646f  s in eps_spec do
+0000b830: 6573 206e 6f74 206d 6174 6368 2066 7265  es not match fre
+0000b840: 7175 656e 6379 206c 6973 7422 2222 0a20  quency list""". 
+0000b850: 2020 2020 2020 2069 6620 7661 6c3a 0a20         if val:. 
+0000b860: 2020 2020 2020 2020 2020 206d 6f64 655f             mode_
+0000b870: 6461 7461 5f66 7265 7173 203d 2076 616c  data_freqs = val
+0000b880: 7565 735b 226d 6f6e 6974 6f72 225d 2e66  ues["monitor"].f
+0000b890: 7265 7173 0a20 2020 2020 2020 2020 2020  reqs.           
+0000b8a0: 2069 6620 6c65 6e28 7661 6c29 2021 3d20   if len(val) != 
+0000b8b0: 6c65 6e28 6d6f 6465 5f64 6174 615f 6672  len(mode_data_fr
+0000b8c0: 6571 7329 3a0a 2020 2020 2020 2020 2020  eqs):.          
+0000b8d0: 2020 2020 2020 7261 6973 6520 5661 6c69        raise Vali
+0000b8e0: 6461 7469 6f6e 4572 726f 7228 0a20 2020  dationError(.   
+0000b8f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b900: 2022 6570 735f 7370 6563 206d 7573 7420   "eps_spec must 
+0000b910: 6265 2070 726f 7669 6465 6420 6174 2074  be provided at t
+0000b920: 6865 2073 616d 6520 6672 6571 7565 6e63  he same frequenc
+0000b930: 6965 7320 6173 206d 6f64 6520 736f 6c76  ies as mode solv
+0000b940: 6572 2064 6174 612e 220a 2020 2020 2020  er data.".      
+0000b950: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+0000b960: 2020 2020 7265 7475 726e 2076 616c 0a0a      return val..
+0000b970: 2020 2020 6465 6620 6e6f 726d 616c 697a      def normaliz
+0000b980: 6528 7365 6c66 2c20 736f 7572 6365 5f73  e(self, source_s
+0000b990: 7065 6374 7275 6d5f 666e 2920 2d3e 204d  pectrum_fn) -> M
+0000b9a0: 6f64 6544 6174 613a 0a20 2020 2020 2020  odeData:.       
+0000b9b0: 2022 2222 5265 7475 726e 2063 6f70 7920   """Return copy 
+0000b9c0: 6f66 2073 656c 6620 6166 7465 7220 6e6f  of self after no
+0000b9d0: 726d 616c 697a 6174 696f 6e20 6973 2061  rmalization is a
+0000b9e0: 7070 6c69 6564 2075 7369 6e67 2073 6f75  pplied using sou
+0000b9f0: 7263 6520 7370 6563 7472 756d 2066 756e  rce spectrum fun
+0000ba00: 6374 696f 6e2e 2222 220a 2020 2020 2020  ction.""".      
+0000ba10: 2020 736f 7572 6365 5f66 7265 715f 616d    source_freq_am
+0000ba20: 7073 203d 2073 6f75 7263 655f 7370 6563  ps = source_spec
+0000ba30: 7472 756d 5f66 6e28 7365 6c66 2e61 6d70  trum_fn(self.amp
+0000ba40: 732e 6629 5b4e 6f6e 652c 203a 2c20 4e6f  s.f)[None, :, No
+0000ba50: 6e65 5d0a 2020 2020 2020 2020 6e65 775f  ne].        new_
+0000ba60: 616d 7073 203d 2028 7365 6c66 2e61 6d70  amps = (self.amp
+0000ba70: 7320 2f20 736f 7572 6365 5f66 7265 715f  s / source_freq_
+0000ba80: 616d 7073 292e 6173 7479 7065 2873 656c  amps).astype(sel
+0000ba90: 662e 616d 7073 2e64 7479 7065 290a 2020  f.amps.dtype).  
+0000baa0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+0000bab0: 662e 636f 7079 2875 7064 6174 653d 6469  f.copy(update=di
+0000bac0: 6374 2861 6d70 733d 6e65 775f 616d 7073  ct(amps=new_amps
+0000bad0: 2929 0a0a 2020 2020 6465 6620 6f76 6572  ))..    def over
+0000bae0: 6c61 705f 736f 7274 280a 2020 2020 2020  lap_sort(.      
+0000baf0: 2020 7365 6c66 2c0a 2020 2020 2020 2020    self,.        
+0000bb00: 7472 6163 6b5f 6672 6571 3a20 5472 6163  track_freq: Trac
+0000bb10: 6b46 7265 712c 0a20 2020 2020 2020 206f  kFreq,.        o
+0000bb20: 7665 726c 6170 5f74 6872 6573 683a 2066  verlap_thresh: f
+0000bb30: 6c6f 6174 203d 2030 2e39 2c0a 2020 2020  loat = 0.9,.    
+0000bb40: 2920 2d3e 204d 6f64 6544 6174 613a 0a20  ) -> ModeData:. 
+0000bb50: 2020 2020 2020 2022 2222 5374 6172 7469         """Starti
+0000bb60: 6e67 2066 726f 6d20 7468 6520 6261 7365  ng from the base
+0000bb70: 2066 7265 7175 656e 6379 2064 6566 696e   frequency defin
+0000bb80: 6564 2062 7920 7061 7261 6d65 7465 7220  ed by parameter 
+0000bb90: 6060 7472 6163 6b5f 6672 6571 6060 2c20  ``track_freq``, 
+0000bba0: 736f 7274 206d 6f64 6573 2061 7420 6561  sort modes at ea
+0000bbb0: 6368 0a20 2020 2020 2020 2066 7265 7175  ch.        frequ
+0000bbc0: 656e 6379 2061 6363 6f72 6469 6e67 2074  ency according t
+0000bbd0: 6f20 7468 6569 7220 6f76 6572 6c61 7020  o their overlap 
+0000bbe0: 7661 6c75 6573 2077 6974 6820 7468 6520  values with the 
+0000bbf0: 6d6f 6465 7320 6174 2074 6865 2070 7265  modes at the pre
+0000bc00: 7669 6f75 7320 6672 6571 7565 6e63 792e  vious frequency.
+0000bc10: 0a20 2020 2020 2020 2054 6861 7420 6973  .        That is
+0000bc20: 2c20 6974 2061 7474 656d 7074 7320 746f  , it attempts to
+0000bc30: 2072 6561 7272 616e 6765 206d 6f64 6573   rearrange modes
+0000bc40: 2069 6e20 7375 6368 2061 2077 6179 2074   in such a way t
+0000bc50: 6861 7420 6120 6769 7665 6e20 6060 6d6f  hat a given ``mo
+0000bc60: 6465 5f69 6e64 6578 6060 0a20 2020 2020  de_index``.     
+0000bc70: 2020 2063 6f72 7265 7370 6f6e 6473 2074     corresponds t
+0000bc80: 6f20 7068 7973 6963 616c 6c79 2074 6865  o physically the
+0000bc90: 2073 616d 6520 6d6f 6465 2061 7420 616c   same mode at al
+0000bca0: 6c20 6672 6571 7565 6e63 6965 732e 204d  l frequencies. M
+0000bcb0: 6f64 6573 2077 6974 6820 6f76 6572 6c61  odes with overla
+0000bcc0: 7020 7661 6c75 6573 206f 7665 720a 2020  p values over.  
+0000bcd0: 2020 2020 2020 6060 6f76 6572 6c61 705f        ``overlap_
+0000bce0: 7472 6573 6860 6020 6172 6520 636f 6e73  tresh`` are cons
+0000bcf0: 6964 6572 6564 206d 6174 6368 696e 6720  idered matching 
+0000bd00: 616e 6420 6e6f 7420 7265 6172 7261 6e67  and not rearrang
+0000bd10: 6564 2e0a 0a20 2020 2020 2020 2050 6172  ed...        Par
+0000bd20: 616d 6574 6572 730a 2020 2020 2020 2020  ameters.        
+0000bd30: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2020  ----------.     
+0000bd40: 2020 2074 7261 636b 5f66 7265 7120 3a20     track_freq : 
+0000bd50: 4c69 7465 7261 6c5b 2263 656e 7472 616c  Literal["central
+0000bd60: 222c 2022 6c6f 7765 7374 222c 2022 6869  ", "lowest", "hi
+0000bd70: 6768 6573 7422 5d0a 2020 2020 2020 2020  ghest"].        
+0000bd80: 2020 2020 5061 7261 6d65 7465 7220 7468      Parameter th
+0000bd90: 6174 2073 7065 6369 6669 6573 2077 6869  at specifies whi
+0000bda0: 6368 2066 7265 7175 656e 6379 2077 696c  ch frequency wil
+0000bdb0: 6c20 7365 7276 6520 6173 2061 2073 7461  l serve as a sta
+0000bdc0: 7274 696e 6720 706f 696e 7420 696e 0a20  rting point in. 
+0000bdd0: 2020 2020 2020 2020 2020 2074 6865 2072             the r
+0000bde0: 656f 7264 6572 696e 6720 7072 6f63 6573  eordering proces
+0000bdf0: 732e 0a20 2020 2020 2020 206f 7665 726c  s..        overl
+0000be00: 6170 5f74 6872 6573 6820 3a20 666c 6f61  ap_thresh : floa
+0000be10: 7420 3d20 302e 390a 2020 2020 2020 2020  t = 0.9.        
+0000be20: 2020 2020 4d6f 6461 6c20 6f76 6572 6c61      Modal overla
+0000be30: 7020 7468 7265 7368 6f6c 6420 6162 6f76  p threshold abov
+0000be40: 6520 7768 6963 6820 7477 6f20 6d6f 6465  e which two mode
+0000be50: 7320 6172 6520 636f 6e73 6964 6572 6564  s are considered
+0000be60: 2074 6f20 6265 2074 6865 2073 616d 6520   to be the same 
+0000be70: 616e 6420 6172 6520 6e6f 740a 2020 2020  and are not.    
+0000be80: 2020 2020 2020 2020 7265 6172 7261 6e67          rearrang
+0000be90: 6564 2e20 4966 2061 6674 6572 2074 6865  ed. If after the
+0000bea0: 2073 6f72 7469 6e67 2070 726f 6365 6475   sorting procedu
+0000beb0: 7265 2074 6865 206f 7665 726c 6170 2076  re the overlap v
+0000bec0: 616c 7565 2062 6574 7765 656e 2074 776f  alue between two
+0000bed0: 2063 6f72 7265 7370 6f6e 6469 6e67 0a20   corresponding. 
+0000bee0: 2020 2020 2020 2020 2020 206d 6f64 6573             modes
+0000bef0: 2069 7320 6c65 7373 2074 6861 6e20 7468   is less than th
+0000bf00: 6973 2074 6872 6573 686f 6c64 2c20 6120  is threshold, a 
+0000bf10: 7761 726e 696e 6720 6162 6f75 7420 6120  warning about a 
+0000bf20: 706f 7373 6962 6c65 2064 6973 636f 6e74  possible discont
+0000bf30: 696e 7569 7479 2069 730a 2020 2020 2020  inuity is.      
+0000bf40: 2020 2020 2020 6469 7370 6c61 7965 642e        displayed.
+0000bf50: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+0000bf60: 2020 2020 2069 6620 6c65 6e28 7365 6c66       if len(self
+0000bf70: 2e66 6965 6c64 5f63 6f6d 706f 6e65 6e74  .field_component
+0000bf80: 7329 203d 3d20 303a 0a20 2020 2020 2020  s) == 0:.       
+0000bf90: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+0000bfa0: 2e63 6f70 7928 290a 2020 2020 2020 2020  .copy().        
+0000bfb0: 6e75 6d5f 6672 6571 7320 3d20 6c65 6e28  num_freqs = len(
+0000bfc0: 7365 6c66 2e6d 6f6e 6974 6f72 2e66 7265  self.monitor.fre
+0000bfd0: 7173 290a 2020 2020 2020 2020 6e75 6d5f  qs).        num_
+0000bfe0: 6d6f 6465 7320 3d20 7365 6c66 2e6d 6f6e  modes = self.mon
+0000bff0: 6974 6f72 2e6d 6f64 655f 7370 6563 2e6e  itor.mode_spec.n
+0000c000: 756d 5f6d 6f64 6573 0a0a 2020 2020 2020  um_modes..      
+0000c010: 2020 6966 2074 7261 636b 5f66 7265 7120    if track_freq 
+0000c020: 3d3d 2022 6c6f 7765 7374 223a 0a20 2020  == "lowest":.   
+0000c030: 2020 2020 2020 2020 2066 305f 696e 6420           f0_ind 
+0000c040: 3d20 300a 2020 2020 2020 2020 656c 6966  = 0.        elif
+0000c050: 2074 7261 636b 5f66 7265 7120 3d3d 2022   track_freq == "
+0000c060: 6869 6768 6573 7422 3a0a 2020 2020 2020  highest":.      
+0000c070: 2020 2020 2020 6630 5f69 6e64 203d 206e        f0_ind = n
+0000c080: 756d 5f66 7265 7173 202d 2031 0a20 2020  um_freqs - 1.   
+0000c090: 2020 2020 2065 6c69 6620 7472 6163 6b5f       elif track_
+0000c0a0: 6672 6571 203d 3d20 2263 656e 7472 616c  freq == "central
+0000c0b0: 223a 0a20 2020 2020 2020 2020 2020 2066  ":.            f
+0000c0c0: 305f 696e 6420 3d20 6e75 6d5f 6672 6571  0_ind = num_freq
+0000c0d0: 7320 2f2f 2032 0a0a 2020 2020 2020 2020  s // 2..        
+0000c0e0: 2320 436f 6d70 7574 6520 736f 7274 696e  # Compute sortin
+0000c0f0: 6720 6f72 6465 7220 616e 6420 6f76 6572  g order and over
+0000c100: 6c61 7073 2077 6974 6820 6e65 6967 6862  laps with neighb
+0000c110: 6f72 696e 6720 6672 6571 7565 6e63 6965  oring frequencie
+0000c120: 730a 2020 2020 2020 2020 736f 7274 696e  s.        sortin
+0000c130: 6720 3d20 2d6e 702e 6f6e 6573 2828 6e75  g = -np.ones((nu
+0000c140: 6d5f 6672 6571 732c 206e 756d 5f6d 6f64  m_freqs, num_mod
+0000c150: 6573 292c 2064 7479 7065 3d69 6e74 290a  es), dtype=int).
+0000c160: 2020 2020 2020 2020 6f76 6572 6c61 7020          overlap 
+0000c170: 3d20 6e70 2e7a 6572 6f73 2828 6e75 6d5f  = np.zeros((num_
+0000c180: 6672 6571 732c 206e 756d 5f6d 6f64 6573  freqs, num_modes
+0000c190: 2929 0a20 2020 2020 2020 2070 6861 7365  )).        phase
+0000c1a0: 203d 206e 702e 7a65 726f 7328 286e 756d   = np.zeros((num
+0000c1b0: 5f66 7265 7173 2c20 6e75 6d5f 6d6f 6465  _freqs, num_mode
+0000c1c0: 7329 290a 2020 2020 2020 2020 736f 7274  s)).        sort
+0000c1d0: 696e 675b 6630 5f69 6e64 2c20 3a5d 203d  ing[f0_ind, :] =
+0000c1e0: 206e 702e 6172 616e 6765 286e 756d 5f6d   np.arange(num_m
+0000c1f0: 6f64 6573 2920 2023 2062 6173 6520 6672  odes)  # base fr
+0000c200: 6571 7565 6e63 7920 776f 6e27 7420 6368  equency won't ch
+0000c210: 616e 6765 0a20 2020 2020 2020 206f 7665  ange.        ove
+0000c220: 726c 6170 5b66 305f 696e 642c 203a 5d20  rlap[f0_ind, :] 
+0000c230: 3d20 6e70 2e6f 6e65 7328 6e75 6d5f 6d6f  = np.ones(num_mo
+0000c240: 6465 7329 0a0a 2020 2020 2020 2020 2320  des)..        # 
+0000c250: 536f 7274 2069 6e20 7477 6f20 6469 7265  Sort in two dire
+0000c260: 6374 696f 6e73 2066 726f 6d20 7468 6520  ctions from the 
+0000c270: 6261 7365 2066 7265 7175 656e 6379 0a20  base frequency. 
+0000c280: 2020 2020 2020 2066 6f72 2073 7465 702c         for step,
+0000c290: 206c 6173 745f 696e 6420 696e 207a 6970   last_ind in zip
+0000c2a0: 285b 2d31 2c20 315d 2c20 5b2d 312c 206e  ([-1, 1], [-1, n
+0000c2b0: 756d 5f66 7265 7173 5d29 3a0a 2020 2020  um_freqs]):.    
+0000c2c0: 2020 2020 2020 2020 2320 5374 6172 7420          # Start 
+0000c2d0: 7769 7468 2074 6865 2062 6173 6520 6672  with the base fr
+0000c2e0: 6571 7565 6e63 790a 2020 2020 2020 2020  equency.        
+0000c2f0: 2020 2020 6461 7461 5f74 656d 706c 6174      data_templat
+0000c300: 6520 3d20 7365 6c66 2e5f 6973 656c 2866  e = self._isel(f
+0000c310: 3d5b 6630 5f69 6e64 5d29 0a0a 2020 2020  =[f0_ind])..    
+0000c320: 2020 2020 2020 2020 2320 4d61 7263 6820          # March 
+0000c330: 746f 206c 6f77 6572 2f68 6967 6865 7220  to lower/higher 
+0000c340: 6672 6571 7565 6e63 6965 730a 2020 2020  frequencies.    
+0000c350: 2020 2020 2020 2020 666f 7220 6672 6571          for freq
+0000c360: 5f69 6420 696e 2072 616e 6765 2866 305f  _id in range(f0_
+0000c370: 696e 6420 2b20 7374 6570 2c20 6c61 7374  ind + step, last
+0000c380: 5f69 6e64 2c20 7374 6570 293a 0a20 2020  _ind, step):.   
+0000c390: 2020 2020 2020 2020 2020 2020 2023 2047               # G
+0000c3a0: 6574 206e 6578 7420 6672 6571 7565 6e63  et next frequenc
+0000c3b0: 7920 746f 2073 6f72 740a 2020 2020 2020  y to sort.      
+0000c3c0: 2020 2020 2020 2020 2020 6461 7461 5f74            data_t
+0000c3d0: 6f5f 736f 7274 203d 2073 656c 662e 5f69  o_sort = self._i
+0000c3e0: 7365 6c28 663d 5b66 7265 715f 6964 5d29  sel(f=[freq_id])
+0000c3f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c400: 2023 2041 7373 6967 6e20 746f 2074 6865   # Assign to the
+0000c410: 2062 6173 6520 6672 6571 7565 6e63 7920   base frequency 
+0000c420: 736f 2074 6861 7420 6f75 7465 725f 646f  so that outer_do
+0000c430: 7420 7769 6c6c 2063 6f6d 7061 7265 2074  t will compare t
+0000c440: 6865 6d0a 2020 2020 2020 2020 2020 2020  hem.            
+0000c450: 2020 2020 6461 7461 5f74 6f5f 736f 7274      data_to_sort
+0000c460: 203d 2064 6174 615f 746f 5f73 6f72 742e   = data_to_sort.
+0000c470: 5f61 7373 6967 6e5f 636f 6f72 6473 2866  _assign_coords(f
+0000c480: 3d5b 7365 6c66 2e6d 6f6e 6974 6f72 2e66  =[self.monitor.f
+0000c490: 7265 7173 5b66 305f 696e 645d 5d29 0a0a  reqs[f0_ind]])..
+0000c4a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c4b0: 2320 436f 6d70 7574 6520 2273 6f72 7469  # Compute "sorti
+0000c4c0: 6e67 2077 2e72 2e74 2e20 746f 206e 6569  ng w.r.t. to nei
+0000c4d0: 6768 626f 7222 2061 6e64 206f 7665 726c  ghbor" and overl
+0000c4e0: 6170 2076 616c 7565 730a 0a20 2020 2020  ap values..     
+0000c4f0: 2020 2020 2020 2020 2020 2073 6f72 7469             sorti
+0000c500: 6e67 5f6f 6e65 5f6d 6f64 652c 2061 6d70  ng_one_mode, amp
+0000c510: 735f 6f6e 655f 6d6f 6465 203d 2064 6174  s_one_mode = dat
+0000c520: 615f 7465 6d70 6c61 7465 2e5f 6669 6e64  a_template._find
+0000c530: 5f6f 7264 6572 696e 675f 6f6e 655f 6672  _ordering_one_fr
+0000c540: 6571 280a 2020 2020 2020 2020 2020 2020  eq(.            
+0000c550: 2020 2020 2020 2020 6461 7461 5f74 6f5f          data_to_
+0000c560: 736f 7274 2c20 6f76 6572 6c61 705f 7468  sort, overlap_th
+0000c570: 7265 7368 0a20 2020 2020 2020 2020 2020  resh.           
+0000c580: 2020 2020 2029 0a0a 2020 2020 2020 2020       )..        
+0000c590: 2020 2020 2020 2020 2320 5472 616e 7366          # Transf
+0000c5a0: 6f72 6d20 2273 6f72 7469 6e67 2077 2e72  orm "sorting w.r
+0000c5b0: 2e74 2e20 6e65 6967 6862 6f72 2220 746f  .t. neighbor" to
+0000c5c0: 2022 736f 7274 696e 6720 772e 722e 742e   "sorting w.r.t.
+0000c5d0: 2074 6f20 6630 5f69 6e64 220a 2020 2020   to f0_ind".    
+0000c5e0: 2020 2020 2020 2020 2020 2020 736f 7274              sort
+0000c5f0: 696e 675b 6672 6571 5f69 642c 203a 5d20  ing[freq_id, :] 
+0000c600: 3d20 736f 7274 696e 675f 6f6e 655f 6d6f  = sorting_one_mo
+0000c610: 6465 5b73 6f72 7469 6e67 5b66 7265 715f  de[sorting[freq_
+0000c620: 6964 202d 2073 7465 702c 203a 5d5d 0a20  id - step, :]]. 
+0000c630: 2020 2020 2020 2020 2020 2020 2020 206f                 o
+0000c640: 7665 726c 6170 5b66 7265 715f 6964 2c20  verlap[freq_id, 
+0000c650: 3a5d 203d 206e 702e 6162 7328 616d 7073  :] = np.abs(amps
+0000c660: 5f6f 6e65 5f6d 6f64 655b 736f 7274 696e  _one_mode[sortin
+0000c670: 675b 6672 6571 5f69 6420 2d20 7374 6570  g[freq_id - step
+0000c680: 2c20 3a5d 5d29 0a20 2020 2020 2020 2020  , :]]).         
+0000c690: 2020 2020 2020 2070 6861 7365 5b66 7265         phase[fre
+0000c6a0: 715f 6964 2c20 3a5d 203d 2070 6861 7365  q_id, :] = phase
+0000c6b0: 5b66 7265 715f 6964 202d 2073 7465 702c  [freq_id - step,
+0000c6c0: 203a 5d20 2b20 6e70 2e61 6e67 6c65 280a   :] + np.angle(.
 0000c6d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c6e0: 616d 7073 5f6f 6e65 5f6d 6f64 655b 736f  amps_one_mode[so
-0000c6f0: 7274 696e 675b 6672 6571 5f69 6420 2d20  rting[freq_id - 
-0000c700: 7374 6570 2c20 3a5d 5d0a 2020 2020 2020  step, :]].      
-0000c710: 2020 2020 2020 2020 2020 290a 0a20 2020            )..   
-0000c720: 2020 2020 2020 2020 2020 2020 2023 2043               # C
-0000c730: 6865 636b 2066 6f72 2064 6973 636f 6e74  heck for discont
-0000c740: 696e 7569 7469 6573 2061 6e64 2073 686f  inuities and sho
-0000c750: 7720 7761 726e 696e 6720 6966 2061 6e79  w warning if any
-0000c760: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000c770: 2066 6f72 206d 6f64 655f 696e 6420 696e   for mode_ind in
-0000c780: 206c 6973 7428 6e70 2e6e 6f6e 7a65 726f   list(np.nonzero
-0000c790: 286f 7665 726c 6170 5b66 7265 715f 6964  (overlap[freq_id
-0000c7a0: 2c20 3a5d 203c 206f 7665 726c 6170 5f74  , :] < overlap_t
-0000c7b0: 6872 6573 6829 5b30 5d29 3a0a 2020 2020  hresh)[0]):.    
+0000c6e0: 2020 2020 616d 7073 5f6f 6e65 5f6d 6f64      amps_one_mod
+0000c6f0: 655b 736f 7274 696e 675b 6672 6571 5f69  e[sorting[freq_i
+0000c700: 6420 2d20 7374 6570 2c20 3a5d 5d0a 2020  d - step, :]].  
+0000c710: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+0000c720: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c730: 2023 2043 6865 636b 2066 6f72 2064 6973   # Check for dis
+0000c740: 636f 6e74 696e 7569 7469 6573 2061 6e64  continuities and
+0000c750: 2073 686f 7720 7761 726e 696e 6720 6966   show warning if
+0000c760: 2061 6e79 0a20 2020 2020 2020 2020 2020   any.           
+0000c770: 2020 2020 2066 6f72 206d 6f64 655f 696e       for mode_in
+0000c780: 6420 696e 206c 6973 7428 6e70 2e6e 6f6e  d in list(np.non
+0000c790: 7a65 726f 286f 7665 726c 6170 5b66 7265  zero(overlap[fre
+0000c7a0: 715f 6964 2c20 3a5d 203c 206f 7665 726c  q_id, :] < overl
+0000c7b0: 6170 5f74 6872 6573 6829 5b30 5d29 3a0a  ap_thresh)[0]):.
 0000c7c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c7d0: 6c6f 672e 7761 726e 696e 6728 0a20 2020  log.warning(.   
-0000c7e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c7f0: 2020 2020 2066 224d 6f64 6520 277b 6d6f       f"Mode '{mo
-0000c800: 6465 5f69 6e64 7d27 2061 7070 6561 7273  de_ind}' appears
-0000c810: 2074 6f20 756e 6465 7267 6f20 6120 6469   to undergo a di
-0000c820: 7363 6f6e 7469 6e75 6f75 7320 6368 616e  scontinuous chan
-0000c830: 6765 2022 0a20 2020 2020 2020 2020 2020  ge ".           
-0000c840: 2020 2020 2020 2020 2020 2020 2066 2262               f"b
-0000c850: 6574 7765 656e 2066 7265 7175 656e 6369  etween frequenci
-0000c860: 6573 2027 7b73 656c 662e 6d6f 6e69 746f  es '{self.monito
-0000c870: 722e 6672 6571 735b 6672 6571 5f69 645d  r.freqs[freq_id]
-0000c880: 7d27 2022 0a20 2020 2020 2020 2020 2020  }' ".           
-0000c890: 2020 2020 2020 2020 2020 2020 2066 2261               f"a
-0000c8a0: 6e64 2027 7b73 656c 662e 6d6f 6e69 746f  nd '{self.monito
-0000c8b0: 722e 6672 6571 735b 6672 6571 5f69 6420  r.freqs[freq_id 
-0000c8c0: 2d20 7374 6570 5d7d 2720 220a 2020 2020  - step]}' ".    
+0000c7d0: 2020 2020 6c6f 672e 7761 726e 696e 6728      log.warning(
+0000c7e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c7f0: 2020 2020 2020 2020 2066 224d 6f64 6520           f"Mode 
+0000c800: 277b 6d6f 6465 5f69 6e64 7d27 2061 7070  '{mode_ind}' app
+0000c810: 6561 7273 2074 6f20 756e 6465 7267 6f20  ears to undergo 
+0000c820: 6120 6469 7363 6f6e 7469 6e75 6f75 7320  a discontinuous 
+0000c830: 6368 616e 6765 2022 0a20 2020 2020 2020  change ".       
+0000c840: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c850: 2066 2262 6574 7765 656e 2066 7265 7175   f"between frequ
+0000c860: 656e 6369 6573 2027 7b73 656c 662e 6d6f  encies '{self.mo
+0000c870: 6e69 746f 722e 6672 6571 735b 6672 6571  nitor.freqs[freq
+0000c880: 5f69 645d 7d27 2022 0a20 2020 2020 2020  _id]}' ".       
+0000c890: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c8a0: 2066 2261 6e64 2027 7b73 656c 662e 6d6f   f"and '{self.mo
+0000c8b0: 6e69 746f 722e 6672 6571 735b 6672 6571  nitor.freqs[freq
+0000c8c0: 5f69 6420 2d20 7374 6570 5d7d 2720 220a  _id - step]}' ".
 0000c8d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c8e0: 2020 2020 6622 286f 7665 726c 6170 3a20      f"(overlap: 
-0000c8f0: 277b 6f76 6572 6c61 705b 6672 6571 5f69  '{overlap[freq_i
-0000c900: 642c 206d 6f64 655f 696e 645d 3a2e 3266  d, mode_ind]:.2f
-0000c910: 7d27 292e 220a 2020 2020 2020 2020 2020  }').".          
-0000c920: 2020 2020 2020 2020 2020 290a 0a20 2020            )..   
-0000c930: 2020 2020 2020 2020 2020 2020 2023 2052               # R
-0000c940: 6561 7373 6967 6e20 666f 7220 7468 6520  eassign for the 
-0000c950: 6e65 7874 2069 7465 7261 7469 6f6e 0a20  next iteration. 
-0000c960: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-0000c970: 6174 615f 7465 6d70 6c61 7465 203d 2064  ata_template = d
-0000c980: 6174 615f 746f 5f73 6f72 740a 0a20 2020  ata_to_sort..   
-0000c990: 2020 2020 2023 2052 6561 7272 616e 6765       # Rearrange
-0000c9a0: 206d 6f64 6573 2075 7369 6e67 2063 6f6d   modes using com
-0000c9b0: 7075 7465 6420 736f 7274 696e 6720 7661  puted sorting va
-0000c9c0: 6c75 6573 0a20 2020 2020 2020 206d 6f64  lues.        mod
-0000c9d0: 655f 6461 7461 5f73 6f72 7465 6420 3d20  e_data_sorted = 
-0000c9e0: 7365 6c66 2e5f 7265 6f72 6465 725f 6d6f  self._reorder_mo
-0000c9f0: 6465 7328 0a20 2020 2020 2020 2020 2020  des(.           
-0000ca00: 2073 6f72 7469 6e67 3d73 6f72 7469 6e67   sorting=sorting
-0000ca10: 2c0a 2020 2020 2020 2020 2020 2020 7068  ,.            ph
-0000ca20: 6173 653d 7068 6173 652c 0a20 2020 2020  ase=phase,.     
-0000ca30: 2020 2020 2020 2074 7261 636b 5f66 7265         track_fre
-0000ca40: 713d 7472 6163 6b5f 6672 6571 2c0a 2020  q=track_freq,.  
-0000ca50: 2020 2020 2020 290a 0a20 2020 2020 2020        )..       
-0000ca60: 2072 6574 7572 6e20 6d6f 6465 5f64 6174   return mode_dat
-0000ca70: 615f 736f 7274 6564 0a0a 2020 2020 6465  a_sorted..    de
-0000ca80: 6620 5f69 7365 6c28 7365 6c66 2c20 2a2a  f _isel(self, **
-0000ca90: 6973 656c 5f6b 7761 7267 7329 3a0a 2020  isel_kwargs):.  
-0000caa0: 2020 2020 2020 2222 2257 7261 7073 2060        """Wraps `
-0000cab0: 6078 6172 7261 792e 4461 7461 4172 7261  `xarray.DataArra
-0000cac0: 792e 6973 656c 6060 2066 6f72 2061 6c6c  y.isel`` for all
-0000cad0: 2064 6174 6120 6669 656c 6473 2074 6861   data fields tha
-0000cae0: 7420 6172 6520 6465 6669 6e65 6420 6f76  t are defined ov
-0000caf0: 6572 2066 7265 7175 656e 6379 2061 6e64  er frequency and
-0000cb00: 0a20 2020 2020 2020 206d 6f64 6520 696e  .        mode in
-0000cb10: 6465 782e 2055 7365 6420 696e 2060 606f  dex. Used in ``o
-0000cb20: 7665 726c 6170 5f73 6f72 7460 6020 6275  verlap_sort`` bu
-0000cb30: 7420 6e6f 7420 6f66 6669 6369 616c 6c79  t not officially
-0000cb40: 2073 7570 706f 7274 6564 2073 696e 6365   supported since
-0000cb50: 2066 6f72 2065 7861 6d70 6c65 0a20 2020   for example.   
-0000cb60: 2020 2020 2060 6073 656c 662e 6d6f 6e69       ``self.moni
-0000cb70: 746f 722e 6d6f 6465 5f73 7065 6360 6020  tor.mode_spec`` 
-0000cb80: 616e 6420 6060 7365 6c66 2e6d 6f6e 6974  and ``self.monit
-0000cb90: 6f72 2e66 7265 7173 6060 2077 696c 6c20  or.freqs`` will 
-0000cba0: 6e6f 206c 6f6e 6765 7220 6265 206d 6174  no longer be mat
-0000cbb0: 6368 696e 6720 7468 650a 2020 2020 2020  ching the.      
-0000cbc0: 2020 6e65 776c 7920 6372 6561 7465 6420    newly created 
-0000cbd0: 6461 7461 2e22 2222 0a0a 2020 2020 2020  data."""..      
-0000cbe0: 2020 7570 6461 7465 5f64 6963 7420 3d20    update_dict = 
-0000cbf0: 6469 6374 2873 656c 662e 5f67 7269 645f  dict(self._grid_
-0000cc00: 636f 7272 6563 7469 6f6e 5f64 6963 742c  correction_dict,
-0000cc10: 202a 2a73 656c 662e 6669 656c 645f 636f   **self.field_co
-0000cc20: 6d70 6f6e 656e 7473 290a 2020 2020 2020  mponents).      
-0000cc30: 2020 7570 6461 7465 5f64 6963 7420 3d20    update_dict = 
-0000cc40: 7b6b 6579 3a20 6669 656c 642e 6973 656c  {key: field.isel
-0000cc50: 282a 2a69 7365 6c5f 6b77 6172 6773 2920  (**isel_kwargs) 
-0000cc60: 666f 7220 6b65 792c 2066 6965 6c64 2069  for key, field i
-0000cc70: 6e20 7570 6461 7465 5f64 6963 742e 6974  n update_dict.it
-0000cc80: 656d 7328 297d 0a20 2020 2020 2020 2072  ems()}.        r
-0000cc90: 6574 7572 6e20 7365 6c66 2e5f 7570 6461  eturn self._upda
-0000cca0: 7465 6428 7570 6461 7465 3d75 7064 6174  ted(update=updat
-0000ccb0: 655f 6469 6374 290a 0a20 2020 2064 6566  e_dict)..    def
-0000ccc0: 205f 6173 7369 676e 5f63 6f6f 7264 7328   _assign_coords(
-0000ccd0: 7365 6c66 2c20 2a2a 6173 7369 676e 5f63  self, **assign_c
-0000cce0: 6f6f 7264 735f 6b77 6172 6773 293a 0a20  oords_kwargs):. 
-0000ccf0: 2020 2020 2020 2022 2222 5772 6170 7320         """Wraps 
-0000cd00: 6060 7861 7272 6179 2e44 6174 6141 7272  ``xarray.DataArr
-0000cd10: 6179 2e61 7373 6967 6e5f 636f 6f72 6473  ay.assign_coords
-0000cd20: 6060 2066 6f72 2061 6c6c 2064 6174 6120  `` for all data 
-0000cd30: 6669 656c 6473 2074 6861 7420 6172 6520  fields that are 
-0000cd40: 6465 6669 6e65 6420 6f76 6572 2066 7265  defined over fre
-0000cd50: 7175 656e 6379 2061 6e64 0a20 2020 2020  quency and.     
-0000cd60: 2020 206d 6f64 6520 696e 6465 782e 2055     mode index. U
-0000cd70: 7365 6420 696e 2060 606f 7665 726c 6170  sed in ``overlap
-0000cd80: 5f73 6f72 7460 6020 6275 7420 6e6f 7420  _sort`` but not 
-0000cd90: 6f66 6669 6369 616c 6c79 2073 7570 706f  officially suppo
-0000cda0: 7274 6564 2073 696e 6365 2066 6f72 2065  rted since for e
-0000cdb0: 7861 6d70 6c65 0a20 2020 2020 2020 2060  xample.        `
-0000cdc0: 6073 656c 662e 6d6f 6e69 746f 722e 6d6f  `self.monitor.mo
-0000cdd0: 6465 5f73 7065 6360 6020 616e 6420 6060  de_spec`` and ``
-0000cde0: 7365 6c66 2e6d 6f6e 6974 6f72 2e66 7265  self.monitor.fre
-0000cdf0: 7173 6060 2077 696c 6c20 6e6f 206c 6f6e  qs`` will no lon
-0000ce00: 6765 7220 6265 206d 6174 6368 696e 6720  ger be matching 
-0000ce10: 7468 650a 2020 2020 2020 2020 6e65 776c  the.        newl
-0000ce20: 7920 6372 6561 7465 6420 6461 7461 2e22  y created data."
-0000ce30: 2222 0a0a 2020 2020 2020 2020 7570 6461  ""..        upda
-0000ce40: 7465 5f64 6963 7420 3d20 6469 6374 2873  te_dict = dict(s
-0000ce50: 656c 662e 5f67 7269 645f 636f 7272 6563  elf._grid_correc
-0000ce60: 7469 6f6e 5f64 6963 742c 202a 2a73 656c  tion_dict, **sel
-0000ce70: 662e 6669 656c 645f 636f 6d70 6f6e 656e  f.field_componen
-0000ce80: 7473 290a 2020 2020 2020 2020 7570 6461  ts).        upda
-0000ce90: 7465 5f64 6963 7420 3d20 7b0a 2020 2020  te_dict = {.    
-0000cea0: 2020 2020 2020 2020 6b65 793a 2066 6965          key: fie
-0000ceb0: 6c64 2e61 7373 6967 6e5f 636f 6f72 6473  ld.assign_coords
-0000cec0: 282a 2a61 7373 6967 6e5f 636f 6f72 6473  (**assign_coords
-0000ced0: 5f6b 7761 7267 7329 2066 6f72 206b 6579  _kwargs) for key
-0000cee0: 2c20 6669 656c 6420 696e 2075 7064 6174  , field in updat
-0000cef0: 655f 6469 6374 2e69 7465 6d73 2829 0a20  e_dict.items(). 
-0000cf00: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
-0000cf10: 2072 6574 7572 6e20 7365 6c66 2e5f 7570   return self._up
-0000cf20: 6461 7465 6428 7570 6461 7465 3d75 7064  dated(update=upd
-0000cf30: 6174 655f 6469 6374 290a 0a20 2020 2064  ate_dict)..    d
-0000cf40: 6566 205f 6669 6e64 5f6f 7264 6572 696e  ef _find_orderin
-0000cf50: 675f 6f6e 655f 6672 6571 280a 2020 2020  g_one_freq(.    
-0000cf60: 2020 2020 7365 6c66 2c0a 2020 2020 2020      self,.      
-0000cf70: 2020 6461 7461 5f74 6f5f 736f 7274 3a20    data_to_sort: 
-0000cf80: 4d6f 6465 4461 7461 2c0a 2020 2020 2020  ModeData,.      
-0000cf90: 2020 6f76 6572 6c61 705f 7468 7265 7368    overlap_thresh
-0000cfa0: 3a20 666c 6f61 742c 0a20 2020 2029 202d  : float,.    ) -
-0000cfb0: 3e20 5475 706c 655b 4e75 6d70 792c 204e  > Tuple[Numpy, N
-0000cfc0: 756d 7079 5d3a 0a20 2020 2020 2020 2022  umpy]:.        "
-0000cfd0: 2222 4669 6e64 206e 6577 206f 7264 6572  ""Find new order
-0000cfe0: 696e 6720 6f66 206d 6f64 6573 2069 6e20  ing of modes in 
-0000cff0: 6461 7461 5f74 6f5f 736f 7274 2062 6173  data_to_sort bas
-0000d000: 6564 206f 6e20 7468 6569 7220 7369 6d69  ed on their simi
-0000d010: 6c61 7269 7479 2074 6f20 6f77 6e20 6d6f  larity to own mo
-0000d020: 6465 732e 2222 220a 0a20 2020 2020 2020  des."""..       
-0000d030: 206e 756d 5f6d 6f64 6573 203d 2073 656c   num_modes = sel
-0000d040: 662e 6e5f 636f 6d70 6c65 782e 7369 7a65  f.n_complex.size
-0000d050: 735b 226d 6f64 655f 696e 6465 7822 5d0a  s["mode_index"].
-0000d060: 0a20 2020 2020 2020 2023 2043 7572 7265  .        # Curre
-0000d070: 6e74 2070 6169 7273 2061 6e64 2074 6865  nt pairs and the
-0000d080: 6972 206f 7665 726c 6170 730a 2020 2020  ir overlaps.    
-0000d090: 2020 2020 7061 6972 7320 3d20 6e70 2e61      pairs = np.a
-0000d0a0: 7261 6e67 6528 6e75 6d5f 6d6f 6465 7329  range(num_modes)
-0000d0b0: 0a20 2020 2020 2020 2063 6f6d 706c 6578  .        complex
-0000d0c0: 5f61 6d70 7320 3d20 7365 6c66 2e64 6f74  _amps = self.dot
-0000d0d0: 2864 6174 615f 746f 5f73 6f72 7429 2e64  (data_to_sort).d
-0000d0e0: 6174 612e 7261 7665 6c28 290a 2020 2020  ata.ravel().    
-0000d0f0: 2020 2020 6966 2073 656c 662e 6d6f 6e69      if self.moni
-0000d100: 746f 722e 7374 6f72 655f 6669 656c 6473  tor.store_fields
-0000d110: 5f64 6972 6563 7469 6f6e 203d 3d20 222d  _direction == "-
-0000d120: 223a 0a20 2020 2020 2020 2020 2020 2063  ":.            c
-0000d130: 6f6d 706c 6578 5f61 6d70 7320 2a3d 202d  omplex_amps *= -
-0000d140: 310a 0a20 2020 2020 2020 2023 2043 6865  1..        # Che
-0000d150: 636b 2077 6865 7468 6572 206d 6f64 6573  ck whether modes
-0000d160: 2061 6c72 6561 6479 206d 6174 6368 0a20   already match. 
-0000d170: 2020 2020 2020 206d 6f64 6573 5f74 6f5f         modes_to_
-0000d180: 736f 7274 203d 206e 702e 7768 6572 6528  sort = np.where(
-0000d190: 6e70 2e61 6273 2863 6f6d 706c 6578 5f61  np.abs(complex_a
-0000d1a0: 6d70 7329 203c 206f 7665 726c 6170 5f74  mps) < overlap_t
-0000d1b0: 6872 6573 6829 5b30 5d0a 2020 2020 2020  hresh)[0].      
-0000d1c0: 2020 6e75 6d5f 6d6f 6465 735f 746f 5f73    num_modes_to_s
-0000d1d0: 6f72 7420 3d20 6c65 6e28 6d6f 6465 735f  ort = len(modes_
-0000d1e0: 746f 5f73 6f72 7429 0a20 2020 2020 2020  to_sort).       
-0000d1f0: 2069 6620 6e75 6d5f 6d6f 6465 735f 746f   if num_modes_to
-0000d200: 5f73 6f72 7420 3c3d 2031 3a0a 2020 2020  _sort <= 1:.    
-0000d210: 2020 2020 2020 2020 7265 7475 726e 2070          return p
-0000d220: 6169 7273 2c20 636f 6d70 6c65 785f 616d  airs, complex_am
-0000d230: 7073 0a0a 2020 2020 2020 2020 2320 4578  ps..        # Ex
-0000d240: 7472 6163 7420 616c 6c20 6d6f 6465 7320  tract all modes 
-0000d250: 6f66 2069 6e74 6572 6573 7420 6672 6f6d  of interest from
-0000d260: 2074 656d 706c 6174 6520 6461 7461 0a20   template data. 
-0000d270: 2020 2020 2020 2064 6174 615f 7465 6d70         data_temp
-0000d280: 6c61 7465 5f72 6564 7563 6564 203d 2073  late_reduced = s
-0000d290: 656c 662e 5f69 7365 6c28 6d6f 6465 5f69  elf._isel(mode_i
-0000d2a0: 6e64 6578 3d6d 6f64 6573 5f74 6f5f 736f  ndex=modes_to_so
-0000d2b0: 7274 290a 0a20 2020 2020 2020 2061 6d70  rt)..        amp
-0000d2c0: 735f 7265 6475 6365 6420 3d20 6461 7461  s_reduced = data
-0000d2d0: 5f74 656d 706c 6174 655f 7265 6475 6365  _template_reduce
-0000d2e0: 642e 6f75 7465 725f 646f 7428 0a20 2020  d.outer_dot(.   
-0000d2f0: 2020 2020 2020 2020 2064 6174 615f 746f           data_to
-0000d300: 5f73 6f72 742e 5f69 7365 6c28 6d6f 6465  _sort._isel(mode
-0000d310: 5f69 6e64 6578 3d6d 6f64 6573 5f74 6f5f  _index=modes_to_
-0000d320: 736f 7274 290a 2020 2020 2020 2020 292e  sort).        ).
-0000d330: 746f 5f6e 756d 7079 2829 5b30 2c20 3a2c  to_numpy()[0, :,
-0000d340: 203a 5d0a 0a20 2020 2020 2020 2069 6620   :]..        if 
-0000d350: 7365 6c66 2e6d 6f6e 6974 6f72 2e73 746f  self.monitor.sto
-0000d360: 7265 5f66 6965 6c64 735f 6469 7265 6374  re_fields_direct
-0000d370: 696f 6e20 3d3d 2022 2d22 3a0a 2020 2020  ion == "-":.    
-0000d380: 2020 2020 2020 2020 616d 7073 5f72 6564          amps_red
-0000d390: 7563 6564 202a 3d20 2d31 0a0a 2020 2020  uced *= -1..    
-0000d3a0: 2020 2020 2320 4669 6e64 2074 6865 206d      # Find the m
-0000d3b0: 6f73 7420 7369 6d69 6c61 7220 6d6f 6465  ost similar mode
-0000d3c0: 7320 616e 6420 636f 7272 6573 706f 6e64  s and correspond
-0000d3d0: 696e 6720 6f76 6572 6c61 7020 7661 6c75  ing overlap valu
-0000d3e0: 6573 0a20 2020 2020 2020 2070 6169 7273  es.        pairs
-0000d3f0: 5f72 6564 7563 6564 2c20 616d 7073 5f72  _reduced, amps_r
-0000d400: 6564 7563 6564 203d 2073 656c 662e 5f66  educed = self._f
-0000d410: 696e 645f 636c 6f73 6573 745f 7061 6972  ind_closest_pair
-0000d420: 7328 616d 7073 5f72 6564 7563 6564 290a  s(amps_reduced).
-0000d430: 0a20 2020 2020 2020 2023 2049 6e73 6572  .        # Inser
-0000d440: 7420 6e65 7720 736f 7274 696e 6720 616e  t new sorting an
-0000d450: 6420 6f76 6572 6c61 7020 7661 6c75 6573  d overlap values
-0000d460: 2069 6e74 6f20 6172 7261 7973 2077 6974   into arrays wit
-0000d470: 6820 616c 6c20 6461 7461 0a20 2020 2020  h all data.     
-0000d480: 2020 2063 6f6d 706c 6578 5f61 6d70 735b     complex_amps[
-0000d490: 6d6f 6465 735f 746f 5f73 6f72 745d 203d  modes_to_sort] =
-0000d4a0: 2061 6d70 735f 7265 6475 6365 640a 2020   amps_reduced.  
-0000d4b0: 2020 2020 2020 7061 6972 735b 6d6f 6465        pairs[mode
-0000d4c0: 735f 746f 5f73 6f72 745d 203d 206d 6f64  s_to_sort] = mod
-0000d4d0: 6573 5f74 6f5f 736f 7274 5b70 6169 7273  es_to_sort[pairs
-0000d4e0: 5f72 6564 7563 6564 5d0a 0a20 2020 2020  _reduced]..     
-0000d4f0: 2020 2072 6574 7572 6e20 7061 6972 732c     return pairs,
-0000d500: 2063 6f6d 706c 6578 5f61 6d70 730a 0a20   complex_amps.. 
-0000d510: 2020 2040 7374 6174 6963 6d65 7468 6f64     @staticmethod
-0000d520: 0a20 2020 2064 6566 205f 6669 6e64 5f63  .    def _find_c
-0000d530: 6c6f 7365 7374 5f70 6169 7273 2861 7272  losest_pairs(arr
-0000d540: 3a20 4e75 6d70 7929 202d 3e20 5475 706c  : Numpy) -> Tupl
-0000d550: 655b 4e75 6d70 792c 204e 756d 7079 5d3a  e[Numpy, Numpy]:
-0000d560: 0a20 2020 2020 2020 2022 2222 4769 7665  .        """Give
-0000d570: 6e20 6120 636f 6d70 6c65 7820 6f76 6572  n a complex over
-0000d580: 6c61 7020 6d61 7472 6978 2070 6169 7220  lap matrix pair 
-0000d590: 726f 7720 616e 6420 636f 6c75 6d6e 2065  row and column e
-0000d5a0: 6e74 7269 6573 2e22 2222 0a0a 2020 2020  ntries."""..    
-0000d5b0: 2020 2020 6e2c 206b 203d 206e 702e 7368      n, k = np.sh
-0000d5c0: 6170 6528 6172 7229 0a20 2020 2020 2020  ape(arr).       
-0000d5d0: 2069 6620 6e20 213d 206b 3a0a 2020 2020   if n != k:.    
-0000d5e0: 2020 2020 2020 2020 7261 6973 6520 4461          raise Da
-0000d5f0: 7461 4572 726f 7228 224f 7665 726c 6170  taError("Overlap
-0000d600: 206d 6174 7269 7820 6d75 7374 2062 6520   matrix must be 
-0000d610: 7371 7561 7265 2e22 290a 0a20 2020 2020  square.")..     
-0000d620: 2020 2061 7272 5f61 6273 203d 206e 702e     arr_abs = np.
-0000d630: 6162 7328 6172 7229 0a20 2020 2020 2020  abs(arr).       
-0000d640: 2070 6169 7273 203d 202d 6e70 2e6f 6e65   pairs = -np.one
-0000d650: 7328 6e2c 2064 7479 7065 3d69 6e74 290a  s(n, dtype=int).
-0000d660: 2020 2020 2020 2020 7661 6c75 6573 203d          values =
-0000d670: 206e 702e 7a65 726f 7328 6e2c 2064 7479   np.zeros(n, dty
-0000d680: 7065 3d6e 702e 636f 6d70 6c65 7831 3238  pe=np.complex128
-0000d690: 290a 2020 2020 2020 2020 666f 7220 5f20  ).        for _ 
-0000d6a0: 696e 2072 616e 6765 286e 293a 0a20 2020  in range(n):.   
-0000d6b0: 2020 2020 2020 2020 2069 6d61 782c 206a           imax, j
-0000d6c0: 6d61 7820 3d20 6e70 2e75 6e72 6176 656c  max = np.unravel
-0000d6d0: 5f69 6e64 6578 286e 702e 6172 676d 6178  _index(np.argmax
-0000d6e0: 2861 7272 5f61 6273 2c20 6178 6973 3d4e  (arr_abs, axis=N
-0000d6f0: 6f6e 6529 2c20 286e 2c20 6b29 290a 2020  one), (n, k)).  
-0000d700: 2020 2020 2020 2020 2020 7061 6972 735b            pairs[
-0000d710: 696d 6178 5d20 3d20 6a6d 6178 0a20 2020  imax] = jmax.   
-0000d720: 2020 2020 2020 2020 2076 616c 7565 735b           values[
-0000d730: 696d 6178 5d20 3d20 6172 725b 696d 6178  imax] = arr[imax
-0000d740: 2c20 6a6d 6178 5d0a 2020 2020 2020 2020  , jmax].        
-0000d750: 2020 2020 6172 725f 6162 735b 696d 6178      arr_abs[imax
-0000d760: 2c20 3a5d 203d 202d 310a 2020 2020 2020  , :] = -1.      
-0000d770: 2020 2020 2020 6172 725f 6162 735b 3a2c        arr_abs[:,
-0000d780: 206a 6d61 785d 203d 202d 310a 0a20 2020   jmax] = -1..   
-0000d790: 2020 2020 2072 6574 7572 6e20 7061 6972       return pair
-0000d7a0: 732c 2076 616c 7565 730a 0a20 2020 2064  s, values..    d
-0000d7b0: 6566 205f 7265 6f72 6465 725f 6d6f 6465  ef _reorder_mode
-0000d7c0: 7328 0a20 2020 2020 2020 2073 656c 662c  s(.        self,
-0000d7d0: 0a20 2020 2020 2020 2073 6f72 7469 6e67  .        sorting
-0000d7e0: 3a20 4e75 6d70 792c 0a20 2020 2020 2020  : Numpy,.       
-0000d7f0: 2070 6861 7365 3a20 4e75 6d70 792c 0a20   phase: Numpy,. 
-0000d800: 2020 2020 2020 2074 7261 636b 5f66 7265         track_fre
-0000d810: 713a 2054 7261 636b 4672 6571 2c0a 2020  q: TrackFreq,.  
-0000d820: 2020 2920 2d3e 204d 6f64 6544 6174 613a    ) -> ModeData:
-0000d830: 0a20 2020 2020 2020 2022 2222 5265 6172  .        """Rear
-0000d840: 7261 6e67 6520 6d6f 6465 7320 666f 7220  range modes for 
-0000d850: 7468 6520 692d 7468 2066 7265 7175 656e  the i-th frequen
-0000d860: 6379 2061 6363 6f72 6469 6e67 2074 6f20  cy according to 
-0000d870: 736f 7274 696e 675b 692c 203a 5d20 616e  sorting[i, :] an
-0000d880: 6420 6170 706c 7920 7068 6173 650a 2020  d apply phase.  
-0000d890: 2020 2020 2020 7368 6966 7473 2e22 2222        shifts."""
-0000d8a0: 0a0a 2020 2020 2020 2020 6e75 6d5f 6672  ..        num_fr
-0000d8b0: 6571 732c 205f 203d 206e 702e 7368 6170  eqs, _ = np.shap
-0000d8c0: 6528 736f 7274 696e 6729 0a0a 2020 2020  e(sorting)..    
-0000d8d0: 2020 2020 2320 4372 6561 7465 206e 6577      # Create new
-0000d8e0: 2064 6963 7420 7769 7468 2072 6561 7272   dict with rearr
-0000d8f0: 616e 6765 6420 6669 656c 6420 636f 6d70  anged field comp
-0000d900: 6f6e 656e 7473 0a20 2020 2020 2020 2075  onents.        u
-0000d910: 7064 6174 655f 6469 6374 203d 207b 7d0a  pdate_dict = {}.
-0000d920: 2020 2020 2020 2020 666f 7220 6669 656c          for fiel
-0000d930: 645f 6e61 6d65 2c20 6669 656c 6420 696e  d_name, field in
-0000d940: 2073 656c 662e 6669 656c 645f 636f 6d70   self.field_comp
-0000d950: 6f6e 656e 7473 2e69 7465 6d73 2829 3a0a  onents.items():.
-0000d960: 2020 2020 2020 2020 2020 2020 6669 656c              fiel
-0000d970: 645f 736f 7274 6564 203d 2066 6965 6c64  d_sorted = field
-0000d980: 2e63 6f70 7928 290a 0a20 2020 2020 2020  .copy()..       
-0000d990: 2020 2020 2023 2052 6561 7272 616e 6765       # Rearrange
-0000d9a0: 206d 6f64 6573 0a20 2020 2020 2020 2020   modes.         
-0000d9b0: 2020 2066 6f72 2066 7265 715f 6964 2069     for freq_id i
-0000d9c0: 6e20 7261 6e67 6528 6e75 6d5f 6672 6571  n range(num_freq
-0000d9d0: 7329 3a0a 2020 2020 2020 2020 2020 2020  s):.            
-0000d9e0: 2020 2020 6669 656c 645f 736f 7274 6564      field_sorted
-0000d9f0: 2e64 6174 615b 2e2e 2e2c 2066 7265 715f  .data[..., freq_
-0000da00: 6964 2c20 3a5d 203d 2066 6965 6c64 5f73  id, :] = field_s
-0000da10: 6f72 7465 642e 6461 7461 5b0a 2020 2020  orted.data[.    
+0000c8e0: 2020 2020 2020 2020 6622 286f 7665 726c          f"(overl
+0000c8f0: 6170 3a20 277b 6f76 6572 6c61 705b 6672  ap: '{overlap[fr
+0000c900: 6571 5f69 642c 206d 6f64 655f 696e 645d  eq_id, mode_ind]
+0000c910: 3a2e 3266 7d27 292e 220a 2020 2020 2020  :.2f}').".      
+0000c920: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+0000c930: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c940: 2023 2052 6561 7373 6967 6e20 666f 7220   # Reassign for 
+0000c950: 7468 6520 6e65 7874 2069 7465 7261 7469  the next iterati
+0000c960: 6f6e 0a20 2020 2020 2020 2020 2020 2020  on.             
+0000c970: 2020 2064 6174 615f 7465 6d70 6c61 7465     data_template
+0000c980: 203d 2064 6174 615f 746f 5f73 6f72 740a   = data_to_sort.
+0000c990: 0a20 2020 2020 2020 2023 2052 6561 7272  .        # Rearr
+0000c9a0: 616e 6765 206d 6f64 6573 2075 7369 6e67  ange modes using
+0000c9b0: 2063 6f6d 7075 7465 6420 736f 7274 696e   computed sortin
+0000c9c0: 6720 7661 6c75 6573 0a20 2020 2020 2020  g values.       
+0000c9d0: 206d 6f64 655f 6461 7461 5f73 6f72 7465   mode_data_sorte
+0000c9e0: 6420 3d20 7365 6c66 2e5f 7265 6f72 6465  d = self._reorde
+0000c9f0: 725f 6d6f 6465 7328 0a20 2020 2020 2020  r_modes(.       
+0000ca00: 2020 2020 2073 6f72 7469 6e67 3d73 6f72       sorting=sor
+0000ca10: 7469 6e67 2c0a 2020 2020 2020 2020 2020  ting,.          
+0000ca20: 2020 7068 6173 653d 7068 6173 652c 0a20    phase=phase,. 
+0000ca30: 2020 2020 2020 2020 2020 2074 7261 636b             track
+0000ca40: 5f66 7265 713d 7472 6163 6b5f 6672 6571  _freq=track_freq
+0000ca50: 2c0a 2020 2020 2020 2020 290a 0a20 2020  ,.        )..   
+0000ca60: 2020 2020 2072 6574 7572 6e20 6d6f 6465       return mode
+0000ca70: 5f64 6174 615f 736f 7274 6564 0a0a 2020  _data_sorted..  
+0000ca80: 2020 6465 6620 5f69 7365 6c28 7365 6c66    def _isel(self
+0000ca90: 2c20 2a2a 6973 656c 5f6b 7761 7267 7329  , **isel_kwargs)
+0000caa0: 3a0a 2020 2020 2020 2020 2222 2257 7261  :.        """Wra
+0000cab0: 7073 2060 6078 6172 7261 792e 4461 7461  ps ``xarray.Data
+0000cac0: 4172 7261 792e 6973 656c 6060 2066 6f72  Array.isel`` for
+0000cad0: 2061 6c6c 2064 6174 6120 6669 656c 6473   all data fields
+0000cae0: 2074 6861 7420 6172 6520 6465 6669 6e65   that are define
+0000caf0: 6420 6f76 6572 2066 7265 7175 656e 6379  d over frequency
+0000cb00: 2061 6e64 0a20 2020 2020 2020 206d 6f64   and.        mod
+0000cb10: 6520 696e 6465 782e 2055 7365 6420 696e  e index. Used in
+0000cb20: 2060 606f 7665 726c 6170 5f73 6f72 7460   ``overlap_sort`
+0000cb30: 6020 6275 7420 6e6f 7420 6f66 6669 6369  ` but not offici
+0000cb40: 616c 6c79 2073 7570 706f 7274 6564 2073  ally supported s
+0000cb50: 696e 6365 2066 6f72 2065 7861 6d70 6c65  ince for example
+0000cb60: 0a20 2020 2020 2020 2060 6073 656c 662e  .        ``self.
+0000cb70: 6d6f 6e69 746f 722e 6d6f 6465 5f73 7065  monitor.mode_spe
+0000cb80: 6360 6020 616e 6420 6060 7365 6c66 2e6d  c`` and ``self.m
+0000cb90: 6f6e 6974 6f72 2e66 7265 7173 6060 2077  onitor.freqs`` w
+0000cba0: 696c 6c20 6e6f 206c 6f6e 6765 7220 6265  ill no longer be
+0000cbb0: 206d 6174 6368 696e 6720 7468 650a 2020   matching the.  
+0000cbc0: 2020 2020 2020 6e65 776c 7920 6372 6561        newly crea
+0000cbd0: 7465 6420 6461 7461 2e22 2222 0a0a 2020  ted data."""..  
+0000cbe0: 2020 2020 2020 7570 6461 7465 5f64 6963        update_dic
+0000cbf0: 7420 3d20 6469 6374 2873 656c 662e 5f67  t = dict(self._g
+0000cc00: 7269 645f 636f 7272 6563 7469 6f6e 5f64  rid_correction_d
+0000cc10: 6963 742c 202a 2a73 656c 662e 6669 656c  ict, **self.fiel
+0000cc20: 645f 636f 6d70 6f6e 656e 7473 290a 2020  d_components).  
+0000cc30: 2020 2020 2020 7570 6461 7465 5f64 6963        update_dic
+0000cc40: 7420 3d20 7b6b 6579 3a20 6669 656c 642e  t = {key: field.
+0000cc50: 6973 656c 282a 2a69 7365 6c5f 6b77 6172  isel(**isel_kwar
+0000cc60: 6773 2920 666f 7220 6b65 792c 2066 6965  gs) for key, fie
+0000cc70: 6c64 2069 6e20 7570 6461 7465 5f64 6963  ld in update_dic
+0000cc80: 742e 6974 656d 7328 297d 0a20 2020 2020  t.items()}.     
+0000cc90: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
+0000cca0: 7570 6461 7465 6428 7570 6461 7465 3d75  updated(update=u
+0000ccb0: 7064 6174 655f 6469 6374 290a 0a20 2020  pdate_dict)..   
+0000ccc0: 2064 6566 205f 6173 7369 676e 5f63 6f6f   def _assign_coo
+0000ccd0: 7264 7328 7365 6c66 2c20 2a2a 6173 7369  rds(self, **assi
+0000cce0: 676e 5f63 6f6f 7264 735f 6b77 6172 6773  gn_coords_kwargs
+0000ccf0: 293a 0a20 2020 2020 2020 2022 2222 5772  ):.        """Wr
+0000cd00: 6170 7320 6060 7861 7272 6179 2e44 6174  aps ``xarray.Dat
+0000cd10: 6141 7272 6179 2e61 7373 6967 6e5f 636f  aArray.assign_co
+0000cd20: 6f72 6473 6060 2066 6f72 2061 6c6c 2064  ords`` for all d
+0000cd30: 6174 6120 6669 656c 6473 2074 6861 7420  ata fields that 
+0000cd40: 6172 6520 6465 6669 6e65 6420 6f76 6572  are defined over
+0000cd50: 2066 7265 7175 656e 6379 2061 6e64 0a20   frequency and. 
+0000cd60: 2020 2020 2020 206d 6f64 6520 696e 6465         mode inde
+0000cd70: 782e 2055 7365 6420 696e 2060 606f 7665  x. Used in ``ove
+0000cd80: 726c 6170 5f73 6f72 7460 6020 6275 7420  rlap_sort`` but 
+0000cd90: 6e6f 7420 6f66 6669 6369 616c 6c79 2073  not officially s
+0000cda0: 7570 706f 7274 6564 2073 696e 6365 2066  upported since f
+0000cdb0: 6f72 2065 7861 6d70 6c65 0a20 2020 2020  or example.     
+0000cdc0: 2020 2060 6073 656c 662e 6d6f 6e69 746f     ``self.monito
+0000cdd0: 722e 6d6f 6465 5f73 7065 6360 6020 616e  r.mode_spec`` an
+0000cde0: 6420 6060 7365 6c66 2e6d 6f6e 6974 6f72  d ``self.monitor
+0000cdf0: 2e66 7265 7173 6060 2077 696c 6c20 6e6f  .freqs`` will no
+0000ce00: 206c 6f6e 6765 7220 6265 206d 6174 6368   longer be match
+0000ce10: 696e 6720 7468 650a 2020 2020 2020 2020  ing the.        
+0000ce20: 6e65 776c 7920 6372 6561 7465 6420 6461  newly created da
+0000ce30: 7461 2e22 2222 0a0a 2020 2020 2020 2020  ta."""..        
+0000ce40: 7570 6461 7465 5f64 6963 7420 3d20 6469  update_dict = di
+0000ce50: 6374 2873 656c 662e 5f67 7269 645f 636f  ct(self._grid_co
+0000ce60: 7272 6563 7469 6f6e 5f64 6963 742c 202a  rrection_dict, *
+0000ce70: 2a73 656c 662e 6669 656c 645f 636f 6d70  *self.field_comp
+0000ce80: 6f6e 656e 7473 290a 2020 2020 2020 2020  onents).        
+0000ce90: 7570 6461 7465 5f64 6963 7420 3d20 7b0a  update_dict = {.
+0000cea0: 2020 2020 2020 2020 2020 2020 6b65 793a              key:
+0000ceb0: 2066 6965 6c64 2e61 7373 6967 6e5f 636f   field.assign_co
+0000cec0: 6f72 6473 282a 2a61 7373 6967 6e5f 636f  ords(**assign_co
+0000ced0: 6f72 6473 5f6b 7761 7267 7329 2066 6f72  ords_kwargs) for
+0000cee0: 206b 6579 2c20 6669 656c 6420 696e 2075   key, field in u
+0000cef0: 7064 6174 655f 6469 6374 2e69 7465 6d73  pdate_dict.items
+0000cf00: 2829 0a20 2020 2020 2020 207d 0a20 2020  ().        }.   
+0000cf10: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+0000cf20: 2e5f 7570 6461 7465 6428 7570 6461 7465  ._updated(update
+0000cf30: 3d75 7064 6174 655f 6469 6374 290a 0a20  =update_dict).. 
+0000cf40: 2020 2064 6566 205f 6669 6e64 5f6f 7264     def _find_ord
+0000cf50: 6572 696e 675f 6f6e 655f 6672 6571 280a  ering_one_freq(.
+0000cf60: 2020 2020 2020 2020 7365 6c66 2c0a 2020          self,.  
+0000cf70: 2020 2020 2020 6461 7461 5f74 6f5f 736f        data_to_so
+0000cf80: 7274 3a20 4d6f 6465 4461 7461 2c0a 2020  rt: ModeData,.  
+0000cf90: 2020 2020 2020 6f76 6572 6c61 705f 7468        overlap_th
+0000cfa0: 7265 7368 3a20 666c 6f61 742c 0a20 2020  resh: float,.   
+0000cfb0: 2029 202d 3e20 5475 706c 655b 4e75 6d70   ) -> Tuple[Nump
+0000cfc0: 792c 204e 756d 7079 5d3a 0a20 2020 2020  y, Numpy]:.     
+0000cfd0: 2020 2022 2222 4669 6e64 206e 6577 206f     """Find new o
+0000cfe0: 7264 6572 696e 6720 6f66 206d 6f64 6573  rdering of modes
+0000cff0: 2069 6e20 6461 7461 5f74 6f5f 736f 7274   in data_to_sort
+0000d000: 2062 6173 6564 206f 6e20 7468 6569 7220   based on their 
+0000d010: 7369 6d69 6c61 7269 7479 2074 6f20 6f77  similarity to ow
+0000d020: 6e20 6d6f 6465 732e 2222 220a 0a20 2020  n modes."""..   
+0000d030: 2020 2020 206e 756d 5f6d 6f64 6573 203d       num_modes =
+0000d040: 2073 656c 662e 6e5f 636f 6d70 6c65 782e   self.n_complex.
+0000d050: 7369 7a65 735b 226d 6f64 655f 696e 6465  sizes["mode_inde
+0000d060: 7822 5d0a 0a20 2020 2020 2020 2023 2043  x"]..        # C
+0000d070: 7572 7265 6e74 2070 6169 7273 2061 6e64  urrent pairs and
+0000d080: 2074 6865 6972 206f 7665 726c 6170 730a   their overlaps.
+0000d090: 2020 2020 2020 2020 7061 6972 7320 3d20          pairs = 
+0000d0a0: 6e70 2e61 7261 6e67 6528 6e75 6d5f 6d6f  np.arange(num_mo
+0000d0b0: 6465 7329 0a20 2020 2020 2020 2063 6f6d  des).        com
+0000d0c0: 706c 6578 5f61 6d70 7320 3d20 7365 6c66  plex_amps = self
+0000d0d0: 2e64 6f74 2864 6174 615f 746f 5f73 6f72  .dot(data_to_sor
+0000d0e0: 7429 2e64 6174 612e 7261 7665 6c28 290a  t).data.ravel().
+0000d0f0: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+0000d100: 6d6f 6e69 746f 722e 7374 6f72 655f 6669  monitor.store_fi
+0000d110: 656c 6473 5f64 6972 6563 7469 6f6e 203d  elds_direction =
+0000d120: 3d20 222d 223a 0a20 2020 2020 2020 2020  = "-":.         
+0000d130: 2020 2063 6f6d 706c 6578 5f61 6d70 7320     complex_amps 
+0000d140: 2a3d 202d 310a 0a20 2020 2020 2020 2023  *= -1..        #
+0000d150: 2043 6865 636b 2077 6865 7468 6572 206d   Check whether m
+0000d160: 6f64 6573 2061 6c72 6561 6479 206d 6174  odes already mat
+0000d170: 6368 0a20 2020 2020 2020 206d 6f64 6573  ch.        modes
+0000d180: 5f74 6f5f 736f 7274 203d 206e 702e 7768  _to_sort = np.wh
+0000d190: 6572 6528 6e70 2e61 6273 2863 6f6d 706c  ere(np.abs(compl
+0000d1a0: 6578 5f61 6d70 7329 203c 206f 7665 726c  ex_amps) < overl
+0000d1b0: 6170 5f74 6872 6573 6829 5b30 5d0a 2020  ap_thresh)[0].  
+0000d1c0: 2020 2020 2020 6e75 6d5f 6d6f 6465 735f        num_modes_
+0000d1d0: 746f 5f73 6f72 7420 3d20 6c65 6e28 6d6f  to_sort = len(mo
+0000d1e0: 6465 735f 746f 5f73 6f72 7429 0a20 2020  des_to_sort).   
+0000d1f0: 2020 2020 2069 6620 6e75 6d5f 6d6f 6465       if num_mode
+0000d200: 735f 746f 5f73 6f72 7420 3c3d 2031 3a0a  s_to_sort <= 1:.
+0000d210: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0000d220: 726e 2070 6169 7273 2c20 636f 6d70 6c65  rn pairs, comple
+0000d230: 785f 616d 7073 0a0a 2020 2020 2020 2020  x_amps..        
+0000d240: 2320 4578 7472 6163 7420 616c 6c20 6d6f  # Extract all mo
+0000d250: 6465 7320 6f66 2069 6e74 6572 6573 7420  des of interest 
+0000d260: 6672 6f6d 2074 656d 706c 6174 6520 6461  from template da
+0000d270: 7461 0a20 2020 2020 2020 2064 6174 615f  ta.        data_
+0000d280: 7465 6d70 6c61 7465 5f72 6564 7563 6564  template_reduced
+0000d290: 203d 2073 656c 662e 5f69 7365 6c28 6d6f   = self._isel(mo
+0000d2a0: 6465 5f69 6e64 6578 3d6d 6f64 6573 5f74  de_index=modes_t
+0000d2b0: 6f5f 736f 7274 290a 0a20 2020 2020 2020  o_sort)..       
+0000d2c0: 2061 6d70 735f 7265 6475 6365 6420 3d20   amps_reduced = 
+0000d2d0: 6461 7461 5f74 656d 706c 6174 655f 7265  data_template_re
+0000d2e0: 6475 6365 642e 6f75 7465 725f 646f 7428  duced.outer_dot(
+0000d2f0: 0a20 2020 2020 2020 2020 2020 2064 6174  .            dat
+0000d300: 615f 746f 5f73 6f72 742e 5f69 7365 6c28  a_to_sort._isel(
+0000d310: 6d6f 6465 5f69 6e64 6578 3d6d 6f64 6573  mode_index=modes
+0000d320: 5f74 6f5f 736f 7274 290a 2020 2020 2020  _to_sort).      
+0000d330: 2020 292e 746f 5f6e 756d 7079 2829 5b30    ).to_numpy()[0
+0000d340: 2c20 3a2c 203a 5d0a 0a20 2020 2020 2020  , :, :]..       
+0000d350: 2069 6620 7365 6c66 2e6d 6f6e 6974 6f72   if self.monitor
+0000d360: 2e73 746f 7265 5f66 6965 6c64 735f 6469  .store_fields_di
+0000d370: 7265 6374 696f 6e20 3d3d 2022 2d22 3a0a  rection == "-":.
+0000d380: 2020 2020 2020 2020 2020 2020 616d 7073              amps
+0000d390: 5f72 6564 7563 6564 202a 3d20 2d31 0a0a  _reduced *= -1..
+0000d3a0: 2020 2020 2020 2020 2320 4669 6e64 2074          # Find t
+0000d3b0: 6865 206d 6f73 7420 7369 6d69 6c61 7220  he most similar 
+0000d3c0: 6d6f 6465 7320 616e 6420 636f 7272 6573  modes and corres
+0000d3d0: 706f 6e64 696e 6720 6f76 6572 6c61 7020  ponding overlap 
+0000d3e0: 7661 6c75 6573 0a20 2020 2020 2020 2070  values.        p
+0000d3f0: 6169 7273 5f72 6564 7563 6564 2c20 616d  airs_reduced, am
+0000d400: 7073 5f72 6564 7563 6564 203d 2073 656c  ps_reduced = sel
+0000d410: 662e 5f66 696e 645f 636c 6f73 6573 745f  f._find_closest_
+0000d420: 7061 6972 7328 616d 7073 5f72 6564 7563  pairs(amps_reduc
+0000d430: 6564 290a 0a20 2020 2020 2020 2023 2049  ed)..        # I
+0000d440: 6e73 6572 7420 6e65 7720 736f 7274 696e  nsert new sortin
+0000d450: 6720 616e 6420 6f76 6572 6c61 7020 7661  g and overlap va
+0000d460: 6c75 6573 2069 6e74 6f20 6172 7261 7973  lues into arrays
+0000d470: 2077 6974 6820 616c 6c20 6461 7461 0a20   with all data. 
+0000d480: 2020 2020 2020 2063 6f6d 706c 6578 5f61         complex_a
+0000d490: 6d70 735b 6d6f 6465 735f 746f 5f73 6f72  mps[modes_to_sor
+0000d4a0: 745d 203d 2061 6d70 735f 7265 6475 6365  t] = amps_reduce
+0000d4b0: 640a 2020 2020 2020 2020 7061 6972 735b  d.        pairs[
+0000d4c0: 6d6f 6465 735f 746f 5f73 6f72 745d 203d  modes_to_sort] =
+0000d4d0: 206d 6f64 6573 5f74 6f5f 736f 7274 5b70   modes_to_sort[p
+0000d4e0: 6169 7273 5f72 6564 7563 6564 5d0a 0a20  airs_reduced].. 
+0000d4f0: 2020 2020 2020 2072 6574 7572 6e20 7061         return pa
+0000d500: 6972 732c 2063 6f6d 706c 6578 5f61 6d70  irs, complex_amp
+0000d510: 730a 0a20 2020 2040 7374 6174 6963 6d65  s..    @staticme
+0000d520: 7468 6f64 0a20 2020 2064 6566 205f 6669  thod.    def _fi
+0000d530: 6e64 5f63 6c6f 7365 7374 5f70 6169 7273  nd_closest_pairs
+0000d540: 2861 7272 3a20 4e75 6d70 7929 202d 3e20  (arr: Numpy) -> 
+0000d550: 5475 706c 655b 4e75 6d70 792c 204e 756d  Tuple[Numpy, Num
+0000d560: 7079 5d3a 0a20 2020 2020 2020 2022 2222  py]:.        """
+0000d570: 4769 7665 6e20 6120 636f 6d70 6c65 7820  Given a complex 
+0000d580: 6f76 6572 6c61 7020 6d61 7472 6978 2070  overlap matrix p
+0000d590: 6169 7220 726f 7720 616e 6420 636f 6c75  air row and colu
+0000d5a0: 6d6e 2065 6e74 7269 6573 2e22 2222 0a0a  mn entries."""..
+0000d5b0: 2020 2020 2020 2020 6e2c 206b 203d 206e          n, k = n
+0000d5c0: 702e 7368 6170 6528 6172 7229 0a20 2020  p.shape(arr).   
+0000d5d0: 2020 2020 2069 6620 6e20 213d 206b 3a0a       if n != k:.
+0000d5e0: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+0000d5f0: 6520 4461 7461 4572 726f 7228 224f 7665  e DataError("Ove
+0000d600: 726c 6170 206d 6174 7269 7820 6d75 7374  rlap matrix must
+0000d610: 2062 6520 7371 7561 7265 2e22 290a 0a20   be square.").. 
+0000d620: 2020 2020 2020 2061 7272 5f61 6273 203d         arr_abs =
+0000d630: 206e 702e 6162 7328 6172 7229 0a20 2020   np.abs(arr).   
+0000d640: 2020 2020 2070 6169 7273 203d 202d 6e70       pairs = -np
+0000d650: 2e6f 6e65 7328 6e2c 2064 7479 7065 3d69  .ones(n, dtype=i
+0000d660: 6e74 290a 2020 2020 2020 2020 7661 6c75  nt).        valu
+0000d670: 6573 203d 206e 702e 7a65 726f 7328 6e2c  es = np.zeros(n,
+0000d680: 2064 7479 7065 3d6e 702e 636f 6d70 6c65   dtype=np.comple
+0000d690: 7831 3238 290a 2020 2020 2020 2020 666f  x128).        fo
+0000d6a0: 7220 5f20 696e 2072 616e 6765 286e 293a  r _ in range(n):
+0000d6b0: 0a20 2020 2020 2020 2020 2020 2069 6d61  .            ima
+0000d6c0: 782c 206a 6d61 7820 3d20 6e70 2e75 6e72  x, jmax = np.unr
+0000d6d0: 6176 656c 5f69 6e64 6578 286e 702e 6172  avel_index(np.ar
+0000d6e0: 676d 6178 2861 7272 5f61 6273 2c20 6178  gmax(arr_abs, ax
+0000d6f0: 6973 3d4e 6f6e 6529 2c20 286e 2c20 6b29  is=None), (n, k)
+0000d700: 290a 2020 2020 2020 2020 2020 2020 7061  ).            pa
+0000d710: 6972 735b 696d 6178 5d20 3d20 6a6d 6178  irs[imax] = jmax
+0000d720: 0a20 2020 2020 2020 2020 2020 2076 616c  .            val
+0000d730: 7565 735b 696d 6178 5d20 3d20 6172 725b  ues[imax] = arr[
+0000d740: 696d 6178 2c20 6a6d 6178 5d0a 2020 2020  imax, jmax].    
+0000d750: 2020 2020 2020 2020 6172 725f 6162 735b          arr_abs[
+0000d760: 696d 6178 2c20 3a5d 203d 202d 310a 2020  imax, :] = -1.  
+0000d770: 2020 2020 2020 2020 2020 6172 725f 6162            arr_ab
+0000d780: 735b 3a2c 206a 6d61 785d 203d 202d 310a  s[:, jmax] = -1.
+0000d790: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0000d7a0: 7061 6972 732c 2076 616c 7565 730a 0a20  pairs, values.. 
+0000d7b0: 2020 2064 6566 205f 7265 6f72 6465 725f     def _reorder_
+0000d7c0: 6d6f 6465 7328 0a20 2020 2020 2020 2073  modes(.        s
+0000d7d0: 656c 662c 0a20 2020 2020 2020 2073 6f72  elf,.        sor
+0000d7e0: 7469 6e67 3a20 4e75 6d70 792c 0a20 2020  ting: Numpy,.   
+0000d7f0: 2020 2020 2070 6861 7365 3a20 4e75 6d70       phase: Nump
+0000d800: 792c 0a20 2020 2020 2020 2074 7261 636b  y,.        track
+0000d810: 5f66 7265 713a 2054 7261 636b 4672 6571  _freq: TrackFreq
+0000d820: 2c0a 2020 2020 2920 2d3e 204d 6f64 6544  ,.    ) -> ModeD
+0000d830: 6174 613a 0a20 2020 2020 2020 2022 2222  ata:.        """
+0000d840: 5265 6172 7261 6e67 6520 6d6f 6465 7320  Rearrange modes 
+0000d850: 666f 7220 7468 6520 692d 7468 2066 7265  for the i-th fre
+0000d860: 7175 656e 6379 2061 6363 6f72 6469 6e67  quency according
+0000d870: 2074 6f20 736f 7274 696e 675b 692c 203a   to sorting[i, :
+0000d880: 5d20 616e 6420 6170 706c 7920 7068 6173  ] and apply phas
+0000d890: 650a 2020 2020 2020 2020 7368 6966 7473  e.        shifts
+0000d8a0: 2e22 2222 0a0a 2020 2020 2020 2020 6e75  ."""..        nu
+0000d8b0: 6d5f 6672 6571 732c 205f 203d 206e 702e  m_freqs, _ = np.
+0000d8c0: 7368 6170 6528 736f 7274 696e 6729 0a0a  shape(sorting)..
+0000d8d0: 2020 2020 2020 2020 2320 4372 6561 7465          # Create
+0000d8e0: 206e 6577 2064 6963 7420 7769 7468 2072   new dict with r
+0000d8f0: 6561 7272 616e 6765 6420 6669 656c 6420  earranged field 
+0000d900: 636f 6d70 6f6e 656e 7473 0a20 2020 2020  components.     
+0000d910: 2020 2075 7064 6174 655f 6469 6374 203d     update_dict =
+0000d920: 207b 7d0a 2020 2020 2020 2020 666f 7220   {}.        for 
+0000d930: 6669 656c 645f 6e61 6d65 2c20 6669 656c  field_name, fiel
+0000d940: 6420 696e 2073 656c 662e 6669 656c 645f  d in self.field_
+0000d950: 636f 6d70 6f6e 656e 7473 2e69 7465 6d73  components.items
+0000d960: 2829 3a0a 2020 2020 2020 2020 2020 2020  ():.            
+0000d970: 6669 656c 645f 736f 7274 6564 203d 2066  field_sorted = f
+0000d980: 6965 6c64 2e63 6f70 7928 290a 0a20 2020  ield.copy()..   
+0000d990: 2020 2020 2020 2020 2023 2052 6561 7272           # Rearr
+0000d9a0: 616e 6765 206d 6f64 6573 0a20 2020 2020  ange modes.     
+0000d9b0: 2020 2020 2020 2066 6f72 2066 7265 715f         for freq_
+0000d9c0: 6964 2069 6e20 7261 6e67 6528 6e75 6d5f  id in range(num_
+0000d9d0: 6672 6571 7329 3a0a 2020 2020 2020 2020  freqs):.        
+0000d9e0: 2020 2020 2020 2020 6669 656c 645f 736f          field_so
+0000d9f0: 7274 6564 2e64 6174 615b 2e2e 2e2c 2066  rted.data[..., f
+0000da00: 7265 715f 6964 2c20 3a5d 203d 2066 6965  req_id, :] = fie
+0000da10: 6c64 5f73 6f72 7465 642e 6461 7461 5b0a  ld_sorted.data[.
 0000da20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000da30: 2e2e 2e2c 2066 7265 715f 6964 2c20 736f  ..., freq_id, so
-0000da40: 7274 696e 675b 6672 6571 5f69 642c 203a  rting[freq_id, :
-0000da50: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0000da60: 2020 5d0a 0a20 2020 2020 2020 2020 2020    ]..           
-0000da70: 2023 2041 7070 6c79 2070 6861 7365 2073   # Apply phase s
-0000da80: 6869 6674 0a20 2020 2020 2020 2020 2020  hift.           
-0000da90: 2070 6861 7365 5f66 6163 7420 3d20 6e70   phase_fact = np
-0000daa0: 2e65 7870 282d 316a 202a 2070 6861 7365  .exp(-1j * phase
-0000dab0: 5b4e 6f6e 652c 204e 6f6e 652c 204e 6f6e  [None, None, Non
-0000dac0: 652c 203a 2c20 3a5d 292e 6173 7479 7065  e, :, :]).astype
-0000dad0: 2866 6965 6c64 5f73 6f72 7465 642e 6461  (field_sorted.da
-0000dae0: 7461 2e64 7479 7065 290a 2020 2020 2020  ta.dtype).      
-0000daf0: 2020 2020 2020 6669 656c 645f 736f 7274        field_sort
-0000db00: 6564 2e64 6174 6120 3d20 6669 656c 645f  ed.data = field_
-0000db10: 736f 7274 6564 2e64 6174 6120 2a20 7068  sorted.data * ph
-0000db20: 6173 655f 6661 6374 0a0a 2020 2020 2020  ase_fact..      
-0000db30: 2020 2020 2020 7570 6461 7465 5f64 6963        update_dic
-0000db40: 745b 6669 656c 645f 6e61 6d65 5d20 3d20  t[field_name] = 
-0000db50: 6669 656c 645f 736f 7274 6564 0a0a 2020  field_sorted..  
-0000db60: 2020 2020 2020 2320 5265 6172 7261 6e67        # Rearrang
-0000db70: 6520 6461 7461 206f 7665 7220 6620 616e  e data over f an
-0000db80: 6420 6d6f 6465 5f69 6e64 6578 0a20 2020  d mode_index.   
-0000db90: 2020 2020 2064 6174 615f 6469 6374 203d       data_dict =
-0000dba0: 2064 6963 7428 2a2a 7365 6c66 2e5f 6772   dict(**self._gr
-0000dbb0: 6964 5f63 6f72 7265 6374 696f 6e5f 6469  id_correction_di
-0000dbc0: 6374 2c20 6e5f 636f 6d70 6c65 783d 7365  ct, n_complex=se
-0000dbd0: 6c66 2e6e 5f63 6f6d 706c 6578 290a 2020  lf.n_complex).  
-0000dbe0: 2020 2020 2020 666f 7220 6b65 792c 2064        for key, d
-0000dbf0: 6174 6120 696e 2064 6174 615f 6469 6374  ata in data_dict
-0000dc00: 2e69 7465 6d73 2829 3a0a 2020 2020 2020  .items():.      
-0000dc10: 2020 2020 2020 7570 6461 7465 5f64 6963        update_dic
-0000dc20: 745b 6b65 795d 203d 2064 6174 612e 636f  t[key] = data.co
-0000dc30: 7079 2829 0a20 2020 2020 2020 2020 2020  py().           
-0000dc40: 2066 6f72 2066 7265 715f 6964 2069 6e20   for freq_id in 
-0000dc50: 7261 6e67 6528 6e75 6d5f 6672 6571 7329  range(num_freqs)
-0000dc60: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000dc70: 2020 7570 6461 7465 5f64 6963 745b 6b65    update_dict[ke
-0000dc80: 795d 2e64 6174 615b 6672 6571 5f69 642c  y].data[freq_id,
-0000dc90: 203a 5d20 3d20 7570 6461 7465 5f64 6963   :] = update_dic
-0000dca0: 745b 6b65 795d 2e64 6174 615b 0a20 2020  t[key].data[.   
-0000dcb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dcc0: 2066 7265 715f 6964 2c20 736f 7274 696e   freq_id, sortin
-0000dcd0: 675b 6672 6571 5f69 642c 203a 5d0a 2020  g[freq_id, :].  
-0000dce0: 2020 2020 2020 2020 2020 2020 2020 5d0a                ].
-0000dcf0: 0a20 2020 2020 2020 2023 2055 7064 6174  .        # Updat
-0000dd00: 6520 6d6f 6465 5f73 7065 6320 696e 2074  e mode_spec in t
-0000dd10: 6865 206d 6f6e 6974 6f72 0a20 2020 2020  he monitor.     
-0000dd20: 2020 206d 6f64 655f 7370 6563 203d 2073     mode_spec = s
-0000dd30: 656c 662e 6d6f 6e69 746f 722e 6d6f 6465  elf.monitor.mode
-0000dd40: 5f73 7065 632e 636f 7079 2875 7064 6174  _spec.copy(updat
-0000dd50: 653d 6469 6374 2874 7261 636b 5f66 7265  e=dict(track_fre
-0000dd60: 713d 7472 6163 6b5f 6672 6571 2929 0a20  q=track_freq)). 
-0000dd70: 2020 2020 2020 2075 7064 6174 655f 6469         update_di
-0000dd80: 6374 5b22 6d6f 6e69 746f 7222 5d20 3d20  ct["monitor"] = 
-0000dd90: 7365 6c66 2e6d 6f6e 6974 6f72 2e63 6f70  self.monitor.cop
-0000dda0: 7928 7570 6461 7465 3d64 6963 7428 6d6f  y(update=dict(mo
-0000ddb0: 6465 5f73 7065 633d 6d6f 6465 5f73 7065  de_spec=mode_spe
-0000ddc0: 6329 290a 0a20 2020 2020 2020 2072 6574  c))..        ret
-0000ddd0: 7572 6e20 7365 6c66 2e63 6f70 7928 7570  urn self.copy(up
-0000dde0: 6461 7465 3d75 7064 6174 655f 6469 6374  date=update_dict
-0000ddf0: 290a 0a20 2020 2064 6566 205f 6772 6f75  )..    def _grou
-0000de00: 705f 696e 6465 785f 706f 7374 5f70 726f  p_index_post_pro
-0000de10: 6365 7373 2873 656c 662c 2066 7265 7175  cess(self, frequ
-0000de20: 656e 6379 5f73 7465 703a 2066 6c6f 6174  ency_step: float
-0000de30: 2920 2d3e 204d 6f64 6544 6174 613a 0a20  ) -> ModeData:. 
-0000de40: 2020 2020 2020 2022 2222 4361 6c63 756c         """Calcul
-0000de50: 6174 6520 6772 6f75 7020 696e 6465 7820  ate group index 
-0000de60: 616e 6420 7265 6d6f 7665 2061 6464 6564  and remove added
-0000de70: 2066 7265 7175 656e 6369 6573 2075 7365   frequencies use
-0000de80: 6420 6f6e 6c79 2066 6f72 2074 6869 7320  d only for this 
-0000de90: 6361 6c63 756c 6174 696f 6e2e 0a0a 2020  calculation...  
-0000dea0: 2020 2020 2020 5061 7261 6d65 7465 7273        Parameters
-0000deb0: 0a20 2020 2020 2020 202d 2d2d 2d2d 2d2d  .        -------
-0000dec0: 2d2d 2d0a 2020 2020 2020 2020 6672 6571  ---.        freq
-0000ded0: 7565 6e63 795f 7374 6570 3a20 666c 6f61  uency_step: floa
-0000dee0: 740a 2020 2020 2020 2020 2020 2020 4672  t.            Fr
-0000def0: 6163 7469 6f6e 616c 2066 7265 7175 656e  actional frequen
-0000df00: 6379 2073 7465 7020 7573 6564 2074 6f20  cy step used to 
-0000df10: 6361 6c63 756c 6174 6520 7468 6520 6772  calculate the gr
-0000df20: 6f75 7020 696e 6465 782e 0a0a 2020 2020  oup index...    
-0000df30: 2020 2020 5265 7475 726e 730a 2020 2020      Returns.    
-0000df40: 2020 2020 2d2d 2d2d 2d2d 2d0a 2020 2020      -------.    
-0000df50: 2020 2020 3a63 6c61 7373 3a60 2e4d 6f64      :class:`.Mod
-0000df60: 6544 6174 6160 0a20 2020 2020 2020 2020  eData`.         
-0000df70: 2020 2046 696c 7465 7265 6420 6461 7461     Filtered data
-0000df80: 2077 6974 6820 6361 6c63 756c 6174 6564   with calculated
-0000df90: 2067 726f 7570 2069 6e64 6578 2e0a 2020   group index..  
-0000dfa0: 2020 2020 2020 2222 220a 0a20 2020 2020        """..     
-0000dfb0: 2020 2066 7265 7173 203d 2073 656c 662e     freqs = self.
-0000dfc0: 6e5f 636f 6d70 6c65 782e 636f 6f72 6473  n_complex.coords
-0000dfd0: 5b22 6622 5d2e 7661 6c75 6573 0a20 2020  ["f"].values.   
-0000dfe0: 2020 2020 206e 756d 5f66 7265 7173 203d       num_freqs =
-0000dff0: 2066 7265 7173 2e73 697a 650a 2020 2020   freqs.size.    
-0000e000: 2020 2020 6261 636b 203d 2073 6c69 6365      back = slice
-0000e010: 2830 2c20 6e75 6d5f 6672 6571 732c 2033  (0, num_freqs, 3
-0000e020: 290a 2020 2020 2020 2020 6365 6e74 6572  ).        center
-0000e030: 203d 2073 6c69 6365 2831 2c20 6e75 6d5f   = slice(1, num_
-0000e040: 6672 6571 732c 2033 290a 2020 2020 2020  freqs, 3).      
-0000e050: 2020 6677 6420 3d20 736c 6963 6528 322c    fwd = slice(2,
-0000e060: 206e 756d 5f66 7265 7173 2c20 3329 0a20   num_freqs, 3). 
-0000e070: 2020 2020 2020 2066 7265 7173 203d 2066         freqs = f
-0000e080: 7265 7173 5b63 656e 7465 725d 0a0a 2020  reqs[center]..  
-0000e090: 2020 2020 2020 2320 6361 6c63 756c 6174        # calculat
-0000e0a0: 6520 6772 6f75 7020 696e 6465 780a 2020  e group index.  
-0000e0b0: 2020 2020 2020 6e5f 6365 6e74 6572 203d        n_center =
-0000e0c0: 2073 656c 662e 6e5f 6566 662e 6973 656c   self.n_eff.isel
-0000e0d0: 2866 3d63 656e 7465 7229 2e76 616c 7565  (f=center).value
-0000e0e0: 730a 2020 2020 2020 2020 6e5f 6261 636b  s.        n_back
-0000e0f0: 7761 7264 203d 2073 656c 662e 6e5f 6566  ward = self.n_ef
-0000e100: 662e 6973 656c 2866 3d62 6163 6b29 2e76  f.isel(f=back).v
-0000e110: 616c 7565 730a 2020 2020 2020 2020 6e5f  alues.        n_
-0000e120: 666f 7277 6172 6420 3d20 7365 6c66 2e6e  forward = self.n
-0000e130: 5f65 6666 2e69 7365 6c28 663d 6677 6429  _eff.isel(f=fwd)
-0000e140: 2e76 616c 7565 730a 0a20 2020 2020 2020  .values..       
-0000e150: 2069 6e76 5f73 7465 7020 3d20 3120 2f20   inv_step = 1 / 
-0000e160: 6672 6571 7565 6e63 795f 7374 6570 0a20  frequency_step. 
-0000e170: 2020 2020 2020 2023 206e 5f67 203d 206e         # n_g = n
-0000e180: 202b 2066 202a 2064 662f 646e 0a20 2020   + f * df/dn.   
-0000e190: 2020 2020 2023 2064 6e2f 6466 203d 2028       # dn/df = (
-0000e1a0: 6e2b 202d 206e 2d29 202f 2028 3220 6620  n+ - n-) / (2 f 
-0000e1b0: 6466 290a 2020 2020 2020 2020 6e5f 6772  df).        n_gr
-0000e1c0: 6f75 705f 6461 7461 203d 206e 5f63 656e  oup_data = n_cen
-0000e1d0: 7465 7220 2b20 286e 5f66 6f72 7761 7264  ter + (n_forward
-0000e1e0: 202d 206e 5f62 6163 6b77 6172 6429 202a   - n_backward) *
-0000e1f0: 2069 6e76 5f73 7465 7020 2a20 302e 350a   inv_step * 0.5.
-0000e200: 2020 2020 2020 2020 2320 4420 3d20 2d32          # D = -2
-0000e210: 202a 2070 6920 2a20 6320 2f20 6c64 615e   * pi * c / lda^
-0000e220: 3220 2a20 6428 765f 675e 2d31 292f 6477  2 * d(v_g^-1)/dw
-0000e230: 203d 202d 2866 202f 2063 295e 3220 2a20   = -(f / c)^2 * 
-0000e240: 2832 202a 2064 6e2f 6466 202b 2066 202a  (2 * dn/df + f *
-0000e250: 2064 326e 2f64 6632 290a 2020 2020 2020   d2n/df2).      
-0000e260: 2020 2320 6432 6e2f 6466 3220 3d20 286e    # d2n/df2 = (n
-0000e270: 2b20 2d20 326e 202b 206e 2d29 202f 2028  + - 2n + n-) / (
-0000e280: 6620 6466 295e 320a 2020 2020 2020 2020  f df)^2.        
-0000e290: 2320 5468 6520 2731 6531 3827 2066 6163  # The '1e18' fac
-0000e2a0: 746f 7220 636f 6e76 6572 7473 2066 726f  tor converts fro
-0000e2b0: 6d20 732f 756d 5e32 2074 6f20 7073 2f28  m s/um^2 to ps/(
-0000e2c0: 6e6d 206b 6d29 0a20 2020 2020 2020 2064  nm km).        d
-0000e2d0: 6973 7065 7273 696f 6e5f 6461 7461 203d  ispersion_data =
-0000e2e0: 2028 0a20 2020 2020 2020 2020 2020 2028   (.            (
-0000e2f0: 6e5f 666f 7277 6172 6420 2a20 2869 6e76  n_forward * (inv
-0000e300: 5f73 7465 7020 2b20 3129 202b 206e 5f62  _step + 1) + n_b
-0000e310: 6163 6b77 6172 6420 2a20 2869 6e76 5f73  ackward * (inv_s
-0000e320: 7465 7020 2d20 3129 202d 206e 5f63 656e  tep - 1) - n_cen
-0000e330: 7465 7220 2a20 696e 765f 7374 6570 202a  ter * inv_step *
-0000e340: 2032 290a 2020 2020 2020 2020 2020 2020   2).            
-0000e350: 2a20 6672 6571 732e 7265 7368 6170 6528  * freqs.reshape(
-0000e360: 282d 312c 2031 2929 0a20 2020 2020 2020  (-1, 1)).       
-0000e370: 2020 2020 202a 2028 2d31 6531 3820 2a20       * (-1e18 * 
-0000e380: 696e 765f 7374 6570 202f 2043 5f30 2a2a  inv_step / C_0**
-0000e390: 3229 0a20 2020 2020 2020 2029 0a0a 2020  2).        )..  
-0000e3a0: 2020 2020 2020 6d6f 6465 5f69 6e64 6578        mode_index
-0000e3b0: 203d 206c 6973 7428 7365 6c66 2e6e 5f63   = list(self.n_c
-0000e3c0: 6f6d 706c 6578 2e63 6f6f 7264 735b 226d  omplex.coords["m
-0000e3d0: 6f64 655f 696e 6465 7822 5d2e 7661 6c75  ode_index"].valu
-0000e3e0: 6573 290a 2020 2020 2020 2020 6620 3d20  es).        f = 
-0000e3f0: 6c69 7374 2866 7265 7173 290a 2020 2020  list(freqs).    
-0000e400: 2020 2020 6e5f 6772 6f75 7020 3d20 4772      n_group = Gr
-0000e410: 6f75 7049 6e64 6578 4461 7461 4172 7261  oupIndexDataArra
-0000e420: 7928 0a20 2020 2020 2020 2020 2020 206e  y(.            n
-0000e430: 5f67 726f 7570 5f64 6174 612c 0a20 2020  _group_data,.   
-0000e440: 2020 2020 2020 2020 2063 6f6f 7264 733d           coords=
-0000e450: 7b22 6622 3a20 662c 2022 6d6f 6465 5f69  {"f": f, "mode_i
-0000e460: 6e64 6578 223a 206d 6f64 655f 696e 6465  ndex": mode_inde
-0000e470: 787d 2c0a 2020 2020 2020 2020 290a 0a20  x},.        ).. 
-0000e480: 2020 2020 2020 2064 6973 7065 7273 696f         dispersio
-0000e490: 6e20 3d20 4d6f 6465 4469 7370 6572 7369  n = ModeDispersi
-0000e4a0: 6f6e 4461 7461 4172 7261 7928 0a20 2020  onDataArray(.   
-0000e4b0: 2020 2020 2020 2020 2064 6973 7065 7273           dispers
-0000e4c0: 696f 6e5f 6461 7461 2c0a 2020 2020 2020  ion_data,.      
-0000e4d0: 2020 2020 2020 636f 6f72 6473 3d7b 2266        coords={"f
-0000e4e0: 223a 2066 2c20 226d 6f64 655f 696e 6465  ": f, "mode_inde
-0000e4f0: 7822 3a20 6d6f 6465 5f69 6e64 6578 7d2c  x": mode_index},
-0000e500: 0a20 2020 2020 2020 2029 0a0a 2020 2020  .        )..    
-0000e510: 2020 2020 2320 7265 6d6f 7665 2064 6174      # remove dat
-0000e520: 6120 636f 7272 6573 706f 6e64 696e 6720  a corresponding 
-0000e530: 746f 2066 7265 7175 656e 6369 6573 2075  to frequencies u
-0000e540: 7365 6420 6f6e 6c79 2066 6f72 2067 726f  sed only for gro
-0000e550: 7570 2069 6e64 6578 2063 616c 6375 6c61  up index calcula
-0000e560: 7469 6f6e 0a20 2020 2020 2020 2075 7064  tion.        upd
-0000e570: 6174 655f 6469 6374 203d 207b 0a20 2020  ate_dict = {.   
-0000e580: 2020 2020 2020 2020 2022 6e5f 636f 6d70           "n_comp
-0000e590: 6c65 7822 3a20 7365 6c66 2e6e 5f63 6f6d  lex": self.n_com
-0000e5a0: 706c 6578 2e69 7365 6c28 663d 6365 6e74  plex.isel(f=cent
-0000e5b0: 6572 292c 0a20 2020 2020 2020 2020 2020  er),.           
-0000e5c0: 2022 6e5f 6772 6f75 705f 7261 7722 3a20   "n_group_raw": 
-0000e5d0: 6e5f 6772 6f75 702c 0a20 2020 2020 2020  n_group,.       
-0000e5e0: 2020 2020 2022 6469 7370 6572 7369 6f6e       "dispersion
-0000e5f0: 5f72 6177 223a 2064 6973 7065 7273 696f  _raw": dispersio
-0000e600: 6e2c 0a20 2020 2020 2020 207d 0a0a 2020  n,.        }..  
-0000e610: 2020 2020 2020 666f 7220 6b65 792c 2066        for key, f
-0000e620: 6965 6c64 2069 6e20 7365 6c66 2e66 6965  ield in self.fie
-0000e630: 6c64 5f63 6f6d 706f 6e65 6e74 732e 6974  ld_components.it
-0000e640: 656d 7328 293a 0a20 2020 2020 2020 2020  ems():.         
-0000e650: 2020 2075 7064 6174 655f 6469 6374 5b6b     update_dict[k
-0000e660: 6579 5d20 3d20 6669 656c 642e 6973 656c  ey] = field.isel
-0000e670: 2866 3d63 656e 7465 7229 0a0a 2020 2020  (f=center)..    
-0000e680: 2020 2020 666f 7220 6b65 792c 2064 6174      for key, dat
-0000e690: 6120 696e 2073 656c 662e 5f67 7269 645f  a in self._grid_
-0000e6a0: 636f 7272 6563 7469 6f6e 5f64 6963 742e  correction_dict.
-0000e6b0: 6974 656d 7328 293a 0a20 2020 2020 2020  items():.       
-0000e6c0: 2020 2020 2075 7064 6174 655f 6469 6374       update_dict
-0000e6d0: 5b6b 6579 5d20 3d20 6461 7461 2e69 7365  [key] = data.ise
-0000e6e0: 6c28 663d 6365 6e74 6572 290a 0a20 2020  l(f=center)..   
-0000e6f0: 2020 2020 2069 6620 7365 6c66 2e65 7073       if self.eps
-0000e700: 5f73 7065 633a 0a20 2020 2020 2020 2020  _spec:.         
-0000e710: 2020 2075 7064 6174 655f 6469 6374 5b22     update_dict["
-0000e720: 6570 735f 7370 6563 225d 203d 2073 656c  eps_spec"] = sel
-0000e730: 662e 6570 735f 7370 6563 5b63 656e 7465  f.eps_spec[cente
-0000e740: 725d 0a0a 2020 2020 2020 2020 7570 6461  r]..        upda
-0000e750: 7465 5f64 6963 745b 226d 6f6e 6974 6f72  te_dict["monitor
-0000e760: 225d 203d 2073 656c 662e 6d6f 6e69 746f  "] = self.monito
-0000e770: 722e 7570 6461 7465 645f 636f 7079 2866  r.updated_copy(f
-0000e780: 7265 7173 3d66 7265 7173 290a 0a20 2020  reqs=freqs)..   
-0000e790: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-0000e7a0: 2e63 6f70 7928 7570 6461 7465 3d75 7064  .copy(update=upd
-0000e7b0: 6174 655f 6469 6374 290a 0a20 2020 2040  ate_dict)..    @
-0000e7c0: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
-0000e7d0: 2074 696d 655f 7265 7665 7273 6564 5f63   time_reversed_c
-0000e7e0: 6f70 7928 7365 6c66 2920 2d3e 2046 6965  opy(self) -> Fie
-0000e7f0: 6c64 4461 7461 3a0a 2020 2020 2020 2020  ldData:.        
-0000e800: 2222 224d 616b 6520 6120 636f 7079 206f  """Make a copy o
-0000e810: 6620 7468 6520 6461 7461 2077 6974 6820  f the data with 
-0000e820: 6469 7265 6374 696f 6e2d 7265 7665 7273  direction-revers
-0000e830: 6564 2066 6965 6c64 732e 2049 6e20 6c6f  ed fields. In lo
-0000e840: 7373 7920 6f72 2067 7972 6f74 726f 7069  ssy or gyrotropi
-0000e850: 6320 7379 7374 656d 732c 0a20 2020 2020  c systems,.     
-0000e860: 2020 2074 6865 2074 696d 652d 7265 7665     the time-reve
-0000e870: 7273 6564 2066 6965 6c64 7320 7769 6c6c  rsed fields will
-0000e880: 206e 6f74 2062 6520 7468 6520 7361 6d65   not be the same
-0000e890: 2061 7320 7468 6520 6261 636b 7761 7264   as the backward
-0000e8a0: 2d70 726f 7061 6761 7469 6e67 206d 6f64  -propagating mod
-0000e8b0: 6573 2e22 2222 0a0a 2020 2020 2020 2020  es."""..        
-0000e8c0: 2320 5469 6d65 2072 6576 6572 7361 6c0a  # Time reversal.
-0000e8d0: 2020 2020 2020 2020 6e65 775f 6461 7461          new_data
-0000e8e0: 203d 207b 7d0a 2020 2020 2020 2020 666f   = {}.        fo
-0000e8f0: 7220 636f 6d70 2c20 6669 656c 6420 696e  r comp, field in
-0000e900: 2073 656c 662e 6669 656c 645f 636f 6d70   self.field_comp
-0000e910: 6f6e 656e 7473 2e69 7465 6d73 2829 3a0a  onents.items():.
-0000e920: 2020 2020 2020 2020 2020 2020 6966 2063              if c
-0000e930: 6f6d 705b 305d 203d 3d20 2248 223a 0a20  omp[0] == "H":. 
-0000e940: 2020 2020 2020 2020 2020 2020 2020 206e                 n
-0000e950: 6577 5f64 6174 615b 636f 6d70 5d20 3d20  ew_data[comp] = 
-0000e960: 2d6e 702e 636f 6e6a 2866 6965 6c64 290a  -np.conj(field).
-0000e970: 2020 2020 2020 2020 2020 2020 656c 7365              else
-0000e980: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000e990: 2020 6e65 775f 6461 7461 5b63 6f6d 705d    new_data[comp]
-0000e9a0: 203d 206e 702e 636f 6e6a 2866 6965 6c64   = np.conj(field
-0000e9b0: 290a 0a20 2020 2020 2020 2023 2073 7769  )..        # swi
-0000e9c0: 7463 6820 6469 7265 6374 696f 6e20 696e  tch direction in
-0000e9d0: 2074 6865 206d 6f6e 6974 6f72 0a20 2020   the monitor.   
-0000e9e0: 2020 2020 206d 6e74 203d 2073 656c 662e       mnt = self.
-0000e9f0: 6d6f 6e69 746f 720a 2020 2020 2020 2020  monitor.        
-0000ea00: 6e65 775f 6469 7220 3d20 222b 2220 6966  new_dir = "+" if
-0000ea10: 206d 6e74 2e73 746f 7265 5f66 6965 6c64   mnt.store_field
-0000ea20: 735f 6469 7265 6374 696f 6e20 3d3d 2022  s_direction == "
-0000ea30: 2d22 2065 6c73 6520 222d 220a 2020 2020  -" else "-".    
-0000ea40: 2020 2020 6e65 775f 6461 7461 5b22 6d6f      new_data["mo
-0000ea50: 6e69 746f 7222 5d20 3d20 6d6e 742e 7570  nitor"] = mnt.up
-0000ea60: 6461 7465 645f 636f 7079 2873 746f 7265  dated_copy(store
-0000ea70: 5f66 6965 6c64 735f 6469 7265 6374 696f  _fields_directio
-0000ea80: 6e3d 6e65 775f 6469 7229 0a20 2020 2020  n=new_dir).     
-0000ea90: 2020 2072 6574 7572 6e20 7365 6c66 2e63     return self.c
-0000eaa0: 6f70 7928 7570 6461 7465 3d6e 6577 5f64  opy(update=new_d
-0000eab0: 6174 6129 0a0a 2020 2020 6465 6620 5f63  ata)..    def _c
-0000eac0: 6f6c 6f63 6174 6564 5f70 726f 7061 6761  olocated_propaga
-0000ead0: 7469 6f6e 5f61 7865 735f 6669 656c 6428  tion_axes_field(
-0000eae0: 7365 6c66 2c20 6669 656c 645f 6e61 6d65  self, field_name
-0000eaf0: 3a20 4c69 7465 7261 6c5b 2245 222c 2022  : Literal["E", "
-0000eb00: 4822 5d29 202d 3e20 7872 2e44 6174 6141  H"]) -> xr.DataA
-0000eb10: 7272 6179 3a0a 2020 2020 2020 2020 2222  rray:.        ""
-0000eb20: 2243 6f6c 6c65 6374 2061 2066 6965 6c64  "Collect a field
-0000eb30: 2044 6174 6141 7272 6179 2063 6f6e 7461   DataArray conta
-0000eb40: 696e 696e 6720 616c 6c20 3320 6669 656c  ining all 3 fiel
-0000eb50: 6420 636f 6d70 6f6e 656e 7473 2061 6e64  d components and
-0000eb60: 2072 6f74 6174 6520 6672 6f6d 2066 7261   rotate from fra
-0000eb70: 6d65 0a20 2020 2020 2020 2077 6974 6820  me.        with 
-0000eb80: 6e6f 726d 616c 2061 7869 7320 616c 6f6e  normal axis alon
-0000eb90: 6720 7a20 746f 2066 7261 6d65 2077 6974  g z to frame wit
-0000eba0: 6820 7072 6f70 6167 6174 696f 6e20 6178  h propagation ax
-0000ebb0: 6973 2061 6c6f 6e67 207a 2e0a 2020 2020  is along z..    
-0000ebc0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-0000ebd0: 7461 6e5f 6469 6d73 203d 2073 656c 662e  tan_dims = self.
-0000ebe0: 5f74 616e 6765 6e74 6961 6c5f 6469 6d73  _tangential_dims
-0000ebf0: 0a20 2020 2020 2020 206e 6f72 6d61 6c5f  .        normal_
-0000ec00: 6469 6d20 3d20 2278 797a 225b 7365 6c66  dim = "xyz"[self
-0000ec10: 2e6d 6f6e 6974 6f72 2e7a 6572 6f5f 6469  .monitor.zero_di
-0000ec20: 6d73 5b30 5d5d 0a20 2020 2020 2020 2066  ms[0]].        f
-0000ec30: 6965 6c64 7320 3d20 7365 6c66 2e5f 636f  ields = self._co
-0000ec40: 6c6f 6361 7465 645f 6669 656c 6473 0a20  located_fields. 
-0000ec50: 2020 2020 2020 2066 6965 6c64 7320 3d20         fields = 
-0000ec60: 7b6b 6579 3a20 7661 6c2e 7371 7565 657a  {key: val.squeez
-0000ec70: 6528 6469 6d3d 6e6f 726d 616c 5f64 696d  e(dim=normal_dim
-0000ec80: 2c20 6472 6f70 3d54 7275 6529 2066 6f72  , drop=True) for
-0000ec90: 206b 6579 2c20 7661 6c20 696e 2066 6965   key, val in fie
-0000eca0: 6c64 732e 6974 656d 7328 297d 0a20 2020  lds.items()}.   
-0000ecb0: 2020 2020 206d 6f64 655f 7370 6563 203d       mode_spec =
-0000ecc0: 2073 656c 662e 6d6f 6e69 746f 722e 6d6f   self.monitor.mo
-0000ecd0: 6465 5f73 7065 630a 0a20 2020 2020 2020  de_spec..       
-0000ece0: 2023 2066 6965 6c64 7320 6173 2061 2028   # fields as a (
-0000ecf0: 332c 202e 2e2e 2920 6e75 6d70 7920 6172  3, ...) numpy ar
-0000ed00: 7261 7920 6f72 6465 7265 6420 6173 205b  ray ordered as [
-0000ed10: 7461 6e67 656e 7469 616c 312c 2074 6167  tangential1, tag
-0000ed20: 656e 7469 616c 322c 206e 6f72 6d61 6c5d  ential2, normal]
-0000ed30: 0a20 2020 2020 2020 2066 6965 6c64 203d  .        field =
-0000ed40: 205b 6669 656c 6473 5b66 6965 6c64 5f6e   [fields[field_n
-0000ed50: 616d 6520 2b20 6469 6d5d 2e76 616c 7565  ame + dim].value
-0000ed60: 7320 666f 7220 6469 6d20 696e 2074 616e  s for dim in tan
-0000ed70: 5f64 696d 735d 0a20 2020 2020 2020 2066  _dims].        f
-0000ed80: 6965 6c64 203d 206e 702e 6172 7261 7928  ield = np.array(
-0000ed90: 6669 656c 6420 2b20 5b66 6965 6c64 735b  field + [fields[
-0000eda0: 6669 656c 645f 6e61 6d65 202b 206e 6f72  field_name + nor
-0000edb0: 6d61 6c5f 6469 6d5d 2e76 616c 7565 735d  mal_dim].values]
-0000edc0: 290a 0a20 2020 2020 2020 2023 2072 6f74  )..        # rot
-0000edd0: 6174 6520 6178 6573 0a20 2020 2020 2020  ate axes.       
-0000ede0: 2069 6620 6d6f 6465 5f73 7065 632e 616e   if mode_spec.an
-0000edf0: 676c 655f 7068 6920 213d 2030 3a0a 2020  gle_phi != 0:.  
-0000ee00: 2020 2020 2020 2020 2020 6669 656c 6420            field 
-0000ee10: 3d20 7365 6c66 2e6d 6f6e 6974 6f72 2e72  = self.monitor.r
-0000ee20: 6f74 6174 655f 706f 696e 7473 2866 6965  otate_points(fie
-0000ee30: 6c64 2c20 5b30 2c20 302c 2031 5d2c 202d  ld, [0, 0, 1], -
-0000ee40: 6d6f 6465 5f73 7065 632e 616e 676c 655f  mode_spec.angle_
-0000ee50: 7068 6929 0a20 2020 2020 2020 2069 6620  phi).        if 
-0000ee60: 6d6f 6465 5f73 7065 632e 616e 676c 655f  mode_spec.angle_
-0000ee70: 7468 6574 6120 213d 2030 3a0a 2020 2020  theta != 0:.    
-0000ee80: 2020 2020 2020 2020 6669 656c 6420 3d20          field = 
-0000ee90: 7365 6c66 2e6d 6f6e 6974 6f72 2e72 6f74  self.monitor.rot
-0000eea0: 6174 655f 706f 696e 7473 2866 6965 6c64  ate_points(field
-0000eeb0: 2c20 5b30 2c20 312c 2030 5d2c 202d 6d6f  , [0, 1, 0], -mo
-0000eec0: 6465 5f73 7065 632e 616e 676c 655f 7468  de_spec.angle_th
-0000eed0: 6574 6129 0a0a 2020 2020 2020 2020 2320  eta)..        # 
-0000eee0: 6e65 7720 636f 6f72 6473 2066 6f72 2074  new coords for t
-0000eef0: 6865 2028 332c 202e 2e2e 2920 6172 7261  he (3, ...) arra
-0000ef00: 790a 2020 2020 2020 2020 636f 6f72 6473  y.        coords
-0000ef10: 203d 207b 2263 6f6d 706f 6e65 6e74 223a   = {"component":
-0000ef20: 205b 302c 2031 2c20 325d 7d0a 2020 2020   [0, 1, 2]}.    
-0000ef30: 2020 2020 2320 6669 656c 6473 2061 7265      # fields are
-0000ef40: 2063 6f6c 6f63 6174 6564 2c20 736f 2061   colocated, so a
-0000ef50: 6c6c 2063 6f6d 706f 6e65 6e74 7320 7368  ll components sh
-0000ef60: 6f75 6c64 2068 6176 6520 7468 6520 7361  ould have the sa
-0000ef70: 6d65 2063 6f6f 7264 730a 2020 2020 2020  me coords.      
-0000ef80: 2020 666f 7220 6469 6d20 696e 2066 6965    for dim in fie
-0000ef90: 6c64 735b 2245 7822 5d2e 6469 6d73 3a0a  lds["Ex"].dims:.
-0000efa0: 2020 2020 2020 2020 2020 2020 636f 6f72              coor
-0000efb0: 6473 2e75 7064 6174 6528 7b64 696d 3a20  ds.update({dim: 
-0000efc0: 6669 656c 6473 5b22 4578 225d 2e63 6f6f  fields["Ex"].coo
-0000efd0: 7264 735b 6469 6d5d 7d29 0a0a 2020 2020  rds[dim]})..    
-0000efe0: 2020 2020 7265 7475 726e 2078 722e 4461      return xr.Da
-0000eff0: 7461 4172 7261 7928 6461 7461 3d66 6965  taArray(data=fie
-0000f000: 6c64 2c20 636f 6f72 6473 3d63 6f6f 7264  ld, coords=coord
-0000f010: 7329 0a0a 2020 2020 4063 6163 6865 645f  s)..    @cached_
-0000f020: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
-0000f030: 2070 6f6c 5f66 7261 6374 696f 6e28 7365   pol_fraction(se
-0000f040: 6c66 2920 2d3e 2078 722e 4461 7461 7365  lf) -> xr.Datase
-0000f050: 743a 0a20 2020 2020 2020 2072 2222 2243  t:.        r"""C
-0000f060: 6f6d 7075 7465 2074 6865 2054 4520 616e  ompute the TE an
-0000f070: 6420 544d 2070 6f6c 6172 697a 6174 696f  d TM polarizatio
-0000f080: 6e20 6672 6163 7469 6f6e 2064 6566 696e  n fraction defin
-0000f090: 6564 2061 7320 7468 6520 6669 656c 6420  ed as the field 
-0000f0a0: 696e 7465 6e73 6974 7920 616c 6f6e 6720  intensity along 
-0000f0b0: 7468 650a 2020 2020 2020 2020 6669 7273  the.        firs
-0000f0c0: 7420 6f72 2074 6865 2073 6563 6f6e 6420  t or the second 
-0000f0d0: 6f66 2074 6865 2074 776f 2074 616e 6765  of the two tange
-0000f0e0: 6e74 6961 6c20 6178 6573 2e20 4d6f 7265  ntial axes. More
-0000f0f0: 2070 7265 6369 7365 6c79 2c20 6966 2024   precisely, if $
-0000f100: 455f 3124 2061 6e64 2024 455f 3224 2061  E_1$ and $E_2$ a
-0000f110: 7265 0a20 2020 2020 2020 2074 6865 2065  re.        the e
-0000f120: 6c65 6374 7269 6320 6669 656c 6420 636f  lectric field co
-0000f130: 6d70 6f6e 656e 7473 2061 6c6f 6e67 2074  mponents along t
-0000f140: 6865 2074 776f 2074 616e 6765 6e74 6961  he two tangentia
-0000f150: 6c20 6178 6573 2c20 7468 6520 5445 2066  l axes, the TE f
-0000f160: 7261 6374 696f 6e20 6973 2064 6566 696e  raction is defin
-0000f170: 6564 2061 733a 0a0a 2020 2020 2020 2020  ed as:..        
-0000f180: 2e2e 206d 6174 683a 3a0a 0a20 2020 2020  .. math::..     
-0000f190: 2020 2020 2020 5c66 7261 637b 5c69 6e74        \frac{\int
-0000f1a0: 207c 455f 317c 5e32 205c 2c20 7b5c 726d   |E_1|^2 \, {\rm
-0000f1b0: 2064 7d53 7d7b 5c69 6e74 205c 6c65 6674   d}S}{\int \left
-0000f1c0: 287c 455f 317c 5e32 202b 207c 455f 327c  (|E_1|^2 + |E_2|
-0000f1d0: 5e32 5c72 6967 6874 2920 5c2c 207b 5c72  ^2\right) \, {\r
-0000f1e0: 6d20 647d 537d 0a0a 2020 2020 2020 2020  m d}S}..        
-0000f1f0: 616e 6420 7468 6520 544d 2066 7261 6374  and the TM fract
-0000f200: 696f 6e20 6973 2065 7175 616c 2074 6f20  ion is equal to 
-0000f210: 6f6e 6520 6d69 6e75 7320 7468 6520 5445  one minus the TE
-0000f220: 2066 7261 6374 696f 6e2e 2054 6865 2074   fraction. The t
-0000f230: 616e 6765 6e74 6961 6c20 6178 6573 2061  angential axes a
-0000f240: 7265 2064 6566 696e 6564 0a20 2020 2020  re defined.     
-0000f250: 2020 2062 7920 706f 7070 696e 6720 7468     by popping th
-0000f260: 6520 6e6f 726d 616c 2061 7869 7320 6672  e normal axis fr
-0000f270: 6f6d 2074 6865 206c 6973 7420 6f66 2060  om the list of `
-0000f280: 6078 2c20 792c 207a 6060 2c20 736f 2065  `x, y, z``, so e
-0000f290: 2e67 2e20 6060 7860 6020 616e 6420 6060  .g. ``x`` and ``
-0000f2a0: 7a60 6020 666f 720a 2020 2020 2020 2020  z`` for.        
-0000f2b0: 7072 6f70 6167 6174 696f 6e20 696e 2074  propagation in t
-0000f2c0: 6865 2060 6079 6060 2064 6972 6563 7469  he ``y`` directi
-0000f2d0: 6f6e 2e0a 2020 2020 2020 2020 2222 220a  on..        """.
-0000f2e0: 2020 2020 2020 2020 6966 206c 656e 2873          if len(s
-0000f2f0: 656c 662e 6669 656c 645f 636f 6d70 6f6e  elf.field_compon
-0000f300: 656e 7473 2920 3d3d 2030 3a0a 2020 2020  ents) == 0:.    
-0000f310: 2020 2020 2020 2020 7261 6973 6520 4461          raise Da
-0000f320: 7461 4572 726f 7228 0a20 2020 2020 2020  taError(.       
-0000f330: 2020 2020 2020 2020 2022 4669 656c 6420           "Field 
-0000f340: 6461 7461 206e 6f74 2069 6e63 6c75 6465  data not include
-0000f350: 6420 696e 2074 6869 7320 4d6f 6465 4461  d in this ModeDa
-0000f360: 7461 206f 6e62 6a65 6374 2e20 5365 7420  ta onbject. Set 
-0000f370: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
-0000f380: 2020 2227 4d6f 6465 4d6f 6e69 746f 722e    "'ModeMonitor.
-0000f390: 7374 6f72 655f 6669 656c 6473 5f64 6972  store_fields_dir
-0000f3a0: 6563 7469 6f6e 2720 746f 2074 6865 2064  ection' to the d
-0000f3b0: 6573 6972 6564 2070 726f 7061 6761 7469  esired propagati
-0000f3c0: 6f6e 2064 6972 6563 7469 6f6e 2074 6f20  on direction to 
-0000f3d0: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
-0000f3e0: 2020 2269 6e63 6c75 6465 2074 6865 206d    "include the m
-0000f3f0: 6f64 6520 6669 656c 6420 7072 6f66 696c  ode field profil
-0000f400: 6573 2069 6e20 7468 6520 636f 7272 6573  es in the corres
-0000f410: 706f 6e64 696e 6720 274d 6f64 6544 6174  ponding 'ModeDat
-0000f420: 6127 2e22 0a20 2020 2020 2020 2020 2020  a'.".           
-0000f430: 2029 0a0a 2020 2020 2020 2020 7461 6e5f   )..        tan_
-0000f440: 6469 6d73 203d 2073 656c 662e 5f74 616e  dims = self._tan
-0000f450: 6765 6e74 6961 6c5f 6469 6d73 0a20 2020  gential_dims.   
-0000f460: 2020 2020 2065 5f66 6965 6c64 203d 2073       e_field = s
-0000f470: 656c 662e 5f63 6f6c 6f63 6174 6564 5f70  elf._colocated_p
-0000f480: 726f 7061 6761 7469 6f6e 5f61 7865 735f  ropagation_axes_
-0000f490: 6669 656c 6428 2245 2229 0a20 2020 2020  field("E").     
-0000f4a0: 2020 2064 6966 665f 6172 6561 203d 2073     diff_area = s
-0000f4b0: 656c 662e 5f64 6966 665f 6172 6561 0a20  elf._diff_area. 
-0000f4c0: 2020 2020 2020 2074 6d5f 696e 7420 3d20         tm_int = 
-0000f4d0: 2864 6966 665f 6172 6561 202a 206e 702e  (diff_area * np.
-0000f4e0: 6162 7328 655f 6669 656c 642e 7365 6c28  abs(e_field.sel(
-0000f4f0: 636f 6d70 6f6e 656e 743d 312c 2064 726f  component=1, dro
-0000f500: 703d 5472 7565 2929 202a 2a20 3229 2e73  p=True)) ** 2).s
-0000f510: 756d 2864 696d 3d74 616e 5f64 696d 7329  um(dim=tan_dims)
-0000f520: 0a20 2020 2020 2020 2074 655f 696e 7420  .        te_int 
-0000f530: 3d20 2864 6966 665f 6172 6561 202a 206e  = (diff_area * n
-0000f540: 702e 6162 7328 655f 6669 656c 642e 7365  p.abs(e_field.se
-0000f550: 6c28 636f 6d70 6f6e 656e 743d 302c 2064  l(component=0, d
-0000f560: 726f 703d 5472 7565 2929 202a 2a20 3229  rop=True)) ** 2)
-0000f570: 2e73 756d 2864 696d 3d74 616e 5f64 696d  .sum(dim=tan_dim
-0000f580: 7329 0a20 2020 2020 2020 2074 655f 6672  s).        te_fr
-0000f590: 6163 203d 2074 655f 696e 7420 2f20 2874  ac = te_int / (t
-0000f5a0: 655f 696e 7420 2b20 746d 5f69 6e74 290a  e_int + tm_int).
-0000f5b0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-0000f5c0: 7872 2e44 6174 6173 6574 2864 6174 615f  xr.Dataset(data_
-0000f5d0: 7661 7273 3d7b 2274 6522 3a20 7465 5f66  vars={"te": te_f
-0000f5e0: 7261 632c 2022 746d 223a 2031 202d 2074  rac, "tm": 1 - t
-0000f5f0: 655f 6672 6163 7d29 0a0a 2020 2020 4063  e_frac})..    @c
-0000f600: 6163 6865 645f 7072 6f70 6572 7479 0a20  ached_property. 
-0000f610: 2020 2064 6566 2070 6f6c 5f66 7261 6374     def pol_fract
-0000f620: 696f 6e5f 7761 7665 6775 6964 6528 7365  ion_waveguide(se
-0000f630: 6c66 2920 2d3e 2078 722e 4461 7461 7365  lf) -> xr.Datase
-0000f640: 743a 0a20 2020 2020 2020 2072 2222 2243  t:.        r"""C
-0000f650: 6f6d 7075 7465 2074 6865 2054 4520 616e  ompute the TE an
-0000f660: 6420 544d 2070 6f6c 6172 697a 6174 696f  d TM polarizatio
-0000f670: 6e20 6672 6163 7469 6f6e 2075 7369 6e67  n fraction using
-0000f680: 2074 6865 2077 6176 6567 7569 6465 2064   the waveguide d
-0000f690: 6566 696e 6974 696f 6e2e 2049 6620 246e  efinition. If $n
-0000f6a0: 2420 6973 0a20 2020 2020 2020 2074 6865  $ is.        the
-0000f6b0: 2070 726f 7061 6761 7469 6f6e 2064 6972   propagation dir
-0000f6c0: 6563 7469 6f6e 2c20 7468 6520 5445 2066  ection, the TE f
-0000f6d0: 7261 6374 696f 6e20 6973 2064 6566 696e  raction is defin
-0000f6e0: 6564 2061 733a 0a0a 2020 2020 2020 2020  ed as:..        
-0000f6f0: 2e2e 206d 6174 683a 3a0a 0a20 2020 2020  .. math::..     
-0000f700: 2020 2020 2020 3120 2d20 5c66 7261 637b        1 - \frac{
-0000f710: 5c69 6e74 207c 4520 5c63 646f 7420 6e7c  \int |E \cdot n|
-0000f720: 5e32 205c 2c20 7b5c 726d 2064 7d53 7d7b  ^2 \, {\rm d}S}{
-0000f730: 5c69 6e74 207c 457c 5e32 205c 2c20 7b5c  \int |E|^2 \, {\
-0000f740: 726d 2064 7d53 7d0a 0a20 2020 2020 2020  rm d}S}..       
-0000f750: 2061 6e64 2074 6865 2054 4d20 6672 6163   and the TM frac
-0000f760: 7469 6f6e 2069 7320 6465 6669 6e65 6420  tion is defined 
-0000f770: 6173 0a0a 2020 2020 2020 2020 2e2e 206d  as..        .. m
-0000f780: 6174 683a 3a0a 0a20 2020 2020 2020 2020  ath::..         
-0000f790: 2020 3120 2d20 5c66 7261 637b 5c69 6e74    1 - \frac{\int
-0000f7a0: 207c 4820 5c63 646f 7420 6e7c 5e32 205c   |H \cdot n|^2 \
-0000f7b0: 2c20 7b5c 726d 2064 7d53 7d7b 5c69 6e74  , {\rm d}S}{\int
-0000f7c0: 207c 487c 5e32 205c 2c20 7b5c 726d 2064   |H|^2 \, {\rm d
-0000f7d0: 7d53 7d0a 0a20 2020 2020 2020 204e 6f74  }S}..        Not
-0000f7e0: 650a 2020 2020 2020 2020 2d2d 2d2d 0a20  e.        ----. 
-0000f7f0: 2020 2020 2020 2020 2020 2054 6865 2077             The w
-0000f800: 6176 6567 7569 6465 2054 4520 616e 6420  aveguide TE and 
-0000f810: 544d 2066 7261 6374 696f 6e73 2064 6f20  TM fractions do 
-0000f820: 6e6f 7420 7375 6d20 746f 206f 6e65 2e20  not sum to one. 
-0000f830: 466f 7220 6578 616d 706c 652c 2054 454d  For example, TEM
-0000f840: 206d 6f64 6573 2074 6861 740a 2020 2020   modes that.    
-0000f850: 2020 2020 2020 2020 6172 6520 636f 6d70          are comp
-0000f860: 6c65 7465 6c79 2074 7261 6e73 7665 7273  letely transvers
-0000f870: 6520 287a 6572 6f20 656c 6563 7472 6963  e (zero electric
-0000f880: 2061 6e64 206d 6167 6e65 7469 6320 6669   and magnetic fi
-0000f890: 656c 6420 696e 2074 6865 2070 726f 7061  eld in the propa
-0000f8a0: 6761 7469 6f6e 0a20 2020 2020 2020 2020  gation.         
-0000f8b0: 2020 2064 6972 6563 7469 6f6e 2920 6861     direction) ha
-0000f8c0: 7665 2054 4520 6672 6163 7469 6f6e 2061  ve TE fraction a
-0000f8d0: 6e64 2054 4d20 6672 6163 7469 6f6e 2062  nd TM fraction b
-0000f8e0: 6f74 6820 6571 7561 6c20 746f 206f 6e65  oth equal to one
-0000f8f0: 2e0a 2020 2020 2020 2020 2222 220a 2020  ..        """.  
-0000f900: 2020 2020 2020 6966 206c 656e 2873 656c        if len(sel
-0000f910: 662e 6669 656c 645f 636f 6d70 6f6e 656e  f.field_componen
-0000f920: 7473 2920 3d3d 2030 3a0a 2020 2020 2020  ts) == 0:.      
-0000f930: 2020 2020 2020 7261 6973 6520 4461 7461        raise Data
-0000f940: 4572 726f 7228 0a20 2020 2020 2020 2020  Error(.         
-0000f950: 2020 2020 2020 2022 4669 656c 6420 6461         "Field da
-0000f960: 7461 206e 6f74 2069 6e63 6c75 6465 6420  ta not included 
-0000f970: 696e 2074 6869 7320 4d6f 6465 4461 7461  in this ModeData
-0000f980: 206f 6e62 6a65 6374 2e20 5365 7420 220a   onbject. Set ".
-0000f990: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f9a0: 2227 4d6f 6465 4d6f 6e69 746f 722e 7374  "'ModeMonitor.st
-0000f9b0: 6f72 655f 6669 656c 6473 5f64 6972 6563  ore_fields_direc
-0000f9c0: 7469 6f6e 2720 746f 2074 6865 2064 6573  tion' to the des
-0000f9d0: 6972 6564 2070 726f 7061 6761 7469 6f6e  ired propagation
-0000f9e0: 2064 6972 6563 7469 6f6e 2074 6f20 220a   direction to ".
-0000f9f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fa00: 2269 6e63 6c75 6465 2074 6865 206d 6f64  "include the mod
-0000fa10: 6520 6669 656c 6420 7072 6f66 696c 6573  e field profiles
-0000fa20: 2069 6e20 7468 6520 636f 7272 6573 706f   in the correspo
-0000fa30: 6e64 696e 6720 274d 6f64 6544 6174 6127  nding 'ModeData'
-0000fa40: 2e22 0a20 2020 2020 2020 2020 2020 2029  .".            )
-0000fa50: 0a0a 2020 2020 2020 2020 7461 6e5f 6469  ..        tan_di
-0000fa60: 6d73 203d 2073 656c 662e 5f74 616e 6765  ms = self._tange
-0000fa70: 6e74 6961 6c5f 6469 6d73 0a20 2020 2020  ntial_dims.     
-0000fa80: 2020 2065 5f66 6965 6c64 203d 2073 656c     e_field = sel
-0000fa90: 662e 5f63 6f6c 6f63 6174 6564 5f70 726f  f._colocated_pro
-0000faa0: 7061 6761 7469 6f6e 5f61 7865 735f 6669  pagation_axes_fi
-0000fab0: 656c 6428 2245 2229 0a20 2020 2020 2020  eld("E").       
-0000fac0: 2068 5f66 6965 6c64 203d 2073 656c 662e   h_field = self.
-0000fad0: 5f63 6f6c 6f63 6174 6564 5f70 726f 7061  _colocated_propa
-0000fae0: 6761 7469 6f6e 5f61 7865 735f 6669 656c  gation_axes_fiel
-0000faf0: 6428 2248 2229 0a20 2020 2020 2020 2064  d("H").        d
-0000fb00: 6966 665f 6172 6561 203d 2073 656c 662e  iff_area = self.
-0000fb10: 5f64 6966 665f 6172 6561 0a0a 2020 2020  _diff_area..    
-0000fb20: 2020 2020 2320 7465 2066 7261 6374 696f      # te fractio
-0000fb30: 6e0a 2020 2020 2020 2020 6669 656c 645f  n.        field_
-0000fb40: 696e 7420 3d20 5b6e 702e 6162 7328 655f  int = [np.abs(e_
-0000fb50: 6669 656c 642e 7365 6c28 636f 6d70 6f6e  field.sel(compon
-0000fb60: 656e 743d 696e 642c 2064 726f 703d 5472  ent=ind, drop=Tr
-0000fb70: 7565 2929 202a 2a20 3220 666f 7220 696e  ue)) ** 2 for in
-0000fb80: 6420 696e 2072 616e 6765 2833 295d 0a20  d in range(3)]. 
-0000fb90: 2020 2020 2020 206e 6f72 6d5f 696e 7420         norm_int 
-0000fba0: 3d20 2864 6966 665f 6172 6561 202a 2066  = (diff_area * f
-0000fbb0: 6965 6c64 5f69 6e74 5b32 5d29 2e73 756d  ield_int[2]).sum
-0000fbc0: 2864 696d 3d74 616e 5f64 696d 7329 0a20  (dim=tan_dims). 
-0000fbd0: 2020 2020 2020 2074 6f74 5f69 6e74 203d         tot_int =
-0000fbe0: 206e 6f72 6d5f 696e 7420 2b20 2864 6966   norm_int + (dif
-0000fbf0: 665f 6172 6561 202a 2028 6669 656c 645f  f_area * (field_
-0000fc00: 696e 745b 305d 202b 2066 6965 6c64 5f69  int[0] + field_i
-0000fc10: 6e74 5b31 5d29 292e 7375 6d28 6469 6d3d  nt[1])).sum(dim=
-0000fc20: 7461 6e5f 6469 6d73 290a 2020 2020 2020  tan_dims).      
-0000fc30: 2020 7465 5f66 7261 6320 3d20 3120 2d20    te_frac = 1 - 
-0000fc40: 6e6f 726d 5f69 6e74 202f 2074 6f74 5f69  norm_int / tot_i
-0000fc50: 6e74 0a0a 2020 2020 2020 2020 2320 746d  nt..        # tm
-0000fc60: 2066 7261 6374 696f 6e0a 2020 2020 2020   fraction.      
-0000fc70: 2020 6669 656c 645f 696e 7420 3d20 5b6e    field_int = [n
-0000fc80: 702e 6162 7328 685f 6669 656c 642e 7365  p.abs(h_field.se
-0000fc90: 6c28 636f 6d70 6f6e 656e 743d 696e 642c  l(component=ind,
-0000fca0: 2064 726f 703d 5472 7565 2929 202a 2a20   drop=True)) ** 
-0000fcb0: 3220 666f 7220 696e 6420 696e 2072 616e  2 for ind in ran
-0000fcc0: 6765 2833 295d 0a20 2020 2020 2020 206e  ge(3)].        n
-0000fcd0: 6f72 6d5f 696e 7420 3d20 2864 6966 665f  orm_int = (diff_
-0000fce0: 6172 6561 202a 2066 6965 6c64 5f69 6e74  area * field_int
-0000fcf0: 5b32 5d29 2e73 756d 2864 696d 3d74 616e  [2]).sum(dim=tan
-0000fd00: 5f64 696d 7329 0a20 2020 2020 2020 2074  _dims).        t
-0000fd10: 6f74 5f69 6e74 203d 206e 6f72 6d5f 696e  ot_int = norm_in
-0000fd20: 7420 2b20 2864 6966 665f 6172 6561 202a  t + (diff_area *
-0000fd30: 2028 6669 656c 645f 696e 745b 305d 202b   (field_int[0] +
-0000fd40: 2066 6965 6c64 5f69 6e74 5b31 5d29 292e   field_int[1])).
-0000fd50: 7375 6d28 6469 6d3d 7461 6e5f 6469 6d73  sum(dim=tan_dims
-0000fd60: 290a 2020 2020 2020 2020 746d 5f66 7261  ).        tm_fra
-0000fd70: 6320 3d20 3120 2d20 6e6f 726d 5f69 6e74  c = 1 - norm_int
-0000fd80: 202f 2074 6f74 5f69 6e74 0a0a 2020 2020   / tot_int..    
-0000fd90: 2020 2020 7265 7475 726e 2078 722e 4461      return xr.Da
-0000fda0: 7461 7365 7428 6461 7461 5f76 6172 733d  taset(data_vars=
-0000fdb0: 7b22 7465 223a 2074 655f 6672 6163 2c20  {"te": te_frac, 
-0000fdc0: 2274 6d22 3a20 746d 5f66 7261 637d 290a  "tm": tm_frac}).
-0000fdd0: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
-0000fde0: 2020 2064 6566 206d 6f64 6573 5f69 6e66     def modes_inf
-0000fdf0: 6f28 7365 6c66 2920 2d3e 2078 722e 4461  o(self) -> xr.Da
-0000fe00: 7461 7365 743a 0a20 2020 2020 2020 2022  taset:.        "
-0000fe10: 2222 4461 7461 7365 7420 636f 6c6c 6563  ""Dataset collec
-0000fe20: 7469 6e67 2076 6172 696f 7573 2070 726f  ting various pro
-0000fe30: 7065 7274 6965 7320 6f66 2074 6865 2073  perties of the s
-0000fe40: 746f 7265 6420 6d6f 6465 732e 2222 220a  tored modes.""".
-0000fe50: 0a20 2020 2020 2020 206c 616d 6264 615f  .        lambda_
-0000fe60: 636d 203d 2043 5f30 202f 2073 656c 662e  cm = C_0 / self.
-0000fe70: 6b5f 6566 662e 6620 2f20 3165 340a 2020  k_eff.f / 1e4.  
-0000fe80: 2020 2020 2020 6c6f 7373 5f64 625f 636d        loss_db_cm
-0000fe90: 203d 2032 3020 2a20 3220 2a20 6e70 2e70   = 20 * 2 * np.p
-0000fea0: 6920 2a20 6e70 2e6c 6f67 3130 286e 702e  i * np.log10(np.
-0000feb0: 6529 202a 2073 656c 662e 6b5f 6566 6620  e) * self.k_eff 
-0000fec0: 2f20 6c61 6d62 6461 5f63 6d0a 0a20 2020  / lambda_cm..   
-0000fed0: 2020 2020 2069 6e66 6f20 3d20 7b0a 2020       info = {.  
-0000fee0: 2020 2020 2020 2020 2020 2277 6176 656c            "wavel
-0000fef0: 656e 6774 6822 3a20 435f 3020 2f20 7365  ength": C_0 / se
-0000ff00: 6c66 2e6e 5f65 6666 2e66 2c0a 2020 2020  lf.n_eff.f,.    
-0000ff10: 2020 2020 2020 2020 226e 2065 6666 223a          "n eff":
-0000ff20: 2073 656c 662e 6e5f 6566 662c 0a20 2020   self.n_eff,.   
-0000ff30: 2020 2020 2020 2020 2022 6b20 6566 6622           "k eff"
-0000ff40: 3a20 7365 6c66 2e6b 5f65 6666 2c0a 2020  : self.k_eff,.  
-0000ff50: 2020 2020 2020 2020 2020 226c 6f73 7320            "loss 
-0000ff60: 2864 422f 636d 2922 3a20 6c6f 7373 5f64  (dB/cm)": loss_d
-0000ff70: 625f 636d 2c0a 2020 2020 2020 2020 2020  b_cm,.          
-0000ff80: 2020 6622 5445 2028 457b 7365 6c66 2e5f    f"TE (E{self._
-0000ff90: 7461 6e67 656e 7469 616c 5f64 696d 735b  tangential_dims[
-0000ffa0: 305d 7d29 2066 7261 6374 696f 6e22 3a20  0]}) fraction": 
-0000ffb0: 7365 6c66 2e70 6f6c 5f66 7261 6374 696f  self.pol_fractio
-0000ffc0: 6e5b 2274 6522 5d2c 0a20 2020 2020 2020  n["te"],.       
-0000ffd0: 2020 2020 2022 7767 2054 4520 6672 6163       "wg TE frac
-0000ffe0: 7469 6f6e 223a 2073 656c 662e 706f 6c5f  tion": self.pol_
-0000fff0: 6672 6163 7469 6f6e 5f77 6176 6567 7569  fraction_wavegui
-00010000: 6465 5b22 7465 225d 2c0a 2020 2020 2020  de["te"],.      
-00010010: 2020 2020 2020 2277 6720 544d 2066 7261        "wg TM fra
-00010020: 6374 696f 6e22 3a20 7365 6c66 2e70 6f6c  ction": self.pol
-00010030: 5f66 7261 6374 696f 6e5f 7761 7665 6775  _fraction_wavegu
-00010040: 6964 655b 2274 6d22 5d2c 0a20 2020 2020  ide["tm"],.     
-00010050: 2020 2020 2020 2022 6d6f 6465 2061 7265         "mode are
-00010060: 6122 3a20 7365 6c66 2e6d 6f64 655f 6172  a": self.mode_ar
-00010070: 6561 2c0a 2020 2020 2020 2020 2020 2020  ea,.            
-00010080: 2267 726f 7570 2069 6e64 6578 223a 2073  "group index": s
-00010090: 656c 662e 6e5f 6772 6f75 705f 7261 772c  elf.n_group_raw,
-000100a0: 2020 2320 5573 6520 7261 7720 6669 656c    # Use raw fiel
-000100b0: 6420 746f 2061 766f 6964 2069 7373 7569  d to avoid issui
-000100c0: 6e67 2061 2077 6172 6e69 6e67 0a20 2020  ng a warning.   
-000100d0: 2020 2020 2020 2020 2022 6469 7370 6572           "disper
-000100e0: 7369 6f6e 2028 7073 2f28 6e6d 206b 6d29  sion (ps/(nm km)
-000100f0: 2922 3a20 7365 6c66 2e64 6973 7065 7273  )": self.dispers
-00010100: 696f 6e5f 7261 772c 2020 2320 5573 6520  ion_raw,  # Use 
-00010110: 7261 7720 6669 656c 6420 746f 2061 766f  raw field to avo
-00010120: 6964 2069 7373 7569 6e67 2061 2077 6172  id issuing a war
-00010130: 6e69 6e67 0a20 2020 2020 2020 207d 0a0a  ning.        }..
-00010140: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-00010150: 6e5f 6772 6f75 705f 7261 7720 6973 206e  n_group_raw is n
-00010160: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
-00010170: 2020 2020 2069 6e66 6f5b 2267 726f 7570       info["group
-00010180: 2069 6e64 6578 225d 203d 2073 656c 662e   index"] = self.
-00010190: 6e5f 6772 6f75 705f 7261 770a 0a20 2020  n_group_raw..   
-000101a0: 2020 2020 2069 6620 6c65 6e28 7365 6c66       if len(self
-000101b0: 2e66 6965 6c64 5f63 6f6d 706f 6e65 6e74  .field_component
-000101c0: 7329 203d 3d20 363a 0a20 2020 2020 2020  s) == 6:.       
-000101d0: 2020 2020 2069 6e66 6f5b 226d 6f64 6520       info["mode 
-000101e0: 6172 6561 225d 203d 2073 656c 662e 6d6f  area"] = self.mo
-000101f0: 6465 5f61 7265 610a 2020 2020 2020 2020  de_area.        
-00010200: 2020 2020 696e 666f 5b66 2254 4520 2845      info[f"TE (E
-00010210: 7b73 656c 662e 5f74 616e 6765 6e74 6961  {self._tangentia
-00010220: 6c5f 6469 6d73 5b30 5d7d 2920 6672 6163  l_dims[0]}) frac
-00010230: 7469 6f6e 225d 203d 2073 656c 662e 706f  tion"] = self.po
-00010240: 6c5f 6672 6163 7469 6f6e 5b22 7465 225d  l_fraction["te"]
-00010250: 0a20 2020 2020 2020 2020 2020 2069 6e66  .            inf
-00010260: 6f5b 2277 6720 5445 2066 7261 6374 696f  o["wg TE fractio
-00010270: 6e22 5d20 3d20 7365 6c66 2e70 6f6c 5f66  n"] = self.pol_f
-00010280: 7261 6374 696f 6e5f 7761 7665 6775 6964  raction_waveguid
-00010290: 655b 2274 6522 5d0a 2020 2020 2020 2020  e["te"].        
-000102a0: 2020 2020 696e 666f 5b22 7767 2054 4d20      info["wg TM 
-000102b0: 6672 6163 7469 6f6e 225d 203d 2073 656c  fraction"] = sel
-000102c0: 662e 706f 6c5f 6672 6163 7469 6f6e 5f77  f.pol_fraction_w
-000102d0: 6176 6567 7569 6465 5b22 746d 225d 0a0a  aveguide["tm"]..
-000102e0: 2020 2020 2020 2020 7265 7475 726e 2078          return x
-000102f0: 722e 4461 7461 7365 7428 6461 7461 5f76  r.Dataset(data_v
-00010300: 6172 733d 696e 666f 290a 0a20 2020 2064  ars=info)..    d
-00010310: 6566 2074 6f5f 6461 7461 6672 616d 6528  ef to_dataframe(
-00010320: 7365 6c66 2920 2d3e 2044 6174 6146 7261  self) -> DataFra
-00010330: 6d65 3a0a 2020 2020 2020 2020 2222 2278  me:.        """x
-00010340: 6172 7261 792d 6c69 6b65 206d 6574 686f  array-like metho
-00010350: 6420 746f 2065 7870 6f72 7420 7468 6520  d to export the 
-00010360: 6060 6d6f 6465 735f 696e 666f 6060 2069  ``modes_info`` i
-00010370: 6e74 6f20 6120 7061 6e64 6173 2064 6174  nto a pandas dat
-00010380: 6166 7261 6d65 2077 6869 6368 2069 7320  aframe which is 
-00010390: 652e 672e 0a20 2020 2020 2020 2073 696d  e.g..        sim
-000103a0: 706c 6520 746f 2076 6973 7561 6c69 7a65  ple to visualize
-000103b0: 2061 7320 6120 7461 626c 652e 2222 220a   as a table.""".
-000103c0: 0a20 2020 2020 2020 2064 6174 6173 6574  .        dataset
-000103d0: 203d 2073 656c 662e 6d6f 6465 735f 696e   = self.modes_in
-000103e0: 666f 0a20 2020 2020 2020 2064 726f 7020  fo.        drop 
-000103f0: 3d20 5b5d 0a0a 2020 2020 2020 2020 6966  = []..        if
-00010400: 206e 6f74 206e 702e 616e 7928 6461 7461   not np.any(data
-00010410: 7365 745b 2267 726f 7570 2069 6e64 6578  set["group index
-00010420: 225d 2e76 616c 7565 7329 3a0a 2020 2020  "].values):.    
-00010430: 2020 2020 2020 2020 6472 6f70 2e61 7070          drop.app
-00010440: 656e 6428 2267 726f 7570 2069 6e64 6578  end("group index
-00010450: 2229 0a20 2020 2020 2020 2069 6620 6e6f  ").        if no
-00010460: 7420 6e70 2e61 6e79 2864 6174 6173 6574  t np.any(dataset
-00010470: 5b22 6469 7370 6572 7369 6f6e 2028 7073  ["dispersion (ps
-00010480: 2f28 6e6d 206b 6d29 2922 5d2e 7661 6c75  /(nm km))"].valu
-00010490: 6573 293a 0a20 2020 2020 2020 2020 2020  es):.           
-000104a0: 2064 726f 702e 6170 7065 6e64 2822 6469   drop.append("di
-000104b0: 7370 6572 7369 6f6e 2028 7073 2f28 6e6d  spersion (ps/(nm
-000104c0: 206b 6d29 2922 290a 2020 2020 2020 2020   km))").        
-000104d0: 6966 206e 702e 616c 6c28 6461 7461 7365  if np.all(datase
-000104e0: 745b 226c 6f73 7320 2864 422f 636d 2922  t["loss (dB/cm)"
-000104f0: 5d20 3d3d 2030 293a 0a20 2020 2020 2020  ] == 0):.       
-00010500: 2020 2020 2064 726f 702e 6170 7065 6e64       drop.append
-00010510: 2822 6c6f 7373 2028 6442 2f63 6d29 2229  ("loss (dB/cm)")
-00010520: 0a0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-00010530: 2064 6174 6173 6574 2e64 726f 705f 7661   dataset.drop_va
-00010540: 7273 2864 726f 7029 2e74 6f5f 6461 7461  rs(drop).to_data
-00010550: 6672 616d 6528 290a 0a0a 636c 6173 7320  frame()...class 
-00010560: 4d6f 6465 536f 6c76 6572 4461 7461 284d  ModeSolverData(M
-00010570: 6f64 6544 6174 6129 3a0a 2020 2020 2222  odeData):.    ""
-00010580: 220a 2020 2020 4461 7461 2061 7373 6f63  ".    Data assoc
-00010590: 6961 7465 6420 7769 7468 2061 203a 636c  iated with a :cl
-000105a0: 6173 733a 602e 4d6f 6465 536f 6c76 6572  ass:`.ModeSolver
-000105b0: 4d6f 6e69 746f 7260 3a20 7363 616c 6172  Monitor`: scalar
-000105c0: 2063 6f6d 706f 6e65 6e74 7320 6f66 2045   components of E
-000105d0: 2061 6e64 2048 2066 6965 6c64 732e 0a0a   and H fields...
-000105e0: 2020 2020 4e6f 7465 730a 2020 2020 2d2d      Notes.    --
-000105f0: 2d2d 2d0a 0a20 2020 2020 2020 2054 6865  ---..        The
-00010600: 2064 6174 6120 6973 2073 746f 7265 6420   data is stored 
-00010610: 6173 2061 2060 4461 7461 4172 7261 7920  as a `DataArray 
-00010620: 3c68 7474 7073 3a2f 2f64 6f63 732e 7861  <https://docs.xa
-00010630: 7272 6179 2e64 6576 2f65 6e2f 7374 6162  rray.dev/en/stab
-00010640: 6c65 2f67 656e 6572 6174 6564 2f78 6172  le/generated/xar
-00010650: 7261 792e 4461 7461 4172 7261 792e 6874  ray.DataArray.ht
-00010660: 6d6c 3e60 5f0a 2020 2020 2020 2020 6f62  ml>`_.        ob
-00010670: 6a65 6374 2075 7369 6e67 2074 6865 2060  ject using the `
-00010680: 7861 7272 6179 203c 6874 7470 733a 2f2f  xarray <https://
-00010690: 646f 6373 2e78 6172 7261 792e 6465 762f  docs.xarray.dev/
-000106a0: 656e 2f73 7461 626c 652f 696e 6465 782e  en/stable/index.
-000106b0: 6874 6d6c 3e60 5f20 7061 636b 6167 652e  html>`_ package.
-000106c0: 0a0a 2020 2020 4578 616d 706c 650a 2020  ..    Example.  
-000106d0: 2020 2d2d 2d2d 2d2d 2d0a 2020 2020 3e3e    -------.    >>
-000106e0: 3e20 6672 6f6d 2074 6964 7933 6420 696d  > from tidy3d im
-000106f0: 706f 7274 204d 6f64 6553 7065 630a 2020  port ModeSpec.  
-00010700: 2020 3e3e 3e20 6672 6f6d 2074 6964 7933    >>> from tidy3
-00010710: 6420 696d 706f 7274 2053 6361 6c61 724d  d import ScalarM
-00010720: 6f64 6546 6965 6c64 4461 7461 4172 7261  odeFieldDataArra
-00010730: 792c 204d 6f64 6549 6e64 6578 4461 7461  y, ModeIndexData
-00010740: 4172 7261 790a 2020 2020 3e3e 3e20 7820  Array.    >>> x 
-00010750: 3d20 5b2d 312c 312c 335d 0a20 2020 203e  = [-1,1,3].    >
-00010760: 3e3e 2079 203d 205b 2d32 2c30 5d0a 2020  >> y = [-2,0].  
-00010770: 2020 3e3e 3e20 7a20 3d20 5b2d 332c 2d31    >>> z = [-3,-1
-00010780: 2c31 2c33 2c35 5d0a 2020 2020 3e3e 3e20  ,1,3,5].    >>> 
-00010790: 6620 3d20 5b32 6531 342c 2033 6531 345d  f = [2e14, 3e14]
-000107a0: 0a20 2020 203e 3e3e 206d 6f64 655f 696e  .    >>> mode_in
-000107b0: 6465 7820 3d20 6e70 2e61 7261 6e67 6528  dex = np.arange(
-000107c0: 3529 0a20 2020 203e 3e3e 2067 7269 6420  5).    >>> grid 
-000107d0: 3d20 4772 6964 2862 6f75 6e64 6172 6965  = Grid(boundarie
-000107e0: 733d 436f 6f72 6473 2878 3d78 2c20 793d  s=Coords(x=x, y=
-000107f0: 792c 207a 3d7a 2929 0a20 2020 203e 3e3e  y, z=z)).    >>>
-00010800: 2066 6965 6c64 5f63 6f6f 7264 7320 3d20   field_coords = 
-00010810: 6469 6374 2878 3d78 5b3a 2d31 5d2c 2079  dict(x=x[:-1], y
-00010820: 3d79 5b3a 2d31 5d2c 207a 3d7a 5b3a 2d31  =y[:-1], z=z[:-1
-00010830: 5d2c 2066 3d66 2c20 6d6f 6465 5f69 6e64  ], f=f, mode_ind
-00010840: 6578 3d6d 6f64 655f 696e 6465 7829 0a20  ex=mode_index). 
-00010850: 2020 203e 3e3e 2066 6965 6c64 203d 2053     >>> field = S
-00010860: 6361 6c61 724d 6f64 6546 6965 6c64 4461  calarModeFieldDa
-00010870: 7461 4172 7261 7928 2831 2b31 6a29 2a6e  taArray((1+1j)*n
-00010880: 702e 7261 6e64 6f6d 2e72 616e 646f 6d28  p.random.random(
-00010890: 2832 2c31 2c34 2c32 2c35 2929 2c20 636f  (2,1,4,2,5)), co
-000108a0: 6f72 6473 3d66 6965 6c64 5f63 6f6f 7264  ords=field_coord
-000108b0: 7329 0a20 2020 203e 3e3e 2069 6e64 6578  s).    >>> index
-000108c0: 5f63 6f6f 7264 7320 3d20 6469 6374 2866  _coords = dict(f
-000108d0: 3d66 2c20 6d6f 6465 5f69 6e64 6578 3d6d  =f, mode_index=m
-000108e0: 6f64 655f 696e 6465 7829 0a20 2020 203e  ode_index).    >
-000108f0: 3e3e 2069 6e64 6578 5f64 6174 6120 3d20  >> index_data = 
-00010900: 4d6f 6465 496e 6465 7844 6174 6141 7272  ModeIndexDataArr
-00010910: 6179 2828 312b 316a 2920 2a20 6e70 2e72  ay((1+1j) * np.r
-00010920: 616e 646f 6d2e 7261 6e64 6f6d 2828 322c  andom.random((2,
-00010930: 3529 292c 2063 6f6f 7264 733d 696e 6465  5)), coords=inde
-00010940: 785f 636f 6f72 6473 290a 2020 2020 3e3e  x_coords).    >>
-00010950: 3e20 6d6f 6e69 746f 7220 3d20 4d6f 6465  > monitor = Mode
-00010960: 536f 6c76 6572 4d6f 6e69 746f 7228 0a20  SolverMonitor(. 
-00010970: 2020 202e 2e2e 2020 2020 7369 7a65 3d28     ...    size=(
-00010980: 322c 302c 3629 2c0a 2020 2020 2e2e 2e20  2,0,6),.    ... 
-00010990: 2020 2066 7265 7173 3d5b 3265 3134 2c20     freqs=[2e14, 
-000109a0: 3365 3134 5d2c 0a20 2020 202e 2e2e 2020  3e14],.    ...  
-000109b0: 2020 6d6f 6465 5f73 7065 633d 4d6f 6465    mode_spec=Mode
-000109c0: 5370 6563 286e 756d 5f6d 6f64 6573 3d35  Spec(num_modes=5
-000109d0: 292c 0a20 2020 202e 2e2e 2020 2020 6e61  ),.    ...    na
-000109e0: 6d65 3d27 6d6f 6465 5f73 6f6c 7665 7227  me='mode_solver'
-000109f0: 2c0a 2020 2020 2e2e 2e20 290a 2020 2020  ,.    ... ).    
-00010a00: 3e3e 3e20 6461 7461 203d 204d 6f64 6553  >>> data = ModeS
-00010a10: 6f6c 7665 7244 6174 6128 0a20 2020 202e  olverData(.    .
-00010a20: 2e2e 2020 2020 206d 6f6e 6974 6f72 3d6d  ..     monitor=m
-00010a30: 6f6e 6974 6f72 2c0a 2020 2020 2e2e 2e20  onitor,.    ... 
-00010a40: 2020 2020 4578 3d66 6965 6c64 2c0a 2020      Ex=field,.  
-00010a50: 2020 2e2e 2e20 2020 2020 4579 3d66 6965    ...     Ey=fie
-00010a60: 6c64 2c0a 2020 2020 2e2e 2e20 2020 2020  ld,.    ...     
-00010a70: 457a 3d66 6965 6c64 2c0a 2020 2020 2e2e  Ez=field,.    ..
-00010a80: 2e20 2020 2020 4878 3d66 6965 6c64 2c0a  .     Hx=field,.
-00010a90: 2020 2020 2e2e 2e20 2020 2020 4879 3d66      ...     Hy=f
-00010aa0: 6965 6c64 2c0a 2020 2020 2e2e 2e20 2020  ield,.    ...   
-00010ab0: 2020 487a 3d66 6965 6c64 2c0a 2020 2020    Hz=field,.    
-00010ac0: 2e2e 2e20 2020 2020 6e5f 636f 6d70 6c65  ...     n_comple
-00010ad0: 783d 696e 6465 785f 6461 7461 2c0a 2020  x=index_data,.  
-00010ae0: 2020 2e2e 2e20 2020 2020 6772 6964 5f65    ...     grid_e
-00010af0: 7870 616e 6465 643d 6772 6964 0a20 2020  xpanded=grid.   
-00010b00: 202e 2e2e 2029 0a20 2020 2022 2222 0a0a   ... ).    """..
-00010b10: 2020 2020 6d6f 6e69 746f 723a 204d 6f64      monitor: Mod
-00010b20: 6553 6f6c 7665 724d 6f6e 6974 6f72 203d  eSolverMonitor =
-00010b30: 2070 642e 4669 656c 6428 0a20 2020 2020   pd.Field(.     
-00010b40: 2020 202e 2e2e 2c20 7469 746c 653d 224d     ..., title="M
-00010b50: 6f6e 6974 6f72 222c 2064 6573 6372 6970  onitor", descrip
-00010b60: 7469 6f6e 3d22 4d6f 6465 2073 6f6c 7665  tion="Mode solve
-00010b70: 7220 6d6f 6e69 746f 7220 6173 736f 6369  r monitor associ
-00010b80: 6174 6564 2077 6974 6820 7468 6520 6461  ated with the da
-00010b90: 7461 2e22 0a20 2020 2029 0a0a 2020 2020  ta.".    )..    
-00010ba0: 616d 7073 3a20 4d6f 6465 416d 7073 4461  amps: ModeAmpsDa
-00010bb0: 7461 4172 7261 7920 3d20 7064 2e46 6965  taArray = pd.Fie
-00010bc0: 6c64 280a 2020 2020 2020 2020 4e6f 6e65  ld(.        None
-00010bd0: 2c20 7469 746c 653d 2241 6d70 6c69 7475  , title="Amplitu
-00010be0: 6465 7322 2c20 6465 7363 7269 7074 696f  des", descriptio
-00010bf0: 6e3d 2255 6e75 7365 6420 666f 7220 4d6f  n="Unused for Mo
-00010c00: 6465 536f 6c76 6572 4461 7461 2e22 0a20  deSolverData.". 
-00010c10: 2020 2029 0a0a 2020 2020 6465 6620 6e6f     )..    def no
-00010c20: 726d 616c 697a 6528 7365 6c66 2c20 736f  rmalize(self, so
-00010c30: 7572 6365 5f73 7065 6374 7275 6d5f 666e  urce_spectrum_fn
-00010c40: 3a20 4361 6c6c 6162 6c65 5b5b 666c 6f61  : Callable[[floa
-00010c50: 745d 2c20 636f 6d70 6c65 785d 2920 2d3e  t], complex]) ->
-00010c60: 204d 6f64 6553 6f6c 7665 7244 6174 613a   ModeSolverData:
-00010c70: 0a20 2020 2020 2020 2022 2222 5265 7475  .        """Retu
-00010c80: 726e 2063 6f70 7920 6f66 2073 656c 6620  rn copy of self 
-00010c90: 6166 7465 7220 6e6f 726d 616c 697a 6174  after normalizat
-00010ca0: 696f 6e20 6973 2061 7070 6c69 6564 2075  ion is applied u
-00010cb0: 7369 6e67 2073 6f75 7263 6520 7370 6563  sing source spec
-00010cc0: 7472 756d 2066 756e 6374 696f 6e2e 2222  trum function.""
-00010cd0: 220a 2020 2020 2020 2020 7265 7475 726e  ".        return
-00010ce0: 2073 656c 662e 636f 7079 2829 0a0a 2020   self.copy()..  
-00010cf0: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
-00010d00: 6465 6620 7469 6d65 5f72 6576 6572 7365  def time_reverse
-00010d10: 645f 636f 7079 2873 656c 6629 202d 3e20  d_copy(self) -> 
-00010d20: 4669 656c 6444 6174 613a 0a20 2020 2020  FieldData:.     
-00010d30: 2020 2022 2222 4d61 6b65 2061 2063 6f70     """Make a cop
-00010d40: 7920 6f66 2074 6865 2064 6174 6120 7769  y of the data wi
-00010d50: 7468 2064 6972 6563 7469 6f6e 2d72 6576  th direction-rev
-00010d60: 6572 7365 6420 6669 656c 6473 2e20 496e  ersed fields. In
-00010d70: 206c 6f73 7379 206f 7220 6779 726f 7472   lossy or gyrotr
-00010d80: 6f70 6963 2073 7973 7465 6d73 2c0a 2020  opic systems,.  
-00010d90: 2020 2020 2020 7468 6520 7469 6d65 2d72        the time-r
-00010da0: 6576 6572 7365 6420 6669 656c 6473 2077  eversed fields w
-00010db0: 696c 6c20 6e6f 7420 6265 2074 6865 2073  ill not be the s
-00010dc0: 616d 6520 6173 2074 6865 2062 6163 6b77  ame as the backw
-00010dd0: 6172 642d 7072 6f70 6167 6174 696e 6720  ard-propagating 
-00010de0: 6d6f 6465 732e 2222 220a 0a20 2020 2020  modes."""..     
-00010df0: 2020 2023 2054 696d 6520 7265 7665 7273     # Time revers
-00010e00: 616c 0a20 2020 2020 2020 206e 6577 5f64  al.        new_d
-00010e10: 6174 6120 3d20 7b7d 0a20 2020 2020 2020  ata = {}.       
-00010e20: 2066 6f72 2063 6f6d 702c 2066 6965 6c64   for comp, field
-00010e30: 2069 6e20 7365 6c66 2e66 6965 6c64 5f63   in self.field_c
-00010e40: 6f6d 706f 6e65 6e74 732e 6974 656d 7328  omponents.items(
-00010e50: 293a 0a20 2020 2020 2020 2020 2020 2069  ):.            i
-00010e60: 6620 636f 6d70 5b30 5d20 3d3d 2022 4822  f comp[0] == "H"
-00010e70: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00010e80: 2020 6e65 775f 6461 7461 5b63 6f6d 705d    new_data[comp]
-00010e90: 203d 202d 6e70 2e63 6f6e 6a28 6669 656c   = -np.conj(fiel
-00010ea0: 6429 0a20 2020 2020 2020 2020 2020 2065  d).            e
-00010eb0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00010ec0: 2020 2020 206e 6577 5f64 6174 615b 636f       new_data[co
-00010ed0: 6d70 5d20 3d20 6e70 2e63 6f6e 6a28 6669  mp] = np.conj(fi
-00010ee0: 656c 6429 0a0a 2020 2020 2020 2020 2320  eld)..        # 
-00010ef0: 7377 6974 6368 2064 6972 6563 7469 6f6e  switch direction
-00010f00: 2069 6e20 7468 6520 6d6f 6e69 746f 720a   in the monitor.
-00010f10: 2020 2020 2020 2020 6d6e 7420 3d20 7365          mnt = se
-00010f20: 6c66 2e6d 6f6e 6974 6f72 0a20 2020 2020  lf.monitor.     
-00010f30: 2020 206e 6577 5f64 6972 203d 2022 2b22     new_dir = "+"
-00010f40: 2069 6620 6d6e 742e 7374 6f72 655f 6669   if mnt.store_fi
-00010f50: 656c 6473 5f64 6972 6563 7469 6f6e 203d  elds_direction =
-00010f60: 3d20 222d 2220 656c 7365 2022 2d22 0a20  = "-" else "-". 
-00010f70: 2020 2020 2020 206e 6577 5f64 6174 615b         new_data[
-00010f80: 226d 6f6e 6974 6f72 225d 203d 206d 6e74  "monitor"] = mnt
-00010f90: 2e75 7064 6174 6564 5f63 6f70 7928 6469  .updated_copy(di
-00010fa0: 7265 6374 696f 6e3d 6e65 775f 6469 722c  rection=new_dir,
-00010fb0: 2073 746f 7265 5f66 6965 6c64 735f 6469   store_fields_di
-00010fc0: 7265 6374 696f 6e3d 6e65 775f 6469 7229  rection=new_dir)
-00010fd0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00010fe0: 7365 6c66 2e63 6f70 7928 7570 6461 7465  self.copy(update
-00010ff0: 3d6e 6577 5f64 6174 6129 0a0a 0a63 6c61  =new_data)...cla
-00011000: 7373 2046 6c75 7844 6174 6128 4d6f 6e69  ss FluxData(Moni
-00011010: 746f 7244 6174 6129 3a0a 2020 2020 2222  torData):.    ""
-00011020: 220a 2020 2020 4461 7461 2061 7373 6f63  ".    Data assoc
-00011030: 6961 7465 6420 7769 7468 2061 203a 636c  iated with a :cl
-00011040: 6173 733a 602e 466c 7578 4d6f 6e69 746f  ass:`.FluxMonito
-00011050: 7260 3a20 666c 7578 2064 6174 6120 696e  r`: flux data in
-00011060: 2074 6865 2066 7265 7175 656e 6379 2d64   the frequency-d
-00011070: 6f6d 6169 6e2e 0a0a 2020 2020 4e6f 7465  omain...    Note
-00011080: 730a 2020 2020 2d2d 2d2d 2d0a 0a20 2020  s.    -----..   
-00011090: 2020 2020 2054 6865 2064 6174 6120 6973       The data is
-000110a0: 2073 746f 7265 6420 6173 2061 2060 4461   stored as a `Da
-000110b0: 7461 4172 7261 7920 3c68 7474 7073 3a2f  taArray <https:/
-000110c0: 2f64 6f63 732e 7861 7272 6179 2e64 6576  /docs.xarray.dev
-000110d0: 2f65 6e2f 7374 6162 6c65 2f67 656e 6572  /en/stable/gener
-000110e0: 6174 6564 2f78 6172 7261 792e 4461 7461  ated/xarray.Data
-000110f0: 4172 7261 792e 6874 6d6c 3e60 5f0a 2020  Array.html>`_.  
-00011100: 2020 2020 2020 6f62 6a65 6374 2075 7369        object usi
-00011110: 6e67 2074 6865 2060 7861 7272 6179 203c  ng the `xarray <
-00011120: 6874 7470 733a 2f2f 646f 6373 2e78 6172  https://docs.xar
-00011130: 7261 792e 6465 762f 656e 2f73 7461 626c  ray.dev/en/stabl
-00011140: 652f 696e 6465 782e 6874 6d6c 3e60 5f20  e/index.html>`_ 
-00011150: 7061 636b 6167 652e 0a0a 2020 2020 2020  package...      
-00011160: 2020 5765 2063 616e 2061 6363 6573 7320    We can access 
-00011170: 7468 6520 6461 7461 2066 6f72 2065 6163  the data for eac
-00011180: 6820 6d6f 6e69 746f 7220 6279 2069 6e64  h monitor by ind
-00011190: 6578 696e 6720 696e 746f 2074 6865 203a  exing into the :
-000111a0: 636c 6173 733a 6053 696d 756c 6174 696f  class:`Simulatio
-000111b0: 6e44 6174 6160 2077 6974 6820 7468 6520  nData` with the 
-000111c0: 6d6f 6e69 746f 720a 2020 2020 2020 2020  monitor.        
-000111d0: 6060 2e6e 616d 6560 602e 2046 6f72 2074  ``.name``. For t
-000111e0: 6865 2066 6c75 7820 6d6f 6e69 746f 7220  he flux monitor 
-000111f0: 6461 7461 2c20 7765 2063 616e 2061 6363  data, we can acc
-00011200: 6573 7320 7468 6520 7261 7720 666c 7578  ess the raw flux
-00011210: 2064 6174 6120 6173 2061 2066 756e 6374   data as a funct
-00011220: 696f 6e20 6f66 2066 7265 7175 656e 6379  ion of frequency
-00011230: 2077 6974 680a 2020 2020 2020 2020 6060   with.        ``
-00011240: 2e66 6c75 7860 602e 2041 7320 6d6f 7374  .flux``. As most
-00011250: 2064 6174 6120 6172 6520 6d75 6c74 6964   data are multid
-00011260: 696d 656e 7369 6f6e 616c 2c20 6974 e280  imensional, it..
-00011270: 9973 206f 6674 656e 2076 6572 7920 6865  .s often very he
-00011280: 6c70 6675 6c20 746f 2070 7269 6e74 206f  lpful to print o
-00011290: 7574 2074 6865 2064 6174 6120 616e 6420  ut the data and 
-000112a0: 6469 7265 6374 6c79 0a20 2020 2020 2020  directly.       
-000112b0: 2069 6e73 7065 6374 2069 7473 2073 7472   inspect its str
-000112c0: 7563 7475 7265 2e0a 0a20 2020 2045 7861  ucture...    Exa
-000112d0: 6d70 6c65 0a20 2020 202d 2d2d 2d2d 2d2d  mple.    -------
-000112e0: 0a20 2020 203e 3e3e 2066 726f 6d20 7469  .    >>> from ti
-000112f0: 6479 3364 2069 6d70 6f72 7420 466c 7578  dy3d import Flux
-00011300: 4461 7461 4172 7261 790a 2020 2020 3e3e  DataArray.    >>
-00011310: 3e20 6620 3d20 5b32 6531 342c 2033 6531  > f = [2e14, 3e1
-00011320: 345d 0a20 2020 203e 3e3e 2063 6f6f 7264  4].    >>> coord
-00011330: 7320 3d20 6469 6374 2866 3d66 290a 2020  s = dict(f=f).  
-00011340: 2020 3e3e 3e20 666c 7578 5f64 6174 6120    >>> flux_data 
-00011350: 3d20 466c 7578 4461 7461 4172 7261 7928  = FluxDataArray(
-00011360: 6e70 2e72 616e 646f 6d2e 7261 6e64 6f6d  np.random.random
-00011370: 2832 292c 2063 6f6f 7264 733d 636f 6f72  (2), coords=coor
-00011380: 6473 290a 2020 2020 3e3e 3e20 6d6f 6e69  ds).    >>> moni
-00011390: 746f 7220 3d20 466c 7578 4d6f 6e69 746f  tor = FluxMonito
-000113a0: 7228 7369 7a65 3d28 322c 302c 3629 2c20  r(size=(2,0,6), 
-000113b0: 6672 6571 733d 5b32 6531 342c 2033 6531  freqs=[2e14, 3e1
-000113c0: 345d 2c20 6e61 6d65 3d27 666c 7578 2729  4], name='flux')
-000113d0: 0a20 2020 203e 3e3e 2064 6174 6120 3d20  .    >>> data = 
-000113e0: 466c 7578 4461 7461 286d 6f6e 6974 6f72  FluxData(monitor
-000113f0: 3d6d 6f6e 6974 6f72 2c20 666c 7578 3d66  =monitor, flux=f
-00011400: 6c75 785f 6461 7461 290a 0a20 2020 2053  lux_data)..    S
-00011410: 6565 2041 6c73 6f0a 2020 2020 2d2d 2d2d  ee Also.    ----
-00011420: 2d2d 2d2d 0a0a 2020 2020 2a2a 4e6f 7465  ----..    **Note
-00011430: 626f 6f6b 733a 2a2a 0a20 2020 2020 2020  books:**.       
-00011440: 202a 2060 4164 7661 6e63 6564 206d 6f6e   * `Advanced mon
-00011450: 6974 6f72 2064 6174 6120 6d61 6e69 7075  itor data manipu
-00011460: 6c61 7469 6f6e 2061 6e64 2076 6973 7561  lation and visua
-00011470: 6c69 7a61 7469 6f6e 203c 2e2e 2f2e 2e2f  lization <../../
-00011480: 6e6f 7465 626f 6f6b 732f 5861 7272 6179  notebooks/Xarray
-00011490: 5475 746f 7269 616c 2e68 746d 6c3e 605f  Tutorial.html>`_
-000114a0: 0a20 2020 2022 2222 0a0a 2020 2020 6d6f  .    """..    mo
-000114b0: 6e69 746f 723a 2046 6c75 784d 6f6e 6974  nitor: FluxMonit
-000114c0: 6f72 203d 2070 642e 4669 656c 6428 0a20  or = pd.Field(. 
-000114d0: 2020 2020 2020 202e 2e2e 2c20 7469 746c         ..., titl
-000114e0: 653d 224d 6f6e 6974 6f72 222c 2064 6573  e="Monitor", des
-000114f0: 6372 6970 7469 6f6e 3d22 4672 6571 7565  cription="Freque
-00011500: 6e63 792d 646f 6d61 696e 2066 6c75 7820  ncy-domain flux 
-00011510: 6d6f 6e69 746f 7220 6173 736f 6369 6174  monitor associat
-00011520: 6564 2077 6974 6820 7468 6520 6461 7461  ed with the data
-00011530: 2e22 0a20 2020 2029 0a0a 2020 2020 666c  .".    )..    fl
-00011540: 7578 3a20 466c 7578 4461 7461 4172 7261  ux: FluxDataArra
-00011550: 7920 3d20 7064 2e46 6965 6c64 280a 2020  y = pd.Field(.  
-00011560: 2020 2020 2020 2e2e 2e2c 2074 6974 6c65        ..., title
-00011570: 3d22 466c 7578 222c 2064 6573 6372 6970  ="Flux", descrip
-00011580: 7469 6f6e 3d22 466c 7578 2076 616c 7565  tion="Flux value
-00011590: 7320 696e 2074 6865 2066 7265 7175 656e  s in the frequen
-000115a0: 6379 2d64 6f6d 6169 6e2e 220a 2020 2020  cy-domain.".    
-000115b0: 290a 0a20 2020 2064 6566 206e 6f72 6d61  )..    def norma
-000115c0: 6c69 7a65 2873 656c 662c 2073 6f75 7263  lize(self, sourc
-000115d0: 655f 7370 6563 7472 756d 5f66 6e29 202d  e_spectrum_fn) -
-000115e0: 3e20 466c 7578 4461 7461 3a0a 2020 2020  > FluxData:.    
-000115f0: 2020 2020 2222 2252 6574 7572 6e20 636f      """Return co
-00011600: 7079 206f 6620 7365 6c66 2061 6674 6572  py of self after
-00011610: 206e 6f72 6d61 6c69 7a61 7469 6f6e 2069   normalization i
-00011620: 7320 6170 706c 6965 6420 7573 696e 6720  s applied using 
-00011630: 736f 7572 6365 2073 7065 6374 7275 6d20  source spectrum 
-00011640: 6675 6e63 7469 6f6e 2e22 2222 0a20 2020  function.""".   
-00011650: 2020 2020 2073 6f75 7263 655f 6672 6571       source_freq
-00011660: 5f61 6d70 7320 3d20 736f 7572 6365 5f73  _amps = source_s
-00011670: 7065 6374 7275 6d5f 666e 2873 656c 662e  pectrum_fn(self.
-00011680: 666c 7578 2e66 290a 2020 2020 2020 2020  flux.f).        
-00011690: 736f 7572 6365 5f70 6f77 6572 203d 2061  source_power = a
-000116a0: 6273 2873 6f75 7263 655f 6672 6571 5f61  bs(source_freq_a
-000116b0: 6d70 7329 202a 2a20 320a 2020 2020 2020  mps) ** 2.      
-000116c0: 2020 6e65 775f 666c 7578 203d 2028 7365    new_flux = (se
-000116d0: 6c66 2e66 6c75 7820 2f20 736f 7572 6365  lf.flux / source
-000116e0: 5f70 6f77 6572 292e 6173 7479 7065 2873  _power).astype(s
-000116f0: 656c 662e 666c 7578 2e64 7479 7065 290a  elf.flux.dtype).
-00011700: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-00011710: 656c 662e 636f 7079 2875 7064 6174 653d  elf.copy(update=
-00011720: 6469 6374 2866 6c75 783d 6e65 775f 666c  dict(flux=new_fl
-00011730: 7578 2929 0a0a 0a63 6c61 7373 2046 6c75  ux))...class Flu
-00011740: 7854 696d 6544 6174 6128 4d6f 6e69 746f  xTimeData(Monito
-00011750: 7244 6174 6129 3a0a 2020 2020 2222 220a  rData):.    """.
-00011760: 2020 2020 4461 7461 2061 7373 6f63 6961      Data associa
-00011770: 7465 6420 7769 7468 2061 203a 636c 6173  ted with a :clas
-00011780: 733a 602e 466c 7578 5469 6d65 4d6f 6e69  s:`.FluxTimeMoni
-00011790: 746f 7260 3a20 666c 7578 2064 6174 6120  tor`: flux data 
-000117a0: 696e 2074 6865 2074 696d 652d 646f 6d61  in the time-doma
-000117b0: 696e 2e0a 0a20 2020 204e 6f74 6573 0a20  in...    Notes. 
-000117c0: 2020 202d 2d2d 2d2d 0a0a 2020 2020 2020     -----..      
-000117d0: 2020 5468 6520 6461 7461 2069 7320 7374    The data is st
-000117e0: 6f72 6564 2061 7320 6120 6044 6174 6141  ored as a `DataA
-000117f0: 7272 6179 203c 6874 7470 733a 2f2f 646f  rray <https://do
-00011800: 6373 2e78 6172 7261 792e 6465 762f 656e  cs.xarray.dev/en
-00011810: 2f73 7461 626c 652f 6765 6e65 7261 7465  /stable/generate
-00011820: 642f 7861 7272 6179 2e44 6174 6141 7272  d/xarray.DataArr
-00011830: 6179 2e68 746d 6c3e 605f 0a20 2020 2020  ay.html>`_.     
-00011840: 2020 206f 626a 6563 7420 7573 696e 6720     object using 
-00011850: 7468 6520 6078 6172 7261 7920 3c68 7474  the `xarray <htt
-00011860: 7073 3a2f 2f64 6f63 732e 7861 7272 6179  ps://docs.xarray
-00011870: 2e64 6576 2f65 6e2f 7374 6162 6c65 2f69  .dev/en/stable/i
-00011880: 6e64 6578 2e68 746d 6c3e 605f 2070 6163  ndex.html>`_ pac
-00011890: 6b61 6765 2e0a 0a20 2020 2045 7861 6d70  kage...    Examp
-000118a0: 6c65 0a20 2020 202d 2d2d 2d2d 2d2d 0a20  le.    -------. 
-000118b0: 2020 203e 3e3e 2066 726f 6d20 7469 6479     >>> from tidy
-000118c0: 3364 2069 6d70 6f72 7420 466c 7578 5469  3d import FluxTi
-000118d0: 6d65 4461 7461 4172 7261 790a 2020 2020  meDataArray.    
-000118e0: 3e3e 3e20 7420 3d20 5b30 2c20 3165 2d31  >>> t = [0, 1e-1
-000118f0: 322c 2032 652d 3132 5d0a 2020 2020 3e3e  2, 2e-12].    >>
-00011900: 3e20 636f 6f72 6473 203d 2064 6963 7428  > coords = dict(
-00011910: 743d 7429 0a20 2020 203e 3e3e 2066 6c75  t=t).    >>> flu
-00011920: 785f 6461 7461 203d 2046 6c75 7854 696d  x_data = FluxTim
-00011930: 6544 6174 6141 7272 6179 286e 702e 7261  eDataArray(np.ra
-00011940: 6e64 6f6d 2e72 616e 646f 6d28 3329 2c20  ndom.random(3), 
-00011950: 636f 6f72 6473 3d63 6f6f 7264 7329 0a20  coords=coords). 
-00011960: 2020 203e 3e3e 206d 6f6e 6974 6f72 203d     >>> monitor =
-00011970: 2046 6c75 7854 696d 654d 6f6e 6974 6f72   FluxTimeMonitor
-00011980: 2873 697a 653d 2832 2c30 2c36 292c 2069  (size=(2,0,6), i
-00011990: 6e74 6572 7661 6c3d 3130 302c 206e 616d  nterval=100, nam
-000119a0: 653d 2766 6c75 785f 7469 6d65 2729 0a20  e='flux_time'). 
-000119b0: 2020 203e 3e3e 2064 6174 6120 3d20 466c     >>> data = Fl
-000119c0: 7578 5469 6d65 4461 7461 286d 6f6e 6974  uxTimeData(monit
-000119d0: 6f72 3d6d 6f6e 6974 6f72 2c20 666c 7578  or=monitor, flux
-000119e0: 3d66 6c75 785f 6461 7461 290a 2020 2020  =flux_data).    
-000119f0: 2222 220a 0a20 2020 206d 6f6e 6974 6f72  """..    monitor
-00011a00: 3a20 466c 7578 5469 6d65 4d6f 6e69 746f  : FluxTimeMonito
-00011a10: 7220 3d20 7064 2e46 6965 6c64 280a 2020  r = pd.Field(.  
-00011a20: 2020 2020 2020 2e2e 2e2c 2074 6974 6c65        ..., title
-00011a30: 3d22 4d6f 6e69 746f 7222 2c20 6465 7363  ="Monitor", desc
-00011a40: 7269 7074 696f 6e3d 2254 696d 652d 646f  ription="Time-do
-00011a50: 6d61 696e 2066 6c75 7820 6d6f 6e69 746f  main flux monito
-00011a60: 7220 6173 736f 6369 6174 6564 2077 6974  r associated wit
-00011a70: 6820 7468 6520 6461 7461 2e22 0a20 2020  h the data.".   
-00011a80: 2029 0a0a 2020 2020 666c 7578 3a20 466c   )..    flux: Fl
-00011a90: 7578 5469 6d65 4461 7461 4172 7261 7920  uxTimeDataArray 
-00011aa0: 3d20 7064 2e46 6965 6c64 280a 2020 2020  = pd.Field(.    
-00011ab0: 2020 2020 2e2e 2e2c 2074 6974 6c65 3d22      ..., title="
-00011ac0: 466c 7578 222c 2064 6573 6372 6970 7469  Flux", descripti
-00011ad0: 6f6e 3d22 466c 7578 2076 616c 7565 7320  on="Flux values 
-00011ae0: 696e 2074 6865 2074 696d 652d 646f 6d61  in the time-doma
-00011af0: 696e 2e22 0a20 2020 2029 0a0a 0a50 726f  in.".    )...Pro
-00011b00: 6a46 6965 6c64 5479 7065 203d 2055 6e69  jFieldType = Uni
-00011b10: 6f6e 5b0a 2020 2020 4669 656c 6450 726f  on[.    FieldPro
-00011b20: 6a65 6374 696f 6e41 6e67 6c65 4461 7461  jectionAngleData
-00011b30: 4172 7261 792c 0a20 2020 2046 6965 6c64  Array,.    Field
-00011b40: 5072 6f6a 6563 7469 6f6e 4361 7274 6573  ProjectionCartes
-00011b50: 6961 6e44 6174 6141 7272 6179 2c0a 2020  ianDataArray,.  
-00011b60: 2020 4669 656c 6450 726f 6a65 6374 696f    FieldProjectio
-00011b70: 6e4b 5370 6163 6544 6174 6141 7272 6179  nKSpaceDataArray
-00011b80: 2c0a 2020 2020 4469 6666 7261 6374 696f  ,.    Diffractio
-00011b90: 6e44 6174 6141 7272 6179 2c0a 5d0a 0a50  nDataArray,.]..P
-00011ba0: 726f 6a4d 6f6e 6974 6f72 5479 7065 203d  rojMonitorType =
-00011bb0: 2055 6e69 6f6e 5b0a 2020 2020 4669 656c   Union[.    Fiel
-00011bc0: 6450 726f 6a65 6374 696f 6e41 6e67 6c65  dProjectionAngle
-00011bd0: 4d6f 6e69 746f 722c 0a20 2020 2046 6965  Monitor,.    Fie
-00011be0: 6c64 5072 6f6a 6563 7469 6f6e 4361 7274  ldProjectionCart
-00011bf0: 6573 6961 6e4d 6f6e 6974 6f72 2c0a 2020  esianMonitor,.  
-00011c00: 2020 4669 656c 6450 726f 6a65 6374 696f    FieldProjectio
-00011c10: 6e4b 5370 6163 654d 6f6e 6974 6f72 2c0a  nKSpaceMonitor,.
-00011c20: 2020 2020 4469 6666 7261 6374 696f 6e4d      DiffractionM
-00011c30: 6f6e 6974 6f72 2c0a 5d0a 0a0a 636c 6173  onitor,.]...clas
-00011c40: 7320 4162 7374 7261 6374 4669 656c 6450  s AbstractFieldP
-00011c50: 726f 6a65 6374 696f 6e44 6174 6128 4d6f  rojectionData(Mo
-00011c60: 6e69 746f 7244 6174 6129 3a0a 2020 2020  nitorData):.    
-00011c70: 2222 2243 6f6c 6c65 6374 696f 6e20 6f66  """Collection of
-00011c80: 2070 726f 6a65 6374 6564 2066 6965 6c64   projected field
-00011c90: 7320 696e 2073 7068 6572 6963 616c 2063  s in spherical c
-00011ca0: 6f6f 7264 696e 6174 6573 2069 6e20 7468  oordinates in th
-00011cb0: 6520 6672 6571 7565 6e63 7920 646f 6d61  e frequency doma
-00011cc0: 696e 2e22 2222 0a0a 2020 2020 6d6f 6e69  in."""..    moni
-00011cd0: 746f 723a 2050 726f 6a4d 6f6e 6974 6f72  tor: ProjMonitor
-00011ce0: 5479 7065 203d 2070 642e 4669 656c 6428  Type = pd.Field(
-00011cf0: 0a20 2020 2020 2020 202e 2e2e 2c0a 2020  .        ...,.  
-00011d00: 2020 2020 2020 7469 746c 653d 2250 726f        title="Pro
-00011d10: 6a65 6374 696f 6e20 6d6f 6e69 746f 7222  jection monitor"
-00011d20: 2c0a 2020 2020 2020 2020 6465 7363 7269  ,.        descri
-00011d30: 7074 696f 6e3d 2246 6965 6c64 2070 726f  ption="Field pro
-00011d40: 6a65 6374 696f 6e20 6d6f 6e69 746f 722e  jection monitor.
-00011d50: 222c 0a20 2020 2020 2020 2064 6973 6372  ",.        discr
-00011d60: 696d 696e 6174 6f72 3d54 5950 455f 5441  iminator=TYPE_TA
-00011d70: 475f 5354 522c 0a20 2020 2029 0a0a 2020  G_STR,.    )..  
-00011d80: 2020 4572 3a20 5072 6f6a 4669 656c 6454    Er: ProjFieldT
-00011d90: 7970 6520 3d20 7064 2e46 6965 6c64 280a  ype = pd.Field(.
-00011da0: 2020 2020 2020 2020 2e2e 2e2c 0a20 2020          ...,.   
-00011db0: 2020 2020 2074 6974 6c65 3d22 4570 6869       title="Ephi
-00011dc0: 222c 0a20 2020 2020 2020 2064 6573 6372  ",.        descr
-00011dd0: 6970 7469 6f6e 3d22 5370 6174 6961 6c20  iption="Spatial 
-00011de0: 6469 7374 7269 6275 7469 6f6e 206f 6620  distribution of 
-00011df0: 722d 636f 6d70 6f6e 656e 7420 6f66 2074  r-component of t
-00011e00: 6865 2065 6c65 6374 7269 6320 6669 656c  he electric fiel
-00011e10: 642e 222c 0a20 2020 2029 0a20 2020 2045  d.",.    ).    E
-00011e20: 7468 6574 613a 2050 726f 6a46 6965 6c64  theta: ProjField
-00011e30: 5479 7065 203d 2070 642e 4669 656c 6428  Type = pd.Field(
-00011e40: 0a20 2020 2020 2020 202e 2e2e 2c0a 2020  .        ...,.  
-00011e50: 2020 2020 2020 7469 746c 653d 2245 7468        title="Eth
-00011e60: 6574 6122 2c0a 2020 2020 2020 2020 6465  eta",.        de
-00011e70: 7363 7269 7074 696f 6e3d 2253 7061 7469  scription="Spati
-00011e80: 616c 2064 6973 7472 6962 7574 696f 6e20  al distribution 
-00011e90: 6f66 2074 6865 2074 6865 7461 2d63 6f6d  of the theta-com
-00011ea0: 706f 6e65 6e74 206f 6620 7468 6520 656c  ponent of the el
-00011eb0: 6563 7472 6963 2066 6965 6c64 2e22 2c0a  ectric field.",.
-00011ec0: 2020 2020 290a 2020 2020 4570 6869 3a20      ).    Ephi: 
-00011ed0: 5072 6f6a 4669 656c 6454 7970 6520 3d20  ProjFieldType = 
-00011ee0: 7064 2e46 6965 6c64 280a 2020 2020 2020  pd.Field(.      
-00011ef0: 2020 2e2e 2e2c 0a20 2020 2020 2020 2074    ...,.        t
-00011f00: 6974 6c65 3d22 4570 6869 222c 0a20 2020  itle="Ephi",.   
-00011f10: 2020 2020 2064 6573 6372 6970 7469 6f6e       description
-00011f20: 3d22 5370 6174 6961 6c20 6469 7374 7269  ="Spatial distri
-00011f30: 6275 7469 6f6e 206f 6620 7068 692d 636f  bution of phi-co
-00011f40: 6d70 6f6e 656e 7420 6f66 2074 6865 2065  mponent of the e
-00011f50: 6c65 6374 7269 6320 6669 656c 642e 222c  lectric field.",
-00011f60: 0a20 2020 2029 0a20 2020 2048 723a 2050  .    ).    Hr: P
-00011f70: 726f 6a46 6965 6c64 5479 7065 203d 2070  rojFieldType = p
-00011f80: 642e 4669 656c 6428 0a20 2020 2020 2020  d.Field(.       
-00011f90: 202e 2e2e 2c0a 2020 2020 2020 2020 7469   ...,.        ti
-00011fa0: 746c 653d 2248 7068 6922 2c0a 2020 2020  tle="Hphi",.    
-00011fb0: 2020 2020 6465 7363 7269 7074 696f 6e3d      description=
-00011fc0: 2253 7061 7469 616c 2064 6973 7472 6962  "Spatial distrib
-00011fd0: 7574 696f 6e20 6f66 2072 2d63 6f6d 706f  ution of r-compo
-00011fe0: 6e65 6e74 206f 6620 7468 6520 6d61 676e  nent of the magn
-00011ff0: 6574 6963 2066 6965 6c64 2e22 2c0a 2020  etic field.",.  
-00012000: 2020 290a 2020 2020 4874 6865 7461 3a20    ).    Htheta: 
-00012010: 5072 6f6a 4669 656c 6454 7970 6520 3d20  ProjFieldType = 
-00012020: 7064 2e46 6965 6c64 280a 2020 2020 2020  pd.Field(.      
-00012030: 2020 2e2e 2e2c 0a20 2020 2020 2020 2074    ...,.        t
-00012040: 6974 6c65 3d22 4874 6865 7461 222c 0a20  itle="Htheta",. 
-00012050: 2020 2020 2020 2064 6573 6372 6970 7469         descripti
-00012060: 6f6e 3d22 5370 6174 6961 6c20 6469 7374  on="Spatial dist
-00012070: 7269 6275 7469 6f6e 206f 6620 7468 6574  ribution of thet
-00012080: 612d 636f 6d70 6f6e 656e 7420 6f66 2074  a-component of t
-00012090: 6865 206d 6167 6e65 7469 6320 6669 656c  he magnetic fiel
-000120a0: 642e 222c 0a20 2020 2029 0a20 2020 2048  d.",.    ).    H
-000120b0: 7068 693a 2050 726f 6a46 6965 6c64 5479  phi: ProjFieldTy
-000120c0: 7065 203d 2070 642e 4669 656c 6428 0a20  pe = pd.Field(. 
-000120d0: 2020 2020 2020 202e 2e2e 2c0a 2020 2020         ...,.    
-000120e0: 2020 2020 7469 746c 653d 2248 7068 6922      title="Hphi"
-000120f0: 2c0a 2020 2020 2020 2020 6465 7363 7269  ,.        descri
-00012100: 7074 696f 6e3d 2253 7061 7469 616c 2064  ption="Spatial d
-00012110: 6973 7472 6962 7574 696f 6e20 6f66 2070  istribution of p
-00012120: 6869 2d63 6f6d 706f 6e65 6e74 206f 6620  hi-component of 
-00012130: 7468 6520 6d61 676e 6574 6963 2066 6965  the magnetic fie
-00012140: 6c64 2e22 2c0a 2020 2020 290a 0a20 2020  ld.",.    )..   
-00012150: 206d 6564 6975 6d3a 204d 6564 6975 6d54   medium: MediumT
-00012160: 7970 6520 3d20 7064 2e46 6965 6c64 280a  ype = pd.Field(.
-00012170: 2020 2020 2020 2020 4d65 6469 756d 2829          Medium()
-00012180: 2c0a 2020 2020 2020 2020 7469 746c 653d  ,.        title=
-00012190: 2242 6163 6b67 726f 756e 6420 4d65 6469  "Background Medi
-000121a0: 756d 222c 0a20 2020 2020 2020 2064 6573  um",.        des
-000121b0: 6372 6970 7469 6f6e 3d22 4261 636b 6772  cription="Backgr
-000121c0: 6f75 6e64 206d 6564 6975 6d20 7468 726f  ound medium thro
-000121d0: 7567 6820 7768 6963 6820 746f 2070 726f  ugh which to pro
-000121e0: 6a65 6374 2066 6965 6c64 732e 222c 0a20  ject fields.",. 
-000121f0: 2020 2020 2020 2064 6973 6372 696d 696e         discrimin
-00012200: 6174 6f72 3d54 5950 455f 5441 475f 5354  ator=TYPE_TAG_ST
-00012210: 522c 0a20 2020 2029 0a0a 2020 2020 4070  R,.    )..    @p
-00012220: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
-00012230: 6669 656c 645f 636f 6d70 6f6e 656e 7473  field_components
-00012240: 2873 656c 6629 202d 3e20 4469 6374 5b73  (self) -> Dict[s
-00012250: 7472 2c20 4461 7461 4172 7261 795d 3a0a  tr, DataArray]:.
-00012260: 2020 2020 2020 2020 2222 224d 6170 7320          """Maps 
-00012270: 7468 6520 6669 656c 6420 636f 6d70 6f6e  the field compon
-00012280: 656e 7473 2074 6f20 7468 6569 7220 6173  ents to their as
-00012290: 736f 6369 6174 6564 2064 6174 612e 2222  sociated data.""
-000122a0: 220a 2020 2020 2020 2020 7265 7475 726e  ".        return
-000122b0: 2064 6963 7428 0a20 2020 2020 2020 2020   dict(.         
-000122c0: 2020 2045 723d 7365 6c66 2e45 722c 0a20     Er=self.Er,. 
-000122d0: 2020 2020 2020 2020 2020 2045 7468 6574             Ethet
-000122e0: 613d 7365 6c66 2e45 7468 6574 612c 0a20  a=self.Etheta,. 
-000122f0: 2020 2020 2020 2020 2020 2045 7068 693d             Ephi=
-00012300: 7365 6c66 2e45 7068 692c 0a20 2020 2020  self.Ephi,.     
-00012310: 2020 2020 2020 2048 723d 7365 6c66 2e48         Hr=self.H
-00012320: 722c 0a20 2020 2020 2020 2020 2020 2048  r,.            H
-00012330: 7468 6574 613d 7365 6c66 2e48 7468 6574  theta=self.Hthet
-00012340: 612c 0a20 2020 2020 2020 2020 2020 2048  a,.            H
-00012350: 7068 693d 7365 6c66 2e48 7068 692c 0a20  phi=self.Hphi,. 
-00012360: 2020 2020 2020 2029 0a0a 2020 2020 4070         )..    @p
-00012370: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
-00012380: 6628 7365 6c66 2920 2d3e 206e 702e 6e64  f(self) -> np.nd
-00012390: 6172 7261 793a 0a20 2020 2020 2020 2022  array:.        "
-000123a0: 2222 4672 6571 7565 6e63 6965 732e 2222  ""Frequencies.""
-000123b0: 220a 2020 2020 2020 2020 7265 7475 726e  ".        return
-000123c0: 206e 702e 6172 7261 7928 7365 6c66 2e45   np.array(self.E
-000123d0: 7468 6574 612e 636f 6f72 6473 5b22 6622  theta.coords["f"
-000123e0: 5d29 0a0a 2020 2020 4070 726f 7065 7274  ])..    @propert
-000123f0: 790a 2020 2020 6465 6620 636f 6f72 6473  y.    def coords
-00012400: 2873 656c 6629 202d 3e20 4469 6374 5b73  (self) -> Dict[s
-00012410: 7472 2c20 6e70 2e6e 6461 7272 6179 5d3a  tr, np.ndarray]:
-00012420: 0a20 2020 2020 2020 2022 2222 436f 6f72  .        """Coor
-00012430: 6469 6e61 7465 7320 6f66 2074 6865 2066  dinates of the f
-00012440: 6965 6c64 7320 636f 6e74 6169 6e65 642e  ields contained.
-00012450: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
-00012460: 726e 2073 656c 662e 4574 6865 7461 2e63  rn self.Etheta.c
-00012470: 6f6f 7264 730a 0a20 2020 2040 7072 6f70  oords..    @prop
-00012480: 6572 7479 0a20 2020 2064 6566 2063 6f6f  erty.    def coo
-00012490: 7264 735f 7370 6865 7269 6361 6c28 7365  rds_spherical(se
-000124a0: 6c66 2920 2d3e 2044 6963 745b 7374 722c  lf) -> Dict[str,
-000124b0: 206e 702e 6e64 6172 7261 795d 3a0a 2020   np.ndarray]:.  
-000124c0: 2020 2020 2020 2222 2243 6f6f 7264 696e        """Coordin
-000124d0: 6174 6573 2067 7269 6420 666f 7220 7468  ates grid for th
-000124e0: 6520 6669 656c 6473 2069 6e20 7468 6520  e fields in the 
-000124f0: 7370 6865 7269 6361 6c20 7379 7374 656d  spherical system
-00012500: 2e22 2222 0a20 2020 2020 2020 2069 6620  .""".        if 
-00012510: 2274 6865 7461 2220 696e 2073 656c 662e  "theta" in self.
-00012520: 636f 6f72 6473 2e6b 6579 7328 293a 0a20  coords.keys():. 
-00012530: 2020 2020 2020 2020 2020 2072 2c20 7468             r, th
-00012540: 6574 612c 2070 6869 203d 206e 702e 6d65  eta, phi = np.me
-00012550: 7368 6772 6964 280a 2020 2020 2020 2020  shgrid(.        
-00012560: 2020 2020 2020 2020 7365 6c66 2e63 6f6f          self.coo
-00012570: 7264 735b 2272 225d 2e76 616c 7565 732c  rds["r"].values,
-00012580: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00012590: 2073 656c 662e 636f 6f72 6473 5b22 7468   self.coords["th
-000125a0: 6574 6122 5d2e 7661 6c75 6573 2c0a 2020  eta"].values,.  
-000125b0: 2020 2020 2020 2020 2020 2020 2020 7365                se
-000125c0: 6c66 2e63 6f6f 7264 735b 2270 6869 225d  lf.coords["phi"]
-000125d0: 2e76 616c 7565 732c 0a20 2020 2020 2020  .values,.       
-000125e0: 2020 2020 2020 2020 2069 6e64 6578 696e           indexin
-000125f0: 673d 2269 6a22 2c0a 2020 2020 2020 2020  g="ij",.        
-00012600: 2020 2020 290a 2020 2020 2020 2020 656c      ).        el
-00012610: 6966 2022 7a22 2069 6e20 7365 6c66 2e63  if "z" in self.c
-00012620: 6f6f 7264 732e 6b65 7973 2829 3a0a 2020  oords.keys():.  
-00012630: 2020 2020 2020 2020 2020 7873 2c20 7973            xs, ys
-00012640: 2c20 7a73 203d 206e 702e 6d65 7368 6772  , zs = np.meshgr
-00012650: 6964 280a 2020 2020 2020 2020 2020 2020  id(.            
-00012660: 2020 2020 7365 6c66 2e63 6f6f 7264 735b      self.coords[
-00012670: 2278 225d 2e76 616c 7565 732c 0a20 2020  "x"].values,.   
-00012680: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-00012690: 662e 636f 6f72 6473 5b22 7922 5d2e 7661  f.coords["y"].va
-000126a0: 6c75 6573 2c0a 2020 2020 2020 2020 2020  lues,.          
-000126b0: 2020 2020 2020 7365 6c66 2e63 6f6f 7264        self.coord
-000126c0: 735b 227a 225d 2e76 616c 7565 732c 0a20  s["z"].values,. 
-000126d0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-000126e0: 6e64 6578 696e 673d 2269 6a22 2c0a 2020  ndexing="ij",.  
-000126f0: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-00012700: 2020 2020 2020 2020 722c 2074 6865 7461          r, theta
-00012710: 2c20 7068 6920 3d20 7365 6c66 2e6d 6f6e  , phi = self.mon
-00012720: 6974 6f72 2e63 6172 5f32 5f73 7068 2878  itor.car_2_sph(x
-00012730: 732c 2079 732c 207a 7329 0a20 2020 2020  s, ys, zs).     
-00012740: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00012750: 2020 2020 2075 7873 2c20 7579 732c 2072       uxs, uys, r
-00012760: 203d 206e 702e 6d65 7368 6772 6964 280a   = np.meshgrid(.
-00012770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012780: 7365 6c66 2e63 6f6f 7264 735b 2275 7822  self.coords["ux"
-00012790: 5d2e 7661 6c75 6573 2c0a 2020 2020 2020  ].values,.      
-000127a0: 2020 2020 2020 2020 2020 7365 6c66 2e63            self.c
-000127b0: 6f6f 7264 735b 2275 7922 5d2e 7661 6c75  oords["uy"].valu
-000127c0: 6573 2c0a 2020 2020 2020 2020 2020 2020  es,.            
-000127d0: 2020 2020 7365 6c66 2e63 6f6f 7264 735b      self.coords[
-000127e0: 2272 225d 2e76 616c 7565 732c 0a20 2020  "r"].values,.   
-000127f0: 2020 2020 2020 2020 2020 2020 2069 6e64               ind
-00012800: 6578 696e 673d 2269 6a22 2c0a 2020 2020  exing="ij",.    
-00012810: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
-00012820: 2020 2020 2020 7468 6574 612c 2070 6869        theta, phi
-00012830: 203d 2073 656c 662e 6d6f 6e69 746f 722e   = self.monitor.
-00012840: 6b73 7061 6365 5f32 5f73 7068 2875 7873  kspace_2_sph(uxs
-00012850: 2c20 7579 732c 2073 656c 662e 6d6f 6e69  , uys, self.moni
-00012860: 746f 722e 7072 6f6a 5f61 7869 7329 0a20  tor.proj_axis). 
-00012870: 2020 2020 2020 2072 6574 7572 6e20 7b22         return {"
-00012880: 7222 3a20 722c 2022 7468 6574 6122 3a20  r": r, "theta": 
-00012890: 7468 6574 612c 2022 7068 6922 3a20 7068  theta, "phi": ph
-000128a0: 697d 0a0a 2020 2020 4070 726f 7065 7274  i}..    @propert
-000128b0: 790a 2020 2020 6465 6620 6469 6d73 2873  y.    def dims(s
-000128c0: 656c 6629 202d 3e20 5475 706c 655b 7374  elf) -> Tuple[st
-000128d0: 722c 202e 2e2e 5d3a 0a20 2020 2020 2020  r, ...]:.       
-000128e0: 2022 2222 4469 6d65 6e73 696f 6e73 206f   """Dimensions o
-000128f0: 6620 7468 6520 7261 6469 6174 696f 6e20  f the radiation 
-00012900: 7665 6374 6f72 7320 636f 6e74 6169 6e65  vectors containe
-00012910: 642e 2222 220a 2020 2020 2020 2020 7265  d.""".        re
-00012920: 7475 726e 2073 656c 662e 4574 6865 7461  turn self.Etheta
-00012930: 2e64 696d 730a 0a20 2020 2064 6566 206d  .dims..    def m
-00012940: 616b 655f 6461 7461 5f61 7272 6179 2873  ake_data_array(s
-00012950: 656c 662c 2064 6174 613a 206e 702e 6e64  elf, data: np.nd
-00012960: 6172 7261 7929 202d 3e20 7872 2e44 6174  array) -> xr.Dat
-00012970: 6141 7272 6179 3a0a 2020 2020 2020 2020  aArray:.        
-00012980: 2222 224d 616b 6520 616e 2078 722e 4461  """Make an xr.Da
-00012990: 7461 4172 7261 7920 7769 7468 2064 6174  taArray with dat
-000129a0: 6120 616e 6420 7361 6d65 2063 6f6f 7264  a and same coord
-000129b0: 7320 616e 6420 6469 6d73 2061 7320 6669  s and dims as fi
-000129c0: 656c 6473 206f 6620 7365 6c66 2e22 2222  elds of self."""
-000129d0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-000129e0: 7872 2e44 6174 6141 7272 6179 2864 6174  xr.DataArray(dat
-000129f0: 613d 6461 7461 2c20 636f 6f72 6473 3d73  a=data, coords=s
-00012a00: 656c 662e 636f 6f72 6473 2c20 6469 6d73  elf.coords, dims
-00012a10: 3d73 656c 662e 6469 6d73 290a 0a20 2020  =self.dims)..   
-00012a20: 2064 6566 206d 616b 655f 6461 7461 7365   def make_datase
-00012a30: 7428 7365 6c66 2c20 6b65 7973 3a20 5475  t(self, keys: Tu
-00012a40: 706c 655b 7374 722c 202e 2e2e 5d2c 2076  ple[str, ...], v
-00012a50: 616c 733a 2054 7570 6c65 5b6e 702e 6e64  als: Tuple[np.nd
-00012a60: 6172 7261 792c 202e 2e2e 5d29 202d 3e20  array, ...]) -> 
-00012a70: 7872 2e44 6174 6173 6574 3a0a 2020 2020  xr.Dataset:.    
-00012a80: 2020 2020 2222 224d 616b 6520 616e 2078      """Make an x
-00012a90: 722e 4461 7461 7365 7420 7769 7468 206b  r.Dataset with k
-00012aa0: 6579 7320 616e 6420 6461 7461 2077 6974  eys and data wit
-00012ab0: 6820 7361 6d65 2063 6f6f 7264 7320 616e  h same coords an
-00012ac0: 6420 6469 6d73 2061 7320 6669 656c 6473  d dims as fields
-00012ad0: 2e22 2222 0a20 2020 2020 2020 2064 6174  .""".        dat
-00012ae0: 615f 6172 7261 7973 203d 2074 7570 6c65  a_arrays = tuple
-00012af0: 286d 6170 2873 656c 662e 6d61 6b65 5f64  (map(self.make_d
-00012b00: 6174 615f 6172 7261 792c 2076 616c 7329  ata_array, vals)
-00012b10: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
-00012b20: 2078 722e 4461 7461 7365 7428 6469 6374   xr.Dataset(dict
-00012b30: 287a 6970 286b 6579 732c 2064 6174 615f  (zip(keys, data_
-00012b40: 6172 7261 7973 2929 290a 0a20 2020 2064  arrays)))..    d
-00012b50: 6566 206d 616b 655f 7265 6e6f 726d 616c  ef make_renormal
-00012b60: 697a 6564 5f64 6174 6128 0a20 2020 2020  ized_data(.     
-00012b70: 2020 2073 656c 662c 2070 6861 7365 3a20     self, phase: 
-00012b80: 6e70 2e6e 6461 7272 6179 2c20 7072 6f6a  np.ndarray, proj
-00012b90: 5f64 6973 7461 6e63 653a 2066 6c6f 6174  _distance: float
-00012ba0: 0a20 2020 2029 202d 3e20 4162 7374 7261  .    ) -> Abstra
-00012bb0: 6374 4669 656c 6450 726f 6a65 6374 696f  ctFieldProjectio
-00012bc0: 6e44 6174 613a 0a20 2020 2020 2020 2022  nData:.        "
-00012bd0: 2222 4865 6c70 6572 2074 6f20 6170 706c  ""Helper to appl
-00012be0: 7920 7468 6520 7265 2d70 726f 6a65 6374  y the re-project
-00012bf0: 696f 6e20 7068 6173 6520 746f 2061 2063  ion phase to a c
-00012c00: 6f70 6965 6420 6461 7461 7365 742e 2222  opied dataset.""
-00012c10: 220a 2020 2020 2020 2020 6e65 775f 6461  ".        new_da
-00012c20: 7461 203d 2073 656c 662e 636f 7079 2829  ta = self.copy()
-00012c30: 0a20 2020 2020 2020 2066 6f72 2066 6965  .        for fie
-00012c40: 6c64 2069 6e20 6e65 775f 6461 7461 2e66  ld in new_data.f
-00012c50: 6965 6c64 5f63 6f6d 706f 6e65 6e74 732e  ield_components.
-00012c60: 7661 6c75 6573 2829 3a0a 2020 2020 2020  values():.      
-00012c70: 2020 2020 2020 6669 656c 642e 7661 6c75        field.valu
-00012c80: 6573 202a 3d20 7068 6173 650a 2020 2020  es *= phase.    
-00012c90: 2020 2020 2020 2020 6966 2022 7222 2069          if "r" i
-00012ca0: 6e20 7365 6c66 2e63 6f6f 7264 732e 6b65  n self.coords.ke
-00012cb0: 7973 2829 3a0a 2020 2020 2020 2020 2020  ys():.          
-00012cc0: 2020 2020 2020 6669 656c 645b 2272 225d        field["r"]
-00012cd0: 203d 206e 702e 6174 6c65 6173 745f 3164   = np.atleast_1d
-00012ce0: 2870 726f 6a5f 6469 7374 616e 6365 290a  (proj_distance).
-00012cf0: 2020 2020 2020 2020 7265 7475 726e 206e          return n
-00012d00: 6577 5f64 6174 610a 0a20 2020 2064 6566  ew_data..    def
-00012d10: 206e 6f72 6d61 6c69 7a65 280a 2020 2020   normalize(.    
-00012d20: 2020 2020 7365 6c66 2c20 736f 7572 6365      self, source
-00012d30: 5f73 7065 6374 7275 6d5f 666e 3a20 4361  _spectrum_fn: Ca
-00012d40: 6c6c 6162 6c65 5b5b 666c 6f61 745d 2c20  llable[[float], 
-00012d50: 636f 6d70 6c65 785d 0a20 2020 2029 202d  complex].    ) -
-00012d60: 3e20 4162 7374 7261 6374 4669 656c 6450  > AbstractFieldP
-00012d70: 726f 6a65 6374 696f 6e44 6174 613a 0a20  rojectionData:. 
-00012d80: 2020 2020 2020 2022 2222 5265 7475 726e         """Return
-00012d90: 2063 6f70 7920 6f66 2073 656c 6620 6166   copy of self af
-00012da0: 7465 7220 6e6f 726d 616c 697a 6174 696f  ter normalizatio
-00012db0: 6e20 6973 2061 7070 6c69 6564 2075 7369  n is applied usi
-00012dc0: 6e67 2073 6f75 7263 6520 7370 6563 7472  ng source spectr
-00012dd0: 756d 2066 756e 6374 696f 6e2e 2222 220a  um function.""".
-00012de0: 2020 2020 2020 2020 6669 656c 6473 5f6e          fields_n
-00012df0: 6f72 6d20 3d20 7b7d 0a20 2020 2020 2020  orm = {}.       
-00012e00: 2066 6f72 2066 6965 6c64 5f6e 616d 652c   for field_name,
-00012e10: 2066 6965 6c64 5f64 6174 6120 696e 2073   field_data in s
-00012e20: 656c 662e 6669 656c 645f 636f 6d70 6f6e  elf.field_compon
-00012e30: 656e 7473 2e69 7465 6d73 2829 3a0a 2020  ents.items():.  
-00012e40: 2020 2020 2020 2020 2020 7372 635f 616d            src_am
-00012e50: 7073 203d 2073 6f75 7263 655f 7370 6563  ps = source_spec
-00012e60: 7472 756d 5f66 6e28 6669 656c 645f 6461  trum_fn(field_da
-00012e70: 7461 2e66 290a 2020 2020 2020 2020 2020  ta.f).          
-00012e80: 2020 6669 656c 6473 5f6e 6f72 6d5b 6669    fields_norm[fi
-00012e90: 656c 645f 6e61 6d65 5d20 3d20 2866 6965  eld_name] = (fie
-00012ea0: 6c64 5f64 6174 6120 2f20 7372 635f 616d  ld_data / src_am
-00012eb0: 7073 292e 6173 7479 7065 2866 6965 6c64  ps).astype(field
-00012ec0: 5f64 6174 612e 6474 7970 6529 0a0a 2020  _data.dtype)..  
-00012ed0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-00012ee0: 662e 636f 7079 2875 7064 6174 653d 6669  f.copy(update=fi
-00012ef0: 656c 6473 5f6e 6f72 6d29 0a0a 2020 2020  elds_norm)..    
-00012f00: 4073 7461 7469 636d 6574 686f 640a 2020  @staticmethod.  
-00012f10: 2020 6465 6620 7761 7665 6e75 6d62 6572    def wavenumber
-00012f20: 286d 6564 6975 6d3a 204d 6564 6975 6d54  (medium: MediumT
-00012f30: 7970 652c 2066 7265 7175 656e 6379 3a20  ype, frequency: 
-00012f40: 666c 6f61 7429 202d 3e20 636f 6d70 6c65  float) -> comple
-00012f50: 783a 0a20 2020 2020 2020 2022 2222 436f  x:.        """Co
-00012f60: 6d70 6c65 7820 7661 6c75 6564 2077 6176  mplex valued wav
-00012f70: 656e 756d 6265 7220 6173 736f 6369 6174  enumber associat
-00012f80: 6564 2077 6974 6820 6120 6672 6571 7565  ed with a freque
-00012f90: 6e63 792e 2222 220a 2020 2020 2020 2020  ncy.""".        
-00012fa0: 696e 6465 785f 6e2c 2069 6e64 6578 5f6b  index_n, index_k
-00012fb0: 203d 206d 6564 6975 6d2e 6e6b 5f6d 6f64   = medium.nk_mod
-00012fc0: 656c 2866 7265 7175 656e 6379 3d66 7265  el(frequency=fre
-00012fd0: 7175 656e 6379 290a 2020 2020 2020 2020  quency).        
-00012fe0: 7265 7475 726e 2028 3220 2a20 6e70 2e70  return (2 * np.p
-00012ff0: 6920 2a20 6672 6571 7565 6e63 7920 2f20  i * frequency / 
-00013000: 435f 3029 202a 2028 696e 6465 785f 6e20  C_0) * (index_n 
-00013010: 2b20 316a 202a 2069 6e64 6578 5f6b 290a  + 1j * index_k).
-00013020: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
-00013030: 2020 2064 6566 206e 6b28 7365 6c66 2920     def nk(self) 
-00013040: 2d3e 2054 7570 6c65 5b66 6c6f 6174 2c20  -> Tuple[float, 
-00013050: 666c 6f61 745d 3a0a 2020 2020 2020 2020  float]:.        
-00013060: 2222 2252 6574 7572 6e73 2074 6865 2072  """Returns the r
-00013070: 6561 6c20 616e 6420 696d 6167 696e 6172  eal and imaginar
-00013080: 7920 7061 7274 7320 6f66 2074 6865 2062  y parts of the b
-00013090: 6163 6b67 726f 756e 6420 6d65 6469 756d  ackground medium
-000130a0: 2773 2072 6566 7261 6374 6976 6520 696e  's refractive in
-000130b0: 6465 782e 2222 220a 2020 2020 2020 2020  dex.""".        
-000130c0: 7265 7475 726e 2073 656c 662e 6d65 6469  return self.medi
-000130d0: 756d 2e6e 6b5f 6d6f 6465 6c28 6672 6571  um.nk_model(freq
-000130e0: 7565 6e63 793d 7365 6c66 2e66 290a 0a20  uency=self.f).. 
-000130f0: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
-00013100: 2064 6566 206b 2873 656c 6629 202d 3e20   def k(self) -> 
-00013110: 636f 6d70 6c65 783a 0a20 2020 2020 2020  complex:.       
-00013120: 2022 2222 5265 7475 726e 7320 7468 6520   """Returns the 
-00013130: 636f 6d70 6c65 7820 7761 7665 206e 756d  complex wave num
-00013140: 6265 7220 6173 736f 6369 6174 6564 2077  ber associated w
-00013150: 6974 6820 7468 6520 6261 636b 6772 6f75  ith the backgrou
-00013160: 6e64 206d 6564 6975 6d2e 2222 220a 2020  nd medium.""".  
-00013170: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-00013180: 662e 7761 7665 6e75 6d62 6572 286d 6564  f.wavenumber(med
-00013190: 6975 6d3d 7365 6c66 2e6d 6564 6975 6d2c  ium=self.medium,
-000131a0: 2066 7265 7175 656e 6379 3d73 656c 662e   frequency=self.
-000131b0: 6629 0a0a 2020 2020 4070 726f 7065 7274  f)..    @propert
-000131c0: 790a 2020 2020 6465 6620 6574 6128 7365  y.    def eta(se
-000131d0: 6c66 2920 2d3e 2063 6f6d 706c 6578 3a0a  lf) -> complex:.
-000131e0: 2020 2020 2020 2020 2222 2252 6574 7572          """Retur
-000131f0: 6e73 2074 6865 2063 6f6d 706c 6578 2077  ns the complex w
-00013200: 6176 6520 696d 7065 6461 6e63 6520 6173  ave impedance as
-00013210: 736f 6369 6174 6564 2077 6974 6820 7468  sociated with th
-00013220: 6520 6261 636b 6772 6f75 6e64 206d 6564  e background med
-00013230: 6975 6d2e 2222 220a 2020 2020 2020 2020  ium.""".        
-00013240: 6570 735f 636f 6d70 6c65 7820 3d20 7365  eps_complex = se
-00013250: 6c66 2e6d 6564 6975 6d2e 6570 735f 6d6f  lf.medium.eps_mo
-00013260: 6465 6c28 6672 6571 7565 6e63 793d 7365  del(frequency=se
-00013270: 6c66 2e66 290a 2020 2020 2020 2020 7265  lf.f).        re
-00013280: 7475 726e 2045 5441 5f30 202f 206e 702e  turn ETA_0 / np.
-00013290: 7371 7274 2865 7073 5f63 6f6d 706c 6578  sqrt(eps_complex
-000132a0: 290a 0a20 2020 2040 7374 6174 6963 6d65  )..    @staticme
-000132b0: 7468 6f64 0a20 2020 2064 6566 2070 726f  thod.    def pro
-000132c0: 7061 6761 7469 6f6e 5f70 6861 7365 2864  pagation_phase(d
-000132d0: 6973 743a 2055 6e69 6f6e 5b66 6c6f 6174  ist: Union[float
-000132e0: 2c20 4e6f 6e65 5d2c 206b 3a20 636f 6d70  , None], k: comp
-000132f0: 6c65 7829 202d 3e20 636f 6d70 6c65 783a  lex) -> complex:
-00013300: 0a20 2020 2020 2020 2022 2222 5068 6173  .        """Phas
-00013310: 6520 6173 736f 6369 6174 6564 2077 6974  e associated wit
-00013320: 6820 7072 6f70 6167 6174 696f 6e20 6f66  h propagation of
-00013330: 2061 2064 6973 7461 6e63 6520 7769 7468   a distance with
-00013340: 2061 2067 6976 656e 2077 6176 656e 756d   a given wavenum
-00013350: 6265 722e 2222 220a 2020 2020 2020 2020  ber.""".        
-00013360: 6966 2064 6973 7420 6973 204e 6f6e 653a  if dist is None:
-00013370: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00013380: 7572 6e20 312e 300a 2020 2020 2020 2020  urn 1.0.        
-00013390: 7265 7475 726e 202d 316a 202a 206b 202a  return -1j * k *
-000133a0: 206e 702e 6578 7028 316a 202a 206b 202a   np.exp(1j * k *
-000133b0: 2064 6973 7429 202f 2028 3420 2a20 6e70   dist) / (4 * np
-000133c0: 2e70 6920 2a20 6469 7374 290a 0a20 2020  .pi * dist)..   
-000133d0: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
-000133e0: 6566 2066 6965 6c64 735f 7370 6865 7269  ef fields_spheri
-000133f0: 6361 6c28 7365 6c66 2920 2d3e 2078 722e  cal(self) -> xr.
-00013400: 4461 7461 7365 743a 0a20 2020 2020 2020  Dataset:.       
-00013410: 2022 2222 4765 7420 616c 6c20 6669 656c   """Get all fiel
-00013420: 6420 636f 6d70 6f6e 656e 7473 2069 6e20  d components in 
-00013430: 7370 6865 7269 6361 6c20 636f 6f72 6469  spherical coordi
-00013440: 6e61 7465 7320 7265 6c61 7469 7665 2074  nates relative t
-00013450: 6f20 7468 6520 6d6f 6e69 746f 7227 730a  o the monitor's.
-00013460: 2020 2020 2020 2020 6c6f 6361 6c20 6f72          local or
-00013470: 6967 696e 2066 6f72 2061 6c6c 2070 726f  igin for all pro
-00013480: 6a65 6374 696f 6e20 6772 6964 2070 6f69  jection grid poi
-00013490: 6e74 7320 616e 6420 6672 6571 7565 6e63  nts and frequenc
-000134a0: 6965 7320 7370 6563 6966 6965 6420 696e  ies specified in
-000134b0: 2074 6865 0a20 2020 2020 2020 203a 636c   the.        :cl
-000134c0: 6173 733a 6041 6273 7472 6163 7446 6965  ass:`AbstractFie
-000134d0: 6c64 5072 6f6a 6563 7469 6f6e 4d6f 6e69  ldProjectionMoni
-000134e0: 746f 7260 2e0a 0a20 2020 2020 2020 2052  tor`...        R
-000134f0: 6574 7572 6e73 0a20 2020 2020 2020 202d  eturns.        -
-00013500: 2d2d 2d2d 2d2d 0a20 2020 2020 2020 2060  ------.        `
-00013510: 6078 6172 7261 792e 4461 7461 7365 7460  `xarray.Dataset`
-00013520: 600a 2020 2020 2020 2020 2020 2020 7861  `.            xa
-00013530: 7272 6179 2064 6174 6173 6574 2063 6f6e  rray dataset con
-00013540: 7461 696e 696e 670a 2020 2020 2020 2020  taining.        
-00013550: 2020 2020 2860 6045 7260 602c 2060 6045      (``Er``, ``E
-00013560: 7468 6574 6160 602c 2060 6045 7068 6960  theta``, ``Ephi`
-00013570: 602c 2060 6048 7260 602c 2060 6048 7468  `, ``Hr``, ``Hth
-00013580: 6574 6160 602c 2060 6048 7068 6960 6029  eta``, ``Hphi``)
-00013590: 0a20 2020 2020 2020 2020 2020 2069 6e20  .            in 
-000135a0: 7370 6865 7269 6361 6c20 636f 6f72 6469  spherical coordi
-000135b0: 6e61 7465 732e 0a20 2020 2020 2020 2022  nates..        "
-000135c0: 2222 0a20 2020 2020 2020 2072 6574 7572  "".        retur
-000135d0: 6e20 7365 6c66 2e6d 616b 655f 6461 7461  n self.make_data
-000135e0: 7365 7428 0a20 2020 2020 2020 2020 2020  set(.           
-000135f0: 206b 6579 733d 7365 6c66 2e66 6965 6c64   keys=self.field
-00013600: 5f63 6f6d 706f 6e65 6e74 732e 6b65 7973  _components.keys
-00013610: 2829 2c20 7661 6c73 3d73 656c 662e 6669  (), vals=self.fi
-00013620: 656c 645f 636f 6d70 6f6e 656e 7473 2e76  eld_components.v
-00013630: 616c 7565 7328 290a 2020 2020 2020 2020  alues().        
-00013640: 290a 0a20 2020 2040 7072 6f70 6572 7479  )..    @property
-00013650: 0a20 2020 2064 6566 2066 6965 6c64 735f  .    def fields_
-00013660: 6361 7274 6573 6961 6e28 7365 6c66 2920  cartesian(self) 
-00013670: 2d3e 2078 722e 4461 7461 7365 743a 0a20  -> xr.Dataset:. 
-00013680: 2020 2020 2020 2022 2222 4765 7420 616c         """Get al
-00013690: 6c20 6669 656c 6420 636f 6d70 6f6e 656e  l field componen
-000136a0: 7473 2069 6e20 4361 7274 6573 6961 6e20  ts in Cartesian 
-000136b0: 636f 6f72 6469 6e61 7465 7320 7265 6c61  coordinates rela
-000136c0: 7469 7665 2074 6f20 7468 6520 6d6f 6e69  tive to the moni
-000136d0: 746f 7227 730a 2020 2020 2020 2020 6c6f  tor's.        lo
-000136e0: 6361 6c20 6f72 6967 696e 2066 6f72 2061  cal origin for a
-000136f0: 6c6c 2070 726f 6a65 6374 696f 6e20 6772  ll projection gr
-00013700: 6964 2070 6f69 6e74 7320 616e 6420 6672  id points and fr
-00013710: 6571 7565 6e63 6965 7320 7370 6563 6966  equencies specif
-00013720: 6965 6420 696e 2074 6865 0a20 2020 2020  ied in the.     
-00013730: 2020 203a 636c 6173 733a 6041 6273 7472     :class:`Abstr
-00013740: 6163 7446 6965 6c64 5072 6f6a 6563 7469  actFieldProjecti
-00013750: 6f6e 4d6f 6e69 746f 7260 2e0a 0a20 2020  onMonitor`...   
-00013760: 2020 2020 2052 6574 7572 6e73 0a20 2020       Returns.   
-00013770: 2020 2020 202d 2d2d 2d2d 2d2d 0a20 2020       -------.   
-00013780: 2020 2020 2060 6078 6172 7261 792e 4461       ``xarray.Da
-00013790: 7461 7365 7460 600a 2020 2020 2020 2020  taset``.        
-000137a0: 2020 2020 7861 7272 6179 2064 6174 6173      xarray datas
-000137b0: 6574 2063 6f6e 7461 696e 696e 6720 2860  et containing (`
-000137c0: 6045 7860 602c 2060 6045 7960 602c 2060  `Ex``, ``Ey``, `
-000137d0: 6045 7a60 602c 2060 6048 7860 602c 2060  `Ez``, ``Hx``, `
-000137e0: 6048 7960 602c 2060 6048 7a60 6029 0a20  `Hy``, ``Hz``). 
-000137f0: 2020 2020 2020 2020 2020 2069 6e20 4361             in Ca
-00013800: 7274 6573 6961 6e20 636f 6f72 6469 6e61  rtesian coordina
-00013810: 7465 732e 0a20 2020 2020 2020 2022 2222  tes..        """
-00013820: 0a20 2020 2020 2020 2023 2063 6f6e 7665  .        # conve
-00013830: 7274 2074 6865 2066 6965 6c64 2063 6f6d  rt the field com
-00013840: 706f 6e65 6e74 7320 746f 2074 6865 2043  ponents to the C
-00013850: 6172 7465 7369 616e 2063 6f6f 7264 696e  artesian coordin
-00013860: 6174 6520 7379 7374 656d 0a20 2020 2020  ate system.     
-00013870: 2020 2063 6f6f 7264 735f 7370 6820 3d20     coords_sph = 
-00013880: 7365 6c66 2e63 6f6f 7264 735f 7370 6865  self.coords_sphe
-00013890: 7269 6361 6c0a 2020 2020 2020 2020 655f  rical.        e_
-000138a0: 6461 7461 203d 2073 656c 662e 6d6f 6e69  data = self.moni
-000138b0: 746f 722e 7370 685f 325f 6361 725f 6669  tor.sph_2_car_fi
-000138c0: 656c 6428 0a20 2020 2020 2020 2020 2020  eld(.           
-000138d0: 2073 656c 662e 4572 2e76 616c 7565 732c   self.Er.values,
-000138e0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-000138f0: 662e 4574 6865 7461 2e76 616c 7565 732c  f.Etheta.values,
-00013900: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00013910: 662e 4570 6869 2e76 616c 7565 732c 0a20  f.Ephi.values,. 
-00013920: 2020 2020 2020 2020 2020 2063 6f6f 7264             coord
-00013930: 735f 7370 685b 2274 6865 7461 225d 5b2e  s_sph["theta"][.
-00013940: 2e2e 2c20 4e6f 6e65 5d2c 0a20 2020 2020  .., None],.     
-00013950: 2020 2020 2020 2063 6f6f 7264 735f 7370         coords_sp
-00013960: 685b 2270 6869 225d 5b2e 2e2e 2c20 4e6f  h["phi"][..., No
-00013970: 6e65 5d2c 0a20 2020 2020 2020 2029 0a20  ne],.        ). 
-00013980: 2020 2020 2020 2068 5f64 6174 6120 3d20         h_data = 
-00013990: 7365 6c66 2e6d 6f6e 6974 6f72 2e73 7068  self.monitor.sph
-000139a0: 5f32 5f63 6172 5f66 6965 6c64 280a 2020  _2_car_field(.  
-000139b0: 2020 2020 2020 2020 2020 7365 6c66 2e48            self.H
-000139c0: 722e 7661 6c75 6573 2c0a 2020 2020 2020  r.values,.      
-000139d0: 2020 2020 2020 7365 6c66 2e48 7468 6574        self.Hthet
-000139e0: 612e 7661 6c75 6573 2c0a 2020 2020 2020  a.values,.      
-000139f0: 2020 2020 2020 7365 6c66 2e48 7068 692e        self.Hphi.
-00013a00: 7661 6c75 6573 2c0a 2020 2020 2020 2020  values,.        
-00013a10: 2020 2020 636f 6f72 6473 5f73 7068 5b22      coords_sph["
-00013a20: 7468 6574 6122 5d5b 2e2e 2e2c 204e 6f6e  theta"][..., Non
-00013a30: 655d 2c0a 2020 2020 2020 2020 2020 2020  e],.            
-00013a40: 636f 6f72 6473 5f73 7068 5b22 7068 6922  coords_sph["phi"
-00013a50: 5d5b 2e2e 2e2c 204e 6f6e 655d 2c0a 2020  ][..., None],.  
-00013a60: 2020 2020 2020 290a 0a20 2020 2020 2020        )..       
-00013a70: 2023 2070 6163 6b61 6765 2069 6e74 6f20   # package into 
-00013a80: 6461 7461 7365 740a 2020 2020 2020 2020  dataset.        
-00013a90: 6b65 7973 203d 2028 2245 7822 2c20 2245  keys = ("Ex", "E
-00013aa0: 7922 2c20 2245 7a22 2c20 2248 7822 2c20  y", "Ez", "Hx", 
-00013ab0: 2248 7922 2c20 2248 7a22 290a 2020 2020  "Hy", "Hz").    
-00013ac0: 2020 2020 6669 656c 645f 636f 6d70 6f6e      field_compon
-00013ad0: 656e 7473 203d 206e 702e 636f 6e63 6174  ents = np.concat
-00013ae0: 656e 6174 6528 2865 5f64 6174 612c 2068  enate((e_data, h
-00013af0: 5f64 6174 6129 2c20 6178 6973 3d30 290a  _data), axis=0).
-00013b00: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-00013b10: 656c 662e 6d61 6b65 5f64 6174 6173 6574  elf.make_dataset
-00013b20: 286b 6579 733d 6b65 7973 2c20 7661 6c73  (keys=keys, vals
-00013b30: 3d66 6965 6c64 5f63 6f6d 706f 6e65 6e74  =field_component
-00013b40: 7329 0a0a 2020 2020 4070 726f 7065 7274  s)..    @propert
-00013b50: 790a 2020 2020 6465 6620 706f 7765 7228  y.    def power(
-00013b60: 7365 6c66 2920 2d3e 2078 722e 4461 7461  self) -> xr.Data
-00013b70: 4172 7261 793a 0a20 2020 2020 2020 2022  Array:.        "
-00013b80: 2222 4765 7420 706f 7765 7220 6d65 6173  ""Get power meas
-00013b90: 7572 6564 206f 6e20 7468 6520 7072 6f6a  ured on the proj
-00013ba0: 6563 7469 6f6e 2067 7269 6420 7265 6c61  ection grid rela
-00013bb0: 7469 7665 2074 6f20 7468 6520 6d6f 6e69  tive to the moni
-00013bc0: 746f 7227 7320 6c6f 6361 6c20 6f72 6967  tor's local orig
-00013bd0: 696e 2e0a 0a20 2020 2020 2020 2052 6574  in...        Ret
-00013be0: 7572 6e73 0a20 2020 2020 2020 202d 2d2d  urns.        ---
-00013bf0: 2d2d 2d2d 0a20 2020 2020 2020 2060 6078  ----.        ``x
-00013c00: 6172 7261 792e 4461 7461 4172 7261 7960  array.DataArray`
-00013c10: 600a 2020 2020 2020 2020 2020 2020 506f  `.            Po
-00013c20: 7765 7220 6174 2070 6f69 6e74 7320 7265  wer at points re
-00013c30: 6c61 7469 7665 2074 6f20 7468 6520 6c6f  lative to the lo
-00013c40: 6361 6c20 6f72 6967 696e 2e0a 2020 2020  cal origin..    
-00013c50: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-00013c60: 706f 7765 725f 7468 6574 6120 3d20 302e  power_theta = 0.
-00013c70: 3520 2a20 6e70 2e72 6561 6c28 7365 6c66  5 * np.real(self
-00013c80: 2e45 7468 6574 612e 7661 6c75 6573 202a  .Etheta.values *
-00013c90: 206e 702e 636f 6e6a 2873 656c 662e 4870   np.conj(self.Hp
-00013ca0: 6869 2e76 616c 7565 7329 290a 2020 2020  hi.values)).    
-00013cb0: 2020 2020 706f 7765 725f 7068 6920 3d20      power_phi = 
-00013cc0: 302e 3520 2a20 6e70 2e72 6561 6c28 2d73  0.5 * np.real(-s
-00013cd0: 656c 662e 4570 6869 2e76 616c 7565 7320  elf.Ephi.values 
-00013ce0: 2a20 6e70 2e63 6f6e 6a28 7365 6c66 2e48  * np.conj(self.H
-00013cf0: 7468 6574 612e 7661 6c75 6573 2929 0a20  theta.values)). 
-00013d00: 2020 2020 2020 2070 6f77 6572 203d 2070         power = p
-00013d10: 6f77 6572 5f74 6865 7461 202b 2070 6f77  ower_theta + pow
-00013d20: 6572 5f70 6869 0a0a 2020 2020 2020 2020  er_phi..        
-00013d30: 7265 7475 726e 2073 656c 662e 6d61 6b65  return self.make
-00013d40: 5f64 6174 615f 6172 7261 7928 6461 7461  _data_array(data
-00013d50: 3d70 6f77 6572 290a 0a20 2020 2040 7072  =power)..    @pr
-00013d60: 6f70 6572 7479 0a20 2020 2064 6566 2072  operty.    def r
-00013d70: 6164 6172 5f63 726f 7373 5f73 6563 7469  adar_cross_secti
-00013d80: 6f6e 2873 656c 6629 202d 3e20 7872 2e44  on(self) -> xr.D
-00013d90: 6174 6141 7272 6179 3a0a 2020 2020 2020  ataArray:.      
-00013da0: 2020 2222 2252 6164 6172 2063 726f 7373    """Radar cross
-00013db0: 2073 6563 7469 6f6e 2069 6e20 756e 6974   section in unit
-00013dc0: 7320 6f66 2069 6e63 6964 656e 7420 706f  s of incident po
-00013dd0: 7765 722e 2222 220a 0a20 2020 2020 2020  wer."""..       
-00013de0: 205f 2c20 696e 6465 785f 6b20 3d20 7365   _, index_k = se
-00013df0: 6c66 2e6e 6b0a 2020 2020 2020 2020 6966  lf.nk.        if
-00013e00: 206e 6f74 206e 702e 616c 6c28 696e 6465   not np.all(inde
-00013e10: 785f 6b20 3d3d 2030 293a 0a20 2020 2020  x_k == 0):.     
-00013e20: 2020 2020 2020 2072 6169 7365 2053 6574         raise Set
-00013e30: 7570 4572 726f 7228 2243 616e 2774 2063  upError("Can't c
-00013e40: 6f6d 7075 7465 2052 4353 2066 6f72 2061  ompute RCS for a
-00013e50: 206c 6f73 7379 2062 6163 6b67 726f 756e   lossy backgroun
-00013e60: 6420 6d65 6469 756d 2e22 290a 0a20 2020  d medium.")..   
-00013e70: 2020 2020 206b 203d 2073 656c 662e 6b5b       k = self.k[
-00013e80: 4e6f 6e65 2c20 4e6f 6e65 2c20 4e6f 6e65  None, None, None
-00013e90: 2c20 2e2e 2e5d 0a20 2020 2020 2020 2065  , ...].        e
-00013ea0: 7461 203d 2073 656c 662e 6574 615b 4e6f  ta = self.eta[No
-00013eb0: 6e65 2c20 4e6f 6e65 2c20 4e6f 6e65 2c20  ne, None, None, 
-00013ec0: 2e2e 2e5d 0a0a 2020 2020 2020 2020 636f  ...]..        co
-00013ed0: 6e73 7461 6e74 203d 206b 2a2a 3220 2f20  nstant = k**2 / 
-00013ee0: 2838 202a 206e 702e 7069 202a 2065 7461  (8 * np.pi * eta
-00013ef0: 290a 0a20 2020 2020 2020 2023 206e 6f72  )..        # nor
-00013f00: 6d61 6c69 7a65 2066 6965 6c64 7320 6279  malize fields by
-00013f10: 2074 6865 2064 6973 7461 6e63 652d 6261   the distance-ba
-00013f20: 7365 6420 7068 6173 6520 6661 6374 6f72  sed phase factor
-00013f30: 0a20 2020 2020 2020 2063 6f6f 7264 735f  .        coords_
-00013f40: 7370 6820 3d20 7365 6c66 2e63 6f6f 7264  sph = self.coord
-00013f50: 735f 7370 6865 7269 6361 6c0a 2020 2020  s_spherical.    
-00013f60: 2020 2020 6966 2063 6f6f 7264 735f 7370      if coords_sp
-00013f70: 685b 2272 225d 2069 7320 4e6f 6e65 3a0a  h["r"] is None:.
-00013f80: 2020 2020 2020 2020 2020 2020 7068 6173              phas
-00013f90: 6520 3d20 312e 300a 2020 2020 2020 2020  e = 1.0.        
-00013fa0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-00013fb0: 2020 7068 6173 6520 3d20 7365 6c66 2e70    phase = self.p
-00013fc0: 726f 7061 6761 7469 6f6e 5f70 6861 7365  ropagation_phase
-00013fd0: 2864 6973 743d 636f 6f72 6473 5f73 7068  (dist=coords_sph
-00013fe0: 5b22 7222 5d5b 2e2e 2e2c 204e 6f6e 655d  ["r"][..., None]
-00013ff0: 2c20 6b3d 6b29 0a20 2020 2020 2020 2045  , k=k).        E
-00014000: 7468 6574 6120 3d20 7365 6c66 2e45 7468  theta = self.Eth
-00014010: 6574 612e 7661 6c75 6573 202f 2070 6861  eta.values / pha
-00014020: 7365 0a20 2020 2020 2020 2045 7068 6920  se.        Ephi 
-00014030: 3d20 7365 6c66 2e45 7068 692e 7661 6c75  = self.Ephi.valu
-00014040: 6573 202f 2070 6861 7365 0a20 2020 2020  es / phase.     
-00014050: 2020 2072 6373 5f64 6174 6120 3d20 636f     rcs_data = co
-00014060: 6e73 7461 6e74 202a 2028 6e70 2e61 6273  nstant * (np.abs
-00014070: 2845 7468 6574 6129 202a 2a20 3220 2b20  (Etheta) ** 2 + 
-00014080: 6e70 2e61 6273 2845 7068 6929 202a 2a20  np.abs(Ephi) ** 
-00014090: 3229 0a0a 2020 2020 2020 2020 7265 7475  2)..        retu
-000140a0: 726e 2073 656c 662e 6d61 6b65 5f64 6174  rn self.make_dat
-000140b0: 615f 6172 7261 7928 6461 7461 3d72 6373  a_array(data=rcs
-000140c0: 5f64 6174 6129 0a0a 0a63 6c61 7373 2046  _data)...class F
-000140d0: 6965 6c64 5072 6f6a 6563 7469 6f6e 416e  ieldProjectionAn
-000140e0: 676c 6544 6174 6128 4162 7374 7261 6374  gleData(Abstract
-000140f0: 4669 656c 6450 726f 6a65 6374 696f 6e44  FieldProjectionD
-00014100: 6174 6129 3a0a 2020 2020 2222 2244 6174  ata):.    """Dat
-00014110: 6120 6173 736f 6369 6174 6564 2077 6974  a associated wit
-00014120: 6820 6120 3a63 6c61 7373 3a60 2e46 6965  h a :class:`.Fie
-00014130: 6c64 5072 6f6a 6563 7469 6f6e 416e 676c  ldProjectionAngl
-00014140: 654d 6f6e 6974 6f72 603a 2063 6f6d 706f  eMonitor`: compo
-00014150: 6e65 6e74 7320 6f66 2070 726f 6a65 6374  nents of project
-00014160: 6564 2066 6965 6c64 732e 0a0a 2020 2020  ed fields...    
-00014170: 4578 616d 706c 650a 2020 2020 2d2d 2d2d  Example.    ----
-00014180: 2d2d 2d0a 2020 2020 3e3e 3e20 6672 6f6d  ---.    >>> from
-00014190: 2074 6964 7933 6420 696d 706f 7274 2046   tidy3d import F
-000141a0: 6965 6c64 5072 6f6a 6563 7469 6f6e 416e  ieldProjectionAn
-000141b0: 676c 6544 6174 6141 7272 6179 0a20 2020  gleDataArray.   
-000141c0: 203e 3e3e 2066 203d 206e 702e 6c69 6e73   >>> f = np.lins
-000141d0: 7061 6365 2831 6531 342c 2032 6531 342c  pace(1e14, 2e14,
-000141e0: 2031 3029 0a20 2020 203e 3e3e 2072 203d   10).    >>> r =
-000141f0: 206e 702e 6174 6c65 6173 745f 3164 2835   np.atleast_1d(5
-00014200: 290a 2020 2020 3e3e 3e20 7468 6574 6120  ).    >>> theta 
-00014210: 3d20 6e70 2e6c 696e 7370 6163 6528 302c  = np.linspace(0,
-00014220: 206e 702e 7069 2c20 3130 290a 2020 2020   np.pi, 10).    
-00014230: 3e3e 3e20 7068 6920 3d20 6e70 2e6c 696e  >>> phi = np.lin
-00014240: 7370 6163 6528 302c 2032 2a6e 702e 7069  space(0, 2*np.pi
-00014250: 2c20 3230 290a 2020 2020 3e3e 3e20 636f  , 20).    >>> co
-00014260: 6f72 6473 203d 2064 6963 7428 723d 722c  ords = dict(r=r,
-00014270: 2074 6865 7461 3d74 6865 7461 2c20 7068   theta=theta, ph
-00014280: 693d 7068 692c 2066 3d66 290a 2020 2020  i=phi, f=f).    
-00014290: 3e3e 3e20 7661 6c75 6573 203d 2028 312b  >>> values = (1+
-000142a0: 316a 2920 2a20 6e70 2e72 616e 646f 6d2e  1j) * np.random.
-000142b0: 7261 6e64 6f6d 2828 6c65 6e28 7229 2c20  random((len(r), 
-000142c0: 6c65 6e28 7468 6574 6129 2c20 6c65 6e28  len(theta), len(
-000142d0: 7068 6929 2c20 6c65 6e28 6629 2929 0a20  phi), len(f))). 
-000142e0: 2020 203e 3e3e 2073 6361 6c61 725f 6669     >>> scalar_fi
-000142f0: 656c 6420 3d20 4669 656c 6450 726f 6a65  eld = FieldProje
-00014300: 6374 696f 6e41 6e67 6c65 4461 7461 4172  ctionAngleDataAr
-00014310: 7261 7928 7661 6c75 6573 2c20 636f 6f72  ray(values, coor
-00014320: 6473 3d63 6f6f 7264 7329 0a20 2020 203e  ds=coords).    >
-00014330: 3e3e 206d 6f6e 6974 6f72 203d 2046 6965  >> monitor = Fie
-00014340: 6c64 5072 6f6a 6563 7469 6f6e 416e 676c  ldProjectionAngl
-00014350: 654d 6f6e 6974 6f72 280a 2020 2020 2e2e  eMonitor(.    ..
-00014360: 2e20 2020 2020 6365 6e74 6572 3d28 312c  .     center=(1,
-00014370: 322c 3329 2c20 7369 7a65 3d28 322c 322c  2,3), size=(2,2,
-00014380: 3229 2c20 6672 6571 733d 662c 206e 616d  2), freqs=f, nam
-00014390: 653d 276e 3266 5f6d 6f6e 6974 6f72 272c  e='n2f_monitor',
-000143a0: 2070 6869 3d70 6869 2c20 7468 6574 613d   phi=phi, theta=
-000143b0: 7468 6574 610a 2020 2020 2e2e 2e20 2020  theta.    ...   
-000143c0: 2020 290a 2020 2020 3e3e 3e20 6461 7461    ).    >>> data
-000143d0: 203d 2046 6965 6c64 5072 6f6a 6563 7469   = FieldProjecti
-000143e0: 6f6e 416e 676c 6544 6174 6128 0a20 2020  onAngleData(.   
-000143f0: 202e 2e2e 2020 2020 206d 6f6e 6974 6f72   ...     monitor
-00014400: 3d6d 6f6e 6974 6f72 2c20 4572 3d73 6361  =monitor, Er=sca
-00014410: 6c61 725f 6669 656c 642c 2045 7468 6574  lar_field, Ethet
-00014420: 613d 7363 616c 6172 5f66 6965 6c64 2c20  a=scalar_field, 
-00014430: 4570 6869 3d73 6361 6c61 725f 6669 656c  Ephi=scalar_fiel
-00014440: 642c 0a20 2020 202e 2e2e 2020 2020 2048  d,.    ...     H
-00014450: 723d 7363 616c 6172 5f66 6965 6c64 2c20  r=scalar_field, 
-00014460: 4874 6865 7461 3d73 6361 6c61 725f 6669  Htheta=scalar_fi
-00014470: 656c 642c 2048 7068 693d 7363 616c 6172  eld, Hphi=scalar
-00014480: 5f66 6965 6c64 2c0a 2020 2020 2e2e 2e20  _field,.    ... 
-00014490: 2020 2020 7072 6f6a 6563 7469 6f6e 5f73      projection_s
-000144a0: 7572 6661 6365 733d 6d6f 6e69 746f 722e  urfaces=monitor.
-000144b0: 7072 6f6a 6563 7469 6f6e 5f73 7572 6661  projection_surfa
-000144c0: 6365 732c 0a20 2020 202e 2e2e 2020 2020  ces,.    ...    
-000144d0: 2029 0a20 2020 2022 2222 0a0a 2020 2020   ).    """..    
-000144e0: 6d6f 6e69 746f 723a 2046 6965 6c64 5072  monitor: FieldPr
-000144f0: 6f6a 6563 7469 6f6e 416e 676c 654d 6f6e  ojectionAngleMon
-00014500: 6974 6f72 203d 2070 642e 4669 656c 6428  itor = pd.Field(
-00014510: 0a20 2020 2020 2020 202e 2e2e 2c0a 2020  .        ...,.  
-00014520: 2020 2020 2020 7469 746c 653d 2250 726f        title="Pro
-00014530: 6a65 6374 696f 6e20 6d6f 6e69 746f 7222  jection monitor"
-00014540: 2c0a 2020 2020 2020 2020 6465 7363 7269  ,.        descri
-00014550: 7074 696f 6e3d 2246 6965 6c64 2070 726f  ption="Field pro
-00014560: 6a65 6374 696f 6e20 6d6f 6e69 746f 7220  jection monitor 
-00014570: 7769 7468 2061 6e20 616e 676c 652d 6261  with an angle-ba
-00014580: 7365 6420 7072 6f6a 6563 7469 6f6e 2067  sed projection g
-00014590: 7269 642e 222c 0a20 2020 2029 0a0a 2020  rid.",.    )..  
-000145a0: 2020 7072 6f6a 6563 7469 6f6e 5f73 7572    projection_sur
-000145b0: 6661 6365 733a 2054 7570 6c65 5b46 6965  faces: Tuple[Fie
-000145c0: 6c64 5072 6f6a 6563 7469 6f6e 5375 7266  ldProjectionSurf
-000145d0: 6163 652c 202e 2e2e 5d20 3d20 7064 2e46  ace, ...] = pd.F
-000145e0: 6965 6c64 280a 2020 2020 2020 2020 2e2e  ield(.        ..
-000145f0: 2e2c 0a20 2020 2020 2020 2074 6974 6c65  .,.        title
-00014600: 3d22 5072 6f6a 6563 7469 6f6e 2073 7572  ="Projection sur
-00014610: 6661 6365 7322 2c0a 2020 2020 2020 2020  faces",.        
-00014620: 6465 7363 7269 7074 696f 6e3d 2253 7572  description="Sur
-00014630: 6661 6365 7320 6f66 2074 6865 206d 6f6e  faces of the mon
-00014640: 6974 6f72 2077 6865 7265 206e 6561 7220  itor where near 
-00014650: 6669 656c 6473 2077 6572 6520 7265 636f  fields were reco
-00014660: 7264 6564 2066 6f72 2070 726f 6a65 6374  rded for project
-00014670: 696f 6e22 2c0a 2020 2020 290a 0a20 2020  ion",.    )..   
-00014680: 2045 723a 2046 6965 6c64 5072 6f6a 6563   Er: FieldProjec
-00014690: 7469 6f6e 416e 676c 6544 6174 6141 7272  tionAngleDataArr
-000146a0: 6179 203d 2070 642e 4669 656c 6428 0a20  ay = pd.Field(. 
-000146b0: 2020 2020 2020 202e 2e2e 2c0a 2020 2020         ...,.    
-000146c0: 2020 2020 7469 746c 653d 2245 7222 2c0a      title="Er",.
-000146d0: 2020 2020 2020 2020 6465 7363 7269 7074          descript
-000146e0: 696f 6e3d 2253 7061 7469 616c 2064 6973  ion="Spatial dis
-000146f0: 7472 6962 7574 696f 6e20 6f66 2072 2d63  tribution of r-c
-00014700: 6f6d 706f 6e65 6e74 206f 6620 7468 6520  omponent of the 
-00014710: 656c 6563 7472 6963 2066 6965 6c64 2e22  electric field."
-00014720: 2c0a 2020 2020 290a 2020 2020 4574 6865  ,.    ).    Ethe
-00014730: 7461 3a20 4669 656c 6450 726f 6a65 6374  ta: FieldProject
-00014740: 696f 6e41 6e67 6c65 4461 7461 4172 7261  ionAngleDataArra
-00014750: 7920 3d20 7064 2e46 6965 6c64 280a 2020  y = pd.Field(.  
-00014760: 2020 2020 2020 2e2e 2e2c 0a20 2020 2020        ...,.     
-00014770: 2020 2074 6974 6c65 3d22 4574 6865 7461     title="Etheta
-00014780: 222c 0a20 2020 2020 2020 2064 6573 6372  ",.        descr
-00014790: 6970 7469 6f6e 3d22 5370 6174 6961 6c20  iption="Spatial 
-000147a0: 6469 7374 7269 6275 7469 6f6e 206f 6620  distribution of 
-000147b0: 7468 6520 7468 6574 612d 636f 6d70 6f6e  the theta-compon
-000147c0: 656e 7420 6f66 2074 6865 2065 6c65 6374  ent of the elect
-000147d0: 7269 6320 6669 656c 642e 222c 0a20 2020  ric field.",.   
-000147e0: 2029 0a20 2020 2045 7068 693a 2046 6965   ).    Ephi: Fie
-000147f0: 6c64 5072 6f6a 6563 7469 6f6e 416e 676c  ldProjectionAngl
-00014800: 6544 6174 6141 7272 6179 203d 2070 642e  eDataArray = pd.
-00014810: 4669 656c 6428 0a20 2020 2020 2020 202e  Field(.        .
-00014820: 2e2e 2c0a 2020 2020 2020 2020 7469 746c  ..,.        titl
-00014830: 653d 2245 7068 6922 2c0a 2020 2020 2020  e="Ephi",.      
-00014840: 2020 6465 7363 7269 7074 696f 6e3d 2253    description="S
-00014850: 7061 7469 616c 2064 6973 7472 6962 7574  patial distribut
-00014860: 696f 6e20 6f66 2070 6869 2d63 6f6d 706f  ion of phi-compo
-00014870: 6e65 6e74 206f 6620 7468 6520 656c 6563  nent of the elec
-00014880: 7472 6963 2066 6965 6c64 2e22 2c0a 2020  tric field.",.  
-00014890: 2020 290a 2020 2020 4872 3a20 4669 656c    ).    Hr: Fiel
-000148a0: 6450 726f 6a65 6374 696f 6e41 6e67 6c65  dProjectionAngle
-000148b0: 4461 7461 4172 7261 7920 3d20 7064 2e46  DataArray = pd.F
-000148c0: 6965 6c64 280a 2020 2020 2020 2020 2e2e  ield(.        ..
-000148d0: 2e2c 0a20 2020 2020 2020 2074 6974 6c65  .,.        title
-000148e0: 3d22 4872 222c 0a20 2020 2020 2020 2064  ="Hr",.        d
-000148f0: 6573 6372 6970 7469 6f6e 3d22 5370 6174  escription="Spat
-00014900: 6961 6c20 6469 7374 7269 6275 7469 6f6e  ial distribution
-00014910: 206f 6620 722d 636f 6d70 6f6e 656e 7420   of r-component 
-00014920: 6f66 2074 6865 206d 6167 6e65 7469 6320  of the magnetic 
-00014930: 6669 656c 642e 222c 0a20 2020 2029 0a20  field.",.    ). 
-00014940: 2020 2048 7468 6574 613a 2046 6965 6c64     Htheta: Field
-00014950: 5072 6f6a 6563 7469 6f6e 416e 676c 6544  ProjectionAngleD
-00014960: 6174 6141 7272 6179 203d 2070 642e 4669  ataArray = pd.Fi
-00014970: 656c 6428 0a20 2020 2020 2020 202e 2e2e  eld(.        ...
-00014980: 2c0a 2020 2020 2020 2020 7469 746c 653d  ,.        title=
-00014990: 2248 7468 6574 6122 2c0a 2020 2020 2020  "Htheta",.      
-000149a0: 2020 6465 7363 7269 7074 696f 6e3d 2253    description="S
-000149b0: 7061 7469 616c 2064 6973 7472 6962 7574  patial distribut
-000149c0: 696f 6e20 6f66 2074 6865 7461 2d63 6f6d  ion of theta-com
-000149d0: 706f 6e65 6e74 206f 6620 7468 6520 6d61  ponent of the ma
-000149e0: 676e 6574 6963 2066 6965 6c64 2e22 2c0a  gnetic field.",.
-000149f0: 2020 2020 290a 2020 2020 4870 6869 3a20      ).    Hphi: 
-00014a00: 4669 656c 6450 726f 6a65 6374 696f 6e41  FieldProjectionA
-00014a10: 6e67 6c65 4461 7461 4172 7261 7920 3d20  ngleDataArray = 
-00014a20: 7064 2e46 6965 6c64 280a 2020 2020 2020  pd.Field(.      
-00014a30: 2020 2e2e 2e2c 0a20 2020 2020 2020 2074    ...,.        t
-00014a40: 6974 6c65 3d22 4870 6869 222c 0a20 2020  itle="Hphi",.   
-00014a50: 2020 2020 2064 6573 6372 6970 7469 6f6e       description
-00014a60: 3d22 5370 6174 6961 6c20 6469 7374 7269  ="Spatial distri
-00014a70: 6275 7469 6f6e 206f 6620 7068 692d 636f  bution of phi-co
-00014a80: 6d70 6f6e 656e 7420 6f66 2074 6865 206d  mponent of the m
-00014a90: 6167 6e65 7469 6320 6669 656c 642e 222c  agnetic field.",
-00014aa0: 0a20 2020 2029 0a0a 2020 2020 4070 726f  .    )..    @pro
-00014ab0: 7065 7274 790a 2020 2020 6465 6620 7228  perty.    def r(
-00014ac0: 7365 6c66 2920 2d3e 206e 702e 6e64 6172  self) -> np.ndar
-00014ad0: 7261 793a 0a20 2020 2020 2020 2022 2222  ray:.        """
-00014ae0: 5261 6469 616c 2064 6973 7461 6e63 652e  Radial distance.
-00014af0: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
-00014b00: 726e 2073 656c 662e 4574 6865 7461 2e72  rn self.Etheta.r
-00014b10: 2e76 616c 7565 730a 0a20 2020 2040 7072  .values..    @pr
-00014b20: 6f70 6572 7479 0a20 2020 2064 6566 2074  operty.    def t
-00014b30: 6865 7461 2873 656c 6629 202d 3e20 6e70  heta(self) -> np
-00014b40: 2e6e 6461 7272 6179 3a0a 2020 2020 2020  .ndarray:.      
-00014b50: 2020 2222 2250 6f6c 6172 2061 6e67 6c65    """Polar angle
-00014b60: 732e 2222 220a 2020 2020 2020 2020 7265  s.""".        re
-00014b70: 7475 726e 2073 656c 662e 4574 6865 7461  turn self.Etheta
-00014b80: 2e74 6865 7461 2e76 616c 7565 730a 0a20  .theta.values.. 
-00014b90: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
-00014ba0: 2064 6566 2070 6869 2873 656c 6629 202d   def phi(self) -
-00014bb0: 3e20 6e70 2e6e 6461 7272 6179 3a0a 2020  > np.ndarray:.  
-00014bc0: 2020 2020 2020 2222 2241 7a69 6d75 7468        """Azimuth
-00014bd0: 616c 2061 6e67 6c65 732e 2222 220a 2020  al angles.""".  
-00014be0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-00014bf0: 662e 4574 6865 7461 2e70 6869 2e76 616c  f.Etheta.phi.val
-00014c00: 7565 730a 0a20 2020 2064 6566 2072 656e  ues..    def ren
-00014c10: 6f72 6d61 6c69 7a65 5f66 6965 6c64 7328  ormalize_fields(
-00014c20: 7365 6c66 2c20 7072 6f6a 5f64 6973 7461  self, proj_dista
-00014c30: 6e63 653a 2066 6c6f 6174 2920 2d3e 2046  nce: float) -> F
-00014c40: 6965 6c64 5072 6f6a 6563 7469 6f6e 416e  ieldProjectionAn
-00014c50: 676c 6544 6174 613a 0a20 2020 2020 2020  gleData:.       
-00014c60: 2022 2222 5265 7475 726e 2061 203a 636c   """Return a :cl
-00014c70: 6173 733a 602e 4669 656c 6450 726f 6a65  ass:`.FieldProje
-00014c80: 6374 696f 6e41 6e67 6c65 4461 7461 6020  ctionAngleData` 
-00014c90: 7769 7468 2066 6965 6c64 7320 7265 2d6e  with fields re-n
-00014ca0: 6f72 6d61 6c69 7a65 6420 746f 2061 206e  ormalized to a n
-00014cb0: 6577 0a20 2020 2020 2020 2070 726f 6a65  ew.        proje
-00014cc0: 6374 696f 6e20 6469 7374 616e 6365 2c20  ction distance, 
-00014cd0: 6279 2061 7070 6c79 696e 6720 6120 7068  by applying a ph
-00014ce0: 6173 6520 6661 6374 6f72 2062 6173 6564  ase factor based
-00014cf0: 206f 6e20 6060 7072 6f6a 5f64 6973 7461   on ``proj_dista
-00014d00: 6e63 6560 602e 0a0a 2020 2020 2020 2020  nce``...        
-00014d10: 5061 7261 6d65 7465 7273 0a20 2020 2020  Parameters.     
-00014d20: 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020     ----------.  
-00014d30: 2020 2020 2020 7072 6f6a 5f64 6973 7461        proj_dista
-00014d40: 6e63 6520 3a20 666c 6f61 7420 3d20 4e6f  nce : float = No
-00014d50: 6e65 0a20 2020 2020 2020 2020 2020 2028  ne.            (
-00014d60: 6d69 6372 6f6e 2920 6e65 7720 7261 6469  micron) new radi
-00014d70: 616c 2064 6973 7461 6e63 6520 7265 6c61  al distance rela
-00014d80: 7469 7665 2074 6f20 7468 6520 6d6f 6e69  tive to the moni
-00014d90: 746f 7227 7320 6c6f 6361 6c20 6f72 6967  tor's local orig
-00014da0: 696e 2e0a 0a20 2020 2020 2020 2052 6574  in...        Ret
-00014db0: 7572 6e73 0a20 2020 2020 2020 202d 2d2d  urns.        ---
-00014dc0: 2d2d 2d2d 0a20 2020 2020 2020 203a 636c  ----.        :cl
-00014dd0: 6173 733a 602e 4669 656c 6450 726f 6a65  ass:`.FieldProje
-00014de0: 6374 696f 6e41 6e67 6c65 4461 7461 600a  ctionAngleData`.
-00014df0: 2020 2020 2020 2020 2020 2020 436f 7079              Copy
-00014e00: 206f 6620 7468 6973 203a 636c 6173 733a   of this :class:
-00014e10: 602e 4669 656c 6450 726f 6a65 6374 696f  `.FieldProjectio
-00014e20: 6e41 6e67 6c65 4461 7461 6020 7769 7468  nAngleData` with
-00014e30: 2066 6965 6c64 7320 7265 2d70 726f 6a65   fields re-proje
-00014e40: 6374 6564 0a20 2020 2020 2020 2020 2020  cted.           
-00014e50: 2074 6f20 6060 7072 6f6a 5f64 6973 7461   to ``proj_dista
-00014e60: 6e63 6560 602e 0a20 2020 2020 2020 2022  nce``..        "
-00014e70: 2222 0a20 2020 2020 2020 2069 6620 7365  "".        if se
-00014e80: 6c66 2e6d 6f6e 6974 6f72 2061 6e64 206e  lf.monitor and n
-00014e90: 6f74 2073 656c 662e 6d6f 6e69 746f 722e  ot self.monitor.
-00014ea0: 6661 725f 6669 656c 645f 6170 7072 6f78  far_field_approx
-00014eb0: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
-00014ec0: 6973 6520 4461 7461 4572 726f 7228 0a20  ise DataError(. 
-00014ed0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-00014ee0: 4669 656c 6473 2070 726f 6a65 6374 6564  Fields projected
-00014ef0: 2077 6974 686f 7574 2069 6e76 6f6b 696e   without invokin
-00014f00: 6720 7468 6520 6661 7220 6669 656c 6420  g the far field 
-00014f10: 6170 7072 6f78 696d 6174 696f 6e20 220a  approximation ".
-00014f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014f30: 2263 616e 6e6f 7420 6265 2072 652d 7072  "cannot be re-pr
-00014f40: 6f6a 6563 7465 6420 746f 2061 206e 6577  ojected to a new
-00014f50: 2064 6973 7461 6e63 652e 220a 2020 2020   distance.".    
-00014f60: 2020 2020 2020 2020 290a 0a20 2020 2020          )..     
-00014f70: 2020 2023 2074 6865 2070 6861 7365 2066     # the phase f
-00014f80: 6163 746f 7220 6173 736f 6369 6174 6564  actor associated
-00014f90: 2077 6974 6820 7468 6520 6f6c 6420 6469   with the old di
-00014fa0: 7374 616e 6365 206d 7573 7420 6265 2072  stance must be r
-00014fb0: 656d 6f76 6564 0a20 2020 2020 2020 2072  emoved.        r
-00014fc0: 203d 2073 656c 662e 636f 6f72 6473 5f73   = self.coords_s
-00014fd0: 7068 6572 6963 616c 5b22 7222 5d5b 2e2e  pherical["r"][..
-00014fe0: 2e2c 204e 6f6e 655d 0a20 2020 2020 2020  ., None].       
-00014ff0: 206f 6c64 5f70 6861 7365 203d 2073 656c   old_phase = sel
-00015000: 662e 7072 6f70 6167 6174 696f 6e5f 7068  f.propagation_ph
-00015010: 6173 6528 6469 7374 3d72 2c20 6b3d 7365  ase(dist=r, k=se
-00015020: 6c66 2e6b 5b4e 6f6e 652c 204e 6f6e 652c  lf.k[None, None,
-00015030: 204e 6f6e 652c 203a 5d29 0a0a 2020 2020   None, :])..    
-00015040: 2020 2020 2320 7468 6520 7068 6173 6520      # the phase 
-00015050: 6661 6374 6f72 2061 7373 6f63 6961 7465  factor associate
-00015060: 6420 7769 7468 2074 6865 206e 6577 2064  d with the new d
-00015070: 6973 7461 6e63 6520 6d75 7374 2062 6520  istance must be 
-00015080: 6170 706c 6965 640a 2020 2020 2020 2020  applied.        
-00015090: 6e65 775f 7068 6173 6520 3d20 7365 6c66  new_phase = self
-000150a0: 2e70 726f 7061 6761 7469 6f6e 5f70 6861  .propagation_pha
-000150b0: 7365 2864 6973 743d 7072 6f6a 5f64 6973  se(dist=proj_dis
-000150c0: 7461 6e63 652c 206b 3d73 656c 662e 6b29  tance, k=self.k)
-000150d0: 0a0a 2020 2020 2020 2020 2320 6e65 7420  ..        # net 
-000150e0: 7068 6173 650a 2020 2020 2020 2020 7068  phase.        ph
-000150f0: 6173 6520 3d20 6e65 775f 7068 6173 655b  ase = new_phase[
-00015100: 4e6f 6e65 2c20 4e6f 6e65 2c20 4e6f 6e65  None, None, None
-00015110: 2c20 3a5d 202f 206f 6c64 5f70 6861 7365  , :] / old_phase
-00015120: 0a0a 2020 2020 2020 2020 2320 636f 6d70  ..        # comp
-00015130: 7574 6520 7570 6461 7465 6420 6669 656c  ute updated fiel
-00015140: 6473 2061 6e64 2074 6865 6972 2063 6f6f  ds and their coo
-00015150: 7264 696e 6174 6573 0a20 2020 2020 2020  rdinates.       
-00015160: 2072 6574 7572 6e20 7365 6c66 2e6d 616b   return self.mak
-00015170: 655f 7265 6e6f 726d 616c 697a 6564 5f64  e_renormalized_d
-00015180: 6174 6128 7068 6173 652c 2070 726f 6a5f  ata(phase, proj_
-00015190: 6469 7374 616e 6365 290a 0a0a 636c 6173  distance)...clas
-000151a0: 7320 4669 656c 6450 726f 6a65 6374 696f  s FieldProjectio
-000151b0: 6e43 6172 7465 7369 616e 4461 7461 2841  nCartesianData(A
-000151c0: 6273 7472 6163 7446 6965 6c64 5072 6f6a  bstractFieldProj
-000151d0: 6563 7469 6f6e 4461 7461 293a 0a20 2020  ectionData):.   
-000151e0: 2022 2222 4461 7461 2061 7373 6f63 6961   """Data associa
-000151f0: 7465 6420 7769 7468 2061 203a 636c 6173  ted with a :clas
-00015200: 733a 602e 4669 656c 6450 726f 6a65 6374  s:`.FieldProject
-00015210: 696f 6e43 6172 7465 7369 616e 4d6f 6e69  ionCartesianMoni
-00015220: 746f 7260 3a20 636f 6d70 6f6e 656e 7473  tor`: components
-00015230: 206f 660a 2020 2020 7072 6f6a 6563 7465   of.    projecte
-00015240: 6420 6669 656c 6473 2e0a 0a20 2020 2045  d fields...    E
-00015250: 7861 6d70 6c65 0a20 2020 202d 2d2d 2d2d  xample.    -----
-00015260: 2d2d 0a20 2020 203e 3e3e 2066 726f 6d20  --.    >>> from 
-00015270: 7469 6479 3364 2069 6d70 6f72 7420 4669  tidy3d import Fi
-00015280: 656c 6450 726f 6a65 6374 696f 6e43 6172  eldProjectionCar
-00015290: 7465 7369 616e 4461 7461 4172 7261 790a  tesianDataArray.
-000152a0: 2020 2020 3e3e 3e20 6620 3d20 6e70 2e6c      >>> f = np.l
-000152b0: 696e 7370 6163 6528 3165 3134 2c20 3265  inspace(1e14, 2e
-000152c0: 3134 2c20 3130 290a 2020 2020 3e3e 3e20  14, 10).    >>> 
-000152d0: 7820 3d20 6e70 2e6c 696e 7370 6163 6528  x = np.linspace(
-000152e0: 302c 2035 2c20 3130 290a 2020 2020 3e3e  0, 5, 10).    >>
-000152f0: 3e20 7920 3d20 6e70 2e6c 696e 7370 6163  > y = np.linspac
-00015300: 6528 302c 2031 302c 2032 3029 0a20 2020  e(0, 10, 20).   
-00015310: 203e 3e3e 207a 203d 206e 702e 6174 6c65   >>> z = np.atle
-00015320: 6173 745f 3164 2835 290a 2020 2020 3e3e  ast_1d(5).    >>
-00015330: 3e20 636f 6f72 6473 203d 2064 6963 7428  > coords = dict(
-00015340: 783d 782c 2079 3d79 2c20 7a3d 7a2c 2066  x=x, y=y, z=z, f
-00015350: 3d66 290a 2020 2020 3e3e 3e20 7661 6c75  =f).    >>> valu
-00015360: 6573 203d 2028 312b 316a 2920 2a20 6e70  es = (1+1j) * np
-00015370: 2e72 616e 646f 6d2e 7261 6e64 6f6d 2828  .random.random((
-00015380: 6c65 6e28 7829 2c20 6c65 6e28 7929 2c20  len(x), len(y), 
-00015390: 6c65 6e28 7a29 2c20 6c65 6e28 6629 2929  len(z), len(f)))
-000153a0: 0a20 2020 203e 3e3e 2073 6361 6c61 725f  .    >>> scalar_
-000153b0: 6669 656c 6420 3d20 4669 656c 6450 726f  field = FieldPro
-000153c0: 6a65 6374 696f 6e43 6172 7465 7369 616e  jectionCartesian
-000153d0: 4461 7461 4172 7261 7928 7661 6c75 6573  DataArray(values
-000153e0: 2c20 636f 6f72 6473 3d63 6f6f 7264 7329  , coords=coords)
-000153f0: 0a20 2020 203e 3e3e 206d 6f6e 6974 6f72  .    >>> monitor
-00015400: 203d 2046 6965 6c64 5072 6f6a 6563 7469   = FieldProjecti
-00015410: 6f6e 4361 7274 6573 6961 6e4d 6f6e 6974  onCartesianMonit
-00015420: 6f72 280a 2020 2020 2e2e 2e20 2020 2020  or(.    ...     
-00015430: 6365 6e74 6572 3d28 312c 322c 3329 2c20  center=(1,2,3), 
-00015440: 7369 7a65 3d28 322c 322c 3229 2c20 6672  size=(2,2,2), fr
-00015450: 6571 733d 662c 206e 616d 653d 276e 3266  eqs=f, name='n2f
-00015460: 5f6d 6f6e 6974 6f72 272c 2078 3d78 2c20  _monitor', x=x, 
-00015470: 793d 792c 0a20 2020 202e 2e2e 2020 2020  y=y,.    ...    
-00015480: 2070 726f 6a5f 6178 6973 3d32 2c20 7072   proj_axis=2, pr
-00015490: 6f6a 5f64 6973 7461 6e63 653d 3530 0a20  oj_distance=50. 
-000154a0: 2020 202e 2e2e 2020 2020 2029 0a20 2020     ...     ).   
-000154b0: 203e 3e3e 2064 6174 6120 3d20 4669 656c   >>> data = Fiel
-000154c0: 6450 726f 6a65 6374 696f 6e43 6172 7465  dProjectionCarte
-000154d0: 7369 616e 4461 7461 280a 2020 2020 2e2e  sianData(.    ..
-000154e0: 2e20 2020 2020 6d6f 6e69 746f 723d 6d6f  .     monitor=mo
-000154f0: 6e69 746f 722c 2045 723d 7363 616c 6172  nitor, Er=scalar
-00015500: 5f66 6965 6c64 2c20 4574 6865 7461 3d73  _field, Etheta=s
-00015510: 6361 6c61 725f 6669 656c 642c 2045 7068  calar_field, Eph
-00015520: 693d 7363 616c 6172 5f66 6965 6c64 2c0a  i=scalar_field,.
-00015530: 2020 2020 2e2e 2e20 2020 2020 4872 3d73      ...     Hr=s
-00015540: 6361 6c61 725f 6669 656c 642c 2048 7468  calar_field, Hth
-00015550: 6574 613d 7363 616c 6172 5f66 6965 6c64  eta=scalar_field
-00015560: 2c20 4870 6869 3d73 6361 6c61 725f 6669  , Hphi=scalar_fi
-00015570: 656c 642c 0a20 2020 202e 2e2e 2020 2020  eld,.    ...    
-00015580: 2070 726f 6a65 6374 696f 6e5f 7375 7266   projection_surf
-00015590: 6163 6573 3d6d 6f6e 6974 6f72 2e70 726f  aces=monitor.pro
-000155a0: 6a65 6374 696f 6e5f 7375 7266 6163 6573  jection_surfaces
-000155b0: 2c0a 2020 2020 2e2e 2e20 2020 2020 290a  ,.    ...     ).
-000155c0: 2020 2020 2222 220a 0a20 2020 206d 6f6e      """..    mon
-000155d0: 6974 6f72 3a20 4669 656c 6450 726f 6a65  itor: FieldProje
-000155e0: 6374 696f 6e43 6172 7465 7369 616e 4d6f  ctionCartesianMo
-000155f0: 6e69 746f 7220 3d20 7064 2e46 6965 6c64  nitor = pd.Field
-00015600: 280a 2020 2020 2020 2020 2e2e 2e2c 0a20  (.        ...,. 
-00015610: 2020 2020 2020 2074 6974 6c65 3d22 5072         title="Pr
-00015620: 6f6a 6563 7469 6f6e 206d 6f6e 6974 6f72  ojection monitor
-00015630: 222c 0a20 2020 2020 2020 2064 6573 6372  ",.        descr
-00015640: 6970 7469 6f6e 3d22 4669 656c 6420 7072  iption="Field pr
-00015650: 6f6a 6563 7469 6f6e 206d 6f6e 6974 6f72  ojection monitor
-00015660: 2077 6974 6820 6120 4361 7274 6573 6961   with a Cartesia
-00015670: 6e20 7072 6f6a 6563 7469 6f6e 2067 7269  n projection gri
-00015680: 642e 222c 0a20 2020 2029 0a0a 2020 2020  d.",.    )..    
-00015690: 7072 6f6a 6563 7469 6f6e 5f73 7572 6661  projection_surfa
-000156a0: 6365 733a 2054 7570 6c65 5b46 6965 6c64  ces: Tuple[Field
-000156b0: 5072 6f6a 6563 7469 6f6e 5375 7266 6163  ProjectionSurfac
-000156c0: 652c 202e 2e2e 5d20 3d20 7064 2e46 6965  e, ...] = pd.Fie
-000156d0: 6c64 280a 2020 2020 2020 2020 2e2e 2e2c  ld(.        ...,
-000156e0: 0a20 2020 2020 2020 2074 6974 6c65 3d22  .        title="
-000156f0: 5072 6f6a 6563 7469 6f6e 2073 7572 6661  Projection surfa
-00015700: 6365 7322 2c0a 2020 2020 2020 2020 6465  ces",.        de
-00015710: 7363 7269 7074 696f 6e3d 2253 7572 6661  scription="Surfa
-00015720: 6365 7320 6f66 2074 6865 206d 6f6e 6974  ces of the monit
-00015730: 6f72 2077 6865 7265 206e 6561 7220 6669  or where near fi
-00015740: 656c 6473 2077 6572 6520 7265 636f 7264  elds were record
-00015750: 6564 2066 6f72 2070 726f 6a65 6374 696f  ed for projectio
-00015760: 6e22 2c0a 2020 2020 290a 0a20 2020 2045  n",.    )..    E
-00015770: 723a 2046 6965 6c64 5072 6f6a 6563 7469  r: FieldProjecti
-00015780: 6f6e 4361 7274 6573 6961 6e44 6174 6141  onCartesianDataA
-00015790: 7272 6179 203d 2070 642e 4669 656c 6428  rray = pd.Field(
-000157a0: 0a20 2020 2020 2020 202e 2e2e 2c0a 2020  .        ...,.  
-000157b0: 2020 2020 2020 7469 746c 653d 2245 7222        title="Er"
-000157c0: 2c0a 2020 2020 2020 2020 6465 7363 7269  ,.        descri
-000157d0: 7074 696f 6e3d 2253 7061 7469 616c 2064  ption="Spatial d
-000157e0: 6973 7472 6962 7574 696f 6e20 6f66 2072  istribution of r
-000157f0: 2d63 6f6d 706f 6e65 6e74 206f 6620 7468  -component of th
-00015800: 6520 656c 6563 7472 6963 2066 6965 6c64  e electric field
-00015810: 2e22 2c0a 2020 2020 290a 2020 2020 4574  .",.    ).    Et
-00015820: 6865 7461 3a20 4669 656c 6450 726f 6a65  heta: FieldProje
-00015830: 6374 696f 6e43 6172 7465 7369 616e 4461  ctionCartesianDa
-00015840: 7461 4172 7261 7920 3d20 7064 2e46 6965  taArray = pd.Fie
-00015850: 6c64 280a 2020 2020 2020 2020 2e2e 2e2c  ld(.        ...,
-00015860: 0a20 2020 2020 2020 2074 6974 6c65 3d22  .        title="
-00015870: 4574 6865 7461 222c 0a20 2020 2020 2020  Etheta",.       
-00015880: 2064 6573 6372 6970 7469 6f6e 3d22 5370   description="Sp
-00015890: 6174 6961 6c20 6469 7374 7269 6275 7469  atial distributi
-000158a0: 6f6e 206f 6620 7468 6520 7468 6574 612d  on of the theta-
-000158b0: 636f 6d70 6f6e 656e 7420 6f66 2074 6865  component of the
-000158c0: 2065 6c65 6374 7269 6320 6669 656c 642e   electric field.
-000158d0: 222c 0a20 2020 2029 0a20 2020 2045 7068  ",.    ).    Eph
-000158e0: 693a 2046 6965 6c64 5072 6f6a 6563 7469  i: FieldProjecti
-000158f0: 6f6e 4361 7274 6573 6961 6e44 6174 6141  onCartesianDataA
-00015900: 7272 6179 203d 2070 642e 4669 656c 6428  rray = pd.Field(
-00015910: 0a20 2020 2020 2020 202e 2e2e 2c0a 2020  .        ...,.  
-00015920: 2020 2020 2020 7469 746c 653d 2245 7068        title="Eph
-00015930: 6922 2c0a 2020 2020 2020 2020 6465 7363  i",.        desc
-00015940: 7269 7074 696f 6e3d 2253 7061 7469 616c  ription="Spatial
-00015950: 2064 6973 7472 6962 7574 696f 6e20 6f66   distribution of
-00015960: 2070 6869 2d63 6f6d 706f 6e65 6e74 206f   phi-component o
-00015970: 6620 7468 6520 656c 6563 7472 6963 2066  f the electric f
-00015980: 6965 6c64 2e22 2c0a 2020 2020 290a 2020  ield.",.    ).  
-00015990: 2020 4872 3a20 4669 656c 6450 726f 6a65    Hr: FieldProje
-000159a0: 6374 696f 6e43 6172 7465 7369 616e 4461  ctionCartesianDa
-000159b0: 7461 4172 7261 7920 3d20 7064 2e46 6965  taArray = pd.Fie
-000159c0: 6c64 280a 2020 2020 2020 2020 2e2e 2e2c  ld(.        ...,
-000159d0: 0a20 2020 2020 2020 2074 6974 6c65 3d22  .        title="
-000159e0: 4872 222c 0a20 2020 2020 2020 2064 6573  Hr",.        des
-000159f0: 6372 6970 7469 6f6e 3d22 5370 6174 6961  cription="Spatia
-00015a00: 6c20 6469 7374 7269 6275 7469 6f6e 206f  l distribution o
-00015a10: 6620 722d 636f 6d70 6f6e 656e 7420 6f66  f r-component of
-00015a20: 2074 6865 206d 6167 6e65 7469 6320 6669   the magnetic fi
-00015a30: 656c 642e 222c 0a20 2020 2029 0a20 2020  eld.",.    ).   
-00015a40: 2048 7468 6574 613a 2046 6965 6c64 5072   Htheta: FieldPr
-00015a50: 6f6a 6563 7469 6f6e 4361 7274 6573 6961  ojectionCartesia
-00015a60: 6e44 6174 6141 7272 6179 203d 2070 642e  nDataArray = pd.
-00015a70: 4669 656c 6428 0a20 2020 2020 2020 202e  Field(.        .
-00015a80: 2e2e 2c0a 2020 2020 2020 2020 7469 746c  ..,.        titl
-00015a90: 653d 2248 7468 6574 6122 2c0a 2020 2020  e="Htheta",.    
-00015aa0: 2020 2020 6465 7363 7269 7074 696f 6e3d      description=
-00015ab0: 2253 7061 7469 616c 2064 6973 7472 6962  "Spatial distrib
-00015ac0: 7574 696f 6e20 6f66 2074 6865 7461 2d63  ution of theta-c
-00015ad0: 6f6d 706f 6e65 6e74 206f 6620 7468 6520  omponent of the 
-00015ae0: 6d61 676e 6574 6963 2066 6965 6c64 2e22  magnetic field."
-00015af0: 2c0a 2020 2020 290a 2020 2020 4870 6869  ,.    ).    Hphi
-00015b00: 3a20 4669 656c 6450 726f 6a65 6374 696f  : FieldProjectio
-00015b10: 6e43 6172 7465 7369 616e 4461 7461 4172  nCartesianDataAr
-00015b20: 7261 7920 3d20 7064 2e46 6965 6c64 280a  ray = pd.Field(.
-00015b30: 2020 2020 2020 2020 2e2e 2e2c 0a20 2020          ...,.   
-00015b40: 2020 2020 2074 6974 6c65 3d22 4870 6869       title="Hphi
-00015b50: 222c 0a20 2020 2020 2020 2064 6573 6372  ",.        descr
-00015b60: 6970 7469 6f6e 3d22 5370 6174 6961 6c20  iption="Spatial 
-00015b70: 6469 7374 7269 6275 7469 6f6e 206f 6620  distribution of 
-00015b80: 7068 692d 636f 6d70 6f6e 656e 7420 6f66  phi-component of
-00015b90: 2074 6865 206d 6167 6e65 7469 6320 6669   the magnetic fi
-00015ba0: 656c 642e 222c 0a20 2020 2029 0a0a 2020  eld.",.    )..  
-00015bb0: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
-00015bc0: 6465 6620 7828 7365 6c66 2920 2d3e 206e  def x(self) -> n
-00015bd0: 702e 6e64 6172 7261 793a 0a20 2020 2020  p.ndarray:.     
-00015be0: 2020 2022 2222 5820 706f 7369 7469 6f6e     """X position
-00015bf0: 732e 2222 220a 2020 2020 2020 2020 7265  s.""".        re
-00015c00: 7475 726e 2073 656c 662e 4574 6865 7461  turn self.Etheta
-00015c10: 2e78 2e76 616c 7565 730a 0a20 2020 2040  .x.values..    @
-00015c20: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
-00015c30: 2079 2873 656c 6629 202d 3e20 6e70 2e6e   y(self) -> np.n
-00015c40: 6461 7272 6179 3a0a 2020 2020 2020 2020  darray:.        
-00015c50: 2222 2259 2070 6f73 6974 696f 6e73 2e22  """Y positions."
-00015c60: 2222 0a20 2020 2020 2020 2072 6574 7572  "".        retur
-00015c70: 6e20 7365 6c66 2e45 7468 6574 612e 792e  n self.Etheta.y.
-00015c80: 7661 6c75 6573 0a0a 2020 2020 4070 726f  values..    @pro
-00015c90: 7065 7274 790a 2020 2020 6465 6620 7a28  perty.    def z(
-00015ca0: 7365 6c66 2920 2d3e 206e 702e 6e64 6172  self) -> np.ndar
-00015cb0: 7261 793a 0a20 2020 2020 2020 2022 2222  ray:.        """
-00015cc0: 5a20 706f 7369 7469 6f6e 732e 2222 220a  Z positions.""".
-00015cd0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-00015ce0: 656c 662e 4574 6865 7461 2e7a 2e76 616c  elf.Etheta.z.val
-00015cf0: 7565 730a 0a20 2020 2064 6566 2072 656e  ues..    def ren
-00015d00: 6f72 6d61 6c69 7a65 5f66 6965 6c64 7328  ormalize_fields(
-00015d10: 7365 6c66 2c20 7072 6f6a 5f64 6973 7461  self, proj_dista
-00015d20: 6e63 653a 2066 6c6f 6174 2920 2d3e 2046  nce: float) -> F
-00015d30: 6965 6c64 5072 6f6a 6563 7469 6f6e 4361  ieldProjectionCa
-00015d40: 7274 6573 6961 6e44 6174 613a 0a20 2020  rtesianData:.   
-00015d50: 2020 2020 2022 2222 5265 7475 726e 2061       """Return a
-00015d60: 203a 636c 6173 733a 602e 4669 656c 6450   :class:`.FieldP
-00015d70: 726f 6a65 6374 696f 6e43 6172 7465 7369  rojectionCartesi
-00015d80: 616e 4461 7461 6020 7769 7468 2066 6965  anData` with fie
-00015d90: 6c64 7320 7265 2d6e 6f72 6d61 6c69 7a65  lds re-normalize
-00015da0: 6420 746f 2061 206e 6577 0a20 2020 2020  d to a new.     
-00015db0: 2020 2070 726f 6a65 6374 696f 6e20 6469     projection di
-00015dc0: 7374 616e 6365 2c20 6279 2061 7070 6c79  stance, by apply
-00015dd0: 696e 6720 6120 7068 6173 6520 6661 6374  ing a phase fact
-00015de0: 6f72 2062 6173 6564 206f 6e20 6060 7072  or based on ``pr
-00015df0: 6f6a 5f64 6973 7461 6e63 6560 602e 0a0a  oj_distance``...
-00015e00: 2020 2020 2020 2020 5061 7261 6d65 7465          Paramete
-00015e10: 7273 0a20 2020 2020 2020 202d 2d2d 2d2d  rs.        -----
-00015e20: 2d2d 2d2d 2d0a 2020 2020 2020 2020 7072  -----.        pr
-00015e30: 6f6a 5f64 6973 7461 6e63 6520 3a20 666c  oj_distance : fl
-00015e40: 6f61 7420 3d20 4e6f 6e65 0a20 2020 2020  oat = None.     
-00015e50: 2020 2020 2020 2028 6d69 6372 6f6e 2920         (micron) 
-00015e60: 6e65 7720 706c 616e 6520 6469 7374 616e  new plane distan
-00015e70: 6365 2072 656c 6174 6976 6520 746f 2074  ce relative to t
-00015e80: 6865 206d 6f6e 6974 6f72 2773 206c 6f63  he monitor's loc
-00015e90: 616c 206f 7269 6769 6e2e 0a0a 2020 2020  al origin...    
-00015ea0: 2020 2020 5265 7475 726e 730a 2020 2020      Returns.    
-00015eb0: 2020 2020 2d2d 2d2d 2d2d 2d0a 2020 2020      -------.    
-00015ec0: 2020 2020 3a63 6c61 7373 3a60 2e46 6965      :class:`.Fie
-00015ed0: 6c64 5072 6f6a 6563 7469 6f6e 4361 7274  ldProjectionCart
-00015ee0: 6573 6961 6e44 6174 6160 0a20 2020 2020  esianData`.     
-00015ef0: 2020 2020 2020 2043 6f70 7920 6f66 2074         Copy of t
-00015f00: 6869 7320 3a63 6c61 7373 3a60 2e46 6965  his :class:`.Fie
-00015f10: 6c64 5072 6f6a 6563 7469 6f6e 4361 7274  ldProjectionCart
-00015f20: 6573 6961 6e44 6174 6160 2077 6974 6820  esianData` with 
-00015f30: 6669 656c 6473 2072 652d 7072 6f6a 6563  fields re-projec
-00015f40: 7465 640a 2020 2020 2020 2020 2020 2020  ted.            
-00015f50: 746f 2060 6070 726f 6a5f 6469 7374 616e  to ``proj_distan
-00015f60: 6365 6060 2e0a 2020 2020 2020 2020 2222  ce``..        ""
-00015f70: 220a 2020 2020 2020 2020 6966 206e 6f74  ".        if not
-00015f80: 2073 656c 662e 6d6f 6e69 746f 722e 6661   self.monitor.fa
-00015f90: 725f 6669 656c 645f 6170 7072 6f78 3a0a  r_field_approx:.
-00015fa0: 2020 2020 2020 2020 2020 2020 7261 6973              rais
-00015fb0: 6520 4461 7461 4572 726f 7228 0a20 2020  e DataError(.   
-00015fc0: 2020 2020 2020 2020 2020 2020 2022 4669               "Fi
-00015fd0: 656c 6473 2070 726f 6a65 6374 6564 2077  elds projected w
-00015fe0: 6974 686f 7574 2069 6e76 6f6b 696e 6720  ithout invoking 
-00015ff0: 7468 6520 6661 7220 6669 656c 6420 6170  the far field ap
-00016000: 7072 6f78 696d 6174 696f 6e20 220a 2020  proximation ".  
-00016010: 2020 2020 2020 2020 2020 2020 2020 2263                "c
-00016020: 616e 6e6f 7420 6265 2072 652d 7072 6f6a  annot be re-proj
-00016030: 6563 7465 6420 746f 2061 206e 6577 2064  ected to a new d
-00016040: 6973 7461 6e63 652e 220a 2020 2020 2020  istance.".      
-00016050: 2020 2020 2020 290a 0a20 2020 2020 2020        )..       
-00016060: 2023 2074 6865 2070 6861 7365 2066 6163   # the phase fac
-00016070: 746f 7220 6173 736f 6369 6174 6564 2077  tor associated w
-00016080: 6974 6820 7468 6520 6f6c 6420 6469 7374  ith the old dist
-00016090: 616e 6365 206d 7573 7420 6265 2072 656d  ance must be rem
-000160a0: 6f76 6564 0a20 2020 2020 2020 206b 203d  oved.        k =
-000160b0: 2073 656c 662e 6b5b 4e6f 6e65 2c20 4e6f   self.k[None, No
-000160c0: 6e65 2c20 4e6f 6e65 2c20 3a5d 0a20 2020  ne, None, :].   
-000160d0: 2020 2020 2072 203d 2073 656c 662e 636f       r = self.co
-000160e0: 6f72 6473 5f73 7068 6572 6963 616c 5b22  ords_spherical["
-000160f0: 7222 5d5b 2e2e 2e2c 204e 6f6e 655d 0a20  r"][..., None]. 
-00016100: 2020 2020 2020 206f 6c64 5f70 6861 7365         old_phase
-00016110: 203d 2073 656c 662e 7072 6f70 6167 6174   = self.propagat
-00016120: 696f 6e5f 7068 6173 6528 6469 7374 3d72  ion_phase(dist=r
-00016130: 2c20 6b3d 6b29 0a0a 2020 2020 2020 2020  , k=k)..        
-00016140: 2320 7570 6461 7465 2074 6865 2066 6965  # update the fie
-00016150: 6c64 2063 6f6d 706f 6e65 6e74 7327 2070  ld components' p
-00016160: 726f 6a65 6374 696f 6e20 6469 7374 616e  rojection distan
-00016170: 6365 0a20 2020 2020 2020 206e 6f72 6d5f  ce.        norm_
-00016180: 6469 722c 205f 203d 2073 656c 662e 6d6f  dir, _ = self.mo
-00016190: 6e69 746f 722e 706f 705f 6178 6973 285b  nitor.pop_axis([
-000161a0: 2278 222c 2022 7922 2c20 227a 225d 2c20  "x", "y", "z"], 
-000161b0: 6178 6973 3d73 656c 662e 6d6f 6e69 746f  axis=self.monito
-000161c0: 722e 7072 6f6a 5f61 7869 7329 0a20 2020  r.proj_axis).   
-000161d0: 2020 2020 2066 6f72 2066 6965 6c64 2069       for field i
-000161e0: 6e20 7365 6c66 2e66 6965 6c64 5f63 6f6d  n self.field_com
-000161f0: 706f 6e65 6e74 732e 7661 6c75 6573 2829  ponents.values()
-00016200: 3a0a 2020 2020 2020 2020 2020 2020 6669  :.            fi
-00016210: 656c 645b 6e6f 726d 5f64 6972 5d20 3d20  eld[norm_dir] = 
-00016220: 6e70 2e61 746c 6561 7374 5f31 6428 7072  np.atleast_1d(pr
-00016230: 6f6a 5f64 6973 7461 6e63 6529 0a0a 2020  oj_distance)..  
-00016240: 2020 2020 2020 2320 7468 6520 7068 6173        # the phas
-00016250: 6520 6661 6374 6f72 2061 7373 6f63 6961  e factor associa
-00016260: 7465 6420 7769 7468 2074 6865 206e 6577  ted with the new
-00016270: 2064 6973 7461 6e63 6520 6d75 7374 2062   distance must b
-00016280: 6520 6170 706c 6965 640a 2020 2020 2020  e applied.      
-00016290: 2020 7220 3d20 7365 6c66 2e63 6f6f 7264    r = self.coord
-000162a0: 735f 7370 6865 7269 6361 6c5b 2272 225d  s_spherical["r"]
-000162b0: 5b2e 2e2e 2c20 4e6f 6e65 5d0a 2020 2020  [..., None].    
-000162c0: 2020 2020 6e65 775f 7068 6173 6520 3d20      new_phase = 
-000162d0: 7365 6c66 2e70 726f 7061 6761 7469 6f6e  self.propagation
-000162e0: 5f70 6861 7365 2864 6973 743d 722c 206b  _phase(dist=r, k
-000162f0: 3d6b 290a 0a20 2020 2020 2020 2023 206e  =k)..        # n
-00016300: 6574 2070 6861 7365 0a20 2020 2020 2020  et phase.       
-00016310: 2070 6861 7365 203d 206e 6577 5f70 6861   phase = new_pha
-00016320: 7365 202f 206f 6c64 5f70 6861 7365 0a0a  se / old_phase..
-00016330: 2020 2020 2020 2020 2320 636f 6d70 7574          # comput
-00016340: 6520 7570 6461 7465 6420 6669 656c 6473  e updated fields
-00016350: 2061 6e64 2074 6865 6972 2063 6f6f 7264   and their coord
-00016360: 696e 6174 6573 0a20 2020 2020 2020 2072  inates.        r
-00016370: 6574 7572 6e20 7365 6c66 2e6d 616b 655f  eturn self.make_
-00016380: 7265 6e6f 726d 616c 697a 6564 5f64 6174  renormalized_dat
-00016390: 6128 7068 6173 652c 2070 726f 6a5f 6469  a(phase, proj_di
-000163a0: 7374 616e 6365 290a 0a0a 636c 6173 7320  stance)...class 
-000163b0: 4669 656c 6450 726f 6a65 6374 696f 6e4b  FieldProjectionK
-000163c0: 5370 6163 6544 6174 6128 4162 7374 7261  SpaceData(Abstra
-000163d0: 6374 4669 656c 6450 726f 6a65 6374 696f  ctFieldProjectio
-000163e0: 6e44 6174 6129 3a0a 2020 2020 2222 2244  nData):.    """D
-000163f0: 6174 6120 6173 736f 6369 6174 6564 2077  ata associated w
-00016400: 6974 6820 6120 3a63 6c61 7373 3a60 2e46  ith a :class:`.F
-00016410: 6965 6c64 5072 6f6a 6563 7469 6f6e 4b53  ieldProjectionKS
-00016420: 7061 6365 4d6f 6e69 746f 7260 3a20 636f  paceMonitor`: co
-00016430: 6d70 6f6e 656e 7473 206f 660a 2020 2020  mponents of.    
-00016440: 7072 6f6a 6563 7465 6420 6669 656c 6473  projected fields
-00016450: 2e0a 0a20 2020 2045 7861 6d70 6c65 0a20  ...    Example. 
-00016460: 2020 202d 2d2d 2d2d 2d2d 0a20 2020 203e     -------.    >
-00016470: 3e3e 2066 726f 6d20 7469 6479 3364 2069  >> from tidy3d i
-00016480: 6d70 6f72 7420 4669 656c 6450 726f 6a65  mport FieldProje
-00016490: 6374 696f 6e4b 5370 6163 6544 6174 6141  ctionKSpaceDataA
-000164a0: 7272 6179 0a20 2020 203e 3e3e 2066 203d  rray.    >>> f =
-000164b0: 206e 702e 6c69 6e73 7061 6365 2831 6531   np.linspace(1e1
-000164c0: 342c 2032 6531 342c 2031 3029 0a20 2020  4, 2e14, 10).   
-000164d0: 203e 3e3e 2075 7820 3d20 6e70 2e6c 696e   >>> ux = np.lin
-000164e0: 7370 6163 6528 302c 2030 2e34 2c20 3130  space(0, 0.4, 10
-000164f0: 290a 2020 2020 3e3e 3e20 7579 203d 206e  ).    >>> uy = n
-00016500: 702e 6c69 6e73 7061 6365 2830 2c20 302e  p.linspace(0, 0.
-00016510: 362c 2032 3029 0a20 2020 203e 3e3e 2072  6, 20).    >>> r
-00016520: 203d 206e 702e 6174 6c65 6173 745f 3164   = np.atleast_1d
-00016530: 2835 290a 2020 2020 3e3e 3e20 636f 6f72  (5).    >>> coor
-00016540: 6473 203d 2064 6963 7428 7578 3d75 782c  ds = dict(ux=ux,
-00016550: 2075 793d 7579 2c20 723d 722c 2066 3d66   uy=uy, r=r, f=f
-00016560: 290a 2020 2020 3e3e 3e20 7661 6c75 6573  ).    >>> values
-00016570: 203d 2028 312b 316a 2920 2a20 6e70 2e72   = (1+1j) * np.r
-00016580: 616e 646f 6d2e 7261 6e64 6f6d 2828 6c65  andom.random((le
-00016590: 6e28 7578 292c 206c 656e 2875 7929 2c20  n(ux), len(uy), 
-000165a0: 6c65 6e28 7229 2c20 6c65 6e28 6629 2929  len(r), len(f)))
-000165b0: 0a20 2020 203e 3e3e 2073 6361 6c61 725f  .    >>> scalar_
-000165c0: 6669 656c 6420 3d20 4669 656c 6450 726f  field = FieldPro
-000165d0: 6a65 6374 696f 6e4b 5370 6163 6544 6174  jectionKSpaceDat
-000165e0: 6141 7272 6179 2876 616c 7565 732c 2063  aArray(values, c
-000165f0: 6f6f 7264 733d 636f 6f72 6473 290a 2020  oords=coords).  
-00016600: 2020 3e3e 3e20 6d6f 6e69 746f 7220 3d20    >>> monitor = 
-00016610: 4669 656c 6450 726f 6a65 6374 696f 6e4b  FieldProjectionK
-00016620: 5370 6163 654d 6f6e 6974 6f72 280a 2020  SpaceMonitor(.  
-00016630: 2020 2e2e 2e20 2020 2020 6365 6e74 6572    ...     center
-00016640: 3d28 312c 322c 3329 2c20 7369 7a65 3d28  =(1,2,3), size=(
-00016650: 322c 322c 3229 2c20 6672 6571 733d 662c  2,2,2), freqs=f,
-00016660: 206e 616d 653d 276e 3266 5f6d 6f6e 6974   name='n2f_monit
-00016670: 6f72 272c 2075 783d 7578 2c20 7579 3d75  or', ux=ux, uy=u
-00016680: 792c 2070 726f 6a5f 6178 6973 3d32 0a20  y, proj_axis=2. 
-00016690: 2020 202e 2e2e 2020 2020 2029 0a20 2020     ...     ).   
-000166a0: 203e 3e3e 2064 6174 6120 3d20 4669 656c   >>> data = Fiel
-000166b0: 6450 726f 6a65 6374 696f 6e4b 5370 6163  dProjectionKSpac
-000166c0: 6544 6174 6128 0a20 2020 202e 2e2e 2020  eData(.    ...  
-000166d0: 2020 206d 6f6e 6974 6f72 3d6d 6f6e 6974     monitor=monit
-000166e0: 6f72 2c20 4572 3d73 6361 6c61 725f 6669  or, Er=scalar_fi
-000166f0: 656c 642c 2045 7468 6574 613d 7363 616c  eld, Etheta=scal
-00016700: 6172 5f66 6965 6c64 2c20 4570 6869 3d73  ar_field, Ephi=s
-00016710: 6361 6c61 725f 6669 656c 642c 0a20 2020  calar_field,.   
-00016720: 202e 2e2e 2020 2020 2048 723d 7363 616c   ...     Hr=scal
-00016730: 6172 5f66 6965 6c64 2c20 4874 6865 7461  ar_field, Htheta
-00016740: 3d73 6361 6c61 725f 6669 656c 642c 2048  =scalar_field, H
-00016750: 7068 693d 7363 616c 6172 5f66 6965 6c64  phi=scalar_field
-00016760: 2c0a 2020 2020 2e2e 2e20 2020 2020 7072  ,.    ...     pr
-00016770: 6f6a 6563 7469 6f6e 5f73 7572 6661 6365  ojection_surface
-00016780: 733d 6d6f 6e69 746f 722e 7072 6f6a 6563  s=monitor.projec
-00016790: 7469 6f6e 5f73 7572 6661 6365 732c 0a20  tion_surfaces,. 
-000167a0: 2020 202e 2e2e 2020 2020 2029 0a20 2020     ...     ).   
-000167b0: 2022 2222 0a0a 2020 2020 6d6f 6e69 746f   """..    monito
-000167c0: 723a 2046 6965 6c64 5072 6f6a 6563 7469  r: FieldProjecti
-000167d0: 6f6e 4b53 7061 6365 4d6f 6e69 746f 7220  onKSpaceMonitor 
-000167e0: 3d20 7064 2e46 6965 6c64 280a 2020 2020  = pd.Field(.    
-000167f0: 2020 2020 2e2e 2e2c 0a20 2020 2020 2020      ...,.       
-00016800: 2074 6974 6c65 3d22 5072 6f6a 6563 7469   title="Projecti
-00016810: 6f6e 206d 6f6e 6974 6f72 222c 0a20 2020  on monitor",.   
-00016820: 2020 2020 2064 6573 6372 6970 7469 6f6e       description
-00016830: 3d22 4669 656c 6420 7072 6f6a 6563 7469  ="Field projecti
-00016840: 6f6e 206d 6f6e 6974 6f72 2077 6974 6820  on monitor with 
-00016850: 6120 7072 6f6a 6563 7469 6f6e 2067 7269  a projection gri
-00016860: 6420 6465 6669 6e65 6420 696e 206b 2d73  d defined in k-s
-00016870: 7061 6365 2e22 2c0a 2020 2020 290a 0a20  pace.",.    ).. 
-00016880: 2020 2070 726f 6a65 6374 696f 6e5f 7375     projection_su
-00016890: 7266 6163 6573 3a20 5475 706c 655b 4669  rfaces: Tuple[Fi
-000168a0: 656c 6450 726f 6a65 6374 696f 6e53 7572  eldProjectionSur
-000168b0: 6661 6365 2c20 2e2e 2e5d 203d 2070 642e  face, ...] = pd.
-000168c0: 4669 656c 6428 0a20 2020 2020 2020 202e  Field(.        .
-000168d0: 2e2e 2c0a 2020 2020 2020 2020 7469 746c  ..,.        titl
-000168e0: 653d 2250 726f 6a65 6374 696f 6e20 7375  e="Projection su
-000168f0: 7266 6163 6573 222c 0a20 2020 2020 2020  rfaces",.       
-00016900: 2064 6573 6372 6970 7469 6f6e 3d22 5375   description="Su
-00016910: 7266 6163 6573 206f 6620 7468 6520 6d6f  rfaces of the mo
-00016920: 6e69 746f 7220 7768 6572 6520 6e65 6172  nitor where near
-00016930: 2066 6965 6c64 7320 7765 7265 2072 6563   fields were rec
-00016940: 6f72 6465 6420 666f 7220 7072 6f6a 6563  orded for projec
-00016950: 7469 6f6e 222c 0a20 2020 2029 0a0a 2020  tion",.    )..  
-00016960: 2020 4572 3a20 4669 656c 6450 726f 6a65    Er: FieldProje
-00016970: 6374 696f 6e4b 5370 6163 6544 6174 6141  ctionKSpaceDataA
-00016980: 7272 6179 203d 2070 642e 4669 656c 6428  rray = pd.Field(
-00016990: 0a20 2020 2020 2020 202e 2e2e 2c0a 2020  .        ...,.  
-000169a0: 2020 2020 2020 7469 746c 653d 2245 7222        title="Er"
-000169b0: 2c0a 2020 2020 2020 2020 6465 7363 7269  ,.        descri
-000169c0: 7074 696f 6e3d 2253 7061 7469 616c 2064  ption="Spatial d
-000169d0: 6973 7472 6962 7574 696f 6e20 6f66 2072  istribution of r
-000169e0: 2d63 6f6d 706f 6e65 6e74 206f 6620 7468  -component of th
-000169f0: 6520 656c 6563 7472 6963 2066 6965 6c64  e electric field
-00016a00: 2e22 2c0a 2020 2020 290a 2020 2020 4574  .",.    ).    Et
-00016a10: 6865 7461 3a20 4669 656c 6450 726f 6a65  heta: FieldProje
-00016a20: 6374 696f 6e4b 5370 6163 6544 6174 6141  ctionKSpaceDataA
-00016a30: 7272 6179 203d 2070 642e 4669 656c 6428  rray = pd.Field(
-00016a40: 0a20 2020 2020 2020 202e 2e2e 2c0a 2020  .        ...,.  
-00016a50: 2020 2020 2020 7469 746c 653d 2245 7468        title="Eth
-00016a60: 6574 6122 2c0a 2020 2020 2020 2020 6465  eta",.        de
-00016a70: 7363 7269 7074 696f 6e3d 2253 7061 7469  scription="Spati
-00016a80: 616c 2064 6973 7472 6962 7574 696f 6e20  al distribution 
-00016a90: 6f66 2074 6865 2074 6865 7461 2d63 6f6d  of the theta-com
-00016aa0: 706f 6e65 6e74 206f 6620 7468 6520 656c  ponent of the el
-00016ab0: 6563 7472 6963 2066 6965 6c64 2e22 2c0a  ectric field.",.
-00016ac0: 2020 2020 290a 2020 2020 4570 6869 3a20      ).    Ephi: 
-00016ad0: 4669 656c 6450 726f 6a65 6374 696f 6e4b  FieldProjectionK
-00016ae0: 5370 6163 6544 6174 6141 7272 6179 203d  SpaceDataArray =
-00016af0: 2070 642e 4669 656c 6428 0a20 2020 2020   pd.Field(.     
-00016b00: 2020 202e 2e2e 2c0a 2020 2020 2020 2020     ...,.        
-00016b10: 7469 746c 653d 2245 7068 6922 2c0a 2020  title="Ephi",.  
-00016b20: 2020 2020 2020 6465 7363 7269 7074 696f        descriptio
-00016b30: 6e3d 2253 7061 7469 616c 2064 6973 7472  n="Spatial distr
-00016b40: 6962 7574 696f 6e20 6f66 2070 6869 2d63  ibution of phi-c
-00016b50: 6f6d 706f 6e65 6e74 206f 6620 7468 6520  omponent of the 
-00016b60: 656c 6563 7472 6963 2066 6965 6c64 2e22  electric field."
-00016b70: 2c0a 2020 2020 290a 2020 2020 4872 3a20  ,.    ).    Hr: 
-00016b80: 4669 656c 6450 726f 6a65 6374 696f 6e4b  FieldProjectionK
-00016b90: 5370 6163 6544 6174 6141 7272 6179 203d  SpaceDataArray =
-00016ba0: 2070 642e 4669 656c 6428 0a20 2020 2020   pd.Field(.     
-00016bb0: 2020 202e 2e2e 2c0a 2020 2020 2020 2020     ...,.        
-00016bc0: 7469 746c 653d 2248 7222 2c0a 2020 2020  title="Hr",.    
-00016bd0: 2020 2020 6465 7363 7269 7074 696f 6e3d      description=
-00016be0: 2253 7061 7469 616c 2064 6973 7472 6962  "Spatial distrib
-00016bf0: 7574 696f 6e20 6f66 2072 2d63 6f6d 706f  ution of r-compo
-00016c00: 6e65 6e74 206f 6620 7468 6520 6d61 676e  nent of the magn
-00016c10: 6574 6963 2066 6965 6c64 2e22 2c0a 2020  etic field.",.  
-00016c20: 2020 290a 2020 2020 4874 6865 7461 3a20    ).    Htheta: 
-00016c30: 4669 656c 6450 726f 6a65 6374 696f 6e4b  FieldProjectionK
-00016c40: 5370 6163 6544 6174 6141 7272 6179 203d  SpaceDataArray =
-00016c50: 2070 642e 4669 656c 6428 0a20 2020 2020   pd.Field(.     
-00016c60: 2020 202e 2e2e 2c0a 2020 2020 2020 2020     ...,.        
-00016c70: 7469 746c 653d 2248 7468 6574 6122 2c0a  title="Htheta",.
-00016c80: 2020 2020 2020 2020 6465 7363 7269 7074          descript
-00016c90: 696f 6e3d 2253 7061 7469 616c 2064 6973  ion="Spatial dis
-00016ca0: 7472 6962 7574 696f 6e20 6f66 2074 6865  tribution of the
-00016cb0: 7461 2d63 6f6d 706f 6e65 6e74 206f 6620  ta-component of 
-00016cc0: 7468 6520 6d61 676e 6574 6963 2066 6965  the magnetic fie
-00016cd0: 6c64 2e22 2c0a 2020 2020 290a 2020 2020  ld.",.    ).    
-00016ce0: 4870 6869 3a20 4669 656c 6450 726f 6a65  Hphi: FieldProje
-00016cf0: 6374 696f 6e4b 5370 6163 6544 6174 6141  ctionKSpaceDataA
-00016d00: 7272 6179 203d 2070 642e 4669 656c 6428  rray = pd.Field(
-00016d10: 0a20 2020 2020 2020 202e 2e2e 2c0a 2020  .        ...,.  
-00016d20: 2020 2020 2020 7469 746c 653d 2248 7068        title="Hph
-00016d30: 6922 2c0a 2020 2020 2020 2020 6465 7363  i",.        desc
-00016d40: 7269 7074 696f 6e3d 2253 7061 7469 616c  ription="Spatial
-00016d50: 2064 6973 7472 6962 7574 696f 6e20 6f66   distribution of
-00016d60: 2070 6869 2d63 6f6d 706f 6e65 6e74 206f   phi-component o
-00016d70: 6620 7468 6520 6d61 676e 6574 6963 2066  f the magnetic f
-00016d80: 6965 6c64 2e22 2c0a 2020 2020 290a 0a20  ield.",.    ).. 
-00016d90: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
-00016da0: 2064 6566 2075 7828 7365 6c66 2920 2d3e   def ux(self) ->
-00016db0: 206e 702e 6e64 6172 7261 793a 0a20 2020   np.ndarray:.   
-00016dc0: 2020 2020 2022 2222 5265 6369 7072 6f63       """Reciproc
-00016dd0: 616c 2058 2070 6f73 6974 696f 6e73 2e22  al X positions."
-00016de0: 2222 0a20 2020 2020 2020 2072 6574 7572  "".        retur
-00016df0: 6e20 7365 6c66 2e45 7468 6574 612e 7578  n self.Etheta.ux
-00016e00: 2e76 616c 7565 730a 0a20 2020 2040 7072  .values..    @pr
-00016e10: 6f70 6572 7479 0a20 2020 2064 6566 2075  operty.    def u
-00016e20: 7928 7365 6c66 2920 2d3e 206e 702e 6e64  y(self) -> np.nd
-00016e30: 6172 7261 793a 0a20 2020 2020 2020 2022  array:.        "
-00016e40: 2222 5265 6369 7072 6f63 616c 2059 2070  ""Reciprocal Y p
-00016e50: 6f73 6974 696f 6e73 2e22 2222 0a20 2020  ositions.""".   
-00016e60: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-00016e70: 2e45 7468 6574 612e 7579 2e76 616c 7565  .Etheta.uy.value
-00016e80: 730a 0a20 2020 2040 7072 6f70 6572 7479  s..    @property
-00016e90: 0a20 2020 2064 6566 2072 2873 656c 6629  .    def r(self)
-00016ea0: 202d 3e20 6e70 2e6e 6461 7272 6179 3a0a   -> np.ndarray:.
-00016eb0: 2020 2020 2020 2020 2222 2252 6164 6961          """Radia
-00016ec0: 6c20 6469 7374 616e 6365 2e22 2222 0a20  l distance.""". 
-00016ed0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-00016ee0: 6c66 2e45 7468 6574 612e 722e 7661 6c75  lf.Etheta.r.valu
-00016ef0: 6573 0a0a 2020 2020 6465 6620 7265 6e6f  es..    def reno
-00016f00: 726d 616c 697a 655f 6669 656c 6473 2873  rmalize_fields(s
-00016f10: 656c 662c 2070 726f 6a5f 6469 7374 616e  elf, proj_distan
-00016f20: 6365 3a20 666c 6f61 7429 202d 3e20 4669  ce: float) -> Fi
-00016f30: 656c 6450 726f 6a65 6374 696f 6e4b 5370  eldProjectionKSp
-00016f40: 6163 6544 6174 613a 0a20 2020 2020 2020  aceData:.       
-00016f50: 2022 2222 5265 7475 726e 2061 203a 636c   """Return a :cl
-00016f60: 6173 733a 602e 4669 656c 6450 726f 6a65  ass:`.FieldProje
-00016f70: 6374 696f 6e4b 5370 6163 6544 6174 6160  ctionKSpaceData`
-00016f80: 2077 6974 6820 6669 656c 6473 2072 652d   with fields re-
-00016f90: 6e6f 726d 616c 697a 6564 2074 6f20 6120  normalized to a 
-00016fa0: 6e65 770a 2020 2020 2020 2020 7072 6f6a  new.        proj
-00016fb0: 6563 7469 6f6e 2064 6973 7461 6e63 652c  ection distance,
-00016fc0: 2062 7920 6170 706c 7969 6e67 2061 2070   by applying a p
-00016fd0: 6861 7365 2066 6163 746f 7220 6261 7365  hase factor base
-00016fe0: 6420 6f6e 2060 6070 726f 6a5f 6469 7374  d on ``proj_dist
-00016ff0: 616e 6365 6060 2e0a 0a20 2020 2020 2020  ance``...       
-00017000: 2050 6172 616d 6574 6572 730a 2020 2020   Parameters.    
-00017010: 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20      ----------. 
-00017020: 2020 2020 2020 2070 726f 6a5f 6469 7374         proj_dist
-00017030: 616e 6365 203a 2066 6c6f 6174 203d 204e  ance : float = N
-00017040: 6f6e 650a 2020 2020 2020 2020 2020 2020  one.            
-00017050: 286d 6963 726f 6e29 206e 6577 2072 6164  (micron) new rad
-00017060: 6961 6c20 6469 7374 616e 6365 2072 656c  ial distance rel
-00017070: 6174 6976 6520 746f 2074 6865 206d 6f6e  ative to the mon
-00017080: 6974 6f72 2773 206c 6f63 616c 206f 7269  itor's local ori
-00017090: 6769 6e2e 0a0a 2020 2020 2020 2020 5265  gin...        Re
-000170a0: 7475 726e 730a 2020 2020 2020 2020 2d2d  turns.        --
-000170b0: 2d2d 2d2d 2d0a 2020 2020 2020 2020 3a63  -----.        :c
-000170c0: 6c61 7373 3a60 2e46 6965 6c64 5072 6f6a  lass:`.FieldProj
-000170d0: 6563 7469 6f6e 4b53 7061 6365 4461 7461  ectionKSpaceData
-000170e0: 600a 2020 2020 2020 2020 2020 2020 436f  `.            Co
-000170f0: 7079 206f 6620 7468 6973 203a 636c 6173  py of this :clas
-00017100: 733a 602e 4669 656c 6450 726f 6a65 6374  s:`.FieldProject
-00017110: 696f 6e4b 5370 6163 6544 6174 6160 2077  ionKSpaceData` w
-00017120: 6974 6820 6669 656c 6473 2072 652d 7072  ith fields re-pr
-00017130: 6f6a 6563 7465 640a 2020 2020 2020 2020  ojected.        
-00017140: 2020 2020 746f 2060 6070 726f 6a5f 6469      to ``proj_di
-00017150: 7374 616e 6365 6060 2e0a 2020 2020 2020  stance``..      
-00017160: 2020 2222 220a 2020 2020 2020 2020 6966    """.        if
-00017170: 2073 656c 662e 6d6f 6e69 746f 7220 616e   self.monitor an
-00017180: 6420 6e6f 7420 7365 6c66 2e6d 6f6e 6974  d not self.monit
-00017190: 6f72 2e66 6172 5f66 6965 6c64 5f61 7070  or.far_field_app
-000171a0: 726f 783a 0a20 2020 2020 2020 2020 2020  rox:.           
-000171b0: 2072 6169 7365 2044 6174 6145 7272 6f72   raise DataError
-000171c0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-000171d0: 2020 2246 6965 6c64 7320 7072 6f6a 6563    "Fields projec
-000171e0: 7465 6420 7769 7468 6f75 7420 696e 766f  ted without invo
-000171f0: 6b69 6e67 2074 6865 2066 6172 2066 6965  king the far fie
-00017200: 6c64 2061 7070 726f 7869 6d61 7469 6f6e  ld approximation
-00017210: 2022 0a20 2020 2020 2020 2020 2020 2020   ".             
-00017220: 2020 2022 6361 6e6e 6f74 2062 6520 7265     "cannot be re
-00017230: 2d70 726f 6a65 6374 6564 2074 6f20 6120  -projected to a 
-00017240: 6e65 7720 6469 7374 616e 6365 2e22 0a20  new distance.". 
-00017250: 2020 2020 2020 2020 2020 2029 0a0a 2020             )..  
-00017260: 2020 2020 2020 2320 7468 6520 7068 6173        # the phas
-00017270: 6520 6661 6374 6f72 2061 7373 6f63 6961  e factor associa
-00017280: 7465 6420 7769 7468 2074 6865 206f 6c64  ted with the old
-00017290: 2064 6973 7461 6e63 6520 6d75 7374 2062   distance must b
-000172a0: 6520 7265 6d6f 7665 640a 2020 2020 2020  e removed.      
-000172b0: 2020 7220 3d20 7365 6c66 2e63 6f6f 7264    r = self.coord
-000172c0: 735f 7370 6865 7269 6361 6c5b 2272 225d  s_spherical["r"]
-000172d0: 5b2e 2e2e 2c20 4e6f 6e65 5d0a 2020 2020  [..., None].    
-000172e0: 2020 2020 6f6c 645f 7068 6173 6520 3d20      old_phase = 
-000172f0: 7365 6c66 2e70 726f 7061 6761 7469 6f6e  self.propagation
-00017300: 5f70 6861 7365 2864 6973 743d 722c 206b  _phase(dist=r, k
-00017310: 3d73 656c 662e 6b5b 4e6f 6e65 2c20 4e6f  =self.k[None, No
-00017320: 6e65 2c20 4e6f 6e65 2c20 3a5d 290a 0a20  ne, None, :]).. 
-00017330: 2020 2020 2020 2023 2074 6865 2070 6861         # the pha
-00017340: 7365 2066 6163 746f 7220 6173 736f 6369  se factor associ
-00017350: 6174 6564 2077 6974 6820 7468 6520 6e65  ated with the ne
-00017360: 7720 6469 7374 616e 6365 206d 7573 7420  w distance must 
-00017370: 6265 2061 7070 6c69 6564 0a20 2020 2020  be applied.     
-00017380: 2020 206e 6577 5f70 6861 7365 203d 2073     new_phase = s
-00017390: 656c 662e 7072 6f70 6167 6174 696f 6e5f  elf.propagation_
-000173a0: 7068 6173 6528 6469 7374 3d70 726f 6a5f  phase(dist=proj_
-000173b0: 6469 7374 616e 6365 2c20 6b3d 7365 6c66  distance, k=self
-000173c0: 2e6b 290a 0a20 2020 2020 2020 2023 206e  .k)..        # n
-000173d0: 6574 2070 6861 7365 0a20 2020 2020 2020  et phase.       
-000173e0: 2070 6861 7365 203d 206e 6577 5f70 6861   phase = new_pha
-000173f0: 7365 5b4e 6f6e 652c 204e 6f6e 652c 204e  se[None, None, N
-00017400: 6f6e 652c 203a 5d20 2f20 6f6c 645f 7068  one, :] / old_ph
-00017410: 6173 650a 0a20 2020 2020 2020 2023 2063  ase..        # c
-00017420: 6f6d 7075 7465 2075 7064 6174 6564 2066  ompute updated f
-00017430: 6965 6c64 7320 616e 6420 7468 6569 7220  ields and their 
-00017440: 636f 6f72 6469 6e61 7465 730a 2020 2020  coordinates.    
-00017450: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-00017460: 6d61 6b65 5f72 656e 6f72 6d61 6c69 7a65  make_renormalize
-00017470: 645f 6461 7461 2870 6861 7365 2c20 7072  d_data(phase, pr
-00017480: 6f6a 5f64 6973 7461 6e63 6529 0a0a 0a63  oj_distance)...c
-00017490: 6c61 7373 2044 6966 6672 6163 7469 6f6e  lass Diffraction
-000174a0: 4461 7461 2841 6273 7472 6163 7446 6965  Data(AbstractFie
-000174b0: 6c64 5072 6f6a 6563 7469 6f6e 4461 7461  ldProjectionData
-000174c0: 293a 0a20 2020 2022 2222 4461 7461 2066  ):.    """Data f
-000174d0: 6f72 2061 203a 636c 6173 733a 602e 4469  or a :class:`.Di
-000174e0: 6666 7261 6374 696f 6e4d 6f6e 6974 6f72  ffractionMonitor
-000174f0: 603a 2063 6f6d 706c 6578 2063 6f6d 706f  `: complex compo
-00017500: 6e65 6e74 7320 6f66 2064 6966 6672 6163  nents of diffrac
-00017510: 7465 6420 6661 7220 6669 656c 6473 2e0a  ted far fields..
-00017520: 0a20 2020 2045 7861 6d70 6c65 0a20 2020  .    Example.   
-00017530: 202d 2d2d 2d2d 2d2d 0a20 2020 203e 3e3e   -------.    >>>
-00017540: 2066 726f 6d20 7469 6479 3364 2069 6d70   from tidy3d imp
-00017550: 6f72 7420 4469 6666 7261 6374 696f 6e44  ort DiffractionD
-00017560: 6174 6141 7272 6179 0a20 2020 203e 3e3e  ataArray.    >>>
-00017570: 2066 203d 206e 702e 6c69 6e73 7061 6365   f = np.linspace
-00017580: 2831 6531 342c 2032 6531 342c 2031 3029  (1e14, 2e14, 10)
-00017590: 0a20 2020 203e 3e3e 206f 7264 6572 735f  .    >>> orders_
-000175a0: 7820 3d20 6c69 7374 2872 616e 6765 282d  x = list(range(-
-000175b0: 342c 2035 2929 0a20 2020 203e 3e3e 206f  4, 5)).    >>> o
-000175c0: 7264 6572 735f 7920 3d20 6c69 7374 2872  rders_y = list(r
-000175d0: 616e 6765 282d 362c 2037 2929 0a20 2020  ange(-6, 7)).   
-000175e0: 203e 3e3e 2070 6f6c 203d 205b 2273 222c   >>> pol = ["s",
-000175f0: 2022 7022 5d0a 2020 2020 3e3e 3e20 636f   "p"].    >>> co
-00017600: 6f72 6473 203d 2064 6963 7428 6f72 6465  ords = dict(orde
-00017610: 7273 5f78 3d6f 7264 6572 735f 782c 206f  rs_x=orders_x, o
-00017620: 7264 6572 735f 793d 6f72 6465 7273 5f79  rders_y=orders_y
-00017630: 2c20 663d 6629 0a20 2020 203e 3e3e 2076  , f=f).    >>> v
-00017640: 616c 7565 7320 3d20 2831 2b31 6a29 202a  alues = (1+1j) *
-00017650: 206e 702e 7261 6e64 6f6d 2e72 616e 646f   np.random.rando
-00017660: 6d28 286c 656e 286f 7264 6572 735f 7829  m((len(orders_x)
-00017670: 2c20 6c65 6e28 6f72 6465 7273 5f79 292c  , len(orders_y),
-00017680: 206c 656e 2866 2929 290a 2020 2020 3e3e   len(f))).    >>
-00017690: 3e20 6669 656c 6420 3d20 4469 6666 7261  > field = Diffra
-000176a0: 6374 696f 6e44 6174 6141 7272 6179 2876  ctionDataArray(v
-000176b0: 616c 7565 732c 2063 6f6f 7264 733d 636f  alues, coords=co
-000176c0: 6f72 6473 290a 2020 2020 3e3e 3e20 6d6f  ords).    >>> mo
-000176d0: 6e69 746f 7220 3d20 4469 6666 7261 6374  nitor = Diffract
-000176e0: 696f 6e4d 6f6e 6974 6f72 280a 2020 2020  ionMonitor(.    
-000176f0: 2e2e 2e20 2020 2020 6365 6e74 6572 3d28  ...     center=(
-00017700: 312c 322c 3329 2c20 7369 7a65 3d28 6e70  1,2,3), size=(np
-00017710: 2e69 6e66 2c6e 702e 696e 662c 3029 2c20  .inf,np.inf,0), 
-00017720: 6672 6571 733d 662c 206e 616d 653d 2764  freqs=f, name='d
-00017730: 6966 6672 6163 7469 6f6e 270a 2020 2020  iffraction'.    
-00017740: 2e2e 2e20 290a 2020 2020 3e3e 3e20 6461  ... ).    >>> da
-00017750: 7461 203d 2044 6966 6672 6163 7469 6f6e  ta = Diffraction
-00017760: 4461 7461 280a 2020 2020 2e2e 2e20 2020  Data(.    ...   
-00017770: 2020 6d6f 6e69 746f 723d 6d6f 6e69 746f    monitor=monito
-00017780: 722c 2073 696d 5f73 697a 653d 5b31 2c31  r, sim_size=[1,1
-00017790: 5d2c 2062 6c6f 6368 5f76 6563 733d 5b31  ], bloch_vecs=[1
-000177a0: 2c32 5d2c 0a20 2020 202e 2e2e 2020 2020  ,2],.    ...    
-000177b0: 2045 7468 6574 613d 6669 656c 642c 2045   Etheta=field, E
-000177c0: 7068 693d 6669 656c 642c 2045 723d 6669  phi=field, Er=fi
-000177d0: 656c 642c 0a20 2020 202e 2e2e 2020 2020  eld,.    ...    
-000177e0: 2048 7468 6574 613d 6669 656c 642c 2048   Htheta=field, H
-000177f0: 7068 693d 6669 656c 642c 2048 723d 6669  phi=field, Hr=fi
-00017800: 656c 642c 0a20 2020 202e 2e2e 2029 0a20  eld,.    ... ). 
-00017810: 2020 2022 2222 0a0a 2020 2020 6d6f 6e69     """..    moni
-00017820: 746f 723a 2044 6966 6672 6163 7469 6f6e  tor: Diffraction
-00017830: 4d6f 6e69 746f 7220 3d20 7064 2e46 6965  Monitor = pd.Fie
-00017840: 6c64 280a 2020 2020 2020 2020 2e2e 2e2c  ld(.        ...,
-00017850: 2074 6974 6c65 3d22 4d6f 6e69 746f 7222   title="Monitor"
-00017860: 2c20 6465 7363 7269 7074 696f 6e3d 2244  , description="D
-00017870: 6966 6672 6163 7469 6f6e 206d 6f6e 6974  iffraction monit
-00017880: 6f72 2061 7373 6f63 6961 7465 6420 7769  or associated wi
-00017890: 7468 2074 6865 2064 6174 612e 220a 2020  th the data.".  
-000178a0: 2020 290a 0a20 2020 2045 723a 2044 6966    )..    Er: Dif
-000178b0: 6672 6163 7469 6f6e 4461 7461 4172 7261  fractionDataArra
-000178c0: 7920 3d20 7064 2e46 6965 6c64 280a 2020  y = pd.Field(.  
-000178d0: 2020 2020 2020 2e2e 2e2c 0a20 2020 2020        ...,.     
-000178e0: 2020 2074 6974 6c65 3d22 4572 222c 0a20     title="Er",. 
-000178f0: 2020 2020 2020 2064 6573 6372 6970 7469         descripti
-00017900: 6f6e 3d22 5370 6174 6961 6c20 6469 7374  on="Spatial dist
-00017910: 7269 6275 7469 6f6e 206f 6620 722d 636f  ribution of r-co
-00017920: 6d70 6f6e 656e 7420 6f66 2074 6865 2065  mponent of the e
-00017930: 6c65 6374 7269 6320 6669 656c 642e 222c  lectric field.",
-00017940: 0a20 2020 2029 0a20 2020 2045 7468 6574  .    ).    Ethet
-00017950: 613a 2044 6966 6672 6163 7469 6f6e 4461  a: DiffractionDa
-00017960: 7461 4172 7261 7920 3d20 7064 2e46 6965  taArray = pd.Fie
-00017970: 6c64 280a 2020 2020 2020 2020 2e2e 2e2c  ld(.        ...,
-00017980: 0a20 2020 2020 2020 2074 6974 6c65 3d22  .        title="
-00017990: 4574 6865 7461 222c 0a20 2020 2020 2020  Etheta",.       
-000179a0: 2064 6573 6372 6970 7469 6f6e 3d22 5370   description="Sp
-000179b0: 6174 6961 6c20 6469 7374 7269 6275 7469  atial distributi
-000179c0: 6f6e 206f 6620 7468 6520 7468 6574 612d  on of the theta-
-000179d0: 636f 6d70 6f6e 656e 7420 6f66 2074 6865  component of the
-000179e0: 2065 6c65 6374 7269 6320 6669 656c 642e   electric field.
-000179f0: 222c 0a20 2020 2029 0a20 2020 2045 7068  ",.    ).    Eph
-00017a00: 693a 2044 6966 6672 6163 7469 6f6e 4461  i: DiffractionDa
-00017a10: 7461 4172 7261 7920 3d20 7064 2e46 6965  taArray = pd.Fie
-00017a20: 6c64 280a 2020 2020 2020 2020 2e2e 2e2c  ld(.        ...,
-00017a30: 0a20 2020 2020 2020 2074 6974 6c65 3d22  .        title="
-00017a40: 4570 6869 222c 0a20 2020 2020 2020 2064  Ephi",.        d
-00017a50: 6573 6372 6970 7469 6f6e 3d22 5370 6174  escription="Spat
-00017a60: 6961 6c20 6469 7374 7269 6275 7469 6f6e  ial distribution
-00017a70: 206f 6620 7068 692d 636f 6d70 6f6e 656e   of phi-componen
-00017a80: 7420 6f66 2074 6865 2065 6c65 6374 7269  t of the electri
-00017a90: 6320 6669 656c 642e 222c 0a20 2020 2029  c field.",.    )
-00017aa0: 0a20 2020 2048 723a 2044 6966 6672 6163  .    Hr: Diffrac
-00017ab0: 7469 6f6e 4461 7461 4172 7261 7920 3d20  tionDataArray = 
-00017ac0: 7064 2e46 6965 6c64 280a 2020 2020 2020  pd.Field(.      
-00017ad0: 2020 2e2e 2e2c 0a20 2020 2020 2020 2074    ...,.        t
-00017ae0: 6974 6c65 3d22 4872 222c 0a20 2020 2020  itle="Hr",.     
-00017af0: 2020 2064 6573 6372 6970 7469 6f6e 3d22     description="
-00017b00: 5370 6174 6961 6c20 6469 7374 7269 6275  Spatial distribu
-00017b10: 7469 6f6e 206f 6620 722d 636f 6d70 6f6e  tion of r-compon
-00017b20: 656e 7420 6f66 2074 6865 206d 6167 6e65  ent of the magne
-00017b30: 7469 6320 6669 656c 642e 222c 0a20 2020  tic field.",.   
-00017b40: 2029 0a20 2020 2048 7468 6574 613a 2044   ).    Htheta: D
-00017b50: 6966 6672 6163 7469 6f6e 4461 7461 4172  iffractionDataAr
-00017b60: 7261 7920 3d20 7064 2e46 6965 6c64 280a  ray = pd.Field(.
-00017b70: 2020 2020 2020 2020 2e2e 2e2c 0a20 2020          ...,.   
-00017b80: 2020 2020 2074 6974 6c65 3d22 4874 6865       title="Hthe
-00017b90: 7461 222c 0a20 2020 2020 2020 2064 6573  ta",.        des
-00017ba0: 6372 6970 7469 6f6e 3d22 5370 6174 6961  cription="Spatia
-00017bb0: 6c20 6469 7374 7269 6275 7469 6f6e 206f  l distribution o
-00017bc0: 6620 7468 6574 612d 636f 6d70 6f6e 656e  f theta-componen
-00017bd0: 7420 6f66 2074 6865 206d 6167 6e65 7469  t of the magneti
-00017be0: 6320 6669 656c 642e 222c 0a20 2020 2029  c field.",.    )
-00017bf0: 0a20 2020 2048 7068 693a 2044 6966 6672  .    Hphi: Diffr
-00017c00: 6163 7469 6f6e 4461 7461 4172 7261 7920  actionDataArray 
-00017c10: 3d20 7064 2e46 6965 6c64 280a 2020 2020  = pd.Field(.    
-00017c20: 2020 2020 2e2e 2e2c 0a20 2020 2020 2020      ...,.       
-00017c30: 2074 6974 6c65 3d22 4870 6869 222c 0a20   title="Hphi",. 
-00017c40: 2020 2020 2020 2064 6573 6372 6970 7469         descripti
-00017c50: 6f6e 3d22 5370 6174 6961 6c20 6469 7374  on="Spatial dist
-00017c60: 7269 6275 7469 6f6e 206f 6620 7068 692d  ribution of phi-
-00017c70: 636f 6d70 6f6e 656e 7420 6f66 2074 6865  component of the
-00017c80: 206d 6167 6e65 7469 6320 6669 656c 642e   magnetic field.
-00017c90: 222c 0a20 2020 2029 0a0a 2020 2020 7369  ",.    )..    si
-00017ca0: 6d5f 7369 7a65 3a20 5475 706c 655b 666c  m_size: Tuple[fl
-00017cb0: 6f61 742c 2066 6c6f 6174 5d20 3d20 7064  oat, float] = pd
-00017cc0: 2e46 6965 6c64 280a 2020 2020 2020 2020  .Field(.        
-00017cd0: 2e2e 2e2c 0a20 2020 2020 2020 2074 6974  ...,.        tit
-00017ce0: 6c65 3d22 446f 6d61 696e 2073 697a 6522  le="Domain size"
-00017cf0: 2c0a 2020 2020 2020 2020 6465 7363 7269  ,.        descri
-00017d00: 7074 696f 6e3d 2253 697a 6520 6f66 2074  ption="Size of t
-00017d10: 6865 206e 6561 7220 6669 656c 6420 696e  he near field in
-00017d20: 2074 6865 206c 6f63 616c 2078 2061 6e64   the local x and
-00017d30: 2079 2064 6972 6563 7469 6f6e 732e 222c   y directions.",
-00017d40: 0a20 2020 2020 2020 2075 6e69 7473 3d4d  .        units=M
-00017d50: 4943 524f 4d45 5445 522c 0a20 2020 2029  ICROMETER,.    )
-00017d60: 0a0a 2020 2020 626c 6f63 685f 7665 6373  ..    bloch_vecs
-00017d70: 3a20 5475 706c 655b 666c 6f61 742c 2066  : Tuple[float, f
-00017d80: 6c6f 6174 5d20 3d20 7064 2e46 6965 6c64  loat] = pd.Field
-00017d90: 280a 2020 2020 2020 2020 2e2e 2e2c 0a20  (.        ...,. 
-00017da0: 2020 2020 2020 2074 6974 6c65 3d22 426c         title="Bl
-00017db0: 6f63 6820 7665 6374 6f72 7322 2c0a 2020  och vectors",.  
-00017dc0: 2020 2020 2020 6465 7363 7269 7074 696f        descriptio
-00017dd0: 6e3d 2242 6c6f 6368 2076 6563 746f 7273  n="Bloch vectors
-00017de0: 2061 6c6f 6e67 2074 6865 206c 6f63 616c   along the local
-00017df0: 2078 2061 6e64 2079 2064 6972 6563 7469   x and y directi
-00017e00: 6f6e 7320 696e 2075 6e69 7473 206f 6620  ons in units of 
-00017e10: 220a 2020 2020 2020 2020 2260 6032 202a  ".        "``2 *
-00017e20: 2070 6920 2f20 2873 696d 756c 6174 696f   pi / (simulatio
-00017e30: 6e20 7369 7a65 2061 6c6f 6e67 2074 6865  n size along the
-00017e40: 2072 6573 7065 6374 6976 6520 6469 6d65   respective dime
-00017e50: 6e73 696f 6e29 6060 2e22 2c0a 2020 2020  nsion)``.",.    
-00017e60: 290a 0a20 2020 2040 7374 6174 6963 6d65  )..    @staticme
-00017e70: 7468 6f64 0a20 2020 2064 6566 2073 6869  thod.    def shi
-00017e80: 6674 6564 5f6f 7264 6572 7328 6f72 6465  fted_orders(orde
-00017e90: 7273 3a20 5475 706c 655b 696e 742c 202e  rs: Tuple[int, .
-00017ea0: 2e2e 5d2c 2062 6c6f 6368 5f76 6563 3a20  ..], bloch_vec: 
-00017eb0: 666c 6f61 7429 202d 3e20 6e70 2e6e 6461  float) -> np.nda
-00017ec0: 7272 6179 3a0a 2020 2020 2020 2020 2222  rray:.        ""
-00017ed0: 2244 6966 6672 6163 7469 6f6e 206f 7264  "Diffraction ord
-00017ee0: 6572 7320 7368 6966 7465 6420 6279 2074  ers shifted by t
-00017ef0: 6865 2042 6c6f 6368 2076 6563 746f 722e  he Bloch vector.
-00017f00: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
-00017f10: 726e 2062 6c6f 6368 5f76 6563 202b 206e  rn bloch_vec + n
-00017f20: 702e 6174 6c65 6173 745f 3164 286f 7264  p.atleast_1d(ord
-00017f30: 6572 7329 0a0a 2020 2020 4073 7461 7469  ers)..    @stati
-00017f40: 636d 6574 686f 640a 2020 2020 6465 6620  cmethod.    def 
-00017f50: 7265 6369 7072 6f63 616c 5f63 6f6f 7264  reciprocal_coord
-00017f60: 7328 0a20 2020 2020 2020 206f 7264 6572  s(.        order
-00017f70: 733a 206e 702e 6e64 6172 7261 792c 2073  s: np.ndarray, s
-00017f80: 697a 653a 2066 6c6f 6174 2c20 626c 6f63  ize: float, bloc
-00017f90: 685f 7665 633a 2066 6c6f 6174 2c20 663a  h_vec: float, f:
-00017fa0: 2066 6c6f 6174 2c20 6d65 6469 756d 3a20   float, medium: 
-00017fb0: 4d65 6469 756d 5479 7065 0a20 2020 2029  MediumType.    )
-00017fc0: 202d 3e20 6e70 2e6e 6461 7272 6179 3a0a   -> np.ndarray:.
-00017fd0: 2020 2020 2020 2020 2222 2247 6574 2074          """Get t
-00017fe0: 6865 206e 6f72 6d61 6c69 7a65 6420 2275  he normalized "u
-00017ff0: 2220 7265 6369 7072 6f63 616c 2063 6f6f  " reciprocal coo
-00018000: 7264 7320 666f 7220 6120 7665 6374 6f72  rds for a vector
-00018010: 206f 6620 6f72 6465 7273 2c20 7369 7a65   of orders, size
-00018020: 2c20 616e 6420 626c 6f63 6820 7665 632e  , and bloch vec.
-00018030: 2222 220a 2020 2020 2020 2020 6966 2073  """.        if s
-00018040: 697a 6520 3d3d 2030 3a0a 2020 2020 2020  ize == 0:.      
-00018050: 2020 2020 2020 7265 7475 726e 206e 702e        return np.
-00018060: 6174 6c65 6173 745f 3264 2830 290a 2020  atleast_2d(0).  
-00018070: 2020 2020 2020 6570 7369 6c6f 6e20 3d20        epsilon = 
-00018080: 6d65 6469 756d 2e65 7073 5f6d 6f64 656c  medium.eps_model
-00018090: 2866 290a 2020 2020 2020 2020 626c 6f63  (f).        bloc
-000180a0: 685f 6172 7261 7920 3d20 4469 6666 7261  h_array = Diffra
-000180b0: 6374 696f 6e44 6174 612e 7368 6966 7465  ctionData.shifte
-000180c0: 645f 6f72 6465 7273 286f 7264 6572 732c  d_orders(orders,
-000180d0: 2062 6c6f 6368 5f76 6563 290a 2020 2020   bloch_vec).    
-000180e0: 2020 2020 7265 7475 726e 2062 6c6f 6368      return bloch
-000180f0: 5f61 7272 6179 5b3a 2c20 4e6f 6e65 5d20  _array[:, None] 
-00018100: 2f20 7369 7a65 202a 2043 5f30 202f 2066  / size * C_0 / f
-00018110: 202f 206e 702e 7265 616c 286e 702e 7371   / np.real(np.sq
-00018120: 7274 2865 7073 696c 6f6e 2929 0a0a 2020  rt(epsilon))..  
-00018130: 2020 4073 7461 7469 636d 6574 686f 640a    @staticmethod.
-00018140: 2020 2020 6465 6620 636f 6d70 7574 655f      def compute_
-00018150: 616e 676c 6573 280a 2020 2020 2020 2020  angles(.        
-00018160: 7265 6369 7072 6f63 616c 5f76 6563 746f  reciprocal_vecto
-00018170: 7273 3a20 5475 706c 655b 6e70 2e6e 6461  rs: Tuple[np.nda
-00018180: 7272 6179 2c20 6e70 2e6e 6461 7272 6179  rray, np.ndarray
-00018190: 5d2c 0a20 2020 2029 202d 3e20 5475 706c  ],.    ) -> Tupl
-000181a0: 655b 6e70 2e6e 6461 7272 6179 2c20 6e70  e[np.ndarray, np
-000181b0: 2e6e 6461 7272 6179 5d3a 0a20 2020 2020  .ndarray]:.     
-000181c0: 2020 2022 2222 436f 6d70 7574 6520 7468     """Compute th
-000181d0: 6520 706f 6c61 7220 616e 6420 617a 696d  e polar and azim
-000181e0: 7574 6820 616e 676c 6573 2061 7373 6f63  uth angles assoc
-000181f0: 6961 7465 6420 7769 7468 2074 6865 2067  iated with the g
-00018200: 6976 656e 2072 6563 6970 726f 6361 6c20  iven reciprocal 
-00018210: 7665 6374 6f72 732e 2222 220a 2020 2020  vectors.""".    
-00018220: 2020 2020 2320 736f 6d65 2077 6176 6520      # some wave 
-00018230: 6e75 6d62 6572 2070 6169 7273 2061 7265  number pairs are
-00018240: 206f 7574 7369 6465 2074 6865 206c 6967   outside the lig
-00018250: 6874 2063 6f6e 652c 206c 6561 6469 6e67  ht cone, leading
-00018260: 2074 6f20 7761 726e 696e 6773 2066 726f   to warnings fro
-00018270: 6d20 6e75 6d70 792e 6172 6373 696e 0a20  m numpy.arcsin. 
-00018280: 2020 2020 2020 2077 6974 6820 7761 726e         with warn
-00018290: 696e 6773 2e63 6174 6368 5f77 6172 6e69  ings.catch_warni
-000182a0: 6e67 7328 293a 0a20 2020 2020 2020 2020  ngs():.         
-000182b0: 2020 2077 6172 6e69 6e67 732e 6669 6c74     warnings.filt
-000182c0: 6572 7761 726e 696e 6773 280a 2020 2020  erwarnings(.    
-000182d0: 2020 2020 2020 2020 2020 2020 2269 676e              "ign
-000182e0: 6f72 6522 2c20 6d65 7373 6167 653d 2269  ore", message="i
-000182f0: 6e76 616c 6964 2076 616c 7565 2065 6e63  nvalid value enc
-00018300: 6f75 6e74 6572 6564 2069 6e20 6172 6373  ountered in arcs
-00018310: 696e 222c 2063 6174 6567 6f72 793d 5275  in", category=Ru
-00018320: 6e74 696d 6557 6172 6e69 6e67 0a20 2020  ntimeWarning.   
-00018330: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
-00018340: 2020 2020 2020 2075 782c 2075 7920 3d20         ux, uy = 
-00018350: 7265 6369 7072 6f63 616c 5f76 6563 746f  reciprocal_vecto
-00018360: 7273 0a20 2020 2020 2020 2020 2020 2074  rs.            t
-00018370: 6865 7461 732c 2070 6869 7320 3d20 4469  hetas, phis = Di
-00018380: 6666 7261 6374 696f 6e4d 6f6e 6974 6f72  ffractionMonitor
-00018390: 2e6b 7370 6163 655f 325f 7370 6828 7578  .kspace_2_sph(ux
-000183a0: 5b3a 2c20 4e6f 6e65 2c20 3a5d 2c20 7579  [:, None, :], uy
-000183b0: 5b4e 6f6e 652c 203a 2c20 3a5d 2c20 6178  [None, :, :], ax
-000183c0: 6973 3d32 290a 2020 2020 2020 2020 7265  is=2).        re
-000183d0: 7475 726e 2028 7468 6574 6173 2c20 7068  turn (thetas, ph
-000183e0: 6973 290a 0a20 2020 2040 7072 6f70 6572  is)..    @proper
-000183f0: 7479 0a20 2020 2064 6566 2063 6f6f 7264  ty.    def coord
-00018400: 735f 7370 6865 7269 6361 6c28 7365 6c66  s_spherical(self
-00018410: 2920 2d3e 2044 6963 745b 7374 722c 206e  ) -> Dict[str, n
-00018420: 702e 6e64 6172 7261 795d 3a0a 2020 2020  p.ndarray]:.    
-00018430: 2020 2020 2222 2243 6f6f 7264 696e 6174      """Coordinat
-00018440: 6573 2067 7269 6420 666f 7220 7468 6520  es grid for the 
-00018450: 6669 656c 6473 2069 6e20 7468 6520 7370  fields in the sp
-00018460: 6865 7269 6361 6c20 7379 7374 656d 2e22  herical system."
-00018470: 2222 0a20 2020 2020 2020 2074 6865 7461  "".        theta
-00018480: 2c20 7068 6920 3d20 7365 6c66 2e61 6e67  , phi = self.ang
-00018490: 6c65 730a 2020 2020 2020 2020 7265 7475  les.        retu
-000184a0: 726e 207b 2272 223a 204e 6f6e 652c 2022  rn {"r": None, "
-000184b0: 7468 6574 6122 3a20 7468 6574 612c 2022  theta": theta, "
-000184c0: 7068 6922 3a20 7068 697d 0a0a 2020 2020  phi": phi}..    
-000184d0: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
-000184e0: 6620 6f72 6465 7273 5f78 2873 656c 6629  f orders_x(self)
-000184f0: 202d 3e20 6e70 2e6e 6461 7272 6179 3a0a   -> np.ndarray:.
-00018500: 2020 2020 2020 2020 2222 2241 6c6c 6f77          """Allow
-00018510: 6564 206f 7264 6572 7320 616c 6f6e 6720  ed orders along 
-00018520: 782e 2222 220a 2020 2020 2020 2020 7265  x.""".        re
-00018530: 7475 726e 206e 702e 6174 6c65 6173 745f  turn np.atleast_
-00018540: 3164 286e 702e 6172 7261 7928 7365 6c66  1d(np.array(self
-00018550: 2e45 7468 6574 612e 636f 6f72 6473 5b22  .Etheta.coords["
-00018560: 6f72 6465 7273 5f78 225d 2929 0a0a 2020  orders_x"]))..  
-00018570: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
-00018580: 6465 6620 6f72 6465 7273 5f79 2873 656c  def orders_y(sel
-00018590: 6629 202d 3e20 6e70 2e6e 6461 7272 6179  f) -> np.ndarray
-000185a0: 3a0a 2020 2020 2020 2020 2222 2241 6c6c  :.        """All
-000185b0: 6f77 6564 206f 7264 6572 7320 616c 6f6e  owed orders alon
-000185c0: 6720 792e 2222 220a 2020 2020 2020 2020  g y.""".        
-000185d0: 7265 7475 726e 206e 702e 6174 6c65 6173  return np.atleas
-000185e0: 745f 3164 286e 702e 6172 7261 7928 7365  t_1d(np.array(se
-000185f0: 6c66 2e45 7468 6574 612e 636f 6f72 6473  lf.Etheta.coords
-00018600: 5b22 6f72 6465 7273 5f79 225d 2929 0a0a  ["orders_y"]))..
-00018610: 2020 2020 4070 726f 7065 7274 790a 2020      @property.  
-00018620: 2020 6465 6620 7265 6369 7072 6f63 616c    def reciprocal
-00018630: 5f76 6563 746f 7273 2873 656c 6629 202d  _vectors(self) -
-00018640: 3e20 5475 706c 655b 6e70 2e6e 6461 7272  > Tuple[np.ndarr
-00018650: 6179 2c20 6e70 2e6e 6461 7272 6179 5d3a  ay, np.ndarray]:
-00018660: 0a20 2020 2020 2020 2022 2222 4765 7420  .        """Get 
-00018670: 7468 6520 6e6f 726d 616c 697a 6564 2022  the normalized "
-00018680: 7578 2220 616e 6420 2275 7922 2072 6563  ux" and "uy" rec
-00018690: 6970 726f 6361 6c20 7665 6374 6f72 732e  iprocal vectors.
-000186a0: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
-000186b0: 726e 2028 7365 6c66 2e75 782c 2073 656c  rn (self.ux, sel
-000186c0: 662e 7579 290a 0a20 2020 2040 7072 6f70  f.uy)..    @prop
-000186d0: 6572 7479 0a20 2020 2064 6566 2075 7828  erty.    def ux(
-000186e0: 7365 6c66 2920 2d3e 206e 702e 6e64 6172  self) -> np.ndar
-000186f0: 7261 793a 0a20 2020 2020 2020 2022 2222  ray:.        """
-00018700: 4e6f 726d 616c 697a 6564 2077 6176 6520  Normalized wave 
-00018710: 7665 6374 6f72 2061 6c6f 6e67 2078 2072  vector along x r
-00018720: 656c 6174 6976 6520 746f 2060 606c 6f63  elative to ``loc
-00018730: 616c 5f6f 7269 6769 6e60 6020 616e 6420  al_origin`` and 
-00018740: 6f72 6965 6e74 6564 0a20 2020 2020 2020  oriented.       
-00018750: 2077 6974 6820 7265 7370 6563 7420 746f   with respect to
-00018760: 2060 606d 6f6e 6974 6f72 2e6e 6f72 6d61   ``monitor.norma
-00018770: 6c5f 6469 7260 602c 206e 6f72 6d61 6c69  l_dir``, normali
-00018780: 7a65 6420 6279 2074 6865 2077 6176 6520  zed by the wave 
-00018790: 6e75 6d62 6572 2069 6e20 7468 650a 2020  number in the.  
-000187a0: 2020 2020 2020 7072 6f6a 6563 7469 6f6e        projection
-000187b0: 206d 6564 6975 6d2e 2222 220a 2020 2020   medium.""".    
-000187c0: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-000187d0: 7265 6369 7072 6f63 616c 5f63 6f6f 7264  reciprocal_coord
-000187e0: 7328 0a20 2020 2020 2020 2020 2020 206f  s(.            o
-000187f0: 7264 6572 733d 7365 6c66 2e6f 7264 6572  rders=self.order
-00018800: 735f 782c 0a20 2020 2020 2020 2020 2020  s_x,.           
-00018810: 2073 697a 653d 7365 6c66 2e73 696d 5f73   size=self.sim_s
-00018820: 697a 655b 305d 2c0a 2020 2020 2020 2020  ize[0],.        
-00018830: 2020 2020 626c 6f63 685f 7665 633d 7365      bloch_vec=se
-00018840: 6c66 2e62 6c6f 6368 5f76 6563 735b 305d  lf.bloch_vecs[0]
-00018850: 2c0a 2020 2020 2020 2020 2020 2020 663d  ,.            f=
-00018860: 7365 6c66 2e66 2c0a 2020 2020 2020 2020  self.f,.        
-00018870: 2020 2020 6d65 6469 756d 3d73 656c 662e      medium=self.
-00018880: 6d65 6469 756d 2c0a 2020 2020 2020 2020  medium,.        
-00018890: 290a 0a20 2020 2040 7072 6f70 6572 7479  )..    @property
-000188a0: 0a20 2020 2064 6566 2075 7928 7365 6c66  .    def uy(self
-000188b0: 2920 2d3e 206e 702e 6e64 6172 7261 793a  ) -> np.ndarray:
-000188c0: 0a20 2020 2020 2020 2022 2222 4e6f 726d  .        """Norm
-000188d0: 616c 697a 6564 2077 6176 6520 7665 6374  alized wave vect
-000188e0: 6f72 2061 6c6f 6e67 2079 2072 656c 6174  or along y relat
-000188f0: 6976 6520 746f 2060 606c 6f63 616c 5f6f  ive to ``local_o
-00018900: 7269 6769 6e60 6020 616e 6420 6f72 6965  rigin`` and orie
-00018910: 6e74 6564 0a20 2020 2020 2020 2077 6974  nted.        wit
-00018920: 6820 7265 7370 6563 7420 746f 2060 606d  h respect to ``m
-00018930: 6f6e 6974 6f72 2e6e 6f72 6d61 6c5f 6469  onitor.normal_di
-00018940: 7260 602c 206e 6f72 6d61 6c69 7a65 6420  r``, normalized 
-00018950: 6279 2074 6865 2077 6176 6520 6e75 6d62  by the wave numb
-00018960: 6572 2069 6e20 7468 650a 2020 2020 2020  er in the.      
-00018970: 2020 7072 6f6a 6563 7469 6f6e 206d 6564    projection med
-00018980: 6975 6d2e 2222 220a 2020 2020 2020 2020  ium.""".        
-00018990: 7265 7475 726e 2073 656c 662e 7265 6369  return self.reci
-000189a0: 7072 6f63 616c 5f63 6f6f 7264 7328 0a20  procal_coords(. 
-000189b0: 2020 2020 2020 2020 2020 206f 7264 6572             order
-000189c0: 733d 7365 6c66 2e6f 7264 6572 735f 792c  s=self.orders_y,
-000189d0: 0a20 2020 2020 2020 2020 2020 2073 697a  .            siz
-000189e0: 653d 7365 6c66 2e73 696d 5f73 697a 655b  e=self.sim_size[
-000189f0: 315d 2c0a 2020 2020 2020 2020 2020 2020  1],.            
-00018a00: 626c 6f63 685f 7665 633d 7365 6c66 2e62  bloch_vec=self.b
-00018a10: 6c6f 6368 5f76 6563 735b 315d 2c0a 2020  loch_vecs[1],.  
-00018a20: 2020 2020 2020 2020 2020 663d 7365 6c66            f=self
-00018a30: 2e66 2c0a 2020 2020 2020 2020 2020 2020  .f,.            
-00018a40: 6d65 6469 756d 3d73 656c 662e 6d65 6469  medium=self.medi
-00018a50: 756d 2c0a 2020 2020 2020 2020 290a 0a20  um,.        ).. 
-00018a60: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
-00018a70: 2064 6566 2061 6e67 6c65 7328 7365 6c66   def angles(self
-00018a80: 2920 2d3e 2054 7570 6c65 5b78 722e 4461  ) -> Tuple[xr.Da
-00018a90: 7461 4172 7261 795d 3a0a 2020 2020 2020  taArray]:.      
-00018aa0: 2020 2222 2254 6865 2028 7468 6574 612c    """The (theta,
-00018ab0: 2070 6869 2920 616e 676c 6573 2063 6f72   phi) angles cor
-00018ac0: 7265 7370 6f6e 6469 6e67 2074 6f20 6561  responding to ea
-00018ad0: 6368 2061 6c6c 6f77 6564 2070 6169 7220  ch allowed pair 
-00018ae0: 6f66 2064 6966 6672 6163 7469 6f6e 0a20  of diffraction. 
-00018af0: 2020 2020 2020 206f 7264 6572 7320 7374         orders st
-00018b00: 6f72 6564 7320 6173 2064 6174 6120 6172  oreds as data ar
-00018b10: 7261 7973 2e20 4469 7361 6c6c 6f77 6564  rays. Disallowed
-00018b20: 2061 6e67 6c65 7320 6172 6520 7365 7420   angles are set 
-00018b30: 746f 2060 606e 702e 6e61 6e60 602e 0a20  to ``np.nan``.. 
-00018b40: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00018b50: 2020 2074 6865 7461 732c 2070 6869 7320     thetas, phis 
-00018b60: 3d20 7365 6c66 2e63 6f6d 7075 7465 5f61  = self.compute_a
-00018b70: 6e67 6c65 7328 7365 6c66 2e72 6563 6970  ngles(self.recip
-00018b80: 726f 6361 6c5f 7665 6374 6f72 7329 0a20  rocal_vectors). 
-00018b90: 2020 2020 2020 2074 6865 7461 5f64 6174         theta_dat
-00018ba0: 6120 3d20 7872 2e44 6174 6141 7272 6179  a = xr.DataArray
-00018bb0: 2874 6865 7461 732c 2063 6f6f 7264 733d  (thetas, coords=
-00018bc0: 7365 6c66 2e63 6f6f 7264 7329 0a20 2020  self.coords).   
-00018bd0: 2020 2020 2070 6869 5f64 6174 6120 3d20       phi_data = 
-00018be0: 7872 2e44 6174 6141 7272 6179 2870 6869  xr.DataArray(phi
-00018bf0: 732c 2063 6f6f 7264 733d 7365 6c66 2e63  s, coords=self.c
-00018c00: 6f6f 7264 7329 0a20 2020 2020 2020 2072  oords).        r
-00018c10: 6574 7572 6e20 7468 6574 615f 6461 7461  eturn theta_data
-00018c20: 2c20 7068 695f 6461 7461 0a0a 2020 2020  , phi_data..    
-00018c30: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
-00018c40: 6620 616d 7073 2873 656c 6629 202d 3e20  f amps(self) -> 
-00018c50: 7872 2e44 6174 6141 7272 6179 3a0a 2020  xr.DataArray:.  
-00018c60: 2020 2020 2020 2222 2243 6f6d 706c 6578        """Complex
-00018c70: 2070 6f77 6572 2061 6d70 6c69 7475 6465   power amplitude
-00018c80: 2069 6e20 6561 6368 206f 7264 6572 2066   in each order f
-00018c90: 6f72 2027 7327 2061 6e64 2027 7027 2070  or 's' and 'p' p
-00018ca0: 6f6c 6172 697a 6174 696f 6e73 2c20 6e6f  olarizations, no
-00018cb0: 726d 616c 697a 6564 2073 6f20 7468 6174  rmalized so that
-00018cc0: 0a20 2020 2020 2020 2074 6865 2070 6f77  .        the pow
-00018cd0: 6572 2063 6172 7269 6564 2062 7920 7468  er carried by th
-00018ce0: 6520 7761 7665 206f 6620 7468 6174 206f  e wave of that o
-00018cf0: 7264 6572 2061 6e64 2070 6f6c 6172 697a  rder and polariz
-00018d00: 6174 696f 6e20 6571 7561 6c73 2060 6061  ation equals ``a
-00018d10: 6273 2861 6d70 7329 5e32 6060 2e0a 2020  bs(amps)^2``..  
-00018d20: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-00018d30: 2020 636f 735f 7468 6574 6120 3d20 6e70    cos_theta = np
-00018d40: 2e63 6f73 286e 702e 6e61 6e5f 746f 5f6e  .cos(np.nan_to_n
-00018d50: 756d 2873 656c 662e 616e 676c 6573 5b30  um(self.angles[0
-00018d60: 5d29 290a 0a20 2020 2020 2020 2023 2077  ]))..        # w
-00018d70: 696c 6c20 7365 7420 616d 706c 6974 7564  ill set amplitud
-00018d80: 6573 2074 6f20 3020 666f 7220 676c 616e  es to 0 for glan
-00018d90: 6369 6e67 206f 7220 6e65 6761 7469 7665  cing or negative
-00018da0: 2061 6e67 6c65 730a 2020 2020 2020 2020   angles.        
-00018db0: 636f 735f 7468 6574 615b 636f 735f 7468  cos_theta[cos_th
-00018dc0: 6574 6120 3c3d 2030 5d20 3d20 6e70 2e69  eta <= 0] = np.i
-00018dd0: 6e66 0a0a 2020 2020 2020 2020 6e6f 726d  nf..        norm
-00018de0: 203d 2031 2e30 202f 206e 702e 7371 7274   = 1.0 / np.sqrt
-00018df0: 2832 2e30 202a 2073 656c 662e 6574 6129  (2.0 * self.eta)
-00018e00: 202f 206e 702e 7371 7274 2863 6f73 5f74   / np.sqrt(cos_t
-00018e10: 6865 7461 290a 2020 2020 2020 2020 616d  heta).        am
-00018e20: 705f 7468 6574 6120 3d20 7365 6c66 2e45  p_theta = self.E
-00018e30: 7468 6574 612e 7661 6c75 6573 202a 206e  theta.values * n
-00018e40: 6f72 6d0a 2020 2020 2020 2020 616d 705f  orm.        amp_
-00018e50: 7068 6920 3d20 7365 6c66 2e45 7068 692e  phi = self.Ephi.
-00018e60: 7661 6c75 6573 202a 206e 6f72 6d0a 0a20  values * norm.. 
-00018e70: 2020 2020 2020 2023 2073 7461 636b 2074         # stack t
-00018e80: 6865 2061 6d70 6c69 7475 6465 7320 696e  he amplitudes in
-00018e90: 2073 2d20 616e 6420 702d 636f 6d70 6f6e   s- and p-compon
-00018ea0: 656e 7473 2061 6c6f 6e67 2061 206e 6577  ents along a new
-00018eb0: 2070 6f6c 6172 697a 6174 696f 6e20 6178   polarization ax
-00018ec0: 6973 0a20 2020 2020 2020 2063 6f6f 7264  is.        coord
-00018ed0: 7320 3d20 7b7d 0a20 2020 2020 2020 2063  s = {}.        c
-00018ee0: 6f6f 7264 735b 226f 7264 6572 735f 7822  oords["orders_x"
-00018ef0: 5d20 3d20 6e70 2e61 746c 6561 7374 5f31  ] = np.atleast_1
-00018f00: 6428 7365 6c66 2e6f 7264 6572 735f 7829  d(self.orders_x)
-00018f10: 0a20 2020 2020 2020 2063 6f6f 7264 735b  .        coords[
-00018f20: 226f 7264 6572 735f 7922 5d20 3d20 6e70  "orders_y"] = np
-00018f30: 2e61 746c 6561 7374 5f31 6428 7365 6c66  .atleast_1d(self
-00018f40: 2e6f 7264 6572 735f 7929 0a20 2020 2020  .orders_y).     
-00018f50: 2020 2063 6f6f 7264 735b 2266 225d 203d     coords["f"] =
-00018f60: 206e 702e 6174 6c65 6173 745f 3164 2873   np.atleast_1d(s
-00018f70: 656c 662e 6629 0a20 2020 2020 2020 2063  elf.f).        c
-00018f80: 6f6f 7264 735b 2270 6f6c 6172 697a 6174  oords["polarizat
-00018f90: 696f 6e22 5d20 3d20 5b22 7322 2c20 2270  ion"] = ["s", "p
-00018fa0: 225d 0a20 2020 2020 2020 2072 6574 7572  "].        retur
-00018fb0: 6e20 7872 2e44 6174 6141 7272 6179 286e  n xr.DataArray(n
-00018fc0: 702e 7374 6163 6b28 5b61 6d70 5f70 6869  p.stack([amp_phi
-00018fd0: 2c20 616d 705f 7468 6574 615d 2c20 6178  , amp_theta], ax
-00018fe0: 6973 3d33 292c 2063 6f6f 7264 733d 636f  is=3), coords=co
-00018ff0: 6f72 6473 290a 0a20 2020 2040 7072 6f70  ords)..    @prop
-00019000: 6572 7479 0a20 2020 2064 6566 2070 6f77  erty.    def pow
-00019010: 6572 2873 656c 6629 202d 3e20 7872 2e44  er(self) -> xr.D
-00019020: 6174 6141 7272 6179 3a0a 2020 2020 2020  ataArray:.      
-00019030: 2020 2222 2254 6f74 616c 2070 6f77 6572    """Total power
-00019040: 2069 6e20 6561 6368 206f 7264 6572 2c20   in each order, 
-00019050: 7375 6d6d 6564 206f 7665 7220 626f 7468  summed over both
-00019060: 2070 6f6c 6172 697a 6174 696f 6e73 2e22   polarizations."
-00019070: 2222 0a20 2020 2020 2020 2072 6574 7572  "".        retur
-00019080: 6e20 286e 702e 6162 7328 7365 6c66 2e61  n (np.abs(self.a
-00019090: 6d70 7329 202a 2a20 3229 2e73 756d 2864  mps) ** 2).sum(d
-000190a0: 696d 3d22 706f 6c61 7269 7a61 7469 6f6e  im="polarization
-000190b0: 2229 0a0a 2020 2020 4070 726f 7065 7274  ")..    @propert
-000190c0: 790a 2020 2020 6465 6620 6669 656c 6473  y.    def fields
-000190d0: 5f73 7068 6572 6963 616c 2873 656c 6629  _spherical(self)
-000190e0: 202d 3e20 7872 2e44 6174 6173 6574 3a0a   -> xr.Dataset:.
-000190f0: 2020 2020 2020 2020 2222 2247 6574 2061          """Get a
-00019100: 6c6c 2066 6965 6c64 2063 6f6d 706f 6e65  ll field compone
-00019110: 6e74 7320 696e 2073 7068 6572 6963 616c  nts in spherical
-00019120: 2063 6f6f 7264 696e 6174 6573 2072 656c   coordinates rel
-00019130: 6174 6976 6520 746f 2074 6865 206d 6f6e  ative to the mon
-00019140: 6974 6f72 2773 0a20 2020 2020 2020 206c  itor's.        l
-00019150: 6f63 616c 206f 7269 6769 6e20 666f 7220  ocal origin for 
-00019160: 616c 6c20 616c 6c6f 7765 6420 6469 6666  all allowed diff
-00019170: 7261 6374 696f 6e20 6f72 6465 7273 2061  raction orders a
-00019180: 6e64 2066 7265 7175 656e 6369 6573 2073  nd frequencies s
-00019190: 7065 6369 6669 6564 2069 6e20 7468 650a  pecified in the.
-000191a0: 2020 2020 2020 2020 3a63 6c61 7373 3a60          :class:`
-000191b0: 4469 6666 7261 6374 696f 6e4d 6f6e 6974  DiffractionMonit
-000191c0: 6f72 602e 0a0a 2020 2020 2020 2020 5265  or`...        Re
-000191d0: 7475 726e 730a 2020 2020 2020 2020 2d2d  turns.        --
-000191e0: 2d2d 2d2d 2d0a 2020 2020 2020 2020 6060  -----.        ``
-000191f0: 7861 7272 6179 2e44 6174 6173 6574 6060  xarray.Dataset``
-00019200: 0a20 2020 2020 2020 2020 2020 2078 6172  .            xar
-00019210: 7261 7920 6461 7461 7365 7420 636f 6e74  ray dataset cont
-00019220: 6169 6e69 6e67 0a20 2020 2020 2020 2020  aining.         
-00019230: 2020 2028 6060 4572 6060 2c20 6060 4574     (``Er``, ``Et
-00019240: 6865 7461 6060 2c20 6060 4570 6869 6060  heta``, ``Ephi``
-00019250: 2c20 6060 4872 6060 2c20 6060 4874 6865  , ``Hr``, ``Hthe
-00019260: 7461 6060 2c20 6060 4870 6869 6060 290a  ta``, ``Hphi``).
-00019270: 2020 2020 2020 2020 2020 2020 696e 2073              in s
-00019280: 7068 6572 6963 616c 2063 6f6f 7264 696e  pherical coordin
-00019290: 6174 6573 2e0a 2020 2020 2020 2020 2222  ates..        ""
-000192a0: 220a 2020 2020 2020 2020 6669 656c 6473  ".        fields
-000192b0: 203d 205b 6669 656c 642e 7661 6c75 6573   = [field.values
-000192c0: 2066 6f72 2066 6965 6c64 2069 6e20 7365   for field in se
-000192d0: 6c66 2e66 6965 6c64 5f63 6f6d 706f 6e65  lf.field_compone
-000192e0: 6e74 732e 7661 6c75 6573 2829 5d0a 2020  nts.values()].  
-000192f0: 2020 2020 2020 6b65 7973 203d 205b 2245        keys = ["E
-00019300: 7222 2c20 2245 7468 6574 6122 2c20 2245  r", "Etheta", "E
-00019310: 7068 6922 2c20 2248 7222 2c20 2248 7468  phi", "Hr", "Hth
-00019320: 6574 6122 2c20 2248 7068 6922 5d0a 2020  eta", "Hphi"].  
-00019330: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-00019340: 662e 5f6d 616b 655f 6461 7461 7365 7428  f._make_dataset(
-00019350: 6669 656c 6473 2c20 6b65 7973 290a 0a20  fields, keys).. 
-00019360: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
-00019370: 2064 6566 2066 6965 6c64 735f 6361 7274   def fields_cart
-00019380: 6573 6961 6e28 7365 6c66 2920 2d3e 2078  esian(self) -> x
-00019390: 722e 4461 7461 7365 743a 0a20 2020 2020  r.Dataset:.     
-000193a0: 2020 2022 2222 4765 7420 616c 6c20 6669     """Get all fi
-000193b0: 656c 6420 636f 6d70 6f6e 656e 7473 2069  eld components i
-000193c0: 6e20 4361 7274 6573 6961 6e20 636f 6f72  n Cartesian coor
-000193d0: 6469 6e61 7465 7320 7265 6c61 7469 7665  dinates relative
-000193e0: 2074 6f20 7468 6520 6d6f 6e69 746f 7227   to the monitor'
-000193f0: 730a 2020 2020 2020 2020 6c6f 6361 6c20  s.        local 
-00019400: 6f72 6967 696e 2066 6f72 2061 6c6c 2061  origin for all a
-00019410: 6c6c 6f77 6564 2064 6966 6672 6163 7469  llowed diffracti
-00019420: 6f6e 206f 7264 6572 7320 616e 6420 6672  on orders and fr
-00019430: 6571 7565 6e63 6965 7320 7370 6563 6966  equencies specif
-00019440: 6965 6420 696e 2074 6865 0a20 2020 2020  ied in the.     
-00019450: 2020 203a 636c 6173 733a 6044 6966 6672     :class:`Diffr
-00019460: 6163 7469 6f6e 4d6f 6e69 746f 7260 2e0a  actionMonitor`..
-00019470: 0a20 2020 2020 2020 2052 6574 7572 6e73  .        Returns
-00019480: 0a20 2020 2020 2020 202d 2d2d 2d2d 2d2d  .        -------
-00019490: 0a20 2020 2020 2020 2060 6078 6172 7261  .        ``xarra
-000194a0: 792e 4461 7461 7365 7460 600a 2020 2020  y.Dataset``.    
-000194b0: 2020 2020 2020 2020 7861 7272 6179 2064          xarray d
-000194c0: 6174 6173 6574 2063 6f6e 7461 696e 696e  ataset containin
-000194d0: 6720 2860 6045 7860 602c 2060 6045 7960  g (``Ex``, ``Ey`
-000194e0: 602c 2060 6045 7a60 602c 2060 6048 7860  `, ``Ez``, ``Hx`
-000194f0: 602c 2060 6048 7960 602c 2060 6048 7a60  `, ``Hy``, ``Hz`
-00019500: 6029 0a20 2020 2020 2020 2020 2020 2069  `).            i
-00019510: 6e20 4361 7274 6573 6961 6e20 636f 6f72  n Cartesian coor
-00019520: 6469 6e61 7465 732e 0a20 2020 2020 2020  dinates..       
-00019530: 2022 2222 0a20 2020 2020 2020 2074 6865   """.        the
-00019540: 7461 2c20 7068 6920 3d20 7365 6c66 2e61  ta, phi = self.a
-00019550: 6e67 6c65 730a 2020 2020 2020 2020 7468  ngles.        th
-00019560: 6574 6120 3d20 7468 6574 612e 7661 6c75  eta = theta.valu
-00019570: 6573 0a20 2020 2020 2020 2070 6869 203d  es.        phi =
-00019580: 2070 6869 2e76 616c 7565 730a 0a20 2020   phi.values..   
-00019590: 2020 2020 2065 5f78 2c20 655f 792c 2065       e_x, e_y, e
-000195a0: 5f7a 203d 2073 656c 662e 6d6f 6e69 746f  _z = self.monito
-000195b0: 722e 7370 685f 325f 6361 725f 6669 656c  r.sph_2_car_fiel
-000195c0: 6428 0a20 2020 2020 2020 2020 2020 2030  d(.            0
-000195d0: 2c20 7365 6c66 2e45 7468 6574 612e 7661  , self.Etheta.va
-000195e0: 6c75 6573 2c20 7365 6c66 2e45 7068 692e  lues, self.Ephi.
-000195f0: 7661 6c75 6573 2c20 7468 6574 612c 2070  values, theta, p
-00019600: 6869 0a20 2020 2020 2020 2029 0a20 2020  hi.        ).   
-00019610: 2020 2020 2068 5f78 2c20 685f 792c 2068       h_x, h_y, h
-00019620: 5f7a 203d 2073 656c 662e 6d6f 6e69 746f  _z = self.monito
-00019630: 722e 7370 685f 325f 6361 725f 6669 656c  r.sph_2_car_fiel
-00019640: 6428 0a20 2020 2020 2020 2020 2020 2030  d(.            0
-00019650: 2c20 7365 6c66 2e48 7468 6574 612e 7661  , self.Htheta.va
-00019660: 6c75 6573 2c20 7365 6c66 2e48 7068 692e  lues, self.Hphi.
-00019670: 7661 6c75 6573 2c20 7468 6574 612c 2070  values, theta, p
-00019680: 6869 0a20 2020 2020 2020 2029 0a20 2020  hi.        ).   
-00019690: 2020 2020 2065 5f78 2c20 655f 792c 2065       e_x, e_y, e
-000196a0: 5f7a 2c20 685f 782c 2068 5f79 2c20 685f  _z, h_x, h_y, h_
-000196b0: 7a20 3d20 280a 2020 2020 2020 2020 2020  z = (.          
-000196c0: 2020 6e70 2e6e 616e 5f74 6f5f 6e75 6d28    np.nan_to_num(
-000196d0: 666c 6429 2066 6f72 2066 6c64 2069 6e20  fld) for fld in 
-000196e0: 5b65 5f78 2c20 655f 792c 2065 5f7a 2c20  [e_x, e_y, e_z, 
-000196f0: 685f 782c 2068 5f79 2c20 685f 7a5d 0a20  h_x, h_y, h_z]. 
-00019700: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
-00019710: 2020 6669 656c 6473 203d 205b 655f 782c    fields = [e_x,
-00019720: 2065 5f79 2c20 655f 7a2c 2068 5f78 2c20   e_y, e_z, h_x, 
-00019730: 685f 792c 2068 5f7a 5d0a 2020 2020 2020  h_y, h_z].      
-00019740: 2020 6b65 7973 203d 205b 2245 7822 2c20    keys = ["Ex", 
-00019750: 2245 7922 2c20 2245 7a22 2c20 2248 7822  "Ey", "Ez", "Hx"
-00019760: 2c20 2248 7922 2c20 2248 7a22 5d0a 2020  , "Hy", "Hz"].  
-00019770: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-00019780: 662e 5f6d 616b 655f 6461 7461 7365 7428  f._make_dataset(
-00019790: 6669 656c 6473 2c20 6b65 7973 290a 0a20  fields, keys).. 
-000197a0: 2020 2064 6566 205f 6d61 6b65 5f64 6174     def _make_dat
-000197b0: 6173 6574 2873 656c 662c 2066 6965 6c64  aset(self, field
-000197c0: 733a 2054 7570 6c65 5b6e 702e 6e64 6172  s: Tuple[np.ndar
-000197d0: 7261 792c 202e 2e2e 5d2c 206b 6579 733a  ray, ...], keys:
-000197e0: 2054 7570 6c65 5b73 7472 2c20 2e2e 2e5d   Tuple[str, ...]
-000197f0: 2920 2d3e 2078 722e 4461 7461 7365 743a  ) -> xr.Dataset:
-00019800: 0a20 2020 2020 2020 2022 2222 4d61 6b65  .        """Make
-00019810: 2061 6e20 7872 2e44 6174 6173 6574 2066   an xr.Dataset f
-00019820: 6f72 2066 6965 6c64 7320 7769 7468 2067  or fields with g
-00019830: 6976 656e 2066 6965 6c64 206e 616d 6573  iven field names
-00019840: 2e22 2222 0a20 2020 2020 2020 2064 6174  .""".        dat
-00019850: 615f 6172 7261 7973 203d 205b 5d0a 2020  a_arrays = [].  
-00019860: 2020 2020 2020 666f 7220 6669 656c 6420        for field 
-00019870: 696e 2066 6965 6c64 733a 0a20 2020 2020  in fields:.     
-00019880: 2020 2020 2020 2064 6174 615f 6172 7261         data_arra
-00019890: 7973 2e61 7070 656e 6428 7872 2e44 6174  ys.append(xr.Dat
-000198a0: 6141 7272 6179 2864 6174 613d 6669 656c  aArray(data=fiel
-000198b0: 642c 2063 6f6f 7264 733d 7365 6c66 2e63  d, coords=self.c
-000198c0: 6f6f 7264 732c 2064 696d 733d 7365 6c66  oords, dims=self
-000198d0: 2e64 696d 7329 290a 2020 2020 2020 2020  .dims)).        
-000198e0: 7265 7475 726e 2078 722e 4461 7461 7365  return xr.Datase
-000198f0: 7428 6469 6374 287a 6970 286b 6579 732c  t(dict(zip(keys,
-00019900: 2064 6174 615f 6172 7261 7973 2929 290a   data_arrays))).
-00019910: 0a0a 4d6f 6e69 746f 7244 6174 6154 7970  ..MonitorDataTyp
-00019920: 6573 203d 2028 0a20 2020 2046 6965 6c64  es = (.    Field
-00019930: 4461 7461 2c0a 2020 2020 4669 656c 6454  Data,.    FieldT
-00019940: 696d 6544 6174 612c 0a20 2020 2050 6572  imeData,.    Per
-00019950: 6d69 7474 6976 6974 7944 6174 612c 0a20  mittivityData,. 
-00019960: 2020 204d 6f64 6553 6f6c 7665 7244 6174     ModeSolverDat
-00019970: 612c 0a20 2020 204d 6f64 6544 6174 612c  a,.    ModeData,
-00019980: 0a20 2020 2046 6c75 7844 6174 612c 0a20  .    FluxData,. 
-00019990: 2020 2046 6c75 7854 696d 6544 6174 612c     FluxTimeData,
-000199a0: 0a20 2020 2046 6965 6c64 5072 6f6a 6563  .    FieldProjec
-000199b0: 7469 6f6e 4b53 7061 6365 4461 7461 2c0a  tionKSpaceData,.
-000199c0: 2020 2020 4669 656c 6450 726f 6a65 6374      FieldProject
-000199d0: 696f 6e43 6172 7465 7369 616e 4461 7461  ionCartesianData
-000199e0: 2c0a 2020 2020 4669 656c 6450 726f 6a65  ,.    FieldProje
-000199f0: 6374 696f 6e41 6e67 6c65 4461 7461 2c0a  ctionAngleData,.
-00019a00: 2020 2020 4469 6666 7261 6374 696f 6e44      DiffractionD
-00019a10: 6174 612c 0a29 0a0a 4d6f 6e69 746f 7244  ata,.)..MonitorD
-00019a20: 6174 6154 7970 6520 3d20 556e 696f 6e5b  ataType = Union[
-00019a30: 4d6f 6e69 746f 7244 6174 6154 7970 6573  MonitorDataTypes
-00019a40: 5d0a                                     ].
+0000da30: 2020 2020 2e2e 2e2c 2066 7265 715f 6964      ..., freq_id
+0000da40: 2c20 736f 7274 696e 675b 6672 6571 5f69  , sorting[freq_i
+0000da50: 642c 203a 5d0a 2020 2020 2020 2020 2020  d, :].          
+0000da60: 2020 2020 2020 5d0a 0a20 2020 2020 2020        ]..       
+0000da70: 2020 2020 2023 2041 7070 6c79 2070 6861       # Apply pha
+0000da80: 7365 2073 6869 6674 0a20 2020 2020 2020  se shift.       
+0000da90: 2020 2020 2070 6861 7365 5f66 6163 7420       phase_fact 
+0000daa0: 3d20 6e70 2e65 7870 282d 316a 202a 2070  = np.exp(-1j * p
+0000dab0: 6861 7365 5b4e 6f6e 652c 204e 6f6e 652c  hase[None, None,
+0000dac0: 204e 6f6e 652c 203a 2c20 3a5d 292e 6173   None, :, :]).as
+0000dad0: 7479 7065 2866 6965 6c64 5f73 6f72 7465  type(field_sorte
+0000dae0: 642e 6461 7461 2e64 7479 7065 290a 2020  d.data.dtype).  
+0000daf0: 2020 2020 2020 2020 2020 6669 656c 645f            field_
+0000db00: 736f 7274 6564 2e64 6174 6120 3d20 6669  sorted.data = fi
+0000db10: 656c 645f 736f 7274 6564 2e64 6174 6120  eld_sorted.data 
+0000db20: 2a20 7068 6173 655f 6661 6374 0a0a 2020  * phase_fact..  
+0000db30: 2020 2020 2020 2020 2020 7570 6461 7465            update
+0000db40: 5f64 6963 745b 6669 656c 645f 6e61 6d65  _dict[field_name
+0000db50: 5d20 3d20 6669 656c 645f 736f 7274 6564  ] = field_sorted
+0000db60: 0a0a 2020 2020 2020 2020 2320 5265 6172  ..        # Rear
+0000db70: 7261 6e67 6520 6461 7461 206f 7665 7220  range data over 
+0000db80: 6620 616e 6420 6d6f 6465 5f69 6e64 6578  f and mode_index
+0000db90: 0a20 2020 2020 2020 2064 6174 615f 6469  .        data_di
+0000dba0: 6374 203d 2064 6963 7428 2a2a 7365 6c66  ct = dict(**self
+0000dbb0: 2e5f 6772 6964 5f63 6f72 7265 6374 696f  ._grid_correctio
+0000dbc0: 6e5f 6469 6374 2c20 6e5f 636f 6d70 6c65  n_dict, n_comple
+0000dbd0: 783d 7365 6c66 2e6e 5f63 6f6d 706c 6578  x=self.n_complex
+0000dbe0: 290a 2020 2020 2020 2020 666f 7220 6b65  ).        for ke
+0000dbf0: 792c 2064 6174 6120 696e 2064 6174 615f  y, data in data_
+0000dc00: 6469 6374 2e69 7465 6d73 2829 3a0a 2020  dict.items():.  
+0000dc10: 2020 2020 2020 2020 2020 7570 6461 7465            update
+0000dc20: 5f64 6963 745b 6b65 795d 203d 2064 6174  _dict[key] = dat
+0000dc30: 612e 636f 7079 2829 0a20 2020 2020 2020  a.copy().       
+0000dc40: 2020 2020 2066 6f72 2066 7265 715f 6964       for freq_id
+0000dc50: 2069 6e20 7261 6e67 6528 6e75 6d5f 6672   in range(num_fr
+0000dc60: 6571 7329 3a0a 2020 2020 2020 2020 2020  eqs):.          
+0000dc70: 2020 2020 2020 7570 6461 7465 5f64 6963        update_dic
+0000dc80: 745b 6b65 795d 2e64 6174 615b 6672 6571  t[key].data[freq
+0000dc90: 5f69 642c 203a 5d20 3d20 7570 6461 7465  _id, :] = update
+0000dca0: 5f64 6963 745b 6b65 795d 2e64 6174 615b  _dict[key].data[
+0000dcb0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000dcc0: 2020 2020 2066 7265 715f 6964 2c20 736f       freq_id, so
+0000dcd0: 7274 696e 675b 6672 6571 5f69 642c 203a  rting[freq_id, :
+0000dce0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+0000dcf0: 2020 5d0a 0a20 2020 2020 2020 2023 2055    ]..        # U
+0000dd00: 7064 6174 6520 6d6f 6465 5f73 7065 6320  pdate mode_spec 
+0000dd10: 696e 2074 6865 206d 6f6e 6974 6f72 0a20  in the monitor. 
+0000dd20: 2020 2020 2020 206d 6f64 655f 7370 6563         mode_spec
+0000dd30: 203d 2073 656c 662e 6d6f 6e69 746f 722e   = self.monitor.
+0000dd40: 6d6f 6465 5f73 7065 632e 636f 7079 2875  mode_spec.copy(u
+0000dd50: 7064 6174 653d 6469 6374 2874 7261 636b  pdate=dict(track
+0000dd60: 5f66 7265 713d 7472 6163 6b5f 6672 6571  _freq=track_freq
+0000dd70: 2929 0a20 2020 2020 2020 2075 7064 6174  )).        updat
+0000dd80: 655f 6469 6374 5b22 6d6f 6e69 746f 7222  e_dict["monitor"
+0000dd90: 5d20 3d20 7365 6c66 2e6d 6f6e 6974 6f72  ] = self.monitor
+0000dda0: 2e63 6f70 7928 7570 6461 7465 3d64 6963  .copy(update=dic
+0000ddb0: 7428 6d6f 6465 5f73 7065 633d 6d6f 6465  t(mode_spec=mode
+0000ddc0: 5f73 7065 6329 290a 0a20 2020 2020 2020  _spec))..       
+0000ddd0: 2072 6574 7572 6e20 7365 6c66 2e63 6f70   return self.cop
+0000dde0: 7928 7570 6461 7465 3d75 7064 6174 655f  y(update=update_
+0000ddf0: 6469 6374 290a 0a20 2020 2064 6566 205f  dict)..    def _
+0000de00: 6772 6f75 705f 696e 6465 785f 706f 7374  group_index_post
+0000de10: 5f70 726f 6365 7373 2873 656c 662c 2066  _process(self, f
+0000de20: 7265 7175 656e 6379 5f73 7465 703a 2066  requency_step: f
+0000de30: 6c6f 6174 2920 2d3e 204d 6f64 6544 6174  loat) -> ModeDat
+0000de40: 613a 0a20 2020 2020 2020 2022 2222 4361  a:.        """Ca
+0000de50: 6c63 756c 6174 6520 6772 6f75 7020 696e  lculate group in
+0000de60: 6465 7820 616e 6420 7265 6d6f 7665 2061  dex and remove a
+0000de70: 6464 6564 2066 7265 7175 656e 6369 6573  dded frequencies
+0000de80: 2075 7365 6420 6f6e 6c79 2066 6f72 2074   used only for t
+0000de90: 6869 7320 6361 6c63 756c 6174 696f 6e2e  his calculation.
+0000dea0: 0a0a 2020 2020 2020 2020 5061 7261 6d65  ..        Parame
+0000deb0: 7465 7273 0a20 2020 2020 2020 202d 2d2d  ters.        ---
+0000dec0: 2d2d 2d2d 2d2d 2d0a 2020 2020 2020 2020  -------.        
+0000ded0: 6672 6571 7565 6e63 795f 7374 6570 3a20  frequency_step: 
+0000dee0: 666c 6f61 740a 2020 2020 2020 2020 2020  float.          
+0000def0: 2020 4672 6163 7469 6f6e 616c 2066 7265    Fractional fre
+0000df00: 7175 656e 6379 2073 7465 7020 7573 6564  quency step used
+0000df10: 2074 6f20 6361 6c63 756c 6174 6520 7468   to calculate th
+0000df20: 6520 6772 6f75 7020 696e 6465 782e 0a0a  e group index...
+0000df30: 2020 2020 2020 2020 5265 7475 726e 730a          Returns.
+0000df40: 2020 2020 2020 2020 2d2d 2d2d 2d2d 2d0a          -------.
+0000df50: 2020 2020 2020 2020 3a63 6c61 7373 3a60          :class:`
+0000df60: 2e4d 6f64 6544 6174 6160 0a20 2020 2020  .ModeData`.     
+0000df70: 2020 2020 2020 2046 696c 7465 7265 6420         Filtered 
+0000df80: 6461 7461 2077 6974 6820 6361 6c63 756c  data with calcul
+0000df90: 6174 6564 2067 726f 7570 2069 6e64 6578  ated group index
+0000dfa0: 2e0a 2020 2020 2020 2020 2222 220a 0a20  ..        """.. 
+0000dfb0: 2020 2020 2020 2066 7265 7173 203d 2073         freqs = s
+0000dfc0: 656c 662e 6e5f 636f 6d70 6c65 782e 636f  elf.n_complex.co
+0000dfd0: 6f72 6473 5b22 6622 5d2e 7661 6c75 6573  ords["f"].values
+0000dfe0: 0a20 2020 2020 2020 206e 756d 5f66 7265  .        num_fre
+0000dff0: 7173 203d 2066 7265 7173 2e73 697a 650a  qs = freqs.size.
+0000e000: 2020 2020 2020 2020 6261 636b 203d 2073          back = s
+0000e010: 6c69 6365 2830 2c20 6e75 6d5f 6672 6571  lice(0, num_freq
+0000e020: 732c 2033 290a 2020 2020 2020 2020 6365  s, 3).        ce
+0000e030: 6e74 6572 203d 2073 6c69 6365 2831 2c20  nter = slice(1, 
+0000e040: 6e75 6d5f 6672 6571 732c 2033 290a 2020  num_freqs, 3).  
+0000e050: 2020 2020 2020 6677 6420 3d20 736c 6963        fwd = slic
+0000e060: 6528 322c 206e 756d 5f66 7265 7173 2c20  e(2, num_freqs, 
+0000e070: 3329 0a20 2020 2020 2020 2066 7265 7173  3).        freqs
+0000e080: 203d 2066 7265 7173 5b63 656e 7465 725d   = freqs[center]
+0000e090: 0a0a 2020 2020 2020 2020 2320 6361 6c63  ..        # calc
+0000e0a0: 756c 6174 6520 6772 6f75 7020 696e 6465  ulate group inde
+0000e0b0: 780a 2020 2020 2020 2020 6e5f 6365 6e74  x.        n_cent
+0000e0c0: 6572 203d 2073 656c 662e 6e5f 6566 662e  er = self.n_eff.
+0000e0d0: 6973 656c 2866 3d63 656e 7465 7229 2e76  isel(f=center).v
+0000e0e0: 616c 7565 730a 2020 2020 2020 2020 6e5f  alues.        n_
+0000e0f0: 6261 636b 7761 7264 203d 2073 656c 662e  backward = self.
+0000e100: 6e5f 6566 662e 6973 656c 2866 3d62 6163  n_eff.isel(f=bac
+0000e110: 6b29 2e76 616c 7565 730a 2020 2020 2020  k).values.      
+0000e120: 2020 6e5f 666f 7277 6172 6420 3d20 7365    n_forward = se
+0000e130: 6c66 2e6e 5f65 6666 2e69 7365 6c28 663d  lf.n_eff.isel(f=
+0000e140: 6677 6429 2e76 616c 7565 730a 0a20 2020  fwd).values..   
+0000e150: 2020 2020 2069 6e76 5f73 7465 7020 3d20       inv_step = 
+0000e160: 3120 2f20 6672 6571 7565 6e63 795f 7374  1 / frequency_st
+0000e170: 6570 0a20 2020 2020 2020 2023 206e 5f67  ep.        # n_g
+0000e180: 203d 206e 202b 2066 202a 2064 662f 646e   = n + f * df/dn
+0000e190: 0a20 2020 2020 2020 2023 2064 6e2f 6466  .        # dn/df
+0000e1a0: 203d 2028 6e2b 202d 206e 2d29 202f 2028   = (n+ - n-) / (
+0000e1b0: 3220 6620 6466 290a 2020 2020 2020 2020  2 f df).        
+0000e1c0: 6e5f 6772 6f75 705f 6461 7461 203d 206e  n_group_data = n
+0000e1d0: 5f63 656e 7465 7220 2b20 286e 5f66 6f72  _center + (n_for
+0000e1e0: 7761 7264 202d 206e 5f62 6163 6b77 6172  ward - n_backwar
+0000e1f0: 6429 202a 2069 6e76 5f73 7465 7020 2a20  d) * inv_step * 
+0000e200: 302e 350a 2020 2020 2020 2020 2320 4420  0.5.        # D 
+0000e210: 3d20 2d32 202a 2070 6920 2a20 6320 2f20  = -2 * pi * c / 
+0000e220: 6c64 615e 3220 2a20 6428 765f 675e 2d31  lda^2 * d(v_g^-1
+0000e230: 292f 6477 203d 202d 2866 202f 2063 295e  )/dw = -(f / c)^
+0000e240: 3220 2a20 2832 202a 2064 6e2f 6466 202b  2 * (2 * dn/df +
+0000e250: 2066 202a 2064 326e 2f64 6632 290a 2020   f * d2n/df2).  
+0000e260: 2020 2020 2020 2320 6432 6e2f 6466 3220        # d2n/df2 
+0000e270: 3d20 286e 2b20 2d20 326e 202b 206e 2d29  = (n+ - 2n + n-)
+0000e280: 202f 2028 6620 6466 295e 320a 2020 2020   / (f df)^2.    
+0000e290: 2020 2020 2320 5468 6520 2731 6531 3827      # The '1e18'
+0000e2a0: 2066 6163 746f 7220 636f 6e76 6572 7473   factor converts
+0000e2b0: 2066 726f 6d20 732f 756d 5e32 2074 6f20   from s/um^2 to 
+0000e2c0: 7073 2f28 6e6d 206b 6d29 0a20 2020 2020  ps/(nm km).     
+0000e2d0: 2020 2064 6973 7065 7273 696f 6e5f 6461     dispersion_da
+0000e2e0: 7461 203d 2028 0a20 2020 2020 2020 2020  ta = (.         
+0000e2f0: 2020 2028 6e5f 666f 7277 6172 6420 2a20     (n_forward * 
+0000e300: 2869 6e76 5f73 7465 7020 2b20 3129 202b  (inv_step + 1) +
+0000e310: 206e 5f62 6163 6b77 6172 6420 2a20 2869   n_backward * (i
+0000e320: 6e76 5f73 7465 7020 2d20 3129 202d 206e  nv_step - 1) - n
+0000e330: 5f63 656e 7465 7220 2a20 696e 765f 7374  _center * inv_st
+0000e340: 6570 202a 2032 290a 2020 2020 2020 2020  ep * 2).        
+0000e350: 2020 2020 2a20 6672 6571 732e 7265 7368      * freqs.resh
+0000e360: 6170 6528 282d 312c 2031 2929 0a20 2020  ape((-1, 1)).   
+0000e370: 2020 2020 2020 2020 202a 2028 2d31 6531           * (-1e1
+0000e380: 3820 2a20 696e 765f 7374 6570 202f 2043  8 * inv_step / C
+0000e390: 5f30 2a2a 3229 0a20 2020 2020 2020 2029  _0**2).        )
+0000e3a0: 0a0a 2020 2020 2020 2020 6d6f 6465 5f69  ..        mode_i
+0000e3b0: 6e64 6578 203d 206c 6973 7428 7365 6c66  ndex = list(self
+0000e3c0: 2e6e 5f63 6f6d 706c 6578 2e63 6f6f 7264  .n_complex.coord
+0000e3d0: 735b 226d 6f64 655f 696e 6465 7822 5d2e  s["mode_index"].
+0000e3e0: 7661 6c75 6573 290a 2020 2020 2020 2020  values).        
+0000e3f0: 6620 3d20 6c69 7374 2866 7265 7173 290a  f = list(freqs).
+0000e400: 2020 2020 2020 2020 6e5f 6772 6f75 7020          n_group 
+0000e410: 3d20 4772 6f75 7049 6e64 6578 4461 7461  = GroupIndexData
+0000e420: 4172 7261 7928 0a20 2020 2020 2020 2020  Array(.         
+0000e430: 2020 206e 5f67 726f 7570 5f64 6174 612c     n_group_data,
+0000e440: 0a20 2020 2020 2020 2020 2020 2063 6f6f  .            coo
+0000e450: 7264 733d 7b22 6622 3a20 662c 2022 6d6f  rds={"f": f, "mo
+0000e460: 6465 5f69 6e64 6578 223a 206d 6f64 655f  de_index": mode_
+0000e470: 696e 6465 787d 2c0a 2020 2020 2020 2020  index},.        
+0000e480: 290a 0a20 2020 2020 2020 2064 6973 7065  )..        dispe
+0000e490: 7273 696f 6e20 3d20 4d6f 6465 4469 7370  rsion = ModeDisp
+0000e4a0: 6572 7369 6f6e 4461 7461 4172 7261 7928  ersionDataArray(
+0000e4b0: 0a20 2020 2020 2020 2020 2020 2064 6973  .            dis
+0000e4c0: 7065 7273 696f 6e5f 6461 7461 2c0a 2020  persion_data,.  
+0000e4d0: 2020 2020 2020 2020 2020 636f 6f72 6473            coords
+0000e4e0: 3d7b 2266 223a 2066 2c20 226d 6f64 655f  ={"f": f, "mode_
+0000e4f0: 696e 6465 7822 3a20 6d6f 6465 5f69 6e64  index": mode_ind
+0000e500: 6578 7d2c 0a20 2020 2020 2020 2029 0a0a  ex},.        )..
+0000e510: 2020 2020 2020 2020 2320 7265 6d6f 7665          # remove
+0000e520: 2064 6174 6120 636f 7272 6573 706f 6e64   data correspond
+0000e530: 696e 6720 746f 2066 7265 7175 656e 6369  ing to frequenci
+0000e540: 6573 2075 7365 6420 6f6e 6c79 2066 6f72  es used only for
+0000e550: 2067 726f 7570 2069 6e64 6578 2063 616c   group index cal
+0000e560: 6375 6c61 7469 6f6e 0a20 2020 2020 2020  culation.       
+0000e570: 2075 7064 6174 655f 6469 6374 203d 207b   update_dict = {
+0000e580: 0a20 2020 2020 2020 2020 2020 2022 6e5f  .            "n_
+0000e590: 636f 6d70 6c65 7822 3a20 7365 6c66 2e6e  complex": self.n
+0000e5a0: 5f63 6f6d 706c 6578 2e69 7365 6c28 663d  _complex.isel(f=
+0000e5b0: 6365 6e74 6572 292c 0a20 2020 2020 2020  center),.       
+0000e5c0: 2020 2020 2022 6e5f 6772 6f75 705f 7261       "n_group_ra
+0000e5d0: 7722 3a20 6e5f 6772 6f75 702c 0a20 2020  w": n_group,.   
+0000e5e0: 2020 2020 2020 2020 2022 6469 7370 6572           "disper
+0000e5f0: 7369 6f6e 5f72 6177 223a 2064 6973 7065  sion_raw": dispe
+0000e600: 7273 696f 6e2c 0a20 2020 2020 2020 207d  rsion,.        }
+0000e610: 0a0a 2020 2020 2020 2020 666f 7220 6b65  ..        for ke
+0000e620: 792c 2066 6965 6c64 2069 6e20 7365 6c66  y, field in self
+0000e630: 2e66 6965 6c64 5f63 6f6d 706f 6e65 6e74  .field_component
+0000e640: 732e 6974 656d 7328 293a 0a20 2020 2020  s.items():.     
+0000e650: 2020 2020 2020 2075 7064 6174 655f 6469         update_di
+0000e660: 6374 5b6b 6579 5d20 3d20 6669 656c 642e  ct[key] = field.
+0000e670: 6973 656c 2866 3d63 656e 7465 7229 0a0a  isel(f=center)..
+0000e680: 2020 2020 2020 2020 666f 7220 6b65 792c          for key,
+0000e690: 2064 6174 6120 696e 2073 656c 662e 5f67   data in self._g
+0000e6a0: 7269 645f 636f 7272 6563 7469 6f6e 5f64  rid_correction_d
+0000e6b0: 6963 742e 6974 656d 7328 293a 0a20 2020  ict.items():.   
+0000e6c0: 2020 2020 2020 2020 2075 7064 6174 655f           update_
+0000e6d0: 6469 6374 5b6b 6579 5d20 3d20 6461 7461  dict[key] = data
+0000e6e0: 2e69 7365 6c28 663d 6365 6e74 6572 290a  .isel(f=center).
+0000e6f0: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
+0000e700: 2e65 7073 5f73 7065 633a 0a20 2020 2020  .eps_spec:.     
+0000e710: 2020 2020 2020 2075 7064 6174 655f 6469         update_di
+0000e720: 6374 5b22 6570 735f 7370 6563 225d 203d  ct["eps_spec"] =
+0000e730: 2073 656c 662e 6570 735f 7370 6563 5b63   self.eps_spec[c
+0000e740: 656e 7465 725d 0a0a 2020 2020 2020 2020  enter]..        
+0000e750: 7570 6461 7465 5f64 6963 745b 226d 6f6e  update_dict["mon
+0000e760: 6974 6f72 225d 203d 2073 656c 662e 6d6f  itor"] = self.mo
+0000e770: 6e69 746f 722e 7570 6461 7465 645f 636f  nitor.updated_co
+0000e780: 7079 2866 7265 7173 3d66 7265 7173 290a  py(freqs=freqs).
+0000e790: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0000e7a0: 7365 6c66 2e63 6f70 7928 7570 6461 7465  self.copy(update
+0000e7b0: 3d75 7064 6174 655f 6469 6374 290a 0a20  =update_dict).. 
+0000e7c0: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
+0000e7d0: 2064 6566 2074 696d 655f 7265 7665 7273   def time_revers
+0000e7e0: 6564 5f63 6f70 7928 7365 6c66 2920 2d3e  ed_copy(self) ->
+0000e7f0: 2046 6965 6c64 4461 7461 3a0a 2020 2020   FieldData:.    
+0000e800: 2020 2020 2222 224d 616b 6520 6120 636f      """Make a co
+0000e810: 7079 206f 6620 7468 6520 6461 7461 2077  py of the data w
+0000e820: 6974 6820 6469 7265 6374 696f 6e2d 7265  ith direction-re
+0000e830: 7665 7273 6564 2066 6965 6c64 732e 2049  versed fields. I
+0000e840: 6e20 6c6f 7373 7920 6f72 2067 7972 6f74  n lossy or gyrot
+0000e850: 726f 7069 6320 7379 7374 656d 732c 0a20  ropic systems,. 
+0000e860: 2020 2020 2020 2074 6865 2074 696d 652d         the time-
+0000e870: 7265 7665 7273 6564 2066 6965 6c64 7320  reversed fields 
+0000e880: 7769 6c6c 206e 6f74 2062 6520 7468 6520  will not be the 
+0000e890: 7361 6d65 2061 7320 7468 6520 6261 636b  same as the back
+0000e8a0: 7761 7264 2d70 726f 7061 6761 7469 6e67  ward-propagating
+0000e8b0: 206d 6f64 6573 2e22 2222 0a0a 2020 2020   modes."""..    
+0000e8c0: 2020 2020 2320 5469 6d65 2072 6576 6572      # Time rever
+0000e8d0: 7361 6c0a 2020 2020 2020 2020 6e65 775f  sal.        new_
+0000e8e0: 6461 7461 203d 207b 7d0a 2020 2020 2020  data = {}.      
+0000e8f0: 2020 666f 7220 636f 6d70 2c20 6669 656c    for comp, fiel
+0000e900: 6420 696e 2073 656c 662e 6669 656c 645f  d in self.field_
+0000e910: 636f 6d70 6f6e 656e 7473 2e69 7465 6d73  components.items
+0000e920: 2829 3a0a 2020 2020 2020 2020 2020 2020  ():.            
+0000e930: 6966 2063 6f6d 705b 305d 203d 3d20 2248  if comp[0] == "H
+0000e940: 223a 0a20 2020 2020 2020 2020 2020 2020  ":.             
+0000e950: 2020 206e 6577 5f64 6174 615b 636f 6d70     new_data[comp
+0000e960: 5d20 3d20 2d6e 702e 636f 6e6a 2866 6965  ] = -np.conj(fie
+0000e970: 6c64 290a 2020 2020 2020 2020 2020 2020  ld).            
+0000e980: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+0000e990: 2020 2020 2020 6e65 775f 6461 7461 5b63        new_data[c
+0000e9a0: 6f6d 705d 203d 206e 702e 636f 6e6a 2866  omp] = np.conj(f
+0000e9b0: 6965 6c64 290a 0a20 2020 2020 2020 2023  ield)..        #
+0000e9c0: 2073 7769 7463 6820 6469 7265 6374 696f   switch directio
+0000e9d0: 6e20 696e 2074 6865 206d 6f6e 6974 6f72  n in the monitor
+0000e9e0: 0a20 2020 2020 2020 206d 6e74 203d 2073  .        mnt = s
+0000e9f0: 656c 662e 6d6f 6e69 746f 720a 2020 2020  elf.monitor.    
+0000ea00: 2020 2020 6e65 775f 6469 7220 3d20 222b      new_dir = "+
+0000ea10: 2220 6966 206d 6e74 2e73 746f 7265 5f66  " if mnt.store_f
+0000ea20: 6965 6c64 735f 6469 7265 6374 696f 6e20  ields_direction 
+0000ea30: 3d3d 2022 2d22 2065 6c73 6520 222d 220a  == "-" else "-".
+0000ea40: 2020 2020 2020 2020 6e65 775f 6461 7461          new_data
+0000ea50: 5b22 6d6f 6e69 746f 7222 5d20 3d20 6d6e  ["monitor"] = mn
+0000ea60: 742e 7570 6461 7465 645f 636f 7079 2873  t.updated_copy(s
+0000ea70: 746f 7265 5f66 6965 6c64 735f 6469 7265  tore_fields_dire
+0000ea80: 6374 696f 6e3d 6e65 775f 6469 7229 0a20  ction=new_dir). 
+0000ea90: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+0000eaa0: 6c66 2e63 6f70 7928 7570 6461 7465 3d6e  lf.copy(update=n
+0000eab0: 6577 5f64 6174 6129 0a0a 2020 2020 6465  ew_data)..    de
+0000eac0: 6620 5f63 6f6c 6f63 6174 6564 5f70 726f  f _colocated_pro
+0000ead0: 7061 6761 7469 6f6e 5f61 7865 735f 6669  pagation_axes_fi
+0000eae0: 656c 6428 7365 6c66 2c20 6669 656c 645f  eld(self, field_
+0000eaf0: 6e61 6d65 3a20 4c69 7465 7261 6c5b 2245  name: Literal["E
+0000eb00: 222c 2022 4822 5d29 202d 3e20 7872 2e44  ", "H"]) -> xr.D
+0000eb10: 6174 6141 7272 6179 3a0a 2020 2020 2020  ataArray:.      
+0000eb20: 2020 2222 2243 6f6c 6c65 6374 2061 2066    """Collect a f
+0000eb30: 6965 6c64 2044 6174 6141 7272 6179 2063  ield DataArray c
+0000eb40: 6f6e 7461 696e 696e 6720 616c 6c20 3320  ontaining all 3 
+0000eb50: 6669 656c 6420 636f 6d70 6f6e 656e 7473  field components
+0000eb60: 2061 6e64 2072 6f74 6174 6520 6672 6f6d   and rotate from
+0000eb70: 2066 7261 6d65 0a20 2020 2020 2020 2077   frame.        w
+0000eb80: 6974 6820 6e6f 726d 616c 2061 7869 7320  ith normal axis 
+0000eb90: 616c 6f6e 6720 7a20 746f 2066 7261 6d65  along z to frame
+0000eba0: 2077 6974 6820 7072 6f70 6167 6174 696f   with propagatio
+0000ebb0: 6e20 6178 6973 2061 6c6f 6e67 207a 2e0a  n axis along z..
+0000ebc0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+0000ebd0: 2020 2020 7461 6e5f 6469 6d73 203d 2073      tan_dims = s
+0000ebe0: 656c 662e 5f74 616e 6765 6e74 6961 6c5f  elf._tangential_
+0000ebf0: 6469 6d73 0a20 2020 2020 2020 206e 6f72  dims.        nor
+0000ec00: 6d61 6c5f 6469 6d20 3d20 2278 797a 225b  mal_dim = "xyz"[
+0000ec10: 7365 6c66 2e6d 6f6e 6974 6f72 2e7a 6572  self.monitor.zer
+0000ec20: 6f5f 6469 6d73 5b30 5d5d 0a20 2020 2020  o_dims[0]].     
+0000ec30: 2020 2066 6965 6c64 7320 3d20 7365 6c66     fields = self
+0000ec40: 2e5f 636f 6c6f 6361 7465 645f 6669 656c  ._colocated_fiel
+0000ec50: 6473 0a20 2020 2020 2020 2066 6965 6c64  ds.        field
+0000ec60: 7320 3d20 7b6b 6579 3a20 7661 6c2e 7371  s = {key: val.sq
+0000ec70: 7565 657a 6528 6469 6d3d 6e6f 726d 616c  ueeze(dim=normal
+0000ec80: 5f64 696d 2c20 6472 6f70 3d54 7275 6529  _dim, drop=True)
+0000ec90: 2066 6f72 206b 6579 2c20 7661 6c20 696e   for key, val in
+0000eca0: 2066 6965 6c64 732e 6974 656d 7328 297d   fields.items()}
+0000ecb0: 0a20 2020 2020 2020 206d 6f64 655f 7370  .        mode_sp
+0000ecc0: 6563 203d 2073 656c 662e 6d6f 6e69 746f  ec = self.monito
+0000ecd0: 722e 6d6f 6465 5f73 7065 630a 0a20 2020  r.mode_spec..   
+0000ece0: 2020 2020 2023 2066 6965 6c64 7320 6173       # fields as
+0000ecf0: 2061 2028 332c 202e 2e2e 2920 6e75 6d70   a (3, ...) nump
+0000ed00: 7920 6172 7261 7920 6f72 6465 7265 6420  y array ordered 
+0000ed10: 6173 205b 7461 6e67 656e 7469 616c 312c  as [tangential1,
+0000ed20: 2074 6167 656e 7469 616c 322c 206e 6f72   tagential2, nor
+0000ed30: 6d61 6c5d 0a20 2020 2020 2020 2066 6965  mal].        fie
+0000ed40: 6c64 203d 205b 6669 656c 6473 5b66 6965  ld = [fields[fie
+0000ed50: 6c64 5f6e 616d 6520 2b20 6469 6d5d 2e76  ld_name + dim].v
+0000ed60: 616c 7565 7320 666f 7220 6469 6d20 696e  alues for dim in
+0000ed70: 2074 616e 5f64 696d 735d 0a20 2020 2020   tan_dims].     
+0000ed80: 2020 2066 6965 6c64 203d 206e 702e 6172     field = np.ar
+0000ed90: 7261 7928 6669 656c 6420 2b20 5b66 6965  ray(field + [fie
+0000eda0: 6c64 735b 6669 656c 645f 6e61 6d65 202b  lds[field_name +
+0000edb0: 206e 6f72 6d61 6c5f 6469 6d5d 2e76 616c   normal_dim].val
+0000edc0: 7565 735d 290a 0a20 2020 2020 2020 2023  ues])..        #
+0000edd0: 2072 6f74 6174 6520 6178 6573 0a20 2020   rotate axes.   
+0000ede0: 2020 2020 2069 6620 6d6f 6465 5f73 7065       if mode_spe
+0000edf0: 632e 616e 676c 655f 7068 6920 213d 2030  c.angle_phi != 0
+0000ee00: 3a0a 2020 2020 2020 2020 2020 2020 6669  :.            fi
+0000ee10: 656c 6420 3d20 7365 6c66 2e6d 6f6e 6974  eld = self.monit
+0000ee20: 6f72 2e72 6f74 6174 655f 706f 696e 7473  or.rotate_points
+0000ee30: 2866 6965 6c64 2c20 5b30 2c20 302c 2031  (field, [0, 0, 1
+0000ee40: 5d2c 202d 6d6f 6465 5f73 7065 632e 616e  ], -mode_spec.an
+0000ee50: 676c 655f 7068 6929 0a20 2020 2020 2020  gle_phi).       
+0000ee60: 2069 6620 6d6f 6465 5f73 7065 632e 616e   if mode_spec.an
+0000ee70: 676c 655f 7468 6574 6120 213d 2030 3a0a  gle_theta != 0:.
+0000ee80: 2020 2020 2020 2020 2020 2020 6669 656c              fiel
+0000ee90: 6420 3d20 7365 6c66 2e6d 6f6e 6974 6f72  d = self.monitor
+0000eea0: 2e72 6f74 6174 655f 706f 696e 7473 2866  .rotate_points(f
+0000eeb0: 6965 6c64 2c20 5b30 2c20 312c 2030 5d2c  ield, [0, 1, 0],
+0000eec0: 202d 6d6f 6465 5f73 7065 632e 616e 676c   -mode_spec.angl
+0000eed0: 655f 7468 6574 6129 0a0a 2020 2020 2020  e_theta)..      
+0000eee0: 2020 2320 6e65 7720 636f 6f72 6473 2066    # new coords f
+0000eef0: 6f72 2074 6865 2028 332c 202e 2e2e 2920  or the (3, ...) 
+0000ef00: 6172 7261 790a 2020 2020 2020 2020 636f  array.        co
+0000ef10: 6f72 6473 203d 207b 2263 6f6d 706f 6e65  ords = {"compone
+0000ef20: 6e74 223a 205b 302c 2031 2c20 325d 7d0a  nt": [0, 1, 2]}.
+0000ef30: 2020 2020 2020 2020 2320 6669 656c 6473          # fields
+0000ef40: 2061 7265 2063 6f6c 6f63 6174 6564 2c20   are colocated, 
+0000ef50: 736f 2061 6c6c 2063 6f6d 706f 6e65 6e74  so all component
+0000ef60: 7320 7368 6f75 6c64 2068 6176 6520 7468  s should have th
+0000ef70: 6520 7361 6d65 2063 6f6f 7264 730a 2020  e same coords.  
+0000ef80: 2020 2020 2020 666f 7220 6469 6d20 696e        for dim in
+0000ef90: 2066 6965 6c64 735b 2245 7822 5d2e 6469   fields["Ex"].di
+0000efa0: 6d73 3a0a 2020 2020 2020 2020 2020 2020  ms:.            
+0000efb0: 636f 6f72 6473 2e75 7064 6174 6528 7b64  coords.update({d
+0000efc0: 696d 3a20 6669 656c 6473 5b22 4578 225d  im: fields["Ex"]
+0000efd0: 2e63 6f6f 7264 735b 6469 6d5d 7d29 0a0a  .coords[dim]})..
+0000efe0: 2020 2020 2020 2020 7265 7475 726e 2078          return x
+0000eff0: 722e 4461 7461 4172 7261 7928 6461 7461  r.DataArray(data
+0000f000: 3d66 6965 6c64 2c20 636f 6f72 6473 3d63  =field, coords=c
+0000f010: 6f6f 7264 7329 0a0a 2020 2020 4063 6163  oords)..    @cac
+0000f020: 6865 645f 7072 6f70 6572 7479 0a20 2020  hed_property.   
+0000f030: 2064 6566 2070 6f6c 5f66 7261 6374 696f   def pol_fractio
+0000f040: 6e28 7365 6c66 2920 2d3e 2078 722e 4461  n(self) -> xr.Da
+0000f050: 7461 7365 743a 0a20 2020 2020 2020 2072  taset:.        r
+0000f060: 2222 2243 6f6d 7075 7465 2074 6865 2054  """Compute the T
+0000f070: 4520 616e 6420 544d 2070 6f6c 6172 697a  E and TM polariz
+0000f080: 6174 696f 6e20 6672 6163 7469 6f6e 2064  ation fraction d
+0000f090: 6566 696e 6564 2061 7320 7468 6520 6669  efined as the fi
+0000f0a0: 656c 6420 696e 7465 6e73 6974 7920 616c  eld intensity al
+0000f0b0: 6f6e 6720 7468 650a 2020 2020 2020 2020  ong the.        
+0000f0c0: 6669 7273 7420 6f72 2074 6865 2073 6563  first or the sec
+0000f0d0: 6f6e 6420 6f66 2074 6865 2074 776f 2074  ond of the two t
+0000f0e0: 616e 6765 6e74 6961 6c20 6178 6573 2e20  angential axes. 
+0000f0f0: 4d6f 7265 2070 7265 6369 7365 6c79 2c20  More precisely, 
+0000f100: 6966 2024 455f 3124 2061 6e64 2024 455f  if $E_1$ and $E_
+0000f110: 3224 2061 7265 0a20 2020 2020 2020 2074  2$ are.        t
+0000f120: 6865 2065 6c65 6374 7269 6320 6669 656c  he electric fiel
+0000f130: 6420 636f 6d70 6f6e 656e 7473 2061 6c6f  d components alo
+0000f140: 6e67 2074 6865 2074 776f 2074 616e 6765  ng the two tange
+0000f150: 6e74 6961 6c20 6178 6573 2c20 7468 6520  ntial axes, the 
+0000f160: 5445 2066 7261 6374 696f 6e20 6973 2064  TE fraction is d
+0000f170: 6566 696e 6564 2061 733a 0a0a 2020 2020  efined as:..    
+0000f180: 2020 2020 2e2e 206d 6174 683a 3a0a 0a20      .. math::.. 
+0000f190: 2020 2020 2020 2020 2020 5c66 7261 637b            \frac{
+0000f1a0: 5c69 6e74 207c 455f 317c 5e32 205c 2c20  \int |E_1|^2 \, 
+0000f1b0: 7b5c 726d 2064 7d53 7d7b 5c69 6e74 205c  {\rm d}S}{\int \
+0000f1c0: 6c65 6674 287c 455f 317c 5e32 202b 207c  left(|E_1|^2 + |
+0000f1d0: 455f 327c 5e32 5c72 6967 6874 2920 5c2c  E_2|^2\right) \,
+0000f1e0: 207b 5c72 6d20 647d 537d 0a0a 2020 2020   {\rm d}S}..    
+0000f1f0: 2020 2020 616e 6420 7468 6520 544d 2066      and the TM f
+0000f200: 7261 6374 696f 6e20 6973 2065 7175 616c  raction is equal
+0000f210: 2074 6f20 6f6e 6520 6d69 6e75 7320 7468   to one minus th
+0000f220: 6520 5445 2066 7261 6374 696f 6e2e 2054  e TE fraction. T
+0000f230: 6865 2074 616e 6765 6e74 6961 6c20 6178  he tangential ax
+0000f240: 6573 2061 7265 2064 6566 696e 6564 0a20  es are defined. 
+0000f250: 2020 2020 2020 2062 7920 706f 7070 696e         by poppin
+0000f260: 6720 7468 6520 6e6f 726d 616c 2061 7869  g the normal axi
+0000f270: 7320 6672 6f6d 2074 6865 206c 6973 7420  s from the list 
+0000f280: 6f66 2060 6078 2c20 792c 207a 6060 2c20  of ``x, y, z``, 
+0000f290: 736f 2065 2e67 2e20 6060 7860 6020 616e  so e.g. ``x`` an
+0000f2a0: 6420 6060 7a60 6020 666f 720a 2020 2020  d ``z`` for.    
+0000f2b0: 2020 2020 7072 6f70 6167 6174 696f 6e20      propagation 
+0000f2c0: 696e 2074 6865 2060 6079 6060 2064 6972  in the ``y`` dir
+0000f2d0: 6563 7469 6f6e 2e0a 2020 2020 2020 2020  ection..        
+0000f2e0: 2222 220a 2020 2020 2020 2020 6966 206c  """.        if l
+0000f2f0: 656e 2873 656c 662e 6669 656c 645f 636f  en(self.field_co
+0000f300: 6d70 6f6e 656e 7473 2920 3d3d 2030 3a0a  mponents) == 0:.
+0000f310: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+0000f320: 6520 4461 7461 4572 726f 7228 0a20 2020  e DataError(.   
+0000f330: 2020 2020 2020 2020 2020 2020 2022 4669               "Fi
+0000f340: 656c 6420 6461 7461 206e 6f74 2069 6e63  eld data not inc
+0000f350: 6c75 6465 6420 696e 2074 6869 7320 4d6f  luded in this Mo
+0000f360: 6465 4461 7461 206f 6e62 6a65 6374 2e20  deData onbject. 
+0000f370: 5365 7420 220a 2020 2020 2020 2020 2020  Set ".          
+0000f380: 2020 2020 2020 2227 4d6f 6465 4d6f 6e69        "'ModeMoni
+0000f390: 746f 722e 7374 6f72 655f 6669 656c 6473  tor.store_fields
+0000f3a0: 5f64 6972 6563 7469 6f6e 2720 746f 2074  _direction' to t
+0000f3b0: 6865 2064 6573 6972 6564 2070 726f 7061  he desired propa
+0000f3c0: 6761 7469 6f6e 2064 6972 6563 7469 6f6e  gation direction
+0000f3d0: 2074 6f20 220a 2020 2020 2020 2020 2020   to ".          
+0000f3e0: 2020 2020 2020 2269 6e63 6c75 6465 2074        "include t
+0000f3f0: 6865 206d 6f64 6520 6669 656c 6420 7072  he mode field pr
+0000f400: 6f66 696c 6573 2069 6e20 7468 6520 636f  ofiles in the co
+0000f410: 7272 6573 706f 6e64 696e 6720 274d 6f64  rresponding 'Mod
+0000f420: 6544 6174 6127 2e22 0a20 2020 2020 2020  eData'.".       
+0000f430: 2020 2020 2029 0a0a 2020 2020 2020 2020       )..        
+0000f440: 7461 6e5f 6469 6d73 203d 2073 656c 662e  tan_dims = self.
+0000f450: 5f74 616e 6765 6e74 6961 6c5f 6469 6d73  _tangential_dims
+0000f460: 0a20 2020 2020 2020 2065 5f66 6965 6c64  .        e_field
+0000f470: 203d 2073 656c 662e 5f63 6f6c 6f63 6174   = self._colocat
+0000f480: 6564 5f70 726f 7061 6761 7469 6f6e 5f61  ed_propagation_a
+0000f490: 7865 735f 6669 656c 6428 2245 2229 0a20  xes_field("E"). 
+0000f4a0: 2020 2020 2020 2064 6966 665f 6172 6561         diff_area
+0000f4b0: 203d 2073 656c 662e 5f64 6966 665f 6172   = self._diff_ar
+0000f4c0: 6561 0a20 2020 2020 2020 2074 6d5f 696e  ea.        tm_in
+0000f4d0: 7420 3d20 2864 6966 665f 6172 6561 202a  t = (diff_area *
+0000f4e0: 206e 702e 6162 7328 655f 6669 656c 642e   np.abs(e_field.
+0000f4f0: 7365 6c28 636f 6d70 6f6e 656e 743d 312c  sel(component=1,
+0000f500: 2064 726f 703d 5472 7565 2929 202a 2a20   drop=True)) ** 
+0000f510: 3229 2e73 756d 2864 696d 3d74 616e 5f64  2).sum(dim=tan_d
+0000f520: 696d 7329 0a20 2020 2020 2020 2074 655f  ims).        te_
+0000f530: 696e 7420 3d20 2864 6966 665f 6172 6561  int = (diff_area
+0000f540: 202a 206e 702e 6162 7328 655f 6669 656c   * np.abs(e_fiel
+0000f550: 642e 7365 6c28 636f 6d70 6f6e 656e 743d  d.sel(component=
+0000f560: 302c 2064 726f 703d 5472 7565 2929 202a  0, drop=True)) *
+0000f570: 2a20 3229 2e73 756d 2864 696d 3d74 616e  * 2).sum(dim=tan
+0000f580: 5f64 696d 7329 0a20 2020 2020 2020 2074  _dims).        t
+0000f590: 655f 6672 6163 203d 2074 655f 696e 7420  e_frac = te_int 
+0000f5a0: 2f20 2874 655f 696e 7420 2b20 746d 5f69  / (te_int + tm_i
+0000f5b0: 6e74 290a 0a20 2020 2020 2020 2072 6574  nt)..        ret
+0000f5c0: 7572 6e20 7872 2e44 6174 6173 6574 2864  urn xr.Dataset(d
+0000f5d0: 6174 615f 7661 7273 3d7b 2274 6522 3a20  ata_vars={"te": 
+0000f5e0: 7465 5f66 7261 632c 2022 746d 223a 2031  te_frac, "tm": 1
+0000f5f0: 202d 2074 655f 6672 6163 7d29 0a0a 2020   - te_frac})..  
+0000f600: 2020 4063 6163 6865 645f 7072 6f70 6572    @cached_proper
+0000f610: 7479 0a20 2020 2064 6566 2070 6f6c 5f66  ty.    def pol_f
+0000f620: 7261 6374 696f 6e5f 7761 7665 6775 6964  raction_waveguid
+0000f630: 6528 7365 6c66 2920 2d3e 2078 722e 4461  e(self) -> xr.Da
+0000f640: 7461 7365 743a 0a20 2020 2020 2020 2072  taset:.        r
+0000f650: 2222 2243 6f6d 7075 7465 2074 6865 2054  """Compute the T
+0000f660: 4520 616e 6420 544d 2070 6f6c 6172 697a  E and TM polariz
+0000f670: 6174 696f 6e20 6672 6163 7469 6f6e 2075  ation fraction u
+0000f680: 7369 6e67 2074 6865 2077 6176 6567 7569  sing the wavegui
+0000f690: 6465 2064 6566 696e 6974 696f 6e2e 2049  de definition. I
+0000f6a0: 6620 246e 2420 6973 0a20 2020 2020 2020  f $n$ is.       
+0000f6b0: 2074 6865 2070 726f 7061 6761 7469 6f6e   the propagation
+0000f6c0: 2064 6972 6563 7469 6f6e 2c20 7468 6520   direction, the 
+0000f6d0: 5445 2066 7261 6374 696f 6e20 6973 2064  TE fraction is d
+0000f6e0: 6566 696e 6564 2061 733a 0a0a 2020 2020  efined as:..    
+0000f6f0: 2020 2020 2e2e 206d 6174 683a 3a0a 0a20      .. math::.. 
+0000f700: 2020 2020 2020 2020 2020 3120 2d20 5c66            1 - \f
+0000f710: 7261 637b 5c69 6e74 207c 4520 5c63 646f  rac{\int |E \cdo
+0000f720: 7420 6e7c 5e32 205c 2c20 7b5c 726d 2064  t n|^2 \, {\rm d
+0000f730: 7d53 7d7b 5c69 6e74 207c 457c 5e32 205c  }S}{\int |E|^2 \
+0000f740: 2c20 7b5c 726d 2064 7d53 7d0a 0a20 2020  , {\rm d}S}..   
+0000f750: 2020 2020 2061 6e64 2074 6865 2054 4d20       and the TM 
+0000f760: 6672 6163 7469 6f6e 2069 7320 6465 6669  fraction is defi
+0000f770: 6e65 6420 6173 0a0a 2020 2020 2020 2020  ned as..        
+0000f780: 2e2e 206d 6174 683a 3a0a 0a20 2020 2020  .. math::..     
+0000f790: 2020 2020 2020 3120 2d20 5c66 7261 637b        1 - \frac{
+0000f7a0: 5c69 6e74 207c 4820 5c63 646f 7420 6e7c  \int |H \cdot n|
+0000f7b0: 5e32 205c 2c20 7b5c 726d 2064 7d53 7d7b  ^2 \, {\rm d}S}{
+0000f7c0: 5c69 6e74 207c 487c 5e32 205c 2c20 7b5c  \int |H|^2 \, {\
+0000f7d0: 726d 2064 7d53 7d0a 0a20 2020 2020 2020  rm d}S}..       
+0000f7e0: 204e 6f74 650a 2020 2020 2020 2020 2d2d   Note.        --
+0000f7f0: 2d2d 0a20 2020 2020 2020 2020 2020 2054  --.            T
+0000f800: 6865 2077 6176 6567 7569 6465 2054 4520  he waveguide TE 
+0000f810: 616e 6420 544d 2066 7261 6374 696f 6e73  and TM fractions
+0000f820: 2064 6f20 6e6f 7420 7375 6d20 746f 206f   do not sum to o
+0000f830: 6e65 2e20 466f 7220 6578 616d 706c 652c  ne. For example,
+0000f840: 2054 454d 206d 6f64 6573 2074 6861 740a   TEM modes that.
+0000f850: 2020 2020 2020 2020 2020 2020 6172 6520              are 
+0000f860: 636f 6d70 6c65 7465 6c79 2074 7261 6e73  completely trans
+0000f870: 7665 7273 6520 287a 6572 6f20 656c 6563  verse (zero elec
+0000f880: 7472 6963 2061 6e64 206d 6167 6e65 7469  tric and magneti
+0000f890: 6320 6669 656c 6420 696e 2074 6865 2070  c field in the p
+0000f8a0: 726f 7061 6761 7469 6f6e 0a20 2020 2020  ropagation.     
+0000f8b0: 2020 2020 2020 2064 6972 6563 7469 6f6e         direction
+0000f8c0: 2920 6861 7665 2054 4520 6672 6163 7469  ) have TE fracti
+0000f8d0: 6f6e 2061 6e64 2054 4d20 6672 6163 7469  on and TM fracti
+0000f8e0: 6f6e 2062 6f74 6820 6571 7561 6c20 746f  on both equal to
+0000f8f0: 206f 6e65 2e0a 2020 2020 2020 2020 2222   one..        ""
+0000f900: 220a 2020 2020 2020 2020 6966 206c 656e  ".        if len
+0000f910: 2873 656c 662e 6669 656c 645f 636f 6d70  (self.field_comp
+0000f920: 6f6e 656e 7473 2920 3d3d 2030 3a0a 2020  onents) == 0:.  
+0000f930: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+0000f940: 4461 7461 4572 726f 7228 0a20 2020 2020  DataError(.     
+0000f950: 2020 2020 2020 2020 2020 2022 4669 656c             "Fiel
+0000f960: 6420 6461 7461 206e 6f74 2069 6e63 6c75  d data not inclu
+0000f970: 6465 6420 696e 2074 6869 7320 4d6f 6465  ded in this Mode
+0000f980: 4461 7461 206f 6e62 6a65 6374 2e20 5365  Data onbject. Se
+0000f990: 7420 220a 2020 2020 2020 2020 2020 2020  t ".            
+0000f9a0: 2020 2020 2227 4d6f 6465 4d6f 6e69 746f      "'ModeMonito
+0000f9b0: 722e 7374 6f72 655f 6669 656c 6473 5f64  r.store_fields_d
+0000f9c0: 6972 6563 7469 6f6e 2720 746f 2074 6865  irection' to the
+0000f9d0: 2064 6573 6972 6564 2070 726f 7061 6761   desired propaga
+0000f9e0: 7469 6f6e 2064 6972 6563 7469 6f6e 2074  tion direction t
+0000f9f0: 6f20 220a 2020 2020 2020 2020 2020 2020  o ".            
+0000fa00: 2020 2020 2269 6e63 6c75 6465 2074 6865      "include the
+0000fa10: 206d 6f64 6520 6669 656c 6420 7072 6f66   mode field prof
+0000fa20: 696c 6573 2069 6e20 7468 6520 636f 7272  iles in the corr
+0000fa30: 6573 706f 6e64 696e 6720 274d 6f64 6544  esponding 'ModeD
+0000fa40: 6174 6127 2e22 0a20 2020 2020 2020 2020  ata'.".         
+0000fa50: 2020 2029 0a0a 2020 2020 2020 2020 7461     )..        ta
+0000fa60: 6e5f 6469 6d73 203d 2073 656c 662e 5f74  n_dims = self._t
+0000fa70: 616e 6765 6e74 6961 6c5f 6469 6d73 0a20  angential_dims. 
+0000fa80: 2020 2020 2020 2065 5f66 6965 6c64 203d         e_field =
+0000fa90: 2073 656c 662e 5f63 6f6c 6f63 6174 6564   self._colocated
+0000faa0: 5f70 726f 7061 6761 7469 6f6e 5f61 7865  _propagation_axe
+0000fab0: 735f 6669 656c 6428 2245 2229 0a20 2020  s_field("E").   
+0000fac0: 2020 2020 2068 5f66 6965 6c64 203d 2073       h_field = s
+0000fad0: 656c 662e 5f63 6f6c 6f63 6174 6564 5f70  elf._colocated_p
+0000fae0: 726f 7061 6761 7469 6f6e 5f61 7865 735f  ropagation_axes_
+0000faf0: 6669 656c 6428 2248 2229 0a20 2020 2020  field("H").     
+0000fb00: 2020 2064 6966 665f 6172 6561 203d 2073     diff_area = s
+0000fb10: 656c 662e 5f64 6966 665f 6172 6561 0a0a  elf._diff_area..
+0000fb20: 2020 2020 2020 2020 2320 7465 2066 7261          # te fra
+0000fb30: 6374 696f 6e0a 2020 2020 2020 2020 6669  ction.        fi
+0000fb40: 656c 645f 696e 7420 3d20 5b6e 702e 6162  eld_int = [np.ab
+0000fb50: 7328 655f 6669 656c 642e 7365 6c28 636f  s(e_field.sel(co
+0000fb60: 6d70 6f6e 656e 743d 696e 642c 2064 726f  mponent=ind, dro
+0000fb70: 703d 5472 7565 2929 202a 2a20 3220 666f  p=True)) ** 2 fo
+0000fb80: 7220 696e 6420 696e 2072 616e 6765 2833  r ind in range(3
+0000fb90: 295d 0a20 2020 2020 2020 206e 6f72 6d5f  )].        norm_
+0000fba0: 696e 7420 3d20 2864 6966 665f 6172 6561  int = (diff_area
+0000fbb0: 202a 2066 6965 6c64 5f69 6e74 5b32 5d29   * field_int[2])
+0000fbc0: 2e73 756d 2864 696d 3d74 616e 5f64 696d  .sum(dim=tan_dim
+0000fbd0: 7329 0a20 2020 2020 2020 2074 6f74 5f69  s).        tot_i
+0000fbe0: 6e74 203d 206e 6f72 6d5f 696e 7420 2b20  nt = norm_int + 
+0000fbf0: 2864 6966 665f 6172 6561 202a 2028 6669  (diff_area * (fi
+0000fc00: 656c 645f 696e 745b 305d 202b 2066 6965  eld_int[0] + fie
+0000fc10: 6c64 5f69 6e74 5b31 5d29 292e 7375 6d28  ld_int[1])).sum(
+0000fc20: 6469 6d3d 7461 6e5f 6469 6d73 290a 2020  dim=tan_dims).  
+0000fc30: 2020 2020 2020 7465 5f66 7261 6320 3d20        te_frac = 
+0000fc40: 3120 2d20 6e6f 726d 5f69 6e74 202f 2074  1 - norm_int / t
+0000fc50: 6f74 5f69 6e74 0a0a 2020 2020 2020 2020  ot_int..        
+0000fc60: 2320 746d 2066 7261 6374 696f 6e0a 2020  # tm fraction.  
+0000fc70: 2020 2020 2020 6669 656c 645f 696e 7420        field_int 
+0000fc80: 3d20 5b6e 702e 6162 7328 685f 6669 656c  = [np.abs(h_fiel
+0000fc90: 642e 7365 6c28 636f 6d70 6f6e 656e 743d  d.sel(component=
+0000fca0: 696e 642c 2064 726f 703d 5472 7565 2929  ind, drop=True))
+0000fcb0: 202a 2a20 3220 666f 7220 696e 6420 696e   ** 2 for ind in
+0000fcc0: 2072 616e 6765 2833 295d 0a20 2020 2020   range(3)].     
+0000fcd0: 2020 206e 6f72 6d5f 696e 7420 3d20 2864     norm_int = (d
+0000fce0: 6966 665f 6172 6561 202a 2066 6965 6c64  iff_area * field
+0000fcf0: 5f69 6e74 5b32 5d29 2e73 756d 2864 696d  _int[2]).sum(dim
+0000fd00: 3d74 616e 5f64 696d 7329 0a20 2020 2020  =tan_dims).     
+0000fd10: 2020 2074 6f74 5f69 6e74 203d 206e 6f72     tot_int = nor
+0000fd20: 6d5f 696e 7420 2b20 2864 6966 665f 6172  m_int + (diff_ar
+0000fd30: 6561 202a 2028 6669 656c 645f 696e 745b  ea * (field_int[
+0000fd40: 305d 202b 2066 6965 6c64 5f69 6e74 5b31  0] + field_int[1
+0000fd50: 5d29 292e 7375 6d28 6469 6d3d 7461 6e5f  ])).sum(dim=tan_
+0000fd60: 6469 6d73 290a 2020 2020 2020 2020 746d  dims).        tm
+0000fd70: 5f66 7261 6320 3d20 3120 2d20 6e6f 726d  _frac = 1 - norm
+0000fd80: 5f69 6e74 202f 2074 6f74 5f69 6e74 0a0a  _int / tot_int..
+0000fd90: 2020 2020 2020 2020 7265 7475 726e 2078          return x
+0000fda0: 722e 4461 7461 7365 7428 6461 7461 5f76  r.Dataset(data_v
+0000fdb0: 6172 733d 7b22 7465 223a 2074 655f 6672  ars={"te": te_fr
+0000fdc0: 6163 2c20 2274 6d22 3a20 746d 5f66 7261  ac, "tm": tm_fra
+0000fdd0: 637d 290a 0a20 2020 2040 7072 6f70 6572  c})..    @proper
+0000fde0: 7479 0a20 2020 2064 6566 206d 6f64 6573  ty.    def modes
+0000fdf0: 5f69 6e66 6f28 7365 6c66 2920 2d3e 2078  _info(self) -> x
+0000fe00: 722e 4461 7461 7365 743a 0a20 2020 2020  r.Dataset:.     
+0000fe10: 2020 2022 2222 4461 7461 7365 7420 636f     """Dataset co
+0000fe20: 6c6c 6563 7469 6e67 2076 6172 696f 7573  llecting various
+0000fe30: 2070 726f 7065 7274 6965 7320 6f66 2074   properties of t
+0000fe40: 6865 2073 746f 7265 6420 6d6f 6465 732e  he stored modes.
+0000fe50: 2222 220a 0a20 2020 2020 2020 206c 616d  """..        lam
+0000fe60: 6264 615f 636d 203d 2043 5f30 202f 2073  bda_cm = C_0 / s
+0000fe70: 656c 662e 6b5f 6566 662e 6620 2f20 3165  elf.k_eff.f / 1e
+0000fe80: 340a 2020 2020 2020 2020 6c6f 7373 5f64  4.        loss_d
+0000fe90: 625f 636d 203d 2032 3020 2a20 3220 2a20  b_cm = 20 * 2 * 
+0000fea0: 6e70 2e70 6920 2a20 6e70 2e6c 6f67 3130  np.pi * np.log10
+0000feb0: 286e 702e 6529 202a 2073 656c 662e 6b5f  (np.e) * self.k_
+0000fec0: 6566 6620 2f20 6c61 6d62 6461 5f63 6d0a  eff / lambda_cm.
+0000fed0: 0a20 2020 2020 2020 2069 6e66 6f20 3d20  .        info = 
+0000fee0: 7b0a 2020 2020 2020 2020 2020 2020 2277  {.            "w
+0000fef0: 6176 656c 656e 6774 6822 3a20 435f 3020  avelength": C_0 
+0000ff00: 2f20 7365 6c66 2e6e 5f65 6666 2e66 2c0a  / self.n_eff.f,.
+0000ff10: 2020 2020 2020 2020 2020 2020 226e 2065              "n e
+0000ff20: 6666 223a 2073 656c 662e 6e5f 6566 662c  ff": self.n_eff,
+0000ff30: 0a20 2020 2020 2020 2020 2020 2022 6b20  .            "k 
+0000ff40: 6566 6622 3a20 7365 6c66 2e6b 5f65 6666  eff": self.k_eff
+0000ff50: 2c0a 2020 2020 2020 2020 2020 2020 226c  ,.            "l
+0000ff60: 6f73 7320 2864 422f 636d 2922 3a20 6c6f  oss (dB/cm)": lo
+0000ff70: 7373 5f64 625f 636d 2c0a 2020 2020 2020  ss_db_cm,.      
+0000ff80: 2020 2020 2020 6622 5445 2028 457b 7365        f"TE (E{se
+0000ff90: 6c66 2e5f 7461 6e67 656e 7469 616c 5f64  lf._tangential_d
+0000ffa0: 696d 735b 305d 7d29 2066 7261 6374 696f  ims[0]}) fractio
+0000ffb0: 6e22 3a20 7365 6c66 2e70 6f6c 5f66 7261  n": self.pol_fra
+0000ffc0: 6374 696f 6e5b 2274 6522 5d2c 0a20 2020  ction["te"],.   
+0000ffd0: 2020 2020 2020 2020 2022 7767 2054 4520           "wg TE 
+0000ffe0: 6672 6163 7469 6f6e 223a 2073 656c 662e  fraction": self.
+0000fff0: 706f 6c5f 6672 6163 7469 6f6e 5f77 6176  pol_fraction_wav
+00010000: 6567 7569 6465 5b22 7465 225d 2c0a 2020  eguide["te"],.  
+00010010: 2020 2020 2020 2020 2020 2277 6720 544d            "wg TM
+00010020: 2066 7261 6374 696f 6e22 3a20 7365 6c66   fraction": self
+00010030: 2e70 6f6c 5f66 7261 6374 696f 6e5f 7761  .pol_fraction_wa
+00010040: 7665 6775 6964 655b 2274 6d22 5d2c 0a20  veguide["tm"],. 
+00010050: 2020 2020 2020 2020 2020 2022 6d6f 6465             "mode
+00010060: 2061 7265 6122 3a20 7365 6c66 2e6d 6f64   area": self.mod
+00010070: 655f 6172 6561 2c0a 2020 2020 2020 2020  e_area,.        
+00010080: 2020 2020 2267 726f 7570 2069 6e64 6578      "group index
+00010090: 223a 2073 656c 662e 6e5f 6772 6f75 705f  ": self.n_group_
+000100a0: 7261 772c 2020 2320 5573 6520 7261 7720  raw,  # Use raw 
+000100b0: 6669 656c 6420 746f 2061 766f 6964 2069  field to avoid i
+000100c0: 7373 7569 6e67 2061 2077 6172 6e69 6e67  ssuing a warning
+000100d0: 0a20 2020 2020 2020 2020 2020 2022 6469  .            "di
+000100e0: 7370 6572 7369 6f6e 2028 7073 2f28 6e6d  spersion (ps/(nm
+000100f0: 206b 6d29 2922 3a20 7365 6c66 2e64 6973   km))": self.dis
+00010100: 7065 7273 696f 6e5f 7261 772c 2020 2320  persion_raw,  # 
+00010110: 5573 6520 7261 7720 6669 656c 6420 746f  Use raw field to
+00010120: 2061 766f 6964 2069 7373 7569 6e67 2061   avoid issuing a
+00010130: 2077 6172 6e69 6e67 0a20 2020 2020 2020   warning.       
+00010140: 207d 0a0a 2020 2020 2020 2020 6966 2073   }..        if s
+00010150: 656c 662e 6e5f 6772 6f75 705f 7261 7720  elf.n_group_raw 
+00010160: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
+00010170: 2020 2020 2020 2020 2069 6e66 6f5b 2267           info["g
+00010180: 726f 7570 2069 6e64 6578 225d 203d 2073  roup index"] = s
+00010190: 656c 662e 6e5f 6772 6f75 705f 7261 770a  elf.n_group_raw.
+000101a0: 0a20 2020 2020 2020 2069 6620 6c65 6e28  .        if len(
+000101b0: 7365 6c66 2e66 6965 6c64 5f63 6f6d 706f  self.field_compo
+000101c0: 6e65 6e74 7329 203d 3d20 363a 0a20 2020  nents) == 6:.   
+000101d0: 2020 2020 2020 2020 2069 6e66 6f5b 226d           info["m
+000101e0: 6f64 6520 6172 6561 225d 203d 2073 656c  ode area"] = sel
+000101f0: 662e 6d6f 6465 5f61 7265 610a 2020 2020  f.mode_area.    
+00010200: 2020 2020 2020 2020 696e 666f 5b66 2254          info[f"T
+00010210: 4520 2845 7b73 656c 662e 5f74 616e 6765  E (E{self._tange
+00010220: 6e74 6961 6c5f 6469 6d73 5b30 5d7d 2920  ntial_dims[0]}) 
+00010230: 6672 6163 7469 6f6e 225d 203d 2073 656c  fraction"] = sel
+00010240: 662e 706f 6c5f 6672 6163 7469 6f6e 5b22  f.pol_fraction["
+00010250: 7465 225d 0a20 2020 2020 2020 2020 2020  te"].           
+00010260: 2069 6e66 6f5b 2277 6720 5445 2066 7261   info["wg TE fra
+00010270: 6374 696f 6e22 5d20 3d20 7365 6c66 2e70  ction"] = self.p
+00010280: 6f6c 5f66 7261 6374 696f 6e5f 7761 7665  ol_fraction_wave
+00010290: 6775 6964 655b 2274 6522 5d0a 2020 2020  guide["te"].    
+000102a0: 2020 2020 2020 2020 696e 666f 5b22 7767          info["wg
+000102b0: 2054 4d20 6672 6163 7469 6f6e 225d 203d   TM fraction"] =
+000102c0: 2073 656c 662e 706f 6c5f 6672 6163 7469   self.pol_fracti
+000102d0: 6f6e 5f77 6176 6567 7569 6465 5b22 746d  on_waveguide["tm
+000102e0: 225d 0a0a 2020 2020 2020 2020 7265 7475  "]..        retu
+000102f0: 726e 2078 722e 4461 7461 7365 7428 6461  rn xr.Dataset(da
+00010300: 7461 5f76 6172 733d 696e 666f 290a 0a20  ta_vars=info).. 
+00010310: 2020 2064 6566 2074 6f5f 6461 7461 6672     def to_datafr
+00010320: 616d 6528 7365 6c66 2920 2d3e 2044 6174  ame(self) -> Dat
+00010330: 6146 7261 6d65 3a0a 2020 2020 2020 2020  aFrame:.        
+00010340: 2222 2278 6172 7261 792d 6c69 6b65 206d  """xarray-like m
+00010350: 6574 686f 6420 746f 2065 7870 6f72 7420  ethod to export 
+00010360: 7468 6520 6060 6d6f 6465 735f 696e 666f  the ``modes_info
+00010370: 6060 2069 6e74 6f20 6120 7061 6e64 6173  `` into a pandas
+00010380: 2064 6174 6166 7261 6d65 2077 6869 6368   dataframe which
+00010390: 2069 7320 652e 672e 0a20 2020 2020 2020   is e.g..       
+000103a0: 2073 696d 706c 6520 746f 2076 6973 7561   simple to visua
+000103b0: 6c69 7a65 2061 7320 6120 7461 626c 652e  lize as a table.
+000103c0: 2222 220a 0a20 2020 2020 2020 2064 6174  """..        dat
+000103d0: 6173 6574 203d 2073 656c 662e 6d6f 6465  aset = self.mode
+000103e0: 735f 696e 666f 0a20 2020 2020 2020 2064  s_info.        d
+000103f0: 726f 7020 3d20 5b5d 0a0a 2020 2020 2020  rop = []..      
+00010400: 2020 6966 206e 6f74 206e 702e 616e 7928    if not np.any(
+00010410: 6461 7461 7365 745b 2267 726f 7570 2069  dataset["group i
+00010420: 6e64 6578 225d 2e76 616c 7565 7329 3a0a  ndex"].values):.
+00010430: 2020 2020 2020 2020 2020 2020 6472 6f70              drop
+00010440: 2e61 7070 656e 6428 2267 726f 7570 2069  .append("group i
+00010450: 6e64 6578 2229 0a20 2020 2020 2020 2069  ndex").        i
+00010460: 6620 6e6f 7420 6e70 2e61 6e79 2864 6174  f not np.any(dat
+00010470: 6173 6574 5b22 6469 7370 6572 7369 6f6e  aset["dispersion
+00010480: 2028 7073 2f28 6e6d 206b 6d29 2922 5d2e   (ps/(nm km))"].
+00010490: 7661 6c75 6573 293a 0a20 2020 2020 2020  values):.       
+000104a0: 2020 2020 2064 726f 702e 6170 7065 6e64       drop.append
+000104b0: 2822 6469 7370 6572 7369 6f6e 2028 7073  ("dispersion (ps
+000104c0: 2f28 6e6d 206b 6d29 2922 290a 2020 2020  /(nm km))").    
+000104d0: 2020 2020 6966 206e 702e 616c 6c28 6461      if np.all(da
+000104e0: 7461 7365 745b 226c 6f73 7320 2864 422f  taset["loss (dB/
+000104f0: 636d 2922 5d20 3d3d 2030 293a 0a20 2020  cm)"] == 0):.   
+00010500: 2020 2020 2020 2020 2064 726f 702e 6170           drop.ap
+00010510: 7065 6e64 2822 6c6f 7373 2028 6442 2f63  pend("loss (dB/c
+00010520: 6d29 2229 0a0a 2020 2020 2020 2020 7265  m)")..        re
+00010530: 7475 726e 2064 6174 6173 6574 2e64 726f  turn dataset.dro
+00010540: 705f 7661 7273 2864 726f 7029 2e74 6f5f  p_vars(drop).to_
+00010550: 6461 7461 6672 616d 6528 290a 0a0a 636c  dataframe()...cl
+00010560: 6173 7320 4d6f 6465 536f 6c76 6572 4461  ass ModeSolverDa
+00010570: 7461 284d 6f64 6544 6174 6129 3a0a 2020  ta(ModeData):.  
+00010580: 2020 2222 220a 2020 2020 4461 7461 2061    """.    Data a
+00010590: 7373 6f63 6961 7465 6420 7769 7468 2061  ssociated with a
+000105a0: 203a 636c 6173 733a 602e 4d6f 6465 536f   :class:`.ModeSo
+000105b0: 6c76 6572 4d6f 6e69 746f 7260 3a20 7363  lverMonitor`: sc
+000105c0: 616c 6172 2063 6f6d 706f 6e65 6e74 7320  alar components 
+000105d0: 6f66 2045 2061 6e64 2048 2066 6965 6c64  of E and H field
+000105e0: 732e 0a0a 2020 2020 4e6f 7465 730a 2020  s...    Notes.  
+000105f0: 2020 2d2d 2d2d 2d0a 0a20 2020 2020 2020    -----..       
+00010600: 2054 6865 2064 6174 6120 6973 2073 746f   The data is sto
+00010610: 7265 6420 6173 2061 2060 4461 7461 4172  red as a `DataAr
+00010620: 7261 7920 3c68 7474 7073 3a2f 2f64 6f63  ray <https://doc
+00010630: 732e 7861 7272 6179 2e64 6576 2f65 6e2f  s.xarray.dev/en/
+00010640: 7374 6162 6c65 2f67 656e 6572 6174 6564  stable/generated
+00010650: 2f78 6172 7261 792e 4461 7461 4172 7261  /xarray.DataArra
+00010660: 792e 6874 6d6c 3e60 5f0a 2020 2020 2020  y.html>`_.      
+00010670: 2020 6f62 6a65 6374 2075 7369 6e67 2074    object using t
+00010680: 6865 2060 7861 7272 6179 203c 6874 7470  he `xarray <http
+00010690: 733a 2f2f 646f 6373 2e78 6172 7261 792e  s://docs.xarray.
+000106a0: 6465 762f 656e 2f73 7461 626c 652f 696e  dev/en/stable/in
+000106b0: 6465 782e 6874 6d6c 3e60 5f20 7061 636b  dex.html>`_ pack
+000106c0: 6167 652e 0a0a 2020 2020 4578 616d 706c  age...    Exampl
+000106d0: 650a 2020 2020 2d2d 2d2d 2d2d 2d0a 2020  e.    -------.  
+000106e0: 2020 3e3e 3e20 6672 6f6d 2074 6964 7933    >>> from tidy3
+000106f0: 6420 696d 706f 7274 204d 6f64 6553 7065  d import ModeSpe
+00010700: 630a 2020 2020 3e3e 3e20 6672 6f6d 2074  c.    >>> from t
+00010710: 6964 7933 6420 696d 706f 7274 2053 6361  idy3d import Sca
+00010720: 6c61 724d 6f64 6546 6965 6c64 4461 7461  larModeFieldData
+00010730: 4172 7261 792c 204d 6f64 6549 6e64 6578  Array, ModeIndex
+00010740: 4461 7461 4172 7261 790a 2020 2020 3e3e  DataArray.    >>
+00010750: 3e20 7820 3d20 5b2d 312c 312c 335d 0a20  > x = [-1,1,3]. 
+00010760: 2020 203e 3e3e 2079 203d 205b 2d32 2c30     >>> y = [-2,0
+00010770: 5d0a 2020 2020 3e3e 3e20 7a20 3d20 5b2d  ].    >>> z = [-
+00010780: 332c 2d31 2c31 2c33 2c35 5d0a 2020 2020  3,-1,1,3,5].    
+00010790: 3e3e 3e20 6620 3d20 5b32 6531 342c 2033  >>> f = [2e14, 3
+000107a0: 6531 345d 0a20 2020 203e 3e3e 206d 6f64  e14].    >>> mod
+000107b0: 655f 696e 6465 7820 3d20 6e70 2e61 7261  e_index = np.ara
+000107c0: 6e67 6528 3529 0a20 2020 203e 3e3e 2067  nge(5).    >>> g
+000107d0: 7269 6420 3d20 4772 6964 2862 6f75 6e64  rid = Grid(bound
+000107e0: 6172 6965 733d 436f 6f72 6473 2878 3d78  aries=Coords(x=x
+000107f0: 2c20 793d 792c 207a 3d7a 2929 0a20 2020  , y=y, z=z)).   
+00010800: 203e 3e3e 2066 6965 6c64 5f63 6f6f 7264   >>> field_coord
+00010810: 7320 3d20 6469 6374 2878 3d78 5b3a 2d31  s = dict(x=x[:-1
+00010820: 5d2c 2079 3d79 5b3a 2d31 5d2c 207a 3d7a  ], y=y[:-1], z=z
+00010830: 5b3a 2d31 5d2c 2066 3d66 2c20 6d6f 6465  [:-1], f=f, mode
+00010840: 5f69 6e64 6578 3d6d 6f64 655f 696e 6465  _index=mode_inde
+00010850: 7829 0a20 2020 203e 3e3e 2066 6965 6c64  x).    >>> field
+00010860: 203d 2053 6361 6c61 724d 6f64 6546 6965   = ScalarModeFie
+00010870: 6c64 4461 7461 4172 7261 7928 2831 2b31  ldDataArray((1+1
+00010880: 6a29 2a6e 702e 7261 6e64 6f6d 2e72 616e  j)*np.random.ran
+00010890: 646f 6d28 2832 2c31 2c34 2c32 2c35 2929  dom((2,1,4,2,5))
+000108a0: 2c20 636f 6f72 6473 3d66 6965 6c64 5f63  , coords=field_c
+000108b0: 6f6f 7264 7329 0a20 2020 203e 3e3e 2069  oords).    >>> i
+000108c0: 6e64 6578 5f63 6f6f 7264 7320 3d20 6469  ndex_coords = di
+000108d0: 6374 2866 3d66 2c20 6d6f 6465 5f69 6e64  ct(f=f, mode_ind
+000108e0: 6578 3d6d 6f64 655f 696e 6465 7829 0a20  ex=mode_index). 
+000108f0: 2020 203e 3e3e 2069 6e64 6578 5f64 6174     >>> index_dat
+00010900: 6120 3d20 4d6f 6465 496e 6465 7844 6174  a = ModeIndexDat
+00010910: 6141 7272 6179 2828 312b 316a 2920 2a20  aArray((1+1j) * 
+00010920: 6e70 2e72 616e 646f 6d2e 7261 6e64 6f6d  np.random.random
+00010930: 2828 322c 3529 292c 2063 6f6f 7264 733d  ((2,5)), coords=
+00010940: 696e 6465 785f 636f 6f72 6473 290a 2020  index_coords).  
+00010950: 2020 3e3e 3e20 6d6f 6e69 746f 7220 3d20    >>> monitor = 
+00010960: 4d6f 6465 536f 6c76 6572 4d6f 6e69 746f  ModeSolverMonito
+00010970: 7228 0a20 2020 202e 2e2e 2020 2020 7369  r(.    ...    si
+00010980: 7a65 3d28 322c 302c 3629 2c0a 2020 2020  ze=(2,0,6),.    
+00010990: 2e2e 2e20 2020 2066 7265 7173 3d5b 3265  ...    freqs=[2e
+000109a0: 3134 2c20 3365 3134 5d2c 0a20 2020 202e  14, 3e14],.    .
+000109b0: 2e2e 2020 2020 6d6f 6465 5f73 7065 633d  ..    mode_spec=
+000109c0: 4d6f 6465 5370 6563 286e 756d 5f6d 6f64  ModeSpec(num_mod
+000109d0: 6573 3d35 292c 0a20 2020 202e 2e2e 2020  es=5),.    ...  
+000109e0: 2020 6e61 6d65 3d27 6d6f 6465 5f73 6f6c    name='mode_sol
+000109f0: 7665 7227 2c0a 2020 2020 2e2e 2e20 290a  ver',.    ... ).
+00010a00: 2020 2020 3e3e 3e20 6461 7461 203d 204d      >>> data = M
+00010a10: 6f64 6553 6f6c 7665 7244 6174 6128 0a20  odeSolverData(. 
+00010a20: 2020 202e 2e2e 2020 2020 206d 6f6e 6974     ...     monit
+00010a30: 6f72 3d6d 6f6e 6974 6f72 2c0a 2020 2020  or=monitor,.    
+00010a40: 2e2e 2e20 2020 2020 4578 3d66 6965 6c64  ...     Ex=field
+00010a50: 2c0a 2020 2020 2e2e 2e20 2020 2020 4579  ,.    ...     Ey
+00010a60: 3d66 6965 6c64 2c0a 2020 2020 2e2e 2e20  =field,.    ... 
+00010a70: 2020 2020 457a 3d66 6965 6c64 2c0a 2020      Ez=field,.  
+00010a80: 2020 2e2e 2e20 2020 2020 4878 3d66 6965    ...     Hx=fie
+00010a90: 6c64 2c0a 2020 2020 2e2e 2e20 2020 2020  ld,.    ...     
+00010aa0: 4879 3d66 6965 6c64 2c0a 2020 2020 2e2e  Hy=field,.    ..
+00010ab0: 2e20 2020 2020 487a 3d66 6965 6c64 2c0a  .     Hz=field,.
+00010ac0: 2020 2020 2e2e 2e20 2020 2020 6e5f 636f      ...     n_co
+00010ad0: 6d70 6c65 783d 696e 6465 785f 6461 7461  mplex=index_data
+00010ae0: 2c0a 2020 2020 2e2e 2e20 2020 2020 6772  ,.    ...     gr
+00010af0: 6964 5f65 7870 616e 6465 643d 6772 6964  id_expanded=grid
+00010b00: 0a20 2020 202e 2e2e 2029 0a20 2020 2022  .    ... ).    "
+00010b10: 2222 0a0a 2020 2020 6d6f 6e69 746f 723a  ""..    monitor:
+00010b20: 204d 6f64 6553 6f6c 7665 724d 6f6e 6974   ModeSolverMonit
+00010b30: 6f72 203d 2070 642e 4669 656c 6428 0a20  or = pd.Field(. 
+00010b40: 2020 2020 2020 202e 2e2e 2c20 7469 746c         ..., titl
+00010b50: 653d 224d 6f6e 6974 6f72 222c 2064 6573  e="Monitor", des
+00010b60: 6372 6970 7469 6f6e 3d22 4d6f 6465 2073  cription="Mode s
+00010b70: 6f6c 7665 7220 6d6f 6e69 746f 7220 6173  olver monitor as
+00010b80: 736f 6369 6174 6564 2077 6974 6820 7468  sociated with th
+00010b90: 6520 6461 7461 2e22 0a20 2020 2029 0a0a  e data.".    )..
+00010ba0: 2020 2020 616d 7073 3a20 4d6f 6465 416d      amps: ModeAm
+00010bb0: 7073 4461 7461 4172 7261 7920 3d20 7064  psDataArray = pd
+00010bc0: 2e46 6965 6c64 280a 2020 2020 2020 2020  .Field(.        
+00010bd0: 4e6f 6e65 2c20 7469 746c 653d 2241 6d70  None, title="Amp
+00010be0: 6c69 7475 6465 7322 2c20 6465 7363 7269  litudes", descri
+00010bf0: 7074 696f 6e3d 2255 6e75 7365 6420 666f  ption="Unused fo
+00010c00: 7220 4d6f 6465 536f 6c76 6572 4461 7461  r ModeSolverData
+00010c10: 2e22 0a20 2020 2029 0a0a 2020 2020 6465  .".    )..    de
+00010c20: 6620 6e6f 726d 616c 697a 6528 7365 6c66  f normalize(self
+00010c30: 2c20 736f 7572 6365 5f73 7065 6374 7275  , source_spectru
+00010c40: 6d5f 666e 3a20 4361 6c6c 6162 6c65 5b5b  m_fn: Callable[[
+00010c50: 666c 6f61 745d 2c20 636f 6d70 6c65 785d  float], complex]
+00010c60: 2920 2d3e 204d 6f64 6553 6f6c 7665 7244  ) -> ModeSolverD
+00010c70: 6174 613a 0a20 2020 2020 2020 2022 2222  ata:.        """
+00010c80: 5265 7475 726e 2063 6f70 7920 6f66 2073  Return copy of s
+00010c90: 656c 6620 6166 7465 7220 6e6f 726d 616c  elf after normal
+00010ca0: 697a 6174 696f 6e20 6973 2061 7070 6c69  ization is appli
+00010cb0: 6564 2075 7369 6e67 2073 6f75 7263 6520  ed using source 
+00010cc0: 7370 6563 7472 756d 2066 756e 6374 696f  spectrum functio
+00010cd0: 6e2e 2222 220a 2020 2020 2020 2020 7265  n.""".        re
+00010ce0: 7475 726e 2073 656c 662e 636f 7079 2829  turn self.copy()
+00010cf0: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
+00010d00: 2020 2020 6465 6620 7469 6d65 5f72 6576      def time_rev
+00010d10: 6572 7365 645f 636f 7079 2873 656c 6629  ersed_copy(self)
+00010d20: 202d 3e20 4669 656c 6444 6174 613a 0a20   -> FieldData:. 
+00010d30: 2020 2020 2020 2022 2222 4d61 6b65 2061         """Make a
+00010d40: 2063 6f70 7920 6f66 2074 6865 2064 6174   copy of the dat
+00010d50: 6120 7769 7468 2064 6972 6563 7469 6f6e  a with direction
+00010d60: 2d72 6576 6572 7365 6420 6669 656c 6473  -reversed fields
+00010d70: 2e20 496e 206c 6f73 7379 206f 7220 6779  . In lossy or gy
+00010d80: 726f 7472 6f70 6963 2073 7973 7465 6d73  rotropic systems
+00010d90: 2c0a 2020 2020 2020 2020 7468 6520 7469  ,.        the ti
+00010da0: 6d65 2d72 6576 6572 7365 6420 6669 656c  me-reversed fiel
+00010db0: 6473 2077 696c 6c20 6e6f 7420 6265 2074  ds will not be t
+00010dc0: 6865 2073 616d 6520 6173 2074 6865 2062  he same as the b
+00010dd0: 6163 6b77 6172 642d 7072 6f70 6167 6174  ackward-propagat
+00010de0: 696e 6720 6d6f 6465 732e 2222 220a 0a20  ing modes.""".. 
+00010df0: 2020 2020 2020 2023 2054 696d 6520 7265         # Time re
+00010e00: 7665 7273 616c 0a20 2020 2020 2020 206e  versal.        n
+00010e10: 6577 5f64 6174 6120 3d20 7b7d 0a20 2020  ew_data = {}.   
+00010e20: 2020 2020 2066 6f72 2063 6f6d 702c 2066       for comp, f
+00010e30: 6965 6c64 2069 6e20 7365 6c66 2e66 6965  ield in self.fie
+00010e40: 6c64 5f63 6f6d 706f 6e65 6e74 732e 6974  ld_components.it
+00010e50: 656d 7328 293a 0a20 2020 2020 2020 2020  ems():.         
+00010e60: 2020 2069 6620 636f 6d70 5b30 5d20 3d3d     if comp[0] ==
+00010e70: 2022 4822 3a0a 2020 2020 2020 2020 2020   "H":.          
+00010e80: 2020 2020 2020 6e65 775f 6461 7461 5b63        new_data[c
+00010e90: 6f6d 705d 203d 202d 6e70 2e63 6f6e 6a28  omp] = -np.conj(
+00010ea0: 6669 656c 6429 0a20 2020 2020 2020 2020  field).         
+00010eb0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00010ec0: 2020 2020 2020 2020 206e 6577 5f64 6174           new_dat
+00010ed0: 615b 636f 6d70 5d20 3d20 6e70 2e63 6f6e  a[comp] = np.con
+00010ee0: 6a28 6669 656c 6429 0a0a 2020 2020 2020  j(field)..      
+00010ef0: 2020 2320 7377 6974 6368 2064 6972 6563    # switch direc
+00010f00: 7469 6f6e 2069 6e20 7468 6520 6d6f 6e69  tion in the moni
+00010f10: 746f 720a 2020 2020 2020 2020 6d6e 7420  tor.        mnt 
+00010f20: 3d20 7365 6c66 2e6d 6f6e 6974 6f72 0a20  = self.monitor. 
+00010f30: 2020 2020 2020 206e 6577 5f64 6972 203d         new_dir =
+00010f40: 2022 2b22 2069 6620 6d6e 742e 7374 6f72   "+" if mnt.stor
+00010f50: 655f 6669 656c 6473 5f64 6972 6563 7469  e_fields_directi
+00010f60: 6f6e 203d 3d20 222d 2220 656c 7365 2022  on == "-" else "
+00010f70: 2d22 0a20 2020 2020 2020 206e 6577 5f64  -".        new_d
+00010f80: 6174 615b 226d 6f6e 6974 6f72 225d 203d  ata["monitor"] =
+00010f90: 206d 6e74 2e75 7064 6174 6564 5f63 6f70   mnt.updated_cop
+00010fa0: 7928 6469 7265 6374 696f 6e3d 6e65 775f  y(direction=new_
+00010fb0: 6469 722c 2073 746f 7265 5f66 6965 6c64  dir, store_field
+00010fc0: 735f 6469 7265 6374 696f 6e3d 6e65 775f  s_direction=new_
+00010fd0: 6469 7229 0a20 2020 2020 2020 2072 6574  dir).        ret
+00010fe0: 7572 6e20 7365 6c66 2e63 6f70 7928 7570  urn self.copy(up
+00010ff0: 6461 7465 3d6e 6577 5f64 6174 6129 0a0a  date=new_data)..
+00011000: 0a63 6c61 7373 2046 6c75 7844 6174 6128  .class FluxData(
+00011010: 4d6f 6e69 746f 7244 6174 6129 3a0a 2020  MonitorData):.  
+00011020: 2020 2222 220a 2020 2020 4461 7461 2061    """.    Data a
+00011030: 7373 6f63 6961 7465 6420 7769 7468 2061  ssociated with a
+00011040: 203a 636c 6173 733a 602e 466c 7578 4d6f   :class:`.FluxMo
+00011050: 6e69 746f 7260 3a20 666c 7578 2064 6174  nitor`: flux dat
+00011060: 6120 696e 2074 6865 2066 7265 7175 656e  a in the frequen
+00011070: 6379 2d64 6f6d 6169 6e2e 0a0a 2020 2020  cy-domain...    
+00011080: 4e6f 7465 730a 2020 2020 2d2d 2d2d 2d0a  Notes.    -----.
+00011090: 0a20 2020 2020 2020 2054 6865 2064 6174  .        The dat
+000110a0: 6120 6973 2073 746f 7265 6420 6173 2061  a is stored as a
+000110b0: 2060 4461 7461 4172 7261 7920 3c68 7474   `DataArray <htt
+000110c0: 7073 3a2f 2f64 6f63 732e 7861 7272 6179  ps://docs.xarray
+000110d0: 2e64 6576 2f65 6e2f 7374 6162 6c65 2f67  .dev/en/stable/g
+000110e0: 656e 6572 6174 6564 2f78 6172 7261 792e  enerated/xarray.
+000110f0: 4461 7461 4172 7261 792e 6874 6d6c 3e60  DataArray.html>`
+00011100: 5f0a 2020 2020 2020 2020 6f62 6a65 6374  _.        object
+00011110: 2075 7369 6e67 2074 6865 2060 7861 7272   using the `xarr
+00011120: 6179 203c 6874 7470 733a 2f2f 646f 6373  ay <https://docs
+00011130: 2e78 6172 7261 792e 6465 762f 656e 2f73  .xarray.dev/en/s
+00011140: 7461 626c 652f 696e 6465 782e 6874 6d6c  table/index.html
+00011150: 3e60 5f20 7061 636b 6167 652e 0a0a 2020  >`_ package...  
+00011160: 2020 2020 2020 5765 2063 616e 2061 6363        We can acc
+00011170: 6573 7320 7468 6520 6461 7461 2066 6f72  ess the data for
+00011180: 2065 6163 6820 6d6f 6e69 746f 7220 6279   each monitor by
+00011190: 2069 6e64 6578 696e 6720 696e 746f 2074   indexing into t
+000111a0: 6865 203a 636c 6173 733a 6053 696d 756c  he :class:`Simul
+000111b0: 6174 696f 6e44 6174 6160 2077 6974 6820  ationData` with 
+000111c0: 7468 6520 6d6f 6e69 746f 720a 2020 2020  the monitor.    
+000111d0: 2020 2020 6060 2e6e 616d 6560 602e 2046      ``.name``. F
+000111e0: 6f72 2074 6865 2066 6c75 7820 6d6f 6e69  or the flux moni
+000111f0: 746f 7220 6461 7461 2c20 7765 2063 616e  tor data, we can
+00011200: 2061 6363 6573 7320 7468 6520 7261 7720   access the raw 
+00011210: 666c 7578 2064 6174 6120 6173 2061 2066  flux data as a f
+00011220: 756e 6374 696f 6e20 6f66 2066 7265 7175  unction of frequ
+00011230: 656e 6379 2077 6974 680a 2020 2020 2020  ency with.      
+00011240: 2020 6060 2e66 6c75 7860 602e 2041 7320    ``.flux``. As 
+00011250: 6d6f 7374 2064 6174 6120 6172 6520 6d75  most data are mu
+00011260: 6c74 6964 696d 656e 7369 6f6e 616c 2c20  ltidimensional, 
+00011270: 6974 e280 9973 206f 6674 656e 2076 6572  it...s often ver
+00011280: 7920 6865 6c70 6675 6c20 746f 2070 7269  y helpful to pri
+00011290: 6e74 206f 7574 2074 6865 2064 6174 6120  nt out the data 
+000112a0: 616e 6420 6469 7265 6374 6c79 0a20 2020  and directly.   
+000112b0: 2020 2020 2069 6e73 7065 6374 2069 7473       inspect its
+000112c0: 2073 7472 7563 7475 7265 2e0a 0a20 2020   structure...   
+000112d0: 2045 7861 6d70 6c65 0a20 2020 202d 2d2d   Example.    ---
+000112e0: 2d2d 2d2d 0a20 2020 203e 3e3e 2066 726f  ----.    >>> fro
+000112f0: 6d20 7469 6479 3364 2069 6d70 6f72 7420  m tidy3d import 
+00011300: 466c 7578 4461 7461 4172 7261 790a 2020  FluxDataArray.  
+00011310: 2020 3e3e 3e20 6620 3d20 5b32 6531 342c    >>> f = [2e14,
+00011320: 2033 6531 345d 0a20 2020 203e 3e3e 2063   3e14].    >>> c
+00011330: 6f6f 7264 7320 3d20 6469 6374 2866 3d66  oords = dict(f=f
+00011340: 290a 2020 2020 3e3e 3e20 666c 7578 5f64  ).    >>> flux_d
+00011350: 6174 6120 3d20 466c 7578 4461 7461 4172  ata = FluxDataAr
+00011360: 7261 7928 6e70 2e72 616e 646f 6d2e 7261  ray(np.random.ra
+00011370: 6e64 6f6d 2832 292c 2063 6f6f 7264 733d  ndom(2), coords=
+00011380: 636f 6f72 6473 290a 2020 2020 3e3e 3e20  coords).    >>> 
+00011390: 6d6f 6e69 746f 7220 3d20 466c 7578 4d6f  monitor = FluxMo
+000113a0: 6e69 746f 7228 7369 7a65 3d28 322c 302c  nitor(size=(2,0,
+000113b0: 3629 2c20 6672 6571 733d 5b32 6531 342c  6), freqs=[2e14,
+000113c0: 2033 6531 345d 2c20 6e61 6d65 3d27 666c   3e14], name='fl
+000113d0: 7578 2729 0a20 2020 203e 3e3e 2064 6174  ux').    >>> dat
+000113e0: 6120 3d20 466c 7578 4461 7461 286d 6f6e  a = FluxData(mon
+000113f0: 6974 6f72 3d6d 6f6e 6974 6f72 2c20 666c  itor=monitor, fl
+00011400: 7578 3d66 6c75 785f 6461 7461 290a 0a20  ux=flux_data).. 
+00011410: 2020 2053 6565 2041 6c73 6f0a 2020 2020     See Also.    
+00011420: 2d2d 2d2d 2d2d 2d2d 0a0a 2020 2020 2a2a  --------..    **
+00011430: 4e6f 7465 626f 6f6b 733a 2a2a 0a20 2020  Notebooks:**.   
+00011440: 2020 2020 202a 2060 4164 7661 6e63 6564       * `Advanced
+00011450: 206d 6f6e 6974 6f72 2064 6174 6120 6d61   monitor data ma
+00011460: 6e69 7075 6c61 7469 6f6e 2061 6e64 2076  nipulation and v
+00011470: 6973 7561 6c69 7a61 7469 6f6e 203c 2e2e  isualization <..
+00011480: 2f2e 2e2f 6e6f 7465 626f 6f6b 732f 5861  /../notebooks/Xa
+00011490: 7272 6179 5475 746f 7269 616c 2e68 746d  rrayTutorial.htm
+000114a0: 6c3e 605f 0a20 2020 2022 2222 0a0a 2020  l>`_.    """..  
+000114b0: 2020 6d6f 6e69 746f 723a 2046 6c75 784d    monitor: FluxM
+000114c0: 6f6e 6974 6f72 203d 2070 642e 4669 656c  onitor = pd.Fiel
+000114d0: 6428 0a20 2020 2020 2020 202e 2e2e 2c20  d(.        ..., 
+000114e0: 7469 746c 653d 224d 6f6e 6974 6f72 222c  title="Monitor",
+000114f0: 2064 6573 6372 6970 7469 6f6e 3d22 4672   description="Fr
+00011500: 6571 7565 6e63 792d 646f 6d61 696e 2066  equency-domain f
+00011510: 6c75 7820 6d6f 6e69 746f 7220 6173 736f  lux monitor asso
+00011520: 6369 6174 6564 2077 6974 6820 7468 6520  ciated with the 
+00011530: 6461 7461 2e22 0a20 2020 2029 0a0a 2020  data.".    )..  
+00011540: 2020 666c 7578 3a20 466c 7578 4461 7461    flux: FluxData
+00011550: 4172 7261 7920 3d20 7064 2e46 6965 6c64  Array = pd.Field
+00011560: 280a 2020 2020 2020 2020 2e2e 2e2c 2074  (.        ..., t
+00011570: 6974 6c65 3d22 466c 7578 222c 2064 6573  itle="Flux", des
+00011580: 6372 6970 7469 6f6e 3d22 466c 7578 2076  cription="Flux v
+00011590: 616c 7565 7320 696e 2074 6865 2066 7265  alues in the fre
+000115a0: 7175 656e 6379 2d64 6f6d 6169 6e2e 220a  quency-domain.".
+000115b0: 2020 2020 290a 0a20 2020 2064 6566 206e      )..    def n
+000115c0: 6f72 6d61 6c69 7a65 2873 656c 662c 2073  ormalize(self, s
+000115d0: 6f75 7263 655f 7370 6563 7472 756d 5f66  ource_spectrum_f
+000115e0: 6e29 202d 3e20 466c 7578 4461 7461 3a0a  n) -> FluxData:.
+000115f0: 2020 2020 2020 2020 2222 2252 6574 7572          """Retur
+00011600: 6e20 636f 7079 206f 6620 7365 6c66 2061  n copy of self a
+00011610: 6674 6572 206e 6f72 6d61 6c69 7a61 7469  fter normalizati
+00011620: 6f6e 2069 7320 6170 706c 6965 6420 7573  on is applied us
+00011630: 696e 6720 736f 7572 6365 2073 7065 6374  ing source spect
+00011640: 7275 6d20 6675 6e63 7469 6f6e 2e22 2222  rum function."""
+00011650: 0a20 2020 2020 2020 2073 6f75 7263 655f  .        source_
+00011660: 6672 6571 5f61 6d70 7320 3d20 736f 7572  freq_amps = sour
+00011670: 6365 5f73 7065 6374 7275 6d5f 666e 2873  ce_spectrum_fn(s
+00011680: 656c 662e 666c 7578 2e66 290a 2020 2020  elf.flux.f).    
+00011690: 2020 2020 736f 7572 6365 5f70 6f77 6572      source_power
+000116a0: 203d 2061 6273 2873 6f75 7263 655f 6672   = abs(source_fr
+000116b0: 6571 5f61 6d70 7329 202a 2a20 320a 2020  eq_amps) ** 2.  
+000116c0: 2020 2020 2020 6e65 775f 666c 7578 203d        new_flux =
+000116d0: 2028 7365 6c66 2e66 6c75 7820 2f20 736f   (self.flux / so
+000116e0: 7572 6365 5f70 6f77 6572 292e 6173 7479  urce_power).asty
+000116f0: 7065 2873 656c 662e 666c 7578 2e64 7479  pe(self.flux.dty
+00011700: 7065 290a 2020 2020 2020 2020 7265 7475  pe).        retu
+00011710: 726e 2073 656c 662e 636f 7079 2875 7064  rn self.copy(upd
+00011720: 6174 653d 6469 6374 2866 6c75 783d 6e65  ate=dict(flux=ne
+00011730: 775f 666c 7578 2929 0a0a 0a63 6c61 7373  w_flux))...class
+00011740: 2046 6c75 7854 696d 6544 6174 6128 4d6f   FluxTimeData(Mo
+00011750: 6e69 746f 7244 6174 6129 3a0a 2020 2020  nitorData):.    
+00011760: 2222 220a 2020 2020 4461 7461 2061 7373  """.    Data ass
+00011770: 6f63 6961 7465 6420 7769 7468 2061 203a  ociated with a :
+00011780: 636c 6173 733a 602e 466c 7578 5469 6d65  class:`.FluxTime
+00011790: 4d6f 6e69 746f 7260 3a20 666c 7578 2064  Monitor`: flux d
+000117a0: 6174 6120 696e 2074 6865 2074 696d 652d  ata in the time-
+000117b0: 646f 6d61 696e 2e0a 0a20 2020 204e 6f74  domain...    Not
+000117c0: 6573 0a20 2020 202d 2d2d 2d2d 0a0a 2020  es.    -----..  
+000117d0: 2020 2020 2020 5468 6520 6461 7461 2069        The data i
+000117e0: 7320 7374 6f72 6564 2061 7320 6120 6044  s stored as a `D
+000117f0: 6174 6141 7272 6179 203c 6874 7470 733a  ataArray <https:
+00011800: 2f2f 646f 6373 2e78 6172 7261 792e 6465  //docs.xarray.de
+00011810: 762f 656e 2f73 7461 626c 652f 6765 6e65  v/en/stable/gene
+00011820: 7261 7465 642f 7861 7272 6179 2e44 6174  rated/xarray.Dat
+00011830: 6141 7272 6179 2e68 746d 6c3e 605f 0a20  aArray.html>`_. 
+00011840: 2020 2020 2020 206f 626a 6563 7420 7573         object us
+00011850: 696e 6720 7468 6520 6078 6172 7261 7920  ing the `xarray 
+00011860: 3c68 7474 7073 3a2f 2f64 6f63 732e 7861  <https://docs.xa
+00011870: 7272 6179 2e64 6576 2f65 6e2f 7374 6162  rray.dev/en/stab
+00011880: 6c65 2f69 6e64 6578 2e68 746d 6c3e 605f  le/index.html>`_
+00011890: 2070 6163 6b61 6765 2e0a 0a20 2020 2045   package...    E
+000118a0: 7861 6d70 6c65 0a20 2020 202d 2d2d 2d2d  xample.    -----
+000118b0: 2d2d 0a20 2020 203e 3e3e 2066 726f 6d20  --.    >>> from 
+000118c0: 7469 6479 3364 2069 6d70 6f72 7420 466c  tidy3d import Fl
+000118d0: 7578 5469 6d65 4461 7461 4172 7261 790a  uxTimeDataArray.
+000118e0: 2020 2020 3e3e 3e20 7420 3d20 5b30 2c20      >>> t = [0, 
+000118f0: 3165 2d31 322c 2032 652d 3132 5d0a 2020  1e-12, 2e-12].  
+00011900: 2020 3e3e 3e20 636f 6f72 6473 203d 2064    >>> coords = d
+00011910: 6963 7428 743d 7429 0a20 2020 203e 3e3e  ict(t=t).    >>>
+00011920: 2066 6c75 785f 6461 7461 203d 2046 6c75   flux_data = Flu
+00011930: 7854 696d 6544 6174 6141 7272 6179 286e  xTimeDataArray(n
+00011940: 702e 7261 6e64 6f6d 2e72 616e 646f 6d28  p.random.random(
+00011950: 3329 2c20 636f 6f72 6473 3d63 6f6f 7264  3), coords=coord
+00011960: 7329 0a20 2020 203e 3e3e 206d 6f6e 6974  s).    >>> monit
+00011970: 6f72 203d 2046 6c75 7854 696d 654d 6f6e  or = FluxTimeMon
+00011980: 6974 6f72 2873 697a 653d 2832 2c30 2c36  itor(size=(2,0,6
+00011990: 292c 2069 6e74 6572 7661 6c3d 3130 302c  ), interval=100,
+000119a0: 206e 616d 653d 2766 6c75 785f 7469 6d65   name='flux_time
+000119b0: 2729 0a20 2020 203e 3e3e 2064 6174 6120  ').    >>> data 
+000119c0: 3d20 466c 7578 5469 6d65 4461 7461 286d  = FluxTimeData(m
+000119d0: 6f6e 6974 6f72 3d6d 6f6e 6974 6f72 2c20  onitor=monitor, 
+000119e0: 666c 7578 3d66 6c75 785f 6461 7461 290a  flux=flux_data).
+000119f0: 2020 2020 2222 220a 0a20 2020 206d 6f6e      """..    mon
+00011a00: 6974 6f72 3a20 466c 7578 5469 6d65 4d6f  itor: FluxTimeMo
+00011a10: 6e69 746f 7220 3d20 7064 2e46 6965 6c64  nitor = pd.Field
+00011a20: 280a 2020 2020 2020 2020 2e2e 2e2c 2074  (.        ..., t
+00011a30: 6974 6c65 3d22 4d6f 6e69 746f 7222 2c20  itle="Monitor", 
+00011a40: 6465 7363 7269 7074 696f 6e3d 2254 696d  description="Tim
+00011a50: 652d 646f 6d61 696e 2066 6c75 7820 6d6f  e-domain flux mo
+00011a60: 6e69 746f 7220 6173 736f 6369 6174 6564  nitor associated
+00011a70: 2077 6974 6820 7468 6520 6461 7461 2e22   with the data."
+00011a80: 0a20 2020 2029 0a0a 2020 2020 666c 7578  .    )..    flux
+00011a90: 3a20 466c 7578 5469 6d65 4461 7461 4172  : FluxTimeDataAr
+00011aa0: 7261 7920 3d20 7064 2e46 6965 6c64 280a  ray = pd.Field(.
+00011ab0: 2020 2020 2020 2020 2e2e 2e2c 2074 6974          ..., tit
+00011ac0: 6c65 3d22 466c 7578 222c 2064 6573 6372  le="Flux", descr
+00011ad0: 6970 7469 6f6e 3d22 466c 7578 2076 616c  iption="Flux val
+00011ae0: 7565 7320 696e 2074 6865 2074 696d 652d  ues in the time-
+00011af0: 646f 6d61 696e 2e22 0a20 2020 2029 0a0a  domain.".    )..
+00011b00: 0a50 726f 6a46 6965 6c64 5479 7065 203d  .ProjFieldType =
+00011b10: 2055 6e69 6f6e 5b0a 2020 2020 4669 656c   Union[.    Fiel
+00011b20: 6450 726f 6a65 6374 696f 6e41 6e67 6c65  dProjectionAngle
+00011b30: 4461 7461 4172 7261 792c 0a20 2020 2046  DataArray,.    F
+00011b40: 6965 6c64 5072 6f6a 6563 7469 6f6e 4361  ieldProjectionCa
+00011b50: 7274 6573 6961 6e44 6174 6141 7272 6179  rtesianDataArray
+00011b60: 2c0a 2020 2020 4669 656c 6450 726f 6a65  ,.    FieldProje
+00011b70: 6374 696f 6e4b 5370 6163 6544 6174 6141  ctionKSpaceDataA
+00011b80: 7272 6179 2c0a 2020 2020 4469 6666 7261  rray,.    Diffra
+00011b90: 6374 696f 6e44 6174 6141 7272 6179 2c0a  ctionDataArray,.
+00011ba0: 5d0a 0a50 726f 6a4d 6f6e 6974 6f72 5479  ]..ProjMonitorTy
+00011bb0: 7065 203d 2055 6e69 6f6e 5b0a 2020 2020  pe = Union[.    
+00011bc0: 4669 656c 6450 726f 6a65 6374 696f 6e41  FieldProjectionA
+00011bd0: 6e67 6c65 4d6f 6e69 746f 722c 0a20 2020  ngleMonitor,.   
+00011be0: 2046 6965 6c64 5072 6f6a 6563 7469 6f6e   FieldProjection
+00011bf0: 4361 7274 6573 6961 6e4d 6f6e 6974 6f72  CartesianMonitor
+00011c00: 2c0a 2020 2020 4669 656c 6450 726f 6a65  ,.    FieldProje
+00011c10: 6374 696f 6e4b 5370 6163 654d 6f6e 6974  ctionKSpaceMonit
+00011c20: 6f72 2c0a 2020 2020 4469 6666 7261 6374  or,.    Diffract
+00011c30: 696f 6e4d 6f6e 6974 6f72 2c0a 5d0a 0a0a  ionMonitor,.]...
+00011c40: 636c 6173 7320 4162 7374 7261 6374 4669  class AbstractFi
+00011c50: 656c 6450 726f 6a65 6374 696f 6e44 6174  eldProjectionDat
+00011c60: 6128 4d6f 6e69 746f 7244 6174 6129 3a0a  a(MonitorData):.
+00011c70: 2020 2020 2222 2243 6f6c 6c65 6374 696f      """Collectio
+00011c80: 6e20 6f66 2070 726f 6a65 6374 6564 2066  n of projected f
+00011c90: 6965 6c64 7320 696e 2073 7068 6572 6963  ields in spheric
+00011ca0: 616c 2063 6f6f 7264 696e 6174 6573 2069  al coordinates i
+00011cb0: 6e20 7468 6520 6672 6571 7565 6e63 7920  n the frequency 
+00011cc0: 646f 6d61 696e 2e22 2222 0a0a 2020 2020  domain."""..    
+00011cd0: 6d6f 6e69 746f 723a 2050 726f 6a4d 6f6e  monitor: ProjMon
+00011ce0: 6974 6f72 5479 7065 203d 2070 642e 4669  itorType = pd.Fi
+00011cf0: 656c 6428 0a20 2020 2020 2020 202e 2e2e  eld(.        ...
+00011d00: 2c0a 2020 2020 2020 2020 7469 746c 653d  ,.        title=
+00011d10: 2250 726f 6a65 6374 696f 6e20 6d6f 6e69  "Projection moni
+00011d20: 746f 7222 2c0a 2020 2020 2020 2020 6465  tor",.        de
+00011d30: 7363 7269 7074 696f 6e3d 2246 6965 6c64  scription="Field
+00011d40: 2070 726f 6a65 6374 696f 6e20 6d6f 6e69   projection moni
+00011d50: 746f 722e 222c 0a20 2020 2020 2020 2064  tor.",.        d
+00011d60: 6973 6372 696d 696e 6174 6f72 3d54 5950  iscriminator=TYP
+00011d70: 455f 5441 475f 5354 522c 0a20 2020 2029  E_TAG_STR,.    )
+00011d80: 0a0a 2020 2020 4572 3a20 5072 6f6a 4669  ..    Er: ProjFi
+00011d90: 656c 6454 7970 6520 3d20 7064 2e46 6965  eldType = pd.Fie
+00011da0: 6c64 280a 2020 2020 2020 2020 2e2e 2e2c  ld(.        ...,
+00011db0: 0a20 2020 2020 2020 2074 6974 6c65 3d22  .        title="
+00011dc0: 4570 6869 222c 0a20 2020 2020 2020 2064  Ephi",.        d
+00011dd0: 6573 6372 6970 7469 6f6e 3d22 5370 6174  escription="Spat
+00011de0: 6961 6c20 6469 7374 7269 6275 7469 6f6e  ial distribution
+00011df0: 206f 6620 722d 636f 6d70 6f6e 656e 7420   of r-component 
+00011e00: 6f66 2074 6865 2065 6c65 6374 7269 6320  of the electric 
+00011e10: 6669 656c 642e 222c 0a20 2020 2029 0a20  field.",.    ). 
+00011e20: 2020 2045 7468 6574 613a 2050 726f 6a46     Etheta: ProjF
+00011e30: 6965 6c64 5479 7065 203d 2070 642e 4669  ieldType = pd.Fi
+00011e40: 656c 6428 0a20 2020 2020 2020 202e 2e2e  eld(.        ...
+00011e50: 2c0a 2020 2020 2020 2020 7469 746c 653d  ,.        title=
+00011e60: 2245 7468 6574 6122 2c0a 2020 2020 2020  "Etheta",.      
+00011e70: 2020 6465 7363 7269 7074 696f 6e3d 2253    description="S
+00011e80: 7061 7469 616c 2064 6973 7472 6962 7574  patial distribut
+00011e90: 696f 6e20 6f66 2074 6865 2074 6865 7461  ion of the theta
+00011ea0: 2d63 6f6d 706f 6e65 6e74 206f 6620 7468  -component of th
+00011eb0: 6520 656c 6563 7472 6963 2066 6965 6c64  e electric field
+00011ec0: 2e22 2c0a 2020 2020 290a 2020 2020 4570  .",.    ).    Ep
+00011ed0: 6869 3a20 5072 6f6a 4669 656c 6454 7970  hi: ProjFieldTyp
+00011ee0: 6520 3d20 7064 2e46 6965 6c64 280a 2020  e = pd.Field(.  
+00011ef0: 2020 2020 2020 2e2e 2e2c 0a20 2020 2020        ...,.     
+00011f00: 2020 2074 6974 6c65 3d22 4570 6869 222c     title="Ephi",
+00011f10: 0a20 2020 2020 2020 2064 6573 6372 6970  .        descrip
+00011f20: 7469 6f6e 3d22 5370 6174 6961 6c20 6469  tion="Spatial di
+00011f30: 7374 7269 6275 7469 6f6e 206f 6620 7068  stribution of ph
+00011f40: 692d 636f 6d70 6f6e 656e 7420 6f66 2074  i-component of t
+00011f50: 6865 2065 6c65 6374 7269 6320 6669 656c  he electric fiel
+00011f60: 642e 222c 0a20 2020 2029 0a20 2020 2048  d.",.    ).    H
+00011f70: 723a 2050 726f 6a46 6965 6c64 5479 7065  r: ProjFieldType
+00011f80: 203d 2070 642e 4669 656c 6428 0a20 2020   = pd.Field(.   
+00011f90: 2020 2020 202e 2e2e 2c0a 2020 2020 2020       ...,.      
+00011fa0: 2020 7469 746c 653d 2248 7068 6922 2c0a    title="Hphi",.
+00011fb0: 2020 2020 2020 2020 6465 7363 7269 7074          descript
+00011fc0: 696f 6e3d 2253 7061 7469 616c 2064 6973  ion="Spatial dis
+00011fd0: 7472 6962 7574 696f 6e20 6f66 2072 2d63  tribution of r-c
+00011fe0: 6f6d 706f 6e65 6e74 206f 6620 7468 6520  omponent of the 
+00011ff0: 6d61 676e 6574 6963 2066 6965 6c64 2e22  magnetic field."
+00012000: 2c0a 2020 2020 290a 2020 2020 4874 6865  ,.    ).    Hthe
+00012010: 7461 3a20 5072 6f6a 4669 656c 6454 7970  ta: ProjFieldTyp
+00012020: 6520 3d20 7064 2e46 6965 6c64 280a 2020  e = pd.Field(.  
+00012030: 2020 2020 2020 2e2e 2e2c 0a20 2020 2020        ...,.     
+00012040: 2020 2074 6974 6c65 3d22 4874 6865 7461     title="Htheta
+00012050: 222c 0a20 2020 2020 2020 2064 6573 6372  ",.        descr
+00012060: 6970 7469 6f6e 3d22 5370 6174 6961 6c20  iption="Spatial 
+00012070: 6469 7374 7269 6275 7469 6f6e 206f 6620  distribution of 
+00012080: 7468 6574 612d 636f 6d70 6f6e 656e 7420  theta-component 
+00012090: 6f66 2074 6865 206d 6167 6e65 7469 6320  of the magnetic 
+000120a0: 6669 656c 642e 222c 0a20 2020 2029 0a20  field.",.    ). 
+000120b0: 2020 2048 7068 693a 2050 726f 6a46 6965     Hphi: ProjFie
+000120c0: 6c64 5479 7065 203d 2070 642e 4669 656c  ldType = pd.Fiel
+000120d0: 6428 0a20 2020 2020 2020 202e 2e2e 2c0a  d(.        ...,.
+000120e0: 2020 2020 2020 2020 7469 746c 653d 2248          title="H
+000120f0: 7068 6922 2c0a 2020 2020 2020 2020 6465  phi",.        de
+00012100: 7363 7269 7074 696f 6e3d 2253 7061 7469  scription="Spati
+00012110: 616c 2064 6973 7472 6962 7574 696f 6e20  al distribution 
+00012120: 6f66 2070 6869 2d63 6f6d 706f 6e65 6e74  of phi-component
+00012130: 206f 6620 7468 6520 6d61 676e 6574 6963   of the magnetic
+00012140: 2066 6965 6c64 2e22 2c0a 2020 2020 290a   field.",.    ).
+00012150: 0a20 2020 206d 6564 6975 6d3a 204d 6564  .    medium: Med
+00012160: 6975 6d54 7970 6520 3d20 7064 2e46 6965  iumType = pd.Fie
+00012170: 6c64 280a 2020 2020 2020 2020 4d65 6469  ld(.        Medi
+00012180: 756d 2829 2c0a 2020 2020 2020 2020 7469  um(),.        ti
+00012190: 746c 653d 2242 6163 6b67 726f 756e 6420  tle="Background 
+000121a0: 4d65 6469 756d 222c 0a20 2020 2020 2020  Medium",.       
+000121b0: 2064 6573 6372 6970 7469 6f6e 3d22 4261   description="Ba
+000121c0: 636b 6772 6f75 6e64 206d 6564 6975 6d20  ckground medium 
+000121d0: 7468 726f 7567 6820 7768 6963 6820 746f  through which to
+000121e0: 2070 726f 6a65 6374 2066 6965 6c64 732e   project fields.
+000121f0: 222c 0a20 2020 2020 2020 2064 6973 6372  ",.        discr
+00012200: 696d 696e 6174 6f72 3d54 5950 455f 5441  iminator=TYPE_TA
+00012210: 475f 5354 522c 0a20 2020 2029 0a0a 2020  G_STR,.    )..  
+00012220: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
+00012230: 6465 6620 6669 656c 645f 636f 6d70 6f6e  def field_compon
+00012240: 656e 7473 2873 656c 6629 202d 3e20 4469  ents(self) -> Di
+00012250: 6374 5b73 7472 2c20 4461 7461 4172 7261  ct[str, DataArra
+00012260: 795d 3a0a 2020 2020 2020 2020 2222 224d  y]:.        """M
+00012270: 6170 7320 7468 6520 6669 656c 6420 636f  aps the field co
+00012280: 6d70 6f6e 656e 7473 2074 6f20 7468 6569  mponents to thei
+00012290: 7220 6173 736f 6369 6174 6564 2064 6174  r associated dat
+000122a0: 612e 2222 220a 2020 2020 2020 2020 7265  a.""".        re
+000122b0: 7475 726e 2064 6963 7428 0a20 2020 2020  turn dict(.     
+000122c0: 2020 2020 2020 2045 723d 7365 6c66 2e45         Er=self.E
+000122d0: 722c 0a20 2020 2020 2020 2020 2020 2045  r,.            E
+000122e0: 7468 6574 613d 7365 6c66 2e45 7468 6574  theta=self.Ethet
+000122f0: 612c 0a20 2020 2020 2020 2020 2020 2045  a,.            E
+00012300: 7068 693d 7365 6c66 2e45 7068 692c 0a20  phi=self.Ephi,. 
+00012310: 2020 2020 2020 2020 2020 2048 723d 7365             Hr=se
+00012320: 6c66 2e48 722c 0a20 2020 2020 2020 2020  lf.Hr,.         
+00012330: 2020 2048 7468 6574 613d 7365 6c66 2e48     Htheta=self.H
+00012340: 7468 6574 612c 0a20 2020 2020 2020 2020  theta,.         
+00012350: 2020 2048 7068 693d 7365 6c66 2e48 7068     Hphi=self.Hph
+00012360: 692c 0a20 2020 2020 2020 2029 0a0a 2020  i,.        )..  
+00012370: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
+00012380: 6465 6620 6628 7365 6c66 2920 2d3e 206e  def f(self) -> n
+00012390: 702e 6e64 6172 7261 793a 0a20 2020 2020  p.ndarray:.     
+000123a0: 2020 2022 2222 4672 6571 7565 6e63 6965     """Frequencie
+000123b0: 732e 2222 220a 2020 2020 2020 2020 7265  s.""".        re
+000123c0: 7475 726e 206e 702e 6172 7261 7928 7365  turn np.array(se
+000123d0: 6c66 2e45 7468 6574 612e 636f 6f72 6473  lf.Etheta.coords
+000123e0: 5b22 6622 5d29 0a0a 2020 2020 4070 726f  ["f"])..    @pro
+000123f0: 7065 7274 790a 2020 2020 6465 6620 636f  perty.    def co
+00012400: 6f72 6473 2873 656c 6629 202d 3e20 4469  ords(self) -> Di
+00012410: 6374 5b73 7472 2c20 6e70 2e6e 6461 7272  ct[str, np.ndarr
+00012420: 6179 5d3a 0a20 2020 2020 2020 2022 2222  ay]:.        """
+00012430: 436f 6f72 6469 6e61 7465 7320 6f66 2074  Coordinates of t
+00012440: 6865 2066 6965 6c64 7320 636f 6e74 6169  he fields contai
+00012450: 6e65 642e 2222 220a 2020 2020 2020 2020  ned.""".        
+00012460: 7265 7475 726e 2073 656c 662e 4574 6865  return self.Ethe
+00012470: 7461 2e63 6f6f 7264 730a 0a20 2020 2040  ta.coords..    @
+00012480: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
+00012490: 2063 6f6f 7264 735f 7370 6865 7269 6361   coords_spherica
+000124a0: 6c28 7365 6c66 2920 2d3e 2044 6963 745b  l(self) -> Dict[
+000124b0: 7374 722c 206e 702e 6e64 6172 7261 795d  str, np.ndarray]
+000124c0: 3a0a 2020 2020 2020 2020 2222 2243 6f6f  :.        """Coo
+000124d0: 7264 696e 6174 6573 2067 7269 6420 666f  rdinates grid fo
+000124e0: 7220 7468 6520 6669 656c 6473 2069 6e20  r the fields in 
+000124f0: 7468 6520 7370 6865 7269 6361 6c20 7379  the spherical sy
+00012500: 7374 656d 2e22 2222 0a20 2020 2020 2020  stem.""".       
+00012510: 2069 6620 2274 6865 7461 2220 696e 2073   if "theta" in s
+00012520: 656c 662e 636f 6f72 6473 2e6b 6579 7328  elf.coords.keys(
+00012530: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
+00012540: 2c20 7468 6574 612c 2070 6869 203d 206e  , theta, phi = n
+00012550: 702e 6d65 7368 6772 6964 280a 2020 2020  p.meshgrid(.    
+00012560: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00012570: 2e63 6f6f 7264 735b 2272 225d 2e76 616c  .coords["r"].val
+00012580: 7565 732c 0a20 2020 2020 2020 2020 2020  ues,.           
+00012590: 2020 2020 2073 656c 662e 636f 6f72 6473       self.coords
+000125a0: 5b22 7468 6574 6122 5d2e 7661 6c75 6573  ["theta"].values
+000125b0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+000125c0: 2020 7365 6c66 2e63 6f6f 7264 735b 2270    self.coords["p
+000125d0: 6869 225d 2e76 616c 7565 732c 0a20 2020  hi"].values,.   
+000125e0: 2020 2020 2020 2020 2020 2020 2069 6e64               ind
+000125f0: 6578 696e 673d 2269 6a22 2c0a 2020 2020  exing="ij",.    
+00012600: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+00012610: 2020 656c 6966 2022 7a22 2069 6e20 7365    elif "z" in se
+00012620: 6c66 2e63 6f6f 7264 732e 6b65 7973 2829  lf.coords.keys()
+00012630: 3a0a 2020 2020 2020 2020 2020 2020 7873  :.            xs
+00012640: 2c20 7973 2c20 7a73 203d 206e 702e 6d65  , ys, zs = np.me
+00012650: 7368 6772 6964 280a 2020 2020 2020 2020  shgrid(.        
+00012660: 2020 2020 2020 2020 7365 6c66 2e63 6f6f          self.coo
+00012670: 7264 735b 2278 225d 2e76 616c 7565 732c  rds["x"].values,
+00012680: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00012690: 2073 656c 662e 636f 6f72 6473 5b22 7922   self.coords["y"
+000126a0: 5d2e 7661 6c75 6573 2c0a 2020 2020 2020  ].values,.      
+000126b0: 2020 2020 2020 2020 2020 7365 6c66 2e63            self.c
+000126c0: 6f6f 7264 735b 227a 225d 2e76 616c 7565  oords["z"].value
+000126d0: 732c 0a20 2020 2020 2020 2020 2020 2020  s,.             
+000126e0: 2020 2069 6e64 6578 696e 673d 2269 6a22     indexing="ij"
+000126f0: 2c0a 2020 2020 2020 2020 2020 2020 290a  ,.            ).
+00012700: 2020 2020 2020 2020 2020 2020 722c 2074              r, t
+00012710: 6865 7461 2c20 7068 6920 3d20 7365 6c66  heta, phi = self
+00012720: 2e6d 6f6e 6974 6f72 2e63 6172 5f32 5f73  .monitor.car_2_s
+00012730: 7068 2878 732c 2079 732c 207a 7329 0a20  ph(xs, ys, zs). 
+00012740: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00012750: 2020 2020 2020 2020 2075 7873 2c20 7579           uxs, uy
+00012760: 732c 2072 203d 206e 702e 6d65 7368 6772  s, r = np.meshgr
+00012770: 6964 280a 2020 2020 2020 2020 2020 2020  id(.            
+00012780: 2020 2020 7365 6c66 2e63 6f6f 7264 735b      self.coords[
+00012790: 2275 7822 5d2e 7661 6c75 6573 2c0a 2020  "ux"].values,.  
+000127a0: 2020 2020 2020 2020 2020 2020 2020 7365                se
+000127b0: 6c66 2e63 6f6f 7264 735b 2275 7922 5d2e  lf.coords["uy"].
+000127c0: 7661 6c75 6573 2c0a 2020 2020 2020 2020  values,.        
+000127d0: 2020 2020 2020 2020 7365 6c66 2e63 6f6f          self.coo
+000127e0: 7264 735b 2272 225d 2e76 616c 7565 732c  rds["r"].values,
+000127f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00012800: 2069 6e64 6578 696e 673d 2269 6a22 2c0a   indexing="ij",.
+00012810: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+00012820: 2020 2020 2020 2020 2020 7468 6574 612c            theta,
+00012830: 2070 6869 203d 2073 656c 662e 6d6f 6e69   phi = self.moni
+00012840: 746f 722e 6b73 7061 6365 5f32 5f73 7068  tor.kspace_2_sph
+00012850: 2875 7873 2c20 7579 732c 2073 656c 662e  (uxs, uys, self.
+00012860: 6d6f 6e69 746f 722e 7072 6f6a 5f61 7869  monitor.proj_axi
+00012870: 7329 0a20 2020 2020 2020 2072 6574 7572  s).        retur
+00012880: 6e20 7b22 7222 3a20 722c 2022 7468 6574  n {"r": r, "thet
+00012890: 6122 3a20 7468 6574 612c 2022 7068 6922  a": theta, "phi"
+000128a0: 3a20 7068 697d 0a0a 2020 2020 4070 726f  : phi}..    @pro
+000128b0: 7065 7274 790a 2020 2020 6465 6620 6469  perty.    def di
+000128c0: 6d73 2873 656c 6629 202d 3e20 5475 706c  ms(self) -> Tupl
+000128d0: 655b 7374 722c 202e 2e2e 5d3a 0a20 2020  e[str, ...]:.   
+000128e0: 2020 2020 2022 2222 4469 6d65 6e73 696f       """Dimensio
+000128f0: 6e73 206f 6620 7468 6520 7261 6469 6174  ns of the radiat
+00012900: 696f 6e20 7665 6374 6f72 7320 636f 6e74  ion vectors cont
+00012910: 6169 6e65 642e 2222 220a 2020 2020 2020  ained.""".      
+00012920: 2020 7265 7475 726e 2073 656c 662e 4574    return self.Et
+00012930: 6865 7461 2e64 696d 730a 0a20 2020 2064  heta.dims..    d
+00012940: 6566 206d 616b 655f 6461 7461 5f61 7272  ef make_data_arr
+00012950: 6179 2873 656c 662c 2064 6174 613a 206e  ay(self, data: n
+00012960: 702e 6e64 6172 7261 7929 202d 3e20 7872  p.ndarray) -> xr
+00012970: 2e44 6174 6141 7272 6179 3a0a 2020 2020  .DataArray:.    
+00012980: 2020 2020 2222 224d 616b 6520 616e 2078      """Make an x
+00012990: 722e 4461 7461 4172 7261 7920 7769 7468  r.DataArray with
+000129a0: 2064 6174 6120 616e 6420 7361 6d65 2063   data and same c
+000129b0: 6f6f 7264 7320 616e 6420 6469 6d73 2061  oords and dims a
+000129c0: 7320 6669 656c 6473 206f 6620 7365 6c66  s fields of self
+000129d0: 2e22 2222 0a20 2020 2020 2020 2072 6574  .""".        ret
+000129e0: 7572 6e20 7872 2e44 6174 6141 7272 6179  urn xr.DataArray
+000129f0: 2864 6174 613d 6461 7461 2c20 636f 6f72  (data=data, coor
+00012a00: 6473 3d73 656c 662e 636f 6f72 6473 2c20  ds=self.coords, 
+00012a10: 6469 6d73 3d73 656c 662e 6469 6d73 290a  dims=self.dims).
+00012a20: 0a20 2020 2064 6566 206d 616b 655f 6461  .    def make_da
+00012a30: 7461 7365 7428 7365 6c66 2c20 6b65 7973  taset(self, keys
+00012a40: 3a20 5475 706c 655b 7374 722c 202e 2e2e  : Tuple[str, ...
+00012a50: 5d2c 2076 616c 733a 2054 7570 6c65 5b6e  ], vals: Tuple[n
+00012a60: 702e 6e64 6172 7261 792c 202e 2e2e 5d29  p.ndarray, ...])
+00012a70: 202d 3e20 7872 2e44 6174 6173 6574 3a0a   -> xr.Dataset:.
+00012a80: 2020 2020 2020 2020 2222 224d 616b 6520          """Make 
+00012a90: 616e 2078 722e 4461 7461 7365 7420 7769  an xr.Dataset wi
+00012aa0: 7468 206b 6579 7320 616e 6420 6461 7461  th keys and data
+00012ab0: 2077 6974 6820 7361 6d65 2063 6f6f 7264   with same coord
+00012ac0: 7320 616e 6420 6469 6d73 2061 7320 6669  s and dims as fi
+00012ad0: 656c 6473 2e22 2222 0a20 2020 2020 2020  elds.""".       
+00012ae0: 2064 6174 615f 6172 7261 7973 203d 2074   data_arrays = t
+00012af0: 7570 6c65 286d 6170 2873 656c 662e 6d61  uple(map(self.ma
+00012b00: 6b65 5f64 6174 615f 6172 7261 792c 2076  ke_data_array, v
+00012b10: 616c 7329 290a 2020 2020 2020 2020 7265  als)).        re
+00012b20: 7475 726e 2078 722e 4461 7461 7365 7428  turn xr.Dataset(
+00012b30: 6469 6374 287a 6970 286b 6579 732c 2064  dict(zip(keys, d
+00012b40: 6174 615f 6172 7261 7973 2929 290a 0a20  ata_arrays))).. 
+00012b50: 2020 2064 6566 206d 616b 655f 7265 6e6f     def make_reno
+00012b60: 726d 616c 697a 6564 5f64 6174 6128 0a20  rmalized_data(. 
+00012b70: 2020 2020 2020 2073 656c 662c 2070 6861         self, pha
+00012b80: 7365 3a20 6e70 2e6e 6461 7272 6179 2c20  se: np.ndarray, 
+00012b90: 7072 6f6a 5f64 6973 7461 6e63 653a 2066  proj_distance: f
+00012ba0: 6c6f 6174 0a20 2020 2029 202d 3e20 4162  loat.    ) -> Ab
+00012bb0: 7374 7261 6374 4669 656c 6450 726f 6a65  stractFieldProje
+00012bc0: 6374 696f 6e44 6174 613a 0a20 2020 2020  ctionData:.     
+00012bd0: 2020 2022 2222 4865 6c70 6572 2074 6f20     """Helper to 
+00012be0: 6170 706c 7920 7468 6520 7265 2d70 726f  apply the re-pro
+00012bf0: 6a65 6374 696f 6e20 7068 6173 6520 746f  jection phase to
+00012c00: 2061 2063 6f70 6965 6420 6461 7461 7365   a copied datase
+00012c10: 742e 2222 220a 2020 2020 2020 2020 6e65  t.""".        ne
+00012c20: 775f 6461 7461 203d 2073 656c 662e 636f  w_data = self.co
+00012c30: 7079 2829 0a20 2020 2020 2020 2066 6f72  py().        for
+00012c40: 2066 6965 6c64 2069 6e20 6e65 775f 6461   field in new_da
+00012c50: 7461 2e66 6965 6c64 5f63 6f6d 706f 6e65  ta.field_compone
+00012c60: 6e74 732e 7661 6c75 6573 2829 3a0a 2020  nts.values():.  
+00012c70: 2020 2020 2020 2020 2020 6669 656c 642e            field.
+00012c80: 7661 6c75 6573 202a 3d20 7068 6173 650a  values *= phase.
+00012c90: 2020 2020 2020 2020 2020 2020 6966 2022              if "
+00012ca0: 7222 2069 6e20 7365 6c66 2e63 6f6f 7264  r" in self.coord
+00012cb0: 732e 6b65 7973 2829 3a0a 2020 2020 2020  s.keys():.      
+00012cc0: 2020 2020 2020 2020 2020 6669 656c 645b            field[
+00012cd0: 2272 225d 203d 206e 702e 6174 6c65 6173  "r"] = np.atleas
+00012ce0: 745f 3164 2870 726f 6a5f 6469 7374 616e  t_1d(proj_distan
+00012cf0: 6365 290a 2020 2020 2020 2020 7265 7475  ce).        retu
+00012d00: 726e 206e 6577 5f64 6174 610a 0a20 2020  rn new_data..   
+00012d10: 2064 6566 206e 6f72 6d61 6c69 7a65 280a   def normalize(.
+00012d20: 2020 2020 2020 2020 7365 6c66 2c20 736f          self, so
+00012d30: 7572 6365 5f73 7065 6374 7275 6d5f 666e  urce_spectrum_fn
+00012d40: 3a20 4361 6c6c 6162 6c65 5b5b 666c 6f61  : Callable[[floa
+00012d50: 745d 2c20 636f 6d70 6c65 785d 0a20 2020  t], complex].   
+00012d60: 2029 202d 3e20 4162 7374 7261 6374 4669   ) -> AbstractFi
+00012d70: 656c 6450 726f 6a65 6374 696f 6e44 6174  eldProjectionDat
+00012d80: 613a 0a20 2020 2020 2020 2022 2222 5265  a:.        """Re
+00012d90: 7475 726e 2063 6f70 7920 6f66 2073 656c  turn copy of sel
+00012da0: 6620 6166 7465 7220 6e6f 726d 616c 697a  f after normaliz
+00012db0: 6174 696f 6e20 6973 2061 7070 6c69 6564  ation is applied
+00012dc0: 2075 7369 6e67 2073 6f75 7263 6520 7370   using source sp
+00012dd0: 6563 7472 756d 2066 756e 6374 696f 6e2e  ectrum function.
+00012de0: 2222 220a 2020 2020 2020 2020 6669 656c  """.        fiel
+00012df0: 6473 5f6e 6f72 6d20 3d20 7b7d 0a20 2020  ds_norm = {}.   
+00012e00: 2020 2020 2066 6f72 2066 6965 6c64 5f6e       for field_n
+00012e10: 616d 652c 2066 6965 6c64 5f64 6174 6120  ame, field_data 
+00012e20: 696e 2073 656c 662e 6669 656c 645f 636f  in self.field_co
+00012e30: 6d70 6f6e 656e 7473 2e69 7465 6d73 2829  mponents.items()
+00012e40: 3a0a 2020 2020 2020 2020 2020 2020 7372  :.            sr
+00012e50: 635f 616d 7073 203d 2073 6f75 7263 655f  c_amps = source_
+00012e60: 7370 6563 7472 756d 5f66 6e28 6669 656c  spectrum_fn(fiel
+00012e70: 645f 6461 7461 2e66 290a 2020 2020 2020  d_data.f).      
+00012e80: 2020 2020 2020 6669 656c 6473 5f6e 6f72        fields_nor
+00012e90: 6d5b 6669 656c 645f 6e61 6d65 5d20 3d20  m[field_name] = 
+00012ea0: 2866 6965 6c64 5f64 6174 6120 2f20 7372  (field_data / sr
+00012eb0: 635f 616d 7073 292e 6173 7479 7065 2866  c_amps).astype(f
+00012ec0: 6965 6c64 5f64 6174 612e 6474 7970 6529  ield_data.dtype)
+00012ed0: 0a0a 2020 2020 2020 2020 7265 7475 726e  ..        return
+00012ee0: 2073 656c 662e 636f 7079 2875 7064 6174   self.copy(updat
+00012ef0: 653d 6669 656c 6473 5f6e 6f72 6d29 0a0a  e=fields_norm)..
+00012f00: 2020 2020 4073 7461 7469 636d 6574 686f      @staticmetho
+00012f10: 640a 2020 2020 6465 6620 7761 7665 6e75  d.    def wavenu
+00012f20: 6d62 6572 286d 6564 6975 6d3a 204d 6564  mber(medium: Med
+00012f30: 6975 6d54 7970 652c 2066 7265 7175 656e  iumType, frequen
+00012f40: 6379 3a20 666c 6f61 7429 202d 3e20 636f  cy: float) -> co
+00012f50: 6d70 6c65 783a 0a20 2020 2020 2020 2022  mplex:.        "
+00012f60: 2222 436f 6d70 6c65 7820 7661 6c75 6564  ""Complex valued
+00012f70: 2077 6176 656e 756d 6265 7220 6173 736f   wavenumber asso
+00012f80: 6369 6174 6564 2077 6974 6820 6120 6672  ciated with a fr
+00012f90: 6571 7565 6e63 792e 2222 220a 2020 2020  equency.""".    
+00012fa0: 2020 2020 696e 6465 785f 6e2c 2069 6e64      index_n, ind
+00012fb0: 6578 5f6b 203d 206d 6564 6975 6d2e 6e6b  ex_k = medium.nk
+00012fc0: 5f6d 6f64 656c 2866 7265 7175 656e 6379  _model(frequency
+00012fd0: 3d66 7265 7175 656e 6379 290a 2020 2020  =frequency).    
+00012fe0: 2020 2020 7265 7475 726e 2028 3220 2a20      return (2 * 
+00012ff0: 6e70 2e70 6920 2a20 6672 6571 7565 6e63  np.pi * frequenc
+00013000: 7920 2f20 435f 3029 202a 2028 696e 6465  y / C_0) * (inde
+00013010: 785f 6e20 2b20 316a 202a 2069 6e64 6578  x_n + 1j * index
+00013020: 5f6b 290a 0a20 2020 2040 7072 6f70 6572  _k)..    @proper
+00013030: 7479 0a20 2020 2064 6566 206e 6b28 7365  ty.    def nk(se
+00013040: 6c66 2920 2d3e 2054 7570 6c65 5b66 6c6f  lf) -> Tuple[flo
+00013050: 6174 2c20 666c 6f61 745d 3a0a 2020 2020  at, float]:.    
+00013060: 2020 2020 2222 2252 6574 7572 6e73 2074      """Returns t
+00013070: 6865 2072 6561 6c20 616e 6420 696d 6167  he real and imag
+00013080: 696e 6172 7920 7061 7274 7320 6f66 2074  inary parts of t
+00013090: 6865 2062 6163 6b67 726f 756e 6420 6d65  he background me
+000130a0: 6469 756d 2773 2072 6566 7261 6374 6976  dium's refractiv
+000130b0: 6520 696e 6465 782e 2222 220a 2020 2020  e index.""".    
+000130c0: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+000130d0: 6d65 6469 756d 2e6e 6b5f 6d6f 6465 6c28  medium.nk_model(
+000130e0: 6672 6571 7565 6e63 793d 7365 6c66 2e66  frequency=self.f
+000130f0: 290a 0a20 2020 2040 7072 6f70 6572 7479  )..    @property
+00013100: 0a20 2020 2064 6566 206b 2873 656c 6629  .    def k(self)
+00013110: 202d 3e20 636f 6d70 6c65 783a 0a20 2020   -> complex:.   
+00013120: 2020 2020 2022 2222 5265 7475 726e 7320       """Returns 
+00013130: 7468 6520 636f 6d70 6c65 7820 7761 7665  the complex wave
+00013140: 206e 756d 6265 7220 6173 736f 6369 6174   number associat
+00013150: 6564 2077 6974 6820 7468 6520 6261 636b  ed with the back
+00013160: 6772 6f75 6e64 206d 6564 6975 6d2e 2222  ground medium.""
+00013170: 220a 2020 2020 2020 2020 7265 7475 726e  ".        return
+00013180: 2073 656c 662e 7761 7665 6e75 6d62 6572   self.wavenumber
+00013190: 286d 6564 6975 6d3d 7365 6c66 2e6d 6564  (medium=self.med
+000131a0: 6975 6d2c 2066 7265 7175 656e 6379 3d73  ium, frequency=s
+000131b0: 656c 662e 6629 0a0a 2020 2020 4070 726f  elf.f)..    @pro
+000131c0: 7065 7274 790a 2020 2020 6465 6620 6574  perty.    def et
+000131d0: 6128 7365 6c66 2920 2d3e 2063 6f6d 706c  a(self) -> compl
+000131e0: 6578 3a0a 2020 2020 2020 2020 2222 2252  ex:.        """R
+000131f0: 6574 7572 6e73 2074 6865 2063 6f6d 706c  eturns the compl
+00013200: 6578 2077 6176 6520 696d 7065 6461 6e63  ex wave impedanc
+00013210: 6520 6173 736f 6369 6174 6564 2077 6974  e associated wit
+00013220: 6820 7468 6520 6261 636b 6772 6f75 6e64  h the background
+00013230: 206d 6564 6975 6d2e 2222 220a 2020 2020   medium.""".    
+00013240: 2020 2020 6570 735f 636f 6d70 6c65 7820      eps_complex 
+00013250: 3d20 7365 6c66 2e6d 6564 6975 6d2e 6570  = self.medium.ep
+00013260: 735f 6d6f 6465 6c28 6672 6571 7565 6e63  s_model(frequenc
+00013270: 793d 7365 6c66 2e66 290a 2020 2020 2020  y=self.f).      
+00013280: 2020 7265 7475 726e 2045 5441 5f30 202f    return ETA_0 /
+00013290: 206e 702e 7371 7274 2865 7073 5f63 6f6d   np.sqrt(eps_com
+000132a0: 706c 6578 290a 0a20 2020 2040 7374 6174  plex)..    @stat
+000132b0: 6963 6d65 7468 6f64 0a20 2020 2064 6566  icmethod.    def
+000132c0: 2070 726f 7061 6761 7469 6f6e 5f70 6861   propagation_pha
+000132d0: 7365 2864 6973 743a 2055 6e69 6f6e 5b66  se(dist: Union[f
+000132e0: 6c6f 6174 2c20 4e6f 6e65 5d2c 206b 3a20  loat, None], k: 
+000132f0: 636f 6d70 6c65 7829 202d 3e20 636f 6d70  complex) -> comp
+00013300: 6c65 783a 0a20 2020 2020 2020 2022 2222  lex:.        """
+00013310: 5068 6173 6520 6173 736f 6369 6174 6564  Phase associated
+00013320: 2077 6974 6820 7072 6f70 6167 6174 696f   with propagatio
+00013330: 6e20 6f66 2061 2064 6973 7461 6e63 6520  n of a distance 
+00013340: 7769 7468 2061 2067 6976 656e 2077 6176  with a given wav
+00013350: 656e 756d 6265 722e 2222 220a 2020 2020  enumber.""".    
+00013360: 2020 2020 6966 2064 6973 7420 6973 204e      if dist is N
+00013370: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+00013380: 2072 6574 7572 6e20 312e 300a 2020 2020   return 1.0.    
+00013390: 2020 2020 7265 7475 726e 202d 316a 202a      return -1j *
+000133a0: 206b 202a 206e 702e 6578 7028 316a 202a   k * np.exp(1j *
+000133b0: 206b 202a 2064 6973 7429 202f 2028 3420   k * dist) / (4 
+000133c0: 2a20 6e70 2e70 6920 2a20 6469 7374 290a  * np.pi * dist).
+000133d0: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
+000133e0: 2020 2064 6566 2066 6965 6c64 735f 7370     def fields_sp
+000133f0: 6865 7269 6361 6c28 7365 6c66 2920 2d3e  herical(self) ->
+00013400: 2078 722e 4461 7461 7365 743a 0a20 2020   xr.Dataset:.   
+00013410: 2020 2020 2022 2222 4765 7420 616c 6c20       """Get all 
+00013420: 6669 656c 6420 636f 6d70 6f6e 656e 7473  field components
+00013430: 2069 6e20 7370 6865 7269 6361 6c20 636f   in spherical co
+00013440: 6f72 6469 6e61 7465 7320 7265 6c61 7469  ordinates relati
+00013450: 7665 2074 6f20 7468 6520 6d6f 6e69 746f  ve to the monito
+00013460: 7227 730a 2020 2020 2020 2020 6c6f 6361  r's.        loca
+00013470: 6c20 6f72 6967 696e 2066 6f72 2061 6c6c  l origin for all
+00013480: 2070 726f 6a65 6374 696f 6e20 6772 6964   projection grid
+00013490: 2070 6f69 6e74 7320 616e 6420 6672 6571   points and freq
+000134a0: 7565 6e63 6965 7320 7370 6563 6966 6965  uencies specifie
+000134b0: 6420 696e 2074 6865 0a20 2020 2020 2020  d in the.       
+000134c0: 203a 636c 6173 733a 6041 6273 7472 6163   :class:`Abstrac
+000134d0: 7446 6965 6c64 5072 6f6a 6563 7469 6f6e  tFieldProjection
+000134e0: 4d6f 6e69 746f 7260 2e0a 0a20 2020 2020  Monitor`...     
+000134f0: 2020 2052 6574 7572 6e73 0a20 2020 2020     Returns.     
+00013500: 2020 202d 2d2d 2d2d 2d2d 0a20 2020 2020     -------.     
+00013510: 2020 2060 6078 6172 7261 792e 4461 7461     ``xarray.Data
+00013520: 7365 7460 600a 2020 2020 2020 2020 2020  set``.          
+00013530: 2020 7861 7272 6179 2064 6174 6173 6574    xarray dataset
+00013540: 2063 6f6e 7461 696e 696e 670a 2020 2020   containing.    
+00013550: 2020 2020 2020 2020 2860 6045 7260 602c          (``Er``,
+00013560: 2060 6045 7468 6574 6160 602c 2060 6045   ``Etheta``, ``E
+00013570: 7068 6960 602c 2060 6048 7260 602c 2060  phi``, ``Hr``, `
+00013580: 6048 7468 6574 6160 602c 2060 6048 7068  `Htheta``, ``Hph
+00013590: 6960 6029 0a20 2020 2020 2020 2020 2020  i``).           
+000135a0: 2069 6e20 7370 6865 7269 6361 6c20 636f   in spherical co
+000135b0: 6f72 6469 6e61 7465 732e 0a20 2020 2020  ordinates..     
+000135c0: 2020 2022 2222 0a20 2020 2020 2020 2072     """.        r
+000135d0: 6574 7572 6e20 7365 6c66 2e6d 616b 655f  eturn self.make_
+000135e0: 6461 7461 7365 7428 0a20 2020 2020 2020  dataset(.       
+000135f0: 2020 2020 206b 6579 733d 7365 6c66 2e66       keys=self.f
+00013600: 6965 6c64 5f63 6f6d 706f 6e65 6e74 732e  ield_components.
+00013610: 6b65 7973 2829 2c20 7661 6c73 3d73 656c  keys(), vals=sel
+00013620: 662e 6669 656c 645f 636f 6d70 6f6e 656e  f.field_componen
+00013630: 7473 2e76 616c 7565 7328 290a 2020 2020  ts.values().    
+00013640: 2020 2020 290a 0a20 2020 2040 7072 6f70      )..    @prop
+00013650: 6572 7479 0a20 2020 2064 6566 2066 6965  erty.    def fie
+00013660: 6c64 735f 6361 7274 6573 6961 6e28 7365  lds_cartesian(se
+00013670: 6c66 2920 2d3e 2078 722e 4461 7461 7365  lf) -> xr.Datase
+00013680: 743a 0a20 2020 2020 2020 2022 2222 4765  t:.        """Ge
+00013690: 7420 616c 6c20 6669 656c 6420 636f 6d70  t all field comp
+000136a0: 6f6e 656e 7473 2069 6e20 4361 7274 6573  onents in Cartes
+000136b0: 6961 6e20 636f 6f72 6469 6e61 7465 7320  ian coordinates 
+000136c0: 7265 6c61 7469 7665 2074 6f20 7468 6520  relative to the 
+000136d0: 6d6f 6e69 746f 7227 730a 2020 2020 2020  monitor's.      
+000136e0: 2020 6c6f 6361 6c20 6f72 6967 696e 2066    local origin f
+000136f0: 6f72 2061 6c6c 2070 726f 6a65 6374 696f  or all projectio
+00013700: 6e20 6772 6964 2070 6f69 6e74 7320 616e  n grid points an
+00013710: 6420 6672 6571 7565 6e63 6965 7320 7370  d frequencies sp
+00013720: 6563 6966 6965 6420 696e 2074 6865 0a20  ecified in the. 
+00013730: 2020 2020 2020 203a 636c 6173 733a 6041         :class:`A
+00013740: 6273 7472 6163 7446 6965 6c64 5072 6f6a  bstractFieldProj
+00013750: 6563 7469 6f6e 4d6f 6e69 746f 7260 2e0a  ectionMonitor`..
+00013760: 0a20 2020 2020 2020 2052 6574 7572 6e73  .        Returns
+00013770: 0a20 2020 2020 2020 202d 2d2d 2d2d 2d2d  .        -------
+00013780: 0a20 2020 2020 2020 2060 6078 6172 7261  .        ``xarra
+00013790: 792e 4461 7461 7365 7460 600a 2020 2020  y.Dataset``.    
+000137a0: 2020 2020 2020 2020 7861 7272 6179 2064          xarray d
+000137b0: 6174 6173 6574 2063 6f6e 7461 696e 696e  ataset containin
+000137c0: 6720 2860 6045 7860 602c 2060 6045 7960  g (``Ex``, ``Ey`
+000137d0: 602c 2060 6045 7a60 602c 2060 6048 7860  `, ``Ez``, ``Hx`
+000137e0: 602c 2060 6048 7960 602c 2060 6048 7a60  `, ``Hy``, ``Hz`
+000137f0: 6029 0a20 2020 2020 2020 2020 2020 2069  `).            i
+00013800: 6e20 4361 7274 6573 6961 6e20 636f 6f72  n Cartesian coor
+00013810: 6469 6e61 7465 732e 0a20 2020 2020 2020  dinates..       
+00013820: 2022 2222 0a20 2020 2020 2020 2023 2063   """.        # c
+00013830: 6f6e 7665 7274 2074 6865 2066 6965 6c64  onvert the field
+00013840: 2063 6f6d 706f 6e65 6e74 7320 746f 2074   components to t
+00013850: 6865 2043 6172 7465 7369 616e 2063 6f6f  he Cartesian coo
+00013860: 7264 696e 6174 6520 7379 7374 656d 0a20  rdinate system. 
+00013870: 2020 2020 2020 2063 6f6f 7264 735f 7370         coords_sp
+00013880: 6820 3d20 7365 6c66 2e63 6f6f 7264 735f  h = self.coords_
+00013890: 7370 6865 7269 6361 6c0a 2020 2020 2020  spherical.      
+000138a0: 2020 655f 6461 7461 203d 2073 656c 662e    e_data = self.
+000138b0: 6d6f 6e69 746f 722e 7370 685f 325f 6361  monitor.sph_2_ca
+000138c0: 725f 6669 656c 6428 0a20 2020 2020 2020  r_field(.       
+000138d0: 2020 2020 2073 656c 662e 4572 2e76 616c       self.Er.val
+000138e0: 7565 732c 0a20 2020 2020 2020 2020 2020  ues,.           
+000138f0: 2073 656c 662e 4574 6865 7461 2e76 616c   self.Etheta.val
+00013900: 7565 732c 0a20 2020 2020 2020 2020 2020  ues,.           
+00013910: 2073 656c 662e 4570 6869 2e76 616c 7565   self.Ephi.value
+00013920: 732c 0a20 2020 2020 2020 2020 2020 2063  s,.            c
+00013930: 6f6f 7264 735f 7370 685b 2274 6865 7461  oords_sph["theta
+00013940: 225d 5b2e 2e2e 2c20 4e6f 6e65 5d2c 0a20  "][..., None],. 
+00013950: 2020 2020 2020 2020 2020 2063 6f6f 7264             coord
+00013960: 735f 7370 685b 2270 6869 225d 5b2e 2e2e  s_sph["phi"][...
+00013970: 2c20 4e6f 6e65 5d2c 0a20 2020 2020 2020  , None],.       
+00013980: 2029 0a20 2020 2020 2020 2068 5f64 6174   ).        h_dat
+00013990: 6120 3d20 7365 6c66 2e6d 6f6e 6974 6f72  a = self.monitor
+000139a0: 2e73 7068 5f32 5f63 6172 5f66 6965 6c64  .sph_2_car_field
+000139b0: 280a 2020 2020 2020 2020 2020 2020 7365  (.            se
+000139c0: 6c66 2e48 722e 7661 6c75 6573 2c0a 2020  lf.Hr.values,.  
+000139d0: 2020 2020 2020 2020 2020 7365 6c66 2e48            self.H
+000139e0: 7468 6574 612e 7661 6c75 6573 2c0a 2020  theta.values,.  
+000139f0: 2020 2020 2020 2020 2020 7365 6c66 2e48            self.H
+00013a00: 7068 692e 7661 6c75 6573 2c0a 2020 2020  phi.values,.    
+00013a10: 2020 2020 2020 2020 636f 6f72 6473 5f73          coords_s
+00013a20: 7068 5b22 7468 6574 6122 5d5b 2e2e 2e2c  ph["theta"][...,
+00013a30: 204e 6f6e 655d 2c0a 2020 2020 2020 2020   None],.        
+00013a40: 2020 2020 636f 6f72 6473 5f73 7068 5b22      coords_sph["
+00013a50: 7068 6922 5d5b 2e2e 2e2c 204e 6f6e 655d  phi"][..., None]
+00013a60: 2c0a 2020 2020 2020 2020 290a 0a20 2020  ,.        )..   
+00013a70: 2020 2020 2023 2070 6163 6b61 6765 2069       # package i
+00013a80: 6e74 6f20 6461 7461 7365 740a 2020 2020  nto dataset.    
+00013a90: 2020 2020 6b65 7973 203d 2028 2245 7822      keys = ("Ex"
+00013aa0: 2c20 2245 7922 2c20 2245 7a22 2c20 2248  , "Ey", "Ez", "H
+00013ab0: 7822 2c20 2248 7922 2c20 2248 7a22 290a  x", "Hy", "Hz").
+00013ac0: 2020 2020 2020 2020 6669 656c 645f 636f          field_co
+00013ad0: 6d70 6f6e 656e 7473 203d 206e 702e 636f  mponents = np.co
+00013ae0: 6e63 6174 656e 6174 6528 2865 5f64 6174  ncatenate((e_dat
+00013af0: 612c 2068 5f64 6174 6129 2c20 6178 6973  a, h_data), axis
+00013b00: 3d30 290a 2020 2020 2020 2020 7265 7475  =0).        retu
+00013b10: 726e 2073 656c 662e 6d61 6b65 5f64 6174  rn self.make_dat
+00013b20: 6173 6574 286b 6579 733d 6b65 7973 2c20  aset(keys=keys, 
+00013b30: 7661 6c73 3d66 6965 6c64 5f63 6f6d 706f  vals=field_compo
+00013b40: 6e65 6e74 7329 0a0a 2020 2020 4070 726f  nents)..    @pro
+00013b50: 7065 7274 790a 2020 2020 6465 6620 706f  perty.    def po
+00013b60: 7765 7228 7365 6c66 2920 2d3e 2078 722e  wer(self) -> xr.
+00013b70: 4461 7461 4172 7261 793a 0a20 2020 2020  DataArray:.     
+00013b80: 2020 2022 2222 4765 7420 706f 7765 7220     """Get power 
+00013b90: 6d65 6173 7572 6564 206f 6e20 7468 6520  measured on the 
+00013ba0: 7072 6f6a 6563 7469 6f6e 2067 7269 6420  projection grid 
+00013bb0: 7265 6c61 7469 7665 2074 6f20 7468 6520  relative to the 
+00013bc0: 6d6f 6e69 746f 7227 7320 6c6f 6361 6c20  monitor's local 
+00013bd0: 6f72 6967 696e 2e0a 0a20 2020 2020 2020  origin...       
+00013be0: 2052 6574 7572 6e73 0a20 2020 2020 2020   Returns.       
+00013bf0: 202d 2d2d 2d2d 2d2d 0a20 2020 2020 2020   -------.       
+00013c00: 2060 6078 6172 7261 792e 4461 7461 4172   ``xarray.DataAr
+00013c10: 7261 7960 600a 2020 2020 2020 2020 2020  ray``.          
+00013c20: 2020 506f 7765 7220 6174 2070 6f69 6e74    Power at point
+00013c30: 7320 7265 6c61 7469 7665 2074 6f20 7468  s relative to th
+00013c40: 6520 6c6f 6361 6c20 6f72 6967 696e 2e0a  e local origin..
+00013c50: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00013c60: 2020 2020 706f 7765 725f 7468 6574 6120      power_theta 
+00013c70: 3d20 302e 3520 2a20 6e70 2e72 6561 6c28  = 0.5 * np.real(
+00013c80: 7365 6c66 2e45 7468 6574 612e 7661 6c75  self.Etheta.valu
+00013c90: 6573 202a 206e 702e 636f 6e6a 2873 656c  es * np.conj(sel
+00013ca0: 662e 4870 6869 2e76 616c 7565 7329 290a  f.Hphi.values)).
+00013cb0: 2020 2020 2020 2020 706f 7765 725f 7068          power_ph
+00013cc0: 6920 3d20 302e 3520 2a20 6e70 2e72 6561  i = 0.5 * np.rea
+00013cd0: 6c28 2d73 656c 662e 4570 6869 2e76 616c  l(-self.Ephi.val
+00013ce0: 7565 7320 2a20 6e70 2e63 6f6e 6a28 7365  ues * np.conj(se
+00013cf0: 6c66 2e48 7468 6574 612e 7661 6c75 6573  lf.Htheta.values
+00013d00: 2929 0a20 2020 2020 2020 2070 6f77 6572  )).        power
+00013d10: 203d 2070 6f77 6572 5f74 6865 7461 202b   = power_theta +
+00013d20: 2070 6f77 6572 5f70 6869 0a0a 2020 2020   power_phi..    
+00013d30: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+00013d40: 6d61 6b65 5f64 6174 615f 6172 7261 7928  make_data_array(
+00013d50: 6461 7461 3d70 6f77 6572 290a 0a20 2020  data=power)..   
+00013d60: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
+00013d70: 6566 2072 6164 6172 5f63 726f 7373 5f73  ef radar_cross_s
+00013d80: 6563 7469 6f6e 2873 656c 6629 202d 3e20  ection(self) -> 
+00013d90: 7872 2e44 6174 6141 7272 6179 3a0a 2020  xr.DataArray:.  
+00013da0: 2020 2020 2020 2222 2252 6164 6172 2063        """Radar c
+00013db0: 726f 7373 2073 6563 7469 6f6e 2069 6e20  ross section in 
+00013dc0: 756e 6974 7320 6f66 2069 6e63 6964 656e  units of inciden
+00013dd0: 7420 706f 7765 722e 2222 220a 0a20 2020  t power."""..   
+00013de0: 2020 2020 205f 2c20 696e 6465 785f 6b20       _, index_k 
+00013df0: 3d20 7365 6c66 2e6e 6b0a 2020 2020 2020  = self.nk.      
+00013e00: 2020 6966 206e 6f74 206e 702e 616c 6c28    if not np.all(
+00013e10: 696e 6465 785f 6b20 3d3d 2030 293a 0a20  index_k == 0):. 
+00013e20: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+00013e30: 2053 6574 7570 4572 726f 7228 2243 616e   SetupError("Can
+00013e40: 2774 2063 6f6d 7075 7465 2052 4353 2066  't compute RCS f
+00013e50: 6f72 2061 206c 6f73 7379 2062 6163 6b67  or a lossy backg
+00013e60: 726f 756e 6420 6d65 6469 756d 2e22 290a  round medium.").
+00013e70: 0a20 2020 2020 2020 206b 203d 2073 656c  .        k = sel
+00013e80: 662e 6b5b 4e6f 6e65 2c20 4e6f 6e65 2c20  f.k[None, None, 
+00013e90: 4e6f 6e65 2c20 2e2e 2e5d 0a20 2020 2020  None, ...].     
+00013ea0: 2020 2065 7461 203d 2073 656c 662e 6574     eta = self.et
+00013eb0: 615b 4e6f 6e65 2c20 4e6f 6e65 2c20 4e6f  a[None, None, No
+00013ec0: 6e65 2c20 2e2e 2e5d 0a0a 2020 2020 2020  ne, ...]..      
+00013ed0: 2020 636f 6e73 7461 6e74 203d 206b 2a2a    constant = k**
+00013ee0: 3220 2f20 2838 202a 206e 702e 7069 202a  2 / (8 * np.pi *
+00013ef0: 2065 7461 290a 0a20 2020 2020 2020 2023   eta)..        #
+00013f00: 206e 6f72 6d61 6c69 7a65 2066 6965 6c64   normalize field
+00013f10: 7320 6279 2074 6865 2064 6973 7461 6e63  s by the distanc
+00013f20: 652d 6261 7365 6420 7068 6173 6520 6661  e-based phase fa
+00013f30: 6374 6f72 0a20 2020 2020 2020 2063 6f6f  ctor.        coo
+00013f40: 7264 735f 7370 6820 3d20 7365 6c66 2e63  rds_sph = self.c
+00013f50: 6f6f 7264 735f 7370 6865 7269 6361 6c0a  oords_spherical.
+00013f60: 2020 2020 2020 2020 6966 2063 6f6f 7264          if coord
+00013f70: 735f 7370 685b 2272 225d 2069 7320 4e6f  s_sph["r"] is No
+00013f80: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
+00013f90: 7068 6173 6520 3d20 312e 300a 2020 2020  phase = 1.0.    
+00013fa0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00013fb0: 2020 2020 2020 7068 6173 6520 3d20 7365        phase = se
+00013fc0: 6c66 2e70 726f 7061 6761 7469 6f6e 5f70  lf.propagation_p
+00013fd0: 6861 7365 2864 6973 743d 636f 6f72 6473  hase(dist=coords
+00013fe0: 5f73 7068 5b22 7222 5d5b 2e2e 2e2c 204e  _sph["r"][..., N
+00013ff0: 6f6e 655d 2c20 6b3d 6b29 0a20 2020 2020  one], k=k).     
+00014000: 2020 2045 7468 6574 6120 3d20 7365 6c66     Etheta = self
+00014010: 2e45 7468 6574 612e 7661 6c75 6573 202f  .Etheta.values /
+00014020: 2070 6861 7365 0a20 2020 2020 2020 2045   phase.        E
+00014030: 7068 6920 3d20 7365 6c66 2e45 7068 692e  phi = self.Ephi.
+00014040: 7661 6c75 6573 202f 2070 6861 7365 0a20  values / phase. 
+00014050: 2020 2020 2020 2072 6373 5f64 6174 6120         rcs_data 
+00014060: 3d20 636f 6e73 7461 6e74 202a 2028 6e70  = constant * (np
+00014070: 2e61 6273 2845 7468 6574 6129 202a 2a20  .abs(Etheta) ** 
+00014080: 3220 2b20 6e70 2e61 6273 2845 7068 6929  2 + np.abs(Ephi)
+00014090: 202a 2a20 3229 0a0a 2020 2020 2020 2020   ** 2)..        
+000140a0: 7265 7475 726e 2073 656c 662e 6d61 6b65  return self.make
+000140b0: 5f64 6174 615f 6172 7261 7928 6461 7461  _data_array(data
+000140c0: 3d72 6373 5f64 6174 6129 0a0a 0a63 6c61  =rcs_data)...cla
+000140d0: 7373 2046 6965 6c64 5072 6f6a 6563 7469  ss FieldProjecti
+000140e0: 6f6e 416e 676c 6544 6174 6128 4162 7374  onAngleData(Abst
+000140f0: 7261 6374 4669 656c 6450 726f 6a65 6374  ractFieldProject
+00014100: 696f 6e44 6174 6129 3a0a 2020 2020 2222  ionData):.    ""
+00014110: 2244 6174 6120 6173 736f 6369 6174 6564  "Data associated
+00014120: 2077 6974 6820 6120 3a63 6c61 7373 3a60   with a :class:`
+00014130: 2e46 6965 6c64 5072 6f6a 6563 7469 6f6e  .FieldProjection
+00014140: 416e 676c 654d 6f6e 6974 6f72 603a 2063  AngleMonitor`: c
+00014150: 6f6d 706f 6e65 6e74 7320 6f66 2070 726f  omponents of pro
+00014160: 6a65 6374 6564 2066 6965 6c64 732e 0a0a  jected fields...
+00014170: 2020 2020 4578 616d 706c 650a 2020 2020      Example.    
+00014180: 2d2d 2d2d 2d2d 2d0a 2020 2020 3e3e 3e20  -------.    >>> 
+00014190: 6672 6f6d 2074 6964 7933 6420 696d 706f  from tidy3d impo
+000141a0: 7274 2046 6965 6c64 5072 6f6a 6563 7469  rt FieldProjecti
+000141b0: 6f6e 416e 676c 6544 6174 6141 7272 6179  onAngleDataArray
+000141c0: 0a20 2020 203e 3e3e 2066 203d 206e 702e  .    >>> f = np.
+000141d0: 6c69 6e73 7061 6365 2831 6531 342c 2032  linspace(1e14, 2
+000141e0: 6531 342c 2031 3029 0a20 2020 203e 3e3e  e14, 10).    >>>
+000141f0: 2072 203d 206e 702e 6174 6c65 6173 745f   r = np.atleast_
+00014200: 3164 2835 290a 2020 2020 3e3e 3e20 7468  1d(5).    >>> th
+00014210: 6574 6120 3d20 6e70 2e6c 696e 7370 6163  eta = np.linspac
+00014220: 6528 302c 206e 702e 7069 2c20 3130 290a  e(0, np.pi, 10).
+00014230: 2020 2020 3e3e 3e20 7068 6920 3d20 6e70      >>> phi = np
+00014240: 2e6c 696e 7370 6163 6528 302c 2032 2a6e  .linspace(0, 2*n
+00014250: 702e 7069 2c20 3230 290a 2020 2020 3e3e  p.pi, 20).    >>
+00014260: 3e20 636f 6f72 6473 203d 2064 6963 7428  > coords = dict(
+00014270: 723d 722c 2074 6865 7461 3d74 6865 7461  r=r, theta=theta
+00014280: 2c20 7068 693d 7068 692c 2066 3d66 290a  , phi=phi, f=f).
+00014290: 2020 2020 3e3e 3e20 7661 6c75 6573 203d      >>> values =
+000142a0: 2028 312b 316a 2920 2a20 6e70 2e72 616e   (1+1j) * np.ran
+000142b0: 646f 6d2e 7261 6e64 6f6d 2828 6c65 6e28  dom.random((len(
+000142c0: 7229 2c20 6c65 6e28 7468 6574 6129 2c20  r), len(theta), 
+000142d0: 6c65 6e28 7068 6929 2c20 6c65 6e28 6629  len(phi), len(f)
+000142e0: 2929 0a20 2020 203e 3e3e 2073 6361 6c61  )).    >>> scala
+000142f0: 725f 6669 656c 6420 3d20 4669 656c 6450  r_field = FieldP
+00014300: 726f 6a65 6374 696f 6e41 6e67 6c65 4461  rojectionAngleDa
+00014310: 7461 4172 7261 7928 7661 6c75 6573 2c20  taArray(values, 
+00014320: 636f 6f72 6473 3d63 6f6f 7264 7329 0a20  coords=coords). 
+00014330: 2020 203e 3e3e 206d 6f6e 6974 6f72 203d     >>> monitor =
+00014340: 2046 6965 6c64 5072 6f6a 6563 7469 6f6e   FieldProjection
+00014350: 416e 676c 654d 6f6e 6974 6f72 280a 2020  AngleMonitor(.  
+00014360: 2020 2e2e 2e20 2020 2020 6365 6e74 6572    ...     center
+00014370: 3d28 312c 322c 3329 2c20 7369 7a65 3d28  =(1,2,3), size=(
+00014380: 322c 322c 3229 2c20 6672 6571 733d 662c  2,2,2), freqs=f,
+00014390: 206e 616d 653d 276e 3266 5f6d 6f6e 6974   name='n2f_monit
+000143a0: 6f72 272c 2070 6869 3d70 6869 2c20 7468  or', phi=phi, th
+000143b0: 6574 613d 7468 6574 610a 2020 2020 2e2e  eta=theta.    ..
+000143c0: 2e20 2020 2020 290a 2020 2020 3e3e 3e20  .     ).    >>> 
+000143d0: 6461 7461 203d 2046 6965 6c64 5072 6f6a  data = FieldProj
+000143e0: 6563 7469 6f6e 416e 676c 6544 6174 6128  ectionAngleData(
+000143f0: 0a20 2020 202e 2e2e 2020 2020 206d 6f6e  .    ...     mon
+00014400: 6974 6f72 3d6d 6f6e 6974 6f72 2c20 4572  itor=monitor, Er
+00014410: 3d73 6361 6c61 725f 6669 656c 642c 2045  =scalar_field, E
+00014420: 7468 6574 613d 7363 616c 6172 5f66 6965  theta=scalar_fie
+00014430: 6c64 2c20 4570 6869 3d73 6361 6c61 725f  ld, Ephi=scalar_
+00014440: 6669 656c 642c 0a20 2020 202e 2e2e 2020  field,.    ...  
+00014450: 2020 2048 723d 7363 616c 6172 5f66 6965     Hr=scalar_fie
+00014460: 6c64 2c20 4874 6865 7461 3d73 6361 6c61  ld, Htheta=scala
+00014470: 725f 6669 656c 642c 2048 7068 693d 7363  r_field, Hphi=sc
+00014480: 616c 6172 5f66 6965 6c64 2c0a 2020 2020  alar_field,.    
+00014490: 2e2e 2e20 2020 2020 7072 6f6a 6563 7469  ...     projecti
+000144a0: 6f6e 5f73 7572 6661 6365 733d 6d6f 6e69  on_surfaces=moni
+000144b0: 746f 722e 7072 6f6a 6563 7469 6f6e 5f73  tor.projection_s
+000144c0: 7572 6661 6365 732c 0a20 2020 202e 2e2e  urfaces,.    ...
+000144d0: 2020 2020 2029 0a20 2020 2022 2222 0a0a       ).    """..
+000144e0: 2020 2020 6d6f 6e69 746f 723a 2046 6965      monitor: Fie
+000144f0: 6c64 5072 6f6a 6563 7469 6f6e 416e 676c  ldProjectionAngl
+00014500: 654d 6f6e 6974 6f72 203d 2070 642e 4669  eMonitor = pd.Fi
+00014510: 656c 6428 0a20 2020 2020 2020 202e 2e2e  eld(.        ...
+00014520: 2c0a 2020 2020 2020 2020 7469 746c 653d  ,.        title=
+00014530: 2250 726f 6a65 6374 696f 6e20 6d6f 6e69  "Projection moni
+00014540: 746f 7222 2c0a 2020 2020 2020 2020 6465  tor",.        de
+00014550: 7363 7269 7074 696f 6e3d 2246 6965 6c64  scription="Field
+00014560: 2070 726f 6a65 6374 696f 6e20 6d6f 6e69   projection moni
+00014570: 746f 7220 7769 7468 2061 6e20 616e 676c  tor with an angl
+00014580: 652d 6261 7365 6420 7072 6f6a 6563 7469  e-based projecti
+00014590: 6f6e 2067 7269 642e 222c 0a20 2020 2029  on grid.",.    )
+000145a0: 0a0a 2020 2020 7072 6f6a 6563 7469 6f6e  ..    projection
+000145b0: 5f73 7572 6661 6365 733a 2054 7570 6c65  _surfaces: Tuple
+000145c0: 5b46 6965 6c64 5072 6f6a 6563 7469 6f6e  [FieldProjection
+000145d0: 5375 7266 6163 652c 202e 2e2e 5d20 3d20  Surface, ...] = 
+000145e0: 7064 2e46 6965 6c64 280a 2020 2020 2020  pd.Field(.      
+000145f0: 2020 2e2e 2e2c 0a20 2020 2020 2020 2074    ...,.        t
+00014600: 6974 6c65 3d22 5072 6f6a 6563 7469 6f6e  itle="Projection
+00014610: 2073 7572 6661 6365 7322 2c0a 2020 2020   surfaces",.    
+00014620: 2020 2020 6465 7363 7269 7074 696f 6e3d      description=
+00014630: 2253 7572 6661 6365 7320 6f66 2074 6865  "Surfaces of the
+00014640: 206d 6f6e 6974 6f72 2077 6865 7265 206e   monitor where n
+00014650: 6561 7220 6669 656c 6473 2077 6572 6520  ear fields were 
+00014660: 7265 636f 7264 6564 2066 6f72 2070 726f  recorded for pro
+00014670: 6a65 6374 696f 6e22 2c0a 2020 2020 290a  jection",.    ).
+00014680: 0a20 2020 2045 723a 2046 6965 6c64 5072  .    Er: FieldPr
+00014690: 6f6a 6563 7469 6f6e 416e 676c 6544 6174  ojectionAngleDat
+000146a0: 6141 7272 6179 203d 2070 642e 4669 656c  aArray = pd.Fiel
+000146b0: 6428 0a20 2020 2020 2020 202e 2e2e 2c0a  d(.        ...,.
+000146c0: 2020 2020 2020 2020 7469 746c 653d 2245          title="E
+000146d0: 7222 2c0a 2020 2020 2020 2020 6465 7363  r",.        desc
+000146e0: 7269 7074 696f 6e3d 2253 7061 7469 616c  ription="Spatial
+000146f0: 2064 6973 7472 6962 7574 696f 6e20 6f66   distribution of
+00014700: 2072 2d63 6f6d 706f 6e65 6e74 206f 6620   r-component of 
+00014710: 7468 6520 656c 6563 7472 6963 2066 6965  the electric fie
+00014720: 6c64 2e22 2c0a 2020 2020 290a 2020 2020  ld.",.    ).    
+00014730: 4574 6865 7461 3a20 4669 656c 6450 726f  Etheta: FieldPro
+00014740: 6a65 6374 696f 6e41 6e67 6c65 4461 7461  jectionAngleData
+00014750: 4172 7261 7920 3d20 7064 2e46 6965 6c64  Array = pd.Field
+00014760: 280a 2020 2020 2020 2020 2e2e 2e2c 0a20  (.        ...,. 
+00014770: 2020 2020 2020 2074 6974 6c65 3d22 4574         title="Et
+00014780: 6865 7461 222c 0a20 2020 2020 2020 2064  heta",.        d
+00014790: 6573 6372 6970 7469 6f6e 3d22 5370 6174  escription="Spat
+000147a0: 6961 6c20 6469 7374 7269 6275 7469 6f6e  ial distribution
+000147b0: 206f 6620 7468 6520 7468 6574 612d 636f   of the theta-co
+000147c0: 6d70 6f6e 656e 7420 6f66 2074 6865 2065  mponent of the e
+000147d0: 6c65 6374 7269 6320 6669 656c 642e 222c  lectric field.",
+000147e0: 0a20 2020 2029 0a20 2020 2045 7068 693a  .    ).    Ephi:
+000147f0: 2046 6965 6c64 5072 6f6a 6563 7469 6f6e   FieldProjection
+00014800: 416e 676c 6544 6174 6141 7272 6179 203d  AngleDataArray =
+00014810: 2070 642e 4669 656c 6428 0a20 2020 2020   pd.Field(.     
+00014820: 2020 202e 2e2e 2c0a 2020 2020 2020 2020     ...,.        
+00014830: 7469 746c 653d 2245 7068 6922 2c0a 2020  title="Ephi",.  
+00014840: 2020 2020 2020 6465 7363 7269 7074 696f        descriptio
+00014850: 6e3d 2253 7061 7469 616c 2064 6973 7472  n="Spatial distr
+00014860: 6962 7574 696f 6e20 6f66 2070 6869 2d63  ibution of phi-c
+00014870: 6f6d 706f 6e65 6e74 206f 6620 7468 6520  omponent of the 
+00014880: 656c 6563 7472 6963 2066 6965 6c64 2e22  electric field."
+00014890: 2c0a 2020 2020 290a 2020 2020 4872 3a20  ,.    ).    Hr: 
+000148a0: 4669 656c 6450 726f 6a65 6374 696f 6e41  FieldProjectionA
+000148b0: 6e67 6c65 4461 7461 4172 7261 7920 3d20  ngleDataArray = 
+000148c0: 7064 2e46 6965 6c64 280a 2020 2020 2020  pd.Field(.      
+000148d0: 2020 2e2e 2e2c 0a20 2020 2020 2020 2074    ...,.        t
+000148e0: 6974 6c65 3d22 4872 222c 0a20 2020 2020  itle="Hr",.     
+000148f0: 2020 2064 6573 6372 6970 7469 6f6e 3d22     description="
+00014900: 5370 6174 6961 6c20 6469 7374 7269 6275  Spatial distribu
+00014910: 7469 6f6e 206f 6620 722d 636f 6d70 6f6e  tion of r-compon
+00014920: 656e 7420 6f66 2074 6865 206d 6167 6e65  ent of the magne
+00014930: 7469 6320 6669 656c 642e 222c 0a20 2020  tic field.",.   
+00014940: 2029 0a20 2020 2048 7468 6574 613a 2046   ).    Htheta: F
+00014950: 6965 6c64 5072 6f6a 6563 7469 6f6e 416e  ieldProjectionAn
+00014960: 676c 6544 6174 6141 7272 6179 203d 2070  gleDataArray = p
+00014970: 642e 4669 656c 6428 0a20 2020 2020 2020  d.Field(.       
+00014980: 202e 2e2e 2c0a 2020 2020 2020 2020 7469   ...,.        ti
+00014990: 746c 653d 2248 7468 6574 6122 2c0a 2020  tle="Htheta",.  
+000149a0: 2020 2020 2020 6465 7363 7269 7074 696f        descriptio
+000149b0: 6e3d 2253 7061 7469 616c 2064 6973 7472  n="Spatial distr
+000149c0: 6962 7574 696f 6e20 6f66 2074 6865 7461  ibution of theta
+000149d0: 2d63 6f6d 706f 6e65 6e74 206f 6620 7468  -component of th
+000149e0: 6520 6d61 676e 6574 6963 2066 6965 6c64  e magnetic field
+000149f0: 2e22 2c0a 2020 2020 290a 2020 2020 4870  .",.    ).    Hp
+00014a00: 6869 3a20 4669 656c 6450 726f 6a65 6374  hi: FieldProject
+00014a10: 696f 6e41 6e67 6c65 4461 7461 4172 7261  ionAngleDataArra
+00014a20: 7920 3d20 7064 2e46 6965 6c64 280a 2020  y = pd.Field(.  
+00014a30: 2020 2020 2020 2e2e 2e2c 0a20 2020 2020        ...,.     
+00014a40: 2020 2074 6974 6c65 3d22 4870 6869 222c     title="Hphi",
+00014a50: 0a20 2020 2020 2020 2064 6573 6372 6970  .        descrip
+00014a60: 7469 6f6e 3d22 5370 6174 6961 6c20 6469  tion="Spatial di
+00014a70: 7374 7269 6275 7469 6f6e 206f 6620 7068  stribution of ph
+00014a80: 692d 636f 6d70 6f6e 656e 7420 6f66 2074  i-component of t
+00014a90: 6865 206d 6167 6e65 7469 6320 6669 656c  he magnetic fiel
+00014aa0: 642e 222c 0a20 2020 2029 0a0a 2020 2020  d.",.    )..    
+00014ab0: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
+00014ac0: 6620 7228 7365 6c66 2920 2d3e 206e 702e  f r(self) -> np.
+00014ad0: 6e64 6172 7261 793a 0a20 2020 2020 2020  ndarray:.       
+00014ae0: 2022 2222 5261 6469 616c 2064 6973 7461   """Radial dista
+00014af0: 6e63 652e 2222 220a 2020 2020 2020 2020  nce.""".        
+00014b00: 7265 7475 726e 2073 656c 662e 4574 6865  return self.Ethe
+00014b10: 7461 2e72 2e76 616c 7565 730a 0a20 2020  ta.r.values..   
+00014b20: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
+00014b30: 6566 2074 6865 7461 2873 656c 6629 202d  ef theta(self) -
+00014b40: 3e20 6e70 2e6e 6461 7272 6179 3a0a 2020  > np.ndarray:.  
+00014b50: 2020 2020 2020 2222 2250 6f6c 6172 2061        """Polar a
+00014b60: 6e67 6c65 732e 2222 220a 2020 2020 2020  ngles.""".      
+00014b70: 2020 7265 7475 726e 2073 656c 662e 4574    return self.Et
+00014b80: 6865 7461 2e74 6865 7461 2e76 616c 7565  heta.theta.value
+00014b90: 730a 0a20 2020 2040 7072 6f70 6572 7479  s..    @property
+00014ba0: 0a20 2020 2064 6566 2070 6869 2873 656c  .    def phi(sel
+00014bb0: 6629 202d 3e20 6e70 2e6e 6461 7272 6179  f) -> np.ndarray
+00014bc0: 3a0a 2020 2020 2020 2020 2222 2241 7a69  :.        """Azi
+00014bd0: 6d75 7468 616c 2061 6e67 6c65 732e 2222  muthal angles.""
+00014be0: 220a 2020 2020 2020 2020 7265 7475 726e  ".        return
+00014bf0: 2073 656c 662e 4574 6865 7461 2e70 6869   self.Etheta.phi
+00014c00: 2e76 616c 7565 730a 0a20 2020 2064 6566  .values..    def
+00014c10: 2072 656e 6f72 6d61 6c69 7a65 5f66 6965   renormalize_fie
+00014c20: 6c64 7328 7365 6c66 2c20 7072 6f6a 5f64  lds(self, proj_d
+00014c30: 6973 7461 6e63 653a 2066 6c6f 6174 2920  istance: float) 
+00014c40: 2d3e 2046 6965 6c64 5072 6f6a 6563 7469  -> FieldProjecti
+00014c50: 6f6e 416e 676c 6544 6174 613a 0a20 2020  onAngleData:.   
+00014c60: 2020 2020 2022 2222 5265 7475 726e 2061       """Return a
+00014c70: 203a 636c 6173 733a 602e 4669 656c 6450   :class:`.FieldP
+00014c80: 726f 6a65 6374 696f 6e41 6e67 6c65 4461  rojectionAngleDa
+00014c90: 7461 6020 7769 7468 2066 6965 6c64 7320  ta` with fields 
+00014ca0: 7265 2d6e 6f72 6d61 6c69 7a65 6420 746f  re-normalized to
+00014cb0: 2061 206e 6577 0a20 2020 2020 2020 2070   a new.        p
+00014cc0: 726f 6a65 6374 696f 6e20 6469 7374 616e  rojection distan
+00014cd0: 6365 2c20 6279 2061 7070 6c79 696e 6720  ce, by applying 
+00014ce0: 6120 7068 6173 6520 6661 6374 6f72 2062  a phase factor b
+00014cf0: 6173 6564 206f 6e20 6060 7072 6f6a 5f64  ased on ``proj_d
+00014d00: 6973 7461 6e63 6560 602e 0a0a 2020 2020  istance``...    
+00014d10: 2020 2020 5061 7261 6d65 7465 7273 0a20      Parameters. 
+00014d20: 2020 2020 2020 202d 2d2d 2d2d 2d2d 2d2d         ---------
+00014d30: 2d0a 2020 2020 2020 2020 7072 6f6a 5f64  -.        proj_d
+00014d40: 6973 7461 6e63 6520 3a20 666c 6f61 7420  istance : float 
+00014d50: 3d20 4e6f 6e65 0a20 2020 2020 2020 2020  = None.         
+00014d60: 2020 2028 6d69 6372 6f6e 2920 6e65 7720     (micron) new 
+00014d70: 7261 6469 616c 2064 6973 7461 6e63 6520  radial distance 
+00014d80: 7265 6c61 7469 7665 2074 6f20 7468 6520  relative to the 
+00014d90: 6d6f 6e69 746f 7227 7320 6c6f 6361 6c20  monitor's local 
+00014da0: 6f72 6967 696e 2e0a 0a20 2020 2020 2020  origin...       
+00014db0: 2052 6574 7572 6e73 0a20 2020 2020 2020   Returns.       
+00014dc0: 202d 2d2d 2d2d 2d2d 0a20 2020 2020 2020   -------.       
+00014dd0: 203a 636c 6173 733a 602e 4669 656c 6450   :class:`.FieldP
+00014de0: 726f 6a65 6374 696f 6e41 6e67 6c65 4461  rojectionAngleDa
+00014df0: 7461 600a 2020 2020 2020 2020 2020 2020  ta`.            
+00014e00: 436f 7079 206f 6620 7468 6973 203a 636c  Copy of this :cl
+00014e10: 6173 733a 602e 4669 656c 6450 726f 6a65  ass:`.FieldProje
+00014e20: 6374 696f 6e41 6e67 6c65 4461 7461 6020  ctionAngleData` 
+00014e30: 7769 7468 2066 6965 6c64 7320 7265 2d70  with fields re-p
+00014e40: 726f 6a65 6374 6564 0a20 2020 2020 2020  rojected.       
+00014e50: 2020 2020 2074 6f20 6060 7072 6f6a 5f64       to ``proj_d
+00014e60: 6973 7461 6e63 6560 602e 0a20 2020 2020  istance``..     
+00014e70: 2020 2022 2222 0a20 2020 2020 2020 2069     """.        i
+00014e80: 6620 7365 6c66 2e6d 6f6e 6974 6f72 2061  f self.monitor a
+00014e90: 6e64 206e 6f74 2073 656c 662e 6d6f 6e69  nd not self.moni
+00014ea0: 746f 722e 6661 725f 6669 656c 645f 6170  tor.far_field_ap
+00014eb0: 7072 6f78 3a0a 2020 2020 2020 2020 2020  prox:.          
+00014ec0: 2020 7261 6973 6520 4461 7461 4572 726f    raise DataErro
+00014ed0: 7228 0a20 2020 2020 2020 2020 2020 2020  r(.             
+00014ee0: 2020 2022 4669 656c 6473 2070 726f 6a65     "Fields proje
+00014ef0: 6374 6564 2077 6974 686f 7574 2069 6e76  cted without inv
+00014f00: 6f6b 696e 6720 7468 6520 6661 7220 6669  oking the far fi
+00014f10: 656c 6420 6170 7072 6f78 696d 6174 696f  eld approximatio
+00014f20: 6e20 220a 2020 2020 2020 2020 2020 2020  n ".            
+00014f30: 2020 2020 2263 616e 6e6f 7420 6265 2072      "cannot be r
+00014f40: 652d 7072 6f6a 6563 7465 6420 746f 2061  e-projected to a
+00014f50: 206e 6577 2064 6973 7461 6e63 652e 220a   new distance.".
+00014f60: 2020 2020 2020 2020 2020 2020 290a 0a20              ).. 
+00014f70: 2020 2020 2020 2023 2074 6865 2070 6861         # the pha
+00014f80: 7365 2066 6163 746f 7220 6173 736f 6369  se factor associ
+00014f90: 6174 6564 2077 6974 6820 7468 6520 6f6c  ated with the ol
+00014fa0: 6420 6469 7374 616e 6365 206d 7573 7420  d distance must 
+00014fb0: 6265 2072 656d 6f76 6564 0a20 2020 2020  be removed.     
+00014fc0: 2020 2072 203d 2073 656c 662e 636f 6f72     r = self.coor
+00014fd0: 6473 5f73 7068 6572 6963 616c 5b22 7222  ds_spherical["r"
+00014fe0: 5d5b 2e2e 2e2c 204e 6f6e 655d 0a20 2020  ][..., None].   
+00014ff0: 2020 2020 206f 6c64 5f70 6861 7365 203d       old_phase =
+00015000: 2073 656c 662e 7072 6f70 6167 6174 696f   self.propagatio
+00015010: 6e5f 7068 6173 6528 6469 7374 3d72 2c20  n_phase(dist=r, 
+00015020: 6b3d 7365 6c66 2e6b 5b4e 6f6e 652c 204e  k=self.k[None, N
+00015030: 6f6e 652c 204e 6f6e 652c 203a 5d29 0a0a  one, None, :])..
+00015040: 2020 2020 2020 2020 2320 7468 6520 7068          # the ph
+00015050: 6173 6520 6661 6374 6f72 2061 7373 6f63  ase factor assoc
+00015060: 6961 7465 6420 7769 7468 2074 6865 206e  iated with the n
+00015070: 6577 2064 6973 7461 6e63 6520 6d75 7374  ew distance must
+00015080: 2062 6520 6170 706c 6965 640a 2020 2020   be applied.    
+00015090: 2020 2020 6e65 775f 7068 6173 6520 3d20      new_phase = 
+000150a0: 7365 6c66 2e70 726f 7061 6761 7469 6f6e  self.propagation
+000150b0: 5f70 6861 7365 2864 6973 743d 7072 6f6a  _phase(dist=proj
+000150c0: 5f64 6973 7461 6e63 652c 206b 3d73 656c  _distance, k=sel
+000150d0: 662e 6b29 0a0a 2020 2020 2020 2020 2320  f.k)..        # 
+000150e0: 6e65 7420 7068 6173 650a 2020 2020 2020  net phase.      
+000150f0: 2020 7068 6173 6520 3d20 6e65 775f 7068    phase = new_ph
+00015100: 6173 655b 4e6f 6e65 2c20 4e6f 6e65 2c20  ase[None, None, 
+00015110: 4e6f 6e65 2c20 3a5d 202f 206f 6c64 5f70  None, :] / old_p
+00015120: 6861 7365 0a0a 2020 2020 2020 2020 2320  hase..        # 
+00015130: 636f 6d70 7574 6520 7570 6461 7465 6420  compute updated 
+00015140: 6669 656c 6473 2061 6e64 2074 6865 6972  fields and their
+00015150: 2063 6f6f 7264 696e 6174 6573 0a20 2020   coordinates.   
+00015160: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+00015170: 2e6d 616b 655f 7265 6e6f 726d 616c 697a  .make_renormaliz
+00015180: 6564 5f64 6174 6128 7068 6173 652c 2070  ed_data(phase, p
+00015190: 726f 6a5f 6469 7374 616e 6365 290a 0a0a  roj_distance)...
+000151a0: 636c 6173 7320 4669 656c 6450 726f 6a65  class FieldProje
+000151b0: 6374 696f 6e43 6172 7465 7369 616e 4461  ctionCartesianDa
+000151c0: 7461 2841 6273 7472 6163 7446 6965 6c64  ta(AbstractField
+000151d0: 5072 6f6a 6563 7469 6f6e 4461 7461 293a  ProjectionData):
+000151e0: 0a20 2020 2022 2222 4461 7461 2061 7373  .    """Data ass
+000151f0: 6f63 6961 7465 6420 7769 7468 2061 203a  ociated with a :
+00015200: 636c 6173 733a 602e 4669 656c 6450 726f  class:`.FieldPro
+00015210: 6a65 6374 696f 6e43 6172 7465 7369 616e  jectionCartesian
+00015220: 4d6f 6e69 746f 7260 3a20 636f 6d70 6f6e  Monitor`: compon
+00015230: 656e 7473 206f 660a 2020 2020 7072 6f6a  ents of.    proj
+00015240: 6563 7465 6420 6669 656c 6473 2e0a 0a20  ected fields... 
+00015250: 2020 2045 7861 6d70 6c65 0a20 2020 202d     Example.    -
+00015260: 2d2d 2d2d 2d2d 0a20 2020 203e 3e3e 2066  ------.    >>> f
+00015270: 726f 6d20 7469 6479 3364 2069 6d70 6f72  rom tidy3d impor
+00015280: 7420 4669 656c 6450 726f 6a65 6374 696f  t FieldProjectio
+00015290: 6e43 6172 7465 7369 616e 4461 7461 4172  nCartesianDataAr
+000152a0: 7261 790a 2020 2020 3e3e 3e20 6620 3d20  ray.    >>> f = 
+000152b0: 6e70 2e6c 696e 7370 6163 6528 3165 3134  np.linspace(1e14
+000152c0: 2c20 3265 3134 2c20 3130 290a 2020 2020  , 2e14, 10).    
+000152d0: 3e3e 3e20 7820 3d20 6e70 2e6c 696e 7370  >>> x = np.linsp
+000152e0: 6163 6528 302c 2035 2c20 3130 290a 2020  ace(0, 5, 10).  
+000152f0: 2020 3e3e 3e20 7920 3d20 6e70 2e6c 696e    >>> y = np.lin
+00015300: 7370 6163 6528 302c 2031 302c 2032 3029  space(0, 10, 20)
+00015310: 0a20 2020 203e 3e3e 207a 203d 206e 702e  .    >>> z = np.
+00015320: 6174 6c65 6173 745f 3164 2835 290a 2020  atleast_1d(5).  
+00015330: 2020 3e3e 3e20 636f 6f72 6473 203d 2064    >>> coords = d
+00015340: 6963 7428 783d 782c 2079 3d79 2c20 7a3d  ict(x=x, y=y, z=
+00015350: 7a2c 2066 3d66 290a 2020 2020 3e3e 3e20  z, f=f).    >>> 
+00015360: 7661 6c75 6573 203d 2028 312b 316a 2920  values = (1+1j) 
+00015370: 2a20 6e70 2e72 616e 646f 6d2e 7261 6e64  * np.random.rand
+00015380: 6f6d 2828 6c65 6e28 7829 2c20 6c65 6e28  om((len(x), len(
+00015390: 7929 2c20 6c65 6e28 7a29 2c20 6c65 6e28  y), len(z), len(
+000153a0: 6629 2929 0a20 2020 203e 3e3e 2073 6361  f))).    >>> sca
+000153b0: 6c61 725f 6669 656c 6420 3d20 4669 656c  lar_field = Fiel
+000153c0: 6450 726f 6a65 6374 696f 6e43 6172 7465  dProjectionCarte
+000153d0: 7369 616e 4461 7461 4172 7261 7928 7661  sianDataArray(va
+000153e0: 6c75 6573 2c20 636f 6f72 6473 3d63 6f6f  lues, coords=coo
+000153f0: 7264 7329 0a20 2020 203e 3e3e 206d 6f6e  rds).    >>> mon
+00015400: 6974 6f72 203d 2046 6965 6c64 5072 6f6a  itor = FieldProj
+00015410: 6563 7469 6f6e 4361 7274 6573 6961 6e4d  ectionCartesianM
+00015420: 6f6e 6974 6f72 280a 2020 2020 2e2e 2e20  onitor(.    ... 
+00015430: 2020 2020 6365 6e74 6572 3d28 312c 322c      center=(1,2,
+00015440: 3329 2c20 7369 7a65 3d28 322c 322c 3229  3), size=(2,2,2)
+00015450: 2c20 6672 6571 733d 662c 206e 616d 653d  , freqs=f, name=
+00015460: 276e 3266 5f6d 6f6e 6974 6f72 272c 2078  'n2f_monitor', x
+00015470: 3d78 2c20 793d 792c 0a20 2020 202e 2e2e  =x, y=y,.    ...
+00015480: 2020 2020 2070 726f 6a5f 6178 6973 3d32       proj_axis=2
+00015490: 2c20 7072 6f6a 5f64 6973 7461 6e63 653d  , proj_distance=
+000154a0: 3530 0a20 2020 202e 2e2e 2020 2020 2029  50.    ...     )
+000154b0: 0a20 2020 203e 3e3e 2064 6174 6120 3d20  .    >>> data = 
+000154c0: 4669 656c 6450 726f 6a65 6374 696f 6e43  FieldProjectionC
+000154d0: 6172 7465 7369 616e 4461 7461 280a 2020  artesianData(.  
+000154e0: 2020 2e2e 2e20 2020 2020 6d6f 6e69 746f    ...     monito
+000154f0: 723d 6d6f 6e69 746f 722c 2045 723d 7363  r=monitor, Er=sc
+00015500: 616c 6172 5f66 6965 6c64 2c20 4574 6865  alar_field, Ethe
+00015510: 7461 3d73 6361 6c61 725f 6669 656c 642c  ta=scalar_field,
+00015520: 2045 7068 693d 7363 616c 6172 5f66 6965   Ephi=scalar_fie
+00015530: 6c64 2c0a 2020 2020 2e2e 2e20 2020 2020  ld,.    ...     
+00015540: 4872 3d73 6361 6c61 725f 6669 656c 642c  Hr=scalar_field,
+00015550: 2048 7468 6574 613d 7363 616c 6172 5f66   Htheta=scalar_f
+00015560: 6965 6c64 2c20 4870 6869 3d73 6361 6c61  ield, Hphi=scala
+00015570: 725f 6669 656c 642c 0a20 2020 202e 2e2e  r_field,.    ...
+00015580: 2020 2020 2070 726f 6a65 6374 696f 6e5f       projection_
+00015590: 7375 7266 6163 6573 3d6d 6f6e 6974 6f72  surfaces=monitor
+000155a0: 2e70 726f 6a65 6374 696f 6e5f 7375 7266  .projection_surf
+000155b0: 6163 6573 2c0a 2020 2020 2e2e 2e20 2020  aces,.    ...   
+000155c0: 2020 290a 2020 2020 2222 220a 0a20 2020    ).    """..   
+000155d0: 206d 6f6e 6974 6f72 3a20 4669 656c 6450   monitor: FieldP
+000155e0: 726f 6a65 6374 696f 6e43 6172 7465 7369  rojectionCartesi
+000155f0: 616e 4d6f 6e69 746f 7220 3d20 7064 2e46  anMonitor = pd.F
+00015600: 6965 6c64 280a 2020 2020 2020 2020 2e2e  ield(.        ..
+00015610: 2e2c 0a20 2020 2020 2020 2074 6974 6c65  .,.        title
+00015620: 3d22 5072 6f6a 6563 7469 6f6e 206d 6f6e  ="Projection mon
+00015630: 6974 6f72 222c 0a20 2020 2020 2020 2064  itor",.        d
+00015640: 6573 6372 6970 7469 6f6e 3d22 4669 656c  escription="Fiel
+00015650: 6420 7072 6f6a 6563 7469 6f6e 206d 6f6e  d projection mon
+00015660: 6974 6f72 2077 6974 6820 6120 4361 7274  itor with a Cart
+00015670: 6573 6961 6e20 7072 6f6a 6563 7469 6f6e  esian projection
+00015680: 2067 7269 642e 222c 0a20 2020 2029 0a0a   grid.",.    )..
+00015690: 2020 2020 7072 6f6a 6563 7469 6f6e 5f73      projection_s
+000156a0: 7572 6661 6365 733a 2054 7570 6c65 5b46  urfaces: Tuple[F
+000156b0: 6965 6c64 5072 6f6a 6563 7469 6f6e 5375  ieldProjectionSu
+000156c0: 7266 6163 652c 202e 2e2e 5d20 3d20 7064  rface, ...] = pd
+000156d0: 2e46 6965 6c64 280a 2020 2020 2020 2020  .Field(.        
+000156e0: 2e2e 2e2c 0a20 2020 2020 2020 2074 6974  ...,.        tit
+000156f0: 6c65 3d22 5072 6f6a 6563 7469 6f6e 2073  le="Projection s
+00015700: 7572 6661 6365 7322 2c0a 2020 2020 2020  urfaces",.      
+00015710: 2020 6465 7363 7269 7074 696f 6e3d 2253    description="S
+00015720: 7572 6661 6365 7320 6f66 2074 6865 206d  urfaces of the m
+00015730: 6f6e 6974 6f72 2077 6865 7265 206e 6561  onitor where nea
+00015740: 7220 6669 656c 6473 2077 6572 6520 7265  r fields were re
+00015750: 636f 7264 6564 2066 6f72 2070 726f 6a65  corded for proje
+00015760: 6374 696f 6e22 2c0a 2020 2020 290a 0a20  ction",.    ).. 
+00015770: 2020 2045 723a 2046 6965 6c64 5072 6f6a     Er: FieldProj
+00015780: 6563 7469 6f6e 4361 7274 6573 6961 6e44  ectionCartesianD
+00015790: 6174 6141 7272 6179 203d 2070 642e 4669  ataArray = pd.Fi
+000157a0: 656c 6428 0a20 2020 2020 2020 202e 2e2e  eld(.        ...
+000157b0: 2c0a 2020 2020 2020 2020 7469 746c 653d  ,.        title=
+000157c0: 2245 7222 2c0a 2020 2020 2020 2020 6465  "Er",.        de
+000157d0: 7363 7269 7074 696f 6e3d 2253 7061 7469  scription="Spati
+000157e0: 616c 2064 6973 7472 6962 7574 696f 6e20  al distribution 
+000157f0: 6f66 2072 2d63 6f6d 706f 6e65 6e74 206f  of r-component o
+00015800: 6620 7468 6520 656c 6563 7472 6963 2066  f the electric f
+00015810: 6965 6c64 2e22 2c0a 2020 2020 290a 2020  ield.",.    ).  
+00015820: 2020 4574 6865 7461 3a20 4669 656c 6450    Etheta: FieldP
+00015830: 726f 6a65 6374 696f 6e43 6172 7465 7369  rojectionCartesi
+00015840: 616e 4461 7461 4172 7261 7920 3d20 7064  anDataArray = pd
+00015850: 2e46 6965 6c64 280a 2020 2020 2020 2020  .Field(.        
+00015860: 2e2e 2e2c 0a20 2020 2020 2020 2074 6974  ...,.        tit
+00015870: 6c65 3d22 4574 6865 7461 222c 0a20 2020  le="Etheta",.   
+00015880: 2020 2020 2064 6573 6372 6970 7469 6f6e       description
+00015890: 3d22 5370 6174 6961 6c20 6469 7374 7269  ="Spatial distri
+000158a0: 6275 7469 6f6e 206f 6620 7468 6520 7468  bution of the th
+000158b0: 6574 612d 636f 6d70 6f6e 656e 7420 6f66  eta-component of
+000158c0: 2074 6865 2065 6c65 6374 7269 6320 6669   the electric fi
+000158d0: 656c 642e 222c 0a20 2020 2029 0a20 2020  eld.",.    ).   
+000158e0: 2045 7068 693a 2046 6965 6c64 5072 6f6a   Ephi: FieldProj
+000158f0: 6563 7469 6f6e 4361 7274 6573 6961 6e44  ectionCartesianD
+00015900: 6174 6141 7272 6179 203d 2070 642e 4669  ataArray = pd.Fi
+00015910: 656c 6428 0a20 2020 2020 2020 202e 2e2e  eld(.        ...
+00015920: 2c0a 2020 2020 2020 2020 7469 746c 653d  ,.        title=
+00015930: 2245 7068 6922 2c0a 2020 2020 2020 2020  "Ephi",.        
+00015940: 6465 7363 7269 7074 696f 6e3d 2253 7061  description="Spa
+00015950: 7469 616c 2064 6973 7472 6962 7574 696f  tial distributio
+00015960: 6e20 6f66 2070 6869 2d63 6f6d 706f 6e65  n of phi-compone
+00015970: 6e74 206f 6620 7468 6520 656c 6563 7472  nt of the electr
+00015980: 6963 2066 6965 6c64 2e22 2c0a 2020 2020  ic field.",.    
+00015990: 290a 2020 2020 4872 3a20 4669 656c 6450  ).    Hr: FieldP
+000159a0: 726f 6a65 6374 696f 6e43 6172 7465 7369  rojectionCartesi
+000159b0: 616e 4461 7461 4172 7261 7920 3d20 7064  anDataArray = pd
+000159c0: 2e46 6965 6c64 280a 2020 2020 2020 2020  .Field(.        
+000159d0: 2e2e 2e2c 0a20 2020 2020 2020 2074 6974  ...,.        tit
+000159e0: 6c65 3d22 4872 222c 0a20 2020 2020 2020  le="Hr",.       
+000159f0: 2064 6573 6372 6970 7469 6f6e 3d22 5370   description="Sp
+00015a00: 6174 6961 6c20 6469 7374 7269 6275 7469  atial distributi
+00015a10: 6f6e 206f 6620 722d 636f 6d70 6f6e 656e  on of r-componen
+00015a20: 7420 6f66 2074 6865 206d 6167 6e65 7469  t of the magneti
+00015a30: 6320 6669 656c 642e 222c 0a20 2020 2029  c field.",.    )
+00015a40: 0a20 2020 2048 7468 6574 613a 2046 6965  .    Htheta: Fie
+00015a50: 6c64 5072 6f6a 6563 7469 6f6e 4361 7274  ldProjectionCart
+00015a60: 6573 6961 6e44 6174 6141 7272 6179 203d  esianDataArray =
+00015a70: 2070 642e 4669 656c 6428 0a20 2020 2020   pd.Field(.     
+00015a80: 2020 202e 2e2e 2c0a 2020 2020 2020 2020     ...,.        
+00015a90: 7469 746c 653d 2248 7468 6574 6122 2c0a  title="Htheta",.
+00015aa0: 2020 2020 2020 2020 6465 7363 7269 7074          descript
+00015ab0: 696f 6e3d 2253 7061 7469 616c 2064 6973  ion="Spatial dis
+00015ac0: 7472 6962 7574 696f 6e20 6f66 2074 6865  tribution of the
+00015ad0: 7461 2d63 6f6d 706f 6e65 6e74 206f 6620  ta-component of 
+00015ae0: 7468 6520 6d61 676e 6574 6963 2066 6965  the magnetic fie
+00015af0: 6c64 2e22 2c0a 2020 2020 290a 2020 2020  ld.",.    ).    
+00015b00: 4870 6869 3a20 4669 656c 6450 726f 6a65  Hphi: FieldProje
+00015b10: 6374 696f 6e43 6172 7465 7369 616e 4461  ctionCartesianDa
+00015b20: 7461 4172 7261 7920 3d20 7064 2e46 6965  taArray = pd.Fie
+00015b30: 6c64 280a 2020 2020 2020 2020 2e2e 2e2c  ld(.        ...,
+00015b40: 0a20 2020 2020 2020 2074 6974 6c65 3d22  .        title="
+00015b50: 4870 6869 222c 0a20 2020 2020 2020 2064  Hphi",.        d
+00015b60: 6573 6372 6970 7469 6f6e 3d22 5370 6174  escription="Spat
+00015b70: 6961 6c20 6469 7374 7269 6275 7469 6f6e  ial distribution
+00015b80: 206f 6620 7068 692d 636f 6d70 6f6e 656e   of phi-componen
+00015b90: 7420 6f66 2074 6865 206d 6167 6e65 7469  t of the magneti
+00015ba0: 6320 6669 656c 642e 222c 0a20 2020 2029  c field.",.    )
+00015bb0: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
+00015bc0: 2020 2020 6465 6620 7828 7365 6c66 2920      def x(self) 
+00015bd0: 2d3e 206e 702e 6e64 6172 7261 793a 0a20  -> np.ndarray:. 
+00015be0: 2020 2020 2020 2022 2222 5820 706f 7369         """X posi
+00015bf0: 7469 6f6e 732e 2222 220a 2020 2020 2020  tions.""".      
+00015c00: 2020 7265 7475 726e 2073 656c 662e 4574    return self.Et
+00015c10: 6865 7461 2e78 2e76 616c 7565 730a 0a20  heta.x.values.. 
+00015c20: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
+00015c30: 2064 6566 2079 2873 656c 6629 202d 3e20   def y(self) -> 
+00015c40: 6e70 2e6e 6461 7272 6179 3a0a 2020 2020  np.ndarray:.    
+00015c50: 2020 2020 2222 2259 2070 6f73 6974 696f      """Y positio
+00015c60: 6e73 2e22 2222 0a20 2020 2020 2020 2072  ns.""".        r
+00015c70: 6574 7572 6e20 7365 6c66 2e45 7468 6574  eturn self.Ethet
+00015c80: 612e 792e 7661 6c75 6573 0a0a 2020 2020  a.y.values..    
+00015c90: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
+00015ca0: 6620 7a28 7365 6c66 2920 2d3e 206e 702e  f z(self) -> np.
+00015cb0: 6e64 6172 7261 793a 0a20 2020 2020 2020  ndarray:.       
+00015cc0: 2022 2222 5a20 706f 7369 7469 6f6e 732e   """Z positions.
+00015cd0: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
+00015ce0: 726e 2073 656c 662e 4574 6865 7461 2e7a  rn self.Etheta.z
+00015cf0: 2e76 616c 7565 730a 0a20 2020 2064 6566  .values..    def
+00015d00: 2072 656e 6f72 6d61 6c69 7a65 5f66 6965   renormalize_fie
+00015d10: 6c64 7328 7365 6c66 2c20 7072 6f6a 5f64  lds(self, proj_d
+00015d20: 6973 7461 6e63 653a 2066 6c6f 6174 2920  istance: float) 
+00015d30: 2d3e 2046 6965 6c64 5072 6f6a 6563 7469  -> FieldProjecti
+00015d40: 6f6e 4361 7274 6573 6961 6e44 6174 613a  onCartesianData:
+00015d50: 0a20 2020 2020 2020 2022 2222 5265 7475  .        """Retu
+00015d60: 726e 2061 203a 636c 6173 733a 602e 4669  rn a :class:`.Fi
+00015d70: 656c 6450 726f 6a65 6374 696f 6e43 6172  eldProjectionCar
+00015d80: 7465 7369 616e 4461 7461 6020 7769 7468  tesianData` with
+00015d90: 2066 6965 6c64 7320 7265 2d6e 6f72 6d61   fields re-norma
+00015da0: 6c69 7a65 6420 746f 2061 206e 6577 0a20  lized to a new. 
+00015db0: 2020 2020 2020 2070 726f 6a65 6374 696f         projectio
+00015dc0: 6e20 6469 7374 616e 6365 2c20 6279 2061  n distance, by a
+00015dd0: 7070 6c79 696e 6720 6120 7068 6173 6520  pplying a phase 
+00015de0: 6661 6374 6f72 2062 6173 6564 206f 6e20  factor based on 
+00015df0: 6060 7072 6f6a 5f64 6973 7461 6e63 6560  ``proj_distance`
+00015e00: 602e 0a0a 2020 2020 2020 2020 5061 7261  `...        Para
+00015e10: 6d65 7465 7273 0a20 2020 2020 2020 202d  meters.        -
+00015e20: 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020 2020  ---------.      
+00015e30: 2020 7072 6f6a 5f64 6973 7461 6e63 6520    proj_distance 
+00015e40: 3a20 666c 6f61 7420 3d20 4e6f 6e65 0a20  : float = None. 
+00015e50: 2020 2020 2020 2020 2020 2028 6d69 6372             (micr
+00015e60: 6f6e 2920 6e65 7720 706c 616e 6520 6469  on) new plane di
+00015e70: 7374 616e 6365 2072 656c 6174 6976 6520  stance relative 
+00015e80: 746f 2074 6865 206d 6f6e 6974 6f72 2773  to the monitor's
+00015e90: 206c 6f63 616c 206f 7269 6769 6e2e 0a0a   local origin...
+00015ea0: 2020 2020 2020 2020 5265 7475 726e 730a          Returns.
+00015eb0: 2020 2020 2020 2020 2d2d 2d2d 2d2d 2d0a          -------.
+00015ec0: 2020 2020 2020 2020 3a63 6c61 7373 3a60          :class:`
+00015ed0: 2e46 6965 6c64 5072 6f6a 6563 7469 6f6e  .FieldProjection
+00015ee0: 4361 7274 6573 6961 6e44 6174 6160 0a20  CartesianData`. 
+00015ef0: 2020 2020 2020 2020 2020 2043 6f70 7920             Copy 
+00015f00: 6f66 2074 6869 7320 3a63 6c61 7373 3a60  of this :class:`
+00015f10: 2e46 6965 6c64 5072 6f6a 6563 7469 6f6e  .FieldProjection
+00015f20: 4361 7274 6573 6961 6e44 6174 6160 2077  CartesianData` w
+00015f30: 6974 6820 6669 656c 6473 2072 652d 7072  ith fields re-pr
+00015f40: 6f6a 6563 7465 640a 2020 2020 2020 2020  ojected.        
+00015f50: 2020 2020 746f 2060 6070 726f 6a5f 6469      to ``proj_di
+00015f60: 7374 616e 6365 6060 2e0a 2020 2020 2020  stance``..      
+00015f70: 2020 2222 220a 2020 2020 2020 2020 6966    """.        if
+00015f80: 206e 6f74 2073 656c 662e 6d6f 6e69 746f   not self.monito
+00015f90: 722e 6661 725f 6669 656c 645f 6170 7072  r.far_field_appr
+00015fa0: 6f78 3a0a 2020 2020 2020 2020 2020 2020  ox:.            
+00015fb0: 7261 6973 6520 4461 7461 4572 726f 7228  raise DataError(
+00015fc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00015fd0: 2022 4669 656c 6473 2070 726f 6a65 6374   "Fields project
+00015fe0: 6564 2077 6974 686f 7574 2069 6e76 6f6b  ed without invok
+00015ff0: 696e 6720 7468 6520 6661 7220 6669 656c  ing the far fiel
+00016000: 6420 6170 7072 6f78 696d 6174 696f 6e20  d approximation 
+00016010: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
+00016020: 2020 2263 616e 6e6f 7420 6265 2072 652d    "cannot be re-
+00016030: 7072 6f6a 6563 7465 6420 746f 2061 206e  projected to a n
+00016040: 6577 2064 6973 7461 6e63 652e 220a 2020  ew distance.".  
+00016050: 2020 2020 2020 2020 2020 290a 0a20 2020            )..   
+00016060: 2020 2020 2023 2074 6865 2070 6861 7365       # the phase
+00016070: 2066 6163 746f 7220 6173 736f 6369 6174   factor associat
+00016080: 6564 2077 6974 6820 7468 6520 6f6c 6420  ed with the old 
+00016090: 6469 7374 616e 6365 206d 7573 7420 6265  distance must be
+000160a0: 2072 656d 6f76 6564 0a20 2020 2020 2020   removed.       
+000160b0: 206b 203d 2073 656c 662e 6b5b 4e6f 6e65   k = self.k[None
+000160c0: 2c20 4e6f 6e65 2c20 4e6f 6e65 2c20 3a5d  , None, None, :]
+000160d0: 0a20 2020 2020 2020 2072 203d 2073 656c  .        r = sel
+000160e0: 662e 636f 6f72 6473 5f73 7068 6572 6963  f.coords_spheric
+000160f0: 616c 5b22 7222 5d5b 2e2e 2e2c 204e 6f6e  al["r"][..., Non
+00016100: 655d 0a20 2020 2020 2020 206f 6c64 5f70  e].        old_p
+00016110: 6861 7365 203d 2073 656c 662e 7072 6f70  hase = self.prop
+00016120: 6167 6174 696f 6e5f 7068 6173 6528 6469  agation_phase(di
+00016130: 7374 3d72 2c20 6b3d 6b29 0a0a 2020 2020  st=r, k=k)..    
+00016140: 2020 2020 2320 7570 6461 7465 2074 6865      # update the
+00016150: 2066 6965 6c64 2063 6f6d 706f 6e65 6e74   field component
+00016160: 7327 2070 726f 6a65 6374 696f 6e20 6469  s' projection di
+00016170: 7374 616e 6365 0a20 2020 2020 2020 206e  stance.        n
+00016180: 6f72 6d5f 6469 722c 205f 203d 2073 656c  orm_dir, _ = sel
+00016190: 662e 6d6f 6e69 746f 722e 706f 705f 6178  f.monitor.pop_ax
+000161a0: 6973 285b 2278 222c 2022 7922 2c20 227a  is(["x", "y", "z
+000161b0: 225d 2c20 6178 6973 3d73 656c 662e 6d6f  "], axis=self.mo
+000161c0: 6e69 746f 722e 7072 6f6a 5f61 7869 7329  nitor.proj_axis)
+000161d0: 0a20 2020 2020 2020 2066 6f72 2066 6965  .        for fie
+000161e0: 6c64 2069 6e20 7365 6c66 2e66 6965 6c64  ld in self.field
+000161f0: 5f63 6f6d 706f 6e65 6e74 732e 7661 6c75  _components.valu
+00016200: 6573 2829 3a0a 2020 2020 2020 2020 2020  es():.          
+00016210: 2020 6669 656c 645b 6e6f 726d 5f64 6972    field[norm_dir
+00016220: 5d20 3d20 6e70 2e61 746c 6561 7374 5f31  ] = np.atleast_1
+00016230: 6428 7072 6f6a 5f64 6973 7461 6e63 6529  d(proj_distance)
+00016240: 0a0a 2020 2020 2020 2020 2320 7468 6520  ..        # the 
+00016250: 7068 6173 6520 6661 6374 6f72 2061 7373  phase factor ass
+00016260: 6f63 6961 7465 6420 7769 7468 2074 6865  ociated with the
+00016270: 206e 6577 2064 6973 7461 6e63 6520 6d75   new distance mu
+00016280: 7374 2062 6520 6170 706c 6965 640a 2020  st be applied.  
+00016290: 2020 2020 2020 7220 3d20 7365 6c66 2e63        r = self.c
+000162a0: 6f6f 7264 735f 7370 6865 7269 6361 6c5b  oords_spherical[
+000162b0: 2272 225d 5b2e 2e2e 2c20 4e6f 6e65 5d0a  "r"][..., None].
+000162c0: 2020 2020 2020 2020 6e65 775f 7068 6173          new_phas
+000162d0: 6520 3d20 7365 6c66 2e70 726f 7061 6761  e = self.propaga
+000162e0: 7469 6f6e 5f70 6861 7365 2864 6973 743d  tion_phase(dist=
+000162f0: 722c 206b 3d6b 290a 0a20 2020 2020 2020  r, k=k)..       
+00016300: 2023 206e 6574 2070 6861 7365 0a20 2020   # net phase.   
+00016310: 2020 2020 2070 6861 7365 203d 206e 6577       phase = new
+00016320: 5f70 6861 7365 202f 206f 6c64 5f70 6861  _phase / old_pha
+00016330: 7365 0a0a 2020 2020 2020 2020 2320 636f  se..        # co
+00016340: 6d70 7574 6520 7570 6461 7465 6420 6669  mpute updated fi
+00016350: 656c 6473 2061 6e64 2074 6865 6972 2063  elds and their c
+00016360: 6f6f 7264 696e 6174 6573 0a20 2020 2020  oordinates.     
+00016370: 2020 2072 6574 7572 6e20 7365 6c66 2e6d     return self.m
+00016380: 616b 655f 7265 6e6f 726d 616c 697a 6564  ake_renormalized
+00016390: 5f64 6174 6128 7068 6173 652c 2070 726f  _data(phase, pro
+000163a0: 6a5f 6469 7374 616e 6365 290a 0a0a 636c  j_distance)...cl
+000163b0: 6173 7320 4669 656c 6450 726f 6a65 6374  ass FieldProject
+000163c0: 696f 6e4b 5370 6163 6544 6174 6128 4162  ionKSpaceData(Ab
+000163d0: 7374 7261 6374 4669 656c 6450 726f 6a65  stractFieldProje
+000163e0: 6374 696f 6e44 6174 6129 3a0a 2020 2020  ctionData):.    
+000163f0: 2222 2244 6174 6120 6173 736f 6369 6174  """Data associat
+00016400: 6564 2077 6974 6820 6120 3a63 6c61 7373  ed with a :class
+00016410: 3a60 2e46 6965 6c64 5072 6f6a 6563 7469  :`.FieldProjecti
+00016420: 6f6e 4b53 7061 6365 4d6f 6e69 746f 7260  onKSpaceMonitor`
+00016430: 3a20 636f 6d70 6f6e 656e 7473 206f 660a  : components of.
+00016440: 2020 2020 7072 6f6a 6563 7465 6420 6669      projected fi
+00016450: 656c 6473 2e0a 0a20 2020 2045 7861 6d70  elds...    Examp
+00016460: 6c65 0a20 2020 202d 2d2d 2d2d 2d2d 0a20  le.    -------. 
+00016470: 2020 203e 3e3e 2066 726f 6d20 7469 6479     >>> from tidy
+00016480: 3364 2069 6d70 6f72 7420 4669 656c 6450  3d import FieldP
+00016490: 726f 6a65 6374 696f 6e4b 5370 6163 6544  rojectionKSpaceD
+000164a0: 6174 6141 7272 6179 0a20 2020 203e 3e3e  ataArray.    >>>
+000164b0: 2066 203d 206e 702e 6c69 6e73 7061 6365   f = np.linspace
+000164c0: 2831 6531 342c 2032 6531 342c 2031 3029  (1e14, 2e14, 10)
+000164d0: 0a20 2020 203e 3e3e 2075 7820 3d20 6e70  .    >>> ux = np
+000164e0: 2e6c 696e 7370 6163 6528 302c 2030 2e34  .linspace(0, 0.4
+000164f0: 2c20 3130 290a 2020 2020 3e3e 3e20 7579  , 10).    >>> uy
+00016500: 203d 206e 702e 6c69 6e73 7061 6365 2830   = np.linspace(0
+00016510: 2c20 302e 362c 2032 3029 0a20 2020 203e  , 0.6, 20).    >
+00016520: 3e3e 2072 203d 206e 702e 6174 6c65 6173  >> r = np.atleas
+00016530: 745f 3164 2835 290a 2020 2020 3e3e 3e20  t_1d(5).    >>> 
+00016540: 636f 6f72 6473 203d 2064 6963 7428 7578  coords = dict(ux
+00016550: 3d75 782c 2075 793d 7579 2c20 723d 722c  =ux, uy=uy, r=r,
+00016560: 2066 3d66 290a 2020 2020 3e3e 3e20 7661   f=f).    >>> va
+00016570: 6c75 6573 203d 2028 312b 316a 2920 2a20  lues = (1+1j) * 
+00016580: 6e70 2e72 616e 646f 6d2e 7261 6e64 6f6d  np.random.random
+00016590: 2828 6c65 6e28 7578 292c 206c 656e 2875  ((len(ux), len(u
+000165a0: 7929 2c20 6c65 6e28 7229 2c20 6c65 6e28  y), len(r), len(
+000165b0: 6629 2929 0a20 2020 203e 3e3e 2073 6361  f))).    >>> sca
+000165c0: 6c61 725f 6669 656c 6420 3d20 4669 656c  lar_field = Fiel
+000165d0: 6450 726f 6a65 6374 696f 6e4b 5370 6163  dProjectionKSpac
+000165e0: 6544 6174 6141 7272 6179 2876 616c 7565  eDataArray(value
+000165f0: 732c 2063 6f6f 7264 733d 636f 6f72 6473  s, coords=coords
+00016600: 290a 2020 2020 3e3e 3e20 6d6f 6e69 746f  ).    >>> monito
+00016610: 7220 3d20 4669 656c 6450 726f 6a65 6374  r = FieldProject
+00016620: 696f 6e4b 5370 6163 654d 6f6e 6974 6f72  ionKSpaceMonitor
+00016630: 280a 2020 2020 2e2e 2e20 2020 2020 6365  (.    ...     ce
+00016640: 6e74 6572 3d28 312c 322c 3329 2c20 7369  nter=(1,2,3), si
+00016650: 7a65 3d28 322c 322c 3229 2c20 6672 6571  ze=(2,2,2), freq
+00016660: 733d 662c 206e 616d 653d 276e 3266 5f6d  s=f, name='n2f_m
+00016670: 6f6e 6974 6f72 272c 2075 783d 7578 2c20  onitor', ux=ux, 
+00016680: 7579 3d75 792c 2070 726f 6a5f 6178 6973  uy=uy, proj_axis
+00016690: 3d32 0a20 2020 202e 2e2e 2020 2020 2029  =2.    ...     )
+000166a0: 0a20 2020 203e 3e3e 2064 6174 6120 3d20  .    >>> data = 
+000166b0: 4669 656c 6450 726f 6a65 6374 696f 6e4b  FieldProjectionK
+000166c0: 5370 6163 6544 6174 6128 0a20 2020 202e  SpaceData(.    .
+000166d0: 2e2e 2020 2020 206d 6f6e 6974 6f72 3d6d  ..     monitor=m
+000166e0: 6f6e 6974 6f72 2c20 4572 3d73 6361 6c61  onitor, Er=scala
+000166f0: 725f 6669 656c 642c 2045 7468 6574 613d  r_field, Etheta=
+00016700: 7363 616c 6172 5f66 6965 6c64 2c20 4570  scalar_field, Ep
+00016710: 6869 3d73 6361 6c61 725f 6669 656c 642c  hi=scalar_field,
+00016720: 0a20 2020 202e 2e2e 2020 2020 2048 723d  .    ...     Hr=
+00016730: 7363 616c 6172 5f66 6965 6c64 2c20 4874  scalar_field, Ht
+00016740: 6865 7461 3d73 6361 6c61 725f 6669 656c  heta=scalar_fiel
+00016750: 642c 2048 7068 693d 7363 616c 6172 5f66  d, Hphi=scalar_f
+00016760: 6965 6c64 2c0a 2020 2020 2e2e 2e20 2020  ield,.    ...   
+00016770: 2020 7072 6f6a 6563 7469 6f6e 5f73 7572    projection_sur
+00016780: 6661 6365 733d 6d6f 6e69 746f 722e 7072  faces=monitor.pr
+00016790: 6f6a 6563 7469 6f6e 5f73 7572 6661 6365  ojection_surface
+000167a0: 732c 0a20 2020 202e 2e2e 2020 2020 2029  s,.    ...     )
+000167b0: 0a20 2020 2022 2222 0a0a 2020 2020 6d6f  .    """..    mo
+000167c0: 6e69 746f 723a 2046 6965 6c64 5072 6f6a  nitor: FieldProj
+000167d0: 6563 7469 6f6e 4b53 7061 6365 4d6f 6e69  ectionKSpaceMoni
+000167e0: 746f 7220 3d20 7064 2e46 6965 6c64 280a  tor = pd.Field(.
+000167f0: 2020 2020 2020 2020 2e2e 2e2c 0a20 2020          ...,.   
+00016800: 2020 2020 2074 6974 6c65 3d22 5072 6f6a       title="Proj
+00016810: 6563 7469 6f6e 206d 6f6e 6974 6f72 222c  ection monitor",
+00016820: 0a20 2020 2020 2020 2064 6573 6372 6970  .        descrip
+00016830: 7469 6f6e 3d22 4669 656c 6420 7072 6f6a  tion="Field proj
+00016840: 6563 7469 6f6e 206d 6f6e 6974 6f72 2077  ection monitor w
+00016850: 6974 6820 6120 7072 6f6a 6563 7469 6f6e  ith a projection
+00016860: 2067 7269 6420 6465 6669 6e65 6420 696e   grid defined in
+00016870: 206b 2d73 7061 6365 2e22 2c0a 2020 2020   k-space.",.    
+00016880: 290a 0a20 2020 2070 726f 6a65 6374 696f  )..    projectio
+00016890: 6e5f 7375 7266 6163 6573 3a20 5475 706c  n_surfaces: Tupl
+000168a0: 655b 4669 656c 6450 726f 6a65 6374 696f  e[FieldProjectio
+000168b0: 6e53 7572 6661 6365 2c20 2e2e 2e5d 203d  nSurface, ...] =
+000168c0: 2070 642e 4669 656c 6428 0a20 2020 2020   pd.Field(.     
+000168d0: 2020 202e 2e2e 2c0a 2020 2020 2020 2020     ...,.        
+000168e0: 7469 746c 653d 2250 726f 6a65 6374 696f  title="Projectio
+000168f0: 6e20 7375 7266 6163 6573 222c 0a20 2020  n surfaces",.   
+00016900: 2020 2020 2064 6573 6372 6970 7469 6f6e       description
+00016910: 3d22 5375 7266 6163 6573 206f 6620 7468  ="Surfaces of th
+00016920: 6520 6d6f 6e69 746f 7220 7768 6572 6520  e monitor where 
+00016930: 6e65 6172 2066 6965 6c64 7320 7765 7265  near fields were
+00016940: 2072 6563 6f72 6465 6420 666f 7220 7072   recorded for pr
+00016950: 6f6a 6563 7469 6f6e 222c 0a20 2020 2029  ojection",.    )
+00016960: 0a0a 2020 2020 4572 3a20 4669 656c 6450  ..    Er: FieldP
+00016970: 726f 6a65 6374 696f 6e4b 5370 6163 6544  rojectionKSpaceD
+00016980: 6174 6141 7272 6179 203d 2070 642e 4669  ataArray = pd.Fi
+00016990: 656c 6428 0a20 2020 2020 2020 202e 2e2e  eld(.        ...
+000169a0: 2c0a 2020 2020 2020 2020 7469 746c 653d  ,.        title=
+000169b0: 2245 7222 2c0a 2020 2020 2020 2020 6465  "Er",.        de
+000169c0: 7363 7269 7074 696f 6e3d 2253 7061 7469  scription="Spati
+000169d0: 616c 2064 6973 7472 6962 7574 696f 6e20  al distribution 
+000169e0: 6f66 2072 2d63 6f6d 706f 6e65 6e74 206f  of r-component o
+000169f0: 6620 7468 6520 656c 6563 7472 6963 2066  f the electric f
+00016a00: 6965 6c64 2e22 2c0a 2020 2020 290a 2020  ield.",.    ).  
+00016a10: 2020 4574 6865 7461 3a20 4669 656c 6450    Etheta: FieldP
+00016a20: 726f 6a65 6374 696f 6e4b 5370 6163 6544  rojectionKSpaceD
+00016a30: 6174 6141 7272 6179 203d 2070 642e 4669  ataArray = pd.Fi
+00016a40: 656c 6428 0a20 2020 2020 2020 202e 2e2e  eld(.        ...
+00016a50: 2c0a 2020 2020 2020 2020 7469 746c 653d  ,.        title=
+00016a60: 2245 7468 6574 6122 2c0a 2020 2020 2020  "Etheta",.      
+00016a70: 2020 6465 7363 7269 7074 696f 6e3d 2253    description="S
+00016a80: 7061 7469 616c 2064 6973 7472 6962 7574  patial distribut
+00016a90: 696f 6e20 6f66 2074 6865 2074 6865 7461  ion of the theta
+00016aa0: 2d63 6f6d 706f 6e65 6e74 206f 6620 7468  -component of th
+00016ab0: 6520 656c 6563 7472 6963 2066 6965 6c64  e electric field
+00016ac0: 2e22 2c0a 2020 2020 290a 2020 2020 4570  .",.    ).    Ep
+00016ad0: 6869 3a20 4669 656c 6450 726f 6a65 6374  hi: FieldProject
+00016ae0: 696f 6e4b 5370 6163 6544 6174 6141 7272  ionKSpaceDataArr
+00016af0: 6179 203d 2070 642e 4669 656c 6428 0a20  ay = pd.Field(. 
+00016b00: 2020 2020 2020 202e 2e2e 2c0a 2020 2020         ...,.    
+00016b10: 2020 2020 7469 746c 653d 2245 7068 6922      title="Ephi"
+00016b20: 2c0a 2020 2020 2020 2020 6465 7363 7269  ,.        descri
+00016b30: 7074 696f 6e3d 2253 7061 7469 616c 2064  ption="Spatial d
+00016b40: 6973 7472 6962 7574 696f 6e20 6f66 2070  istribution of p
+00016b50: 6869 2d63 6f6d 706f 6e65 6e74 206f 6620  hi-component of 
+00016b60: 7468 6520 656c 6563 7472 6963 2066 6965  the electric fie
+00016b70: 6c64 2e22 2c0a 2020 2020 290a 2020 2020  ld.",.    ).    
+00016b80: 4872 3a20 4669 656c 6450 726f 6a65 6374  Hr: FieldProject
+00016b90: 696f 6e4b 5370 6163 6544 6174 6141 7272  ionKSpaceDataArr
+00016ba0: 6179 203d 2070 642e 4669 656c 6428 0a20  ay = pd.Field(. 
+00016bb0: 2020 2020 2020 202e 2e2e 2c0a 2020 2020         ...,.    
+00016bc0: 2020 2020 7469 746c 653d 2248 7222 2c0a      title="Hr",.
+00016bd0: 2020 2020 2020 2020 6465 7363 7269 7074          descript
+00016be0: 696f 6e3d 2253 7061 7469 616c 2064 6973  ion="Spatial dis
+00016bf0: 7472 6962 7574 696f 6e20 6f66 2072 2d63  tribution of r-c
+00016c00: 6f6d 706f 6e65 6e74 206f 6620 7468 6520  omponent of the 
+00016c10: 6d61 676e 6574 6963 2066 6965 6c64 2e22  magnetic field."
+00016c20: 2c0a 2020 2020 290a 2020 2020 4874 6865  ,.    ).    Hthe
+00016c30: 7461 3a20 4669 656c 6450 726f 6a65 6374  ta: FieldProject
+00016c40: 696f 6e4b 5370 6163 6544 6174 6141 7272  ionKSpaceDataArr
+00016c50: 6179 203d 2070 642e 4669 656c 6428 0a20  ay = pd.Field(. 
+00016c60: 2020 2020 2020 202e 2e2e 2c0a 2020 2020         ...,.    
+00016c70: 2020 2020 7469 746c 653d 2248 7468 6574      title="Hthet
+00016c80: 6122 2c0a 2020 2020 2020 2020 6465 7363  a",.        desc
+00016c90: 7269 7074 696f 6e3d 2253 7061 7469 616c  ription="Spatial
+00016ca0: 2064 6973 7472 6962 7574 696f 6e20 6f66   distribution of
+00016cb0: 2074 6865 7461 2d63 6f6d 706f 6e65 6e74   theta-component
+00016cc0: 206f 6620 7468 6520 6d61 676e 6574 6963   of the magnetic
+00016cd0: 2066 6965 6c64 2e22 2c0a 2020 2020 290a   field.",.    ).
+00016ce0: 2020 2020 4870 6869 3a20 4669 656c 6450      Hphi: FieldP
+00016cf0: 726f 6a65 6374 696f 6e4b 5370 6163 6544  rojectionKSpaceD
+00016d00: 6174 6141 7272 6179 203d 2070 642e 4669  ataArray = pd.Fi
+00016d10: 656c 6428 0a20 2020 2020 2020 202e 2e2e  eld(.        ...
+00016d20: 2c0a 2020 2020 2020 2020 7469 746c 653d  ,.        title=
+00016d30: 2248 7068 6922 2c0a 2020 2020 2020 2020  "Hphi",.        
+00016d40: 6465 7363 7269 7074 696f 6e3d 2253 7061  description="Spa
+00016d50: 7469 616c 2064 6973 7472 6962 7574 696f  tial distributio
+00016d60: 6e20 6f66 2070 6869 2d63 6f6d 706f 6e65  n of phi-compone
+00016d70: 6e74 206f 6620 7468 6520 6d61 676e 6574  nt of the magnet
+00016d80: 6963 2066 6965 6c64 2e22 2c0a 2020 2020  ic field.",.    
+00016d90: 290a 0a20 2020 2040 7072 6f70 6572 7479  )..    @property
+00016da0: 0a20 2020 2064 6566 2075 7828 7365 6c66  .    def ux(self
+00016db0: 2920 2d3e 206e 702e 6e64 6172 7261 793a  ) -> np.ndarray:
+00016dc0: 0a20 2020 2020 2020 2022 2222 5265 6369  .        """Reci
+00016dd0: 7072 6f63 616c 2058 2070 6f73 6974 696f  procal X positio
+00016de0: 6e73 2e22 2222 0a20 2020 2020 2020 2072  ns.""".        r
+00016df0: 6574 7572 6e20 7365 6c66 2e45 7468 6574  eturn self.Ethet
+00016e00: 612e 7578 2e76 616c 7565 730a 0a20 2020  a.ux.values..   
+00016e10: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
+00016e20: 6566 2075 7928 7365 6c66 2920 2d3e 206e  ef uy(self) -> n
+00016e30: 702e 6e64 6172 7261 793a 0a20 2020 2020  p.ndarray:.     
+00016e40: 2020 2022 2222 5265 6369 7072 6f63 616c     """Reciprocal
+00016e50: 2059 2070 6f73 6974 696f 6e73 2e22 2222   Y positions."""
+00016e60: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00016e70: 7365 6c66 2e45 7468 6574 612e 7579 2e76  self.Etheta.uy.v
+00016e80: 616c 7565 730a 0a20 2020 2040 7072 6f70  alues..    @prop
+00016e90: 6572 7479 0a20 2020 2064 6566 2072 2873  erty.    def r(s
+00016ea0: 656c 6629 202d 3e20 6e70 2e6e 6461 7272  elf) -> np.ndarr
+00016eb0: 6179 3a0a 2020 2020 2020 2020 2222 2252  ay:.        """R
+00016ec0: 6164 6961 6c20 6469 7374 616e 6365 2e22  adial distance."
+00016ed0: 2222 0a20 2020 2020 2020 2072 6574 7572  "".        retur
+00016ee0: 6e20 7365 6c66 2e45 7468 6574 612e 722e  n self.Etheta.r.
+00016ef0: 7661 6c75 6573 0a0a 2020 2020 6465 6620  values..    def 
+00016f00: 7265 6e6f 726d 616c 697a 655f 6669 656c  renormalize_fiel
+00016f10: 6473 2873 656c 662c 2070 726f 6a5f 6469  ds(self, proj_di
+00016f20: 7374 616e 6365 3a20 666c 6f61 7429 202d  stance: float) -
+00016f30: 3e20 4669 656c 6450 726f 6a65 6374 696f  > FieldProjectio
+00016f40: 6e4b 5370 6163 6544 6174 613a 0a20 2020  nKSpaceData:.   
+00016f50: 2020 2020 2022 2222 5265 7475 726e 2061       """Return a
+00016f60: 203a 636c 6173 733a 602e 4669 656c 6450   :class:`.FieldP
+00016f70: 726f 6a65 6374 696f 6e4b 5370 6163 6544  rojectionKSpaceD
+00016f80: 6174 6160 2077 6974 6820 6669 656c 6473  ata` with fields
+00016f90: 2072 652d 6e6f 726d 616c 697a 6564 2074   re-normalized t
+00016fa0: 6f20 6120 6e65 770a 2020 2020 2020 2020  o a new.        
+00016fb0: 7072 6f6a 6563 7469 6f6e 2064 6973 7461  projection dista
+00016fc0: 6e63 652c 2062 7920 6170 706c 7969 6e67  nce, by applying
+00016fd0: 2061 2070 6861 7365 2066 6163 746f 7220   a phase factor 
+00016fe0: 6261 7365 6420 6f6e 2060 6070 726f 6a5f  based on ``proj_
+00016ff0: 6469 7374 616e 6365 6060 2e0a 0a20 2020  distance``...   
+00017000: 2020 2020 2050 6172 616d 6574 6572 730a       Parameters.
+00017010: 2020 2020 2020 2020 2d2d 2d2d 2d2d 2d2d          --------
+00017020: 2d2d 0a20 2020 2020 2020 2070 726f 6a5f  --.        proj_
+00017030: 6469 7374 616e 6365 203a 2066 6c6f 6174  distance : float
+00017040: 203d 204e 6f6e 650a 2020 2020 2020 2020   = None.        
+00017050: 2020 2020 286d 6963 726f 6e29 206e 6577      (micron) new
+00017060: 2072 6164 6961 6c20 6469 7374 616e 6365   radial distance
+00017070: 2072 656c 6174 6976 6520 746f 2074 6865   relative to the
+00017080: 206d 6f6e 6974 6f72 2773 206c 6f63 616c   monitor's local
+00017090: 206f 7269 6769 6e2e 0a0a 2020 2020 2020   origin...      
+000170a0: 2020 5265 7475 726e 730a 2020 2020 2020    Returns.      
+000170b0: 2020 2d2d 2d2d 2d2d 2d0a 2020 2020 2020    -------.      
+000170c0: 2020 3a63 6c61 7373 3a60 2e46 6965 6c64    :class:`.Field
+000170d0: 5072 6f6a 6563 7469 6f6e 4b53 7061 6365  ProjectionKSpace
+000170e0: 4461 7461 600a 2020 2020 2020 2020 2020  Data`.          
+000170f0: 2020 436f 7079 206f 6620 7468 6973 203a    Copy of this :
+00017100: 636c 6173 733a 602e 4669 656c 6450 726f  class:`.FieldPro
+00017110: 6a65 6374 696f 6e4b 5370 6163 6544 6174  jectionKSpaceDat
+00017120: 6160 2077 6974 6820 6669 656c 6473 2072  a` with fields r
+00017130: 652d 7072 6f6a 6563 7465 640a 2020 2020  e-projected.    
+00017140: 2020 2020 2020 2020 746f 2060 6070 726f          to ``pro
+00017150: 6a5f 6469 7374 616e 6365 6060 2e0a 2020  j_distance``..  
+00017160: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+00017170: 2020 6966 2073 656c 662e 6d6f 6e69 746f    if self.monito
+00017180: 7220 616e 6420 6e6f 7420 7365 6c66 2e6d  r and not self.m
+00017190: 6f6e 6974 6f72 2e66 6172 5f66 6965 6c64  onitor.far_field
+000171a0: 5f61 7070 726f 783a 0a20 2020 2020 2020  _approx:.       
+000171b0: 2020 2020 2072 6169 7365 2044 6174 6145       raise DataE
+000171c0: 7272 6f72 280a 2020 2020 2020 2020 2020  rror(.          
+000171d0: 2020 2020 2020 2246 6965 6c64 7320 7072        "Fields pr
+000171e0: 6f6a 6563 7465 6420 7769 7468 6f75 7420  ojected without 
+000171f0: 696e 766f 6b69 6e67 2074 6865 2066 6172  invoking the far
+00017200: 2066 6965 6c64 2061 7070 726f 7869 6d61   field approxima
+00017210: 7469 6f6e 2022 0a20 2020 2020 2020 2020  tion ".         
+00017220: 2020 2020 2020 2022 6361 6e6e 6f74 2062         "cannot b
+00017230: 6520 7265 2d70 726f 6a65 6374 6564 2074  e re-projected t
+00017240: 6f20 6120 6e65 7720 6469 7374 616e 6365  o a new distance
+00017250: 2e22 0a20 2020 2020 2020 2020 2020 2029  .".            )
+00017260: 0a0a 2020 2020 2020 2020 2320 7468 6520  ..        # the 
+00017270: 7068 6173 6520 6661 6374 6f72 2061 7373  phase factor ass
+00017280: 6f63 6961 7465 6420 7769 7468 2074 6865  ociated with the
+00017290: 206f 6c64 2064 6973 7461 6e63 6520 6d75   old distance mu
+000172a0: 7374 2062 6520 7265 6d6f 7665 640a 2020  st be removed.  
+000172b0: 2020 2020 2020 7220 3d20 7365 6c66 2e63        r = self.c
+000172c0: 6f6f 7264 735f 7370 6865 7269 6361 6c5b  oords_spherical[
+000172d0: 2272 225d 5b2e 2e2e 2c20 4e6f 6e65 5d0a  "r"][..., None].
+000172e0: 2020 2020 2020 2020 6f6c 645f 7068 6173          old_phas
+000172f0: 6520 3d20 7365 6c66 2e70 726f 7061 6761  e = self.propaga
+00017300: 7469 6f6e 5f70 6861 7365 2864 6973 743d  tion_phase(dist=
+00017310: 722c 206b 3d73 656c 662e 6b5b 4e6f 6e65  r, k=self.k[None
+00017320: 2c20 4e6f 6e65 2c20 4e6f 6e65 2c20 3a5d  , None, None, :]
+00017330: 290a 0a20 2020 2020 2020 2023 2074 6865  )..        # the
+00017340: 2070 6861 7365 2066 6163 746f 7220 6173   phase factor as
+00017350: 736f 6369 6174 6564 2077 6974 6820 7468  sociated with th
+00017360: 6520 6e65 7720 6469 7374 616e 6365 206d  e new distance m
+00017370: 7573 7420 6265 2061 7070 6c69 6564 0a20  ust be applied. 
+00017380: 2020 2020 2020 206e 6577 5f70 6861 7365         new_phase
+00017390: 203d 2073 656c 662e 7072 6f70 6167 6174   = self.propagat
+000173a0: 696f 6e5f 7068 6173 6528 6469 7374 3d70  ion_phase(dist=p
+000173b0: 726f 6a5f 6469 7374 616e 6365 2c20 6b3d  roj_distance, k=
+000173c0: 7365 6c66 2e6b 290a 0a20 2020 2020 2020  self.k)..       
+000173d0: 2023 206e 6574 2070 6861 7365 0a20 2020   # net phase.   
+000173e0: 2020 2020 2070 6861 7365 203d 206e 6577       phase = new
+000173f0: 5f70 6861 7365 5b4e 6f6e 652c 204e 6f6e  _phase[None, Non
+00017400: 652c 204e 6f6e 652c 203a 5d20 2f20 6f6c  e, None, :] / ol
+00017410: 645f 7068 6173 650a 0a20 2020 2020 2020  d_phase..       
+00017420: 2023 2063 6f6d 7075 7465 2075 7064 6174   # compute updat
+00017430: 6564 2066 6965 6c64 7320 616e 6420 7468  ed fields and th
+00017440: 6569 7220 636f 6f72 6469 6e61 7465 730a  eir coordinates.
+00017450: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+00017460: 656c 662e 6d61 6b65 5f72 656e 6f72 6d61  elf.make_renorma
+00017470: 6c69 7a65 645f 6461 7461 2870 6861 7365  lized_data(phase
+00017480: 2c20 7072 6f6a 5f64 6973 7461 6e63 6529  , proj_distance)
+00017490: 0a0a 0a63 6c61 7373 2044 6966 6672 6163  ...class Diffrac
+000174a0: 7469 6f6e 4461 7461 2841 6273 7472 6163  tionData(Abstrac
+000174b0: 7446 6965 6c64 5072 6f6a 6563 7469 6f6e  tFieldProjection
+000174c0: 4461 7461 293a 0a20 2020 2022 2222 4461  Data):.    """Da
+000174d0: 7461 2066 6f72 2061 203a 636c 6173 733a  ta for a :class:
+000174e0: 602e 4469 6666 7261 6374 696f 6e4d 6f6e  `.DiffractionMon
+000174f0: 6974 6f72 603a 2063 6f6d 706c 6578 2063  itor`: complex c
+00017500: 6f6d 706f 6e65 6e74 7320 6f66 2064 6966  omponents of dif
+00017510: 6672 6163 7465 6420 6661 7220 6669 656c  fracted far fiel
+00017520: 6473 2e0a 0a20 2020 2045 7861 6d70 6c65  ds...    Example
+00017530: 0a20 2020 202d 2d2d 2d2d 2d2d 0a20 2020  .    -------.   
+00017540: 203e 3e3e 2066 726f 6d20 7469 6479 3364   >>> from tidy3d
+00017550: 2069 6d70 6f72 7420 4469 6666 7261 6374   import Diffract
+00017560: 696f 6e44 6174 6141 7272 6179 0a20 2020  ionDataArray.   
+00017570: 203e 3e3e 2066 203d 206e 702e 6c69 6e73   >>> f = np.lins
+00017580: 7061 6365 2831 6531 342c 2032 6531 342c  pace(1e14, 2e14,
+00017590: 2031 3029 0a20 2020 203e 3e3e 206f 7264   10).    >>> ord
+000175a0: 6572 735f 7820 3d20 6c69 7374 2872 616e  ers_x = list(ran
+000175b0: 6765 282d 342c 2035 2929 0a20 2020 203e  ge(-4, 5)).    >
+000175c0: 3e3e 206f 7264 6572 735f 7920 3d20 6c69  >> orders_y = li
+000175d0: 7374 2872 616e 6765 282d 362c 2037 2929  st(range(-6, 7))
+000175e0: 0a20 2020 203e 3e3e 2070 6f6c 203d 205b  .    >>> pol = [
+000175f0: 2273 222c 2022 7022 5d0a 2020 2020 3e3e  "s", "p"].    >>
+00017600: 3e20 636f 6f72 6473 203d 2064 6963 7428  > coords = dict(
+00017610: 6f72 6465 7273 5f78 3d6f 7264 6572 735f  orders_x=orders_
+00017620: 782c 206f 7264 6572 735f 793d 6f72 6465  x, orders_y=orde
+00017630: 7273 5f79 2c20 663d 6629 0a20 2020 203e  rs_y, f=f).    >
+00017640: 3e3e 2076 616c 7565 7320 3d20 2831 2b31  >> values = (1+1
+00017650: 6a29 202a 206e 702e 7261 6e64 6f6d 2e72  j) * np.random.r
+00017660: 616e 646f 6d28 286c 656e 286f 7264 6572  andom((len(order
+00017670: 735f 7829 2c20 6c65 6e28 6f72 6465 7273  s_x), len(orders
+00017680: 5f79 292c 206c 656e 2866 2929 290a 2020  _y), len(f))).  
+00017690: 2020 3e3e 3e20 6669 656c 6420 3d20 4469    >>> field = Di
+000176a0: 6666 7261 6374 696f 6e44 6174 6141 7272  ffractionDataArr
+000176b0: 6179 2876 616c 7565 732c 2063 6f6f 7264  ay(values, coord
+000176c0: 733d 636f 6f72 6473 290a 2020 2020 3e3e  s=coords).    >>
+000176d0: 3e20 6d6f 6e69 746f 7220 3d20 4469 6666  > monitor = Diff
+000176e0: 7261 6374 696f 6e4d 6f6e 6974 6f72 280a  ractionMonitor(.
+000176f0: 2020 2020 2e2e 2e20 2020 2020 6365 6e74      ...     cent
+00017700: 6572 3d28 312c 322c 3329 2c20 7369 7a65  er=(1,2,3), size
+00017710: 3d28 6e70 2e69 6e66 2c6e 702e 696e 662c  =(np.inf,np.inf,
+00017720: 3029 2c20 6672 6571 733d 662c 206e 616d  0), freqs=f, nam
+00017730: 653d 2764 6966 6672 6163 7469 6f6e 270a  e='diffraction'.
+00017740: 2020 2020 2e2e 2e20 290a 2020 2020 3e3e      ... ).    >>
+00017750: 3e20 6461 7461 203d 2044 6966 6672 6163  > data = Diffrac
+00017760: 7469 6f6e 4461 7461 280a 2020 2020 2e2e  tionData(.    ..
+00017770: 2e20 2020 2020 6d6f 6e69 746f 723d 6d6f  .     monitor=mo
+00017780: 6e69 746f 722c 2073 696d 5f73 697a 653d  nitor, sim_size=
+00017790: 5b31 2c31 5d2c 2062 6c6f 6368 5f76 6563  [1,1], bloch_vec
+000177a0: 733d 5b31 2c32 5d2c 0a20 2020 202e 2e2e  s=[1,2],.    ...
+000177b0: 2020 2020 2045 7468 6574 613d 6669 656c       Etheta=fiel
+000177c0: 642c 2045 7068 693d 6669 656c 642c 2045  d, Ephi=field, E
+000177d0: 723d 6669 656c 642c 0a20 2020 202e 2e2e  r=field,.    ...
+000177e0: 2020 2020 2048 7468 6574 613d 6669 656c       Htheta=fiel
+000177f0: 642c 2048 7068 693d 6669 656c 642c 2048  d, Hphi=field, H
+00017800: 723d 6669 656c 642c 0a20 2020 202e 2e2e  r=field,.    ...
+00017810: 2029 0a20 2020 2022 2222 0a0a 2020 2020   ).    """..    
+00017820: 6d6f 6e69 746f 723a 2044 6966 6672 6163  monitor: Diffrac
+00017830: 7469 6f6e 4d6f 6e69 746f 7220 3d20 7064  tionMonitor = pd
+00017840: 2e46 6965 6c64 280a 2020 2020 2020 2020  .Field(.        
+00017850: 2e2e 2e2c 2074 6974 6c65 3d22 4d6f 6e69  ..., title="Moni
+00017860: 746f 7222 2c20 6465 7363 7269 7074 696f  tor", descriptio
+00017870: 6e3d 2244 6966 6672 6163 7469 6f6e 206d  n="Diffraction m
+00017880: 6f6e 6974 6f72 2061 7373 6f63 6961 7465  onitor associate
+00017890: 6420 7769 7468 2074 6865 2064 6174 612e  d with the data.
+000178a0: 220a 2020 2020 290a 0a20 2020 2045 723a  ".    )..    Er:
+000178b0: 2044 6966 6672 6163 7469 6f6e 4461 7461   DiffractionData
+000178c0: 4172 7261 7920 3d20 7064 2e46 6965 6c64  Array = pd.Field
+000178d0: 280a 2020 2020 2020 2020 2e2e 2e2c 0a20  (.        ...,. 
+000178e0: 2020 2020 2020 2074 6974 6c65 3d22 4572         title="Er
+000178f0: 222c 0a20 2020 2020 2020 2064 6573 6372  ",.        descr
+00017900: 6970 7469 6f6e 3d22 5370 6174 6961 6c20  iption="Spatial 
+00017910: 6469 7374 7269 6275 7469 6f6e 206f 6620  distribution of 
+00017920: 722d 636f 6d70 6f6e 656e 7420 6f66 2074  r-component of t
+00017930: 6865 2065 6c65 6374 7269 6320 6669 656c  he electric fiel
+00017940: 642e 222c 0a20 2020 2029 0a20 2020 2045  d.",.    ).    E
+00017950: 7468 6574 613a 2044 6966 6672 6163 7469  theta: Diffracti
+00017960: 6f6e 4461 7461 4172 7261 7920 3d20 7064  onDataArray = pd
+00017970: 2e46 6965 6c64 280a 2020 2020 2020 2020  .Field(.        
+00017980: 2e2e 2e2c 0a20 2020 2020 2020 2074 6974  ...,.        tit
+00017990: 6c65 3d22 4574 6865 7461 222c 0a20 2020  le="Etheta",.   
+000179a0: 2020 2020 2064 6573 6372 6970 7469 6f6e       description
+000179b0: 3d22 5370 6174 6961 6c20 6469 7374 7269  ="Spatial distri
+000179c0: 6275 7469 6f6e 206f 6620 7468 6520 7468  bution of the th
+000179d0: 6574 612d 636f 6d70 6f6e 656e 7420 6f66  eta-component of
+000179e0: 2074 6865 2065 6c65 6374 7269 6320 6669   the electric fi
+000179f0: 656c 642e 222c 0a20 2020 2029 0a20 2020  eld.",.    ).   
+00017a00: 2045 7068 693a 2044 6966 6672 6163 7469   Ephi: Diffracti
+00017a10: 6f6e 4461 7461 4172 7261 7920 3d20 7064  onDataArray = pd
+00017a20: 2e46 6965 6c64 280a 2020 2020 2020 2020  .Field(.        
+00017a30: 2e2e 2e2c 0a20 2020 2020 2020 2074 6974  ...,.        tit
+00017a40: 6c65 3d22 4570 6869 222c 0a20 2020 2020  le="Ephi",.     
+00017a50: 2020 2064 6573 6372 6970 7469 6f6e 3d22     description="
+00017a60: 5370 6174 6961 6c20 6469 7374 7269 6275  Spatial distribu
+00017a70: 7469 6f6e 206f 6620 7068 692d 636f 6d70  tion of phi-comp
+00017a80: 6f6e 656e 7420 6f66 2074 6865 2065 6c65  onent of the ele
+00017a90: 6374 7269 6320 6669 656c 642e 222c 0a20  ctric field.",. 
+00017aa0: 2020 2029 0a20 2020 2048 723a 2044 6966     ).    Hr: Dif
+00017ab0: 6672 6163 7469 6f6e 4461 7461 4172 7261  fractionDataArra
+00017ac0: 7920 3d20 7064 2e46 6965 6c64 280a 2020  y = pd.Field(.  
+00017ad0: 2020 2020 2020 2e2e 2e2c 0a20 2020 2020        ...,.     
+00017ae0: 2020 2074 6974 6c65 3d22 4872 222c 0a20     title="Hr",. 
+00017af0: 2020 2020 2020 2064 6573 6372 6970 7469         descripti
+00017b00: 6f6e 3d22 5370 6174 6961 6c20 6469 7374  on="Spatial dist
+00017b10: 7269 6275 7469 6f6e 206f 6620 722d 636f  ribution of r-co
+00017b20: 6d70 6f6e 656e 7420 6f66 2074 6865 206d  mponent of the m
+00017b30: 6167 6e65 7469 6320 6669 656c 642e 222c  agnetic field.",
+00017b40: 0a20 2020 2029 0a20 2020 2048 7468 6574  .    ).    Hthet
+00017b50: 613a 2044 6966 6672 6163 7469 6f6e 4461  a: DiffractionDa
+00017b60: 7461 4172 7261 7920 3d20 7064 2e46 6965  taArray = pd.Fie
+00017b70: 6c64 280a 2020 2020 2020 2020 2e2e 2e2c  ld(.        ...,
+00017b80: 0a20 2020 2020 2020 2074 6974 6c65 3d22  .        title="
+00017b90: 4874 6865 7461 222c 0a20 2020 2020 2020  Htheta",.       
+00017ba0: 2064 6573 6372 6970 7469 6f6e 3d22 5370   description="Sp
+00017bb0: 6174 6961 6c20 6469 7374 7269 6275 7469  atial distributi
+00017bc0: 6f6e 206f 6620 7468 6574 612d 636f 6d70  on of theta-comp
+00017bd0: 6f6e 656e 7420 6f66 2074 6865 206d 6167  onent of the mag
+00017be0: 6e65 7469 6320 6669 656c 642e 222c 0a20  netic field.",. 
+00017bf0: 2020 2029 0a20 2020 2048 7068 693a 2044     ).    Hphi: D
+00017c00: 6966 6672 6163 7469 6f6e 4461 7461 4172  iffractionDataAr
+00017c10: 7261 7920 3d20 7064 2e46 6965 6c64 280a  ray = pd.Field(.
+00017c20: 2020 2020 2020 2020 2e2e 2e2c 0a20 2020          ...,.   
+00017c30: 2020 2020 2074 6974 6c65 3d22 4870 6869       title="Hphi
+00017c40: 222c 0a20 2020 2020 2020 2064 6573 6372  ",.        descr
+00017c50: 6970 7469 6f6e 3d22 5370 6174 6961 6c20  iption="Spatial 
+00017c60: 6469 7374 7269 6275 7469 6f6e 206f 6620  distribution of 
+00017c70: 7068 692d 636f 6d70 6f6e 656e 7420 6f66  phi-component of
+00017c80: 2074 6865 206d 6167 6e65 7469 6320 6669   the magnetic fi
+00017c90: 656c 642e 222c 0a20 2020 2029 0a0a 2020  eld.",.    )..  
+00017ca0: 2020 7369 6d5f 7369 7a65 3a20 5475 706c    sim_size: Tupl
+00017cb0: 655b 666c 6f61 742c 2066 6c6f 6174 5d20  e[float, float] 
+00017cc0: 3d20 7064 2e46 6965 6c64 280a 2020 2020  = pd.Field(.    
+00017cd0: 2020 2020 2e2e 2e2c 0a20 2020 2020 2020      ...,.       
+00017ce0: 2074 6974 6c65 3d22 446f 6d61 696e 2073   title="Domain s
+00017cf0: 697a 6522 2c0a 2020 2020 2020 2020 6465  ize",.        de
+00017d00: 7363 7269 7074 696f 6e3d 2253 697a 6520  scription="Size 
+00017d10: 6f66 2074 6865 206e 6561 7220 6669 656c  of the near fiel
+00017d20: 6420 696e 2074 6865 206c 6f63 616c 2078  d in the local x
+00017d30: 2061 6e64 2079 2064 6972 6563 7469 6f6e   and y direction
+00017d40: 732e 222c 0a20 2020 2020 2020 2075 6e69  s.",.        uni
+00017d50: 7473 3d4d 4943 524f 4d45 5445 522c 0a20  ts=MICROMETER,. 
+00017d60: 2020 2029 0a0a 2020 2020 626c 6f63 685f     )..    bloch_
+00017d70: 7665 6373 3a20 5475 706c 655b 666c 6f61  vecs: Tuple[floa
+00017d80: 742c 2066 6c6f 6174 5d20 3d20 7064 2e46  t, float] = pd.F
+00017d90: 6965 6c64 280a 2020 2020 2020 2020 2e2e  ield(.        ..
+00017da0: 2e2c 0a20 2020 2020 2020 2074 6974 6c65  .,.        title
+00017db0: 3d22 426c 6f63 6820 7665 6374 6f72 7322  ="Bloch vectors"
+00017dc0: 2c0a 2020 2020 2020 2020 6465 7363 7269  ,.        descri
+00017dd0: 7074 696f 6e3d 2242 6c6f 6368 2076 6563  ption="Bloch vec
+00017de0: 746f 7273 2061 6c6f 6e67 2074 6865 206c  tors along the l
+00017df0: 6f63 616c 2078 2061 6e64 2079 2064 6972  ocal x and y dir
+00017e00: 6563 7469 6f6e 7320 696e 2075 6e69 7473  ections in units
+00017e10: 206f 6620 220a 2020 2020 2020 2020 2260   of ".        "`
+00017e20: 6032 202a 2070 6920 2f20 2873 696d 756c  `2 * pi / (simul
+00017e30: 6174 696f 6e20 7369 7a65 2061 6c6f 6e67  ation size along
+00017e40: 2074 6865 2072 6573 7065 6374 6976 6520   the respective 
+00017e50: 6469 6d65 6e73 696f 6e29 6060 2e22 2c0a  dimension)``.",.
+00017e60: 2020 2020 290a 0a20 2020 2040 7374 6174      )..    @stat
+00017e70: 6963 6d65 7468 6f64 0a20 2020 2064 6566  icmethod.    def
+00017e80: 2073 6869 6674 6564 5f6f 7264 6572 7328   shifted_orders(
+00017e90: 6f72 6465 7273 3a20 5475 706c 655b 696e  orders: Tuple[in
+00017ea0: 742c 202e 2e2e 5d2c 2062 6c6f 6368 5f76  t, ...], bloch_v
+00017eb0: 6563 3a20 666c 6f61 7429 202d 3e20 6e70  ec: float) -> np
+00017ec0: 2e6e 6461 7272 6179 3a0a 2020 2020 2020  .ndarray:.      
+00017ed0: 2020 2222 2244 6966 6672 6163 7469 6f6e    """Diffraction
+00017ee0: 206f 7264 6572 7320 7368 6966 7465 6420   orders shifted 
+00017ef0: 6279 2074 6865 2042 6c6f 6368 2076 6563  by the Bloch vec
+00017f00: 746f 722e 2222 220a 2020 2020 2020 2020  tor.""".        
+00017f10: 7265 7475 726e 2062 6c6f 6368 5f76 6563  return bloch_vec
+00017f20: 202b 206e 702e 6174 6c65 6173 745f 3164   + np.atleast_1d
+00017f30: 286f 7264 6572 7329 0a0a 2020 2020 4073  (orders)..    @s
+00017f40: 7461 7469 636d 6574 686f 640a 2020 2020  taticmethod.    
+00017f50: 6465 6620 7265 6369 7072 6f63 616c 5f63  def reciprocal_c
+00017f60: 6f6f 7264 7328 0a20 2020 2020 2020 206f  oords(.        o
+00017f70: 7264 6572 733a 206e 702e 6e64 6172 7261  rders: np.ndarra
+00017f80: 792c 2073 697a 653a 2066 6c6f 6174 2c20  y, size: float, 
+00017f90: 626c 6f63 685f 7665 633a 2066 6c6f 6174  bloch_vec: float
+00017fa0: 2c20 663a 2066 6c6f 6174 2c20 6d65 6469  , f: float, medi
+00017fb0: 756d 3a20 4d65 6469 756d 5479 7065 0a20  um: MediumType. 
+00017fc0: 2020 2029 202d 3e20 6e70 2e6e 6461 7272     ) -> np.ndarr
+00017fd0: 6179 3a0a 2020 2020 2020 2020 2222 2247  ay:.        """G
+00017fe0: 6574 2074 6865 206e 6f72 6d61 6c69 7a65  et the normalize
+00017ff0: 6420 2275 2220 7265 6369 7072 6f63 616c  d "u" reciprocal
+00018000: 2063 6f6f 7264 7320 666f 7220 6120 7665   coords for a ve
+00018010: 6374 6f72 206f 6620 6f72 6465 7273 2c20  ctor of orders, 
+00018020: 7369 7a65 2c20 616e 6420 626c 6f63 6820  size, and bloch 
+00018030: 7665 632e 2222 220a 2020 2020 2020 2020  vec.""".        
+00018040: 6966 2073 697a 6520 3d3d 2030 3a0a 2020  if size == 0:.  
+00018050: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00018060: 206e 702e 6174 6c65 6173 745f 3264 2830   np.atleast_2d(0
+00018070: 290a 2020 2020 2020 2020 6570 7369 6c6f  ).        epsilo
+00018080: 6e20 3d20 6d65 6469 756d 2e65 7073 5f6d  n = medium.eps_m
+00018090: 6f64 656c 2866 290a 2020 2020 2020 2020  odel(f).        
+000180a0: 626c 6f63 685f 6172 7261 7920 3d20 4469  bloch_array = Di
+000180b0: 6666 7261 6374 696f 6e44 6174 612e 7368  ffractionData.sh
+000180c0: 6966 7465 645f 6f72 6465 7273 286f 7264  ifted_orders(ord
+000180d0: 6572 732c 2062 6c6f 6368 5f76 6563 290a  ers, bloch_vec).
+000180e0: 2020 2020 2020 2020 7265 7475 726e 2062          return b
+000180f0: 6c6f 6368 5f61 7272 6179 5b3a 2c20 4e6f  loch_array[:, No
+00018100: 6e65 5d20 2f20 7369 7a65 202a 2043 5f30  ne] / size * C_0
+00018110: 202f 2066 202f 206e 702e 7265 616c 286e   / f / np.real(n
+00018120: 702e 7371 7274 2865 7073 696c 6f6e 2929  p.sqrt(epsilon))
+00018130: 0a0a 2020 2020 4073 7461 7469 636d 6574  ..    @staticmet
+00018140: 686f 640a 2020 2020 6465 6620 636f 6d70  hod.    def comp
+00018150: 7574 655f 616e 676c 6573 280a 2020 2020  ute_angles(.    
+00018160: 2020 2020 7265 6369 7072 6f63 616c 5f76      reciprocal_v
+00018170: 6563 746f 7273 3a20 5475 706c 655b 6e70  ectors: Tuple[np
+00018180: 2e6e 6461 7272 6179 2c20 6e70 2e6e 6461  .ndarray, np.nda
+00018190: 7272 6179 5d2c 0a20 2020 2029 202d 3e20  rray],.    ) -> 
+000181a0: 5475 706c 655b 6e70 2e6e 6461 7272 6179  Tuple[np.ndarray
+000181b0: 2c20 6e70 2e6e 6461 7272 6179 5d3a 0a20  , np.ndarray]:. 
+000181c0: 2020 2020 2020 2022 2222 436f 6d70 7574         """Comput
+000181d0: 6520 7468 6520 706f 6c61 7220 616e 6420  e the polar and 
+000181e0: 617a 696d 7574 6820 616e 676c 6573 2061  azimuth angles a
+000181f0: 7373 6f63 6961 7465 6420 7769 7468 2074  ssociated with t
+00018200: 6865 2067 6976 656e 2072 6563 6970 726f  he given recipro
+00018210: 6361 6c20 7665 6374 6f72 732e 2222 220a  cal vectors.""".
+00018220: 2020 2020 2020 2020 2320 736f 6d65 2077          # some w
+00018230: 6176 6520 6e75 6d62 6572 2070 6169 7273  ave number pairs
+00018240: 2061 7265 206f 7574 7369 6465 2074 6865   are outside the
+00018250: 206c 6967 6874 2063 6f6e 652c 206c 6561   light cone, lea
+00018260: 6469 6e67 2074 6f20 7761 726e 696e 6773  ding to warnings
+00018270: 2066 726f 6d20 6e75 6d70 792e 6172 6373   from numpy.arcs
+00018280: 696e 0a20 2020 2020 2020 2077 6974 6820  in.        with 
+00018290: 7761 726e 696e 6773 2e63 6174 6368 5f77  warnings.catch_w
+000182a0: 6172 6e69 6e67 7328 293a 0a20 2020 2020  arnings():.     
+000182b0: 2020 2020 2020 2077 6172 6e69 6e67 732e         warnings.
+000182c0: 6669 6c74 6572 7761 726e 696e 6773 280a  filterwarnings(.
+000182d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000182e0: 2269 676e 6f72 6522 2c20 6d65 7373 6167  "ignore", messag
+000182f0: 653d 2269 6e76 616c 6964 2076 616c 7565  e="invalid value
+00018300: 2065 6e63 6f75 6e74 6572 6564 2069 6e20   encountered in 
+00018310: 6172 6373 696e 222c 2063 6174 6567 6f72  arcsin", categor
+00018320: 793d 5275 6e74 696d 6557 6172 6e69 6e67  y=RuntimeWarning
+00018330: 0a20 2020 2020 2020 2020 2020 2029 0a20  .            ). 
+00018340: 2020 2020 2020 2020 2020 2075 782c 2075             ux, u
+00018350: 7920 3d20 7265 6369 7072 6f63 616c 5f76  y = reciprocal_v
+00018360: 6563 746f 7273 0a20 2020 2020 2020 2020  ectors.         
+00018370: 2020 2074 6865 7461 732c 2070 6869 7320     thetas, phis 
+00018380: 3d20 4469 6666 7261 6374 696f 6e4d 6f6e  = DiffractionMon
+00018390: 6974 6f72 2e6b 7370 6163 655f 325f 7370  itor.kspace_2_sp
+000183a0: 6828 7578 5b3a 2c20 4e6f 6e65 2c20 3a5d  h(ux[:, None, :]
+000183b0: 2c20 7579 5b4e 6f6e 652c 203a 2c20 3a5d  , uy[None, :, :]
+000183c0: 2c20 6178 6973 3d32 290a 2020 2020 2020  , axis=2).      
+000183d0: 2020 7265 7475 726e 2028 7468 6574 6173    return (thetas
+000183e0: 2c20 7068 6973 290a 0a20 2020 2040 7072  , phis)..    @pr
+000183f0: 6f70 6572 7479 0a20 2020 2064 6566 2063  operty.    def c
+00018400: 6f6f 7264 735f 7370 6865 7269 6361 6c28  oords_spherical(
+00018410: 7365 6c66 2920 2d3e 2044 6963 745b 7374  self) -> Dict[st
+00018420: 722c 206e 702e 6e64 6172 7261 795d 3a0a  r, np.ndarray]:.
+00018430: 2020 2020 2020 2020 2222 2243 6f6f 7264          """Coord
+00018440: 696e 6174 6573 2067 7269 6420 666f 7220  inates grid for 
+00018450: 7468 6520 6669 656c 6473 2069 6e20 7468  the fields in th
+00018460: 6520 7370 6865 7269 6361 6c20 7379 7374  e spherical syst
+00018470: 656d 2e22 2222 0a20 2020 2020 2020 2074  em.""".        t
+00018480: 6865 7461 2c20 7068 6920 3d20 7365 6c66  heta, phi = self
+00018490: 2e61 6e67 6c65 730a 2020 2020 2020 2020  .angles.        
+000184a0: 7265 7475 726e 207b 2272 223a 204e 6f6e  return {"r": Non
+000184b0: 652c 2022 7468 6574 6122 3a20 7468 6574  e, "theta": thet
+000184c0: 612c 2022 7068 6922 3a20 7068 697d 0a0a  a, "phi": phi}..
+000184d0: 2020 2020 4070 726f 7065 7274 790a 2020      @property.  
+000184e0: 2020 6465 6620 6f72 6465 7273 5f78 2873    def orders_x(s
+000184f0: 656c 6629 202d 3e20 6e70 2e6e 6461 7272  elf) -> np.ndarr
+00018500: 6179 3a0a 2020 2020 2020 2020 2222 2241  ay:.        """A
+00018510: 6c6c 6f77 6564 206f 7264 6572 7320 616c  llowed orders al
+00018520: 6f6e 6720 782e 2222 220a 2020 2020 2020  ong x.""".      
+00018530: 2020 7265 7475 726e 206e 702e 6174 6c65    return np.atle
+00018540: 6173 745f 3164 286e 702e 6172 7261 7928  ast_1d(np.array(
+00018550: 7365 6c66 2e45 7468 6574 612e 636f 6f72  self.Etheta.coor
+00018560: 6473 5b22 6f72 6465 7273 5f78 225d 2929  ds["orders_x"]))
+00018570: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
+00018580: 2020 2020 6465 6620 6f72 6465 7273 5f79      def orders_y
+00018590: 2873 656c 6629 202d 3e20 6e70 2e6e 6461  (self) -> np.nda
+000185a0: 7272 6179 3a0a 2020 2020 2020 2020 2222  rray:.        ""
+000185b0: 2241 6c6c 6f77 6564 206f 7264 6572 7320  "Allowed orders 
+000185c0: 616c 6f6e 6720 792e 2222 220a 2020 2020  along y.""".    
+000185d0: 2020 2020 7265 7475 726e 206e 702e 6174      return np.at
+000185e0: 6c65 6173 745f 3164 286e 702e 6172 7261  least_1d(np.arra
+000185f0: 7928 7365 6c66 2e45 7468 6574 612e 636f  y(self.Etheta.co
+00018600: 6f72 6473 5b22 6f72 6465 7273 5f79 225d  ords["orders_y"]
+00018610: 2929 0a0a 2020 2020 4070 726f 7065 7274  ))..    @propert
+00018620: 790a 2020 2020 6465 6620 7265 6369 7072  y.    def recipr
+00018630: 6f63 616c 5f76 6563 746f 7273 2873 656c  ocal_vectors(sel
+00018640: 6629 202d 3e20 5475 706c 655b 6e70 2e6e  f) -> Tuple[np.n
+00018650: 6461 7272 6179 2c20 6e70 2e6e 6461 7272  darray, np.ndarr
+00018660: 6179 5d3a 0a20 2020 2020 2020 2022 2222  ay]:.        """
+00018670: 4765 7420 7468 6520 6e6f 726d 616c 697a  Get the normaliz
+00018680: 6564 2022 7578 2220 616e 6420 2275 7922  ed "ux" and "uy"
+00018690: 2072 6563 6970 726f 6361 6c20 7665 6374   reciprocal vect
+000186a0: 6f72 732e 2222 220a 2020 2020 2020 2020  ors.""".        
+000186b0: 7265 7475 726e 2028 7365 6c66 2e75 782c  return (self.ux,
+000186c0: 2073 656c 662e 7579 290a 0a20 2020 2040   self.uy)..    @
+000186d0: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
+000186e0: 2075 7828 7365 6c66 2920 2d3e 206e 702e   ux(self) -> np.
+000186f0: 6e64 6172 7261 793a 0a20 2020 2020 2020  ndarray:.       
+00018700: 2022 2222 4e6f 726d 616c 697a 6564 2077   """Normalized w
+00018710: 6176 6520 7665 6374 6f72 2061 6c6f 6e67  ave vector along
+00018720: 2078 2072 656c 6174 6976 6520 746f 2060   x relative to `
+00018730: 606c 6f63 616c 5f6f 7269 6769 6e60 6020  `local_origin`` 
+00018740: 616e 6420 6f72 6965 6e74 6564 0a20 2020  and oriented.   
+00018750: 2020 2020 2077 6974 6820 7265 7370 6563       with respec
+00018760: 7420 746f 2060 606d 6f6e 6974 6f72 2e6e  t to ``monitor.n
+00018770: 6f72 6d61 6c5f 6469 7260 602c 206e 6f72  ormal_dir``, nor
+00018780: 6d61 6c69 7a65 6420 6279 2074 6865 2077  malized by the w
+00018790: 6176 6520 6e75 6d62 6572 2069 6e20 7468  ave number in th
+000187a0: 650a 2020 2020 2020 2020 7072 6f6a 6563  e.        projec
+000187b0: 7469 6f6e 206d 6564 6975 6d2e 2222 220a  tion medium.""".
+000187c0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+000187d0: 656c 662e 7265 6369 7072 6f63 616c 5f63  elf.reciprocal_c
+000187e0: 6f6f 7264 7328 0a20 2020 2020 2020 2020  oords(.         
+000187f0: 2020 206f 7264 6572 733d 7365 6c66 2e6f     orders=self.o
+00018800: 7264 6572 735f 782c 0a20 2020 2020 2020  rders_x,.       
+00018810: 2020 2020 2073 697a 653d 7365 6c66 2e73       size=self.s
+00018820: 696d 5f73 697a 655b 305d 2c0a 2020 2020  im_size[0],.    
+00018830: 2020 2020 2020 2020 626c 6f63 685f 7665          bloch_ve
+00018840: 633d 7365 6c66 2e62 6c6f 6368 5f76 6563  c=self.bloch_vec
+00018850: 735b 305d 2c0a 2020 2020 2020 2020 2020  s[0],.          
+00018860: 2020 663d 7365 6c66 2e66 2c0a 2020 2020    f=self.f,.    
+00018870: 2020 2020 2020 2020 6d65 6469 756d 3d73          medium=s
+00018880: 656c 662e 6d65 6469 756d 2c0a 2020 2020  elf.medium,.    
+00018890: 2020 2020 290a 0a20 2020 2040 7072 6f70      )..    @prop
+000188a0: 6572 7479 0a20 2020 2064 6566 2075 7928  erty.    def uy(
+000188b0: 7365 6c66 2920 2d3e 206e 702e 6e64 6172  self) -> np.ndar
+000188c0: 7261 793a 0a20 2020 2020 2020 2022 2222  ray:.        """
+000188d0: 4e6f 726d 616c 697a 6564 2077 6176 6520  Normalized wave 
+000188e0: 7665 6374 6f72 2061 6c6f 6e67 2079 2072  vector along y r
+000188f0: 656c 6174 6976 6520 746f 2060 606c 6f63  elative to ``loc
+00018900: 616c 5f6f 7269 6769 6e60 6020 616e 6420  al_origin`` and 
+00018910: 6f72 6965 6e74 6564 0a20 2020 2020 2020  oriented.       
+00018920: 2077 6974 6820 7265 7370 6563 7420 746f   with respect to
+00018930: 2060 606d 6f6e 6974 6f72 2e6e 6f72 6d61   ``monitor.norma
+00018940: 6c5f 6469 7260 602c 206e 6f72 6d61 6c69  l_dir``, normali
+00018950: 7a65 6420 6279 2074 6865 2077 6176 6520  zed by the wave 
+00018960: 6e75 6d62 6572 2069 6e20 7468 650a 2020  number in the.  
+00018970: 2020 2020 2020 7072 6f6a 6563 7469 6f6e        projection
+00018980: 206d 6564 6975 6d2e 2222 220a 2020 2020   medium.""".    
+00018990: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+000189a0: 7265 6369 7072 6f63 616c 5f63 6f6f 7264  reciprocal_coord
+000189b0: 7328 0a20 2020 2020 2020 2020 2020 206f  s(.            o
+000189c0: 7264 6572 733d 7365 6c66 2e6f 7264 6572  rders=self.order
+000189d0: 735f 792c 0a20 2020 2020 2020 2020 2020  s_y,.           
+000189e0: 2073 697a 653d 7365 6c66 2e73 696d 5f73   size=self.sim_s
+000189f0: 697a 655b 315d 2c0a 2020 2020 2020 2020  ize[1],.        
+00018a00: 2020 2020 626c 6f63 685f 7665 633d 7365      bloch_vec=se
+00018a10: 6c66 2e62 6c6f 6368 5f76 6563 735b 315d  lf.bloch_vecs[1]
+00018a20: 2c0a 2020 2020 2020 2020 2020 2020 663d  ,.            f=
+00018a30: 7365 6c66 2e66 2c0a 2020 2020 2020 2020  self.f,.        
+00018a40: 2020 2020 6d65 6469 756d 3d73 656c 662e      medium=self.
+00018a50: 6d65 6469 756d 2c0a 2020 2020 2020 2020  medium,.        
+00018a60: 290a 0a20 2020 2040 7072 6f70 6572 7479  )..    @property
+00018a70: 0a20 2020 2064 6566 2061 6e67 6c65 7328  .    def angles(
+00018a80: 7365 6c66 2920 2d3e 2054 7570 6c65 5b78  self) -> Tuple[x
+00018a90: 722e 4461 7461 4172 7261 795d 3a0a 2020  r.DataArray]:.  
+00018aa0: 2020 2020 2020 2222 2254 6865 2028 7468        """The (th
+00018ab0: 6574 612c 2070 6869 2920 616e 676c 6573  eta, phi) angles
+00018ac0: 2063 6f72 7265 7370 6f6e 6469 6e67 2074   corresponding t
+00018ad0: 6f20 6561 6368 2061 6c6c 6f77 6564 2070  o each allowed p
+00018ae0: 6169 7220 6f66 2064 6966 6672 6163 7469  air of diffracti
+00018af0: 6f6e 0a20 2020 2020 2020 206f 7264 6572  on.        order
+00018b00: 7320 7374 6f72 6564 7320 6173 2064 6174  s storeds as dat
+00018b10: 6120 6172 7261 7973 2e20 4469 7361 6c6c  a arrays. Disall
+00018b20: 6f77 6564 2061 6e67 6c65 7320 6172 6520  owed angles are 
+00018b30: 7365 7420 746f 2060 606e 702e 6e61 6e60  set to ``np.nan`
+00018b40: 602e 0a20 2020 2020 2020 2022 2222 0a20  `..        """. 
+00018b50: 2020 2020 2020 2074 6865 7461 732c 2070         thetas, p
+00018b60: 6869 7320 3d20 7365 6c66 2e63 6f6d 7075  his = self.compu
+00018b70: 7465 5f61 6e67 6c65 7328 7365 6c66 2e72  te_angles(self.r
+00018b80: 6563 6970 726f 6361 6c5f 7665 6374 6f72  eciprocal_vector
+00018b90: 7329 0a20 2020 2020 2020 2074 6865 7461  s).        theta
+00018ba0: 5f64 6174 6120 3d20 7872 2e44 6174 6141  _data = xr.DataA
+00018bb0: 7272 6179 2874 6865 7461 732c 2063 6f6f  rray(thetas, coo
+00018bc0: 7264 733d 7365 6c66 2e63 6f6f 7264 7329  rds=self.coords)
+00018bd0: 0a20 2020 2020 2020 2070 6869 5f64 6174  .        phi_dat
+00018be0: 6120 3d20 7872 2e44 6174 6141 7272 6179  a = xr.DataArray
+00018bf0: 2870 6869 732c 2063 6f6f 7264 733d 7365  (phis, coords=se
+00018c00: 6c66 2e63 6f6f 7264 7329 0a20 2020 2020  lf.coords).     
+00018c10: 2020 2072 6574 7572 6e20 7468 6574 615f     return theta_
+00018c20: 6461 7461 2c20 7068 695f 6461 7461 0a0a  data, phi_data..
+00018c30: 2020 2020 4070 726f 7065 7274 790a 2020      @property.  
+00018c40: 2020 6465 6620 616d 7073 2873 656c 6629    def amps(self)
+00018c50: 202d 3e20 7872 2e44 6174 6141 7272 6179   -> xr.DataArray
+00018c60: 3a0a 2020 2020 2020 2020 2222 2243 6f6d  :.        """Com
+00018c70: 706c 6578 2070 6f77 6572 2061 6d70 6c69  plex power ampli
+00018c80: 7475 6465 2069 6e20 6561 6368 206f 7264  tude in each ord
+00018c90: 6572 2066 6f72 2027 7327 2061 6e64 2027  er for 's' and '
+00018ca0: 7027 2070 6f6c 6172 697a 6174 696f 6e73  p' polarizations
+00018cb0: 2c20 6e6f 726d 616c 697a 6564 2073 6f20  , normalized so 
+00018cc0: 7468 6174 0a20 2020 2020 2020 2074 6865  that.        the
+00018cd0: 2070 6f77 6572 2063 6172 7269 6564 2062   power carried b
+00018ce0: 7920 7468 6520 7761 7665 206f 6620 7468  y the wave of th
+00018cf0: 6174 206f 7264 6572 2061 6e64 2070 6f6c  at order and pol
+00018d00: 6172 697a 6174 696f 6e20 6571 7561 6c73  arization equals
+00018d10: 2060 6061 6273 2861 6d70 7329 5e32 6060   ``abs(amps)^2``
+00018d20: 2e0a 2020 2020 2020 2020 2222 220a 2020  ..        """.  
+00018d30: 2020 2020 2020 636f 735f 7468 6574 6120        cos_theta 
+00018d40: 3d20 6e70 2e63 6f73 286e 702e 6e61 6e5f  = np.cos(np.nan_
+00018d50: 746f 5f6e 756d 2873 656c 662e 616e 676c  to_num(self.angl
+00018d60: 6573 5b30 5d29 290a 0a20 2020 2020 2020  es[0]))..       
+00018d70: 2023 2077 696c 6c20 7365 7420 616d 706c   # will set ampl
+00018d80: 6974 7564 6573 2074 6f20 3020 666f 7220  itudes to 0 for 
+00018d90: 676c 616e 6369 6e67 206f 7220 6e65 6761  glancing or nega
+00018da0: 7469 7665 2061 6e67 6c65 730a 2020 2020  tive angles.    
+00018db0: 2020 2020 636f 735f 7468 6574 615b 636f      cos_theta[co
+00018dc0: 735f 7468 6574 6120 3c3d 2030 5d20 3d20  s_theta <= 0] = 
+00018dd0: 6e70 2e69 6e66 0a0a 2020 2020 2020 2020  np.inf..        
+00018de0: 6e6f 726d 203d 2031 2e30 202f 206e 702e  norm = 1.0 / np.
+00018df0: 7371 7274 2832 2e30 202a 2073 656c 662e  sqrt(2.0 * self.
+00018e00: 6574 6129 202f 206e 702e 7371 7274 2863  eta) / np.sqrt(c
+00018e10: 6f73 5f74 6865 7461 290a 2020 2020 2020  os_theta).      
+00018e20: 2020 616d 705f 7468 6574 6120 3d20 7365    amp_theta = se
+00018e30: 6c66 2e45 7468 6574 612e 7661 6c75 6573  lf.Etheta.values
+00018e40: 202a 206e 6f72 6d0a 2020 2020 2020 2020   * norm.        
+00018e50: 616d 705f 7068 6920 3d20 7365 6c66 2e45  amp_phi = self.E
+00018e60: 7068 692e 7661 6c75 6573 202a 206e 6f72  phi.values * nor
+00018e70: 6d0a 0a20 2020 2020 2020 2023 2073 7461  m..        # sta
+00018e80: 636b 2074 6865 2061 6d70 6c69 7475 6465  ck the amplitude
+00018e90: 7320 696e 2073 2d20 616e 6420 702d 636f  s in s- and p-co
+00018ea0: 6d70 6f6e 656e 7473 2061 6c6f 6e67 2061  mponents along a
+00018eb0: 206e 6577 2070 6f6c 6172 697a 6174 696f   new polarizatio
+00018ec0: 6e20 6178 6973 0a20 2020 2020 2020 2063  n axis.        c
+00018ed0: 6f6f 7264 7320 3d20 7b7d 0a20 2020 2020  oords = {}.     
+00018ee0: 2020 2063 6f6f 7264 735b 226f 7264 6572     coords["order
+00018ef0: 735f 7822 5d20 3d20 6e70 2e61 746c 6561  s_x"] = np.atlea
+00018f00: 7374 5f31 6428 7365 6c66 2e6f 7264 6572  st_1d(self.order
+00018f10: 735f 7829 0a20 2020 2020 2020 2063 6f6f  s_x).        coo
+00018f20: 7264 735b 226f 7264 6572 735f 7922 5d20  rds["orders_y"] 
+00018f30: 3d20 6e70 2e61 746c 6561 7374 5f31 6428  = np.atleast_1d(
+00018f40: 7365 6c66 2e6f 7264 6572 735f 7929 0a20  self.orders_y). 
+00018f50: 2020 2020 2020 2063 6f6f 7264 735b 2266         coords["f
+00018f60: 225d 203d 206e 702e 6174 6c65 6173 745f  "] = np.atleast_
+00018f70: 3164 2873 656c 662e 6629 0a20 2020 2020  1d(self.f).     
+00018f80: 2020 2063 6f6f 7264 735b 2270 6f6c 6172     coords["polar
+00018f90: 697a 6174 696f 6e22 5d20 3d20 5b22 7322  ization"] = ["s"
+00018fa0: 2c20 2270 225d 0a20 2020 2020 2020 2072  , "p"].        r
+00018fb0: 6574 7572 6e20 7872 2e44 6174 6141 7272  eturn xr.DataArr
+00018fc0: 6179 286e 702e 7374 6163 6b28 5b61 6d70  ay(np.stack([amp
+00018fd0: 5f70 6869 2c20 616d 705f 7468 6574 615d  _phi, amp_theta]
+00018fe0: 2c20 6178 6973 3d33 292c 2063 6f6f 7264  , axis=3), coord
+00018ff0: 733d 636f 6f72 6473 290a 0a20 2020 2040  s=coords)..    @
+00019000: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
+00019010: 2070 6f77 6572 2873 656c 6629 202d 3e20   power(self) -> 
+00019020: 7872 2e44 6174 6141 7272 6179 3a0a 2020  xr.DataArray:.  
+00019030: 2020 2020 2020 2222 2254 6f74 616c 2070        """Total p
+00019040: 6f77 6572 2069 6e20 6561 6368 206f 7264  ower in each ord
+00019050: 6572 2c20 7375 6d6d 6564 206f 7665 7220  er, summed over 
+00019060: 626f 7468 2070 6f6c 6172 697a 6174 696f  both polarizatio
+00019070: 6e73 2e22 2222 0a20 2020 2020 2020 2072  ns.""".        r
+00019080: 6574 7572 6e20 286e 702e 6162 7328 7365  eturn (np.abs(se
+00019090: 6c66 2e61 6d70 7329 202a 2a20 3229 2e73  lf.amps) ** 2).s
+000190a0: 756d 2864 696d 3d22 706f 6c61 7269 7a61  um(dim="polariza
+000190b0: 7469 6f6e 2229 0a0a 2020 2020 4070 726f  tion")..    @pro
+000190c0: 7065 7274 790a 2020 2020 6465 6620 6669  perty.    def fi
+000190d0: 656c 6473 5f73 7068 6572 6963 616c 2873  elds_spherical(s
+000190e0: 656c 6629 202d 3e20 7872 2e44 6174 6173  elf) -> xr.Datas
+000190f0: 6574 3a0a 2020 2020 2020 2020 2222 2247  et:.        """G
+00019100: 6574 2061 6c6c 2066 6965 6c64 2063 6f6d  et all field com
+00019110: 706f 6e65 6e74 7320 696e 2073 7068 6572  ponents in spher
+00019120: 6963 616c 2063 6f6f 7264 696e 6174 6573  ical coordinates
+00019130: 2072 656c 6174 6976 6520 746f 2074 6865   relative to the
+00019140: 206d 6f6e 6974 6f72 2773 0a20 2020 2020   monitor's.     
+00019150: 2020 206c 6f63 616c 206f 7269 6769 6e20     local origin 
+00019160: 666f 7220 616c 6c20 616c 6c6f 7765 6420  for all allowed 
+00019170: 6469 6666 7261 6374 696f 6e20 6f72 6465  diffraction orde
+00019180: 7273 2061 6e64 2066 7265 7175 656e 6369  rs and frequenci
+00019190: 6573 2073 7065 6369 6669 6564 2069 6e20  es specified in 
+000191a0: 7468 650a 2020 2020 2020 2020 3a63 6c61  the.        :cla
+000191b0: 7373 3a60 4469 6666 7261 6374 696f 6e4d  ss:`DiffractionM
+000191c0: 6f6e 6974 6f72 602e 0a0a 2020 2020 2020  onitor`...      
+000191d0: 2020 5265 7475 726e 730a 2020 2020 2020    Returns.      
+000191e0: 2020 2d2d 2d2d 2d2d 2d0a 2020 2020 2020    -------.      
+000191f0: 2020 6060 7861 7272 6179 2e44 6174 6173    ``xarray.Datas
+00019200: 6574 6060 0a20 2020 2020 2020 2020 2020  et``.           
+00019210: 2078 6172 7261 7920 6461 7461 7365 7420   xarray dataset 
+00019220: 636f 6e74 6169 6e69 6e67 0a20 2020 2020  containing.     
+00019230: 2020 2020 2020 2028 6060 4572 6060 2c20         (``Er``, 
+00019240: 6060 4574 6865 7461 6060 2c20 6060 4570  ``Etheta``, ``Ep
+00019250: 6869 6060 2c20 6060 4872 6060 2c20 6060  hi``, ``Hr``, ``
+00019260: 4874 6865 7461 6060 2c20 6060 4870 6869  Htheta``, ``Hphi
+00019270: 6060 290a 2020 2020 2020 2020 2020 2020  ``).            
+00019280: 696e 2073 7068 6572 6963 616c 2063 6f6f  in spherical coo
+00019290: 7264 696e 6174 6573 2e0a 2020 2020 2020  rdinates..      
+000192a0: 2020 2222 220a 2020 2020 2020 2020 6669    """.        fi
+000192b0: 656c 6473 203d 205b 6669 656c 642e 7661  elds = [field.va
+000192c0: 6c75 6573 2066 6f72 2066 6965 6c64 2069  lues for field i
+000192d0: 6e20 7365 6c66 2e66 6965 6c64 5f63 6f6d  n self.field_com
+000192e0: 706f 6e65 6e74 732e 7661 6c75 6573 2829  ponents.values()
+000192f0: 5d0a 2020 2020 2020 2020 6b65 7973 203d  ].        keys =
+00019300: 205b 2245 7222 2c20 2245 7468 6574 6122   ["Er", "Etheta"
+00019310: 2c20 2245 7068 6922 2c20 2248 7222 2c20  , "Ephi", "Hr", 
+00019320: 2248 7468 6574 6122 2c20 2248 7068 6922  "Htheta", "Hphi"
+00019330: 5d0a 2020 2020 2020 2020 7265 7475 726e  ].        return
+00019340: 2073 656c 662e 5f6d 616b 655f 6461 7461   self._make_data
+00019350: 7365 7428 6669 656c 6473 2c20 6b65 7973  set(fields, keys
+00019360: 290a 0a20 2020 2040 7072 6f70 6572 7479  )..    @property
+00019370: 0a20 2020 2064 6566 2066 6965 6c64 735f  .    def fields_
+00019380: 6361 7274 6573 6961 6e28 7365 6c66 2920  cartesian(self) 
+00019390: 2d3e 2078 722e 4461 7461 7365 743a 0a20  -> xr.Dataset:. 
+000193a0: 2020 2020 2020 2022 2222 4765 7420 616c         """Get al
+000193b0: 6c20 6669 656c 6420 636f 6d70 6f6e 656e  l field componen
+000193c0: 7473 2069 6e20 4361 7274 6573 6961 6e20  ts in Cartesian 
+000193d0: 636f 6f72 6469 6e61 7465 7320 7265 6c61  coordinates rela
+000193e0: 7469 7665 2074 6f20 7468 6520 6d6f 6e69  tive to the moni
+000193f0: 746f 7227 730a 2020 2020 2020 2020 6c6f  tor's.        lo
+00019400: 6361 6c20 6f72 6967 696e 2066 6f72 2061  cal origin for a
+00019410: 6c6c 2061 6c6c 6f77 6564 2064 6966 6672  ll allowed diffr
+00019420: 6163 7469 6f6e 206f 7264 6572 7320 616e  action orders an
+00019430: 6420 6672 6571 7565 6e63 6965 7320 7370  d frequencies sp
+00019440: 6563 6966 6965 6420 696e 2074 6865 0a20  ecified in the. 
+00019450: 2020 2020 2020 203a 636c 6173 733a 6044         :class:`D
+00019460: 6966 6672 6163 7469 6f6e 4d6f 6e69 746f  iffractionMonito
+00019470: 7260 2e0a 0a20 2020 2020 2020 2052 6574  r`...        Ret
+00019480: 7572 6e73 0a20 2020 2020 2020 202d 2d2d  urns.        ---
+00019490: 2d2d 2d2d 0a20 2020 2020 2020 2060 6078  ----.        ``x
+000194a0: 6172 7261 792e 4461 7461 7365 7460 600a  array.Dataset``.
+000194b0: 2020 2020 2020 2020 2020 2020 7861 7272              xarr
+000194c0: 6179 2064 6174 6173 6574 2063 6f6e 7461  ay dataset conta
+000194d0: 696e 696e 6720 2860 6045 7860 602c 2060  ining (``Ex``, `
+000194e0: 6045 7960 602c 2060 6045 7a60 602c 2060  `Ey``, ``Ez``, `
+000194f0: 6048 7860 602c 2060 6048 7960 602c 2060  `Hx``, ``Hy``, `
+00019500: 6048 7a60 6029 0a20 2020 2020 2020 2020  `Hz``).         
+00019510: 2020 2069 6e20 4361 7274 6573 6961 6e20     in Cartesian 
+00019520: 636f 6f72 6469 6e61 7465 732e 0a20 2020  coordinates..   
+00019530: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00019540: 2074 6865 7461 2c20 7068 6920 3d20 7365   theta, phi = se
+00019550: 6c66 2e61 6e67 6c65 730a 2020 2020 2020  lf.angles.      
+00019560: 2020 7468 6574 6120 3d20 7468 6574 612e    theta = theta.
+00019570: 7661 6c75 6573 0a20 2020 2020 2020 2070  values.        p
+00019580: 6869 203d 2070 6869 2e76 616c 7565 730a  hi = phi.values.
+00019590: 0a20 2020 2020 2020 2065 5f78 2c20 655f  .        e_x, e_
+000195a0: 792c 2065 5f7a 203d 2073 656c 662e 6d6f  y, e_z = self.mo
+000195b0: 6e69 746f 722e 7370 685f 325f 6361 725f  nitor.sph_2_car_
+000195c0: 6669 656c 6428 0a20 2020 2020 2020 2020  field(.         
+000195d0: 2020 2030 2c20 7365 6c66 2e45 7468 6574     0, self.Ethet
+000195e0: 612e 7661 6c75 6573 2c20 7365 6c66 2e45  a.values, self.E
+000195f0: 7068 692e 7661 6c75 6573 2c20 7468 6574  phi.values, thet
+00019600: 612c 2070 6869 0a20 2020 2020 2020 2029  a, phi.        )
+00019610: 0a20 2020 2020 2020 2068 5f78 2c20 685f  .        h_x, h_
+00019620: 792c 2068 5f7a 203d 2073 656c 662e 6d6f  y, h_z = self.mo
+00019630: 6e69 746f 722e 7370 685f 325f 6361 725f  nitor.sph_2_car_
+00019640: 6669 656c 6428 0a20 2020 2020 2020 2020  field(.         
+00019650: 2020 2030 2c20 7365 6c66 2e48 7468 6574     0, self.Hthet
+00019660: 612e 7661 6c75 6573 2c20 7365 6c66 2e48  a.values, self.H
+00019670: 7068 692e 7661 6c75 6573 2c20 7468 6574  phi.values, thet
+00019680: 612c 2070 6869 0a20 2020 2020 2020 2029  a, phi.        )
+00019690: 0a20 2020 2020 2020 2065 5f78 2c20 655f  .        e_x, e_
+000196a0: 792c 2065 5f7a 2c20 685f 782c 2068 5f79  y, e_z, h_x, h_y
+000196b0: 2c20 685f 7a20 3d20 280a 2020 2020 2020  , h_z = (.      
+000196c0: 2020 2020 2020 6e70 2e6e 616e 5f74 6f5f        np.nan_to_
+000196d0: 6e75 6d28 666c 6429 2066 6f72 2066 6c64  num(fld) for fld
+000196e0: 2069 6e20 5b65 5f78 2c20 655f 792c 2065   in [e_x, e_y, e
+000196f0: 5f7a 2c20 685f 782c 2068 5f79 2c20 685f  _z, h_x, h_y, h_
+00019700: 7a5d 0a20 2020 2020 2020 2029 0a0a 2020  z].        )..  
+00019710: 2020 2020 2020 6669 656c 6473 203d 205b        fields = [
+00019720: 655f 782c 2065 5f79 2c20 655f 7a2c 2068  e_x, e_y, e_z, h
+00019730: 5f78 2c20 685f 792c 2068 5f7a 5d0a 2020  _x, h_y, h_z].  
+00019740: 2020 2020 2020 6b65 7973 203d 205b 2245        keys = ["E
+00019750: 7822 2c20 2245 7922 2c20 2245 7a22 2c20  x", "Ey", "Ez", 
+00019760: 2248 7822 2c20 2248 7922 2c20 2248 7a22  "Hx", "Hy", "Hz"
+00019770: 5d0a 2020 2020 2020 2020 7265 7475 726e  ].        return
+00019780: 2073 656c 662e 5f6d 616b 655f 6461 7461   self._make_data
+00019790: 7365 7428 6669 656c 6473 2c20 6b65 7973  set(fields, keys
+000197a0: 290a 0a20 2020 2064 6566 205f 6d61 6b65  )..    def _make
+000197b0: 5f64 6174 6173 6574 2873 656c 662c 2066  _dataset(self, f
+000197c0: 6965 6c64 733a 2054 7570 6c65 5b6e 702e  ields: Tuple[np.
+000197d0: 6e64 6172 7261 792c 202e 2e2e 5d2c 206b  ndarray, ...], k
+000197e0: 6579 733a 2054 7570 6c65 5b73 7472 2c20  eys: Tuple[str, 
+000197f0: 2e2e 2e5d 2920 2d3e 2078 722e 4461 7461  ...]) -> xr.Data
+00019800: 7365 743a 0a20 2020 2020 2020 2022 2222  set:.        """
+00019810: 4d61 6b65 2061 6e20 7872 2e44 6174 6173  Make an xr.Datas
+00019820: 6574 2066 6f72 2066 6965 6c64 7320 7769  et for fields wi
+00019830: 7468 2067 6976 656e 2066 6965 6c64 206e  th given field n
+00019840: 616d 6573 2e22 2222 0a20 2020 2020 2020  ames.""".       
+00019850: 2064 6174 615f 6172 7261 7973 203d 205b   data_arrays = [
+00019860: 5d0a 2020 2020 2020 2020 666f 7220 6669  ].        for fi
+00019870: 656c 6420 696e 2066 6965 6c64 733a 0a20  eld in fields:. 
+00019880: 2020 2020 2020 2020 2020 2064 6174 615f             data_
+00019890: 6172 7261 7973 2e61 7070 656e 6428 7872  arrays.append(xr
+000198a0: 2e44 6174 6141 7272 6179 2864 6174 613d  .DataArray(data=
+000198b0: 6669 656c 642c 2063 6f6f 7264 733d 7365  field, coords=se
+000198c0: 6c66 2e63 6f6f 7264 732c 2064 696d 733d  lf.coords, dims=
+000198d0: 7365 6c66 2e64 696d 7329 290a 2020 2020  self.dims)).    
+000198e0: 2020 2020 7265 7475 726e 2078 722e 4461      return xr.Da
+000198f0: 7461 7365 7428 6469 6374 287a 6970 286b  taset(dict(zip(k
+00019900: 6579 732c 2064 6174 615f 6172 7261 7973  eys, data_arrays
+00019910: 2929 290a 0a0a 4d6f 6e69 746f 7244 6174  )))...MonitorDat
+00019920: 6154 7970 6573 203d 2028 0a20 2020 2046  aTypes = (.    F
+00019930: 6965 6c64 4461 7461 2c0a 2020 2020 4669  ieldData,.    Fi
+00019940: 656c 6454 696d 6544 6174 612c 0a20 2020  eldTimeData,.   
+00019950: 2050 6572 6d69 7474 6976 6974 7944 6174   PermittivityDat
+00019960: 612c 0a20 2020 204d 6f64 6553 6f6c 7665  a,.    ModeSolve
+00019970: 7244 6174 612c 0a20 2020 204d 6f64 6544  rData,.    ModeD
+00019980: 6174 612c 0a20 2020 2046 6c75 7844 6174  ata,.    FluxDat
+00019990: 612c 0a20 2020 2046 6c75 7854 696d 6544  a,.    FluxTimeD
+000199a0: 6174 612c 0a20 2020 2046 6965 6c64 5072  ata,.    FieldPr
+000199b0: 6f6a 6563 7469 6f6e 4b53 7061 6365 4461  ojectionKSpaceDa
+000199c0: 7461 2c0a 2020 2020 4669 656c 6450 726f  ta,.    FieldPro
+000199d0: 6a65 6374 696f 6e43 6172 7465 7369 616e  jectionCartesian
+000199e0: 4461 7461 2c0a 2020 2020 4669 656c 6450  Data,.    FieldP
+000199f0: 726f 6a65 6374 696f 6e41 6e67 6c65 4461  rojectionAngleDa
+00019a00: 7461 2c0a 2020 2020 4469 6666 7261 6374  ta,.    Diffract
+00019a10: 696f 6e44 6174 612c 0a29 0a0a 4d6f 6e69  ionData,.)..Moni
+00019a20: 746f 7244 6174 6154 7970 6520 3d20 556e  torDataType = Un
+00019a30: 696f 6e5b 4d6f 6e69 746f 7244 6174 6154  ion[MonitorDataT
+00019a40: 7970 6573 5d0a                           ypes].
```

### Comparing `tidy3d-2.6.4/tidy3d/components/data/sim_data.py` & `tidy3d-2.7.0rc1/tidy3d/components/data/sim_data.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,11 @@
 """ Simulation Level Data """
 from __future__ import annotations
 from typing import Callable, Tuple, Union
+from abc import ABC
 
 import pathlib
 import xarray as xr
 import pydantic.v1 as pd
 import numpy as np
 import h5py
 import json
@@ -22,172 +23,28 @@
 
 DATA_TYPE_MAP = {data.__fields__["monitor"].type_: data for data in MonitorDataTypes}
 
 # maps monitor type (string) to the class of the corresponding data
 DATA_TYPE_NAME_MAP = {val.__fields__["monitor"].type_.__name__: val for val in MonitorDataTypes}
 
 
-class SimulationData(AbstractSimulationData):
-    """Stores data from a collection of :class:`.Monitor` objects in a :class:`.Simulation`.
+class AbstractYeeGridSimulationData(AbstractSimulationData, ABC):
+    """Data from an :class:`.AbstractYeeGridSimulation` involving
+    electromagnetic fields on a Yee grid.
 
     Notes
     -----
 
         The ``SimulationData`` objects store a copy of the original :class:`.Simulation`:, so it can be recovered if the
         ``SimulationData`` is loaded in a new session and the :class:`.Simulation` is no longer in memory.
 
         More importantly, the ``SimulationData`` contains a reference to the data for each of the monitors within the
         original :class:`.Simulation`. This data can be accessed directly using the name given to the monitors initially.
-
-    Examples
-    --------
-
-    Standalone example:
-
-    >>> import tidy3d as td
-    >>> num_modes = 5
-    >>> x = [-1,1,3]
-    >>> y = [-2,0,2,4]
-    >>> z = [-3,-1,1,3,5]
-    >>> f = [2e14, 3e14]
-    >>> coords = dict(x=x[:-1], y=y[:-1], z=z[:-1], f=f)
-    >>> grid = td.Grid(boundaries=td.Coords(x=x, y=y, z=z))
-    >>> scalar_field = td.ScalarFieldDataArray((1+1j) * np.random.random((2,3,4,2)), coords=coords)
-    >>> field_monitor = td.FieldMonitor(
-    ...     size=(2,4,6),
-    ...     freqs=[2e14, 3e14],
-    ...     name='field',
-    ...     fields=['Ex'],
-    ...     colocate=True,
-    ... )
-    >>> sim = td.Simulation(
-    ...     size=(2, 4, 6),
-    ...     grid_spec=td.GridSpec(wavelength=1.0),
-    ...     monitors=[field_monitor],
-    ...     run_time=2e-12,
-    ...     sources=[
-    ...         td.UniformCurrentSource(
-    ...             size=(0, 0, 0),
-    ...             center=(0, 0.5, 0),
-    ...             polarization="Hx",
-    ...             source_time=td.GaussianPulse(
-    ...                 freq0=2e14,
-    ...                 fwidth=4e13,
-    ...             ),
-    ...         )
-    ...     ],
-    ... )
-    >>> field_data = td.FieldData(monitor=field_monitor, Ex=scalar_field, grid_expanded=grid)
-    >>> sim_data = td.SimulationData(simulation=sim, data=(field_data,))
-
-    To save and load the :class:`SimulationData` object.
-
-    .. code-block:: python
-
-        sim_data.to_file(fname='path/to/file.hdf5') # Save a SimulationData object to a HDF5 file
-        sim_data = SimulationData.from_file(fname='path/to/file.hdf5') # Load a SimulationData object from a HDF5 file.
-
-    See Also
-    --------
-
-    **Notebooks:**
-        * `Quickstart <../../notebooks/StartHere.html>`_: Usage in a basic simulation flow.
-        * `Performing visualization of simulation data <../../notebooks/VizData.html>`_
-        * `Advanced monitor data manipulation and visualization <../../notebooks/XarrayTutorial.html>`_
-
     """
 
-    simulation: Simulation = pd.Field(
-        ...,
-        title="Simulation",
-        description="Original :class:`.Simulation` associated with the data.",
-    )
-
-    data: Tuple[annotate_type(MonitorDataType), ...] = pd.Field(
-        ...,
-        title="Monitor Data",
-        description="List of :class:`.MonitorData` instances "
-        "associated with the monitors of the original :class:`.Simulation`.",
-    )
-
-    diverged: bool = pd.Field(
-        False,
-        title="Diverged",
-        description="A boolean flag denoting whether the simulation run diverged.",
-    )
-
-    @property
-    def final_decay_value(self) -> float:
-        """Returns value of the field decay at the final time step."""
-        log_str = self.log
-        if log_str is None:
-            raise DataError(
-                "No log string in the SimulationData object, can't find final decay value."
-            )
-        lines = log_str.split("\n")
-        decay_lines = [line for line in lines if "field decay" in line]
-        final_decay = 1.0
-        if len(decay_lines) > 0:
-            final_decay_line = decay_lines[-1]
-            final_decay = float(final_decay_line.split("field decay: ")[-1])
-        return final_decay
-
-    def source_spectrum(self, source_index: int) -> Callable:
-        """Get a spectrum normalization function for a given source index."""
-
-        if source_index is None or len(self.simulation.sources) == 0:
-            return np.ones_like
-
-        source = self.simulation.sources[source_index]
-        source_time = source.source_time
-        times = self.simulation.tmesh
-        dt = self.simulation.dt
-
-        # plug in mornitor_data frequency domain information
-        def source_spectrum_fn(freqs):
-            """Source amplitude as function of frequency."""
-            spectrum = source_time.spectrum(times, freqs, dt)
-
-            # Remove user defined amplitude and phase from the normalization
-            # such that they would still have an effect on the output fields.
-            # In other words, we are only normalizing out the arbitrary part of the spectrum
-            # that depends on things like freq0, fwidth and offset.
-            return spectrum / source_time.amplitude / np.exp(1j * source_time.phase)
-
-        return source_spectrum_fn
-
-    def renormalize(self, normalize_index: int) -> SimulationData:
-        """Return a copy of the :class:`.SimulationData` with a different source used for the
-        normalization."""
-
-        num_sources = len(self.simulation.sources)
-        if normalize_index == self.simulation.normalize_index or num_sources == 0:
-            # already normalized to that index
-            return self.copy()
-
-        if normalize_index and (normalize_index < 0 or normalize_index >= num_sources):
-            # normalize index out of bounds for source list
-            raise DataError(
-                f"normalize_index {normalize_index} out of bounds for list of sources "
-                f"of length {num_sources}"
-            )
-
-        def source_spectrum_fn(freqs):
-            """Normalization function that also removes previous normalization if needed."""
-            new_spectrum_fn = self.source_spectrum(normalize_index)
-            old_spectrum_fn = self.source_spectrum(self.simulation.normalize_index)
-            return new_spectrum_fn(freqs) / old_spectrum_fn(freqs)
-
-        # Make a new monitor_data dictionary with renormalized data
-        data_normalized = [mnt_data.normalize(source_spectrum_fn) for mnt_data in self.data]
-
-        simulation = self.simulation.copy(update=dict(normalize_index=normalize_index))
-
-        return self.copy(update=dict(simulation=simulation, data=data_normalized))
-
     def load_field_monitor(self, monitor_name: str) -> AbstractFieldData:
         """Load monitor and raise exception if not a field monitor."""
         mon_data = self[monitor_name]
         if not isinstance(mon_data, AbstractFieldData):
             raise DataError(
                 f"data for monitor '{monitor_name}' does not contain field data "
                 f"as it is a '{type(mon_data)}'."
@@ -592,14 +449,16 @@
         monitor = self.simulation.get_monitor_by_name(field_monitor_name)
         thin_dims = {
             "xyz"[dim]: monitor.center[dim]
             for dim in range(3)
             if monitor.size[dim] == 0 and "xyz"[dim] not in sel_kwargs
         }
         for axis, pos in thin_dims.items():
+            if axis not in field_data.coords:
+                continue
             if field_data.coords[axis].size <= 1:
                 field_data = field_data.sel(**{axis: pos}, method="nearest")
             else:
                 field_data = field_data.interp(**{axis: pos}, kwargs=dict(bounds_error=True))
 
         # warn about new API changes and replace the values
         if "freq" in sel_kwargs:
@@ -615,15 +474,19 @@
                 "'time' will error in future release, please update your local script to use "
                 "'t=value'."
             )
             sel_kwargs["t"] = sel_kwargs.pop("time")
 
         # select the extra coordinates out of the data from user-specified kwargs
         for coord_name, coord_val in sel_kwargs.items():
-            if field_data.coords[coord_name].size <= 1:
+            if (
+                field_data.coords[coord_name].size <= 1
+                or coord_name == "eme_port_index"
+                or coord_name == "mode_index"
+            ):
                 field_data = field_data.sel(**{coord_name: coord_val}, method=None)
             else:
                 field_data = field_data.interp(
                     **{coord_name: coord_val}, kwargs=dict(bounds_error=True)
                 )
 
         # before dropping coordinates, check if a frequency can be derived from the data that can
@@ -656,15 +519,18 @@
                 "All coordinates in the data after selection must be spatial (x, y, z), "
                 f" given {non_scalar_coords.keys()}."
             )
 
         # get the spatial coordinate corresponding to the plane
         planar_coord = [name for name, c in spatial_coords_in_data.items() if c is False][0]
         axis = "xyz".index(planar_coord)
-        position = float(field_data.coords[planar_coord])
+        if planar_coord in field_data.coords:
+            position = float(field_data.coords[planar_coord])
+        else:
+            position = monitor.center[axis]
 
         return self.plot_scalar_array(
             field_data=field_data,
             axis=axis,
             position=position,
             freq=freq_eps_eval,
             eps_alpha=eps_alpha,
@@ -775,7 +641,166 @@
         # set the limits based on the xarray coordinates min and max
         x_coord_values = field_data.coords[x_coord_label]
         y_coord_values = field_data.coords[y_coord_label]
         ax.set_xlim(min(x_coord_values), max(x_coord_values))
         ax.set_ylim(min(y_coord_values), max(y_coord_values))
 
         return ax
+
+
+class SimulationData(AbstractYeeGridSimulationData):
+    """Stores data from a collection of :class:`.Monitor` objects in a :class:`.Simulation`.
+
+    Notes
+    -----
+
+        The ``SimulationData`` objects store a copy of the original :class:`.Simulation`:, so it can be recovered if the
+        ``SimulationData`` is loaded in a new session and the :class:`.Simulation` is no longer in memory.
+
+        More importantly, the ``SimulationData`` contains a reference to the data for each of the monitors within the
+        original :class:`.Simulation`. This data can be accessed directly using the name given to the monitors initially.
+
+    Examples
+    --------
+
+    Standalone example:
+
+    >>> import tidy3d as td
+    >>> num_modes = 5
+    >>> x = [-1,1,3]
+    >>> y = [-2,0,2,4]
+    >>> z = [-3,-1,1,3,5]
+    >>> f = [2e14, 3e14]
+    >>> coords = dict(x=x[:-1], y=y[:-1], z=z[:-1], f=f)
+    >>> grid = td.Grid(boundaries=td.Coords(x=x, y=y, z=z))
+    >>> scalar_field = td.ScalarFieldDataArray((1+1j) * np.random.random((2,3,4,2)), coords=coords)
+    >>> field_monitor = td.FieldMonitor(
+    ...     size=(2,4,6),
+    ...     freqs=[2e14, 3e14],
+    ...     name='field',
+    ...     fields=['Ex'],
+    ...     colocate=True,
+    ... )
+    >>> sim = td.Simulation(
+    ...     size=(2, 4, 6),
+    ...     grid_spec=td.GridSpec(wavelength=1.0),
+    ...     monitors=[field_monitor],
+    ...     run_time=2e-12,
+    ...     sources=[
+    ...         td.UniformCurrentSource(
+    ...             size=(0, 0, 0),
+    ...             center=(0, 0.5, 0),
+    ...             polarization="Hx",
+    ...             source_time=td.GaussianPulse(
+    ...                 freq0=2e14,
+    ...                 fwidth=4e13,
+    ...             ),
+    ...         )
+    ...     ],
+    ... )
+    >>> field_data = td.FieldData(monitor=field_monitor, Ex=scalar_field, grid_expanded=grid)
+    >>> sim_data = td.SimulationData(simulation=sim, data=(field_data,))
+
+    To save and load the :class:`SimulationData` object.
+
+    .. code-block:: python
+
+        sim_data.to_file(fname='path/to/file.hdf5') # Save a SimulationData object to a HDF5 file
+        sim_data = SimulationData.from_file(fname='path/to/file.hdf5') # Load a SimulationData object from a HDF5 file.
+
+    See Also
+    --------
+
+    **Notebooks:**
+        * `Quickstart <../../notebooks/StartHere.html>`_: Usage in a basic simulation flow.
+        * `Performing visualization of simulation data <../../notebooks/VizData.html>`_
+        * `Advanced monitor data manipulation and visualization <../../notebooks/XarrayTutorial.html>`_
+
+    """
+
+    simulation: Simulation = pd.Field(
+        ...,
+        title="Simulation",
+        description="Original :class:`.Simulation` associated with the data.",
+    )
+
+    data: Tuple[annotate_type(MonitorDataType), ...] = pd.Field(
+        ...,
+        title="Monitor Data",
+        description="List of :class:`.MonitorData` instances "
+        "associated with the monitors of the original :class:`.Simulation`.",
+    )
+
+    diverged: bool = pd.Field(
+        False,
+        title="Diverged",
+        description="A boolean flag denoting whether the simulation run diverged.",
+    )
+
+    @property
+    def final_decay_value(self) -> float:
+        """Returns value of the field decay at the final time step."""
+        log_str = self.log
+        if log_str is None:
+            raise DataError(
+                "No log string in the SimulationData object, can't find final decay value."
+            )
+        lines = log_str.split("\n")
+        decay_lines = [line for line in lines if "field decay" in line]
+        final_decay = 1.0
+        if len(decay_lines) > 0:
+            final_decay_line = decay_lines[-1]
+            final_decay = float(final_decay_line.split("field decay: ")[-1])
+        return final_decay
+
+    def source_spectrum(self, source_index: int) -> Callable:
+        """Get a spectrum normalization function for a given source index."""
+
+        if source_index is None or len(self.simulation.sources) == 0:
+            return np.ones_like
+
+        source = self.simulation.sources[source_index]
+        source_time = source.source_time
+        times = self.simulation.tmesh
+        dt = self.simulation.dt
+
+        # plug in mornitor_data frequency domain information
+        def source_spectrum_fn(freqs):
+            """Source amplitude as function of frequency."""
+            spectrum = source_time.spectrum(times, freqs, dt)
+
+            # Remove user defined amplitude and phase from the normalization
+            # such that they would still have an effect on the output fields.
+            # In other words, we are only normalizing out the arbitrary part of the spectrum
+            # that depends on things like freq0, fwidth and offset.
+            return spectrum / source_time.amplitude / np.exp(1j * source_time.phase)
+
+        return source_spectrum_fn
+
+    def renormalize(self, normalize_index: int) -> SimulationData:
+        """Return a copy of the :class:`.SimulationData` with a different source used for the
+        normalization."""
+
+        num_sources = len(self.simulation.sources)
+        if normalize_index == self.simulation.normalize_index or num_sources == 0:
+            # already normalized to that index
+            return self.copy()
+
+        if normalize_index and (normalize_index < 0 or normalize_index >= num_sources):
+            # normalize index out of bounds for source list
+            raise DataError(
+                f"normalize_index {normalize_index} out of bounds for list of sources "
+                f"of length {num_sources}"
+            )
+
+        def source_spectrum_fn(freqs):
+            """Normalization function that also removes previous normalization if needed."""
+            new_spectrum_fn = self.source_spectrum(normalize_index)
+            old_spectrum_fn = self.source_spectrum(self.simulation.normalize_index)
+            return new_spectrum_fn(freqs) / old_spectrum_fn(freqs)
+
+        # Make a new monitor_data dictionary with renormalized data
+        data_normalized = [mnt_data.normalize(source_spectrum_fn) for mnt_data in self.data]
+
+        simulation = self.simulation.copy(update=dict(normalize_index=normalize_index))
+
+        return self.copy(update=dict(simulation=simulation, data=data_normalized))
```

### Comparing `tidy3d-2.6.4/tidy3d/components/data/validators.py` & `tidy3d-2.7.0rc1/tidy3d/components/data/validators.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/field_projection.py` & `tidy3d-2.7.0rc1/tidy3d/components/field_projection.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/file_util.py` & `tidy3d-2.7.0rc1/tidy3d/components/file_util.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/geometry/base.py` & `tidy3d-2.7.0rc1/tidy3d/components/geometry/base.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 """Abstract base classes for geometry."""
 
-
 from __future__ import annotations
 
 from abc import ABC, abstractmethod
 from typing import List, Tuple, Any, Union, Callable
 from math import isclose
 import functools
+import pathlib
 
 import pydantic.v1 as pydantic
 import numpy as np
 import shapely
 from matplotlib import patches
 
 from ..base import Tidy3dBaseModel, cached_property
@@ -1354,14 +1354,15 @@
             raise Tidy3dImportError(
                 "Python modules 'gdspy' and 'gdstk' not found. To export geometries to .gds "
                 "files, please install one of those those modules."
             )
 
         cell = library.new_cell(gds_cell_name)
         self.to_gds(cell, x=x, y=y, z=z, gds_layer=gds_layer, gds_dtype=gds_dtype)
+        pathlib.Path(fname).parent.mkdir(parents=True, exist_ok=True)
         library.write_gds(fname)
 
     def _as_union(self) -> List[Geometry]:
         """Return a list of geometries that, united, make up the given geometry."""
         if isinstance(self, GeometryGroup):
             return self.geometries
 
@@ -1854,15 +1855,15 @@
         ]
         mesh = trimesh.Trimesh(vertices, faces)
 
         section = mesh.section(plane_origin=origin, plane_normal=normal)
         if section is None:
             return []
         path, _ = section.to_planar(to_2D=to_2D)
-        return path.polygons_full.tolist()
+        return path.polygons_full
 
     def intersections_plane(self, x: float = None, y: float = None, z: float = None):
         """Returns shapely geometry at plane specified by one non None value of x,y,z.
 
         Parameters
         ----------
         x : float = None
@@ -2196,14 +2197,24 @@
 
     @pydantic.validator("transform")
     def _transform_is_invertible(cls, val):
         # If the transform is not invertible, this will raise an error
         _ = np.linalg.inv(val)
         return val
 
+    @pydantic.validator("geometry")
+    def _geometry_is_finite(cls, val):
+        if not np.isfinite(val.bounds).all():
+            raise ValidationError(
+                "Transformations are only supported on geometries with finite dimensions. "
+                "Try using a large value instead of 'inf' when creating geometries that undergo "
+                "transformations."
+            )
+        return val
+
     @pydantic.root_validator(skip_on_failure=True)
     def _apply_transforms(cls, values):
         while isinstance(values["geometry"], Transformed):
             inner = values["geometry"]
             values["geometry"] = inner.geometry
             values["transform"] = np.dot(values["transform"], inner.transform)
         return values
```

### Comparing `tidy3d-2.6.4/tidy3d/components/geometry/mesh.py` & `tidy3d-2.7.0rc1/tidy3d/components/geometry/mesh.py`

 * *Files 0% similar despite different names*

```diff
@@ -306,15 +306,15 @@
             For more details refer to
             `Shapely's Documentation <https://shapely.readthedocs.io/en/stable/project.html>`_.
         """
         section = self.trimesh.section(plane_origin=origin, plane_normal=normal)
         if section is None:
             return []
         path, _ = section.to_planar(to_2D=to_2D)
-        return path.polygons_full.tolist()
+        return path.polygons_full
 
     def intersections_plane(
         self, x: float = None, y: float = None, z: float = None
     ) -> List[Shapely]:
         """Returns list of shapely geometries at plane specified by one non-None value of x,y,z.
 
         Parameters
```

### Comparing `tidy3d-2.6.4/tidy3d/components/geometry/polyslab.py` & `tidy3d-2.7.0rc1/tidy3d/components/geometry/polyslab.py`

 * *Files 0% similar despite different names*

```diff
@@ -582,15 +582,15 @@
         vertices = np.vstack(self.unpop_axis(z, (x, y), self.axis)).T
         mesh = trimesh.Trimesh(vertices, faces)
 
         section = mesh.section(plane_origin=origin, plane_normal=normal)
         if section is None:
             return []
         path, _ = section.to_planar(to_2D=to_2D)
-        return path.polygons_full.tolist()
+        return path.polygons_full
 
     def _intersections_normal(self, z: float):
         """Find shapely geometries intersecting planar geometry with axis normal to slab.
 
         Parameters
         ----------
         z : float
```

### Comparing `tidy3d-2.6.4/tidy3d/components/geometry/primitives.py` & `tidy3d-2.7.0rc1/tidy3d/components/geometry/primitives.py`

 * *Files 0% similar despite different names*

```diff
@@ -324,15 +324,15 @@
 
         mesh = trimesh.Trimesh(vertices, faces)
 
         section = mesh.section(plane_origin=origin, plane_normal=normal)
         if section is None:
             return []
         path, _ = section.to_planar(to_2D=to_2D)
-        return path.polygons_full.tolist()
+        return path.polygons_full
 
     def _intersections_normal(self, z: float):
         """Find shapely geometries intersecting cylindrical geometry with axis normal to slab.
 
         Parameters
         ----------
         z : float
```

### Comparing `tidy3d-2.6.4/tidy3d/components/geometry/triangulation.py` & `tidy3d-2.7.0rc1/tidy3d/components/geometry/triangulation.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/geometry/utils.py` & `tidy3d-2.7.0rc1/tidy3d/components/geometry/utils.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/geometry/utils_2d.py` & `tidy3d-2.7.0rc1/tidy3d/components/geometry/utils_2d.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,26 +1,52 @@
 """Utilities for 2D geometry manipulation."""
 import numpy as np
 import shapely
 from typing import Tuple, List
 
 from ..types import Axis
-from ...constants import fp_eps, inf
+from ...constants import inf
 from ...exceptions import ValidationError
 from ..geometry.base import Geometry, Box, ClipOperation
 from ..geometry.primitives import Cylinder
 from ..geometry.polyslab import PolySlab
+from ..grid.grid import Grid
 from ..scene import Scene
 from ..structure import Structure
 
 # for 2d materials. to find neighboring media, search a distance on either side
 # equal to this times the grid size
 DIST_NEIGHBOR_REL_2D_MED = 1e-5
 
 
+def increment_float(val: np.float32, sign) -> np.float32:
+    """Applies a small positive or negative shift to a 32bit float using numpy.nextafter,"""
+    """but additionally handles some corner cases."""
+    # Infinity is left unchanged
+    if val == inf or val == -inf:
+        return val
+
+    if sign >= 0:
+        sign = 1
+    else:
+        sign = -1
+    # Numpy seems to skip over the increment from -0.0 and +0.0
+    # which is different from c++
+    val_inc = np.nextafter(val, sign * inf, dtype=np.float32)
+
+    return np.float32(val_inc)
+
+
+def snap_coordinate_to_grid(grid: Grid, center: float, axis: Axis) -> float:
+    """2D materials are snapped to grid along their normal axis"""
+    new_centers = grid.boundaries.to_list[axis]
+    new_center = new_centers[np.argmin(abs(new_centers - center))]
+    return new_center
+
+
 def get_bounds(geom: Geometry, axis: Axis) -> Tuple[float, float]:
     """Get the bounds of a geometry in the axis direction."""
     return (geom.bounds[0][axis], geom.bounds[1][axis])
 
 
 def set_bounds(geom: Geometry, bounds: Tuple[float, float], axis: Axis) -> Geometry:
     """Set the bounds of a geometry in the axis direction."""
@@ -70,18 +96,16 @@
 
         # to prevent false positives due to 2D materials touching different materials
         # along their sides, shrink the bounds along the tangential directions by
         # a tiny bit before checking for intersections
         bounds = [list(i) for i in geom_shifted.bounds]
         _, tan_dirs = Geometry.pop_axis([0, 1, 2], axis=axis)
         for dim in tan_dirs:
-            if bounds[0][dim] != -inf:
-                bounds[0][dim] += fp_eps * max(np.abs(bounds[0][dim]), 1.0)
-            if bounds[1][dim] != inf:
-                bounds[1][dim] -= fp_eps * max(np.abs(bounds[1][dim]), 1.0)
+            bounds[0][dim] = increment_float(bounds[0][dim], 1.0)
+            bounds[1][dim] = increment_float(bounds[1][dim], -1.0)
 
         structures_side = Scene.intersecting_structures(Box.from_bounds(*bounds), structures)
 
         if position < 0:
             neighbors_below += list(structures_side)
         else:
             neighbors_above += list(structures_side)
```

### Comparing `tidy3d-2.6.4/tidy3d/components/grid/grid.py` & `tidy3d-2.7.0rc1/tidy3d/components/grid/grid.py`

 * *Files 15% similar despite different names*

```diff
@@ -3,14 +3,15 @@
 from typing import Tuple, List, Union
 
 import numpy as np
 import pydantic.v1 as pd
 
 from ..base import Tidy3dBaseModel
 from ..data.data_array import DataArray, SpatialDataArray, ScalarFieldDataArray
+from ..data.dataset import UnstructuredGridDatasetType, UnstructuredGridDataset
 from ..types import ArrayFloat1D, Axis, TYPE_TAG_STR, InterpMethod, Literal
 from ..geometry.base import Box
 
 from ...exceptions import SetupError
 
 # data type of one dimensional coordinate array.
 Coords1D = ArrayFloat1D
@@ -45,15 +46,15 @@
         return {key: np.array(value) for key, value in self.dict(exclude={TYPE_TAG_STR}).items()}
 
     @property
     def to_list(self):
         """Return a list of the three Coord1D objects as numpy arrays."""
         return list(self.to_dict.values())
 
-    def spatial_interp(
+    def _interp_from_xarray(
         self,
         array: Union[SpatialDataArray, ScalarFieldDataArray],
         interp_method: InterpMethod,
         fill_value: Union[Literal["extrapolate"], float] = "extrapolate",
     ) -> Union[SpatialDataArray, ScalarFieldDataArray]:
         """
         Similar to ``xarrray.DataArray.interp`` with 2 enhancements:
@@ -79,25 +80,14 @@
             The interpolated spatial dataset.
 
         Note
         ----
         This method is called from a :class:`Coords` instance with the array to be interpolated as
         an argument, not the other way around.
         """
-
-        # Check for empty dimensions
-        result_coords = dict(self.to_dict)
-        if any(len(v) == 0 for v in result_coords.values()):
-            for c in array.coords:
-                if c not in result_coords:
-                    result_coords[c] = array.coords[c].values
-            result_shape = tuple(len(v) for v in result_coords.values())
-            result = DataArray(np.empty(result_shape, dtype=array.dtype), coords=result_coords)
-            return result
-
         # Check which axes need interpolation or selection
         interp_ax = []
         isel_ax = []
         for ax in "xyz":
             if array.sizes[ax] == 1:
                 isel_ax.append(ax)
             else:
@@ -135,14 +125,111 @@
             nearest_array = array.interp({ax: self.to_dict[ax] for ax in interp_ax}, **interp_param)
             interp_array.values[:] = np.where(
                 np.isnan(interp_array.values), nearest_array.values, interp_array.values
             )
 
         return interp_array
 
+    def _interp_from_unstructured(
+        self,
+        array: UnstructuredGridDatasetType,
+        interp_method: InterpMethod,
+        fill_value: Union[Literal["extrapolate"], float] = "extrapolate",
+    ) -> SpatialDataArray:
+        """
+        Interpolate from untructured grid onto a Cartesian one.
+
+        Parameters
+        ----------
+        array : Union[class:`.TriangularGridDataset`, class:`.TetrahedralGridDataset`]
+            Supplied scalar dataset
+        interp_method : :class:`.InterpMethod`
+            Interpolation method.
+        fill_value : Union[Literal['extrapolate'], float] = "extrapolate"
+            Value used to fill in for points outside the data range. If set to 'extrapolate',
+            values will be extrapolated into those regions using the "nearest" method.
+
+        Returns
+        -------
+        :class:`.SpatialDataArray`
+            The interpolated spatial dataset.
+
+        Note
+        ----
+        This method is called from a :class:`Coords` instance with the array to be interpolated as
+        an argument, not the other way around.
+        """
+        interp_array = array.interp(
+            **{ax: self.to_dict[ax] for ax in "xyz"}, method=interp_method, fill_value=fill_value
+        )
+
+        return interp_array
+
+    def spatial_interp(
+        self,
+        array: Union[SpatialDataArray, ScalarFieldDataArray, UnstructuredGridDatasetType],
+        interp_method: InterpMethod,
+        fill_value: Union[Literal["extrapolate"], float] = "extrapolate",
+    ) -> Union[SpatialDataArray, ScalarFieldDataArray]:
+        """
+        Similar to ``xarrray.DataArray.interp`` with 2 enhancements:
+
+            1) (if input data is an ``xarrray.DataArray``) Check if the coordinate of the supplied
+            data are in monotonically increasing order. If they are, apply the faster
+            ``assume_sorted=True``.
+
+            2) Data is assumed invariant along zero-size dimensions (if any).
+
+        Parameters
+        ----------
+        array : Union[
+                :class:`.SpatialDataArray`,
+                :class:`.ScalarFieldDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+        ]
+            Supplied scalar dataset
+        interp_method : :class:`.InterpMethod`
+            Interpolation method.
+        fill_value : Union[Literal['extrapolate'], float] = "extrapolate"
+            Value used to fill in for points outside the data range. If set to 'extrapolate',
+            values will be extrapolated into those regions using the "nearest" method.
+
+        Returns
+        -------
+        Union[:class:`.SpatialDataArray`, :class:`.ScalarFieldDataArray`]
+            The interpolated spatial dataset.
+
+        Note
+        ----
+        This method is called from a :class:`Coords` instance with the array to be interpolated as
+        an argument, not the other way around.
+        """
+
+        # Check for empty dimensions
+        result_coords = dict(self.to_dict)
+        if any(len(v) == 0 for v in result_coords.values()):
+            if isinstance(array, (SpatialDataArray, ScalarFieldDataArray)):
+                for c in array.coords:
+                    if c not in result_coords:
+                        result_coords[c] = array.coords[c].values
+            result_shape = tuple(len(v) for v in result_coords.values())
+            result = DataArray(np.empty(result_shape, dtype=array.dtype), coords=result_coords)
+            return result
+
+        # interpolation
+        if isinstance(array, UnstructuredGridDataset):
+            return self._interp_from_unstructured(
+                array=array, interp_method=interp_method, fill_value=fill_value
+            )
+        else:
+            return self._interp_from_xarray(
+                array=array, interp_method=interp_method, fill_value=fill_value
+            )
+
 
 class FieldGrid(Tidy3dBaseModel):
     """Holds the grid data for a single field.
 
     Example
     -------
     >>> x = np.linspace(-1, 1, 10)
```

### Comparing `tidy3d-2.6.4/tidy3d/components/grid/grid_spec.py` & `tidy3d-2.7.0rc1/tidy3d/components/grid/grid_spec.py`

 * *Files 4% similar despite different names*

```diff
@@ -5,23 +5,78 @@
 from typing import Tuple, List, Union
 
 import numpy as np
 import pydantic.v1 as pd
 
 from .grid import Coords1D, Coords, Grid
 from .mesher import GradedMesher, MesherType
-from ..base import Tidy3dBaseModel
+from ..base import Tidy3dBaseModel, cached_property
 from ..types import Axis, Symmetry, annotate_type, TYPE_TAG_STR
 from ..source import SourceType
 from ..structure import Structure, StructureType
 from ..geometry.base import Box
 from ...log import log
 from ...exceptions import SetupError
 from ...constants import MICROMETER, C_0, fp_eps
 
+# Default Courant number reduction rate in Benkler's scheme
+DEFAULT_COURANT_REDUCTION_BENKLER = 0.3
+
+
+class ConformalMeshSpec(Tidy3dBaseModel, ABC):
+    """Base class defining conformal mesh specifications."""
+
+    @cached_property
+    def courant_ratio(self) -> float:
+        """The scaling ratio applied to Courant number so that the courant number
+        in the simulation is ``sim.courant * courant_ratio``.
+        """
+        return 1.0
+
+
+class StaircasingConformalMeshSpec(ConformalMeshSpec):
+    """Simple staircasing scheme based on
+    [Taflove, The Electrical Engineering Handbook 3.629-670 (2005): 15.].
+    """
+
+
+class HeuristicConformalMeshSpec(ConformalMeshSpec):
+    """Slightly different from the staircasing scheme: the field component near PEC
+    is considered to be outside PEC if it's substantially normal to the interface.
+    """
+
+
+class BenklerConformalMeshSpec(ConformalMeshSpec):
+    """Conformal mesh scheme based on
+    [S. Benkler, IEEE Transactions on Antennas and Propagation 54.6, 1843 (2006)], which is similar
+    to the approach described in [S. Dey, R. Mittra, IEEE Microwave and Guided Wave Letters 7.9, 273 (1997)].
+    """
+
+    timestep_reduction: float = pd.Field(
+        DEFAULT_COURANT_REDUCTION_BENKLER,
+        title="Time Step Size Reduction Rate",
+        description="Reduction factor between 0 and 1 such that the simulation's time step size "
+        "will be ``1 - timestep_reduction`` times its default value. "
+        "Accuracy can be improved with a smaller time step size; but simulation time increased as well.",
+        lt=1,
+        ge=0,
+    )
+
+    @cached_property
+    def courant_ratio(self) -> float:
+        """The scaling ratio applied to Courant number so that the courant number
+        in the simulation is ``sim.courant * courant_ratio``.
+        """
+        return 1 - self.timestep_reduction
+
+
+ConformalMeshSpecType = Union[
+    BenklerConformalMeshSpec, StaircasingConformalMeshSpec, HeuristicConformalMeshSpec
+]
+
 
 class GridSpec1d(Tidy3dBaseModel, ABC):
 
     """Abstract base class, defines 1D grid generation specifications."""
 
     def make_coords(
         self,
@@ -348,14 +403,15 @@
     dl_min: pd.NonNegativeFloat = pd.Field(
         0,
         title="Lower bound of grid size",
         description="Lower bound of the grid size along this dimension regardless of "
         "structures present in the simulation, including override structures "
         "with ``enforced=True``. It is a soft bound, meaning that the actual minimal "
         "grid size might be slightly smaller.",
+        units=MICROMETER,
     )
 
     mesher: MesherType = pd.Field(
         GradedMesher(),
         title="Grid Construction Tool",
         description="The type of mesher to use to generate the grid automatically.",
     )
```

### Comparing `tidy3d-2.6.4/tidy3d/components/grid/mesher.py` & `tidy3d-2.7.0rc1/tidy3d/components/grid/mesher.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/heat/boundary.py` & `tidy3d-2.7.0rc1/tidy3d/components/heat/boundary.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/heat/data/monitor_data.py` & `tidy3d-2.7.0rc1/tidy3d/components/heat/data/monitor_data.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/heat/data/sim_data.py` & `tidy3d-2.7.0rc1/tidy3d/components/heat/data/sim_data.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/heat/grid.py` & `tidy3d-2.7.0rc1/tidy3d/components/heat/grid.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/heat/monitor.py` & `tidy3d-2.7.0rc1/tidy3d/components/heat/monitor.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/heat/simulation.py` & `tidy3d-2.7.0rc1/tidy3d/components/heat/simulation.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 """Defines heat simulation class"""
 from __future__ import annotations
 
 from typing import Tuple, List, Dict
 from matplotlib import cm
+import numpy as np
 
 import pydantic.v1 as pd
 
 from .boundary import TemperatureBC, HeatFluxBC, ConvectionBC
 from .boundary import HeatBoundarySpec
 from .source import HeatSourceType, UniformHeatSource
 from .monitor import HeatMonitorType
@@ -135,18 +136,28 @@
                     )
         return val
 
     @pd.validator("size", always=True)
     def check_zero_dim_domain(cls, val, values):
         """Error if heat domain have zero dimensions."""
 
-        if any(length == 0 for length in val):
-            raise SetupError(
-                "'HeatSimulation' does not currently support domains with dimensions of zero size."
-            )
+        dim_names = ["x", "y", "z"]
+        zero_dimensions = [False, False, False]
+        zero_dim_str = ""
+        for n, v in enumerate(val):
+            if v == 0:
+                zero_dimensions[n] = True
+                zero_dim_str += f"{dim_names[n]}- "
+
+        num_zero_dims = np.sum(zero_dimensions)
+
+        if num_zero_dims > 1:
+            mssg = f"Your current HeatSimulation has zero size along the {zero_dim_str}dimensions. "
+            mssg += "Only 2- and 3-D simulations are currently supported."
+            raise SetupError(mssg)
 
         return val
 
     @pd.validator("boundary_spec", always=True)
     @skip_if_fields_missing(["structures", "medium"])
     def names_exist_bcs(cls, val, values):
         """Error if boundary conditions point to non-existing structures/media."""
```

### Comparing `tidy3d-2.6.4/tidy3d/components/heat/source.py` & `tidy3d-2.7.0rc1/tidy3d/components/heat/source.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/heat_spec.py` & `tidy3d-2.7.0rc1/tidy3d/components/heat_spec.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/medium.py` & `tidy3d-2.7.0rc1/tidy3d/components/medium.py`

 * *Files 4% similar despite different names*

```diff
@@ -4,23 +4,24 @@
 from abc import ABC, abstractmethod
 from typing import Tuple, Union, Callable, Optional, Dict, List
 import functools
 from math import isclose
 
 import pydantic.v1 as pd
 import numpy as np
-import xarray as xr
 
 from .base import Tidy3dBaseModel, cached_property
 from .base import skip_if_fields_missing
 from .grid.grid import Coords, Grid
 from .types import PoleAndResidue, Ax, FreqBound, TYPE_TAG_STR
 from .types import InterpMethod, Bound, ArrayComplex3D, ArrayFloat1D
 from .types import Axis, TensorReal, Complex
-from .data.dataset import PermittivityDataset
+from .data.dataset import PermittivityDataset, CustomSpatialDataType, CustomSpatialDataTypeAnnotated
+from .data.dataset import _get_numpy_array, _zeros_like, _check_same_coordinates, _ones_like
+from .data.dataset import UnstructuredGridDataset
 from .data.validators import validate_no_nans
 from .data.data_array import SpatialDataArray, ScalarFieldDataArray, DATA_ARRAY_MAP
 from .viz import add_ax_if_none
 from .geometry.base import Geometry
 from .validators import validate_name_str, validate_parameter_perturbation
 from ..constants import C_0, pec_val, EPSILON_0, fp_eps, HBAR
 from ..constants import HERTZ, CONDUCTIVITY, PERMITTIVITY, RADPERSEC, MICROMETER, SECOND
@@ -1040,25 +1041,41 @@
     def _interp_method(self, comp: Axis) -> InterpMethod:
         """Interpolation method applied to comp."""
         return self.interp_method
 
     @abstractmethod
     def eps_dataarray_freq(
         self, frequency: float
-    ) -> Tuple[SpatialDataArray, SpatialDataArray, SpatialDataArray]:
+    ) -> Tuple[CustomSpatialDataType, CustomSpatialDataType, CustomSpatialDataType]:
         """Permittivity array at ``frequency``.
 
         Parameters
         ----------
         frequency : float
             Frequency to evaluate permittivity at (Hz).
 
         Returns
         -------
-        Tuple[:class:`.SpatialDataArray`, :class:`.SpatialDataArray`, :class:`.SpatialDataArray`]
+        Tuple[
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`
+            ],
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`
+            ],
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`
+            ],
+        ]
             The permittivity evaluated at ``frequency``.
         """
 
     def eps_diagonal_on_grid(
         self,
         frequency: float,
         coords: Coords,
@@ -1077,18 +1094,20 @@
         -------
         Tuple[ArrayComplex3D, ArrayComplex3D, ArrayComplex3D]
             The complex-valued permittivity tensor at ``frequency`` interpolated
             at the supplied coordinate.
         """
         eps_spatial = self.eps_dataarray_freq(frequency)
         if self.is_isotropic:
-            eps_interp = coords.spatial_interp(eps_spatial[0], self._interp_method(0)).values
+            eps_interp = _get_numpy_array(
+                coords.spatial_interp(eps_spatial[0], self._interp_method(0))
+            )
             return (eps_interp, eps_interp, eps_interp)
         return tuple(
-            coords.spatial_interp(eps_comp, self._interp_method(comp)).values
+            _get_numpy_array(coords.spatial_interp(eps_comp, self._interp_method(comp)))
             for comp, eps_comp in enumerate(eps_spatial)
         )
 
     def eps_comp_on_grid(
         self,
         row: Axis,
         col: Axis,
@@ -1120,40 +1139,42 @@
             return self.eps_diagonal_on_grid(frequency, coords)[row]
         return 0j
 
     @ensure_freq_in_range
     def eps_model(self, frequency: float) -> complex:
         """Complex-valued spatially averaged permittivity as a function of frequency."""
         if self.is_isotropic:
-            return np.mean(self.eps_dataarray_freq(frequency)[0].values)
+            return np.mean(_get_numpy_array(self.eps_dataarray_freq(frequency)[0]))
         return np.mean(
-            [np.mean(eps_comp.values) for eps_comp in self.eps_dataarray_freq(frequency)]
+            [np.mean(_get_numpy_array(eps_comp)) for eps_comp in self.eps_dataarray_freq(frequency)]
         )
 
     @ensure_freq_in_range
     def eps_diagonal(self, frequency: float) -> Tuple[complex, complex, complex]:
         """Main diagonal of the complex-valued permittivity tensor
         at ``frequency``. Spatially, we take max{||eps||}, so that autoMesh generation
         works appropriately.
         """
         eps_spatial = self.eps_dataarray_freq(frequency)
         if self.is_isotropic:
-            eps_comp = eps_spatial[0].values.ravel()
+            eps_comp = _get_numpy_array(eps_spatial[0]).ravel()
             eps = eps_comp[np.argmax(np.abs(eps_comp))]
             return (eps, eps, eps)
-        eps_spatial_array = (eps_comp.values.ravel() for eps_comp in eps_spatial)
+        eps_spatial_array = (_get_numpy_array(eps_comp).ravel() for eps_comp in eps_spatial)
         return tuple(eps_comp[np.argmax(np.abs(eps_comp))] for eps_comp in eps_spatial_array)
 
     @staticmethod
-    def _validate_isreal_dataarray(dataarray: SpatialDataArray) -> bool:
+    def _validate_isreal_dataarray(dataarray: CustomSpatialDataType) -> bool:
         """Validate that the dataarray is real"""
-        return np.all(np.isreal(dataarray.values))
+        return np.all(np.isreal(_get_numpy_array(dataarray)))
 
     @staticmethod
-    def _validate_isreal_dataarray_tuple(dataarray_tuple: Tuple[SpatialDataArray, ...]) -> bool:
+    def _validate_isreal_dataarray_tuple(
+        dataarray_tuple: Tuple[CustomSpatialDataType, ...]
+    ) -> bool:
         """Validate that the dataarray is real"""
         return np.all([AbstractCustomMedium._validate_isreal_dataarray(f) for f in dataarray_tuple])
 
     @abstractmethod
     def _sel_custom_data_inside(self, bounds: Bound):
         """Return a new medium that contains the minimal amount custom data necessary to cover
         a spatial region defined by ``bounds``."""
@@ -1174,14 +1195,32 @@
             Medium with reduced data.
         """
 
         self_mod_data_reduced = super().sel_inside(bounds)
 
         return self_mod_data_reduced._sel_custom_data_inside(bounds)
 
+    @staticmethod
+    def _not_loaded(field):
+        """Check whether data was not loaded."""
+        if isinstance(field, str) and field in DATA_ARRAY_MAP:
+            return True
+        # attempting to construct an UnstructuredGridDataset from a dict
+        elif isinstance(field, dict) and field.get("type") in (
+            "TriangularGridDataset",
+            "TetrahedralGridDataset",
+        ):
+            return any(
+                isinstance(subfield, str) and subfield in DATA_ARRAY_MAP
+                for subfield in [field["points"], field["cells"], field["values"]]
+            )
+        # attempting to pass an UnstructuredGridDataset with zero points
+        elif isinstance(field, UnstructuredGridDataset):
+            return any(len(subfield) == 0 for subfield in [field.points, field.cells, field.values])
+
 
 """ Dispersionless Medium """
 
 
 # PEC keyword
 class PECMedium(AbstractMedium):
     """Perfect electrical conductor class.
@@ -1289,30 +1328,30 @@
     @skip_if_fields_missing(["modulation_spec"])
     def _permittivity_modulation_validation(cls, val, values):
         """Assert modulated permittivity cannot be <= 0."""
         modulation = values.get("modulation_spec")
         if modulation is None or modulation.permittivity is None:
             return val
 
-        min_eps_inf = val if np.ndim(val) == 0 else np.min(np.array(val))
+        min_eps_inf = np.min(_get_numpy_array(val))
         if min_eps_inf - modulation.permittivity.max_modulation <= 0:
             raise ValidationError(
                 "The minimum permittivity value with modulation applied was found to be negative."
             )
         return val
 
     @pd.validator("conductivity", always=True)
     @skip_if_fields_missing(["modulation_spec", "allow_gain"])
     def _passivity_modulation_validation(cls, val, values):
         """Assert passive medium if ``allow_gain`` is False."""
         modulation = values.get("modulation_spec")
         if modulation is None or modulation.conductivity is None:
             return val
 
-        min_sigma = val if np.ndim(val) == 0 else np.min(np.array(val))
+        min_sigma = np.min(_get_numpy_array(val))
         if not values.get("allow_gain") and min_sigma - modulation.conductivity.max_modulation < 0:
             raise ValidationError(
                 "For passive medium, 'conductivity' must be non-negative at any time."
                 "With conductivity modulation, this medium can sometimes be active. "
                 "Please set 'allow_gain=True'. "
                 "Caution: simulations with a gain medium are unstable, "
                 "and are likely to diverge."
@@ -1382,22 +1421,22 @@
     >>> coords = dict(x=X, y=Y, z=Z)
     >>> permittivity= SpatialDataArray(np.ones((Nx, Ny, Nz)), coords=coords)
     >>> conductivity= SpatialDataArray(np.ones((Nx, Ny, Nz)), coords=coords)
     >>> dielectric = CustomIsotropicMedium(permittivity=permittivity, conductivity=conductivity)
     >>> eps = dielectric.eps_model(200e12)
     """
 
-    permittivity: SpatialDataArray = pd.Field(
+    permittivity: CustomSpatialDataTypeAnnotated = pd.Field(
         ...,
         title="Permittivity",
         description="Relative permittivity.",
         units=PERMITTIVITY,
     )
 
-    conductivity: Optional[SpatialDataArray] = pd.Field(
+    conductivity: Optional[CustomSpatialDataTypeAnnotated] = pd.Field(
         None,
         title="Conductivity",
         description="Electric conductivity. Defined such that the imaginary part of the complex "
         "permittivity at angular frequency omega is given by conductivity/omega.",
         units=CONDUCTIVITY,
     )
 
@@ -1407,15 +1446,15 @@
     @pd.validator("permittivity", always=True)
     def _eps_inf_greater_no_less_than_one(cls, val):
         """Assert any eps_inf must be >=1"""
 
         if not CustomIsotropicMedium._validate_isreal_dataarray(val):
             raise SetupError("'permittivity' must be real.")
 
-        if np.any(val.values < 1):
+        if np.any(_get_numpy_array(val) < 1):
             raise SetupError("'permittivity' must be no less than one.")
 
         return val
 
     @pd.validator("conductivity", always=True)
     @skip_if_fields_missing(["permittivity"])
     def _conductivity_real_and_correct_shape(cls, val, values):
@@ -1423,25 +1462,25 @@
 
         if val is None:
             return val
 
         if not CustomIsotropicMedium._validate_isreal_dataarray(val):
             raise SetupError("'conductivity' must be real.")
 
-        if values["permittivity"].coords != val.coords:
+        if not _check_same_coordinates(values["permittivity"], val):
             raise SetupError("'permittivity' and 'conductivity' must have the same coordinates.")
         return val
 
     @pd.validator("conductivity", always=True)
     @skip_if_fields_missing(["allow_gain"])
     def _passivity_validation(cls, val, values):
         """Assert passive medium if ``allow_gain`` is False."""
         if val is None:
             return val
-        if not values.get("allow_gain") and np.any(val.values < 0):
+        if not values.get("allow_gain") and np.any(_get_numpy_array(val) < 0):
             raise ValidationError(
                 "For passive medium, 'conductivity' must be non-negative. "
                 "To simulate a gain medium, please set 'allow_gain=True'. "
                 "Caution: simulations with a gain medium are unstable, and are likely to diverge."
             )
         return val
 
@@ -1449,43 +1488,59 @@
     def n_cfl(self):
         """This property computes the index of refraction related to CFL condition, so that
         the FDTD with this medium is stable when the time step size that doesn't take
         material factor into account is multiplied by ``n_cfl``.
 
         For dispersiveless medium, it equals ``sqrt(permittivity)``.
         """
-        permittivity = np.min(self.permittivity.values)
+        permittivity = np.min(_get_numpy_array(self.permittivity))
         if self.modulation_spec is not None and self.modulation_spec.permittivity is not None:
             permittivity -= self.modulation_spec.permittivity.max_modulation
         n, _ = self.eps_complex_to_nk(permittivity)
         return n
 
     @cached_property
     def is_isotropic(self):
         """Whether the medium is isotropic."""
         return True
 
     def eps_dataarray_freq(
         self, frequency: float
-    ) -> Tuple[SpatialDataArray, SpatialDataArray, SpatialDataArray]:
+    ) -> Tuple[CustomSpatialDataType, CustomSpatialDataType, CustomSpatialDataType]:
         """Permittivity array at ``frequency``.
 
         Parameters
         ----------
         frequency : float
             Frequency to evaluate permittivity at (Hz).
 
         Returns
         -------
-        Tuple[:class:`.SpatialDataArray`, :class:`.SpatialDataArray`, :class:`.SpatialDataArray`]
+        Tuple[
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`
+            ],
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`
+            ],
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`
+            ],
+        ]
             The permittivity evaluated at ``frequency``.
         """
         conductivity = self.conductivity
         if conductivity is None:
-            conductivity = xr.zeros_like(self.permittivity)
+            conductivity = _zeros_like(self.permittivity)
         eps = self.eps_sigma_to_eps_complex(self.permittivity, conductivity, frequency)
         return (eps, eps, eps)
 
     def _sel_custom_data_inside(self, bounds: Bound):
         """Return a new custom medium that contains the minimal amount data necessary to cover
         a spatial region defined by ``bounds``.
 
@@ -1539,22 +1594,22 @@
         None,
         title="Permittivity Dataset",
         description="[To be deprecated] User-supplied dataset containing complex-valued "
         "permittivity as a function of space. Permittivity distribution over the Yee-grid "
         "will be interpolated based on ``interp_method``.",
     )
 
-    permittivity: Optional[SpatialDataArray] = pd.Field(
+    permittivity: Optional[CustomSpatialDataTypeAnnotated] = pd.Field(
         None,
         title="Permittivity",
         description="Spatial profile of relative permittivity.",
         units=PERMITTIVITY,
     )
 
-    conductivity: Optional[SpatialDataArray] = pd.Field(
+    conductivity: Optional[CustomSpatialDataTypeAnnotated] = pd.Field(
         None,
         title="Conductivity",
         description="Spatial profile Electric conductivity. Defined such "
         "that the imaginary part of the complex permittivity at angular "
         "frequency omega is given by conductivity/omega.",
         units=CONDUCTIVITY,
     )
@@ -1566,20 +1621,20 @@
     @pd.root_validator(pre=True)
     def _warn_if_none(cls, values):
         """Warn if the data array fails to load, and return a vacuum medium."""
         eps_dataset = values.get("eps_dataset")
         permittivity = values.get("permittivity")
         conductivity = values.get("conductivity")
         fail_load = False
-        if isinstance(permittivity, str) and permittivity in DATA_ARRAY_MAP.keys():
+        if cls._not_loaded(permittivity):
             log.warning(
                 "Loading 'permittivity' without data; constructing a vacuum medium instead."
             )
             fail_load = True
-        if isinstance(conductivity, str) and conductivity in DATA_ARRAY_MAP.keys():
+        if cls._not_loaded(conductivity):
             log.warning(
                 "Loading 'conductivity' without data; constructing a vacuum medium instead."
             )
             fail_load = True
         if isinstance(eps_dataset, dict):
             if any((v in DATA_ARRAY_MAP for _, v in eps_dataset.items() if isinstance(v, str))):
                 log.warning(
@@ -1663,40 +1718,40 @@
             return val
         modulation = values.get("modulation_spec")
 
         for comp in ["eps_xx", "eps_yy", "eps_zz"]:
             eps_real, sigma = CustomMedium.eps_complex_to_eps_sigma(
                 val.field_components[comp], val.field_components[comp].f
             )
-            if np.any(eps_real.values < 1):
+            if np.any(_get_numpy_array(eps_real) < 1):
                 raise SetupError(
                     "Permittivity at infinite frequency at any spatial point "
                     "must be no less than one."
                 )
 
             if modulation is not None and modulation.permittivity is not None:
-                if np.any(eps_real.values - modulation.permittivity.max_modulation <= 0):
+                if np.any(_get_numpy_array(eps_real) - modulation.permittivity.max_modulation <= 0):
                     raise ValidationError(
                         "The minimum permittivity value with modulation applied "
                         "was found to be negative."
                     )
 
-            if not values.get("allow_gain") and np.any(sigma.values < 0):
+            if not values.get("allow_gain") and np.any(_get_numpy_array(sigma) < 0):
                 raise ValidationError(
                     "For passive medium, imaginary part of permittivity must be non-negative. "
                     "To simulate a gain medium, please set 'allow_gain=True'. "
                     "Caution: simulations with a gain medium are unstable, "
                     "and are likely to diverge."
                 )
 
             if (
                 not values.get("allow_gain")
                 and modulation is not None
                 and modulation.conductivity is not None
-                and np.any(sigma.values - modulation.conductivity.max_modulation <= 0)
+                and np.any(_get_numpy_array(sigma) - modulation.conductivity.max_modulation <= 0)
             ):
                 raise ValidationError(
                     "For passive medium, imaginary part of permittivity must be non-negative "
                     "at any time. "
                     "With conductivity modulation, this medium can sometimes be active. "
                     "Please set 'allow_gain=True'. "
                     "Caution: simulations with a gain medium are unstable, "
@@ -1710,22 +1765,22 @@
         """Assert any eps_inf must be >=1"""
         if val is None:
             return val
 
         if not CustomMedium._validate_isreal_dataarray(val):
             raise SetupError("'permittivity' must be real.")
 
-        if np.any(val.values < 1):
+        if np.any(_get_numpy_array(val) < 1):
             raise SetupError("'permittivity' must be no less than one.")
 
         modulation = values.get("modulation_spec")
         if modulation is None or modulation.permittivity is None:
             return val
 
-        if np.any(val.values - modulation.permittivity.max_modulation <= 0):
+        if np.any(_get_numpy_array(val) - modulation.permittivity.max_modulation <= 0):
             raise ValidationError(
                 "The minimum permittivity value with modulation applied was found to be negative."
             )
 
         return val
 
     @pd.validator("conductivity", always=True)
@@ -1735,23 +1790,23 @@
 
         if val is None:
             return val
 
         if not CustomMedium._validate_isreal_dataarray(val):
             raise SetupError("'conductivity' must be real.")
 
-        if not values.get("allow_gain") and np.any(val.values < 0):
+        if not values.get("allow_gain") and np.any(_get_numpy_array(val) < 0):
             raise ValidationError(
                 "For passive medium, 'conductivity' must be non-negative. "
                 "To simulate a gain medium, please set 'allow_gain=True'. "
                 "Caution: simulations with a gain medium are unstable, "
                 "and are likely to diverge."
             )
 
-        if values["permittivity"].coords != val.coords:
+        if not _check_same_coordinates(values["permittivity"], val):
             raise SetupError("'permittivity' and 'conductivity' must have the same coordinates.")
 
         return val
 
     @pd.validator("conductivity", always=True)
     @skip_if_fields_missing(["eps_dataset", "modulation_spec", "allow_gain"])
     def _passivity_modulation_validation(cls, val, values):
@@ -1761,15 +1816,17 @@
         if values.get("eps_dataset"):
             return val
 
         # permittivity defined with ``permittivity`` and ``conductivity``
         modulation = values.get("modulation_spec")
         if values.get("allow_gain") or modulation is None or modulation.conductivity is None:
             return val
-        if val is None or np.any(val.values - modulation.conductivity.max_modulation < 0):
+        if val is None or np.any(
+            _get_numpy_array(val) - modulation.conductivity.max_modulation < 0
+        ):
             raise ValidationError(
                 "For passive medium, 'conductivity' must be non-negative at any time. "
                 "With conductivity modulation, this medium can sometimes be active. "
                 "Please set 'allow_gain=True'. "
                 "Caution: simulations with a gain medium are unstable, "
                 "and are likely to diverge."
             )
@@ -1858,25 +1915,41 @@
         For dispersiveless custom medium, it equals ``min[sqrt(eps_inf)]``, where ``min``
         is performed over all components and spatial points.
         """
         return self._medium.n_cfl
 
     def eps_dataarray_freq(
         self, frequency: float
-    ) -> Tuple[SpatialDataArray, SpatialDataArray, SpatialDataArray]:
+    ) -> Tuple[CustomSpatialDataType, CustomSpatialDataType, CustomSpatialDataType]:
         """Permittivity array at ``frequency``. ()
 
         Parameters
         ----------
         frequency : float
             Frequency to evaluate permittivity at (Hz).
 
         Returns
         -------
-        Tuple[:class:`.SpatialDataArray`, :class:`.SpatialDataArray`, :class:`.SpatialDataArray`]
+        Tuple[
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ],
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ],
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ],
+        ]
             The permittivity evaluated at ``frequency``.
         """
         return self._medium.eps_dataarray_freq(frequency)
 
     def eps_diagonal_on_grid(
         self,
         frequency: float,
@@ -1914,24 +1987,29 @@
         as a function of frequency.
         """
         return self._medium.eps_model(frequency)
 
     @classmethod
     def from_eps_raw(
         cls,
-        eps: Union[ScalarFieldDataArray, SpatialDataArray],
+        eps: Union[ScalarFieldDataArray, CustomSpatialDataType],
         freq: float = None,
         interp_method: InterpMethod = "nearest",
         **kwargs,
     ) -> CustomMedium:
         """Construct a :class:`.CustomMedium` from datasets containing raw permittivity values.
 
         Parameters
         ----------
-        eps : Union[:class:`.SpatialDataArray`, :class:`.ScalarFieldDataArray`]
+        eps : Union[
+                :class:`.SpatialDataArray`,
+                :class:`.ScalarFieldDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ]
             Dataset containing complex-valued permittivity as a function of space.
         freq : float, optional
             Frequency at which ``eps`` are defined.
         interp_method : :class:`.InterpMethod`, optional
             Interpolation method to obtain permittivity values that are not supplied
             at the Yee grids.
 
@@ -1946,15 +2024,15 @@
             In this case, leave ``freq`` kwarg as the default of ``None``.
 
         Returns
         -------
         :class:`.CustomMedium`
             Medium containing the spatially varying permittivity data.
         """
-        if isinstance(eps, SpatialDataArray):
+        if isinstance(eps, CustomSpatialDataType.__args__):
             # purely real, not need to know `freq`
             if CustomMedium._validate_isreal_dataarray(eps):
                 return cls(permittivity=eps, interp_method=interp_method, **kwargs)
             # complex permittivity, needs to know `freq`
             if freq is None:
                 raise SetupError(
                     "For a complex 'eps', 'freq' at which 'eps' is defined must be supplied",
@@ -1978,27 +2056,37 @@
         eps_real = SpatialDataArray(eps_real.squeeze(dim="f", drop=True))
         sigma = SpatialDataArray(sigma.squeeze(dim="f", drop=True))
         return cls(permittivity=eps_real, conductivity=sigma, interp_method=interp_method, **kwargs)
 
     @classmethod
     def from_nk(
         cls,
-        n: Union[ScalarFieldDataArray, SpatialDataArray],
-        k: Optional[Union[ScalarFieldDataArray, SpatialDataArray]] = None,
+        n: Union[ScalarFieldDataArray, CustomSpatialDataType],
+        k: Optional[Union[ScalarFieldDataArray, CustomSpatialDataType]] = None,
         freq: float = None,
         interp_method: InterpMethod = "nearest",
         **kwargs,
     ) -> CustomMedium:
         """Construct a :class:`.CustomMedium` from datasets containing n and k values.
 
         Parameters
         ----------
-        n : Union[:class:`.SpatialDataArray`, :class:`.ScalarFieldDataArray`]
+        n : Union[
+                :class:`.SpatialDataArray`,
+                :class:`.ScalarFieldDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ]
             Real part of refractive index.
-        k : Union[:class:`.SpatialDataArray`, :class:`.ScalarFieldDataArray`], optional
+        k : Union[
+                :class:`.SpatialDataArray`,
+                :class:`.ScalarFieldDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ], optional
             Imaginary part of refrative index for lossy medium.
         freq : float, optional
             Frequency at which ``n`` and ``k`` are defined.
         interp_method : :class:`.InterpMethod`, optional
             Interpolation method to obtain permittivity values that are not supplied
             at the Yee grids.
 
@@ -2021,21 +2109,19 @@
             if isinstance(n, ScalarFieldDataArray):
                 n = SpatialDataArray(n.squeeze(dim="f", drop=True))
             freq = 0  # dummy value
             eps_real, _ = CustomMedium.nk_to_eps_sigma(n, 0 * n, freq)
             return cls(permittivity=eps_real, interp_method=interp_method, **kwargs)
 
         # lossy case
-        if n.coords.keys() != k.coords.keys():
-            raise SetupError("'n' and 'k' must be of the same type.")
-        if n.coords != k.coords:
-            raise SetupError("'n' and 'k' must have same coordinates.")
+        if not _check_same_coordinates(n, k):
+            raise SetupError("'n' and 'k' must be of the same type and must have same coordinates.")
 
         # k is a SpatialDataArray
-        if isinstance(k, SpatialDataArray):
+        if isinstance(k, CustomSpatialDataType.__args__):
             if freq is None:
                 raise SetupError(
                     "For a lossy medium, must supply 'freq' at which to convert 'n' "
                     "and 'k' to a complex valued permittivity."
                 )
             eps_real, sigma = CustomMedium.nk_to_eps_sigma(n, k, freq)
             return cls(
@@ -2206,15 +2292,15 @@
         @skip_if_fields_missing(["modulation_spec"])
         def _validate_permittivity_modulation(cls, val, values):
             """Assert modulated permittivity cannot be <= 0."""
             modulation = values.get("modulation_spec")
             if modulation is None or modulation.permittivity is None:
                 return val
 
-            min_eps_inf = val if np.ndim(val) == 0 else np.min(np.array(val))
+            min_eps_inf = np.min(_get_numpy_array(val))
             if min_eps_inf - modulation.permittivity.max_modulation <= 0:
                 raise ValidationError(
                     "The minimum permittivity value with modulation applied was found to be negative."
                 )
             return val
 
         return _validate_permittivity_modulation
@@ -2289,15 +2375,15 @@
         """This property computes the index of refraction related to CFL condition, so that
         the FDTD with this medium is stable when the time step size that doesn't take
         material factor into account is multiplied by ``n_cfl``.
 
         For PoleResidue model, it equals ``sqrt(eps_inf)``
         [https://ieeexplore.ieee.org/document/9082879].
         """
-        permittivity = np.min(self.pole_residue.eps_inf.values)
+        permittivity = np.min(_get_numpy_array(self.pole_residue.eps_inf))
         if self.modulation_spec is not None and self.modulation_spec.permittivity is not None:
             permittivity -= self.modulation_spec.permittivity.max_modulation
         n, _ = self.eps_complex_to_nk(permittivity)
         return n
 
     @cached_property
     def is_isotropic(self):
@@ -2323,24 +2409,24 @@
         @pd.root_validator(pre=True, allow_reuse=True)
         def _warn_if_none(cls, values):
             """Warn if any of `eps_inf` and nested_tuple_field are not load."""
             eps_inf = values.get("eps_inf")
             coeffs = values.get(nested_tuple_field)
             fail_load = False
 
-            if isinstance(eps_inf, str) and eps_inf in DATA_ARRAY_MAP.keys():
+            if AbstractCustomMedium._not_loaded(eps_inf):
                 log.warning("Loading 'eps_inf' without data; constructing a vacuum medium instead.")
                 fail_load = True
             for coeff in coeffs:
                 if fail_load:
                     break
                 for coeff_i in coeff:
-                    if isinstance(coeff_i, str) and coeff_i in DATA_ARRAY_MAP.keys():
+                    if AbstractCustomMedium._not_loaded(coeff_i):
                         log.warning(
-                            "Loading '{nested_tuple_field}' without data; "
+                            f"Loading '{nested_tuple_field}' without data; "
                             "constructing a vacuum medium instead."
                         )
                         fail_load = True
                         break
 
             if fail_load and eps_inf is None:
                 return {nested_tuple_field: ()}
@@ -2398,32 +2484,32 @@
         units=(RADPERSEC, RADPERSEC),
     )
 
     @pd.validator("poles", always=True)
     def _causality_validation(cls, val):
         """Assert causal medium."""
         for a, _ in val:
-            if np.any(np.real(a) > 0):
+            if np.any(np.real(_get_numpy_array(a)) > 0):
                 raise SetupError("For stable medium, 'Re(a_i)' must be non-positive.")
         return val
 
     _validate_permittivity_modulation = DispersiveMedium._permittivity_modulation_validation()
     _validate_conductivity_modulation = DispersiveMedium._conductivity_modulation_validation()
 
     @ensure_freq_in_range
     def eps_model(self, frequency: float) -> complex:
         """Complex-valued permittivity as a function of frequency."""
 
         omega = 2 * np.pi * frequency
-        eps = self.eps_inf + np.zeros_like(frequency) + 0.0j
+        eps = self.eps_inf + 0 * frequency + 0.0j
         for a, c in self.poles:
             a_cc = np.conj(a)
             c_cc = np.conj(c)
-            eps -= c / (1j * omega + a)
-            eps -= c_cc / (1j * omega + a_cc)
+            eps = eps - c / (1j * omega + a)
+            eps = eps - c_cc / (1j * omega + a_cc)
         return eps
 
     def _pole_residue_dict(self) -> Dict:
         """Dict representation of Medium as a pole-residue model."""
 
         return dict(
             eps_inf=self.eps_inf,
@@ -2470,15 +2556,15 @@
         :class:`.Medium`
             The non-dispersive equivalent with constant permittivity and conductivity.
         """
         res = 0
         for a, c in self.poles:
             if abs(a) > fp_eps:
                 raise ValidationError("Cannot convert dispersive 'PoleResidue' to 'Medium'.")
-            res += (c + np.conj(c)) / 2
+            res = res + (c + np.conj(c)) / 2
         sigma = res * 2 * EPSILON_0
         return Medium(
             permittivity=self.eps_inf,
             conductivity=np.real(sigma),
             frequency_range=self.frequency_range,
         )
 
@@ -2787,22 +2873,24 @@
     * `Fitting dispersive material models <../../notebooks/Fitting.html>`_
 
     **Lectures**
 
     * `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_
     """
 
-    eps_inf: SpatialDataArray = pd.Field(
+    eps_inf: CustomSpatialDataTypeAnnotated = pd.Field(
         ...,
         title="Epsilon at Infinity",
         description="Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
         units=PERMITTIVITY,
     )
 
-    poles: Tuple[Tuple[SpatialDataArray, SpatialDataArray], ...] = pd.Field(
+    poles: Tuple[
+        Tuple[CustomSpatialDataTypeAnnotated, CustomSpatialDataTypeAnnotated], ...
+    ] = pd.Field(
         (),
         title="Poles",
         description="Tuple of complex-valued (:math:`a_i, c_i`) poles for the model.",
         units=(RADPERSEC, RADPERSEC),
     )
 
     _no_nans_eps_inf = validate_no_nans("eps_inf")
@@ -2810,46 +2898,61 @@
     _warn_if_none = CustomDispersiveMedium._warn_if_data_none("poles")
 
     @pd.validator("eps_inf", always=True)
     def _eps_inf_positive(cls, val):
         """eps_inf must be positive"""
         if not CustomDispersiveMedium._validate_isreal_dataarray(val):
             raise SetupError("'eps_inf' must be real.")
-        if np.any(val < 0):
+        if np.any(_get_numpy_array(val) < 0):
             raise SetupError("'eps_inf' must be positive.")
         return val
 
     @pd.validator("poles", always=True)
     @skip_if_fields_missing(["eps_inf"])
     def _poles_correct_shape(cls, val, values):
         """poles must have the same shape."""
 
-        expected_coords = values["eps_inf"].coords
         for coeffs in val:
             for coeff in coeffs:
-                if coeff.coords != expected_coords:
+                if not _check_same_coordinates(coeff, values["eps_inf"]):
                     raise SetupError(
                         "All pole coefficients 'a' and 'c' must have the same coordinates; "
                         "The coordinates must also be consistent with 'eps_inf'."
                     )
         return val
 
     def eps_dataarray_freq(
         self, frequency: float
-    ) -> Tuple[SpatialDataArray, SpatialDataArray, SpatialDataArray]:
+    ) -> Tuple[CustomSpatialDataType, CustomSpatialDataType, CustomSpatialDataType]:
         """Permittivity array at ``frequency``.
 
         Parameters
         ----------
         frequency : float
             Frequency to evaluate permittivity at (Hz).
 
         Returns
         -------
-        Tuple[:class:`.SpatialDataArray`, :class:`.SpatialDataArray`, :class:`.SpatialDataArray`]
+        Tuple[
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ],
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ],
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ],
+        ]
             The permittivity evaluated at ``frequency``.
         """
         eps = PoleResidue.eps_model(self, frequency)
         return (eps, eps, eps)
 
     def poles_on_grid(self, coords: Coords) -> Tuple[Tuple[ArrayComplex3D, ArrayComplex3D], ...]:
         """Spatial profile of poles interpolated at the supplied coordinates.
@@ -2862,15 +2965,15 @@
         Returns
         -------
         Tuple[Tuple[ArrayComplex3D, ArrayComplex3D], ...]
             The poles interpolated at the supplied coordinate.
         """
 
         def fun_interp(input_data: SpatialDataArray) -> ArrayComplex3D:
-            return coords.spatial_interp(input_data, self.interp_method).values
+            return _get_numpy_array(coords.spatial_interp(input_data, self.interp_method))
 
         return tuple((fun_interp(a), fun_interp(c)) for (a, c) in self.poles)
 
     @classmethod
     def from_medium(cls, medium: CustomMedium) -> CustomPoleResidue:
         """Convert a :class:`.CustomMedium` to a pole residue model.
 
@@ -2880,15 +2983,15 @@
             The medium with permittivity and conductivity to convert.
 
         Returns
         -------
         :class:`.CustomPoleResidue`
             The pole residue equivalent.
         """
-        poles = [(xr.zeros_like(medium.conductivity), medium.conductivity / (2 * EPSILON_0))]
+        poles = [(_zeros_like(medium.conductivity), medium.conductivity / (2 * EPSILON_0))]
         medium_dict = medium.dict(exclude={"type", "eps_dataset", "permittivity", "conductivity"})
         medium_dict.update({"eps_inf": medium.permittivity, "poles": poles})
         return CustomPoleResidue.parse_obj(medium_dict)
 
     def to_medium(self) -> CustomMedium:
         """Convert to a :class:`.CustomMedium`.
         Requires the pole residue model to only have a pole at 0 frequency,
@@ -2897,19 +3000,19 @@
         Returns
         -------
         :class:`.CustomMedium`
             The non-dispersive equivalent with constant permittivity and conductivity.
         """
         res = 0
         for a, c in self.poles:
-            if np.any(abs(a.values) > fp_eps):
+            if np.any(abs(_get_numpy_array(a)) > fp_eps):
                 raise ValidationError(
                     "Cannot convert dispersive 'CustomPoleResidue' to 'CustomMedium'."
                 )
-            res += (c + np.conj(c)) / 2
+            res = res + (c + np.conj(c)) / 2
         sigma = res * 2 * EPSILON_0
 
         self_dict = self.dict(exclude={"type", "eps_inf", "poles"})
         self_dict.update({"permittivity": self.eps_inf, "conductivity": np.real(sigma)})
         return CustomMedium.parse_obj(self_dict)
 
     @cached_property
@@ -3027,15 +3130,15 @@
     def _n_model(self, frequency: float) -> complex:
         """Complex-valued refractive index as a function of frequency."""
 
         wvl = C_0 / np.array(frequency)
         wvl2 = wvl**2
         n_squared = 1.0
         for B, C in self.coeffs:
-            n_squared += B * wvl2 / (wvl2 - C)
+            n_squared = n_squared + B * wvl2 / (wvl2 - C)
         return np.sqrt(n_squared + 0j)
 
     @ensure_freq_in_range
     def eps_model(self, frequency: float) -> complex:
         """Complex-valued permittivity as a function of frequency."""
 
         n = self._n_model(frequency)
@@ -3121,15 +3224,17 @@
     **Notebooks**
         * `Fitting dispersive material models <../../notebooks/Fitting.html>`_
 
     **Lectures**
         * `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_
     """
 
-    coeffs: Tuple[Tuple[SpatialDataArray, SpatialDataArray], ...] = pd.Field(
+    coeffs: Tuple[
+        Tuple[CustomSpatialDataTypeAnnotated, CustomSpatialDataTypeAnnotated], ...
+    ] = pd.Field(
         ...,
         title="Coefficients",
         description="List of Sellmeier (:math:`B_i, C_i`) coefficients.",
         units=(None, MICROMETER + "^2"),
     )
 
     _no_nans = validate_no_nans("coeffs")
@@ -3137,105 +3242,130 @@
     _warn_if_none = CustomDispersiveMedium._warn_if_data_none("coeffs")
 
     @pd.validator("coeffs", always=True)
     def _correct_shape_and_sign(cls, val):
         """every term in coeffs must have the same shape, and B>=0 and C>0."""
         if len(val) == 0:
             return val
-        expected_coords = val[0][0].coords
         for B, C in val:
-            if B.coords != expected_coords or C.coords != expected_coords:
+            if not _check_same_coordinates(B, val[0][0]) or not _check_same_coordinates(
+                C, val[0][0]
+            ):
                 raise SetupError("Every term in 'coeffs' must have the same coordinates.")
             if not CustomDispersiveMedium._validate_isreal_dataarray_tuple((B, C)):
                 raise SetupError("'B' and 'C' must be real.")
-            if np.any(C <= 0):
+            if np.any(_get_numpy_array(C) <= 0):
                 raise SetupError("'C' must be positive.")
         return val
 
     @pd.validator("coeffs", always=True)
     @skip_if_fields_missing(["allow_gain"])
     def _passivity_validation(cls, val, values):
         """Assert passive medium if `allow_gain` is False."""
         if values.get("allow_gain"):
             return val
         for B, _ in val:
-            if np.any(B < 0):
+            if np.any(_get_numpy_array(B) < 0):
                 raise ValidationError(
                     "For passive medium, 'B_i' must be non-negative. "
                     "To simulate a gain medium, please set 'allow_gain=True'. "
                     "Caution: simulations with a gain medium are unstable, "
                     "and are likely to diverge."
                 )
         return val
 
     def _pole_residue_dict(self) -> Dict:
         """Dict representation of Medium as a pole-residue model."""
         poles_dict = Sellmeier._pole_residue_dict(self)
         if len(self.coeffs) > 0:
-            poles_dict.update({"eps_inf": xr.ones_like(self.coeffs[0][0])})
+            poles_dict.update({"eps_inf": _ones_like(self.coeffs[0][0])})
         return poles_dict
 
     def eps_dataarray_freq(
         self, frequency: float
-    ) -> Tuple[SpatialDataArray, SpatialDataArray, SpatialDataArray]:
+    ) -> Tuple[CustomSpatialDataType, CustomSpatialDataType, CustomSpatialDataType]:
         """Permittivity array at ``frequency``.
 
         Parameters
         ----------
         frequency : float
             Frequency to evaluate permittivity at (Hz).
 
         Returns
         -------
-        Tuple[:class:`.SpatialDataArray`, :class:`.SpatialDataArray`, :class:`.SpatialDataArray`]
+        Tuple[
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ],
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ],
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ],
+        ]
             The permittivity evaluated at ``frequency``.
         """
         eps = Sellmeier.eps_model(self, frequency)
         # if `eps` is simply a float, convert it to a SpatialDataArray ; this is possible when
         # `coeffs` is empty.
         if isinstance(eps, (int, float, complex)):
             eps = SpatialDataArray(eps * np.ones((1, 1, 1)), coords=dict(x=[0], y=[0], z=[0]))
         return (eps, eps, eps)
 
     @classmethod
     def from_dispersion(
         cls,
-        n: SpatialDataArray,
+        n: CustomSpatialDataType,
         freq: float,
-        dn_dwvl: SpatialDataArray,
+        dn_dwvl: CustomSpatialDataType,
         interp_method="nearest",
         **kwargs,
     ):
         """Convert ``n`` and wavelength dispersion ``dn_dwvl`` values at frequency ``freq`` to
         a single-pole :class:`CustomSellmeier` medium.
 
         Parameters
         ----------
-        n : :class:`.SpatialDataArray`
+        n : Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ]
             Real part of refractive index. Must be larger than or equal to one.
-        dn_dwvl : :class:`.SpatialDataArray`
+        dn_dwvl : Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ]
             Derivative of the refractive index with wavelength (1/um). Must be negative.
         freq : float
             Frequency at which ``n`` and ``dn_dwvl`` are sampled.
         interp_method : :class:`.InterpMethod`, optional
             Interpolation method to obtain permittivity values that are not supplied
             at the Yee grids.
 
         Returns
         -------
         :class:`.CustomSellmeier`
             Single-pole Sellmeier medium with the prvoided refractive index and index dispersion
             valuesat at the prvoided frequency.
         """
 
-        if n.shape != dn_dwvl.shape:
+        if not _check_same_coordinates(n, dn_dwvl):
             raise ValidationError("'n' and'dn_dwvl' must have the same dimension.")
-        if np.any(dn_dwvl >= 0):
+        if np.any(_get_numpy_array(dn_dwvl) >= 0):
             raise ValidationError("Dispersion ``dn_dwvl`` must be smaller than zero.")
-        if np.any(n < 1):
+        if np.any(_get_numpy_array(n) < 1):
             raise ValidationError("Refractive index ``n`` cannot be smaller than one.")
         return cls(
             coeffs=cls._from_dispersion_to_coeffs(n, freq, dn_dwvl),
             interp_method=interp_method,
             **kwargs,
         )
 
@@ -3342,15 +3472,15 @@
 
     @ensure_freq_in_range
     def eps_model(self, frequency: float) -> complex:
         """Complex-valued permittivity as a function of frequency."""
 
         eps = self.eps_inf + 0.0j
         for de, f, delta in self.coeffs:
-            eps += (de * f**2) / (f**2 - 2j * frequency * delta - frequency**2)
+            eps = eps + (de * f**2) / (f**2 - 2j * frequency * delta - frequency**2)
         return eps
 
     def _pole_residue_dict(self) -> Dict:
         """Dict representation of Medium as a pole-residue model."""
 
         poles = []
         for de, f, delta in self.coeffs:
@@ -3376,16 +3506,16 @@
             frequency_range=self.frequency_range,
             name=self.name,
         )
 
     @staticmethod
     def _all_larger(coeff_a, coeff_b) -> bool:
         """``coeff_a`` and ``coeff_b`` can be either float or SpatialDataArray."""
-        if isinstance(coeff_a, SpatialDataArray):
-            return np.all(coeff_a.values > coeff_b.values)
+        if isinstance(coeff_a, CustomSpatialDataType.__args__):
+            return np.all(_get_numpy_array(coeff_a) > _get_numpy_array(coeff_b))
         return coeff_a > coeff_b
 
     @classmethod
     def from_nk(cls, n: float, k: float, freq: float, **kwargs):
         """Convert ``n`` and ``k`` values at frequency ``freq`` to a single-pole Lorentz
         medium.
 
@@ -3473,22 +3603,29 @@
     **Notebooks**
         * `Fitting dispersive material models <../../notebooks/Fitting.html>`_
 
     **Lectures**
         * `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_
     """
 
-    eps_inf: SpatialDataArray = pd.Field(
+    eps_inf: CustomSpatialDataTypeAnnotated = pd.Field(
         ...,
         title="Epsilon at Infinity",
         description="Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
         units=PERMITTIVITY,
     )
 
-    coeffs: Tuple[Tuple[SpatialDataArray, SpatialDataArray, SpatialDataArray], ...] = pd.Field(
+    coeffs: Tuple[
+        Tuple[
+            CustomSpatialDataTypeAnnotated,
+            CustomSpatialDataTypeAnnotated,
+            CustomSpatialDataTypeAnnotated,
+        ],
+        ...,
+    ] = pd.Field(
         ...,
         title="Coefficients",
         description="List of (:math:`\\Delta\\epsilon_i, f_i, \\delta_i`) values for model.",
         units=(PERMITTIVITY, HERTZ, HERTZ),
     )
 
     _no_nans_eps_inf = validate_no_nans("eps_inf")
@@ -3497,15 +3634,15 @@
     _warn_if_none = CustomDispersiveMedium._warn_if_data_none("coeffs")
 
     @pd.validator("eps_inf", always=True)
     def _eps_inf_positive(cls, val):
         """eps_inf must be positive"""
         if not CustomDispersiveMedium._validate_isreal_dataarray(val):
             raise SetupError("'eps_inf' must be real.")
-        if np.any(val < 0):
+        if np.any(_get_numpy_array(val) < 0):
             raise SetupError("'eps_inf' must be positive.")
         return val
 
     @pd.validator("coeffs", always=True)
     def _coeffs_unequal_f_delta(cls, val):
         """f and delta cannot be exactly the same.
         Not needed for now because we have a more strict
@@ -3513,20 +3650,19 @@
         """
         return val
 
     @pd.validator("coeffs", always=True)
     @skip_if_fields_missing(["eps_inf"])
     def _coeffs_correct_shape(cls, val, values):
         """coeffs must have consistent shape."""
-        expected_coords = values["eps_inf"].coords
         for de, f, delta in val:
             if (
-                de.coords != expected_coords
-                or f.coords != expected_coords
-                or delta.coords != expected_coords
+                not _check_same_coordinates(de, values["eps_inf"])
+                or not _check_same_coordinates(f, values["eps_inf"])
+                or not _check_same_coordinates(delta, values["eps_inf"])
             ):
                 raise SetupError(
                     "All terms in 'coeffs' must have the same coordinates; "
                     "The coordinates must also be consistent with 'eps_inf'."
                 )
             if not CustomDispersiveMedium._validate_isreal_dataarray_tuple((de, f, delta)):
                 raise SetupError("All terms in 'coeffs' must be real.")
@@ -3547,38 +3683,54 @@
 
     @pd.validator("coeffs", always=True)
     @skip_if_fields_missing(["allow_gain"])
     def _passivity_validation(cls, val, values):
         """Assert passive medium if ``allow_gain`` is False."""
         allow_gain = values.get("allow_gain")
         for del_ep, _, delta in val:
-            if np.any(delta < 0):
+            if np.any(_get_numpy_array(delta) < 0):
                 raise ValidationError("For stable medium, 'delta_i' must be non-negative.")
-            if not allow_gain and np.any(del_ep < 0):
+            if not allow_gain and np.any(_get_numpy_array(del_ep) < 0):
                 raise ValidationError(
                     "For passive medium, 'Delta epsilon_i' must be non-negative. "
                     "To simulate a gain medium, please set 'allow_gain=True'. "
                     "Caution: simulations with a gain medium are unstable, "
                     "and are likely to diverge."
                 )
         return val
 
     def eps_dataarray_freq(
         self, frequency: float
-    ) -> Tuple[SpatialDataArray, SpatialDataArray, SpatialDataArray]:
+    ) -> Tuple[CustomSpatialDataType, CustomSpatialDataType, CustomSpatialDataType]:
         """Permittivity array at ``frequency``.
 
         Parameters
         ----------
         frequency : float
             Frequency to evaluate permittivity at (Hz).
 
         Returns
         -------
-        Tuple[:class:`.SpatialDataArray`, :class:`.SpatialDataArray`, :class:`.SpatialDataArray`]
+        Tuple[
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ],
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ],
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ],
+        ]
             The permittivity evaluated at ``frequency``.
         """
         eps = Lorentz.eps_model(self, frequency)
         return (eps, eps, eps)
 
     def _sel_custom_data_inside(self, bounds: Bound):
         """Return a new custom medium that contains the minimal amount data necessary to cover
@@ -3672,15 +3824,15 @@
 
     @ensure_freq_in_range
     def eps_model(self, frequency: float) -> complex:
         """Complex-valued permittivity as a function of frequency."""
 
         eps = self.eps_inf + 0.0j
         for f, delta in self.coeffs:
-            eps -= (f**2) / (frequency**2 + 1j * frequency * delta)
+            eps = eps - (f**2) / (frequency**2 + 1j * frequency * delta)
         return eps
 
     def _pole_residue_dict(self) -> Dict:
         """Dict representation of Medium as a pole-residue model."""
 
         poles = []
 
@@ -3691,15 +3843,15 @@
             c0 = (w**2) / 2 / d + 0j
             c1 = -c0
             a1 = -d + 0j
 
             if isinstance(c0, complex):
                 a0 = 0j
             else:
-                a0 = xr.zeros_like(c0)
+                a0 = 0 * c0
 
             poles.extend(((a0, c0), (a1, c1)))
 
         return dict(
             eps_inf=self.eps_inf,
             poles=poles,
             frequency_range=self.frequency_range,
@@ -3742,22 +3894,24 @@
     **Notebooks**
         * `Fitting dispersive material models <../../notebooks/Fitting.html>`_
 
     **Lectures**
         * `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_
     """
 
-    eps_inf: SpatialDataArray = pd.Field(
+    eps_inf: CustomSpatialDataTypeAnnotated = pd.Field(
         ...,
         title="Epsilon at Infinity",
         description="Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
         units=PERMITTIVITY,
     )
 
-    coeffs: Tuple[Tuple[SpatialDataArray, SpatialDataArray], ...] = pd.Field(
+    coeffs: Tuple[
+        Tuple[CustomSpatialDataTypeAnnotated, CustomSpatialDataTypeAnnotated], ...
+    ] = pd.Field(
         ...,
         title="Coefficients",
         description="List of (:math:`f_i, \\delta_i`) values for model.",
         units=(HERTZ, HERTZ),
     )
 
     _no_nans_eps_inf = validate_no_nans("eps_inf")
@@ -3766,48 +3920,65 @@
     _warn_if_none = CustomDispersiveMedium._warn_if_data_none("coeffs")
 
     @pd.validator("eps_inf", always=True)
     def _eps_inf_positive(cls, val):
         """eps_inf must be positive"""
         if not CustomDispersiveMedium._validate_isreal_dataarray(val):
             raise SetupError("'eps_inf' must be real.")
-        if np.any(val < 0):
+        if np.any(_get_numpy_array(val) < 0):
             raise SetupError("'eps_inf' must be positive.")
         return val
 
     @pd.validator("coeffs", always=True)
     @skip_if_fields_missing(["eps_inf"])
     def _coeffs_correct_shape_and_sign(cls, val, values):
         """coeffs must have consistent shape and sign."""
-        expected_coords = values["eps_inf"].coords
         for f, delta in val:
-            if f.coords != expected_coords or delta.coords != expected_coords:
+            if not _check_same_coordinates(f, values["eps_inf"]) or not _check_same_coordinates(
+                delta, values["eps_inf"]
+            ):
                 raise SetupError(
                     "All terms in 'coeffs' must have the same coordinates; "
                     "The coordinates must also be consistent with 'eps_inf'."
                 )
             if not CustomDispersiveMedium._validate_isreal_dataarray_tuple((f, delta)):
                 raise SetupError("All terms in 'coeffs' must be real.")
-            if np.any(delta <= 0):
+            if np.any(_get_numpy_array(delta) <= 0):
                 raise SetupError("For stable medium, 'delta' must be positive.")
         return val
 
     def eps_dataarray_freq(
         self, frequency: float
-    ) -> Tuple[SpatialDataArray, SpatialDataArray, SpatialDataArray]:
+    ) -> Tuple[CustomSpatialDataType, CustomSpatialDataType, CustomSpatialDataType]:
         """Permittivity array at ``frequency``.
 
         Parameters
         ----------
         frequency : float
             Frequency to evaluate permittivity at (Hz).
 
         Returns
         -------
-        Tuple[:class:`.SpatialDataArray`, :class:`.SpatialDataArray`, :class:`.SpatialDataArray`]
+        Tuple[
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ],
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ],
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ],
+        ]
             The permittivity evaluated at ``frequency``.
         """
         eps = Drude.eps_model(self, frequency)
         return (eps, eps, eps)
 
     def _sel_custom_data_inside(self, bounds: Bound):
         """Return a new custom medium that contains the minimal amount data necessary to cover
@@ -3910,15 +4081,15 @@
 
     @ensure_freq_in_range
     def eps_model(self, frequency: float) -> complex:
         """Complex-valued permittivity as a function of frequency."""
 
         eps = self.eps_inf + 0.0j
         for de, tau in self.coeffs:
-            eps += de / (1 - 1j * frequency * tau)
+            eps = eps + de / (1 - 1j * frequency * tau)
         return eps
 
     def _pole_residue_dict(self):
         """Dict representation of Medium as a pole-residue model."""
 
         poles = []
         for de, tau in self.coeffs:
@@ -3969,22 +4140,24 @@
     **Notebooks**
         * `Fitting dispersive material models <../../notebooks/Fitting.html>`_
 
     **Lectures**
         * `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_
     """
 
-    eps_inf: SpatialDataArray = pd.Field(
+    eps_inf: CustomSpatialDataTypeAnnotated = pd.Field(
         ...,
         title="Epsilon at Infinity",
         description="Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
         units=PERMITTIVITY,
     )
 
-    coeffs: Tuple[Tuple[SpatialDataArray, SpatialDataArray], ...] = pd.Field(
+    coeffs: Tuple[
+        Tuple[CustomSpatialDataTypeAnnotated, CustomSpatialDataTypeAnnotated], ...
+    ] = pd.Field(
         ...,
         title="Coefficients",
         description="List of (:math:`\\Delta\\epsilon_i, \\tau_i`) values for model.",
         units=(PERMITTIVITY, SECOND),
     )
 
     _no_nans_eps_inf = validate_no_nans("eps_inf")
@@ -3993,63 +4166,80 @@
     _warn_if_none = CustomDispersiveMedium._warn_if_data_none("coeffs")
 
     @pd.validator("eps_inf", always=True)
     def _eps_inf_positive(cls, val):
         """eps_inf must be positive"""
         if not CustomDispersiveMedium._validate_isreal_dataarray(val):
             raise SetupError("'eps_inf' must be real.")
-        if np.any(val < 0):
+        if np.any(_get_numpy_array(val) < 0):
             raise SetupError("'eps_inf' must be positive.")
         return val
 
     @pd.validator("coeffs", always=True)
     @skip_if_fields_missing(["eps_inf"])
     def _coeffs_correct_shape(cls, val, values):
         """coeffs must have consistent shape."""
-        expected_coords = values["eps_inf"].coords
         for de, tau in val:
-            if de.coords != expected_coords or tau.coords != expected_coords:
+            if not _check_same_coordinates(de, values["eps_inf"]) or not _check_same_coordinates(
+                tau, values["eps_inf"]
+            ):
                 raise SetupError(
                     "All terms in 'coeffs' must have the same coordinates; "
                     "The coordinates must also be consistent with 'eps_inf'."
                 )
             if not CustomDispersiveMedium._validate_isreal_dataarray_tuple((de, tau)):
                 raise SetupError("All terms in 'coeffs' must be real.")
         return val
 
     @pd.validator("coeffs", always=True)
     @skip_if_fields_missing(["allow_gain"])
     def _passivity_validation(cls, val, values):
         """Assert passive medium if ``allow_gain`` is False."""
         allow_gain = values.get("allow_gain")
         for del_ep, tau in val:
-            if np.any(tau <= 0):
+            if np.any(_get_numpy_array(tau) <= 0):
                 raise SetupError("For stable medium, 'tau_i' must be positive.")
-            if not allow_gain and np.any(del_ep < 0):
+            if not allow_gain and np.any(_get_numpy_array(del_ep) < 0):
                 raise ValidationError(
                     "For passive medium, 'Delta epsilon_i' must be non-negative. "
                     "To simulate a gain medium, please set 'allow_gain=True'. "
                     "Caution: simulations with a gain medium are unstable, "
                     "and are likely to diverge."
                 )
         return val
 
     def eps_dataarray_freq(
         self, frequency: float
-    ) -> Tuple[SpatialDataArray, SpatialDataArray, SpatialDataArray]:
+    ) -> Tuple[CustomSpatialDataType, CustomSpatialDataType, CustomSpatialDataType]:
         """Permittivity array at ``frequency``.
 
         Parameters
         ----------
         frequency : float
             Frequency to evaluate permittivity at (Hz).
 
         Returns
         -------
-        Tuple[:class:`.SpatialDataArray`, :class:`.SpatialDataArray`, :class:`.SpatialDataArray`]
+        Tuple[
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ],
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ],
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ],
+        ]
             The permittivity evaluated at ``frequency``.
         """
         eps = Debye.eps_model(self, frequency)
         return (eps, eps, eps)
 
     def _sel_custom_data_inside(self, bounds: Bound):
         """Return a new custom medium that contains the minimal amount data necessary to cover
@@ -4671,25 +4861,41 @@
             return self.interp_method
         # use component's interp_method
         comp_map = ["xx", "yy", "zz"]
         return self.components[comp_map[comp]].interp_method
 
     def eps_dataarray_freq(
         self, frequency: float
-    ) -> Tuple[SpatialDataArray, SpatialDataArray, SpatialDataArray]:
+    ) -> Tuple[CustomSpatialDataType, CustomSpatialDataType, CustomSpatialDataType]:
         """Permittivity array at ``frequency``.
 
         Parameters
         ----------
         frequency : float
             Frequency to evaluate permittivity at (Hz).
 
         Returns
         -------
-        Tuple[:class:`.SpatialDataArray`, :class:`.SpatialDataArray`, :class:`.SpatialDataArray`]
+        Tuple[
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ],
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ],
+            Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ],
+        ]
             The permittivity evaluated at ``frequency``.
         """
         return tuple(
             mat_component.eps_dataarray_freq(frequency)[ind]
             for ind, mat_component in enumerate(self.components.values())
         )
 
@@ -4760,31 +4966,43 @@
         "If the resulting medium is not a custom medium (no perturbations), this field does not "
         "have an effect.",
     )
 
     @abstractmethod
     def perturbed_copy(
         self,
-        temperature: SpatialDataArray = None,
-        electron_density: SpatialDataArray = None,
-        hole_density: SpatialDataArray = None,
+        temperature: CustomSpatialDataType = None,
+        electron_density: CustomSpatialDataType = None,
+        hole_density: CustomSpatialDataType = None,
         interp_method: InterpMethod = "linear",
     ) -> Union[AbstractMedium, AbstractCustomMedium]:
         """Sample perturbations on provided heat and/or charge data and create a custom medium.
         Any of ``temperature``, ``electron_density``, and ``hole_density`` can be ``None``.
         If all passed arguments are ``None`` then a non-custom medium is returned.
         All provided fields must have identical coords.
 
         Parameters
         ----------
-        temperature : SpatialDataArray = None
+        temperature : Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ] = None
             Temperature field data.
-        electron_density : SpatialDataArray = None
+        electron_density : Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ] = None
             Electron density field data.
-        hole_density : SpatialDataArray = None
+        hole_density : Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ] = None
             Hole density field data.
         interp_method : :class:`.InterpMethod`, optional
             Interpolation method to obtain heat and/or charge values that are not supplied
             at the Yee grids.
 
         Returns
         -------
@@ -4836,31 +5054,43 @@
         allowed_real_range=[(0.0, None)],
         allowed_imag_range=[None],
         allowed_complex=False,
     )
 
     def perturbed_copy(
         self,
-        temperature: SpatialDataArray = None,
-        electron_density: SpatialDataArray = None,
-        hole_density: SpatialDataArray = None,
+        temperature: CustomSpatialDataType = None,
+        electron_density: CustomSpatialDataType = None,
+        hole_density: CustomSpatialDataType = None,
         interp_method: InterpMethod = "linear",
     ) -> Union[Medium, CustomMedium]:
         """Sample perturbations on provided heat and/or charge data and return 'CustomMedium'.
         Any of temperature, electron_density, and hole_density can be 'None'. If all passed
         arguments are 'None' then a 'Medium' object is returned. All provided fields must have
         identical coords.
 
         Parameters
         ----------
-        temperature : SpatialDataArray = None
+        temperature : Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ] = None
             Temperature field data.
-        electron_density : SpatialDataArray = None
+        electron_density : Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ] = None
             Electron density field data.
-        hole_density : SpatialDataArray = None
+        hole_density : Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ] = None
             Hole density field data.
         interp_method : :class:`.InterpMethod`, optional
             Interpolation method to obtain heat and/or charge values that are not supplied
             at the Yee grids.
 
         Returns
         -------
@@ -4881,15 +5111,15 @@
             return Medium.parse_obj(new_dict)
 
         permittivity_field = self.permittivity + ParameterPerturbation._zeros_like(
             temperature, electron_density, hole_density
         )
 
         if self.permittivity_perturbation is not None:
-            permittivity_field += self.permittivity_perturbation.apply_data(
+            permittivity_field = permittivity_field + self.permittivity_perturbation.apply_data(
                 temperature, electron_density, hole_density
             )
 
         conductivity_field = None
         if self.conductivity_perturbation is not None:
             conductivity_field = self.conductivity + self.conductivity_perturbation.apply_data(
                 temperature, electron_density, hole_density
@@ -4958,31 +5188,43 @@
         "poles",
         allowed_real_range=[(None, 0.0), (None, None)],
         allowed_imag_range=[None, None],
     )
 
     def perturbed_copy(
         self,
-        temperature: SpatialDataArray = None,
-        electron_density: SpatialDataArray = None,
-        hole_density: SpatialDataArray = None,
+        temperature: CustomSpatialDataType = None,
+        electron_density: CustomSpatialDataType = None,
+        hole_density: CustomSpatialDataType = None,
         interp_method: InterpMethod = "linear",
     ) -> Union[PoleResidue, CustomPoleResidue]:
         """Sample perturbations on provided heat and/or charge data and return 'CustomPoleResidue'.
         Any of temperature, electron_density, and hole_density can be 'None'. If all passed
         arguments are 'None' then a 'PoleResidue' object is returned. All provided fields must have
         identical coords.
 
         Parameters
         ----------
-        temperature : SpatialDataArray = None
+        temperature : Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ] = None
             Temperature field data.
-        electron_density : SpatialDataArray = None
+        electron_density : Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ] = None
             Electron density field data.
-        hole_density : SpatialDataArray = None
+        hole_density : Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ] = None
             Hole density field data.
         interp_method : :class:`.InterpMethod`, optional
             Interpolation method to obtain heat and/or charge values that are not supplied
             at the Yee grids.
 
         Returns
         -------
@@ -4998,25 +5240,29 @@
 
         zeros = ParameterPerturbation._zeros_like(temperature, electron_density, hole_density)
 
         # sample eps_inf
         eps_inf_field = self.eps_inf + zeros
 
         if self.eps_inf_perturbation is not None:
-            eps_inf_field += self.eps_inf_perturbation.apply_data(
+            eps_inf_field = eps_inf_field + self.eps_inf_perturbation.apply_data(
                 temperature, electron_density, hole_density
             )
 
         # sample poles
         poles_field = [[a + zeros, c + zeros] for a, c in self.poles]
         for (a_perturb, c_perturb), (a_field, c_field) in zip(self.poles_perturbation, poles_field):
             if a_perturb is not None:
-                a_field += a_perturb.apply_data(temperature, electron_density, hole_density)
+                a_field = a_field + a_perturb.apply_data(
+                    temperature, electron_density, hole_density
+                )
             if c_perturb is not None:
-                c_field += c_perturb.apply_data(temperature, electron_density, hole_density)
+                c_field = c_field + c_perturb.apply_data(
+                    temperature, electron_density, hole_density
+                )
 
         new_dict["eps_inf"] = eps_inf_field
         new_dict["poles"] = poles_field
         new_dict["interp_method"] = interp_method
 
         return CustomPoleResidue.parse_obj(new_dict)
```

### Comparing `tidy3d-2.6.4/tidy3d/components/mode.py` & `tidy3d-2.7.0rc1/tidy3d/components/mode.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/parameter_perturbation.py` & `tidy3d-2.7.0rc1/tidy3d/components/parameter_perturbation.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,24 +3,26 @@
 
 from abc import ABC, abstractmethod
 from typing import Callable, Union, Tuple, List
 import functools
 
 import pydantic.v1 as pd
 import numpy as np
-import xarray as xr
 import matplotlib.pyplot as plt
 
-from .data.data_array import SpatialDataArray, HeatDataArray, ChargeDataArray
+from .data.data_array import SpatialDataArray, HeatDataArray, ChargeDataArray, IndexedDataArray
+from .data.dataset import UnstructuredGridDataset, CustomSpatialDataType
+from .data.dataset import _get_numpy_array, _zeros_like, _check_same_coordinates
 from .base import Tidy3dBaseModel, cached_property
 from ..constants import KELVIN, CMCUBE, PERCMCUBE, inf
 from ..log import log
 from ..components.types import Ax, ArrayLike, Complex, FieldVal, InterpMethod, TYPE_TAG_STR
 from ..components.viz import add_ax_if_none
 from ..components.data.validators import validate_no_nans
+from ..exceptions import DataError
 
 """ Generic perturbation classes """
 
 
 class AbstractPerturbation(ABC, Tidy3dBaseModel):
     """Abstract class for a generic perturbation."""
 
@@ -39,16 +41,16 @@
         """Find value range for a linear perturbation."""
         if coeff in (0, 0j):  # to avoid 0*inf
             return np.array([0, 0])
         return tuple(np.sort(coeff * (np.array(interval) - ref)))
 
     @staticmethod
     def _get_val(
-        field: Union[ArrayLike[float], ArrayLike[Complex], SpatialDataArray], val: FieldVal
-    ) -> Union[ArrayLike[float], ArrayLike[Complex], SpatialDataArray]:
+        field: Union[ArrayLike[float], ArrayLike[Complex], CustomSpatialDataType], val: FieldVal
+    ) -> Union[ArrayLike[float], ArrayLike[Complex], CustomSpatialDataType]:
         """Get specified value from a field."""
 
         if val == "real":
             return np.real(field)
 
         if val == "imag":
             return np.imag(field)
@@ -63,49 +65,40 @@
             return np.arctan2(np.real(field), np.imag(field))
 
         raise ValueError(
             "Unknown 'val' key. Argument 'val' can take values 'real', 'imag', 'abs', "
             "'abs^2', or 'phase'."
         )
 
-    @staticmethod
-    def _array_type(value: Union[ArrayLike[float], ArrayLike[Complex], SpatialDataArray]) -> str:
-        """Check whether variable is scalar, array, or spatial array."""
-        if isinstance(value, SpatialDataArray):
-            return "spatial"
-        if np.ndim(value) == 0:
-            return "scalar"
-        return "array"
-
 
 """ Elementary heat perturbation classes """
 
 
 def ensure_temp_in_range(
     sample: Callable[
-        Union[ArrayLike[float], SpatialDataArray],
-        Union[ArrayLike[float], ArrayLike[Complex], SpatialDataArray],
+        Union[ArrayLike[float], CustomSpatialDataType],
+        Union[ArrayLike[float], ArrayLike[Complex], CustomSpatialDataType],
     ]
 ) -> Callable[
-    Union[ArrayLike[float], SpatialDataArray],
-    Union[ArrayLike[float], ArrayLike[Complex], SpatialDataArray],
+    Union[ArrayLike[float], CustomSpatialDataType],
+    Union[ArrayLike[float], ArrayLike[Complex], CustomSpatialDataType],
 ]:
     """Decorate ``sample`` to log warning if temperature supplied is out of bounds."""
 
     @functools.wraps(sample)
     def _sample(
-        self, temperature: Union[ArrayLike[float], SpatialDataArray]
-    ) -> Union[ArrayLike[float], ArrayLike[Complex], SpatialDataArray]:
+        self, temperature: Union[ArrayLike[float], CustomSpatialDataType]
+    ) -> Union[ArrayLike[float], ArrayLike[Complex], CustomSpatialDataType]:
         """New sample function."""
 
         if np.iscomplexobj(temperature):
-            raise ValueError("Cannot pass complex 'temperature' to 'sample()'")
+            raise DataError("Cannot pass complex 'temperature' to 'sample()'")
 
         temp_min, temp_max = self.temperature_range
-        temperature_numpy = np.array(temperature)
+        temperature_numpy = _get_numpy_array(temperature)
         if np.any(temperature_numpy < temp_min) or np.any(temperature_numpy > temp_max):
             log.warning(
                 "Temperature passed to 'HeatPerturbation.sample()'"
                 f"is outside of 'HeatPerturbation.temperature_range' = {self.temperature_range}"
             )
         return sample(self, temperature)
 
@@ -120,26 +113,37 @@
         title="Temperature range",
         description="Temperature range in which perturbation model is valid.",
         units=KELVIN,
     )
 
     @abstractmethod
     def sample(
-        self, temperature: Union[ArrayLike[float], SpatialDataArray]
-    ) -> Union[ArrayLike[float], ArrayLike[Complex], SpatialDataArray]:
+        self, temperature: Union[ArrayLike[float], CustomSpatialDataType]
+    ) -> Union[ArrayLike[float], ArrayLike[Complex], CustomSpatialDataType]:
         """Sample perturbation.
 
         Parameters
         ----------
-        temperature : Union[ArrayLike[float], SpatialDataArray]
+        temperature : Union[
+                ArrayLike[float],
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ]
             Temperature sample point(s).
 
         Returns
         -------
-        Union[ArrayLike[float], ArrayLike[Complex], SpatialDataArray]
+        Union[
+            ArrayLike[float],
+            ArrayLike[complex],
+            :class:`.SpatialDataArray`,
+            :class:`.TriangularGridDataset`,
+            :class:`.TetrahedralGridDataset`,
+        ]
             Sampled perturbation value(s).
         """
 
     @add_ax_if_none
     def plot(
         self,
         temperature: ArrayLike[float],
@@ -224,33 +228,45 @@
     @cached_property
     def perturbation_range(self) -> Union[Tuple[float, float], Tuple[Complex, Complex]]:
         """Range of possible perturbation values in the provided ``temperature_range``."""
         return self._linear_range(self.temperature_range, self.temperature_ref, self.coeff)
 
     @ensure_temp_in_range
     def sample(
-        self, temperature: Union[ArrayLike[float], SpatialDataArray]
-    ) -> Union[ArrayLike[float], ArrayLike[Complex], SpatialDataArray]:
+        self, temperature: Union[ArrayLike[float], CustomSpatialDataType]
+    ) -> Union[ArrayLike[float], ArrayLike[Complex], CustomSpatialDataType]:
         """Sample perturbation at temperature points.
 
         Parameters
         ----------
-        temperature : Union[ArrayLike[float], SpatialDataArray]
+        temperature : Union[
+            ArrayLike[float],
+            :class:`.SpatialDataArray`,
+            :class:`.TriangularGridDataset`,
+            :class:`.TetrahedralGridDataset`,
+        ]
             Temperature sample point(s).
 
         Returns
         -------
-        Union[ArrayLike[float], ArrayLike[Complex], SpatialDataArray]
+        Union[
+            ArrayLike[float],
+            ArrayLike[complex],
+            :class:`.SpatialDataArray`,
+            :class:`.TriangularGridDataset`,
+            :class:`.TetrahedralGridDataset`,
+        ]
             Sampled perturbation value(s).
         """
 
-        # convert to numpy if not spatial data array
-        t_vals = np.array(temperature) if self._array_type(temperature) == "array" else temperature
+        temp_vals = temperature
+        if isinstance(temperature, (list, tuple)):
+            temp_vals = np.array(temperature)
 
-        return self.coeff * (t_vals - self.temperature_ref)
+        return self.coeff * (temp_vals - self.temperature_ref)
 
     @cached_property
     def is_complex(self) -> bool:
         """Whether perturbation is complex valued."""
         return np.iscomplex(self.coeff)
 
 
@@ -335,38 +351,57 @@
 
         values.update({"temperature_range": temperature_range})
 
         return values
 
     @ensure_temp_in_range
     def sample(
-        self, temperature: Union[ArrayLike[float], SpatialDataArray]
-    ) -> Union[ArrayLike[float], ArrayLike[Complex], SpatialDataArray]:
+        self, temperature: Union[ArrayLike[float], CustomSpatialDataType]
+    ) -> Union[ArrayLike[float], ArrayLike[Complex], CustomSpatialDataType]:
         """Sample perturbation at provided temperature points.
 
         Parameters
         ----------
-        temperature : Union[ArrayLike[float], SpatialDataArray]
+        temperature : Union[
+                ArrayLike[float],
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ]
             Temperature sample point(s).
 
         Returns
         -------
-        Union[ArrayLike[float], ArrayLike[Complex], SpatialDataArray]
+        Union[
+            ArrayLike[float],
+            ArrayLike[complex],
+            :class:`.SpatialDataArray`,
+            :class:`.TriangularGridDataset`,
+            :class:`.TetrahedralGridDataset`,
+        ]
             Sampled perturbation value(s).
         """
 
         t_range = self.temperature_range
-        temperature_clip = np.clip(temperature, t_range[0], t_range[1])
-        data = self.perturbation_values.interp(T=temperature_clip, method=self.interp_method)
+        temp_clip = np.clip(_get_numpy_array(temperature), t_range[0], t_range[1])
+        sampled = self.perturbation_values.interp(
+            T=temp_clip.ravel(), method=self.interp_method
+        ).values
+        sampled = np.reshape(sampled, np.shape(temp_clip))
+
         # preserve input type
         if isinstance(temperature, SpatialDataArray):
-            return SpatialDataArray(data.drop_vars("T"))
+            return SpatialDataArray(sampled, coords=temperature.coords)
+        if isinstance(temperature, UnstructuredGridDataset):
+            return temperature.updated_copy(
+                values=IndexedDataArray(sampled, coords=temperature.values.coords)
+            )
         if np.ndim(temperature) == 0:
-            return data.item()
-        return data.data
+            return sampled.item()
+        return sampled
 
     @cached_property
     def is_complex(self) -> bool:
         """Whether perturbation is complex valued."""
         return np.iscomplexobj(self.perturbation_values)
 
 
@@ -374,51 +409,57 @@
 
 
 """ Elementary charge perturbation classes """
 
 
 def ensure_charge_in_range(
     sample: Callable[
-        [Union[ArrayLike[float], SpatialDataArray], Union[ArrayLike[float], SpatialDataArray]],
-        Union[ArrayLike[float], ArrayLike[Complex], SpatialDataArray],
+        [
+            Union[ArrayLike[float], CustomSpatialDataType],
+            Union[ArrayLike[float], CustomSpatialDataType],
+        ],
+        Union[ArrayLike[float], ArrayLike[Complex], CustomSpatialDataType],
     ]
 ) -> Callable[
-    [Union[ArrayLike[float], SpatialDataArray], Union[ArrayLike[float], SpatialDataArray]],
-    Union[ArrayLike[float], ArrayLike[Complex], SpatialDataArray],
+    [
+        Union[ArrayLike[float], CustomSpatialDataType],
+        Union[ArrayLike[float], CustomSpatialDataType],
+    ],
+    Union[ArrayLike[float], ArrayLike[Complex], CustomSpatialDataType],
 ]:
     """Decorate ``sample`` to log warning if charge supplied is out of bounds."""
 
     @functools.wraps(sample)
     def _sample(
         self,
-        electron_density: Union[ArrayLike[float], SpatialDataArray],
-        hole_density: Union[ArrayLike[float], SpatialDataArray],
-    ) -> Union[ArrayLike[float], ArrayLike[Complex], SpatialDataArray]:
+        electron_density: Union[ArrayLike[float], CustomSpatialDataType],
+        hole_density: Union[ArrayLike[float], CustomSpatialDataType],
+    ) -> Union[ArrayLike[float], ArrayLike[Complex], CustomSpatialDataType]:
         """New sample function."""
 
         # disable complex input
         if np.iscomplexobj(electron_density):
-            raise ValueError("Cannot pass complex 'electron_density' to 'sample()'")
+            raise DataError("Cannot pass complex 'electron_density' to 'sample()'")
 
         if np.iscomplexobj(hole_density):
-            raise ValueError("Cannot pass complex 'hole_density' to 'sample()'")
+            raise DataError("Cannot pass complex 'hole_density' to 'sample()'")
 
         # check ranges
         e_min, e_max = self.electron_range
 
-        electron_numpy = np.array(electron_density)
+        electron_numpy = _get_numpy_array(electron_density)
         if np.any(electron_numpy < e_min) or np.any(electron_numpy > e_max):
             log.warning(
                 "Electron density values passed to 'ChargePerturbation.sample()'"
                 f"is outside of 'ChargePerturbation.electron_range' = {self.electron_range}"
             )
 
         h_min, h_max = self.hole_range
 
-        hole_numpy = np.array(hole_density)
+        hole_numpy = _get_numpy_array(hole_density)
         if np.any(hole_numpy < h_min) or np.any(hole_numpy > h_max):
             log.warning(
                 "Hole density values passed to 'ChargePerturbation.sample()'"
                 f"is outside of 'ChargePerturbation.hole_range' = {self.hole_range}"
             )
 
         return sample(self, electron_density, hole_density)
@@ -440,35 +481,50 @@
         title="Hole Density Range",
         description="Range of holes densities in which perturbation model is valid.",
     )
 
     @abstractmethod
     def sample(
         self,
-        electron_density: Union[ArrayLike[float], SpatialDataArray],
-        hole_density: Union[ArrayLike[float], SpatialDataArray],
-    ) -> Union[ArrayLike[float], ArrayLike[Complex], SpatialDataArray]:
+        electron_density: Union[ArrayLike[float], CustomSpatialDataType],
+        hole_density: Union[ArrayLike[float], CustomSpatialDataType],
+    ) -> Union[ArrayLike[float], ArrayLike[Complex], CustomSpatialDataType]:
         """Sample perturbation.
 
         Parameters
         ----------
-        electron_density : Union[ArrayLike[float], SpatialDataArray]
+        electron_density : Union[
+                ArrayLike[float],
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ]
             Electron density sample point(s).
-        hole_density : Union[ArrayLike[float], SpatialDataArray]
+        hole_density : Union[
+                ArrayLike[float],
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ]
             Hole density sample point(s).
 
         Note
         ----
-        Cannot provide a :class:`.SpatialDataArray` for one argument and a regular array
-        (``list``, ``tuple``, ``numpy.nd_array``) for the other. Additionally, if both arguments are
-        regular arrays they must be one-dimensional arrays.
+        Provided ``electron_density`` and ``hole_density`` must be of the same type and match
+        shapes/coordinates, unless one of them is a scalar.
 
         Returns
         -------
-        Union[ArrayLike[float], ArrayLike[Complex], SpatialDataArray]
+        Union[
+            ArrayLike[float],
+            ArrayLike[complex],
+            :class:`.SpatialDataArray`,
+            :class:`.TriangularGridDataset`,
+            :class:`.TetrahedralGridDataset`,
+        ]
             Sampled perturbation value(s).
         """
 
     @add_ax_if_none
     def plot(
         self,
         electron_density: ArrayLike[float],
@@ -476,17 +532,17 @@
         val: FieldVal = "real",
         ax: Ax = None,
     ) -> Ax:
         """Plot perturbation using provided electron and hole density sample points.
 
         Parameters
         ----------
-        electron_density : Union[ArrayLike[float], SpatialDataArray]
+        electron_density : Union[ArrayLike[float], CustomSpatialDataType]
             Array of electron density sample points.
-        hole_density : Union[ArrayLike[float], SpatialDataArray]
+        hole_density : Union[ArrayLike[float], CustomSpatialDataType]
             Array of hole density sample points.
         val : Literal['real', 'imag', 'abs', 'abs^2', 'phase'] = 'real'
             Which part of the field to plot.
         ax : matplotlib.axes._subplots.Axes = None
             Matplotlib axes to plot on, if not specified, one is created.
 
         Returns
@@ -522,38 +578,14 @@
             ax.set_ylabel("hole density (1/cm^3)")
 
         ax.set_title(f"charge dependence of {val}(perturbation value)")
         ax.set_aspect("auto")
 
         return ax
 
-    @staticmethod
-    def _get_eh_types(electron_density, hole_density):
-        """Get types of provided arguments and check that no mixing between spatial and regular
-        arrays.
-        """
-        e_type = AbstractPerturbation._array_type(electron_density)
-        h_type = AbstractPerturbation._array_type(hole_density)
-
-        one_array = e_type == "array" or h_type == "array"
-        one_spatial = e_type == "spatial" or h_type == "spatial"
-
-        if one_array and one_spatial:
-            raise ValueError(
-                "Cannot mix 'SpatialDataArray' and regular python arrays for 'electron_density'"
-                "'hole_density'."
-            )
-
-        if e_type == "array" and h_type == "array" and (np.ndim(e_type) > 1 or np.ndim(h_type) > 1):
-            raise ValueError(
-                "Cannot mix multidimensional arrays for 'electron_density' and 'hole_density'."
-            )
-
-        return e_type, h_type
-
 
 class LinearChargePerturbation(ChargePerturbation):
     """Specifies parameter's perturbation due to free carrier effects as a linear function of
     electron and hole densities:
 
     Notes
     -----
@@ -627,48 +659,85 @@
         range_from_h = self._linear_range(self.hole_range, self.hole_ref, self.hole_coeff)
 
         return tuple(np.array(range_from_e) + np.array(range_from_h))
 
     @ensure_charge_in_range
     def sample(
         self,
-        electron_density: Union[ArrayLike[float], SpatialDataArray],
-        hole_density: Union[ArrayLike[float], SpatialDataArray],
-    ) -> Union[ArrayLike[float], ArrayLike[Complex], SpatialDataArray]:
+        electron_density: Union[ArrayLike[float], CustomSpatialDataType],
+        hole_density: Union[ArrayLike[float], CustomSpatialDataType],
+    ) -> Union[ArrayLike[float], ArrayLike[Complex], CustomSpatialDataType]:
         """Sample perturbation at electron and hole density points.
 
         Parameters
         ----------
-        electron_density : Union[ArrayLike[float], SpatialDataArray]
+        electron_density : Union[
+                ArrayLike[float],
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ]
             Electron density sample point(s).
-        hole_density : Union[ArrayLike[float], SpatialDataArray]
+        hole_density : Union[
+                ArrayLike[float],
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ]
             Hole density sample point(s).
 
         Note
         ----
-        Cannot provide a :class:`.SpatialDataArray` for one argument and a regular array
-        (``list``, ``tuple``, ``numpy.nd_array``) for the other. Additionally, if both arguments are
-        regular arrays they must be one-dimensional arrays.
+        Provided ``electron_density`` and ``hole_density`` must be of the same type and match
+        shapes/coordinates, unless one of them is a scalar or both are 1d arrays, in which case
+        values are broadcasted.
 
         Returns
         -------
-        Union[ArrayLike[float], ArrayLike[Complex], SpatialDataArray]
+        Union[
+            ArrayLike[float],
+            ArrayLike[complex],
+            :class:`.SpatialDataArray`,
+            :class:`.TriangularGridDataset`,
+            :class:`.TetrahedralGridDataset`,
+        ]
             Sampled perturbation value(s).
         """
-        e_type, h_type = self._get_eh_types(electron_density, hole_density)
+        inputs = [electron_density, hole_density]
 
-        if e_type == "array" and h_type == "array":
-            e_mesh, h_mesh = np.meshgrid(electron_density, hole_density, indexing="ij")
+        no_scalars = all(np.ndim(_get_numpy_array(arr)) > 0 for arr in inputs)
+        both_1d = all(
+            isinstance(arr, (list, tuple, np.ndarray)) and np.ndim(arr) == 1 for arr in inputs
+        )
 
-            return self.electron_coeff * (e_mesh - self.electron_ref) + self.hole_coeff * (
-                h_mesh - self.hole_ref
+        # we allow combining a scalar with any other type
+        # or 2 1d arrays (broadcasting)
+        # otherwise we require match in shape/coords
+        if (
+            no_scalars
+            and not both_1d
+            and not _check_same_coordinates(electron_density, hole_density)
+        ):
+            raise DataError(
+                "Provided electron and hole density data must be of the same type and shape."
             )
 
-        e_vals = np.array(electron_density) if e_type == "array" else electron_density
-        h_vals = np.array(hole_density) if h_type == "array" else hole_density
+        e_vals = electron_density
+        h_vals = hole_density
+
+        # convert python arrays into numpy
+        if isinstance(electron_density, (list, tuple)):
+            e_vals = np.array(electron_density)
+
+        if isinstance(hole_density, (list, tuple)):
+            h_vals = np.array(hole_density)
+
+        # broadcast if both are 1d arrays
+        if both_1d:
+            e_vals, h_vals = np.meshgrid(e_vals, h_vals, indexing="ij")
 
         return self.electron_coeff * (e_vals - self.electron_ref) + self.hole_coeff * (
             h_vals - self.hole_ref
         )
 
     @cached_property
     def is_complex(self) -> bool:
@@ -779,49 +848,108 @@
         values.update({"electron_range": electron_range, "hole_range": hole_range})
 
         return values
 
     @ensure_charge_in_range
     def sample(
         self,
-        electron_density: Union[ArrayLike[float], SpatialDataArray],
-        hole_density: Union[ArrayLike[float], SpatialDataArray],
-    ) -> Union[ArrayLike[float], ArrayLike[Complex], SpatialDataArray]:
+        electron_density: Union[ArrayLike[float], CustomSpatialDataType],
+        hole_density: Union[ArrayLike[float], CustomSpatialDataType],
+    ) -> Union[ArrayLike[float], ArrayLike[Complex], CustomSpatialDataType]:
         """Sample perturbation at electron and hole density points.
 
         Parameters
         ----------
-        electron_density : Union[ArrayLike[float], SpatialDataArray]
+        electron_density : Union[
+                ArrayLike[float],
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ]
             Electron density sample point(s).
-        hole_density : Union[ArrayLike[float], SpatialDataArray]
+        hole_density : Union[
+                ArrayLike[float],
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ]
             Hole density sample point(s).
 
         Note
         ----
-        Cannot provide a :class:`.SpatialDataArray` for one argument and a regular array
-        (``list``, ``tuple``, ``numpy.nd_array``) for the other. Additionally, if both arguments are
-        regular arrays they must be one-dimensional arrays.
+        Provided ``electron_density`` and ``hole_density`` must be of the same type and match
+        shapes/coordinates, unless one of them is a scalar or both are 1d arrays, in which case
+        values are broadcasted.
 
         Returns
         -------
-        Union[ArrayLike[float], ArrayLike[Complex], SpatialDataArray]
+        Union[
+            ArrayLike[float],
+            ArrayLike[complex],
+            :class:`.SpatialDataArray`,
+            :class:`.TriangularGridDataset`,
+            :class:`.TetrahedralGridDataset`,
+        ]
             Sampled perturbation value(s).
         """
-        e_type, h_type = self._get_eh_types(electron_density, hole_density)
+        inputs = [electron_density, hole_density]
+
+        no_scalars = all(np.ndim(_get_numpy_array(arr)) > 0 for arr in inputs)
+        both_1d = all(
+            isinstance(arr, (list, tuple, np.ndarray)) and np.ndim(_get_numpy_array(arr)) == 1
+            for arr in inputs
+        )
+
+        # we allow combining a scalar with any other type
+        # or 2 1d arrays (broadcasting)
+        # otherwise we require match in shape/coords
+        if (
+            no_scalars
+            and not both_1d
+            and not _check_same_coordinates(electron_density, hole_density)
+        ):
+            raise DataError(
+                "Provided electron and hole density data must be of the same type and shape."
+            )
+
+        # clip to allowed values
+        # (this also implicitly convert python arrays into numpy
+        e_vals = np.core.umath.clip(
+            electron_density, self.electron_range[0], self.electron_range[1]
+        )
+        h_vals = np.core.umath.clip(hole_density, self.hole_range[0], self.hole_range[1])
+
+        # we cannot pass UnstructuredGridDataset directly into xarray interp
+        # thus we need to explicitly grad the underlying xarray
+        if isinstance(e_vals, UnstructuredGridDataset):
+            e_vals = e_vals.values
+        if isinstance(h_vals, UnstructuredGridDataset):
+            h_vals = h_vals.values
+
+        # note that the dimensionality of this operation differs depending on whether xarrays
+        # or simple unlabeled arrays are provided:
+        # - for unlabeled arrays, values are broadcasted
+        # - for xarrays, values are considered pairwise based on xarrays' coords
+        sampled = self.perturbation_values.interp(n=e_vals, p=h_vals, method=self.interp_method)
+
+        # grab the result without any labels
+        sampled = sampled.values
+
+        # preserve input type
+        for arr in inputs:
+            if isinstance(arr, SpatialDataArray):
+                return SpatialDataArray(sampled, coords=arr.coords)
 
-        e_clip = np.clip(electron_density, self.electron_range[0], self.electron_range[1])
-        h_clip = np.clip(hole_density, self.hole_range[0], self.hole_range[1])
+            if isinstance(arr, UnstructuredGridDataset):
+                return arr.updated_copy(values=IndexedDataArray(sampled, coords=arr.values.coords))
 
-        data = self.perturbation_values.interp(n=e_clip, p=h_clip, method=self.interp_method)
+        if all(np.ndim(_get_numpy_array(arr)) == 0 for arr in inputs):
+            return sampled.item()
 
-        if e_type == "scalar" and h_type == "scalar":
-            return data.item()
-        if e_type == "spatial" or h_type == "spatial":
-            return SpatialDataArray(data.drop_vars(["n", "p"]))
-        return data.data
+        return sampled
 
     @cached_property
     def is_complex(self) -> bool:
         """Whether perturbation is complex valued."""
         return np.iscomplexobj(self.perturbation_values)
 
 
@@ -884,59 +1012,75 @@
         for p in self.perturbation_list:
             prange = prange + p.perturbation_range
 
         return tuple(prange)
 
     @staticmethod
     def _zeros_like(
-        T: SpatialDataArray = None,
-        n: SpatialDataArray = None,
-        p: SpatialDataArray = None,
+        T: CustomSpatialDataType = None,
+        n: CustomSpatialDataType = None,
+        p: CustomSpatialDataType = None,
     ):
         """Check that fields have the same coordinates and return an array field with zeros."""
         template = None
         for field in [T, n, p]:
             if field is not None:
-                if template is not None and field.coords != template.coords:
-                    raise ValueError(
+                if template is not None and not _check_same_coordinates(field, template):
+                    raise DataError(
                         "'temperature', 'electron_density', and 'hole_density' must have the same "
                         "coordinates if provided."
                     )
                 template = field
 
         if template is None:
-            raise ValueError(
+            raise DataError(
                 "At least one of 'temperature', 'electron_density', or 'hole_density' must be "
                 "provided."
             )
 
-        return xr.zeros_like(template)
+        return _zeros_like(template)
 
     def apply_data(
         self,
-        temperature: SpatialDataArray = None,
-        electron_density: SpatialDataArray = None,
-        hole_density: SpatialDataArray = None,
-    ) -> SpatialDataArray:
+        temperature: CustomSpatialDataType = None,
+        electron_density: CustomSpatialDataType = None,
+        hole_density: CustomSpatialDataType = None,
+    ) -> CustomSpatialDataType:
         """Sample perturbations on provided heat and/or charge data. At least one of
         ``temperature``, ``electron_density``, and ``hole_density`` must be not ``None``.
         All provided fields must have identical coords.
 
         Parameters
         ----------
-        temperature : SpatialDataArray = None
+        temperature : Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ] = None
             Temperature field data.
-        electron_density : SpatialDataArray = None
+        electron_density : Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ] = None
             Electron density field data.
-        hole_density : SpatialDataArray = None
+        hole_density : Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ] = None
             Hole density field data.
 
         Returns
         -------
-        SpatialDataArray
+        Union[
+            :class:`.SpatialDataArray`,
+            :class:`.TriangularGridDataset`,
+            :class:`.TetrahedralGridDataset`,
+        ] = None
             Sampled perturbation field.
         """
 
         result = self._zeros_like(temperature, electron_density, hole_density)
 
         if temperature is not None and self.heat is not None:
             result = result + self.heat.sample(temperature)
```

### Comparing `tidy3d-2.6.4/tidy3d/components/scene.py` & `tidy3d-2.7.0rc1/tidy3d/components/scene.py`

 * *Files 2% similar despite different names*

```diff
@@ -15,15 +15,16 @@
 from .geometry.utils import flatten_groups, traverse_geometries
 from .types import Ax, Shapely, TYPE_TAG_STR, Bound, Size, Coordinate, InterpMethod
 from .medium import Medium, MediumType
 from .medium import AbstractCustomMedium, Medium2D, MediumType3D
 from .medium import AbstractPerturbationMedium
 from .grid.grid import Grid
 from .structure import Structure
-from .data.data_array import SpatialDataArray
+from .data.dataset import _get_numpy_array, CustomSpatialDataType
+from .data.dataset import UnstructuredGridDataset, TetrahedralGridDataset, TriangularGridDataset
 from .viz import add_ax_if_none, equal_aspect
 from .grid.grid import Coords
 from .heat_spec import SolidSpec
 
 from .viz import MEDIUM_CMAP, STRUCTURE_EPS_CMAP, PlotParams, polygon_path, STRUCTURE_HEAT_COND_CMAP
 from .viz import plot_params_structure, plot_params_fluid
 
@@ -846,19 +847,19 @@
         eps_max = max(eps_list, default=1)
         # custom medium, the min and max in the supplied dataset over all components and
         # spatial locations.
         for mat in [medium for medium in medium_list if isinstance(medium, AbstractCustomMedium)]:
             eps_dataarray = mat.eps_dataarray_freq(freq)
             eps_min = min(
                 eps_min,
-                min(np.min(eps_comp.real.values.ravel()) for eps_comp in eps_dataarray),
+                min(np.min(_get_numpy_array(eps_comp.real).ravel()) for eps_comp in eps_dataarray),
             )
             eps_max = max(
                 eps_max,
-                max(np.max(eps_comp.real.values.ravel()) for eps_comp in eps_dataarray),
+                max(np.max(_get_numpy_array(eps_comp.real).ravel()) for eps_comp in eps_dataarray),
             )
         return eps_min, eps_max
 
     def _pcolormesh_shape_custom_medium_structure_eps(
         self,
         x: float,
         y: float,
@@ -887,17 +888,59 @@
         rmin.insert(normal_axis_ind, normal_position)
         rmax.insert(normal_axis_ind, normal_position)
 
         if grid is None:
             plane_axes_inds = [0, 1, 2]
             plane_axes_inds.pop(normal_axis_ind)
 
+            eps_diag = medium.eps_dataarray_freq(frequency=freq)
+
+            # handle unstructured data case
+            if isinstance(eps_diag[0], UnstructuredGridDataset):
+                if (
+                    isinstance(eps_diag[0], TriangularGridDataset)
+                    and eps_diag[0].normal_axis != normal_axis_ind
+                ):
+                    # if we trying to visualize 2d unstructured data not along its normal direction
+                    # we need to extract line slice that lies in the visualization plane
+                    # note that after this eps_diag[] will be SpatialDataArray's
+                    eps_diag = list(eps_diag)
+                    for dim in range(3):
+                        eps_diag[dim] = eps_diag[dim].plane_slice(
+                            axis=normal_axis_ind, pos=normal_position
+                        )
+                else:
+                    eps_mean = (eps_diag[0] + eps_diag[1] + eps_diag[2]) / 3
+
+                    if isinstance(eps_mean, TetrahedralGridDataset):
+                        # extract slice if volumetric unstructured data
+                        eps_mean = eps_mean.plane_slice(axis=normal_axis_ind, pos=normal_position)
+
+                    if reverse:
+                        eps_mean = eps_min + eps_max - eps_mean
+
+                    # at this point eps_mean is TriangularGridDataset and we just plot it directly
+                    # with applying shape mask
+                    eps_mean.plot(
+                        grid=False,
+                        ax=ax,
+                        cbar=False,
+                        cmap=STRUCTURE_EPS_CMAP,
+                        vmin=eps_min,
+                        vmax=eps_max,
+                        pcolor_kwargs=dict(
+                            clip_path=(polygon_path(shape), ax.transData),
+                            clip_box=ax.bbox,
+                            alpha=alpha,
+                        ),
+                    )
+                    return
+
             # in case when different components of custom medium are defined on different grids
             # we will combine all points along each dimension
-            eps_diag = medium.eps_dataarray_freq(frequency=freq)
             if (
                 eps_diag[0].coords == eps_diag[1].coords
                 and eps_diag[0].coords == eps_diag[2].coords
             ):
                 coords_to_insert = [eps_diag[0].coords]
             else:
                 coords_to_insert = [eps_diag[0].coords, eps_diag[1].coords, eps_diag[2].coords]
@@ -1236,40 +1279,52 @@
         ax = self.box.plot_shape(shape=shape, plot_params=plot_params, ax=ax)
         return ax
 
     """ Misc """
 
     def perturbed_mediums_copy(
         self,
-        temperature: SpatialDataArray = None,
-        electron_density: SpatialDataArray = None,
-        hole_density: SpatialDataArray = None,
+        temperature: CustomSpatialDataType = None,
+        electron_density: CustomSpatialDataType = None,
+        hole_density: CustomSpatialDataType = None,
         interp_method: InterpMethod = "linear",
     ) -> Scene:
         """Return a copy of the scene with heat and/or charge data applied to all mediums
         that have perturbation models specified. That is, such mediums will be replaced with
         spatially dependent custom mediums that reflect perturbation effects. Any of temperature,
         electron_density, and hole_density can be ``None``. All provided fields must have identical
         coords.
 
         Parameters
         ----------
-        temperature : SpatialDataArray = None
+        temperature : Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ] = None
             Temperature field data.
-        electron_density : SpatialDataArray = None
+        electron_density : Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ] = None
             Electron density field data.
-        hole_density : SpatialDataArray = None
+        hole_density : Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ] = None
             Hole density field data.
         interp_method : :class:`.InterpMethod`, optional
             Interpolation method to obtain heat and/or charge values that are not supplied
             at the Yee grids.
 
         Returns
         -------
-        Scene
+        :class:`.Scene`
             Simulation after application of heat and/or charge data.
         """
 
         scene_dict = self.dict()
         structures = self.structures
         array_dict = {
             "temperature": temperature,
```

### Comparing `tidy3d-2.6.4/tidy3d/components/simulation.py` & `tidy3d-2.7.0rc1/tidy3d/components/simulation.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,48 +1,51 @@
 """ Container holding all information about simulation and its components"""
 from __future__ import annotations
 
 from typing import Dict, Tuple, List, Set, Union
+from abc import ABC, abstractmethod
 
 import pydantic.v1 as pydantic
 import numpy as np
 import xarray as xr
 import matplotlib as mpl
 import math
+import pathlib
 
 from .base import cached_property
 from .base import skip_if_fields_missing
 from .validators import assert_objects_in_sim_bounds
 from .validators import validate_mode_objects_symmetry
 from .geometry.base import Geometry, Box
 from .geometry.mesh import TriangleMesh
 from .geometry.utils import flatten_groups, traverse_geometries
-from .geometry.utils_2d import get_bounds, set_bounds, get_thickened_geom, subdivide
+from .geometry.utils_2d import get_bounds, increment_float, set_bounds, get_thickened_geom
+from .geometry.utils_2d import subdivide, snap_coordinate_to_grid
 from .types import Ax, FreqBound, Axis, annotate_type, InterpMethod, Symmetry
 from .types import Literal, TYPE_TAG_STR
 from .grid.grid import Coords1D, Grid, Coords
 from .grid.grid_spec import GridSpec, UniformGrid, AutoGrid, CustomGrid
+from .grid.grid_spec import ConformalMeshSpecType, StaircasingConformalMeshSpec
 from .medium import MediumType, AbstractMedium
-from .medium import AbstractCustomMedium, Medium2D
+from .medium import AbstractCustomMedium, Medium, Medium2D, MediumType3D
 from .medium import AnisotropicMedium, FullyAnisotropicMedium, AbstractPerturbationMedium
 from .boundary import BoundarySpec, BlochBoundary, PECBoundary, PMCBoundary, Periodic, Boundary
 from .boundary import PML, StablePML, Absorber, AbsorberSpec
-from .structure import Structure
+from .structure import Structure, MeshOverrideStructure
 from .source import SourceType, PlaneWave, GaussianBeam, AstigmaticGaussianBeam, CustomFieldSource
 from .source import CustomCurrentSource, CustomSourceTime, ContinuousWave
 from .source import TFSF, Source, ModeSource
-from .medium import Medium, MediumType3D
 from .monitor import MonitorType, Monitor, FreqMonitor, SurfaceIntegrationMonitor
-from .monitor import AbstractModeMonitor, FieldMonitor, TimeMonitor
+from .monitor import AbstractModeMonitor, FieldMonitor, TimeMonitor, FieldTimeMonitor
 from .monitor import PermittivityMonitor, DiffractionMonitor, AbstractFieldProjectionMonitor
 from .monitor import FieldProjectionAngleMonitor, FieldProjectionKSpaceMonitor
-from .data.dataset import Dataset
-from .data.data_array import SpatialDataArray
+from .lumped_element import LumpedElementType, LumpedResistor
+from .data.dataset import Dataset, CustomSpatialDataType
 from .viz import add_ax_if_none, equal_aspect
-from .scene import Scene
+from .scene import Scene, MAX_NUM_MEDIUMS
 
 from .viz import PlotParams
 from .viz import plot_params_pml, plot_params_override_structures
 from .viz import plot_params_pec, plot_params_pmc, plot_params_bloch, plot_sim_3d
 
 from ..constants import C_0, SECOND, fp_eps, inf
 from ..exceptions import SetupError, ValidationError, Tidy3dError, Tidy3dImportError
@@ -65,34 +68,1238 @@
 
 # minimum number of grid points allowed per central wavelength in a medium
 MIN_GRIDS_PER_WVL = 6.0
 
 # maximum number of sources
 MAX_NUM_SOURCES = 1000
 
-# maximum numbers of simulation parameters
+# restrictions on simulation number of cells and number of time steps
 MAX_TIME_STEPS = 1e7
 WARN_TIME_STEPS = 1e6
 MAX_GRID_CELLS = 20e9
 MAX_CELLS_TIMES_STEPS = 1e16
+
+# monitor warnings and restrictions
+MAX_TIME_MONITOR_STEPS = 5000  # does not apply to 0D monitors
 WARN_MONITOR_DATA_SIZE_GB = 10
 MAX_MONITOR_INTERNAL_DATA_SIZE_GB = 50
 MAX_SIMULATION_DATA_SIZE_GB = 50
 WARN_MODE_NUM_CELLS = 1e5
 
 # number of grid cells at which we warn about slow Simulation.epsilon()
 NUM_CELLS_WARN_EPSILON = 100_000_000
 # number of structures at which we warn about slow Simulation.epsilon()
 NUM_STRUCTURES_WARN_EPSILON = 10_000
 
 # height of the PML plotting boxes along any dimensions where sim.size[dim] == 0
 PML_HEIGHT_FOR_0_DIMS = 0.02
 
 
-class Simulation(AbstractSimulation):
+class AbstractYeeGridSimulation(AbstractSimulation, ABC):
+    """
+    Abstract class for a simulation involving electromagnetic fields defined on a Yee grid.
+    """
+
+    lumped_elements: Tuple[LumpedElementType, ...] = pydantic.Field(
+        (),
+        title="Lumped Elements",
+        description="Tuple of lumped elements in the simulation. "
+        "Note: only :class:`tidy3d.LumpedResistor` is supported currently.",
+    )
+    """
+    Tuple of lumped elements in the simulation.
+    """
+
+    grid_spec: GridSpec = pydantic.Field(
+        GridSpec(),
+        title="Grid Specification",
+        description="Specifications for the simulation grid along each of the three directions.",
+    )
+    """
+    Specifications for the simulation grid along each of the three directions.
+
+    Example
+    -------
+    Simple application reference:
+
+    .. code-block:: python
+
+         Simulation(
+            ...
+             grid_spec=GridSpec(
+                grid_x = AutoGrid(min_steps_per_wvl = 20),
+                grid_y = AutoGrid(min_steps_per_wvl = 20),
+                grid_z = AutoGrid(min_steps_per_wvl = 20)
+            ),
+            ...
+         )
+
+    See Also
+    --------
+
+    :class:`GridSpec`
+        Collective grid specification for all three dimensions.
+
+    :class:`UniformGrid`
+        Uniform 1D grid.
+
+    :class:`AutoGrid`
+        Specification for non-uniform grid along a given dimension.
+
+    **Notebooks:**
+        * `Using automatic nonuniform meshing <../../notebooks/AutoGrid.html>`_
+    """
+
+    subpixel: bool = pydantic.Field(
+        True,
+        title="Subpixel Averaging",
+        description="If ``True``, uses subpixel averaging of the permittivity "
+        "based on structure definition, resulting in much higher accuracy for a given grid size.",
+    )
+    """
+    If ``True``, uses subpixel averaging of the permittivity based on structure definition, resulting in much
+    higher accuracy for a given grid size.,
+
+    **1D Illustration**
+
+    For example, in the image below, two silicon slabs with thicknesses 150nm and 175nm centered in a grid with
+    spatial discretization :math:`\\Delta z = 25\\text{nm}` compute the effective permittivity of each grid point as the
+    average permittivity between the grid points. A simplified equation based on the ratio :math:`\\eta` between the
+    permittivity of the two materials at the interface in this case:
+
+    .. math::
+
+        \\epsilon_{eff} = \\eta \\epsilon_{si} + (1 - \\eta) \\epsilon_{air}
+
+    .. TODO check the actual implementation to be accurate here.
+
+    .. image:: ../../_static/img/subpixel_permittivity_1d.png
+
+    However, in this 1D case, this averaging is accurate because the dominant electric field is parallel to the
+    dielectric grid points.
+
+    You can learn more about the subpixel averaging derivation from Maxwell's equations in 1D in this lecture:
+    `Introduction to subpixel averaging <https://www.flexcompute.com/fdtd101/Lecture-10-Introduction-to-subpixel
+    -averaging/>`_.
+
+    **2D & 3D Usage Caveats**
+
+    *   In 2D, the subpixel averaging implementation depends on the polarization (:math:`s` or :math:`p`)  of the
+        incident electric field on the interface.
+
+    *   In 3D, the subpixel averaging is implemented with tensorial averaging due to arbitrary surface and field
+        spatial orientations.
+
+
+    See Also
+    --------
+
+    **Lectures:**
+        *  `Introduction to subpixel averaging <https://www.flexcompute.com/fdtd101/Lecture-10-Introduction-to-subpixel-averaging/>`_
+        *  `Dielectric constant assignment on Yee grids <https://www.flexcompute.com/fdtd101/Lecture-9-Dielectric-constant-assignment-on-Yee-grids/>`_
+    """
+
+    @pydantic.validator("lumped_elements", always=True)
+    @skip_if_fields_missing(["structures"])
+    def _validate_num_lumped_elements(cls, val, values):
+        """Error if too many lumped elements present."""
+
+        if val is None:
+            return val
+        structures = values.get("structures")
+        mediums = {structure.medium for structure in structures}
+        total_num_mediums = len(val) + len(mediums)
+        if total_num_mediums > MAX_NUM_MEDIUMS:
+            raise ValidationError(
+                f"Tidy3D only supports {MAX_NUM_MEDIUMS} distinct lumped elements and structures."
+                f"{total_num_mediums} were supplied."
+            )
+
+        return val
+
+    @pydantic.validator("lumped_elements")
+    @skip_if_fields_missing(["size"])
+    def _check_3d_simulation_with_lumped_elements(cls, val, values):
+        """Error if Simulation contained lumped elements and is not a 3D simulation"""
+        size = values.get("size")
+        if val and size.count(0.0) > 0:
+            raise ValidationError(
+                f"'{cls.__name__}' must be a 3D simulation when a 'LumpedElement' is present."
+            )
+        return val
+
+    @pydantic.validator("grid_spec", always=True)
+    @abstractmethod
+    def _validate_auto_grid_wavelength(cls, val, values):
+        """Check that wavelength can be defined if there is auto grid spec."""
+        pass
+
+    def _monitor_num_cells(self, monitor: Monitor) -> int:
+        """Total number of cells included in monitor based on simulation grid."""
+
+        def num_cells_in_monitor(monitor: Monitor) -> int:
+            """Get the number of measurement cells in a monitor given the simulation grid and
+            downsampling."""
+            if not self.intersects(monitor):
+                # Monitor is outside of simulation domain; can happen e.g. for integration surfaces
+                return 0
+            num_cells = self.discretize_monitor(monitor).num_cells
+            # take monitor downsampling into account
+            num_cells = monitor.downsampled_num_cells(num_cells)
+            return np.prod(np.array(num_cells, dtype=np.int64))
+
+        if isinstance(monitor, SurfaceIntegrationMonitor):
+            return sum(num_cells_in_monitor(mnt) for mnt in monitor.integration_surfaces)
+        return num_cells_in_monitor(monitor)
+
+    @equal_aspect
+    @add_ax_if_none
+    def plot(
+        self,
+        x: float = None,
+        y: float = None,
+        z: float = None,
+        ax: Ax = None,
+        source_alpha: float = None,
+        monitor_alpha: float = None,
+        lumped_element_alpha: float = None,
+        hlim: Tuple[float, float] = None,
+        vlim: Tuple[float, float] = None,
+        **patch_kwargs,
+    ) -> Ax:
+        """Plot each of simulation's components on a plane defined by one nonzero x,y,z coordinate.
+
+        Parameters
+        ----------
+        x : float = None
+            position of plane in x direction, only one of x, y, z must be specified to define plane.
+        y : float = None
+            position of plane in y direction, only one of x, y, z must be specified to define plane.
+        z : float = None
+            position of plane in z direction, only one of x, y, z must be specified to define plane.
+        source_alpha : float = None
+            Opacity of the sources. If ``None``, uses Tidy3d default.
+        monitor_alpha : float = None
+            Opacity of the monitors. If ``None``, uses Tidy3d default.
+        lumped_element_alpha : float = None
+            Opacity of the lumped elements. If ``None``, uses Tidy3d default.
+        ax : matplotlib.axes._subplots.Axes = None
+            Matplotlib axes to plot on, if not specified, one is created.
+        hlim : Tuple[float, float] = None
+            The x range if plotting on xy or xz planes, y range if plotting on yz plane.
+        vlim : Tuple[float, float] = None
+            The z range if plotting on xz or yz planes, y plane if plotting on xy plane.
+
+        Returns
+        -------
+        matplotlib.axes._subplots.Axes
+            The supplied or created matplotlib axes.
+
+        See Also
+        ---------
+
+        **Notebooks**
+            * `Visualizing geometries in Tidy3D: Plotting Materials <../../notebooks/VizSimulation.html#Plotting-Materials>`_
+
+        """
+        hlim, vlim = Scene._get_plot_lims(
+            bounds=self.simulation_bounds, x=x, y=y, z=z, hlim=hlim, vlim=vlim
+        )
+
+        ax = self.plot_structures(ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim)
+        ax = self.plot_sources(ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim, alpha=source_alpha)
+        ax = self.plot_monitors(ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim, alpha=monitor_alpha)
+        ax = self.plot_lumped_elements(
+            ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim, alpha=lumped_element_alpha
+        )
+        ax = self.plot_symmetries(ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim)
+        ax = self.plot_pml(ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim)
+        ax = Scene._set_plot_bounds(
+            bounds=self.simulation_bounds, ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim
+        )
+        ax = self.plot_boundaries(ax=ax, x=x, y=y, z=z)
+        return ax
+
+    @equal_aspect
+    @add_ax_if_none
+    def plot_eps(
+        self,
+        x: float = None,
+        y: float = None,
+        z: float = None,
+        freq: float = None,
+        alpha: float = None,
+        source_alpha: float = None,
+        monitor_alpha: float = None,
+        lumped_element_alpha: float = None,
+        hlim: Tuple[float, float] = None,
+        vlim: Tuple[float, float] = None,
+        ax: Ax = None,
+    ) -> Ax:
+        """Plot each of simulation's components on a plane defined by one nonzero x,y,z coordinate.
+        The permittivity is plotted in grayscale based on its value at the specified frequency.
+
+        Parameters
+        ----------
+        x : float = None
+            position of plane in x direction, only one of x, y, z must be specified to define plane.
+        y : float = None
+            position of plane in y direction, only one of x, y, z must be specified to define plane.
+        z : float = None
+            position of plane in z direction, only one of x, y, z must be specified to define plane.
+        freq : float = None
+            Frequency to evaluate the relative permittivity of all mediums.
+            If not specified, evaluates at infinite frequency.
+        alpha : float = None
+            Opacity of the structures being plotted.
+            Defaults to the structure default alpha.
+        source_alpha : float = None
+            Opacity of the sources. If ``None``, uses Tidy3d default.
+        monitor_alpha : float = None
+            Opacity of the monitors. If ``None``, uses Tidy3d default.
+        lumped_element_alpha : float = None
+            Opacity of the lumped elements. If ``None``, uses Tidy3d default.
+        ax : matplotlib.axes._subplots.Axes = None
+            Matplotlib axes to plot on, if not specified, one is created.
+        hlim : Tuple[float, float] = None
+            The x range if plotting on xy or xz planes, y range if plotting on yz plane.
+        vlim : Tuple[float, float] = None
+            The z range if plotting on xz or yz planes, y plane if plotting on xy plane.
+
+        Returns
+        -------
+        matplotlib.axes._subplots.Axes
+            The supplied or created matplotlib axes.
+
+        See Also
+        ---------
+
+        **Notebooks**
+            * `Visualizing geometries in Tidy3D: Plotting Permittivity <../../notebooks/VizSimulation.html#Plotting-Permittivity>`_
+        """
+
+        hlim, vlim = Scene._get_plot_lims(
+            bounds=self.simulation_bounds, x=x, y=y, z=z, hlim=hlim, vlim=vlim
+        )
+
+        ax = self.plot_structures_eps(
+            freq=freq,
+            cbar=True,
+            alpha=alpha,
+            ax=ax,
+            x=x,
+            y=y,
+            z=z,
+            hlim=hlim,
+            vlim=vlim,
+        )
+        ax = self.plot_sources(ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim, alpha=source_alpha)
+        ax = self.plot_monitors(ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim, alpha=monitor_alpha)
+        ax = self.plot_lumped_elements(
+            ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim, alpha=lumped_element_alpha
+        )
+        ax = self.plot_symmetries(ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim)
+        ax = self.plot_pml(ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim)
+        ax = Scene._set_plot_bounds(
+            bounds=self.simulation_bounds, ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim
+        )
+        ax = self.plot_boundaries(ax=ax, x=x, y=y, z=z)
+        return ax
+
+    @equal_aspect
+    @add_ax_if_none
+    def plot_structures_eps(
+        self,
+        x: float = None,
+        y: float = None,
+        z: float = None,
+        freq: float = None,
+        alpha: float = None,
+        cbar: bool = True,
+        reverse: bool = False,
+        ax: Ax = None,
+        hlim: Tuple[float, float] = None,
+        vlim: Tuple[float, float] = None,
+    ) -> Ax:
+        """Plot each of simulation's structures on a plane defined by one nonzero x,y,z coordinate.
+        The permittivity is plotted in grayscale based on its value at the specified frequency.
+
+        Parameters
+        ----------
+        x : float = None
+            position of plane in x direction, only one of x, y, z must be specified to define plane.
+        y : float = None
+            position of plane in y direction, only one of x, y, z must be specified to define plane.
+        z : float = None
+            position of plane in z direction, only one of x, y, z must be specified to define plane.
+        freq : float = None
+            Frequency to evaluate the relative permittivity of all mediums.
+            If not specified, evaluates at infinite frequency.
+        reverse : bool = False
+            If ``False``, the highest permittivity is plotted in black.
+            If ``True``, it is plotteed in white (suitable for black backgrounds).
+        cbar : bool = True
+            Whether to plot a colorbar for the relative permittivity.
+        alpha : float = None
+            Opacity of the structures being plotted.
+            Defaults to the structure default alpha.
+        ax : matplotlib.axes._subplots.Axes = None
+            Matplotlib axes to plot on, if not specified, one is created.
+        hlim : Tuple[float, float] = None
+            The x range if plotting on xy or xz planes, y range if plotting on yz plane.
+        vlim : Tuple[float, float] = None
+            The z range if plotting on xz or yz planes, y plane if plotting on xy plane.
+
+        Returns
+        -------
+        matplotlib.axes._subplots.Axes
+            The supplied or created matplotlib axes.
+        """
+
+        hlim, vlim = Scene._get_plot_lims(
+            bounds=self.simulation_bounds, x=x, y=y, z=z, hlim=hlim, vlim=vlim
+        )
+
+        return self.scene.plot_structures_eps(
+            freq=freq,
+            cbar=cbar,
+            alpha=alpha,
+            ax=ax,
+            x=x,
+            y=y,
+            z=z,
+            hlim=hlim,
+            vlim=vlim,
+            grid=self.grid,
+            reverse=reverse,
+        )
+
+    @equal_aspect
+    @add_ax_if_none
+    def plot_pml(
+        self,
+        x: float = None,
+        y: float = None,
+        z: float = None,
+        hlim: Tuple[float, float] = None,
+        vlim: Tuple[float, float] = None,
+        ax: Ax = None,
+    ) -> Ax:
+        """Plot each of simulation's absorbing boundaries
+        on a plane defined by one nonzero x,y,z coordinate.
+
+        Parameters
+        ----------
+        x : float = None
+            position of plane in x direction, only one of x, y, z must be specified to define plane.
+        y : float = None
+            position of plane in y direction, only one of x, y, z must be specified to define plane.
+        z : float = None
+            position of plane in z direction, only one of x, y, z must be specified to define plane
+        hlim : Tuple[float, float] = None
+            The x range if plotting on xy or xz planes, y range if plotting on yz plane.
+        vlim : Tuple[float, float] = None
+            The z range if plotting on xz or yz planes, y plane if plotting on xy plane.
+        ax : matplotlib.axes._subplots.Axes = None
+            Matplotlib axes to plot on, if not specified, one is created.
+
+        Returns
+        -------
+        matplotlib.axes._subplots.Axes
+            The supplied or created matplotlib axes.
+        """
+        normal_axis, _ = self.parse_xyz_kwargs(x=x, y=y, z=z)
+        pml_boxes = self._make_pml_boxes(normal_axis=normal_axis)
+        for pml_box in pml_boxes:
+            pml_box.plot(x=x, y=y, z=z, ax=ax, **plot_params_pml.to_kwargs())
+        ax = Scene._set_plot_bounds(
+            bounds=self.simulation_bounds, ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim
+        )
+        return ax
+
+    # candidate for removal in 3.0
+    @cached_property
+    def bounds_pml(self) -> Tuple[Tuple[float, float, float], Tuple[float, float, float]]:
+        """Simulation bounds including the PML regions."""
+        log.warning(
+            "'Simulation.bounds_pml' will be removed in Tidy3D 3.0. "
+            "Use 'Simulation.simulation_bounds' instead."
+        )
+        return self.simulation_bounds
+
+    @cached_property
+    def simulation_bounds(self) -> Tuple[Tuple[float, float, float], Tuple[float, float, float]]:
+        """Simulation bounds including the PML regions."""
+        pml_thick = self.pml_thicknesses
+        bounds_in = self.bounds
+        bounds_min = tuple((bmin - pml[0] for bmin, pml in zip(bounds_in[0], pml_thick)))
+        bounds_max = tuple((bmax + pml[1] for bmax, pml in zip(bounds_in[1], pml_thick)))
+
+        return (bounds_min, bounds_max)
+
+    def _make_pml_boxes(self, normal_axis: Axis) -> List[Box]:
+        """make a list of Box objects representing the pml to plot on plane."""
+        pml_boxes = []
+        pml_thicks = self.pml_thicknesses
+        for pml_axis, num_layers_dim in enumerate(self.num_pml_layers):
+            if pml_axis == normal_axis:
+                continue
+            for sign, pml_height, num_layers in zip((-1, 1), pml_thicks[pml_axis], num_layers_dim):
+                if num_layers == 0:
+                    continue
+                pml_box = self._make_pml_box(pml_axis=pml_axis, pml_height=pml_height, sign=sign)
+                pml_boxes.append(pml_box)
+        return pml_boxes
+
+    def _make_pml_box(self, pml_axis: Axis, pml_height: float, sign: int) -> Box:
+        """Construct a :class:`.Box` representing an arborbing boundary to be plotted."""
+        rmin, rmax = (list(bounds) for bounds in self.simulation_bounds)
+        if sign == -1:
+            rmax[pml_axis] = rmin[pml_axis] + pml_height
+        else:
+            rmin[pml_axis] = rmax[pml_axis] - pml_height
+        pml_box = Box.from_bounds(rmin=rmin, rmax=rmax)
+
+        # if any dimension of the sim has size 0, set the PML to a very small size along that dim
+        new_size = list(pml_box.size)
+        for dim_index, sim_size in enumerate(self.size):
+            if sim_size == 0.0:
+                new_size[dim_index] = PML_HEIGHT_FOR_0_DIMS
+        pml_box = pml_box.updated_copy(size=new_size)
+
+        return pml_box
+
+    # candidate for removal in 3.0
+    def eps_bounds(self, freq: float = None) -> Tuple[float, float]:
+        """Compute range of (real) permittivity present in the simulation at frequency "freq"."""
+
+        log.warning(
+            "'Simulation.eps_bounds()' will be removed in Tidy3D 3.0. "
+            "Use 'Simulation.scene.eps_bounds()' instead."
+        )
+        return self.scene.eps_bounds(freq=freq)
+
+    @cached_property
+    def pml_thicknesses(self) -> List[Tuple[float, float]]:
+        """Thicknesses (um) of absorbers in all three axes and directions (-, +)
+
+        Returns
+        -------
+        List[Tuple[float, float]]
+            List containing the absorber thickness (micron) in - and + boundaries.
+        """
+        num_layers = self.num_pml_layers
+        pml_thicknesses = []
+        for num_layer, boundaries in zip(num_layers, self.grid.boundaries.to_list):
+            thick_l = boundaries[num_layer[0]] - boundaries[0]
+            thick_r = boundaries[-1] - boundaries[-1 - num_layer[1]]
+            pml_thicknesses.append((thick_l, thick_r))
+        return pml_thicknesses
+
+    @equal_aspect
+    @add_ax_if_none
+    def plot_lumped_elements(
+        self,
+        x: float = None,
+        y: float = None,
+        z: float = None,
+        hlim: Tuple[float, float] = None,
+        vlim: Tuple[float, float] = None,
+        alpha: float = None,
+        ax: Ax = None,
+    ) -> Ax:
+        """Plot each of simulation's lumped elements on a plane defined by one
+        nonzero x,y,z coordinate.
+
+        Parameters
+        ----------
+        x : float = None
+            position of plane in x direction, only one of x, y, z must be specified to define plane.
+        y : float = None
+            position of plane in y direction, only one of x, y, z must be specified to define plane.
+        z : float = None
+            position of plane in z direction, only one of x, y, z must be specified to define plane.
+        hlim : Tuple[float, float] = None
+            The x range if plotting on xy or xz planes, y range if plotting on yz plane.
+        vlim : Tuple[float, float] = None
+            The z range if plotting on xz or yz planes, y plane if plotting on xy plane.
+        alpha : float = None
+            Opacity of the lumped element, If ``None`` uses Tidy3d default.
+        ax : matplotlib.axes._subplots.Axes = None
+            Matplotlib axes to plot on, if not specified, one is created.
+
+        Returns
+        -------
+        matplotlib.axes._subplots.Axes
+            The supplied or created matplotlib axes.
+        """
+        bounds = self.bounds
+        for element in self.lumped_elements:
+            ax = element.plot(x=x, y=y, z=z, alpha=alpha, ax=ax, sim_bounds=bounds)
+        ax = Scene._set_plot_bounds(
+            bounds=self.simulation_bounds, ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim
+        )
+        return ax
+
+    @add_ax_if_none
+    def plot_grid(
+        self,
+        x: float = None,
+        y: float = None,
+        z: float = None,
+        ax: Ax = None,
+        hlim: Tuple[float, float] = None,
+        vlim: Tuple[float, float] = None,
+        **kwargs,
+    ) -> Ax:
+        """Plot the cell boundaries as lines on a plane defined by one nonzero x,y,z coordinate.
+
+        Parameters
+        ----------
+        x : float = None
+            position of plane in x direction, only one of x, y, z must be specified to define plane.
+        y : float = None
+            position of plane in y direction, only one of x, y, z must be specified to define plane.
+        z : float = None
+            position of plane in z direction, only one of x, y, z must be specified to define plane.
+        hlim : Tuple[float, float] = None
+            The x range if plotting on xy or xz planes, y range if plotting on yz plane.
+        vlim : Tuple[float, float] = None
+            The z range if plotting on xz or yz planes, y plane if plotting on xy plane.
+        ax : matplotlib.axes._subplots.Axes = None
+            Matplotlib axes to plot on, if not specified, one is created.
+        **kwargs
+            Optional keyword arguments passed to the matplotlib ``LineCollection``.
+            For details on accepted values, refer to
+            `Matplotlib's documentation <https://tinyurl.com/2p97z4cn>`_.
+
+        Returns
+        -------
+        matplotlib.axes._subplots.Axes
+            The supplied or created matplotlib axes.
+        """
+        kwargs.setdefault("linewidth", 0.2)
+        kwargs.setdefault("colors", "black")
+        cell_boundaries = self.grid.boundaries
+        axis, _ = self.parse_xyz_kwargs(x=x, y=y, z=z)
+        _, (axis_x, axis_y) = self.pop_axis([0, 1, 2], axis=axis)
+        boundaries_x = cell_boundaries.dict()["xyz"[axis_x]]
+        boundaries_y = cell_boundaries.dict()["xyz"[axis_y]]
+        _, (xmin, ymin) = self.pop_axis(self.simulation_bounds[0], axis=axis)
+        _, (xmax, ymax) = self.pop_axis(self.simulation_bounds[1], axis=axis)
+        segs_x = [((bound, ymin), (bound, ymax)) for bound in boundaries_x]
+        line_segments_x = mpl.collections.LineCollection(segs_x, **kwargs)
+        segs_y = [((xmin, bound), (xmax, bound)) for bound in boundaries_y]
+        line_segments_y = mpl.collections.LineCollection(segs_y, **kwargs)
+
+        # Plot grid
+        ax.add_collection(line_segments_x)
+        ax.add_collection(line_segments_y)
+
+        # Plot bounding boxes of override structures
+        plot_params = plot_params_override_structures.include_kwargs(
+            linewidth=2 * kwargs["linewidth"], edgecolor=kwargs["colors"]
+        )
+        for structure in self.grid_spec.override_structures:
+            bounds = list(zip(*structure.geometry.bounds))
+            _, ((xmin, xmax), (ymin, ymax)) = structure.geometry.pop_axis(bounds, axis=axis)
+            xmin, xmax, ymin, ymax = (self._evaluate_inf(v) for v in (xmin, xmax, ymin, ymax))
+            rect = mpl.patches.Rectangle(
+                xy=(xmin, ymin),
+                width=(xmax - xmin),
+                height=(ymax - ymin),
+                **plot_params.to_kwargs(),
+            )
+            ax.add_patch(rect)
+
+        ax = Scene._set_plot_bounds(
+            bounds=self.simulation_bounds, ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim
+        )
+
+        return ax
+
+    @equal_aspect
+    @add_ax_if_none
+    def plot_boundaries(
+        self,
+        x: float = None,
+        y: float = None,
+        z: float = None,
+        ax: Ax = None,
+        **kwargs,
+    ) -> Ax:
+        """Plot the simulation boundary conditions as lines on a plane
+           defined by one nonzero x,y,z coordinate.
+
+        Parameters
+        ----------
+        x : float = None
+            position of plane in x direction, only one of x, y, z must be specified to define plane.
+        y : float = None
+            position of plane in y direction, only one of x, y, z must be specified to define plane.
+        z : float = None
+            position of plane in z direction, only one of x, y, z must be specified to define plane.
+        ax : matplotlib.axes._subplots.Axes = None
+            Matplotlib axes to plot on, if not specified, one is created.
+        **kwargs
+            Optional keyword arguments passed to the matplotlib ``LineCollection``.
+            For details on accepted values, refer to
+            `Matplotlib's documentation <https://tinyurl.com/2p97z4cn>`_.
+
+        Returns
+        -------
+        matplotlib.axes._subplots.Axes
+            The supplied or created matplotlib axes.
+        """
+
+        def set_plot_params(boundary_edge, lim, side, thickness):
+            """Return the line plot properties such as color and opacity based on the boundary"""
+            if isinstance(boundary_edge, PECBoundary):
+                plot_params = plot_params_pec.copy(deep=True)
+            elif isinstance(boundary_edge, PMCBoundary):
+                plot_params = plot_params_pmc.copy(deep=True)
+            elif isinstance(boundary_edge, BlochBoundary):
+                plot_params = plot_params_bloch.copy(deep=True)
+            else:
+                plot_params = PlotParams(alpha=0)
+
+            # expand axis limit so that the axis ticks and labels aren't covered
+            new_lim = lim
+            if plot_params.alpha != 0:
+                if side == -1:
+                    new_lim = lim - thickness
+                elif side == 1:
+                    new_lim = lim + thickness
+
+            return plot_params, new_lim
+
+        boundaries = self.boundary_spec.to_list
+
+        normal_axis, _ = self.parse_xyz_kwargs(x=x, y=y, z=z)
+        _, (dim_u, dim_v) = self.pop_axis([0, 1, 2], axis=normal_axis)
+
+        umin, umax = ax.get_xlim()
+        vmin, vmax = ax.get_ylim()
+
+        size_factor = 1.0 / 35.0
+        thickness_u = (umax - umin) * size_factor
+        thickness_v = (vmax - vmin) * size_factor
+
+        # boundary along the u axis, minus side
+        plot_params, ulim_minus = set_plot_params(boundaries[dim_u][0], umin, -1, thickness_u)
+        rect = mpl.patches.Rectangle(
+            xy=(umin - thickness_u, vmin),
+            width=thickness_u,
+            height=(vmax - vmin),
+            **plot_params.to_kwargs(),
+            **kwargs,
+        )
+        ax.add_patch(rect)
+
+        # boundary along the u axis, plus side
+        plot_params, ulim_plus = set_plot_params(boundaries[dim_u][1], umax, 1, thickness_u)
+        rect = mpl.patches.Rectangle(
+            xy=(umax, vmin),
+            width=thickness_u,
+            height=(vmax - vmin),
+            **plot_params.to_kwargs(),
+            **kwargs,
+        )
+        ax.add_patch(rect)
+
+        # boundary along the v axis, minus side
+        plot_params, vlim_minus = set_plot_params(boundaries[dim_v][0], vmin, -1, thickness_v)
+        rect = mpl.patches.Rectangle(
+            xy=(umin, vmin - thickness_v),
+            width=(umax - umin),
+            height=thickness_v,
+            **plot_params.to_kwargs(),
+            **kwargs,
+        )
+        ax.add_patch(rect)
+
+        # boundary along the v axis, plus side
+        plot_params, vlim_plus = set_plot_params(boundaries[dim_v][1], vmax, 1, thickness_v)
+        rect = mpl.patches.Rectangle(
+            xy=(umin, vmax),
+            width=(umax - umin),
+            height=thickness_v,
+            **plot_params.to_kwargs(),
+            **kwargs,
+        )
+        ax.add_patch(rect)
+
+        # ax = self._set_plot_bounds(ax=ax, x=x, y=y, z=z)
+        ax.set_xlim([ulim_minus, ulim_plus])
+        ax.set_ylim([vlim_minus, vlim_plus])
+
+        return ax
+
+    # TODO: not yet supported
+    # def plot_3d(self, width=800, height=800) -> None:
+    #    """Render 3D plot of ``Simulation`` (in jupyter notebook only).
+    #    Parameters
+    #    ----------
+    #    width : float = 800
+    #        width of the 3d view dom's size
+    #    height : float = 800
+    #        height of the 3d view dom's size
+    #
+    #    """
+    #    return plot_sim_3d(self, width=width, height=height)
+
+    @cached_property
+    def grid(self) -> Grid:
+        """FDTD grid spatial locations and information.
+
+        Returns
+        -------
+        :class:`.Grid`
+            :class:`.Grid` storing the spatial locations relevant to the simulation.
+        """
+
+        # Add a simulation Box as the first structure
+        structures = [Structure(geometry=self.geometry, medium=self.medium)]
+        structures += self.structures
+
+        grid = self.grid_spec.make_grid(
+            structures=structures,
+            symmetry=self.symmetry,
+            periodic=self._periodic,
+            sources=self.sources,
+            num_pml_layers=self.num_pml_layers,
+        )
+
+        # This would AutoGrid the in-plane directions of the 2D materials
+        # return self._grid_corrections_2dmaterials(grid)
+        return grid
+
+    @cached_property
+    def num_cells(self) -> int:
+        """Number of cells in the simulation.
+
+        Returns
+        -------
+        int
+            Number of yee cells in the simulation.
+        """
+
+        return np.prod(self.grid.num_cells, dtype=np.int64)
+
+    def _subgrid(self, span_inds: np.ndarray, grid: Grid = None):
+        """Take a subgrid of the simulation grid with cell span defined by ``span_inds`` along the
+        three dimensions. Optionally, a grid different from the simulation grid can be provided.
+        The ``span_inds`` can also extend beyond the grid, in which case the grid is padded based
+        on the boundary conditions of the simulation along the different dimensions."""
+
+        if not grid:
+            grid = self.grid
+
+        boundary_dict = {}
+        for idim, (dim, periodic) in enumerate(zip("xyz", self._periodic)):
+            ind_beg, ind_end = span_inds[idim]
+            # ind_end + 1 because we are selecting cell boundaries not cells
+            boundary_dict[dim] = grid.extended_subspace(idim, ind_beg, ind_end + 1, periodic)
+        return Grid(boundaries=Coords(**boundary_dict))
+
+    @cached_property
+    def _periodic(self) -> Tuple[bool, bool, bool]:
+        """For each dimension, ``True`` if periodic/Bloch boundaries and ``False`` otherwise.
+        We check on both sides but in practice there should be no cases in which a periodic/Bloch
+        BC is on one side only. This is explicitly validated for Bloch, and implicitly done for
+        periodic, in which case we allow PEC/PMC on the other side, but we replace the periodic
+        boundary with another PEC/PMC plane upon initialization."""
+        periodic = []
+        for bcs_1d in self.boundary_spec.to_list:
+            periodic.append(all(isinstance(bcs, (Periodic, BlochBoundary)) for bcs in bcs_1d))
+        return periodic
+
+    @cached_property
+    def num_pml_layers(self) -> List[Tuple[float, float]]:
+        """Number of absorbing layers in all three axes and directions (-, +).
+
+        Returns
+        -------
+        List[Tuple[float, float]]
+            List containing the number of absorber layers in - and + boundaries.
+        """
+        num_layers = [[0, 0], [0, 0], [0, 0]]
+
+        for idx_i, boundary1d in enumerate(self.boundary_spec.to_list):
+            for idx_j, boundary in enumerate(boundary1d):
+                if isinstance(boundary, (PML, StablePML, Absorber)):
+                    num_layers[idx_i][idx_j] = boundary.num_layers
+
+        return num_layers
+
+    def _snap_zero_dim(self, grid: Grid):
+        """Snap a grid to the simulation center along any dimension along which simulation is
+        effectively 0D, defined as having a single pixel. This is more general than just checking
+        size = 0."""
+        size_snapped = [
+            size if num_cells > 1 else 0 for num_cells, size in zip(self.grid.num_cells, self.size)
+        ]
+        return grid.snap_to_box_zero_dim(Box(center=self.center, size=size_snapped))
+
+    def _discretize_grid(self, box: Box, grid: Grid, extend: bool = False) -> Grid:
+        """Grid containing only cells that intersect with a :class:`Box`.
+
+        As opposed to ``Simulation.discretize``, this function operates on a ``grid``
+        which may not be the grid of the simulation.
+        """
+
+        if not self.intersects(box):
+            log.error(f"Box {box} is outside simulation, cannot discretize.")
+
+        span_inds = grid.discretize_inds(box=box, extend=extend)
+        return self._subgrid(span_inds=span_inds, grid=grid)
+
+    def _discretize_inds_monitor(self, monitor: Monitor):
+        """Start and stopping indexes for the cells where data needs to be recorded to fully cover
+        a ``monitor``. This is used during the solver run. The final grid on which a monitor data
+        lives is computed in ``discretize_monitor``, with the difference being that 0-sized
+        dimensions of the monitor or the simulation are snapped in post-processing."""
+
+        # Expand monitor size slightly to break numerical precision in favor of always having
+        # enough data to span the full monitor.
+        expand_size = [size + fp_eps if size > fp_eps else size for size in monitor.size]
+        box_expanded = Box(center=monitor.center, size=expand_size)
+        # Discretize without extension for now
+        span_inds = np.array(self.grid.discretize_inds(box_expanded, extend=False))
+
+        if any(ind[0] >= ind[1] for ind in span_inds):
+            # At least one dimension has no indexes inside the grid, e.g. monitor is entirely
+            # outside of the grid
+            return span_inds
+
+        # Now add extensions, which are specific for monitors and are determined such that data
+        # colocated to grid boundaries can be interpolated anywhere inside the monitor.
+        # We always need to expand on the right.
+        span_inds[:, 1] += 1
+        # Non-colocating monitors also need to expand on the left.
+        if not monitor.colocate:
+            span_inds[:, 0] -= 1
+        return span_inds
+
+    def discretize_monitor(self, monitor: Monitor) -> Grid:
+        """Grid on which monitor data corresponding to a given monitor will be computed."""
+        span_inds = self._discretize_inds_monitor(monitor)
+        grid_snapped = self._subgrid(span_inds=span_inds).snap_to_box_zero_dim(monitor)
+        grid_snapped = self._snap_zero_dim(grid=grid_snapped)
+        return grid_snapped
+
+    def discretize(self, box: Box, extend: bool = False) -> Grid:
+        """Grid containing only cells that intersect with a :class:`.Box`.
+
+        Parameters
+        ----------
+        box : :class:`.Box`
+            Rectangular geometry within simulation to discretize.
+        extend : bool = False
+            If ``True``, ensure that the returned indexes extend sufficiently in every direction to
+            be able to interpolate any field component at any point within the ``box``, for field
+            components sampled on the Yee grid.
+
+        Returns
+        -------
+        :class:`Grid`
+            The FDTD subgrid containing simulation points that intersect with ``box``.
+        """
+        return self._discretize_grid(box=box, grid=self.grid, extend=extend)
+
+    def epsilon(
+        self,
+        box: Box,
+        coord_key: str = "centers",
+        freq: float = None,
+    ) -> xr.DataArray:
+        """Get array of permittivity at volume specified by box and freq.
+
+        Parameters
+        ----------
+        box : :class:`.Box`
+            Rectangular geometry specifying where to measure the permittivity.
+        coord_key : str = 'centers'
+            Specifies at what part of the grid to return the permittivity at.
+            Accepted values are ``{'centers', 'boundaries', 'Ex', 'Ey', 'Ez', 'Exy', 'Exz', 'Eyx',
+            'Eyz', 'Ezx', Ezy'}``. The field values (eg. ``'Ex'``) correspond to the corresponding field
+            locations on the yee lattice. If field values are selected, the corresponding diagonal
+            (eg. ``eps_xx`` in case of ``'Ex'``) or off-diagonal (eg. ``eps_xy`` in case of ``'Exy'``) epsilon
+            component from the epsilon tensor is returned. Otherwise, the average of the main
+            values is returned.
+        freq : float = None
+            The frequency to evaluate the mediums at.
+            If not specified, evaluates at infinite frequency.
+
+        Returns
+        -------
+        xarray.DataArray
+            Datastructure containing the relative permittivity values and location coordinates.
+            For details on xarray DataArray objects,
+            refer to `xarray's Documentation <https://tinyurl.com/2zrzsp7b>`_.
+
+        See Also
+        --------
+
+        **Notebooks**
+            * `First walkthrough: permittivity data <../../notebooks/Simulation.html#Permittivity-data>`_
+        """
+
+        sub_grid = self.discretize(box)
+        return self.epsilon_on_grid(grid=sub_grid, coord_key=coord_key, freq=freq)
+
+    def epsilon_on_grid(
+        self,
+        grid: Grid,
+        coord_key: str = "centers",
+        freq: float = None,
+    ) -> xr.DataArray:
+        """Get array of permittivity at a given freq on a given grid.
+
+        Parameters
+        ----------
+        grid : :class:`.Grid`
+            Grid specifying where to measure the permittivity.
+        coord_key : str = 'centers'
+            Specifies at what part of the grid to return the permittivity at.
+            Accepted values are ``{'centers', 'boundaries', 'Ex', 'Ey', 'Ez', 'Exy', 'Exz', 'Eyx',
+            'Eyz', 'Ezx', Ezy'}``. The field values (eg. ``'Ex'``) correspond to the corresponding field
+            locations on the yee lattice. If field values are selected, the corresponding diagonal
+            (eg. ``eps_xx`` in case of ``'Ex'``) or off-diagonal (eg. ``eps_xy`` in case of ``'Exy'``) epsilon
+            component from the epsilon tensor is returned. Otherwise, the average of the main
+            values is returned.
+        freq : float = None
+            The frequency to evaluate the mediums at.
+            If not specified, evaluates at infinite frequency.
+        Returns
+        -------
+        xarray.DataArray
+            Datastructure containing the relative permittivity values and location coordinates.
+            For details on xarray DataArray objects,
+            refer to `xarray's Documentation <https://tinyurl.com/2zrzsp7b>`_.
+        """
+
+        grid_cells = np.prod(grid.num_cells)
+        num_structures = len(self.structures)
+        if grid_cells > NUM_CELLS_WARN_EPSILON:
+            log.warning(
+                f"Requested grid contains {int(grid_cells):.2e} grid cells. "
+                "Epsilon calculation may be slow."
+            )
+        if num_structures > NUM_STRUCTURES_WARN_EPSILON:
+            log.warning(
+                f"Simulation contains {num_structures:.2e} structures. "
+                "Epsilon calculation may be slow."
+            )
+
+        def get_eps(structure: Structure, frequency: float, coords: Coords):
+            """Select the correct epsilon component if field locations are requested."""
+            if coord_key[0] != "E":
+                return np.mean(structure.eps_diagonal(frequency, coords), axis=0)
+            row = ["x", "y", "z"].index(coord_key[1])
+            if len(coord_key) == 2:  # diagonal component in case of Ex, Ey, and Ez
+                col = row
+            else:  # off-diagonal component in case of Exy, Exz, Eyx, etc
+                col = ["x", "y", "z"].index(coord_key[2])
+            return structure.eps_comp(row, col, frequency, coords)
+
+        def make_eps_data(coords: Coords):
+            """returns epsilon data on grid of points defined by coords"""
+            arrays = (np.array(coords.x), np.array(coords.y), np.array(coords.z))
+            eps_background = get_eps(
+                structure=self.scene.background_structure, frequency=freq, coords=coords
+            )
+            shape = tuple(len(array) for array in arrays)
+            eps_array = eps_background * np.ones(shape, dtype=complex)
+            # replace 2d materials with volumetric equivalents
+            with log as consolidated_logger:
+                for structure in self.volumetric_structures:
+                    # Indexing subset within the bounds of the structure
+
+                    inds = structure.geometry._inds_inside_bounds(*arrays)
+
+                    # Get permittivity on meshgrid over the reduced coordinates
+                    coords_reduced = tuple(arr[ind] for arr, ind in zip(arrays, inds))
+                    if any(coords.size == 0 for coords in coords_reduced):
+                        continue
+
+                    red_coords = Coords(**dict(zip("xyz", coords_reduced)))
+                    eps_structure = get_eps(structure=structure, frequency=freq, coords=red_coords)
+
+                    if structure.medium.nonlinear_spec is not None:
+                        consolidated_logger.warning(
+                            "Evaluating permittivity of a nonlinear "
+                            "medium ignores the nonlinearity."
+                        )
+
+                    if isinstance(structure.geometry, TriangleMesh):
+                        consolidated_logger.warning(
+                            "Client-side permittivity of a 'TriangleMesh' may be "
+                            "inaccurate if the mesh is not unionized. We recommend unionizing "
+                            "all meshes before import. A 'PermittivityMonitor' can be used to "
+                            "obtain the true permittivity and check that the surface mesh is "
+                            "loaded correctly."
+                        )
+
+                    # Update permittivity array at selected indexes within the geometry
+                    is_inside = structure.geometry.inside_meshgrid(*coords_reduced)
+                    eps_array[inds][is_inside] = (eps_structure * is_inside)[is_inside]
+
+            coords = dict(zip("xyz", arrays))
+            return xr.DataArray(eps_array, coords=coords, dims=("x", "y", "z"))
+
+        # combine all data into dictionary
+        if coord_key[0] == "E":
+            # off-diagonal components are sampled at respective locations (eg. `eps_xy` at `Ex`)
+            coords = grid[coord_key[0:2]]
+        else:
+            coords = grid[coord_key]
+        return make_eps_data(coords)
+
+    def _volumetric_structures_grid(self, grid: Grid) -> Tuple[Structure]:
+        """Generate a tuple of structures wherein any 2D materials are converted to 3D
+        volumetric equivalents, using ``grid`` as the simulation grid."""
+
+        if (
+            not any(isinstance(medium, Medium2D) for medium in self.scene.mediums)
+            and not self.lumped_elements
+        ):
+            return self.structures
+
+        def get_dls(geom: Geometry, axis: Axis, num_dls: int) -> List[float]:
+            """Get grid size around the 2D material."""
+            dls = self._discretize_grid(Box.from_bounds(*geom.bounds), grid=grid).sizes.to_list[
+                axis
+            ]
+            # When 1 dl is requested it is assumed that only an approximate value is needed
+            # before the 2D material has been snapped to the grid
+            if num_dls == 1:
+                return [np.mean(dls)]
+
+            # When 2 dls are requested the 2D geometry should have been snapped to grid,
+            # so this represents the exact adjacent grid spacing
+            if len(dls) != num_dls:
+                raise Tidy3dError(
+                    "Failed to detect grid size around the 2D material. "
+                    "Can't generate volumetric equivalent for this simulation. "
+                    "If you received this error, please create an issue in the Tidy3D "
+                    "github repository."
+                )
+            return dls
+
+        def snap_to_grid(geom: Geometry, axis: Axis) -> Geometry:
+            """Snap a 2D material to the Yee grid."""
+            center = get_bounds(geom, axis)[0]
+            assert get_bounds(geom, axis)[0] == get_bounds(geom, axis)[1]
+            snapped_center = snap_coordinate_to_grid(self.grid, center, axis)
+            return set_bounds(geom, (snapped_center, snapped_center), axis)
+
+        lumped_structures = []
+        for lumped_element in self.lumped_elements:
+            _, tan_dirs = self.pop_axis([0, 1, 2], axis=lumped_element.normal_axis)
+
+            if isinstance(lumped_element, LumpedResistor):
+                conductivity = lumped_element.sheet_conductance
+
+                if tan_dirs[0] == lumped_element.voltage_axis:
+                    medium_dict = {
+                        "ss": Medium(conductivity=conductivity),
+                        "tt": self.medium,
+                    }
+                else:
+                    medium_dict = {
+                        "tt": Medium(conductivity=conductivity),
+                        "ss": self.medium,
+                    }
+                lumped_structures.append(
+                    Structure(
+                        geometry=Box(size=lumped_element.size, center=lumped_element.center),
+                        medium=Medium2D(**medium_dict),
+                    )
+                )
+
+        # Begin volumetric structures grid
+        all_structures = list(self.structures) + lumped_structures
+
+        # For 1D and 2D simulations, a nonzero size is needed for the polygon operations in subdivide
+        placeholder_size = tuple(i if i > 0 else inf for i in self.geometry.size)
+        simulation_placeholder_geometry = self.geometry.updated_copy(
+            center=self.geometry.center, size=placeholder_size
+        )
+
+        simulation_background = Structure(
+            geometry=simulation_placeholder_geometry, medium=self.medium
+        )
+        background_structures = [simulation_background]
+        new_structures = []
+        for structure in all_structures:
+            if not isinstance(structure.medium, Medium2D):
+                # found a 3D material; keep it
+                background_structures.append(structure)
+                new_structures.append(structure)
+                continue
+            # otherwise, found a 2D material; replace it with volumetric equivalent
+            axis = structure.geometry._normal_2dmaterial
+            geometry = structure.geometry
+
+            # subdivide
+            avg_axis_dl = get_dls(geometry, axis, 1)[0]
+            subdivided_geometries = subdivide(geometry, axis, avg_axis_dl, background_structures)
+            # Create and add volumetric equivalents
+            background_structures_temp = []
+            for subdivided_geometry in subdivided_geometries:
+                # Snap to the grid and create volumetric equivalent
+                snapped_geometry = snap_to_grid(subdivided_geometry[0], axis)
+                snapped_center = get_bounds(snapped_geometry, axis)[0]
+                dls = get_dls(get_thickened_geom(snapped_geometry, axis, avg_axis_dl), axis, 2)
+                adjacent_media = [subdivided_geometry[1].medium, subdivided_geometry[2].medium]
+
+                # Create the new volumetric medium
+                new_medium = structure.medium.volumetric_equivalent(
+                    axis=axis, adjacent_media=adjacent_media, adjacent_dls=dls
+                )
+
+                new_bounds = (snapped_center - dls[0] / 2, snapped_center + dls[1] / 2)
+                temp_geometry = set_bounds(snapped_geometry, bounds=new_bounds, axis=axis)
+                temp_structure = structure.updated_copy(geometry=temp_geometry, medium=new_medium)
+
+                if structure.medium.is_pec:
+                    pec_plus = increment_float(snapped_center, 1.0)
+                    pec_minus = increment_float(snapped_center, -1.0)
+                    new_bounds = (pec_minus, pec_plus)
+                new_geometry = set_bounds(snapped_geometry, bounds=new_bounds, axis=axis)
+                new_structure = structure.updated_copy(geometry=new_geometry, medium=new_medium)
+
+                new_structures.append(new_structure)
+                background_structures_temp.append(temp_structure)
+
+            background_structures += background_structures_temp
+
+        return tuple(new_structures)
+
+    @cached_property
+    def volumetric_structures(self) -> Tuple[Structure]:
+        """Generate a tuple of structures wherein any 2D materials are converted to 3D
+        volumetric equivalents."""
+        return self._volumetric_structures_grid(self.grid)
+
+    def suggest_mesh_overrides(self, **kwargs) -> List[MeshOverrideStructure]:
+        """Generate a :class:.`MeshOverrideStructure` `List` which is automatically generated
+        from structures in the simulation.
+        """
+        mesh_overrides = []
+
+        # For now we can suggest MeshOverrideStructures for lumped elements.
+        for lumped_element in self.lumped_elements:
+            mesh_overrides.extend(lumped_element.to_mesh_overrides())
+
+        return mesh_overrides
+
+
+class Simulation(AbstractYeeGridSimulation):
     """
     Custom implementation of Maxwells equations which represents the physical model to be solved using the FDTD
     method.
 
     Notes
     -----
 
@@ -311,14 +1518,50 @@
         Specifications for the simulation grid along each of the three directions.
 
     **Lectures:**
         *  `Time step size and CFL condition in FDTD <https://www.flexcompute.com/fdtd101/Lecture-7-Time-step-size-and-CFL-condition-in-FDTD/>`_
         *  `Numerical dispersion in FDTD <https://www.flexcompute.com/fdtd101/Lecture-8-Numerical-dispersion-in-FDTD/>`_
     """
 
+    lumped_elements: Tuple[LumpedElementType, ...] = pydantic.Field(
+        (),
+        title="Lumped Elements",
+        description="Tuple of lumped elements in the simulation. "
+        "Note: only :class:`tidy3d.LumpedResistor` is supported currently.",
+    )
+    """
+    Tuple of lumped elements in the simulation.
+
+    Example
+    -------
+    Simple application reference:
+
+    .. code-block:: python
+
+         Simulation(
+            ...
+            lumped_elements=[
+                LumpedResistor(
+                    size=(0, 3, 1),
+                    center=(0, 0, 0),
+                    voltage_axis=2,
+                    resistance=50,
+                    name="resistor_1",
+                )
+            ],
+            ...
+         )
+
+    See Also
+    --------
+
+    `Index <../lumped_elements.html>`_:
+        Available lumped element types.
+    """
+
     grid_spec: GridSpec = pydantic.Field(
         GridSpec(),
         title="Grid Specification",
         description="Specifications for the simulation grid along each of the three directions.",
     )
     """
     Specifications for the simulation grid along each of the three directions.
@@ -695,14 +1938,22 @@
         "bisecting the simulation domain normal to the x-, y-, and z-axis "
         "at the simulation center of each axis, respectively. "
         "Each element can be ``0`` (no symmetry), ``1`` (even, i.e. 'PMC' symmetry) or "
         "``-1`` (odd, i.e. 'PEC' symmetry). "
         "Note that the vectorial nature of the fields must be taken into account to correctly "
         "determine the symmetry value.",
     )
+
+    pec_conformal_mesh_spec: ConformalMeshSpecType = pydantic.Field(
+        StaircasingConformalMeshSpec(),
+        title="Conformal mesh specifications",
+        description="Conformal mesh specifications applied to PEC strucures.",
+        discriminator=TYPE_TAG_STR,
+    )
+
     """
     You should set the ``symmetry`` parameter in your :class:`Simulation` object using a tuple of integers
     defining reflection symmetry across a plane bisecting the simulation domain normal to the x-, y-, and z-axis.
     Each element can be 0 (no symmetry), 1 (even, i.e. :class:`PMC` symmetry) or -1 (odd, i.e. :class:`PEC`
     symmetry). Note that the vectorial nature of the fields must be considered to determine the symmetry value
     correctly.
 
@@ -1664,14 +2915,15 @@
         log.begin_capture()
         self._validate_size()
         self._validate_monitor_size()
         self._validate_modes_size()
         self._validate_datasets_not_none()
         self._validate_tfsf_structure_intersections()
         self._warn_time_monitors_outside_run_time()
+        self._validate_time_monitors_num_steps()
         _ = self.volumetric_structures
         log.end_capture(self)
         if source_required and len(self.sources) == 0:
             raise SetupError("No sources in simulation.")
 
     def _validate_size(self) -> None:
         """Ensures the simulation is within size limits before simulation is uploaded."""
@@ -1775,42 +3027,39 @@
         with log as consolidated_logger:
             for mnt_ind, monitor in enumerate(self.monitors):
                 if isinstance(monitor, AbstractModeMonitor):
                     msg_header = f"Mode monitor '{monitor.name}' "
                     custom_loc = ["monitors", mnt_ind]
                     warn_mode_size(monitor=monitor, msg_header=msg_header, custom_loc=custom_loc)
 
+    def _validate_time_monitors_num_steps(self) -> None:
+        """Raise an error if non-0D time monitors have too many time steps."""
+        for monitor in self.monitors:
+            if not isinstance(monitor, FieldTimeMonitor) or len(monitor.zero_dims) == 3:
+                continue
+            num_time_steps = monitor.num_steps(self.tmesh)
+            if num_time_steps > MAX_TIME_MONITOR_STEPS:
+                raise SetupError(
+                    f"Time monitor '{monitor.name}' records at {num_time_steps} time steps, which "
+                    f"is larger than the maximum allowed value of {MAX_TIME_MONITOR_STEPS} when "
+                    "the monitor is not zero-dimensional. Change the geometry to a point monitor, "
+                    "or use 'start', 'stop', and 'interval' to reduce the number of time steps "
+                    "at which the monitor stores data."
+                )
+
     @cached_property
     def monitors_data_size(self) -> Dict[str, float]:
         """Dictionary mapping monitor names to their estimated storage size in bytes."""
         data_size = {}
         for monitor in self.monitors:
             num_cells = self._monitor_num_cells(monitor)
             storage_size = float(monitor.storage_size(num_cells=num_cells, tmesh=self.tmesh))
             data_size[monitor.name] = storage_size
         return data_size
 
-    def _monitor_num_cells(self, monitor: Monitor) -> int:
-        """Total number of cells included in monitor based on simulation grid."""
-
-        def num_cells_in_monitor(monitor: Monitor) -> int:
-            """Get the number of measurement cells in a monitor given the simulation grid and
-            downsampling."""
-            if not self.intersects(monitor):
-                # Monitor is outside of simulation domain; can happen e.g. for integration surfaces
-                return 0
-            num_cells = self.discretize_monitor(monitor).num_cells
-            # take monitor downsampling into account
-            num_cells = monitor.downsampled_num_cells(num_cells)
-            return np.prod(np.array(num_cells, dtype=np.int64))
-
-        if isinstance(monitor, SurfaceIntegrationMonitor):
-            return sum(num_cells_in_monitor(mnt) for mnt in monitor.integration_surfaces)
-        return num_cells_in_monitor(monitor)
-
     def _validate_datasets_not_none(self) -> None:
         """Ensures that all custom datasets are defined."""
         if any(dataset is None for dataset in self.custom_datasets):
             raise SetupError(
                 "Data for a custom data component is missing. This can happen for example if the "
                 "Simulation has been loaded from json. To save and load simulations with custom "
                 "data, use hdf5 format instead."
@@ -2333,562 +3582,19 @@
             x=x,
             y=y,
             z=z,
             permittivity_threshold=permittivity_threshold,
             frequency=frequency,
             gds_layer_dtype_map=gds_layer_dtype_map,
         )
+        pathlib.Path(fname).parent.mkdir(parents=True, exist_ok=True)
         library.write_gds(fname)
 
     """ Plotting """
 
-    @equal_aspect
-    @add_ax_if_none
-    def plot(
-        self,
-        x: float = None,
-        y: float = None,
-        z: float = None,
-        ax: Ax = None,
-        source_alpha: float = None,
-        monitor_alpha: float = None,
-        hlim: Tuple[float, float] = None,
-        vlim: Tuple[float, float] = None,
-        **patch_kwargs,
-    ) -> Ax:
-        """Plot each of simulation's components on a plane defined by one nonzero x,y,z coordinate.
-
-        Parameters
-        ----------
-        x : float = None
-            position of plane in x direction, only one of x, y, z must be specified to define plane.
-        y : float = None
-            position of plane in y direction, only one of x, y, z must be specified to define plane.
-        z : float = None
-            position of plane in z direction, only one of x, y, z must be specified to define plane.
-        source_alpha : float = None
-            Opacity of the sources. If ``None``, uses Tidy3d default.
-        monitor_alpha : float = None
-            Opacity of the monitors. If ``None``, uses Tidy3d default.
-        ax : matplotlib.axes._subplots.Axes = None
-            Matplotlib axes to plot on, if not specified, one is created.
-        hlim : Tuple[float, float] = None
-            The x range if plotting on xy or xz planes, y range if plotting on yz plane.
-        vlim : Tuple[float, float] = None
-            The z range if plotting on xz or yz planes, y plane if plotting on xy plane.
-
-        Returns
-        -------
-        matplotlib.axes._subplots.Axes
-            The supplied or created matplotlib axes.
-
-        See Also
-        ---------
-
-        **Notebooks**
-            * `Visualizing geometries in Tidy3D: Plotting Materials <../../notebooks/VizSimulation.html#Plotting-Materials>`_
-
-        """
-        hlim, vlim = Scene._get_plot_lims(
-            bounds=self.simulation_bounds, x=x, y=y, z=z, hlim=hlim, vlim=vlim
-        )
-
-        ax = self.plot_structures(ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim)
-        ax = self.plot_sources(ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim, alpha=source_alpha)
-        ax = self.plot_monitors(ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim, alpha=monitor_alpha)
-        ax = self.plot_symmetries(ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim)
-        ax = self.plot_pml(ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim)
-        ax = Scene._set_plot_bounds(
-            bounds=self.simulation_bounds, ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim
-        )
-        ax = self.plot_boundaries(ax=ax, x=x, y=y, z=z)
-        return ax
-
-    @equal_aspect
-    @add_ax_if_none
-    def plot_eps(
-        self,
-        x: float = None,
-        y: float = None,
-        z: float = None,
-        freq: float = None,
-        alpha: float = None,
-        source_alpha: float = None,
-        monitor_alpha: float = None,
-        hlim: Tuple[float, float] = None,
-        vlim: Tuple[float, float] = None,
-        ax: Ax = None,
-    ) -> Ax:
-        """Plot each of simulation's components on a plane defined by one nonzero x,y,z coordinate.
-        The permittivity is plotted in grayscale based on its value at the specified frequency.
-
-        Parameters
-        ----------
-        x : float = None
-            position of plane in x direction, only one of x, y, z must be specified to define plane.
-        y : float = None
-            position of plane in y direction, only one of x, y, z must be specified to define plane.
-        z : float = None
-            position of plane in z direction, only one of x, y, z must be specified to define plane.
-        freq : float = None
-            Frequency to evaluate the relative permittivity of all mediums.
-            If not specified, evaluates at infinite frequency.
-        alpha : float = None
-            Opacity of the structures being plotted.
-            Defaults to the structure default alpha.
-        source_alpha : float = None
-            Opacity of the sources. If ``None``, uses Tidy3d default.
-        monitor_alpha : float = None
-            Opacity of the monitors. If ``None``, uses Tidy3d default.
-        ax : matplotlib.axes._subplots.Axes = None
-            Matplotlib axes to plot on, if not specified, one is created.
-        hlim : Tuple[float, float] = None
-            The x range if plotting on xy or xz planes, y range if plotting on yz plane.
-        vlim : Tuple[float, float] = None
-            The z range if plotting on xz or yz planes, y plane if plotting on xy plane.
-
-        Returns
-        -------
-        matplotlib.axes._subplots.Axes
-            The supplied or created matplotlib axes.
-
-        See Also
-        ---------
-
-        **Notebooks**
-            * `Visualizing geometries in Tidy3D: Plotting Permittivity <../../notebooks/VizSimulation.html#Plotting-Permittivity>`_
-        """
-
-        hlim, vlim = Scene._get_plot_lims(
-            bounds=self.simulation_bounds, x=x, y=y, z=z, hlim=hlim, vlim=vlim
-        )
-
-        ax = self.plot_structures_eps(
-            freq=freq,
-            cbar=True,
-            alpha=alpha,
-            ax=ax,
-            x=x,
-            y=y,
-            z=z,
-            hlim=hlim,
-            vlim=vlim,
-        )
-        ax = self.plot_sources(ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim, alpha=source_alpha)
-        ax = self.plot_monitors(ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim, alpha=monitor_alpha)
-        ax = self.plot_symmetries(ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim)
-        ax = self.plot_pml(ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim)
-        ax = Scene._set_plot_bounds(
-            bounds=self.simulation_bounds, ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim
-        )
-        ax = self.plot_boundaries(ax=ax, x=x, y=y, z=z)
-        return ax
-
-    @equal_aspect
-    @add_ax_if_none
-    def plot_structures_eps(
-        self,
-        x: float = None,
-        y: float = None,
-        z: float = None,
-        freq: float = None,
-        alpha: float = None,
-        cbar: bool = True,
-        reverse: bool = False,
-        ax: Ax = None,
-        hlim: Tuple[float, float] = None,
-        vlim: Tuple[float, float] = None,
-    ) -> Ax:
-        """Plot each of simulation's structures on a plane defined by one nonzero x,y,z coordinate.
-        The permittivity is plotted in grayscale based on its value at the specified frequency.
-
-        Parameters
-        ----------
-        x : float = None
-            position of plane in x direction, only one of x, y, z must be specified to define plane.
-        y : float = None
-            position of plane in y direction, only one of x, y, z must be specified to define plane.
-        z : float = None
-            position of plane in z direction, only one of x, y, z must be specified to define plane.
-        freq : float = None
-            Frequency to evaluate the relative permittivity of all mediums.
-            If not specified, evaluates at infinite frequency.
-        reverse : bool = False
-            If ``False``, the highest permittivity is plotted in black.
-            If ``True``, it is plotteed in white (suitable for black backgrounds).
-        cbar : bool = True
-            Whether to plot a colorbar for the relative permittivity.
-        alpha : float = None
-            Opacity of the structures being plotted.
-            Defaults to the structure default alpha.
-        ax : matplotlib.axes._subplots.Axes = None
-            Matplotlib axes to plot on, if not specified, one is created.
-        hlim : Tuple[float, float] = None
-            The x range if plotting on xy or xz planes, y range if plotting on yz plane.
-        vlim : Tuple[float, float] = None
-            The z range if plotting on xz or yz planes, y plane if plotting on xy plane.
-
-        Returns
-        -------
-        matplotlib.axes._subplots.Axes
-            The supplied or created matplotlib axes.
-        """
-
-        hlim, vlim = Scene._get_plot_lims(
-            bounds=self.simulation_bounds, x=x, y=y, z=z, hlim=hlim, vlim=vlim
-        )
-
-        return self.scene.plot_structures_eps(
-            freq=freq,
-            cbar=cbar,
-            alpha=alpha,
-            ax=ax,
-            x=x,
-            y=y,
-            z=z,
-            hlim=hlim,
-            vlim=vlim,
-            grid=self.grid,
-            reverse=reverse,
-        )
-
-    # candidate for removal in 3.0
-    def eps_bounds(self, freq: float = None) -> Tuple[float, float]:
-        """Compute range of (real) permittivity present in the simulation at frequency "freq"."""
-
-        log.warning(
-            "'Simulation.eps_bounds()' will be removed in Tidy3D 3.0. "
-            "Use 'Simulation.scene.eps_bounds()' instead."
-        )
-        return self.scene.eps_bounds(freq=freq)
-
-    @cached_property
-    def num_pml_layers(self) -> List[Tuple[float, float]]:
-        """Number of absorbing layers in all three axes and directions (-, +).
-
-        Returns
-        -------
-        List[Tuple[float, float]]
-            List containing the number of absorber layers in - and + boundaries.
-        """
-        num_layers = [[0, 0], [0, 0], [0, 0]]
-
-        for idx_i, boundary1d in enumerate(self.boundary_spec.to_list):
-            for idx_j, boundary in enumerate(boundary1d):
-                if isinstance(boundary, (PML, StablePML, Absorber)):
-                    num_layers[idx_i][idx_j] = boundary.num_layers
-
-        return num_layers
-
-    @cached_property
-    def pml_thicknesses(self) -> List[Tuple[float, float]]:
-        """Thicknesses (um) of absorbers in all three axes and directions (-, +)
-
-        Returns
-        -------
-        List[Tuple[float, float]]
-            List containing the absorber thickness (micron) in - and + boundaries.
-        """
-        num_layers = self.num_pml_layers
-        pml_thicknesses = []
-        for num_layer, boundaries in zip(num_layers, self.grid.boundaries.to_list):
-            thick_l = boundaries[num_layer[0]] - boundaries[0]
-            thick_r = boundaries[-1] - boundaries[-1 - num_layer[1]]
-            pml_thicknesses.append((thick_l, thick_r))
-        return pml_thicknesses
-
-    # candidate for removal in 3.0
-    @cached_property
-    def bounds_pml(self) -> Tuple[Tuple[float, float, float], Tuple[float, float, float]]:
-        """Simulation bounds including the PML regions."""
-        log.warning(
-            "'Simulation.bounds_pml' will be removed in Tidy3D 3.0. "
-            "Use 'Simulation.simulation_bounds' instead."
-        )
-        return self.simulation_bounds
-
-    @cached_property
-    def simulation_bounds(self) -> Tuple[Tuple[float, float, float], Tuple[float, float, float]]:
-        """Simulation bounds including the PML regions."""
-        pml_thick = self.pml_thicknesses
-        bounds_in = self.bounds
-        bounds_min = tuple((bmin - pml[0] for bmin, pml in zip(bounds_in[0], pml_thick)))
-        bounds_max = tuple((bmax + pml[1] for bmax, pml in zip(bounds_in[1], pml_thick)))
-
-        return (bounds_min, bounds_max)
-
-    @equal_aspect
-    @add_ax_if_none
-    def plot_pml(
-        self,
-        x: float = None,
-        y: float = None,
-        z: float = None,
-        hlim: Tuple[float, float] = None,
-        vlim: Tuple[float, float] = None,
-        ax: Ax = None,
-    ) -> Ax:
-        """Plot each of simulation's absorbing boundaries
-        on a plane defined by one nonzero x,y,z coordinate.
-
-        Parameters
-        ----------
-        x : float = None
-            position of plane in x direction, only one of x, y, z must be specified to define plane.
-        y : float = None
-            position of plane in y direction, only one of x, y, z must be specified to define plane.
-        z : float = None
-            position of plane in z direction, only one of x, y, z must be specified to define plane
-        hlim : Tuple[float, float] = None
-            The x range if plotting on xy or xz planes, y range if plotting on yz plane.
-        vlim : Tuple[float, float] = None
-            The z range if plotting on xz or yz planes, y plane if plotting on xy plane.
-        ax : matplotlib.axes._subplots.Axes = None
-            Matplotlib axes to plot on, if not specified, one is created.
-
-        Returns
-        -------
-        matplotlib.axes._subplots.Axes
-            The supplied or created matplotlib axes.
-        """
-        normal_axis, _ = self.parse_xyz_kwargs(x=x, y=y, z=z)
-        pml_boxes = self._make_pml_boxes(normal_axis=normal_axis)
-        for pml_box in pml_boxes:
-            pml_box.plot(x=x, y=y, z=z, ax=ax, **plot_params_pml.to_kwargs())
-        ax = Scene._set_plot_bounds(
-            bounds=self.simulation_bounds, ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim
-        )
-        return ax
-
-    def _make_pml_boxes(self, normal_axis: Axis) -> List[Box]:
-        """make a list of Box objects representing the pml to plot on plane."""
-        pml_boxes = []
-        pml_thicks = self.pml_thicknesses
-        for pml_axis, num_layers_dim in enumerate(self.num_pml_layers):
-            if pml_axis == normal_axis:
-                continue
-            for sign, pml_height, num_layers in zip((-1, 1), pml_thicks[pml_axis], num_layers_dim):
-                if num_layers == 0:
-                    continue
-                pml_box = self._make_pml_box(pml_axis=pml_axis, pml_height=pml_height, sign=sign)
-                pml_boxes.append(pml_box)
-        return pml_boxes
-
-    def _make_pml_box(self, pml_axis: Axis, pml_height: float, sign: int) -> Box:
-        """Construct a :class:`.Box` representing an arborbing boundary to be plotted."""
-        rmin, rmax = (list(bounds) for bounds in self.simulation_bounds)
-        if sign == -1:
-            rmax[pml_axis] = rmin[pml_axis] + pml_height
-        else:
-            rmin[pml_axis] = rmax[pml_axis] - pml_height
-        pml_box = Box.from_bounds(rmin=rmin, rmax=rmax)
-
-        # if any dimension of the sim has size 0, set the PML to a very small size along that dim
-        new_size = list(pml_box.size)
-        for dim_index, sim_size in enumerate(self.size):
-            if sim_size == 0.0:
-                new_size[dim_index] = PML_HEIGHT_FOR_0_DIMS
-        pml_box = pml_box.updated_copy(size=new_size)
-
-        return pml_box
-
-    @add_ax_if_none
-    def plot_grid(
-        self,
-        x: float = None,
-        y: float = None,
-        z: float = None,
-        ax: Ax = None,
-        hlim: Tuple[float, float] = None,
-        vlim: Tuple[float, float] = None,
-        **kwargs,
-    ) -> Ax:
-        """Plot the cell boundaries as lines on a plane defined by one nonzero x,y,z coordinate.
-
-        Parameters
-        ----------
-        x : float = None
-            position of plane in x direction, only one of x, y, z must be specified to define plane.
-        y : float = None
-            position of plane in y direction, only one of x, y, z must be specified to define plane.
-        z : float = None
-            position of plane in z direction, only one of x, y, z must be specified to define plane.
-        hlim : Tuple[float, float] = None
-            The x range if plotting on xy or xz planes, y range if plotting on yz plane.
-        vlim : Tuple[float, float] = None
-            The z range if plotting on xz or yz planes, y plane if plotting on xy plane.
-        ax : matplotlib.axes._subplots.Axes = None
-            Matplotlib axes to plot on, if not specified, one is created.
-        **kwargs
-            Optional keyword arguments passed to the matplotlib ``LineCollection``.
-            For details on accepted values, refer to
-            `Matplotlib's documentation <https://tinyurl.com/2p97z4cn>`_.
-
-        Returns
-        -------
-        matplotlib.axes._subplots.Axes
-            The supplied or created matplotlib axes.
-        """
-        kwargs.setdefault("linewidth", 0.2)
-        kwargs.setdefault("colors", "black")
-        cell_boundaries = self.grid.boundaries
-        axis, _ = self.parse_xyz_kwargs(x=x, y=y, z=z)
-        _, (axis_x, axis_y) = self.pop_axis([0, 1, 2], axis=axis)
-        boundaries_x = cell_boundaries.dict()["xyz"[axis_x]]
-        boundaries_y = cell_boundaries.dict()["xyz"[axis_y]]
-        _, (xmin, ymin) = self.pop_axis(self.simulation_bounds[0], axis=axis)
-        _, (xmax, ymax) = self.pop_axis(self.simulation_bounds[1], axis=axis)
-        segs_x = [((bound, ymin), (bound, ymax)) for bound in boundaries_x]
-        line_segments_x = mpl.collections.LineCollection(segs_x, **kwargs)
-        segs_y = [((xmin, bound), (xmax, bound)) for bound in boundaries_y]
-        line_segments_y = mpl.collections.LineCollection(segs_y, **kwargs)
-
-        # Plot grid
-        ax.add_collection(line_segments_x)
-        ax.add_collection(line_segments_y)
-
-        # Plot bounding boxes of override structures
-        plot_params = plot_params_override_structures.include_kwargs(
-            linewidth=2 * kwargs["linewidth"], edgecolor=kwargs["colors"]
-        )
-        for structure in self.grid_spec.override_structures:
-            bounds = list(zip(*structure.geometry.bounds))
-            _, ((xmin, xmax), (ymin, ymax)) = structure.geometry.pop_axis(bounds, axis=axis)
-            xmin, xmax, ymin, ymax = (self._evaluate_inf(v) for v in (xmin, xmax, ymin, ymax))
-            rect = mpl.patches.Rectangle(
-                xy=(xmin, ymin),
-                width=(xmax - xmin),
-                height=(ymax - ymin),
-                **plot_params.to_kwargs(),
-            )
-            ax.add_patch(rect)
-
-        ax = Scene._set_plot_bounds(
-            bounds=self.simulation_bounds, ax=ax, x=x, y=y, z=z, hlim=hlim, vlim=vlim
-        )
-
-        return ax
-
-    @equal_aspect
-    @add_ax_if_none
-    def plot_boundaries(
-        self,
-        x: float = None,
-        y: float = None,
-        z: float = None,
-        ax: Ax = None,
-        **kwargs,
-    ) -> Ax:
-        """Plot the simulation boundary conditions as lines on a plane
-           defined by one nonzero x,y,z coordinate.
-
-        Parameters
-        ----------
-        x : float = None
-            position of plane in x direction, only one of x, y, z must be specified to define plane.
-        y : float = None
-            position of plane in y direction, only one of x, y, z must be specified to define plane.
-        z : float = None
-            position of plane in z direction, only one of x, y, z must be specified to define plane.
-        ax : matplotlib.axes._subplots.Axes = None
-            Matplotlib axes to plot on, if not specified, one is created.
-        **kwargs
-            Optional keyword arguments passed to the matplotlib ``LineCollection``.
-            For details on accepted values, refer to
-            `Matplotlib's documentation <https://tinyurl.com/2p97z4cn>`_.
-
-        Returns
-        -------
-        matplotlib.axes._subplots.Axes
-            The supplied or created matplotlib axes.
-        """
-
-        def set_plot_params(boundary_edge, lim, side, thickness):
-            """Return the line plot properties such as color and opacity based on the boundary"""
-            if isinstance(boundary_edge, PECBoundary):
-                plot_params = plot_params_pec.copy(deep=True)
-            elif isinstance(boundary_edge, PMCBoundary):
-                plot_params = plot_params_pmc.copy(deep=True)
-            elif isinstance(boundary_edge, BlochBoundary):
-                plot_params = plot_params_bloch.copy(deep=True)
-            else:
-                plot_params = PlotParams(alpha=0)
-
-            # expand axis limit so that the axis ticks and labels aren't covered
-            new_lim = lim
-            if plot_params.alpha != 0:
-                if side == -1:
-                    new_lim = lim - thickness
-                elif side == 1:
-                    new_lim = lim + thickness
-
-            return plot_params, new_lim
-
-        boundaries = self.boundary_spec.to_list
-
-        normal_axis, _ = self.parse_xyz_kwargs(x=x, y=y, z=z)
-        _, (dim_u, dim_v) = self.pop_axis([0, 1, 2], axis=normal_axis)
-
-        umin, umax = ax.get_xlim()
-        vmin, vmax = ax.get_ylim()
-
-        size_factor = 1.0 / 35.0
-        thickness_u = (umax - umin) * size_factor
-        thickness_v = (vmax - vmin) * size_factor
-
-        # boundary along the u axis, minus side
-        plot_params, ulim_minus = set_plot_params(boundaries[dim_u][0], umin, -1, thickness_u)
-        rect = mpl.patches.Rectangle(
-            xy=(umin - thickness_u, vmin),
-            width=thickness_u,
-            height=(vmax - vmin),
-            **plot_params.to_kwargs(),
-            **kwargs,
-        )
-        ax.add_patch(rect)
-
-        # boundary along the u axis, plus side
-        plot_params, ulim_plus = set_plot_params(boundaries[dim_u][1], umax, 1, thickness_u)
-        rect = mpl.patches.Rectangle(
-            xy=(umax, vmin),
-            width=thickness_u,
-            height=(vmax - vmin),
-            **plot_params.to_kwargs(),
-            **kwargs,
-        )
-        ax.add_patch(rect)
-
-        # boundary along the v axis, minus side
-        plot_params, vlim_minus = set_plot_params(boundaries[dim_v][0], vmin, -1, thickness_v)
-        rect = mpl.patches.Rectangle(
-            xy=(umin, vmin - thickness_v),
-            width=(umax - umin),
-            height=thickness_v,
-            **plot_params.to_kwargs(),
-            **kwargs,
-        )
-        ax.add_patch(rect)
-
-        # boundary along the v axis, plus side
-        plot_params, vlim_plus = set_plot_params(boundaries[dim_v][1], vmax, 1, thickness_v)
-        rect = mpl.patches.Rectangle(
-            xy=(umin, vmax),
-            width=(umax - umin),
-            height=thickness_v,
-            **plot_params.to_kwargs(),
-            **kwargs,
-        )
-        ax.add_patch(rect)
-
-        # ax = self._set_plot_bounds(ax=ax, x=x, y=y, z=z)
-        ax.set_xlim([ulim_minus, ulim_plus])
-        ax.set_ylim([vlim_minus, vlim_plus])
-
-        return ax
-
     @cached_property
     def frequency_range(self) -> FreqBound:
         """Range of frequencies spanning all sources' frequency dependence.
 
         Returns
         -------
         Tuple[float, float]
@@ -2911,28 +3617,35 @@
 
         """
         return plot_sim_3d(self, width=width, height=height)
 
     """ Discretization """
 
     @cached_property
+    def scaled_courant(self) -> float:
+        """When conformal mesh is applied, courant number is scaled down depending on `conformal_mesh_spec`."""
+        if self.subpixel:
+            return self.courant * self.pec_conformal_mesh_spec.courant_ratio
+        return self.courant
+
+    @cached_property
     def dt(self) -> float:
         """Simulation time step (distance).
 
         Returns
         -------
         float
             Time step (seconds).
         """
         dl_mins = [np.min(sizes) for sizes in self.grid.sizes.to_list]
         dl_sum_inv_sq = sum(1 / dl**2 for dl in dl_mins)
         dl_avg = 1 / np.sqrt(dl_sum_inv_sq)
         # material factor
         n_cfl = min(min(mat.n_cfl for mat in self.scene.mediums), 1)
-        return n_cfl * self.courant * dl_avg / C_0
+        return n_cfl * self.scaled_courant * dl_avg / C_0
 
     @cached_property
     def tmesh(self) -> Coords1D:
         """FDTD time stepping points.
 
         Returns
         -------
@@ -2944,14 +3657,25 @@
 
     @cached_property
     def num_time_steps(self) -> int:
         """Number of time steps in simulation."""
 
         return len(self.tmesh)
 
+    @cached_property
+    def self_structure(self) -> Structure:
+        """The simulation background as a ``Structure``."""
+        geometry = Box(size=(inf, inf, inf), center=self.center)
+        return Structure(geometry=geometry, medium=self.medium)
+
+    @cached_property
+    def all_structures(self) -> List[Structure]:
+        """List of all structures in the simulation (including the ``Simulation.medium``)."""
+        return [self.self_structure] + list(self.structures)
+
     def _grid_corrections_2dmaterials(self, grid: Grid) -> Grid:
         """Correct the grid if 2d materials are present, using their volumetric equivalents."""
         if not any(isinstance(structure.medium, Medium2D) for structure in self.structures):
             return grid
 
         # when there are 2D materials, need to make grid again with volumetric_structures
         # generated using the first grid
@@ -2998,63 +3722,27 @@
                 coords_all[axis] = volumetric_grid.boundaries.to_list[axis]
             else:
                 coords_all[axis] = grid.boundaries.to_list[axis]
 
         return Grid(boundaries=Coords(**dict(zip("xyz", coords_all))))
 
     @cached_property
-    def grid(self) -> Grid:
-        """FDTD grid spatial locations and information.
-
-        Returns
-        -------
-        :class:`.Grid`
-            :class:`.Grid` storing the spatial locations relevant to the simulation.
-        """
-
-        # Add a simulation Box as the first structure
-        structures = [Structure(geometry=self.geometry, medium=self.medium)]
-        structures += self.structures
-
-        grid = self.grid_spec.make_grid(
-            structures=structures,
-            symmetry=self.symmetry,
-            periodic=self._periodic,
-            sources=self.sources,
-            num_pml_layers=self.num_pml_layers,
-        )
-
-        # This would AutoGrid the in-plane directions of the 2D materials
-        # return self._grid_corrections_2dmaterials(grid)
-        return grid
-
-    @cached_property
-    def num_cells(self) -> int:
-        """Number of cells in the simulation.
-
-        Returns
-        -------
-        int
-            Number of yee cells in the simulation.
-        """
-
-        return np.prod(self.grid.num_cells, dtype=np.int64)
-
-    @cached_property
     def wvl_mat_min(self) -> float:
         """Minimum wavelength in the material.
 
         Returns
         -------
         float
             Minimum wavelength in the material (microns).
         """
         freq_max = max(source.source_time.freq0 for source in self.sources)
         wvl_min = C_0 / freq_max
-        eps_max = max(abs(structure.medium.eps_model(freq_max)) for structure in self.structures)
+
+        all_structures = self.all_structures
+        eps_max = max(abs(structure.medium.eps_model(freq_max)) for structure in all_structures)
         n_max, _ = AbstractMedium.eps_complex_to_nk(eps_max)
         return wvl_min / n_max
 
     @cached_property
     def complex_fields(self) -> bool:
         """Whether complex fields are used in the simulation. Currently this only happens when there
         are Bloch boundaries.
@@ -3100,266 +3788,14 @@
             nyquist_step = int(1 / (2 * freq_max) / self.dt) - 1
             nyquist_step = max(1, nyquist_step)
         else:
             nyquist_step = 1
 
         return nyquist_step
 
-    def _subgrid(self, span_inds: np.ndarray, grid: Grid = None):
-        """Take a subgrid of the simulation grid with cell span defined by ``span_inds`` along the
-        three dimensions. Optionally, a grid different from the simulation grid can be provided.
-        The ``span_inds`` can also extend beyond the grid, in which case the grid is padded based
-        on the boundary conditions of the simulation along the different dimensions."""
-
-        if not grid:
-            grid = self.grid
-
-        boundary_dict = {}
-        for idim, (dim, periodic) in enumerate(zip("xyz", self._periodic)):
-            ind_beg, ind_end = span_inds[idim]
-            # ind_end + 1 because we are selecting cell boundaries not cells
-            boundary_dict[dim] = grid.extended_subspace(idim, ind_beg, ind_end + 1, periodic)
-        return Grid(boundaries=Coords(**boundary_dict))
-
-    def _snap_zero_dim(self, grid: Grid):
-        """Snap a grid to the simulation center along any dimension along which simulation is
-        effectively 0D, defined as having a single pixel. This is more general than just checking
-        size = 0."""
-        size_snapped = [
-            size if num_cells > 1 else 0 for num_cells, size in zip(self.grid.num_cells, self.size)
-        ]
-        return grid.snap_to_box_zero_dim(Box(center=self.center, size=size_snapped))
-
-    @cached_property
-    def _periodic(self) -> Tuple[bool, bool, bool]:
-        """For each dimension, ``True`` if periodic/Bloch boundaries and ``False`` otherwise.
-        We check on both sides but in practice there should be no cases in which a periodic/Bloch
-        BC is on one side only. This is explicitly validated for Bloch, and implicitly done for
-        periodic, in which case we allow PEC/PMC on the other side, but we replace the periodic
-        boundary with another PEC/PMC plane upon initialization."""
-        periodic = []
-        for bcs_1d in self.boundary_spec.to_list:
-            periodic.append(all(isinstance(bcs, (Periodic, BlochBoundary)) for bcs in bcs_1d))
-        return periodic
-
-    def _discretize_grid(self, box: Box, grid: Grid, extend: bool = False) -> Grid:
-        """Grid containing only cells that intersect with a :class:`Box`.
-
-        As opposed to ``Simulation.discretize``, this function operates on a ``grid``
-        which may not be the grid of the simulation.
-        """
-
-        if not self.intersects(box):
-            log.error(f"Box {box} is outside simulation, cannot discretize.")
-
-        span_inds = grid.discretize_inds(box=box, extend=extend)
-        return self._subgrid(span_inds=span_inds, grid=grid)
-
-    def _discretize_inds_monitor(self, monitor: Monitor):
-        """Start and stopping indexes for the cells where data needs to be recorded to fully cover
-        a ``monitor``. This is used during the solver run. The final grid on which a monitor data
-        lives is computed in ``discretize_monitor``, with the difference being that 0-sized
-        dimensions of the monitor or the simulation are snapped in post-processing."""
-
-        # Expand monitor size slightly to break numerical precision in favor of always having
-        # enough data to span the full monitor.
-        expand_size = [size + fp_eps if size > fp_eps else size for size in monitor.size]
-        box_expanded = Box(center=monitor.center, size=expand_size)
-        # Discretize without extension for now
-        span_inds = np.array(self.grid.discretize_inds(box_expanded, extend=False))
-
-        if any(ind[0] >= ind[1] for ind in span_inds):
-            # At least one dimension has no indexes inside the grid, e.g. monitor is entirely
-            # outside of the grid
-            return span_inds
-
-        # Now add extensions, which are specific for monitors and are determined such that data
-        # colocated to grid boundaries can be interpolated anywhere inside the monitor.
-        # We always need to expand on the right.
-        span_inds[:, 1] += 1
-        # Non-colocating monitors also need to expand on the left.
-        if not monitor.colocate:
-            span_inds[:, 0] -= 1
-        return span_inds
-
-    def discretize_monitor(self, monitor: Monitor) -> Grid:
-        """Grid on which monitor data corresponding to a given monitor will be computed."""
-        span_inds = self._discretize_inds_monitor(monitor)
-        grid_snapped = self._subgrid(span_inds=span_inds).snap_to_box_zero_dim(monitor)
-        grid_snapped = self._snap_zero_dim(grid=grid_snapped)
-        return grid_snapped
-
-    def discretize(self, box: Box, extend: bool = False) -> Grid:
-        """Grid containing only cells that intersect with a :class:`.Box`.
-
-        Parameters
-        ----------
-        box : :class:`.Box`
-            Rectangular geometry within simulation to discretize.
-        extend : bool = False
-            If ``True``, ensure that the returned indexes extend sufficiently in every direction to
-            be able to interpolate any field component at any point within the ``box``, for field
-            components sampled on the Yee grid.
-
-        Returns
-        -------
-        :class:`Grid`
-            The FDTD subgrid containing simulation points that intersect with ``box``.
-        """
-        return self._discretize_grid(box=box, grid=self.grid, extend=extend)
-
-    def epsilon(
-        self,
-        box: Box,
-        coord_key: str = "centers",
-        freq: float = None,
-    ) -> xr.DataArray:
-        """Get array of permittivity at volume specified by box and freq.
-
-        Parameters
-        ----------
-        box : :class:`.Box`
-            Rectangular geometry specifying where to measure the permittivity.
-        coord_key : str = 'centers'
-            Specifies at what part of the grid to return the permittivity at.
-            Accepted values are ``{'centers', 'boundaries', 'Ex', 'Ey', 'Ez', 'Exy', 'Exz', 'Eyx',
-            'Eyz', 'Ezx', Ezy'}``. The field values (eg. ``'Ex'``) correspond to the corresponding field
-            locations on the yee lattice. If field values are selected, the corresponding diagonal
-            (eg. ``eps_xx`` in case of ``'Ex'``) or off-diagonal (eg. ``eps_xy`` in case of ``'Exy'``) epsilon
-            component from the epsilon tensor is returned. Otherwise, the average of the main
-            values is returned.
-        freq : float = None
-            The frequency to evaluate the mediums at.
-            If not specified, evaluates at infinite frequency.
-
-        Returns
-        -------
-        xarray.DataArray
-            Datastructure containing the relative permittivity values and location coordinates.
-            For details on xarray DataArray objects,
-            refer to `xarray's Documentation <https://tinyurl.com/2zrzsp7b>`_.
-
-        See Also
-        --------
-
-        **Notebooks**
-            * `First walkthrough: permittivity data <../../notebooks/Simulation.html#Permittivity-data>`_
-        """
-
-        sub_grid = self.discretize(box)
-        return self.epsilon_on_grid(grid=sub_grid, coord_key=coord_key, freq=freq)
-
-    def epsilon_on_grid(
-        self,
-        grid: Grid,
-        coord_key: str = "centers",
-        freq: float = None,
-    ) -> xr.DataArray:
-        """Get array of permittivity at a given freq on a given grid.
-
-        Parameters
-        ----------
-        grid : :class:`.Grid`
-            Grid specifying where to measure the permittivity.
-        coord_key : str = 'centers'
-            Specifies at what part of the grid to return the permittivity at.
-            Accepted values are ``{'centers', 'boundaries', 'Ex', 'Ey', 'Ez', 'Exy', 'Exz', 'Eyx',
-            'Eyz', 'Ezx', Ezy'}``. The field values (eg. ``'Ex'``) correspond to the corresponding field
-            locations on the yee lattice. If field values are selected, the corresponding diagonal
-            (eg. ``eps_xx`` in case of ``'Ex'``) or off-diagonal (eg. ``eps_xy`` in case of ``'Exy'``) epsilon
-            component from the epsilon tensor is returned. Otherwise, the average of the main
-            values is returned.
-        freq : float = None
-            The frequency to evaluate the mediums at.
-            If not specified, evaluates at infinite frequency.
-        Returns
-        -------
-        xarray.DataArray
-            Datastructure containing the relative permittivity values and location coordinates.
-            For details on xarray DataArray objects,
-            refer to `xarray's Documentation <https://tinyurl.com/2zrzsp7b>`_.
-        """
-
-        grid_cells = np.prod(grid.num_cells)
-        num_structures = len(self.structures)
-        if grid_cells > NUM_CELLS_WARN_EPSILON:
-            log.warning(
-                f"Requested grid contains {int(grid_cells):.2e} grid cells. "
-                "Epsilon calculation may be slow."
-            )
-        if num_structures > NUM_STRUCTURES_WARN_EPSILON:
-            log.warning(
-                f"Simulation contains {num_structures:.2e} structures. "
-                "Epsilon calculation may be slow."
-            )
-
-        def get_eps(structure: Structure, frequency: float, coords: Coords):
-            """Select the correct epsilon component if field locations are requested."""
-            if coord_key[0] != "E":
-                return np.mean(structure.eps_diagonal(frequency, coords), axis=0)
-            row = ["x", "y", "z"].index(coord_key[1])
-            if len(coord_key) == 2:  # diagonal component in case of Ex, Ey, and Ez
-                col = row
-            else:  # off-diagonal component in case of Exy, Exz, Eyx, etc
-                col = ["x", "y", "z"].index(coord_key[2])
-            return structure.eps_comp(row, col, frequency, coords)
-
-        def make_eps_data(coords: Coords):
-            """returns epsilon data on grid of points defined by coords"""
-            arrays = (np.array(coords.x), np.array(coords.y), np.array(coords.z))
-            eps_background = get_eps(
-                structure=self.scene.background_structure, frequency=freq, coords=coords
-            )
-            shape = tuple(len(array) for array in arrays)
-            eps_array = eps_background * np.ones(shape, dtype=complex)
-            # replace 2d materials with volumetric equivalents
-            with log as consolidated_logger:
-                for structure in self.volumetric_structures:
-                    # Indexing subset within the bounds of the structure
-
-                    inds = structure.geometry._inds_inside_bounds(*arrays)
-
-                    # Get permittivity on meshgrid over the reduced coordinates
-                    coords_reduced = tuple(arr[ind] for arr, ind in zip(arrays, inds))
-                    if any(coords.size == 0 for coords in coords_reduced):
-                        continue
-
-                    red_coords = Coords(**dict(zip("xyz", coords_reduced)))
-                    eps_structure = get_eps(structure=structure, frequency=freq, coords=red_coords)
-
-                    if structure.medium.nonlinear_spec is not None:
-                        consolidated_logger.warning(
-                            "Evaluating permittivity of a nonlinear "
-                            "medium ignores the nonlinearity."
-                        )
-
-                    if isinstance(structure.geometry, TriangleMesh):
-                        consolidated_logger.warning(
-                            "Client-side permittivity of a 'TriangleMesh' may be "
-                            "inaccurate if the mesh is not unionized. We recommend unionizing "
-                            "all meshes before import. A 'PermittivityMonitor' can be used to "
-                            "obtain the true permittivity and check that the surface mesh is "
-                            "loaded correctly."
-                        )
-
-                    # Update permittivity array at selected indexes within the geometry
-                    is_inside = structure.geometry.inside_meshgrid(*coords_reduced)
-                    eps_array[inds][is_inside] = (eps_structure * is_inside)[is_inside]
-
-            coords = dict(zip("xyz", arrays))
-            return xr.DataArray(eps_array, coords=coords, dims=("x", "y", "z"))
-
-        # combine all data into dictionary
-        if coord_key[0] == "E":
-            # off-diagonal components are sampled at respective locations (eg. `eps_xy` at `Ex`)
-            coords = grid[coord_key[0:2]]
-        else:
-            coords = grid[coord_key]
-        return make_eps_data(coords)
-
     @property
     def custom_datasets(self) -> List[Dataset]:
         """List of custom datasets for verification purposes. If the list is not empty, then
         the simulation needs to be exported to hdf5 to store the data.
         """
         datasets_source_time = [
             src.source_time.source_time_dataset
@@ -3388,144 +3824,58 @@
             datasets_source_time
             + datasets_field_source
             + datasets_current_source
             + datasets_medium
             + datasets_geometry
         )
 
-    def _volumetric_structures_grid(self, grid: Grid) -> Tuple[Structure]:
-        """Generate a tuple of structures wherein any 2D materials are converted to 3D
-        volumetric equivalents, using ``grid`` as the simulation grid."""
-
-        if not any(isinstance(medium, Medium2D) for medium in self.scene.mediums):
-            return self.structures
-
-        def get_dls(geom: Geometry, axis: Axis, num_dls: int) -> List[float]:
-            """Get grid size around the 2D material."""
-            dls = self._discretize_grid(Box.from_bounds(*geom.bounds), grid=grid).sizes.to_list[
-                axis
-            ]
-            # When 1 dl is requested it is assumed that only an approximate value is needed
-            # before the 2D material has been snapped to the grid
-            if num_dls == 1:
-                return [np.mean(dls)]
-
-            # When 2 dls are requested the 2D geometry should have been snapped to grid,
-            # so this represents the exact adjacent grid spacing
-            if len(dls) != num_dls:
-                raise Tidy3dError(
-                    "Failed to detect grid size around the 2D material. "
-                    "Can't generate volumetric equivalent for this simulation. "
-                    "If you received this error, please create an issue in the Tidy3D "
-                    "github repository."
-                )
-            return dls
-
-        def snap_to_grid(geom: Geometry, axis: Axis) -> Geometry:
-            """Snap a 2D material to the Yee grid."""
-            new_centers = self._discretize_grid(
-                Box.from_bounds(*geom.bounds), grid=grid
-            ).boundaries.to_list[axis]
-            new_center = new_centers[np.argmin(abs(new_centers - get_bounds(geom, axis)[0]))]
-            return set_bounds(geom, (new_center, new_center), axis)
-
-        # Begin volumetric structures grid
-        # For 1D and 2D simulations, a nonzero size is needed for the polygon operations in subdivide
-        placeholder_size = tuple(i if i > 0 else inf for i in self.geometry.size)
-        simulation_placeholder_geometry = self.geometry.updated_copy(
-            center=self.geometry.center, size=placeholder_size
-        )
-
-        simulation_background = Structure(
-            geometry=simulation_placeholder_geometry, medium=self.medium
-        )
-        background_structures = [simulation_background]
-        new_structures = []
-        for structure in self.structures:
-            if not isinstance(structure.medium, Medium2D):
-                # found a 3D material; keep it
-                background_structures.append(structure)
-                new_structures.append(structure)
-                continue
-            # otherwise, found a 2D material; replace it with volumetric equivalent
-            axis = structure.geometry._normal_2dmaterial
-            geometry = structure.geometry
-
-            # subdivide
-            avg_axis_dl = get_dls(geometry, axis, 1)[0]
-            subdivided_geometries = subdivide(geometry, axis, avg_axis_dl, background_structures)
-            # Create and add volumetric equivalents
-            background_structures_temp = []
-            for subdivided_geometry in subdivided_geometries:
-                # Snap to the grid and create volumetric equivalent
-                snapped_geometry = snap_to_grid(subdivided_geometry[0], axis)
-                snapped_center = get_bounds(snapped_geometry, axis)[0]
-                dls = get_dls(get_thickened_geom(snapped_geometry, axis, avg_axis_dl), axis, 2)
-                adjacent_media = [subdivided_geometry[1].medium, subdivided_geometry[2].medium]
-
-                # Create the new volumetric medium
-                new_medium = structure.medium.volumetric_equivalent(
-                    axis=axis, adjacent_media=adjacent_media, adjacent_dls=dls
-                )
-
-                new_bounds = (snapped_center - dls[0] / 2, snapped_center + dls[1] / 2)
-                temp_geometry = set_bounds(snapped_geometry, bounds=new_bounds, axis=axis)
-                temp_structure = structure.updated_copy(geometry=temp_geometry, medium=new_medium)
-
-                if structure.medium.is_pec:
-                    pec_delta = fp_eps * max(np.abs(snapped_center), 1.0)
-                    new_bounds = (snapped_center - pec_delta, snapped_center + pec_delta)
-                new_geometry = set_bounds(snapped_geometry, bounds=new_bounds, axis=axis)
-                new_structure = structure.updated_copy(geometry=new_geometry, medium=new_medium)
-
-                new_structures.append(new_structure)
-                background_structures_temp.append(temp_structure)
-
-            background_structures += background_structures_temp
-
-        return tuple(new_structures)
-
-    @cached_property
-    def volumetric_structures(self) -> Tuple[Structure]:
-        """Generate a tuple of structures wherein any 2D materials are converted to 3D
-        volumetric equivalents."""
-        return self._volumetric_structures_grid(self.grid)
-
     @cached_property
     def allow_gain(self) -> bool:
         """``True`` if any of the mediums in the simulation allows gain."""
 
         for medium in self.scene.mediums:
             if isinstance(medium, AnisotropicMedium):
                 if np.any([med.allow_gain for med in [medium.xx, medium.yy, medium.zz]]):
                     return True
             elif medium.allow_gain:
                 return True
         return False
 
     def perturbed_mediums_copy(
         self,
-        temperature: SpatialDataArray = None,
-        electron_density: SpatialDataArray = None,
-        hole_density: SpatialDataArray = None,
+        temperature: CustomSpatialDataType = None,
+        electron_density: CustomSpatialDataType = None,
+        hole_density: CustomSpatialDataType = None,
         interp_method: InterpMethod = "linear",
     ) -> Simulation:
         """Return a copy of the simulation with heat and/or charge data applied to all mediums
         that have perturbation models specified. That is, such mediums will be replaced with
         spatially dependent custom mediums that reflect perturbation effects. Any of temperature,
         electron_density, and hole_density can be ``None``. All provided fields must have identical
         coords.
 
         Parameters
         ----------
-        temperature : SpatialDataArray = None
+        temperature : Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ] = None
             Temperature field data.
-        electron_density : SpatialDataArray = None
+        electron_density : Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ] = None
             Electron density field data.
-        hole_density : SpatialDataArray = None
+        hole_density : Union[
+                :class:`.SpatialDataArray`,
+                :class:`.TriangularGridDataset`,
+                :class:`.TetrahedralGridDataset`,
+            ] = None
             Hole density field data.
         interp_method : :class:`.InterpMethod`, optional
             Interpolation method to obtain heat and/or charge values that are not supplied
             at the Yee grids.
 
         Returns
         -------
```

### Comparing `tidy3d-2.6.4/tidy3d/components/source.py` & `tidy3d-2.7.0rc1/tidy3d/components/source.py`

 * *Files 1% similar despite different names*

```diff
@@ -464,14 +464,23 @@
         title="Enable Interpolation",
         description="Handles reverse-interpolation of zero-size dimensions of the source. "
         "If ``False``, the source data is snapped to the nearest Yee grid point. If ``True``, "
         "equivalent source data is applied on the surrounding Yee grid points to emulate "
         "placement at the specified location using linear interpolation.",
     )
 
+    confine_to_bounds: bool = pydantic.Field(
+        False,
+        title="Confine to Analytical Bounds",
+        description="If ``True``, any source amplitudes which, after discretization, fall beyond "
+        "the bounding box of the source are zeroed out, but only along directions where "
+        "the source has a non-zero extent. The bounding box is inclusive. Should be set ```True`` "
+        "when the current source is being used to excite a current in a conductive material.",
+    )
+
 
 class UniformCurrentSource(CurrentSource, ReverseInterpolatedSource):
     """Source in a rectangular volume with uniform time dependence.
 
     Notes
     -----
```

### Comparing `tidy3d-2.6.4/tidy3d/components/structure.py` & `tidy3d-2.7.0rc1/tidy3d/components/structure.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 """Defines Geometric objects with Medium properties."""
 from __future__ import annotations
 
 from typing import Union, Tuple, Optional
+import pathlib
 import pydantic.v1 as pydantic
 import numpy as np
 
 from .base import Tidy3dBaseModel, skip_if_fields_missing
 from .validators import validate_name_str
 from .geometry.utils import GeometryType, validate_no_transformed_polyslabs
 from .medium import MediumType, AbstractCustomMedium, Medium2D
@@ -415,14 +416,15 @@
             y=y,
             z=z,
             permittivity_threshold=permittivity_threshold,
             frequency=frequency,
             gds_layer=gds_layer,
             gds_dtype=gds_dtype,
         )
+        pathlib.Path(fname).parent.mkdir(parents=True, exist_ok=True)
         library.write_gds(fname)
 
 
 class MeshOverrideStructure(AbstractStructure):
     """Defines an object that is only used in the process of generating the mesh.
 
     Notes
```

### Comparing `tidy3d-2.6.4/tidy3d/components/time.py` & `tidy3d-2.7.0rc1/tidy3d/components/time.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/time_modulation.py` & `tidy3d-2.7.0rc1/tidy3d/components/time_modulation.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/transformation.py` & `tidy3d-2.7.0rc1/tidy3d/components/transformation.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/types.py` & `tidy3d-2.7.0rc1/tidy3d/components/types.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/components/validators.py` & `tidy3d-2.7.0rc1/tidy3d/components/validators.py`

 * *Files 1% similar despite different names*

```diff
@@ -42,14 +42,27 @@
     For more details: `Pydantic Validators <https://pydantic-docs.helpmanual.io/usage/validators/>`_
 """
 
 # Lowest frequency supported (Hz)
 MIN_FREQUENCY = 1e5
 
 
+def assert_line():
+    """makes sure a field's ``size`` attribute has exactly 2 zeros"""
+
+    @pydantic.validator("size", allow_reuse=True, always=True)
+    def is_line(cls, val):
+        """Raise validation error if not 1 dimensional."""
+        if val.count(0.0) != 2:
+            raise ValidationError(f"'{cls.__name__}' object must be a line, given size={val}")
+        return val
+
+    return is_line
+
+
 def assert_plane():
     """makes sure a field's ``size`` attribute has exactly 1 zero"""
 
     @pydantic.validator("size", allow_reuse=True, always=True)
     def is_plane(cls, val):
         """Raise validation error if not planar."""
         if val.count(0.0) != 1:
```

### Comparing `tidy3d-2.6.4/tidy3d/components/viz.py` & `tidy3d-2.7.0rc1/tidy3d/components/viz.py`

 * *Files 3% similar despite different names*

```diff
@@ -111,14 +111,17 @@
 plot_params_bloch = PlotParams(alpha=1.0, facecolor="orchid", edgecolor="black", zorder=inf)
 plot_params_symmetry = PlotParams(edgecolor="gray", facecolor="gray", alpha=0.6, zorder=inf)
 plot_params_override_structures = PlotParams(
     linewidth=0.4, edgecolor="black", fill=False, zorder=inf
 )
 plot_params_fluid = PlotParams(facecolor="white", edgecolor="lightsteelblue", lw=0.4, hatch="xx")
 plot_params_grid = PlotParams(edgecolor="black", lw=0.2)
+plot_params_lumped_element = PlotParams(
+    alpha=0.4, facecolor="mediumblue", edgecolor="mediumblue", lw=3
+)
 
 # stores color of simulation.structures for given index in simulation.medium_map
 MEDIUM_CMAP = [
     "#689DBC",
     "#D0698E",
     "#5E6EAD",
     "#C6224E",
```

### Comparing `tidy3d-2.6.4/tidy3d/config.py` & `tidy3d-2.7.0rc1/tidy3d/config.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/constants.py` & `tidy3d-2.7.0rc1/tidy3d/constants.py`

 * *Files 5% similar despite different names*

```diff
@@ -158,14 +158,19 @@
 """
 
 PICOSECOND_PER_NANOMETER_PER_KILOMETER = "ps/(nm km)"
 """
 Picosecond per (nanometer kilometer).
 """
 
+OHM = "ohm"
+"""
+SI unit of resistance..
+"""
+
 THERMAL_CONDUCTIVITY = "W/(um*K)"
 """
 Watts per (micrometer Kelvin).
 """
 
 SPECIFIC_HEAT_CAPACITY = "J/(kg*K)"
 """
```

### Comparing `tidy3d-2.6.4/tidy3d/exceptions.py` & `tidy3d-2.7.0rc1/tidy3d/exceptions.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/log.py` & `tidy3d-2.7.0rc1/tidy3d/log.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/material_library/material_library.py` & `tidy3d-2.7.0rc1/tidy3d/material_library/material_library.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,42 +1,52 @@
 """Holds dispersive models for several commonly used optical materials."""
 import json
 from typing import Dict, List
 import pydantic.v1 as pd
 
-from ..components.medium import PoleResidue, Medium2D
+from ..components.medium import PoleResidue, Medium2D, AnisotropicMedium, Sellmeier
 from ..components.base import Tidy3dBaseModel
+from ..components.types import Axis
 from ..exceptions import SetupError
 from .material_reference import material_refs, ReferenceData
 from .parametric_materials import Graphene
 
 
 def export_matlib_to_file(fname: str = "matlib.json") -> None:
     """Write the material library to a .json file."""
 
     mat_lib_dict = {
         f'{mat.name} ("{mat_name}")': {
             var_name: json.loads(var.medium._json_string) for var_name, var in mat.variants.items()
         }
         for mat_name, mat in material_library.items()
-        if not isinstance(mat, type)
+        if not isinstance(mat, (type, MaterialItemUniaxial))
     }
 
+    # Uniaxial medium treated differently
+    mat_lib_dict.update(
+        {
+            f'{mat.name} ("{mat_name}")': {
+                var_name: {
+                    "ordinary": json.loads(var.ordinary._json_string),
+                    "extraordinary": json.loads(var.extraordinary._json_string),
+                }
+                for var_name, var in mat.variants.items()
+            }
+            for mat_name, mat in material_library.items()
+            if isinstance(mat, MaterialItemUniaxial)
+        }
+    )
+
     with open(fname, "w") as f:
         json.dump(mat_lib_dict, f)
 
 
-class VariantItem(Tidy3dBaseModel):
-    """Reference, data_source, and material model for a variant of a material."""
-
-    medium: PoleResidue = pd.Field(
-        ...,
-        title="Material dispersion model",
-        description="A dispersive medium described by the pole-residue pair model.",
-    )
+class AbstractVariantItem(Tidy3dBaseModel):
+    """Reference, and data_source for a variant of a material."""
 
     reference: List[ReferenceData] = pd.Field(
         None,
         title="Reference information",
         description="A list of references related to this variant model.",
     )
 
@@ -44,14 +54,24 @@
         None,
         title="Dispersion data URL",
         description="The URL to access the dispersion data upon which the material "
         "model is fitted.",
     )
 
 
+class VariantItem(AbstractVariantItem):
+    """Reference, data_source, and material model for a variant of a material."""
+
+    medium: PoleResidue = pd.Field(
+        ...,
+        title="Material dispersion model",
+        description="A dispersive medium described by the pole-residue pair model.",
+    )
+
+
 class MaterialItem(Tidy3dBaseModel):
     """A material that includes several variants."""
 
     name: str = pd.Field(..., title="Name", description="Unique name for the medium.")
     variants: Dict[str, VariantItem] = pd.Field(
         ...,
         title="Dictionary of available variants for this material",
@@ -78,15 +98,15 @@
 
     @property
     def medium(self):
         """The default medium."""
         return self.variants[self.default].medium
 
 
-class VariantItem2D(VariantItem):
+class VariantItem2D(AbstractVariantItem):
     """Reference, data_source, and material model for a variant of a 2D material."""
 
     medium: Medium2D = pd.Field(
         ...,
         title="Material dispersion model",
         description="A dispersive 2D medium described by a surface conductivity model, "
         "which is handled as an anisotropic medium with pole-residue pair models "
@@ -101,14 +121,76 @@
         ...,
         title="Dictionary of available variants for this material",
         description="A dictionary of available variants for this material "
         "that maps from a key to the variant model.",
     )
 
 
+class VariantItemUniaxial(AbstractVariantItem):
+    """Reference, data_source, and material model for a variant of an uniaxial material."""
+
+    ordinary: PoleResidue = pd.Field(
+        ..., title="Ordinary Component", description="Medium describing the ordinary component."
+    )
+
+    extraordinary: PoleResidue = pd.Field(
+        ...,
+        title="Extraordinary Component",
+        description="Medium describing the extraordinary component.",
+    )
+
+    def medium(self, optical_axis: Axis) -> AnisotropicMedium:
+        """
+        Generate anisotropic medium.
+
+        Parameters
+        ----------
+        optical_axis : Axis
+            Optical axis of the uniaxial medium.
+
+        Returns
+        -------
+        :class:`.AnisotropicMedium`
+            The anisotropic medium representing the uniaxial medium.
+        """
+
+        components = ["xx", "yy", "zz"]
+        mat_dict = {comp: self.ordinary for comp in components}
+        mat_dict.update({components[optical_axis]: self.extraordinary})
+        return AnisotropicMedium.parse_obj(mat_dict)
+
+
+class MaterialItemUniaxial(MaterialItem):
+    """A material that includes several variants."""
+
+    variants: Dict[str, VariantItemUniaxial] = pd.Field(
+        ...,
+        title="Dictionary of available variants for this material",
+        description="A dictionary of available variants for this material "
+        "that maps from a key to the variant model.",
+    )
+
+    def medium(self, optical_axis: Axis):
+        """The default medium."""
+        return self.variants[self.default].medium(optical_axis)
+
+
+LiNbO3_Zelmon1997 = VariantItemUniaxial(
+    ordinary=Sellmeier(
+        coeffs=((2.6734, 0.01764), (1.2290, 0.05914), (12.614, 474.60)),
+        frequency_range=(59958491600000.0, 749481145000000.0),
+    ).pole_residue,
+    extraordinary=Sellmeier(
+        coeffs=((2.9804, 0.02047), (0.5981, 0.0666), (8.9543, 416.08)),
+        frequency_range=(59958491600000.0, 749481145000000.0),
+    ).pole_residue,
+    reference=[material_refs["Zelmon1997"]],
+    data_url="https://refractiveindex.info/data_csv.php?datafile=database/data-nk/main/LiNbO3/Zelmon-e.yml",
+)
+
 Ag_Rakic1998BB = VariantItem(
     medium=PoleResidue(
         eps_inf=2.080628548409516,
         poles=[
             (
                 (-74116405167315.4 - 1j * 0.0),
                 (-1.0385354711010449e18 - 1j * 0.0),
@@ -2129,9 +2211,14 @@
             Palik_Lossy=cSi_PalikLossy,
             SalzbergVilla1957=cSi_SalzbergVilla1957,
             Li1993_293K=cSi_Li1993_293K,
             Green2008=cSi_Green2008,
         ),
         default="Green2008",
     ),
+    LiNbO3=MaterialItemUniaxial(
+        name="Lithium niobate",
+        variants=dict(Zelmon1997=LiNbO3_Zelmon1997),
+        default="Zelmon1997",
+    ),
     graphene=Graphene,
 )
```

### Comparing `tidy3d-2.6.4/tidy3d/material_library/material_reference.py` & `tidy3d-2.7.0rc1/tidy3d/material_library/material_reference.py`

 * *Files 2% similar despite different names*

```diff
@@ -140,14 +140,20 @@
         doi="https://doi.org/10.1364/AO.21.001069",
     ),
     Nigara1968=ReferenceData(
         journal="Y. Nigara. Measurement of the optical constants of yttrium oxide, "
         "Jpn. J. Appl. Phys. 7, 404-408 (1968)",
         doi="https://doi.org/10.1143/JJAP.7.404",
     ),
+    Zelmon1997=ReferenceData(
+        journal="D. E. Zelmon, D. L. Small and D. Jundt. Infrared corrected Sellmeier "
+        "coefficients for congruently grown lithium niobate and 5 mol.% magnesium oxide-doped "
+        "lithium niobate, J. Opt. Soc. Am. B 14, 3319-3322 (1997)",
+        doi="https://doi.org/10.1364/JOSAB.14.003319",
+    ),
     Zelmon1998=ReferenceData(
         journal="D. E. Zelmon, D. L. Small and R. Page. Refractive-index measurements "
         "of undoped yttrium aluminum garnet from 0.4 to 5.0 m, Appl. Opt. 37, 4933-4935 (1998)",
         doi="https://doi.org/10.1364/AO.37.004933",
     ),
     SalzbergVilla1957=ReferenceData(
         journal="C. D. Salzberg and J. J. Villa. Infrared Refractive Indexes of "
```

### Comparing `tidy3d-2.6.4/tidy3d/material_library/parametric_materials.py` & `tidy3d-2.7.0rc1/tidy3d/material_library/parametric_materials.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/packaging.py` & `tidy3d-2.7.0rc1/tidy3d/packaging.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/plugins/adjoint/README.md` & `tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/README.md`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/plugins/adjoint/__init__.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/__init__.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/plugins/adjoint/components/__init__.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/components/__init__.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/plugins/adjoint/components/base.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/components/base.py`

 * *Files 9% similar despite different names*

```diff
@@ -11,14 +11,28 @@
 from jax.tree_util import tree_flatten as jax_tree_flatten
 from jax.tree_util import tree_unflatten as jax_tree_unflatten
 
 from ....components.base import Tidy3dBaseModel
 from .data.data_array import JaxDataArray, JAX_DATA_ARRAY_TAG
 
 
+# end of the error message when a ``_validate_web_adjoint`` exception is raised
+WEB_ADJOINT_MESSAGE = (
+    "You can still run this simulation through "
+    "'tidy3d.plugins.adjoint.web.run_local' or 'tidy3d.plugins.adjoint.web.run_local' "
+    ", which are similar to 'run' / 'run_async', but "
+    "perform the gradient postprocessing calculation locally after the simulation runs. "
+    "Note that the postprocessing time can become "
+    "quite long (several minutes or more) if these restrictions are exceeded. "
+    "Furthermore, the local versions of 'adjoint' require downloading field data "
+    "inside of the 'input_structures', which can greatly increase the size of data "
+    "needing to be downloaded."
+)
+
+
 class JaxObject(Tidy3dBaseModel):
     """Abstract class that makes a :class:`.Tidy3dBaseModel` jax-compatible through inheritance."""
 
     _tidy3d_class = Tidy3dBaseModel
 
     """Shortcut to get names of fields with certain properties."""
 
@@ -53,14 +67,18 @@
     def jax_fields(self) -> dict:
         """Get dictionary of ``jax`` fields."""
 
         # TODO: don't use getattr, define this dictionary better
         jax_field_names = self.get_jax_field_names()
         return {key: getattr(self, key) for key in jax_field_names}
 
+    def _validate_web_adjoint(self) -> None:
+        """Run validators for this component, only if using ``tda.web.run()``."""
+        pass
+
     """Methods needed for jax to register arbitrary classes."""
 
     def tree_flatten(self) -> Tuple[list, dict]:
         """How to flatten a :class:`.JaxObject` instance into a ``pytree``."""
         children = []
         aux_data = self.dict()
```

### Comparing `tidy3d-2.6.4/tidy3d/plugins/adjoint/components/data/data_array.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/components/data/data_array.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/plugins/adjoint/components/data/dataset.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/components/data/dataset.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/plugins/adjoint/components/data/monitor_data.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/components/data/monitor_data.py`

 * *Files 1% similar despite different names*

```diff
@@ -156,20 +156,26 @@
     def __getitem__(self, item: str) -> bool:
         return self.field_components[item]
 
     def package_colocate_results(self, centered_fields: Dict[str, ScalarFieldDataArray]) -> Any:
         """How to package the dictionary of fields computed via self.colocate()."""
         return self.updated_copy(**centered_fields)
 
-    def package_flux_results(self, flux_values: JaxDataArray) -> float:
+    def package_flux_results(self, flux_values: JaxDataArray) -> Union[float, JaxDataArray]:
         """How to package the dictionary of fields computed via self.colocate()."""
-        flux_data = flux_values
-        if isinstance(flux_data, JaxDataArray):
-            return jnp.sum(flux_data.values)
-        return jnp.sum(flux_data)
+
+        freqs = flux_values.coords.get("f")
+
+        # handle single frequency case separately for backwards compatibility
+        # return a float of the only value
+        if freqs is not None and len(freqs) == 1:
+            return jnp.sum(flux_values.values)
+
+        # for multi-frequency, return a JaxDataArray
+        return flux_values
 
     @property
     def intensity(self) -> ScalarFieldDataArray:
         """Return the sum of the squared absolute electric field components."""
         raise NotImplementedError("'intensity' is not yet supported in the adjoint plugin.")
 
     @cached_property
```

### Comparing `tidy3d-2.6.4/tidy3d/plugins/adjoint/components/data/sim_data.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/components/data/sim_data.py`

 * *Files 6% similar despite different names*

```diff
@@ -50,14 +50,42 @@
 
     task_id: str = pd.Field(
         None,
         title="Task ID",
         description="Optional field storing the task_id for the original JaxSimulation.",
     )
 
+    def get_poynting_vector(self, field_monitor_name: str) -> xr.Dataset:
+        """return ``xarray.Dataset`` of the Poynting vector at Yee cell centers.
+
+        Calculated values represent the instantaneous Poynting vector for time-domain fields and the
+        complex vector for frequency-domain: ``S = 1/2 E  conj(H)``.
+
+        Only the available components are returned, e.g., if the indicated monitor doesn't include
+        field component `"Ex"`, then `"Sy"` and `"Sz"` will not be calculated.
+
+        Parameters
+        ----------
+        field_monitor_name : str
+            Name of field monitor used in the original :class:`Simulation`.
+
+        Returns
+        -------
+        xarray.DataArray
+            DataArray containing the Poynting vector calculated based on the field components
+            colocated at the center locations of the Yee grid.
+        """
+
+        if field_monitor_name in self.output_monitor_data:
+            raise NotImplementedError(
+                "Adjoint support for differentiation with respect to Poynting vector not available."
+            )
+
+        return super().get_poynting_vector(field_monitor_name)
+
     @property
     def grad_data_symmetry(self) -> Tuple[FieldData, ...]:
         """``self.grad_data`` but with ``symmetry_expanded_copy`` applied."""
         return tuple(data.symmetry_expanded_copy for data in self.grad_data)
 
     @property
     def grad_eps_data_symmetry(self) -> Tuple[FieldData, ...]:
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `tidy3d-2.6.4/tidy3d/plugins/adjoint/components/geometry.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/components/geometry.py`

 * *Files 2% similar despite different names*

```diff
@@ -18,15 +18,15 @@
 from ....components.data.monitor_data import FieldData, PermittivityData
 from ....components.data.data_array import ScalarFieldDataArray
 from ....components.monitor import FieldMonitor, PermittivityMonitor
 from ....constants import fp_eps, MICROMETER
 from ....exceptions import AdjointError
 from ....log import log
 
-from .base import JaxObject
+from .base import JaxObject, WEB_ADJOINT_MESSAGE
 from .types import JaxFloat
 
 # number of integration points per unit wavelength in material
 PTS_PER_WVL_INTEGRATION = 50
 
 # how much to expand the gradient monitors on each side beyond the self.bounds
 GRAD_MONITOR_EXPANSION = fp_eps
@@ -297,22 +297,25 @@
     @pd.validator("dilation", always=True)
     def no_dilation(cls, val):
         """Don't allow dilation."""
         if not np.isclose(val, 0.0):
             raise AdjointError("'JaxPolySlab' does not support dilation.")
         return val
 
-    @pd.validator("vertices", always=True)
-    def limit_number_of_vertices(cls, val):
+    def _validate_web_adjoint(self) -> None:
+        """Run validators for this component, only if using ``tda.web.run()``."""
+        self._limit_number_of_vertices()
+
+    def _limit_number_of_vertices(self) -> None:
         """Limit the maximum number of vertices."""
-        if len(val) > MAX_NUM_VERTICES:
+        if len(self.vertices_jax) > MAX_NUM_VERTICES:
             raise AdjointError(
-                f"For performance, a maximum of {MAX_NUM_VERTICES} are allowed in 'JaxPolySlab'."
+                f"For performance, a maximum of {MAX_NUM_VERTICES} are allowed in 'JaxPolySlab'. "
+                + WEB_ADJOINT_MESSAGE
             )
-        return val
 
     def edge_contrib(
         self,
         vertex_grad: Coordinate2D,
         vertex_stat: Coordinate2D,
         is_next: bool,
         e_mult_xyz: Tuple[Dict[str, ScalarFieldDataArray]],
```

### Comparing `tidy3d-2.6.4/tidy3d/plugins/adjoint/components/medium.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/components/medium.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 from ....components.types import Bound, Literal
 from ....components.medium import Medium, AnisotropicMedium, CustomMedium
 from ....components.geometry.base import Geometry
 from ....components.data.monitor_data import FieldData
 from ....exceptions import SetupError
 from ....constants import CONDUCTIVITY
 
-from .base import JaxObject
+from .base import JaxObject, WEB_ADJOINT_MESSAGE
 from .types import JaxFloat
 from .data.data_array import JaxDataArray
 from .data.dataset import JaxPermittivityDataset
 
 
 # number of integration points per unit wavelength in material
 PTS_PER_WVL_INTEGRATION = 20
@@ -300,32 +300,36 @@
             raise SetupError(
                 "'permittivity' and 'conductivity' are not yet supported in adjoint plugin. "
                 "Please continue to use the 'eps_dataset' field to define the component "
                 "of the permittivity tensor."
             )
         return values
 
-    @pd.validator("eps_dataset", always=True)
-    def _is_not_too_large(cls, val):
+    def _validate_web_adjoint(self) -> None:
+        """Run validators for this component, only if using ``tda.web.run()``."""
+        self._is_not_too_large()
+
+    def _is_not_too_large(self):
         """Ensure number of pixels does not surpass a set amount."""
 
+        field_components = self.eps_dataset.field_components
+
         for field_dim in "xyz":
             field_name = f"eps_{field_dim}{field_dim}"
-            data_array = val.field_components[field_name]
+            data_array = field_components[field_name]
             coord_lens = [len(data_array.coords[key]) for key in "xyz"]
             num_cells_dim = np.prod(coord_lens)
             if num_cells_dim > MAX_NUM_CELLS_CUSTOM_MEDIUM:
                 raise SetupError(
                     "For the adjoint plugin, each component of the 'JaxCustomMedium.eps_dataset' "
                     f"is restricted to have a maximum of {MAX_NUM_CELLS_CUSTOM_MEDIUM} cells. "
-                    f"Detected {num_cells_dim} grid cells in the '{field_name}' component ."
+                    f"Detected {num_cells_dim} grid cells in the '{field_name}' component. "
+                    + WEB_ADJOINT_MESSAGE
                 )
 
-        return val
-
     @pd.validator("eps_dataset", always=True)
     def _eps_dataset_single_frequency(cls, val):
         """Override of inherited validator. (still needed)"""
         return val
 
     @pd.validator("eps_dataset", always=True)
     def _eps_dataset_eps_inf_greater_no_less_than_one_sigma_positive(cls, val, values):
```

### Comparing `tidy3d-2.6.4/tidy3d/plugins/adjoint/components/simulation.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/components/simulation.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,29 +2,31 @@
 from __future__ import annotations
 
 from typing import Tuple, Union, List, Dict, Literal
 from multiprocessing import Pool
 
 import pydantic.v1 as pd
 import numpy as np
+import xarray as xr
 
 from jax.tree_util import register_pytree_node_class
 
 from ....log import log
 from ....components.base import cached_property, Tidy3dBaseModel, skip_if_fields_missing
 from ....components.monitor import FieldMonitor, PermittivityMonitor
 from ....components.monitor import ModeMonitor, DiffractionMonitor, Monitor
 from ....components.simulation import Simulation
 from ....components.data.monitor_data import FieldData, PermittivityData
 from ....components.structure import Structure
 from ....components.types import Ax, annotate_type
+from ....components.geometry.base import Box
 from ....constants import HERTZ, SECOND
 from ....exceptions import AdjointError
 
-from .base import JaxObject
+from .base import JaxObject, WEB_ADJOINT_MESSAGE
 from .structure import (
     JaxStructure,
     JaxStructureType,
     JaxStructureStaticMedium,
     JaxStructureStaticGeometry,
 )
 from .geometry import JaxPolySlab, JaxGeometryGroup
@@ -32,16 +34,16 @@
 
 # bandwidth of adjoint source in units of freq0 if no `fwidth_adjoint`, and one output freq
 FWIDTH_FACTOR = 1.0 / 10
 
 # bandwidth of adjoint sources in units of the minimum difference between output frequencies
 FWIDTH_FACTOR_MULTIFREQ = 0.1
 
-# the adjoint run time is RUN_TIME_FACTOR / fwidth
-RUN_TIME_FACTOR = 100
+# the adjoint run time is the forward simulation run time + RUN_TIME_FACTOR / fwidth
+RUN_TIME_FACTOR = 10
 
 # how many processors to use for server and client side adjoint
 NUM_PROC_LOCAL = 1
 
 # number of input structures before it errors
 MAX_NUM_INPUT_STRUCTURES = 400
 
@@ -173,26 +175,14 @@
     def _subpixel_is_on(cls, val):
         """Assert subpixel is on."""
         if not val:
             raise AdjointError("'JaxSimulation.subpixel' must be 'True' to use adjoint plugin.")
         return val
 
     @pd.validator("input_structures", always=True)
-    def _restrict_input_structures(cls, val):
-        """Restrict number of input structures."""
-        num_input_structures = len(val)
-        if num_input_structures > MAX_NUM_INPUT_STRUCTURES:
-            raise AdjointError(
-                "For performance, adjoint plugin restricts the number of input structures to "
-                f"{MAX_NUM_INPUT_STRUCTURES}. Found {num_input_structures}."
-            )
-
-        return val
-
-    @pd.validator("input_structures", always=True)
     @skip_if_fields_missing(["structures"])
     def _warn_overlap(cls, val, values):
         """Print appropriate warning if structures intersect in ways that cause gradient error."""
 
         input_structures = [s for s in val if "geometry" in s._differentiable_fields]
 
         structures = list(values.get("structures"))
@@ -277,14 +267,29 @@
             medium = struct.medium
             # hasattr is just an additional check to avoid unnecessary bugs
             # if a medium is encountered that does not support nonlinear spec, or things change.
             if hasattr(medium, "nonlinear_spec") and medium.nonlinear_spec:
                 log.warning(f"Nonlinear medium detected in input_structures[{i}]. " + NL_WARNING)
         return val
 
+    def _restrict_input_structures(self) -> None:
+        """Restrict number of input structures."""
+        num_input_structures = len(self.input_structures)
+        if num_input_structures > MAX_NUM_INPUT_STRUCTURES:
+            raise AdjointError(
+                "For performance, adjoint plugin restricts the number of input structures to "
+                f"{MAX_NUM_INPUT_STRUCTURES}. Found {num_input_structures}. " + WEB_ADJOINT_MESSAGE
+            )
+
+    def _validate_web_adjoint(self) -> None:
+        """Run validators for this component, only if using ``tda.web.run()``."""
+        self._restrict_input_structures()
+        for structure in self.input_structures:
+            structure._validate_web_adjoint()
+
     @staticmethod
     def get_freqs_adjoint(output_monitors: List[Monitor]) -> List[float]:
         """Return sorted list of unique frequencies stripped from a collection of monitors."""
 
         if len(output_monitors) == 0:
             raise AdjointError("Can't get adjoint frequency as no output monitors present.")
 
@@ -346,15 +351,16 @@
     @cached_property
     def _run_time_adjoint(self: float) -> float:
         """Return the run time of the adjoint simulation as a function of its fwidth."""
 
         if self.run_time_adjoint is not None:
             return self.run_time_adjoint
 
-        run_time_adjoint = RUN_TIME_FACTOR / self._fwidth_adjoint
+        run_time_fwd = self.run_time
+        run_time_adjoint = run_time_fwd + RUN_TIME_FACTOR / self._fwidth_adjoint
 
         if self._is_multi_freq:
             log.warning(
                 f"{len(self.freqs_adjoint)} unique frequencies detected in the output monitors "
                 f"with a minimum spacing of {self._min_delta_freq:.3e} (Hz). "
                 f"Setting the 'fwidth' of the adjoint sources to {FWIDTH_FACTOR_MULTIFREQ} times "
                 f"this value = {self._fwidth_adjoint:.3e} (Hz) to avoid spectral overlap. "
@@ -364,14 +370,31 @@
                 "If the adjoint 'run_time' is large due to small frequency spacing, "
                 "it could be better to instead run one simulation per frequency, "
                 "which can be done in parallel using 'tidy3d.plugins.adjoint.web.run_async'."
             )
 
         return run_time_adjoint
 
+    @cached_property
+    def tmesh_adjoint(self) -> np.ndarray:
+        """FDTD time stepping points.
+
+        Returns
+        -------
+        np.ndarray
+            Times (seconds) that the simulation time steps through.
+        """
+        dt = self.dt
+        return np.arange(0.0, self._run_time_adjoint + dt, dt)
+
+    @cached_property
+    def num_time_steps_adjoint(self) -> int:
+        """Number of time steps in the adjoint simulation."""
+        return len(self.tmesh_adjoint)
+
     def to_simulation(self) -> Tuple[Simulation, JaxInfo]:
         """Convert :class:`.JaxSimulation` instance to :class:`.Simulation` with an info dict."""
 
         sim_dict = self.dict(
             exclude={
                 "type",
                 "structures",
@@ -560,14 +583,54 @@
             cbar=cbar,
             reverse=reverse,
             ax=ax,
             hlim=hlim,
             vlim=vlim,
         )
 
+    def epsilon(
+        self,
+        box: Box,
+        coord_key: str = "centers",
+        freq: float = None,
+    ) -> xr.DataArray:
+        """Get array of permittivity at volume specified by box and freq.
+
+        Parameters
+        ----------
+        box : :class:`.Box`
+            Rectangular geometry specifying where to measure the permittivity.
+        coord_key : str = 'centers'
+            Specifies at what part of the grid to return the permittivity at.
+            Accepted values are ``{'centers', 'boundaries', 'Ex', 'Ey', 'Ez', 'Exy', 'Exz', 'Eyx',
+            'Eyz', 'Ezx', Ezy'}``. The field values (eg. ``'Ex'``) correspond to the corresponding field
+            locations on the yee lattice. If field values are selected, the corresponding diagonal
+            (eg. ``eps_xx`` in case of ``'Ex'``) or off-diagonal (eg. ``eps_xy`` in case of ``'Exy'``) epsilon
+            component from the epsilon tensor is returned. Otherwise, the average of the main
+            values is returned.
+        freq : float = None
+            The frequency to evaluate the mediums at.
+            If not specified, evaluates at infinite frequency.
+
+        Returns
+        -------
+        xarray.DataArray
+            Datastructure containing the relative permittivity values and location coordinates.
+            For details on xarray DataArray objects,
+            refer to `xarray's Documentation <https://tinyurl.com/2zrzsp7b>`_.
+
+        See Also
+        --------
+
+        **Notebooks**
+            * `First walkthrough: permittivity data <../../notebooks/Simulation.html#Permittivity-data>`_
+        """
+        sim, _ = self.to_simulation()
+        return sim.epsilon(box=box, coord_key=coord_key, freq=freq)
+
     def __eq__(self, other: JaxSimulation) -> bool:
         """Are two JaxSimulation objects equal?"""
         return self.to_simulation()[0] == other.to_simulation()[0]
 
     @classmethod
     def split_monitors(cls, monitors: List[Monitor], jax_info: JaxInfo) -> Dict[str, Monitor]:
         """Split monitors into user and adjoint required based on jax info."""
```

### Comparing `tidy3d-2.6.4/tidy3d/plugins/adjoint/components/structure.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/components/structure.py`

 * *Files 3% similar despite different names*

```diff
@@ -34,14 +34,21 @@
     medium: Union[JaxMediumType, MediumType]
 
     @pd.validator("medium", always=True)
     def _check_2d_geometry(cls, val, values):
         """Override validator checking 2D geometry, which triggers unnecessarily for gradients."""
         return val
 
+    def _validate_web_adjoint(self) -> None:
+        """Run validators for this component, only if using ``tda.web.run()``."""
+        if "geometry" in self._differentiable_fields:
+            self.geometry._validate_web_adjoint()
+        if "medium" in self._differentiable_fields:
+            self.medium._validate_web_adjoint()
+
     @property
     def jax_fields(self):
         """The fields that are jax-traced for this class."""
         return dict(geometry=self.geometry, medium=self.medium)
 
     @property
     def exclude_fields(self):
```

### Comparing `tidy3d-2.6.4/tidy3d/plugins/adjoint/components/types.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/components/types.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/plugins/adjoint/utils/filter.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/utils/filter.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/plugins/adjoint/utils/penalty.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/utils/penalty.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,20 +3,29 @@
 
 import pydantic.v1 as pd
 import jax.numpy as jnp
 
 from ....components.base import Tidy3dBaseModel
 from ....components.types import ArrayFloat2D
 from ....constants import MICROMETER
-
+from ....log import log
 from .filter import ConicFilter, BinaryProjector
 
 # Radius of Curvature Calculation
 
 
+def is_jax_object(arr) -> bool:
+    """Test whether an object is a `jnp.ndarray` or an iterable containing them."""
+    if isinstance(arr, jnp.ndarray):
+        return True
+    if isinstance(arr, (list, tuple)):
+        return is_jax_object(arr[0])
+    return False
+
+
 class Penalty(Tidy3dBaseModel, ABC):
     """Abstract penalty class. Initializes with parameters and .evaluate() on a design."""
 
     @abstractmethod
     def evaluate(self) -> float:
         """Evaluate the penalty on supplied values."""
 
@@ -66,14 +75,27 @@
 
     def evaluate(self, points: ArrayFloat2D) -> float:
         """Get the average penalty as a function of supplied (x, y) points by
         fitting a spline to the curve and evaluating local radius of curvature compared to a
         desired minimum value. If ``wrap``, it is assumed that the points wrap around to form a
         closed geometry instead of an isolated line segment."""
 
+        if not is_jax_object(points):
+            log.warning(
+                "The points passed to 'RadiusPenalty.evaluate()' are not a 'jax' array. "
+                "If passing the 'JaxPolySlab.vertices' field directly, note that the "
+                "derivative information for this field "
+                "is no longer traced by jax as of "
+                "version '2.7'. "
+                "The derivative information is contained in 'JaxPolySlab.vertices_jax'. "
+                "Therefore, we recommend changing your code to either pass that field or pass "
+                "the output of the parameterization functions directly, eg. "
+                "'penalty.evaluate(make_vertices(params))'."
+            )
+
         def quad_fit(p0, pc, p2):
             """Quadratic bezier fit (and derivatives) for three points.
             (x(t), y(t)) = P(t) = P0*t^2 + P1*2*t*(1-t) + P2*(1-t)^2
              t in [0, 1]
             """
 
             # ensure curve goes through (x1, y1) at t=0.5
```

### Comparing `tidy3d-2.6.4/tidy3d/plugins/adjoint/web.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/adjoint/web.py`

 * *Files 1% similar despite different names*

```diff
@@ -107,14 +107,16 @@
 
     Returns
     -------
     :class:`.JaxSimulationData`
         Object containing solver results for the supplied :class:`.JaxSimulation`.
     """
 
+    simulation._validate_web_adjoint()
+
     sim, jax_info = simulation.to_simulation()
 
     sim_data = tidy3d_run_fn(
         simulation=sim,
         task_name=str(task_name),
         folder_name=folder_name,
         path=path,
@@ -130,14 +132,16 @@
     folder_name: str,
     path: str,
     callback_url: str,
     verbose: bool,
 ) -> Tuple[JaxSimulationData, Tuple[RunResidual]]:
     """Run forward pass and stash extra objects for the backwards pass."""
 
+    simulation._validate_web_adjoint()
+
     sim_fwd, jax_info_fwd, jax_info_orig = simulation.to_simulation_fwd()
 
     sim_data_orig, task_id = webapi_run_adjoint_fwd(
         simulation=sim_fwd,
         jax_info=jax_info_fwd,
         task_name=str(task_name),
         folder_name=folder_name,
@@ -392,14 +396,17 @@
 
     Returns
     ------
     Tuple[:class:`.JaxSimulationData`, ...]
         Contains the :class:`.JaxSimulationData` of each :class:`.JaxSimulation`.
     """
 
+    for simulation in simulations:
+        simulation._validate_web_adjoint()
+
     # get task names, the td.Simulation, and JaxInfo for all supplied simulations
     task_names = [str(_task_name_orig(i)) for i in range(len(simulations))]
     task_info = [jax_sim.to_simulation() for jax_sim in simulations]
 
     # process this into dictionaries of task_name -> Simulation and task_name -> JaxInfo
     sims, jax_infos = list(zip(*task_info))
     sims_tidy3d = dict(zip(task_names, sims))
@@ -433,14 +440,17 @@
     path_dir: str,
     callback_url: str,
     verbose: bool,
     num_workers: int,
 ) -> Tuple[Tuple[JaxSimulationData, ...], RunResidualBatch]:
     """Run forward pass and stash extra objects for the backwards pass."""
 
+    for simulation in simulations:
+        simulation._validate_web_adjoint()
+
     jax_infos_orig = []
     sims_fwd = []
     jax_infos_fwd = []
     for simulation in simulations:
         sim_fwd, jax_info_fwd, jax_info_orig = simulation.to_simulation_fwd()
         jax_infos_orig.append(jax_info_orig)
         sims_fwd.append(sim_fwd)
```

### Comparing `tidy3d-2.6.4/tidy3d/plugins/design/README.md` & `tidy3d-2.7.0rc1/tidy3d/plugins/design/README.md`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/plugins/design/design.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/design/design.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/plugins/design/method.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/design/method.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/plugins/design/parameter.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/design/parameter.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/plugins/design/result.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/design/result.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/plugins/dispersion/fit.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/dispersion/fit.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/plugins/dispersion/fit_fast.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/dispersion/fit_fast.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/plugins/dispersion/web.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/dispersion/web.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/plugins/mode/LICENSE` & `tidy3d-2.7.0rc1/tidy3d/plugins/mode/LICENSE`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/plugins/mode/derivatives.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/mode/derivatives.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/plugins/mode/mode_solver.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/mode/mode_solver.py`

 * *Files 3% similar despite different names*

```diff
@@ -444,44 +444,73 @@
         """Compute the epsilon tensor in the plane. Order of components is xx, xy, xz, yx, etc."""
         eps_keys = ["Ex", "Exy", "Exz", "Eyx", "Ey", "Eyz", "Ezx", "Ezy", "Ez"]
         eps_tensor = [
             self.simulation.epsilon_on_grid(self._solver_grid, key, freq) for key in eps_keys
         ]
         return np.stack(eps_tensor, axis=0)
 
-    def _solver_eps(self, freq: float) -> ArrayComplex4D:
-        """Diagonal permittivity in the shape needed by solver, with normal axis rotated to z."""
-
-        # Get diagonal epsilon components in the plane
-        eps_tensor = self._get_epsilon(freq)
-
+    def _tensorial_material_profile_modal_plane_tranform(
+        self, mat_data: ArrayComplex4D
+    ) -> ArrayComplex4D:
+        """For tensorial material response function such as epsilon and mu, pick and tranform it to
+        modal plane with normal axis rotated to z.
+        """
         # get rid of normal axis
-        eps_tensor = np.take(eps_tensor, indices=[0], axis=1 + self.normal_axis)
-        eps_tensor = np.squeeze(eps_tensor, axis=1 + self.normal_axis)
+        mat_tensor = np.take(mat_data, indices=[0], axis=1 + self.normal_axis)
+        mat_tensor = np.squeeze(mat_tensor, axis=1 + self.normal_axis)
 
         # convert to into 3-by-3 representation for easier axis swap
-        flat_shape = np.shape(eps_tensor)  # 9 components flat
+        flat_shape = np.shape(mat_tensor)  # 9 components flat
         tensor_shape = [3, 3] + list(flat_shape[1:])  # 3-by-3 matrix
-        eps_tensor = eps_tensor.reshape(tensor_shape)
+        mat_tensor = mat_tensor.reshape(tensor_shape)
 
         # swap axes to plane coordinates (normal_axis goes to z)
         if self.normal_axis == 0:
             # swap x and y
-            eps_tensor[[0, 1], :, ...] = eps_tensor[[1, 0], :, ...]
-            eps_tensor[:, [0, 1], ...] = eps_tensor[:, [1, 0], ...]
+            mat_tensor[[0, 1], :, ...] = mat_tensor[[1, 0], :, ...]
+            mat_tensor[:, [0, 1], ...] = mat_tensor[:, [1, 0], ...]
         if self.normal_axis <= 1:
             # swap x (normal_axis==0) or y (normal_axis==1) and z
-            eps_tensor[[1, 2], :, ...] = eps_tensor[[2, 1], :, ...]
-            eps_tensor[:, [1, 2], ...] = eps_tensor[:, [2, 1], ...]
+            mat_tensor[[1, 2], :, ...] = mat_tensor[[2, 1], :, ...]
+            mat_tensor[:, [1, 2], ...] = mat_tensor[:, [2, 1], ...]
 
         # back to "flat" representation
-        eps_tensor = eps_tensor.reshape(flat_shape)
+        mat_tensor = mat_tensor.reshape(flat_shape)
 
-        # construct eps to feed to mode solver
-        return eps_tensor
+        # construct to feed to mode solver
+        return mat_tensor
+
+    def _diagonal_material_profile_modal_plane_tranform(
+        self, mat_data: ArrayComplex4D
+    ) -> ArrayComplex3D:
+        """For diagonal material response function such as epsilon and mu, pick and tranform it to
+        modal plane with normal axis rotated to z.
+        """
+        # get rid of normal axis
+        mat_tensor = np.take(mat_data, indices=[0], axis=1 + self.normal_axis)
+        mat_tensor = np.squeeze(mat_tensor, axis=1 + self.normal_axis)
+
+        # swap axes to plane coordinates (normal_axis goes to z)
+        if self.normal_axis == 0:
+            # swap x and y
+            mat_tensor[[0, 1], :, ...] = mat_tensor[[1, 0], :, ...]
+        if self.normal_axis <= 1:
+            # swap x (normal_axis==0) or y (normal_axis==1) and z
+            mat_tensor[[1, 2], :, ...] = mat_tensor[[2, 1], :, ...]
+
+        # construct to feed to mode solver
+        return mat_tensor
+
+    def _solver_eps(self, freq: float) -> ArrayComplex4D:
+        """Diagonal permittivity in the shape needed by solver, with normal axis rotated to z."""
+
+        # Get diagonal epsilon components in the plane
+        eps_tensor = self._get_epsilon(freq)
+        # tranformation
+        return self._tensorial_material_profile_modal_plane_tranform(eps_tensor)
 
     def _solve_all_freqs(
         self,
         coords: Tuple[ArrayFloat1D, ArrayFloat1D],
         symmetry: Tuple[Symmetry, Symmetry],
     ) -> Tuple[List[float], List[Dict[str, ArrayComplex4D]], List[EpsSpecType]]:
         """Call the mode solver at all requested frequencies."""
@@ -495,14 +524,30 @@
             )
             fields.append(fields_freq)
             n_complex.append(n_freq)
             eps_spec.append(eps_spec_freq)
 
         return n_complex, fields, eps_spec
 
+    def _postprocess_solver_fields(self, solver_fields):
+        """Postprocess `solver_fields` from `compute_modes` to proper coordinate"""
+        fields = {key: [] for key in ("Ex", "Ey", "Ez", "Hx", "Hy", "Hz")}
+        for mode_index in range(self.mode_spec.num_modes):
+            # Get E and H fields at the current mode_index
+            ((Ex, Ey, Ez), (Hx, Hy, Hz)) = self._process_fields(solver_fields, mode_index)
+
+            # Note: back in original coordinates
+            fields_mode = {"Ex": Ex, "Ey": Ey, "Ez": Ez, "Hx": Hx, "Hy": Hy, "Hz": Hz}
+            for field_name, field in fields_mode.items():
+                fields[field_name].append(field)
+
+        for field_name, field in fields.items():
+            fields[field_name] = np.stack(field, axis=-1)
+        return fields
+
     def _solve_single_freq(
         self,
         freq: float,
         coords: Tuple[ArrayFloat1D, ArrayFloat1D],
         symmetry: Tuple[Symmetry, Symmetry],
     ) -> Tuple[float, Dict[str, ArrayComplex4D], EpsSpecType]:
         """Call the mode solver at a single frequency.
@@ -518,27 +563,15 @@
             coords=coords,
             freq=freq,
             mode_spec=self.mode_spec,
             symmetry=symmetry,
             direction=self.direction,
         )
 
-        fields = {key: [] for key in ("Ex", "Ey", "Ez", "Hx", "Hy", "Hz")}
-        for mode_index in range(self.mode_spec.num_modes):
-            # Get E and H fields at the current mode_index
-            ((Ex, Ey, Ez), (Hx, Hy, Hz)) = self._process_fields(solver_fields, mode_index)
-
-            # Note: back in original coordinates
-            fields_mode = {"Ex": Ex, "Ey": Ey, "Ez": Ez, "Hx": Hx, "Hy": Hy, "Hz": Hz}
-            for field_name, field in fields_mode.items():
-                fields[field_name].append(field)
-
-        for field_name, field in fields.items():
-            fields[field_name] = np.stack(field, axis=-1)
-
+        fields = self._postprocess_solver_fields(solver_fields)
         return n_complex, fields, eps_spec
 
     def _rotate_field_coords(self, field: FIELD) -> FIELD:
         """Move the propagation axis=z to the proper order in the array."""
         f_x, f_y, f_z = np.moveaxis(field, source=3, destination=1 + self.normal_axis)
         return np.stack(self.plane.unpop_axis(f_z, (f_x, f_y), axis=self.normal_axis), axis=0)
```

### Comparing `tidy3d-2.6.4/tidy3d/plugins/mode/solver.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/mode/solver.py`

 * *Files 4% similar despite different names*

```diff
@@ -30,14 +30,16 @@
     @classmethod
     def compute_modes(
         cls,
         eps_cross,
         coords,
         freq,
         mode_spec,
+        mu_cross=None,
+        split_curl_scaling=None,
         symmetry=(0, 0),
         direction="+",
     ) -> Tuple[Numpy, Numpy, EpsSpecType]:
         """
         Solve for the modes of a waveguide cross-section.
 
         Parameters
@@ -50,14 +52,26 @@
             Two 1D arrays with each with size one larger than the corresponding axis of
             ``eps_cross``.
             Defines a (potentially non-uniform) Cartesian grid on which the modes are computed.
         freq : float
             (Hertz) Frequency at which the eigenmodes are computed.
         mode_spec : ModeSpec
             ``ModeSpec`` object containing specifications of the mode solver.
+        mu_cross : array_like or tuple of array_like
+            Either a single 2D array defining the relative permeability in the cross-section,
+            or nine 2D arrays defining the permeability at the Hx, Hy, and Hz locations
+            of the Yee grid in the order xx, xy, xz, yx, yy, yz, zx, zy, zz.
+            Set to 1 if `None`.
+        split_curl_scaling : tuple of array_like
+            Split curl coefficient to Curl E. Three 2D arrays defining the scaling factor
+            at the Ex, Ey, and Ez locations of the Yee grid in the order xx, yy, zz.
+            Following Benkler's approach, we formulate it as the following:
+            1) during mode solver: eps_cross -> eps_corss / scaling, so eigenvector is E * scaling
+            2) in postprocessing: apply scaling^-1 to eigenvector to obtain E
+        direction : Union["+", "-"]
         direction : Union["+", "-"]
             Direction of mode propagation.
 
         Returns
         -------
         Tuple[Numpy, Numpy, str]
             The first array gives the E and H fields for all modes, the second one gives the complex
@@ -68,47 +82,61 @@
         num_modes = mode_spec.num_modes
         bend_radius = mode_spec.bend_radius
         bend_axis = mode_spec.bend_axis
         angle_theta = mode_spec.angle_theta
         angle_phi = mode_spec.angle_phi
         omega = 2 * np.pi * freq
         k0 = omega / C_0
+        enable_incidence_matrices = split_curl_scaling is not None or mu_cross is not None
 
-        if isinstance(eps_cross, Numpy):
-            eps_xx, eps_xy, eps_xz, eps_yx, eps_yy, eps_yz, eps_zx, eps_zy, eps_zz = eps_cross
-        elif len(eps_cross) == 9:
-            eps_xx, eps_xy, eps_xz, eps_yx, eps_yy, eps_yz, eps_zx, eps_zy, eps_zz = (
-                np.copy(e) for e in eps_cross
-            )
-        else:
-            raise ValueError("Wrong input to mode solver pemittivity!")
+        eps_formated = cls.format_medium_data(eps_cross)
+        eps_xx, eps_xy, eps_xz, eps_yx, eps_yy, eps_yz, eps_zx, eps_zy, eps_zz = eps_formated
+
+        mu_formated = None
+        if mu_cross is not None:
+            mu_formated = cls.format_medium_data(mu_cross)
 
         Nx, Ny = eps_xx.shape
         N = eps_xx.size
 
         if len(coords[0]) != Nx + 1 or len(coords[1]) != Ny + 1:
             raise ValueError("Mismatch between 'coords' and 'esp_cross' shapes.")
         new_coords = [np.copy(c) for c in coords]
 
         """We work with full tensorial epsilon in mu to handle the most general cases that can
         be introduced by coordinate transformations. In the solver, we distinguish the case when
         these tensors are still diagonal, in which case the matrix for diagonalization has shape
         (2N, 2N), and the full tensorial case, in which case it has shape (4N, 4N)."""
         eps_tensor = np.zeros((3, 3, N), dtype=np.complex128)
         mu_tensor = np.zeros((3, 3, N), dtype=np.complex128)
+        identity_tensor = np.zeros((3, 3, N), dtype=np.complex128)
         for row, eps_row in enumerate(
             [[eps_xx, eps_xy, eps_xz], [eps_yx, eps_yy, eps_yz], [eps_zx, eps_zy, eps_zz]]
         ):
-            mu_tensor[row, row, :] = 1.0
+            identity_tensor[row, row, :] = 1.0
             for col, eps in enumerate(eps_row):
+                if split_curl_scaling is not None and col == row:
+                    outside_pec = ~np.isclose(split_curl_scaling[col], 0)
+                    eps[outside_pec] /= split_curl_scaling[col][outside_pec]
+
                 eps_tensor[row, col, :] = eps.ravel()
 
+        if mu_formated is not None:
+            mu_xx, mu_xy, mu_xz, mu_yx, mu_yy, mu_yz, mu_zx, mu_zy, mu_zz = mu_formated
+            for row, mu_row in enumerate(
+                [[mu_xx, mu_xy, mu_xz], [mu_yx, mu_yy, mu_yz], [mu_zx, mu_zy, mu_zz]]
+            ):
+                for col, mu in enumerate(mu_row):
+                    mu_tensor[row, col, :] = mu.ravel()
+        else:
+            mu_tensor = np.copy(identity_tensor)
+
         # Get Jacobian of all coordinate transformations. Initialize as identity (same as mu so far)
-        jac_e = np.real(np.copy(mu_tensor))
-        jac_h = np.real(np.copy(mu_tensor))
+        jac_e = np.real(np.copy(identity_tensor))
+        jac_h = np.real(np.copy(identity_tensor))
 
         if bend_radius is not None:
             new_coords, jac_e, jac_h = radial_transform(new_coords, bend_radius, bend_axis)
 
         if np.abs(angle_theta) > 0:
             new_coords, jac_e_tmp, jac_h_tmp = angled_transform(new_coords, angle_theta, angle_phi)
             jac_e = np.einsum("ij...,jp...->ip...", jac_e_tmp, jac_e)
@@ -183,18 +211,21 @@
             eps_tensor,
             mu_tensor,
             der_mats,
             num_modes,
             target_neff_p,
             mode_spec.precision,
             direction,
+            enable_incidence_matrices,
         )
 
         # Transform back to original axes, E = J^T E'
         E = np.sum(jac_e[..., None] * E[:, None, ...], axis=0)
+        if split_curl_scaling is not None:
+            E = cls.split_curl_field_postprocess(split_curl_scaling, E)
         E = E.reshape((3, Nx, Ny, 1, num_modes))
         H = np.sum(jac_h[..., None] * H[:, None, ...], axis=0)
         H = H.reshape((3, Nx, Ny, 1, num_modes))
         neff = neff * np.linalg.norm(kp_to_k)
         keff = keff * np.linalg.norm(kp_to_k)
 
         fields = np.stack((E, H), axis=0)
@@ -213,14 +244,15 @@
         eps_tensor,
         mu_tensor,
         der_mats,
         num_modes,
         neff_guess,
         mat_precision,
         direction,
+        enable_incidence_matrices,
     ):
         """Solve for the electromagnetic modes of a system defined by in-plane permittivity and
         permeability and assuming translational invariance in the normal direction.
 
         Parameters
         ----------
         Nx : int
@@ -285,15 +317,17 @@
             "mat_precision": mat_precision,
         }
 
         is_eps_complex = cls.isinstance_complex(eps_tensor)
 
         if not is_tensorial:
             eps_spec = "diagonal"
-            E, H, neff, keff = cls.solver_diagonal(**kwargs)
+            E, H, neff, keff = cls.solver_diagonal(
+                **kwargs, enable_incidence_matrices=enable_incidence_matrices
+            )
             if direction == "-":
                 H[0] *= -1
                 H[1] *= -1
                 E[2] *= -1
 
         elif not is_eps_complex:
             eps_spec = "tensorial_real"
@@ -339,19 +373,28 @@
         or ``np.abs(mat_data) < tol``. This operates in-place on mat so there is no return.
         """
         max_element = np.amax(np.abs(mat))
         mat.data *= np.logical_or(np.abs(mat.data) / max_element > tol, np.abs(mat.data) > tol)
         mat.eliminate_zeros()
 
     @classmethod
-    def solver_diagonal(cls, eps, mu, der_mats, num_modes, neff_guess, vec_init, mat_precision):
+    def solver_diagonal(
+        cls,
+        eps,
+        mu,
+        der_mats,
+        num_modes,
+        neff_guess,
+        vec_init,
+        mat_precision,
+        enable_incidence_matrices,
+    ):
         """EM eigenmode solver assuming ``eps`` and ``mu`` are diagonal everywhere."""
 
         # code associated with these options is included below in case it's useful in the future
-        enable_incidence_matrices = False
         enable_preconditioner = False
         analyze_conditioning = False
 
         def incidence_matrix_for_pec(eps_vec, threshold=0.9 * np.abs(pec_val)):
             """Incidence matrix indicating non-PEC entries associated with 'eps_vec'."""
             nnz = eps_vec[np.abs(eps_vec) < threshold]
             eps_nz = eps_vec.copy()
@@ -735,11 +778,43 @@
             # Real and imaginary part of the effective index
             neff = np.sqrt(vre / 2 + np.sqrt(vre**2 + vim**2) / 2)
             keff = vim / 2 / (neff + 1e-10)
             return neff, keff
 
         raise RuntimeError(f"Unidentified 'mode_solver_type={mode_solver_type}'.")
 
+    @staticmethod
+    def format_medium_data(mat_data):
+        """
+        mat_data can be either permittivity or permeability. It's either a single 2D array
+        defining the relative property in the cross-section, or nine 2D arrays defining
+        the property at the E(H)x, E(H)y, and E(H)z locations of the Yee grid in the order
+        xx, xy, xz, yx, yy, yz, zx, zy, zz.
+        """
+        if isinstance(mat_data, Numpy):
+            return (mat_data[i, :, :] for i in range(9))
+        if len(mat_data) == 9:
+            return (np.copy(e) for e in mat_data)
+        raise ValueError("Wrong input to mode solver pemittivity/permeability!")
+
+    @staticmethod
+    def split_curl_field_postprocess(split_curl, E):
+        """E has the shape (3, N, num_modes)"""
+        _, Nx, Ny = split_curl.shape
+        field_shape = E.shape
+
+        # set a dummy value of split curl inside PEC to avoid division by 0 warning (it's 0/0, since
+        # E field inside PEC is also 0); then by the end, zero out E inside PEC again just to be safe.
+        outside_pec = ~np.isclose(split_curl, 0)
+        split_curl_scaling = np.copy(split_curl)
+        split_curl_scaling[~outside_pec] = 1.0
+
+        E = E.reshape(3, Nx, Ny, field_shape[-1])
+        E /= split_curl_scaling[:, :, :, np.newaxis]
+        E *= outside_pec[:, :, :, np.newaxis]
+        E = E.reshape(field_shape)
+        return E
+
 
 def compute_modes(*args, **kwargs) -> Tuple[Numpy, Numpy, str]:
     """A wrapper around ``EigSolver.compute_modes``, which is used in ``ModeSolver``."""
     return EigSolver.compute_modes(*args, **kwargs)
```

### Comparing `tidy3d-2.6.4/tidy3d/plugins/mode/transforms.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/mode/transforms.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/plugins/polyslab/polyslab.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/polyslab/polyslab.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/plugins/resonance/resonance.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/resonance/resonance.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/plugins/smatrix/smatrix.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/smatrix/component_modelers/modal.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,134 +1,68 @@
-"""Tools for generating an S matrix automatically from tidy3d simulation and port definitions."""
+"""Tool for generating an S matrix automatically from a Tidy3d simulation and modal port definitions."""
+# TODO: The names "ComponentModeler" and "Port" should be changed to "ModalComponentModeler" and
+# "ModalPort" to explicitly differentiate these from "TerminalComponentModeler" and "LumpedPort".
 from __future__ import annotations
 
 from typing import List, Tuple, Optional, Dict
-import os
 
 import pydantic.v1 as pd
 import numpy as np
 
-from ...constants import HERTZ
-from ...components.simulation import Simulation
-from ...components.geometry.base import Box
-from ...components.mode import ModeSpec
-from ...components.monitor import ModeMonitor
-from ...components.source import ModeSource, GaussianPulse
-from ...components.data.sim_data import SimulationData
-from ...components.data.data_array import DataArray
-from ...components.types import Direction, Ax, Complex, FreqArray
-from ...components.viz import add_ax_if_none, equal_aspect
-from ...components.base import Tidy3dBaseModel, cached_property
-from ...exceptions import SetupError, Tidy3dKeyError
-from ...log import log
-from ...web.api.container import BatchData, Batch
-
-# fwidth of gaussian pulse in units of central frequency
-FWIDTH_FRAC = 1.0 / 10
-DEFAULT_DATA_DIR = "."
-
-
-class Port(Box):
-    """Specifies a port in the scattering matrix."""
-
-    direction: Direction = pd.Field(
-        ...,
-        title="Direction",
-        description="'+' or '-', defining which direction is considered 'input'.",
-    )
-    mode_spec: ModeSpec = pd.Field(
-        ModeSpec(),
-        title="Mode Specification",
-        description="Specifies how the mode solver will solve for the modes of the port.",
-    )
-    name: str = pd.Field(
-        ...,
-        title="Name",
-        description="Unique name for the port.",
-        min_length=1,
-    )
+from ....components.simulation import Simulation
+from ....components.monitor import ModeMonitor
+from ....components.source import ModeSource, GaussianPulse
+from ....components.data.sim_data import SimulationData
+from ....components.types import Ax, Complex
+from ....components.viz import add_ax_if_none, equal_aspect
+from ....components.base import cached_property
+from ....exceptions import SetupError
+from ....web.api.container import BatchData
+
+from .base import AbstractComponentModeler, FWIDTH_FRAC
+from ..ports.modal import ModalPortDataArray, Port
 
 
 MatrixIndex = Tuple[str, pd.NonNegativeInt]  # the 'i' in S_ij
 Element = Tuple[MatrixIndex, MatrixIndex]  # the 'ij' in S_ij
 
 
-class SMatrixDataArray(DataArray):
-    """Scattering matrix elements.
-
-    Example
-    -------
-    >>> port_in = ['port1', 'port2']
-    >>> port_out = ['port1', 'port2']
-    >>> mode_index_in = [0, 1]
-    >>> mode_index_out = [0, 1]
-    >>> f = [2e14]
-    >>> coords = dict(
-    ...     port_in=port_in,
-    ...     port_out=port_out,
-    ...     mode_index_in=mode_index_in,
-    ...     mode_index_out=mode_index_out,
-    ...     f=f
-    ... )
-    >>> fd = SMatrixDataArray((1 + 1j) * np.random.random((2, 2, 2, 2, 1)), coords=coords)
-    """
-
-    __slots__ = ()
-    _dims = ("port_out", "mode_index_out", "port_in", "mode_index_in", "f")
-    _data_attrs = {"long_name": "scattering matrix element"}
-
-
-class ComponentModeler(Tidy3dBaseModel):
+class ComponentModeler(AbstractComponentModeler):
     """
     Tool for modeling devices and computing scattering matrix elements.
 
     .. TODO missing basic example
 
     See Also
     --------
 
     **Notebooks**
         * `Computing the scattering matrix of a device <../../notebooks/SMatrix.html>`_
     """
 
-    simulation: Simulation = pd.Field(
-        ...,
-        title="Simulation",
-        description="Simulation describing the device without any sources present.",
-    )
     ports: Tuple[Port, ...] = pd.Field(
         (),
         title="Ports",
         description="Collection of ports describing the scattering matrix elements. "
         "For each input mode, one simulation will be run with a modal source.",
     )
-    freqs: FreqArray = pd.Field(
-        ...,
-        title="Frequencies",
-        description="Array or list of frequencies at which to evaluate the scattering matrix.",
-        units=HERTZ,
-    )
 
-    folder_name: str = pd.Field(
-        "default",
-        title="Folder Name",
-        description="Name of the folder for the tasks on web.",
-    )
     element_mappings: Tuple[Tuple[Element, Element, Complex], ...] = pd.Field(
         (),
         title="Element Mappings",
         description="Mapping between elements of the scattering matrix, "
         "as specified by pairs of ``(port name, mode index)`` matrix indices, where the "
         "first element of the pair is the output and the second element of the pair is the input."
         "Each item of ``element_mappings`` is a tuple of ``(element1, element2, c)``, where "
         "the scattering matrix ``Smatrix[element2]`` is set equal to ``c * Smatrix[element1]``."
         "If all elements of a given column of the scattering matrix are defined by "
         " ``element_mappings``, the simulation corresponding to this column "
         "is skipped automatically.",
     )
+
     run_only: Optional[Tuple[MatrixIndex, ...]] = pd.Field(
         None,
         title="Run Only",
         description="If given, a tuple of matrix indices, specified by (:class:`.Port`, ``int``),"
         " to run only, excluding the other rows from the scattering matrix. "
         "If this option is used, "
         "the data corresponding to other inputs will be missing in the resulting matrix.",
@@ -138,26 +72,22 @@
     source. If any indices are excluded, they will not be run."""
 
     verbose: bool = pd.Field(
         False,
         title="Verbosity",
         description="Whether the :class:`.ComponentModeler` should print status and progressbars.",
     )
+
     callback_url: str = pd.Field(
         None,
         title="Callback URL",
         description="Http PUT url to receive simulation finish event. "
         "The body content is a json file with fields "
         "``{'id', 'status', 'name', 'workUnit', 'solverVersion'}``.",
     )
-    path_dir: str = pd.Field(
-        DEFAULT_DATA_DIR,
-        title="Directory Path",
-        description="Base directory where data and batch will be downloaded.",
-    )
 
     @pd.validator("simulation", always=True)
     def _sim_has_no_sources(cls, val):
         """Make sure simulation has no sources as they interfere with tool."""
         if len(val.sources) > 0:
             raise SetupError("'ComponentModeler.simulation' must not have any sources.")
         return val
@@ -219,20 +149,30 @@
 
             # if any matrix elements in row still not covered by map, a source is needed for row.
             if not all(matrix_elements_covered):
                 source_indices_needed.append(col_index)
 
         return source_indices_needed
 
-    def get_port_by_name(self, port_name: str) -> Port:
-        """Get the port from the name."""
-        ports = [port for port in self.ports if port.name == port_name]
-        if len(ports) == 0:
-            raise Tidy3dKeyError(f'Port "{port_name}" not found.')
-        return ports[0]
+    @cached_property
+    def port_names(self) -> Tuple[List[str], List[str]]:
+        """List of port names for inputs and outputs, respectively."""
+
+        def get_port_names(matrix_elements: Tuple[str, int]) -> List[str]:
+            """Get the port names from a list of (port name, mode index)."""
+            port_names = []
+            for port_name, _ in matrix_elements:
+                if port_name not in port_names:
+                    port_names.append(port_name)
+            return port_names
+
+        port_names_in = get_port_names(self.matrix_indices_source)
+        port_names_out = get_port_names(self.matrix_indices_monitor)
+
+        return port_names_out, port_names_in
 
     def to_monitor(self, port: Port) -> ModeMonitor:
         """Creates a mode monitor from a given port."""
         return ModeMonitor(
             center=port.center,
             size=port.size,
             freqs=self.freqs,
@@ -299,32 +239,25 @@
 
         shift_value = self._shift_value_signed(port=port)
         center_shifted = list(port.center)
         center_shifted[port.size.index(0.0)] += shift_value
         port_shifted = port.copy(update=dict(center=center_shifted))
         return port_shifted
 
-    @staticmethod
-    def _task_name(port: Port, mode_index: int) -> str:
-        """The name of a task, determined by the port of the source and mode index."""
-        return f"smatrix_{port.name}_{mode_index}"
-
     @equal_aspect
     @add_ax_if_none
-    def plot_sim(
-        self, x: float = None, y: float = None, z: float = None, ax: Ax = None, **kwargs
-    ) -> Ax:
+    def plot_sim(self, x: float = None, y: float = None, z: float = None, ax: Ax = None) -> Ax:
         """Plot a :class:`Simulation` with all sources added for each port, for troubleshooting."""
 
         plot_sources = []
         for port_source in self.ports:
             mode_source_0 = self.to_source(port=port_source, mode_index=0)
             plot_sources.append(mode_source_0)
         sim_plot = self.simulation.copy(update=dict(sources=plot_sources))
-        return sim_plot.plot(x=x, y=y, z=z, ax=ax, **kwargs)
+        return sim_plot.plot(x=x, y=y, z=z, ax=ax)
 
     @equal_aspect
     @add_ax_if_none
     def plot_sim_eps(
         self, x: float = None, y: float = None, z: float = None, ax: Ax = None, **kwargs
     ) -> Ax:
         """Plot permittivity of the :class:`Simulation` with all sources added for each port."""
@@ -332,66 +265,14 @@
         plot_sources = []
         for port_source in self.ports:
             mode_source_0 = self.to_source(port=port_source, mode_index=0)
             plot_sources.append(mode_source_0)
         sim_plot = self.simulation.copy(update=dict(sources=plot_sources))
         return sim_plot.plot_eps(x=x, y=y, z=z, ax=ax, **kwargs)
 
-    @cached_property
-    def batch(self) -> Batch:
-        """Batch associated with this component modeler."""
-
-        # first try loading the batch from file, if it exists
-        batch_path = self._batch_path
-        if os.path.exists(batch_path):
-            return Batch.from_file(fname=batch_path)
-
-        return Batch(
-            simulations=self.sim_dict,
-            folder_name=self.folder_name,
-            callback_url=self.callback_url,
-            verbose=self.verbose,
-            simulation_type="tidy3d_smatrix",
-        )
-
-    @cached_property
-    def batch_path(self) -> str:
-        """Path to the batch saved to file."""
-
-        return self.batch._batch_path(path_dir=DEFAULT_DATA_DIR)
-
-    def get_path_dir(self, path_dir: str) -> None:
-        """Check whether the supplied 'path_dir' matches the internal field value."""
-
-        if path_dir not in (DEFAULT_DATA_DIR, self.path_dir):
-            log.warning(
-                f"'ComponentModeler' method was supplied a 'path_dir' of '{path_dir}' "
-                f"when its internal 'path_dir' field was set to '{self.path_dir}'. "
-                "The passed value will be deprecated in later versions. "
-                "Please set the internal 'path_dir' field to the desired value and "
-                "remove the 'path_dir' from the method argument. "
-                f"Using supplied '{path_dir}'."
-            )
-            return path_dir
-
-        return self.path_dir
-
-    @cached_property
-    def _batch_path(self) -> str:
-        """Where we store the batch for this ComponentModeler instance after the run."""
-        hash_str = self._hash_self()
-        return os.path.join(self.path_dir, "batch" + hash_str + ".json")
-
-    def _run_sims(self, path_dir: str = DEFAULT_DATA_DIR) -> BatchData:
-        """Run :class:`Simulations` for each port and return the batch after saving."""
-        batch = self.batch
-        batch_data = batch.run(path_dir=path_dir)
-        batch.to_file(self._batch_path)
-        return batch_data
-
     def _normalization_factor(self, port_source: Port, sim_data: SimulationData) -> complex:
         """Compute the normalization amplitude based on the measured input mode amplitude."""
 
         port_monitor_data = sim_data[port_source.name]
         mode_index = sim_data.simulation.sources[0].mode_index
 
         normalize_amps = port_monitor_data.amps.sel(
@@ -411,32 +292,15 @@
             return max(mode_index for _, mode_index in matrix_elements)
 
         max_mode_index_out = get_max_mode_indices(self.matrix_indices_monitor)
         max_mode_index_in = get_max_mode_indices(self.matrix_indices_source)
 
         return max_mode_index_out, max_mode_index_in
 
-    @cached_property
-    def port_names(self) -> Tuple[List[str], List[str]]:
-        """List of port names for inputs and outputs, respectively."""
-
-        def get_port_names(matrix_elements: Tuple[str, int]) -> List[str]:
-            """Get the port names from a list of (port name, mode index)."""
-            port_names = []
-            for port_name, _ in matrix_elements:
-                if port_name not in port_names:
-                    port_names.append(port_name)
-            return port_names
-
-        port_names_in = get_port_names(self.matrix_indices_source)
-        port_names_out = get_port_names(self.matrix_indices_monitor)
-
-        return port_names_out, port_names_in
-
-    def _construct_smatrix(self, batch_data: BatchData) -> SMatrixDataArray:
+    def _construct_smatrix(self, batch_data: BatchData) -> ModalPortDataArray:
         """Post process `BatchData` to generate scattering matrix."""
 
         max_mode_index_out, max_mode_index_in = self.max_mode_index
         num_modes_out = max_mode_index_out + 1
         num_modes_in = max_mode_index_in + 1
         port_names_out, port_names_in = self.port_names
 
@@ -447,15 +311,15 @@
         coords = dict(
             port_out=port_names_out,
             port_in=port_names_in,
             mode_index_out=range(num_modes_out),
             mode_index_in=range(num_modes_in),
             f=np.array(self.freqs),
         )
-        s_matrix = SMatrixDataArray(values, coords=coords)
+        s_matrix = ModalPortDataArray(values, coords=coords)
 
         # loop through source ports
         for col_index in self.matrix_indices_run_sim:
             port_name_in, mode_index_in = col_index
             port_in = self.get_port_by_name(port_name=port_name_in)
 
             sim_data = batch_data[self._task_name(port=port_in, mode_index=mode_index_in)]
@@ -499,21 +363,7 @@
                 mode_index_in=mode_index_in_to,
                 port_out=port_out_to,
                 mode_index_out=mode_index_out_to,
             )
             s_matrix.loc[coords_to] = mult_by * s_matrix.loc[coords_from].values
 
         return s_matrix
-
-    def run(self, path_dir: str = DEFAULT_DATA_DIR) -> SMatrixDataArray:
-        """Solves for the scattering matrix of the system."""
-        path_dir = self.get_path_dir(path_dir)
-
-        batch_data = self._run_sims(path_dir=path_dir)
-        return self._construct_smatrix(batch_data=batch_data)
-
-    def load(self, path_dir: str = DEFAULT_DATA_DIR) -> SMatrixDataArray:
-        """Load a scattering matrix from saved :class:`BatchData` object."""
-        path_dir = self.get_path_dir(path_dir)
-
-        batch_data = BatchData.load(path_dir=path_dir)
-        return self._construct_smatrix(batch_data=batch_data)
```

### Comparing `tidy3d-2.6.4/tidy3d/plugins/waveguide/rectangular_dielectric.py` & `tidy3d-2.7.0rc1/tidy3d/plugins/waveguide/rectangular_dielectric.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/schema.json` & `tidy3d-2.7.0rc1/tidy3d/schema.json`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 {
   "title": "Simulation",
-  "description": "Custom implementation of Maxwell\u2019s equations which represents the physical model to be solved using the FDTD\nmethod.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nmedium : Union[Medium, AnisotropicMedium, PECMedium, PoleResidue, Sellmeier, Lorentz, Debye, Drude, FullyAnisotropicMedium, CustomMedium, CustomPoleResidue, CustomSellmeier, CustomLorentz, CustomDebye, CustomDrude, CustomAnisotropicMedium, PerturbationMedium, PerturbationPoleResidue] = Medium(name=None, frequency_range=None, allow_gain=False, nonlinear_spec=None, modulation_spec=None, heat_spec=None, type='Medium', permittivity=1.0, conductivity=0.0)\n    Background medium of simulation, defaults to vacuum if not specified.\nstructures : Tuple[Structure, ...] = ()\n    Tuple of structures present in simulation. Note: Structures defined later in this list override the simulation material properties in regions of spatial overlap.\nsymmetry : Tuple[Literal[0, -1, 1], Literal[0, -1, 1], Literal[0, -1, 1]] = (0, 0, 0)\n    Tuple of integers defining reflection symmetry across a plane bisecting the simulation domain normal to the x-, y-, and z-axis at the simulation center of each axis, respectively. Each element can be ``0`` (no symmetry), ``1`` (even, i.e. 'PMC' symmetry) or ``-1`` (odd, i.e. 'PEC' symmetry). Note that the vectorial nature of the fields must be taken into account to correctly determine the symmetry value.\nsources : Tuple[Annotated[Union[tidy3d.components.source.UniformCurrentSource, tidy3d.components.source.PointDipole, tidy3d.components.source.GaussianBeam, tidy3d.components.source.AstigmaticGaussianBeam, tidy3d.components.source.ModeSource, tidy3d.components.source.PlaneWave, tidy3d.components.source.CustomFieldSource, tidy3d.components.source.CustomCurrentSource, tidy3d.components.source.TFSF], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})], ...] = ()\n    Tuple of electric current sources injecting fields into the simulation.\nboundary_spec : BoundarySpec = BoundarySpec(x=Boundary(plus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)),, minus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)),, type='Boundary'), y=Boundary(plus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)),, minus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)),, type='Boundary'), z=Boundary(plus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)),, minus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)),, type='Boundary'), type='BoundarySpec')\n    Specification of boundary conditions along each dimension. If ``None``, PML boundary conditions are applied on all sides.\nmonitors : Tuple[Annotated[Union[tidy3d.components.monitor.FieldMonitor, tidy3d.components.monitor.FieldTimeMonitor, tidy3d.components.monitor.PermittivityMonitor, tidy3d.components.monitor.FluxMonitor, tidy3d.components.monitor.FluxTimeMonitor, tidy3d.components.monitor.ModeMonitor, tidy3d.components.monitor.ModeSolverMonitor, tidy3d.components.monitor.FieldProjectionAngleMonitor, tidy3d.components.monitor.FieldProjectionCartesianMonitor, tidy3d.components.monitor.FieldProjectionKSpaceMonitor, tidy3d.components.monitor.DiffractionMonitor], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})], ...] = ()\n    Tuple of monitors in the simulation. Note: monitor names are used to access data after simulation is run.\ngrid_spec : GridSpec = GridSpec(grid_x=AutoGrid(type='AutoGrid',, min_steps_per_wvl=10.0,, max_scale=1.4,, dl_min=0.0,, mesher=GradedMesher(type='GradedMesher')), grid_y=AutoGrid(type='AutoGrid',, min_steps_per_wvl=10.0,, max_scale=1.4,, dl_min=0.0,, mesher=GradedMesher(type='GradedMesher')), grid_z=AutoGrid(type='AutoGrid',, min_steps_per_wvl=10.0,, max_scale=1.4,, dl_min=0.0,, mesher=GradedMesher(type='GradedMesher')), wavelength=None, override_structures=(), type='GridSpec')\n    Specifications for the simulation grid along each of the three directions.\nversion : str = 2.6.4\n    String specifying the front end version number.\ncourant : ConstrainedFloatValue = 0.99\n    Courant stability factor, controls time step to spatial step ratio. Lower values lead to more stable simulations for dispersive materials, but result in longer simulation times. This factor is normalized to no larger than 1 when CFL stability condition is met in 3D.\nnormalize_index : Optional[NonNegativeInt] = 0\n    Index of the source in the tuple of sources whose spectrum will be used to normalize the frequency-dependent data. If ``None``, the raw field data is returned unnormalized.\nshutoff : NonNegativeFloat = 1e-05\n    Ratio of the instantaneous integrated E-field intensity to the maximum value at which the simulation will automatically terminate time stepping. Used to prevent extraneous run time of simulations with fully decayed fields. Set to ``0`` to disable this feature.\nsubpixel : bool = True\n    If ``True``, uses subpixel averaging of the permittivity based on structure definition, resulting in much higher accuracy for a given grid size.\nrun_time : PositiveFloat\n    [units = sec].  Total electromagnetic evolution time in seconds. Note: If simulation 'shutoff' is specified, simulation will terminate early when shutoff condition met. \n\nNotes\n-----\n\n    A ``Simulation`` defines a custom implementation of Maxwell's equations which represents the physical model\n    to be solved using `the Finite-Difference Time-Domain (FDTD) method\n    <https://www.flexcompute.com/fdtd101/Lecture-1-Introduction-to-FDTD-Simulation/>`_. ``tidy3d`` simulations\n    run very quickly in the cloud through GPU parallelization.\n\n    .. image:: ../../_static/img/field_update_fdtd.png\n        :width: 50%\n        :align: left\n\n    FDTD is a method for simulating the interaction of electromagnetic waves with structures and materials. It is\n    the most widely used method in photonics design. The Maxwell's\n    equations implemented in the ``Simulation`` are solved per time-step in the order shown in this image.\n\n    The simplified input to FDTD solver consists of the permittivity distribution defined by :attr:`structures`\n    which describe the device and :attr:`sources` of electromagnetic excitation. This information is used to\n    computate the time dynamics of the electric and magnetic fields in this system. From these time-domain\n    results, frequency-domain information of the simulation can also be extracted, and used for device design and\n    optimization.\n\n    If you are new to the FDTD method, we recommend you get started with the `FDTD 101 Lecture Series\n    <https://www.flexcompute.com/tidy3d/learning-center/fdtd101/>`_\n\n    **Dimensions Selection**\n\n    By default, simulations are defined as 3D. To make the simulation 2D, we can just set the simulation\n    :attr:`size` in one of the dimensions to be 0. However, note that we still have to define a grid size (eg.\n    ``tidy3d.Simulation(size=[size_x, size_y, 0])``) and specify a periodic boundary condition in that direction.\n\n    .. TODO sort out inheritance problem https://aware-moon.cloudvent.net/tidy3d/examples/notebooks/RingResonator/\n\n    See further parameter explanations below.\n\nExample\n-------\n>>> from tidy3d import Sphere, Cylinder, PolySlab\n>>> from tidy3d import UniformCurrentSource, GaussianPulse\n>>> from tidy3d import FieldMonitor, FluxMonitor\n>>> from tidy3d import GridSpec, AutoGrid\n>>> from tidy3d import BoundarySpec, Boundary\n>>> from tidy3d import Medium\n>>> sim = Simulation(\n...     size=(3.0, 3.0, 3.0),\n...     grid_spec=GridSpec(\n...         grid_x = AutoGrid(min_steps_per_wvl = 20),\n...         grid_y = AutoGrid(min_steps_per_wvl = 20),\n...         grid_z = AutoGrid(min_steps_per_wvl = 20)\n...     ),\n...     run_time=40e-11,\n...     structures=[\n...         Structure(\n...             geometry=Box(size=(1, 1, 1), center=(0, 0, 0)),\n...             medium=Medium(permittivity=2.0),\n...         ),\n...     ],\n...     sources=[\n...         UniformCurrentSource(\n...             size=(0, 0, 0),\n...             center=(0, 0.5, 0),\n...             polarization=\"Hx\",\n...             source_time=GaussianPulse(\n...                 freq0=2e14,\n...                 fwidth=4e13,\n...             ),\n...         )\n...     ],\n...     monitors=[\n...         FluxMonitor(size=(1, 1, 0), center=(0, 0, 0), freqs=[2e14, 2.5e14], name='flux'),\n...     ],\n...     symmetry=(0, 0, 0),\n...     boundary_spec=BoundarySpec(\n...         x = Boundary.pml(num_layers=20),\n...         y = Boundary.pml(num_layers=30),\n...         z = Boundary.periodic(),\n...     ),\n...     shutoff=1e-6,\n...     courant=0.8,\n...     subpixel=False,\n... )\n\nSee Also\n--------\n\n**Notebooks:**\n    * `Quickstart <../../notebooks/StartHere.html>`_: Usage in a basic simulation flow.\n    * `Using automatic nonuniform meshing <../../notebooks/AutoGrid.html>`_\n    * See nearly all notebooks for :class:`Simulation` applications.\n\n**Lectures:**\n    * `Introduction to FDTD Simulation <https://www.flexcompute.com/fdtd101/Lecture-1-Introduction-to-FDTD-Simulation/#presentation-slides>`_: Usage in a basic simulation flow.\n    * `Prelude to Integrated Photonics Simulation: Mode Injection <https://www.flexcompute.com/fdtd101/Lecture-4-Prelude-to-Integrated-Photonics-Simulation-Mode-Injection/>`_\n\n**GUI:**\n    * `FDTD Walkthrough <https://www.flexcompute.com/tidy3d/learning-center/tidy3d-gui/Lecture-1-FDTD-Walkthrough/#presentation-slides>`_",
+  "description": "Custom implementation of Maxwell\u2019s equations which represents the physical model to be solved using the FDTD\nmethod.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nmedium : Union[Medium, AnisotropicMedium, PECMedium, PoleResidue, Sellmeier, Lorentz, Debye, Drude, FullyAnisotropicMedium, CustomMedium, CustomPoleResidue, CustomSellmeier, CustomLorentz, CustomDebye, CustomDrude, CustomAnisotropicMedium, PerturbationMedium, PerturbationPoleResidue] = Medium(name=None, frequency_range=None, allow_gain=False, nonlinear_spec=None, modulation_spec=None, heat_spec=None, type='Medium', permittivity=1.0, conductivity=0.0)\n    Background medium of simulation, defaults to vacuum if not specified.\nstructures : Tuple[Structure, ...] = ()\n    Tuple of structures present in simulation. Note: Structures defined later in this list override the simulation material properties in regions of spatial overlap.\nsymmetry : Tuple[Literal[0, -1, 1], Literal[0, -1, 1], Literal[0, -1, 1]] = (0, 0, 0)\n    Tuple of integers defining reflection symmetry across a plane bisecting the simulation domain normal to the x-, y-, and z-axis at the simulation center of each axis, respectively. Each element can be ``0`` (no symmetry), ``1`` (even, i.e. 'PMC' symmetry) or ``-1`` (odd, i.e. 'PEC' symmetry). Note that the vectorial nature of the fields must be taken into account to correctly determine the symmetry value.\nsources : Tuple[Annotated[Union[tidy3d.components.source.UniformCurrentSource, tidy3d.components.source.PointDipole, tidy3d.components.source.GaussianBeam, tidy3d.components.source.AstigmaticGaussianBeam, tidy3d.components.source.ModeSource, tidy3d.components.source.PlaneWave, tidy3d.components.source.CustomFieldSource, tidy3d.components.source.CustomCurrentSource, tidy3d.components.source.TFSF], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})], ...] = ()\n    Tuple of electric current sources injecting fields into the simulation.\nboundary_spec : BoundarySpec = BoundarySpec(x=Boundary(plus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)),, minus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)),, type='Boundary'), y=Boundary(plus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)),, minus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)),, type='Boundary'), z=Boundary(plus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)),, minus=PML(name=None,, type='PML',, num_layers=12,, parameters=PMLParams(sigma_order=3,, sigma_min=0.0,, sigma_max=1.5,, type='PMLParams',, kappa_order=3,, kappa_min=1.0,, kappa_max=3.0,, alpha_order=1,, alpha_min=0.0,, alpha_max=0.0)),, type='Boundary'), type='BoundarySpec')\n    Specification of boundary conditions along each dimension. If ``None``, PML boundary conditions are applied on all sides.\nmonitors : Tuple[Annotated[Union[tidy3d.components.monitor.FieldMonitor, tidy3d.components.monitor.FieldTimeMonitor, tidy3d.components.monitor.PermittivityMonitor, tidy3d.components.monitor.FluxMonitor, tidy3d.components.monitor.FluxTimeMonitor, tidy3d.components.monitor.ModeMonitor, tidy3d.components.monitor.ModeSolverMonitor, tidy3d.components.monitor.FieldProjectionAngleMonitor, tidy3d.components.monitor.FieldProjectionCartesianMonitor, tidy3d.components.monitor.FieldProjectionKSpaceMonitor, tidy3d.components.monitor.DiffractionMonitor], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})], ...] = ()\n    Tuple of monitors in the simulation. Note: monitor names are used to access data after simulation is run.\ngrid_spec : GridSpec = GridSpec(grid_x=AutoGrid(type='AutoGrid',, min_steps_per_wvl=10.0,, max_scale=1.4,, dl_min=0.0,, mesher=GradedMesher(type='GradedMesher')), grid_y=AutoGrid(type='AutoGrid',, min_steps_per_wvl=10.0,, max_scale=1.4,, dl_min=0.0,, mesher=GradedMesher(type='GradedMesher')), grid_z=AutoGrid(type='AutoGrid',, min_steps_per_wvl=10.0,, max_scale=1.4,, dl_min=0.0,, mesher=GradedMesher(type='GradedMesher')), wavelength=None, override_structures=(), type='GridSpec')\n    Specifications for the simulation grid along each of the three directions.\nversion : str = 2.7.0rc1\n    String specifying the front end version number.\nlumped_elements : Tuple[LumpedResistor, ...] = ()\n    Tuple of lumped elements in the simulation. Note: only :class:`tidy3d.LumpedResistor` is supported currently.\nsubpixel : bool = True\n    If ``True``, uses subpixel averaging of the permittivity based on structure definition, resulting in much higher accuracy for a given grid size.\ncourant : ConstrainedFloatValue = 0.99\n    Courant stability factor, controls time step to spatial step ratio. Lower values lead to more stable simulations for dispersive materials, but result in longer simulation times. This factor is normalized to no larger than 1 when CFL stability condition is met in 3D.\nnormalize_index : Optional[NonNegativeInt] = 0\n    Index of the source in the tuple of sources whose spectrum will be used to normalize the frequency-dependent data. If ``None``, the raw field data is returned unnormalized.\nshutoff : NonNegativeFloat = 1e-05\n    Ratio of the instantaneous integrated E-field intensity to the maximum value at which the simulation will automatically terminate time stepping. Used to prevent extraneous run time of simulations with fully decayed fields. Set to ``0`` to disable this feature.\npec_conformal_mesh_spec : Union[BenklerConformalMeshSpec, StaircasingConformalMeshSpec, HeuristicConformalMeshSpec] = StaircasingConformalMeshSpec(type='StaircasingConformalMeshSpec')\n    Conformal mesh specifications applied to PEC strucures.\nrun_time : PositiveFloat\n    [units = sec].  Total electromagnetic evolution time in seconds. Note: If simulation 'shutoff' is specified, simulation will terminate early when shutoff condition met. \n\nNotes\n-----\n\n    A ``Simulation`` defines a custom implementation of Maxwell's equations which represents the physical model\n    to be solved using `the Finite-Difference Time-Domain (FDTD) method\n    <https://www.flexcompute.com/fdtd101/Lecture-1-Introduction-to-FDTD-Simulation/>`_. ``tidy3d`` simulations\n    run very quickly in the cloud through GPU parallelization.\n\n    .. image:: ../../_static/img/field_update_fdtd.png\n        :width: 50%\n        :align: left\n\n    FDTD is a method for simulating the interaction of electromagnetic waves with structures and materials. It is\n    the most widely used method in photonics design. The Maxwell's\n    equations implemented in the ``Simulation`` are solved per time-step in the order shown in this image.\n\n    The simplified input to FDTD solver consists of the permittivity distribution defined by :attr:`structures`\n    which describe the device and :attr:`sources` of electromagnetic excitation. This information is used to\n    computate the time dynamics of the electric and magnetic fields in this system. From these time-domain\n    results, frequency-domain information of the simulation can also be extracted, and used for device design and\n    optimization.\n\n    If you are new to the FDTD method, we recommend you get started with the `FDTD 101 Lecture Series\n    <https://www.flexcompute.com/tidy3d/learning-center/fdtd101/>`_\n\n    **Dimensions Selection**\n\n    By default, simulations are defined as 3D. To make the simulation 2D, we can just set the simulation\n    :attr:`size` in one of the dimensions to be 0. However, note that we still have to define a grid size (eg.\n    ``tidy3d.Simulation(size=[size_x, size_y, 0])``) and specify a periodic boundary condition in that direction.\n\n    .. TODO sort out inheritance problem https://aware-moon.cloudvent.net/tidy3d/examples/notebooks/RingResonator/\n\n    See further parameter explanations below.\n\nExample\n-------\n>>> from tidy3d import Sphere, Cylinder, PolySlab\n>>> from tidy3d import UniformCurrentSource, GaussianPulse\n>>> from tidy3d import FieldMonitor, FluxMonitor\n>>> from tidy3d import GridSpec, AutoGrid\n>>> from tidy3d import BoundarySpec, Boundary\n>>> from tidy3d import Medium\n>>> sim = Simulation(\n...     size=(3.0, 3.0, 3.0),\n...     grid_spec=GridSpec(\n...         grid_x = AutoGrid(min_steps_per_wvl = 20),\n...         grid_y = AutoGrid(min_steps_per_wvl = 20),\n...         grid_z = AutoGrid(min_steps_per_wvl = 20)\n...     ),\n...     run_time=40e-11,\n...     structures=[\n...         Structure(\n...             geometry=Box(size=(1, 1, 1), center=(0, 0, 0)),\n...             medium=Medium(permittivity=2.0),\n...         ),\n...     ],\n...     sources=[\n...         UniformCurrentSource(\n...             size=(0, 0, 0),\n...             center=(0, 0.5, 0),\n...             polarization=\"Hx\",\n...             source_time=GaussianPulse(\n...                 freq0=2e14,\n...                 fwidth=4e13,\n...             ),\n...         )\n...     ],\n...     monitors=[\n...         FluxMonitor(size=(1, 1, 0), center=(0, 0, 0), freqs=[2e14, 2.5e14], name='flux'),\n...     ],\n...     symmetry=(0, 0, 0),\n...     boundary_spec=BoundarySpec(\n...         x = Boundary.pml(num_layers=20),\n...         y = Boundary.pml(num_layers=30),\n...         z = Boundary.periodic(),\n...     ),\n...     shutoff=1e-6,\n...     courant=0.8,\n...     subpixel=False,\n... )\n\nSee Also\n--------\n\n**Notebooks:**\n    * `Quickstart <../../notebooks/StartHere.html>`_: Usage in a basic simulation flow.\n    * `Using automatic nonuniform meshing <../../notebooks/AutoGrid.html>`_\n    * See nearly all notebooks for :class:`Simulation` applications.\n\n**Lectures:**\n    * `Introduction to FDTD Simulation <https://www.flexcompute.com/fdtd101/Lecture-1-Introduction-to-FDTD-Simulation/#presentation-slides>`_: Usage in a basic simulation flow.\n    * `Prelude to Integrated Photonics Simulation: Mode Injection <https://www.flexcompute.com/fdtd101/Lecture-4-Prelude-to-Integrated-Photonics-Simulation-Mode-Injection/>`_\n\n**GUI:**\n    * `FDTD Walkthrough <https://www.flexcompute.com/tidy3d/learning-center/tidy3d-gui/Lecture-1-FDTD-Walkthrough/#presentation-slides>`_",
   "type": "object",
   "properties": {
     "type": {
       "title": "Type",
       "default": "Simulation",
       "enum": [
         "Simulation"
@@ -471,17 +471,32 @@
           "$ref": "#/definitions/GridSpec"
         }
       ]
     },
     "version": {
       "title": "Version",
       "description": "String specifying the front end version number.",
-      "default": "2.6.4",
+      "default": "2.7.0rc1",
       "type": "string"
     },
+    "lumped_elements": {
+      "title": "Lumped Elements",
+      "description": "Tuple of lumped elements in the simulation. Note: only :class:`tidy3d.LumpedResistor` is supported currently.",
+      "default": [],
+      "type": "array",
+      "items": {
+        "$ref": "#/definitions/LumpedResistor"
+      }
+    },
+    "subpixel": {
+      "title": "Subpixel Averaging",
+      "description": "If ``True``, uses subpixel averaging of the permittivity based on structure definition, resulting in much higher accuracy for a given grid size.",
+      "default": true,
+      "type": "boolean"
+    },
     "courant": {
       "title": "Courant Factor",
       "description": "Courant stability factor, controls time step to spatial step ratio. Lower values lead to more stable simulations for dispersive materials, but result in longer simulation times. This factor is normalized to no larger than 1 when CFL stability condition is met in 3D.",
       "default": 0.99,
       "exclusiveMinimum": 0.0,
       "maximum": 1.0,
       "type": "number"
@@ -496,19 +511,39 @@
     "shutoff": {
       "title": "Shutoff Condition",
       "description": "Ratio of the instantaneous integrated E-field intensity to the maximum value at which the simulation will automatically terminate time stepping. Used to prevent extraneous run time of simulations with fully decayed fields. Set to ``0`` to disable this feature.",
       "default": 1e-05,
       "minimum": 0,
       "type": "number"
     },
-    "subpixel": {
-      "title": "Subpixel Averaging",
-      "description": "If ``True``, uses subpixel averaging of the permittivity based on structure definition, resulting in much higher accuracy for a given grid size.",
-      "default": true,
-      "type": "boolean"
+    "pec_conformal_mesh_spec": {
+      "title": "Conformal mesh specifications",
+      "description": "Conformal mesh specifications applied to PEC strucures.",
+      "default": {
+        "type": "StaircasingConformalMeshSpec"
+      },
+      "discriminator": {
+        "propertyName": "type",
+        "mapping": {
+          "BenklerConformalMeshSpec": "#/definitions/BenklerConformalMeshSpec",
+          "StaircasingConformalMeshSpec": "#/definitions/StaircasingConformalMeshSpec",
+          "HeuristicConformalMeshSpec": "#/definitions/HeuristicConformalMeshSpec"
+        }
+      },
+      "oneOf": [
+        {
+          "$ref": "#/definitions/BenklerConformalMeshSpec"
+        },
+        {
+          "$ref": "#/definitions/StaircasingConformalMeshSpec"
+        },
+        {
+          "$ref": "#/definitions/HeuristicConformalMeshSpec"
+        }
+      ]
     },
     "run_time": {
       "title": "Run Time",
       "description": "Total electromagnetic evolution time in seconds. Note: If simulation 'shutoff' is specified, simulation will terminate early when shutoff condition met. ",
       "units": "sec",
       "exclusiveMinimum": 0,
       "type": "number"
@@ -2275,17 +2310,160 @@
       "required": [
         "eps_xx",
         "eps_yy",
         "eps_zz"
       ],
       "additionalProperties": false
     },
+    "TriangularGridDataset": {
+      "title": "TriangularGridDataset",
+      "description": "Dataset for storing triangular grid data. Data values are associated with the nodes of\nthe grid.\n\nParameters\n----------\npoints : PointDataArray\n    Coordinates of points composing the unstructured grid.\nvalues : IndexedDataArray\n    Values stored at the grid points.\ncells : CellDataArray\n    Cells composing the unstructured grid specified as connections between grid points.\nnormal_axis : Literal[0, 1, 2]\n    Orientation of the grid.\nnormal_pos : float\n    Coordinate of the grid along the normal direction.\n\nNote\n----\nTo use full functionality of unstructured datasets one must install ``vtk`` package (``pip\ninstall tidy3d[vtk]`` or ``pip install vtk``). Otherwise the functionality of unstructured\ndatasets is limited to creation, writing to/loading from a file, and arithmetic manipulations.\n\nExample\n-------\n>>> tri_grid_points = PointDataArray(\n...     [[0.0, 0.0], [1.0, 0.0], [0.0, 1.0], [1.0, 1.0]],\n...     coords=dict(index=np.arange(4), axis=np.arange(2)),\n... )\n>>>\n>>> tri_grid_cells = CellDataArray(\n...     [[0, 1, 2], [1, 2, 3]],\n...     coords=dict(cell_index=np.arange(2), vertex_index=np.arange(3)),\n... )\n>>>\n>>> tri_grid_values = IndexedDataArray(\n...     [1.0, 2.0, 3.0, 4.0], coords=dict(index=np.arange(4)),\n... )\n>>>\n>>> tri_grid = TriangularGridDataset(\n...     normal_axis=1,\n...     normal_pos=0,\n...     points=tri_grid_points,\n...     cells=tri_grid_cells,\n...     values=tri_grid_values,\n... )",
+      "type": "object",
+      "properties": {
+        "type": {
+          "title": "Type",
+          "default": "TriangularGridDataset",
+          "enum": [
+            "TriangularGridDataset"
+          ],
+          "type": "string"
+        },
+        "points": {
+          "title": "DataArray",
+          "description": "Coordinates of points composing the unstructured grid.",
+          "type": "xr.DataArray",
+          "properties": {
+            "_dims": {
+              "title": "_dims",
+              "type": "Tuple[str, ...]"
+            }
+          },
+          "required": [
+            "_dims"
+          ]
+        },
+        "values": {
+          "title": "DataArray",
+          "description": "Values stored at the grid points.",
+          "type": "xr.DataArray",
+          "properties": {
+            "_dims": {
+              "title": "_dims",
+              "type": "Tuple[str, ...]"
+            }
+          },
+          "required": [
+            "_dims"
+          ]
+        },
+        "cells": {
+          "title": "DataArray",
+          "description": "Cells composing the unstructured grid specified as connections between grid points.",
+          "type": "xr.DataArray",
+          "properties": {
+            "_dims": {
+              "title": "_dims",
+              "type": "Tuple[str, ...]"
+            }
+          },
+          "required": [
+            "_dims"
+          ]
+        },
+        "normal_axis": {
+          "title": "Grid Axis",
+          "description": "Orientation of the grid.",
+          "enum": [
+            0,
+            1,
+            2
+          ],
+          "type": "integer"
+        },
+        "normal_pos": {
+          "title": "Position",
+          "description": "Coordinate of the grid along the normal direction.",
+          "type": "number"
+        }
+      },
+      "required": [
+        "points",
+        "values",
+        "cells",
+        "normal_axis",
+        "normal_pos"
+      ],
+      "additionalProperties": false
+    },
+    "TetrahedralGridDataset": {
+      "title": "TetrahedralGridDataset",
+      "description": "Dataset for storing tetrahedral grid data. Data values are associated with the nodes of\nthe grid.\n\nParameters\n----------\npoints : PointDataArray\n    Coordinates of points composing the unstructured grid.\nvalues : IndexedDataArray\n    Values stored at the grid points.\ncells : CellDataArray\n    Cells composing the unstructured grid specified as connections between grid points.\n\nNote\n----\nTo use full functionality of unstructured datasets one must install ``vtk`` package (``pip\ninstall tidy3d[vtk]`` or ``pip install vtk``). Otherwise the functionality of unstructured\ndatasets is limited to creation, writing to/loading from a file, and arithmetic manipulations.\n\nExample\n-------\n>>> tet_grid_points = PointDataArray(\n...     [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]],\n...     coords=dict(index=np.arange(4), axis=np.arange(3)),\n... )\n>>>\n>>> tet_grid_cells = CellDataArray(\n...     [[0, 1, 2, 3]],\n...     coords=dict(cell_index=np.arange(1), vertex_index=np.arange(4)),\n... )\n>>>\n>>> tet_grid_values = IndexedDataArray(\n...     [1.0, 2.0, 3.0, 4.0], coords=dict(index=np.arange(4)),\n... )\n>>>\n>>> tet_grid = TetrahedralGridDataset(\n...     points=tet_grid_points,\n...     cells=tet_grid_cells,\n...     values=tet_grid_values,\n... )",
+      "type": "object",
+      "properties": {
+        "type": {
+          "title": "Type",
+          "default": "TetrahedralGridDataset",
+          "enum": [
+            "TetrahedralGridDataset"
+          ],
+          "type": "string"
+        },
+        "points": {
+          "title": "DataArray",
+          "description": "Coordinates of points composing the unstructured grid.",
+          "type": "xr.DataArray",
+          "properties": {
+            "_dims": {
+              "title": "_dims",
+              "type": "Tuple[str, ...]"
+            }
+          },
+          "required": [
+            "_dims"
+          ]
+        },
+        "values": {
+          "title": "DataArray",
+          "description": "Values stored at the grid points.",
+          "type": "xr.DataArray",
+          "properties": {
+            "_dims": {
+              "title": "_dims",
+              "type": "Tuple[str, ...]"
+            }
+          },
+          "required": [
+            "_dims"
+          ]
+        },
+        "cells": {
+          "title": "DataArray",
+          "description": "Cells composing the unstructured grid specified as connections between grid points.",
+          "type": "xr.DataArray",
+          "properties": {
+            "_dims": {
+              "title": "_dims",
+              "type": "Tuple[str, ...]"
+            }
+          },
+          "required": [
+            "_dims"
+          ]
+        }
+      },
+      "required": [
+        "points",
+        "values",
+        "cells"
+      ],
+      "additionalProperties": false
+    },
     "CustomMedium": {
       "title": "CustomMedium",
-      "description": ":class:`.Medium` with user-supplied permittivity distribution.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\nsubpixel : bool = False\n    If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.\neps_dataset : Optional[PermittivityDataset] = None\n    [To be deprecated] User-supplied dataset containing complex-valued permittivity as a function of space. Permittivity distribution over the Yee-grid will be interpolated based on ``interp_method``.\npermittivity : Optional[SpatialDataArray] = None\n    [units = None (relative permittivity)].  Spatial profile of relative permittivity.\nconductivity : Optional[SpatialDataArray] = None\n    [units = S/um].  Spatial profile Electric conductivity. Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.\n\nExample\n-------\n>>> Nx, Ny, Nz = 10, 9, 8\n>>> X = np.linspace(-1, 1, Nx)\n>>> Y = np.linspace(-1, 1, Ny)\n>>> Z = np.linspace(-1, 1, Nz)\n>>> coords = dict(x=X, y=Y, z=Z)\n>>> permittivity= SpatialDataArray(np.ones((Nx, Ny, Nz)), coords=coords)\n>>> conductivity= SpatialDataArray(np.ones((Nx, Ny, Nz)), coords=coords)\n>>> dielectric = CustomMedium(permittivity=permittivity, conductivity=conductivity)\n>>> eps = dielectric.eps_model(200e12)",
+      "description": ":class:`.Medium` with user-supplied permittivity distribution.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\nsubpixel : bool = False\n    If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.\neps_dataset : Optional[PermittivityDataset] = None\n    [To be deprecated] User-supplied dataset containing complex-valued permittivity as a function of space. Permittivity distribution over the Yee-grid will be interpolated based on ``interp_method``.\npermittivity : Union[SpatialDataArray, Annotated[Union[tidy3d.components.data.dataset.TriangularGridDataset, tidy3d.components.data.dataset.TetrahedralGridDataset], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})], NoneType] = None\n    [units = None (relative permittivity)].  Spatial profile of relative permittivity.\nconductivity : Union[SpatialDataArray, Annotated[Union[tidy3d.components.data.dataset.TriangularGridDataset, tidy3d.components.data.dataset.TetrahedralGridDataset], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})], NoneType] = None\n    [units = S/um].  Spatial profile Electric conductivity. Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.\n\nExample\n-------\n>>> Nx, Ny, Nz = 10, 9, 8\n>>> X = np.linspace(-1, 1, Nx)\n>>> Y = np.linspace(-1, 1, Ny)\n>>> Z = np.linspace(-1, 1, Nz)\n>>> coords = dict(x=X, y=Y, z=Z)\n>>> permittivity= SpatialDataArray(np.ones((Nx, Ny, Nz)), coords=coords)\n>>> conductivity= SpatialDataArray(np.ones((Nx, Ny, Nz)), coords=coords)\n>>> dielectric = CustomMedium(permittivity=permittivity, conductivity=conductivity)\n>>> eps = dielectric.eps_model(200e12)",
       "type": "object",
       "properties": {
         "name": {
           "title": "Name",
           "description": "Optional unique name for medium.",
           "type": "string"
         },
@@ -2384,49 +2562,79 @@
           "allOf": [
             {
               "$ref": "#/definitions/PermittivityDataset"
             }
           ]
         },
         "permittivity": {
-          "title": "DataArray",
+          "title": "Permittivity",
           "description": "Spatial profile of relative permittivity.",
           "units": "None (relative permittivity)",
-          "type": "xr.DataArray",
-          "properties": {
-            "_dims": {
-              "title": "_dims",
-              "type": "Tuple[str, ...]"
+          "anyOf": [
+            {
+              "title": "DataArray",
+              "type": "xr.DataArray",
+              "properties": {
+                "_dims": {
+                  "title": "_dims",
+                  "type": "Tuple[str, ...]"
+                }
+              },
+              "required": [
+                "_dims"
+              ]
+            },
+            {
+              "oneOf": [
+                {
+                  "$ref": "#/definitions/TriangularGridDataset"
+                },
+                {
+                  "$ref": "#/definitions/TetrahedralGridDataset"
+                }
+              ]
             }
-          },
-          "required": [
-            "_dims"
           ]
         },
         "conductivity": {
-          "title": "DataArray",
+          "title": "Conductivity",
           "description": "Spatial profile Electric conductivity. Defined such that the imaginary part of the complex permittivity at angular frequency omega is given by conductivity/omega.",
           "units": "S/um",
-          "type": "xr.DataArray",
-          "properties": {
-            "_dims": {
-              "title": "_dims",
-              "type": "Tuple[str, ...]"
+          "anyOf": [
+            {
+              "title": "DataArray",
+              "type": "xr.DataArray",
+              "properties": {
+                "_dims": {
+                  "title": "_dims",
+                  "type": "Tuple[str, ...]"
+                }
+              },
+              "required": [
+                "_dims"
+              ]
+            },
+            {
+              "oneOf": [
+                {
+                  "$ref": "#/definitions/TriangularGridDataset"
+                },
+                {
+                  "$ref": "#/definitions/TetrahedralGridDataset"
+                }
+              ]
             }
-          },
-          "required": [
-            "_dims"
           ]
         }
       },
       "additionalProperties": false
     },
     "CustomPoleResidue": {
       "title": "CustomPoleResidue",
-      "description": "A spatially varying dispersive medium described by the pole-residue pair model.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : SpatialDataArray\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\npoles : Tuple[Tuple[tidy3d.components.data.data_array.SpatialDataArray, tidy3d.components.data.data_array.SpatialDataArray], ...] = ()\n    [units = (rad/sec, rad/sec)].  Tuple of complex-valued (:math:`a_i, c_i`) poles for the model.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\nsubpixel : bool = False\n    If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.\n\nNotes\n-----\n\n    In this method, the frequency-dependent permittivity :math:`\\epsilon(\\omega)` is expressed as a sum of\n    resonant material poles _`[1]`.\n\n    .. math::\n\n        \\epsilon(\\omega) = \\epsilon_\\infty - \\sum_i\n        \\left[\\frac{c_i}{j \\omega + a_i} +\n        \\frac{c_i^*}{j \\omega + a_i^*}\\right]\n\n    For each of these resonant poles identified by the index :math:`i`, an auxiliary differential equation is\n    used to relate the auxiliary current :math:`J_i(t)` to the applied electric field :math:`E(t)`.\n    The sum of all these auxiliary current contributions describes the total dielectric response of the material.\n\n    .. math::\n\n        \\frac{d}{dt} J_i (t) - a_i J_i (t) = \\epsilon_0 c_i \\frac{d}{dt} E (t)\n\n    Hence, the computational cost increases with the number of poles.\n\n    **References**\n\n    .. [1]   M. Han, R.W. Dutton and S. Fan, IEEE Microwave and Wireless Component Letters, 16, 119 (2006).\n\n    .. TODO add links to notebooks using this.\n\nExample\n-------\n>>> x = np.linspace(-1, 1, 5)\n>>> y = np.linspace(-1, 1, 6)\n>>> z = np.linspace(-1, 1, 7)\n>>> coords = dict(x=x, y=y, z=z)\n>>> eps_inf = SpatialDataArray(np.ones((5, 6, 7)), coords=coords)\n>>> a1 = SpatialDataArray(-np.random.random((5, 6, 7)), coords=coords)\n>>> c1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> a2 = SpatialDataArray(-np.random.random((5, 6, 7)), coords=coords)\n>>> c2 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> pole_res = CustomPoleResidue(eps_inf=eps_inf, poles=[(a1, c1), (a2, c2)])\n>>> eps = pole_res.eps_model(200e12)\n\nSee Also\n--------\n\n**Notebooks**\n\n* `Fitting dispersive material models <../../notebooks/Fitting.html>`_\n\n**Lectures**\n\n* `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_",
+      "description": "A spatially varying dispersive medium described by the pole-residue pair model.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : Union[SpatialDataArray, Annotated[Union[tidy3d.components.data.dataset.TriangularGridDataset, tidy3d.components.data.dataset.TetrahedralGridDataset], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})]]\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\npoles : Tuple[Tuple[Union[tidy3d.components.data.data_array.SpatialDataArray, Annotated[Union[tidy3d.components.data.dataset.TriangularGridDataset, tidy3d.components.data.dataset.TetrahedralGridDataset], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})]], Union[tidy3d.components.data.data_array.SpatialDataArray, Annotated[Union[tidy3d.components.data.dataset.TriangularGridDataset, tidy3d.components.data.dataset.TetrahedralGridDataset], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})]]], ...] = ()\n    [units = (rad/sec, rad/sec)].  Tuple of complex-valued (:math:`a_i, c_i`) poles for the model.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\nsubpixel : bool = False\n    If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.\n\nNotes\n-----\n\n    In this method, the frequency-dependent permittivity :math:`\\epsilon(\\omega)` is expressed as a sum of\n    resonant material poles _`[1]`.\n\n    .. math::\n\n        \\epsilon(\\omega) = \\epsilon_\\infty - \\sum_i\n        \\left[\\frac{c_i}{j \\omega + a_i} +\n        \\frac{c_i^*}{j \\omega + a_i^*}\\right]\n\n    For each of these resonant poles identified by the index :math:`i`, an auxiliary differential equation is\n    used to relate the auxiliary current :math:`J_i(t)` to the applied electric field :math:`E(t)`.\n    The sum of all these auxiliary current contributions describes the total dielectric response of the material.\n\n    .. math::\n\n        \\frac{d}{dt} J_i (t) - a_i J_i (t) = \\epsilon_0 c_i \\frac{d}{dt} E (t)\n\n    Hence, the computational cost increases with the number of poles.\n\n    **References**\n\n    .. [1]   M. Han, R.W. Dutton and S. Fan, IEEE Microwave and Wireless Component Letters, 16, 119 (2006).\n\n    .. TODO add links to notebooks using this.\n\nExample\n-------\n>>> x = np.linspace(-1, 1, 5)\n>>> y = np.linspace(-1, 1, 6)\n>>> z = np.linspace(-1, 1, 7)\n>>> coords = dict(x=x, y=y, z=z)\n>>> eps_inf = SpatialDataArray(np.ones((5, 6, 7)), coords=coords)\n>>> a1 = SpatialDataArray(-np.random.random((5, 6, 7)), coords=coords)\n>>> c1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> a2 = SpatialDataArray(-np.random.random((5, 6, 7)), coords=coords)\n>>> c2 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> pole_res = CustomPoleResidue(eps_inf=eps_inf, poles=[(a1, c1), (a2, c2)])\n>>> eps = pole_res.eps_model(200e12)\n\nSee Also\n--------\n\n**Notebooks**\n\n* `Fitting dispersive material models <../../notebooks/Fitting.html>`_\n\n**Lectures**\n\n* `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_",
       "type": "object",
       "properties": {
         "name": {
           "title": "Name",
           "description": "Optional unique name for medium.",
           "type": "string"
         },
@@ -2500,26 +2708,41 @@
           "default": "CustomPoleResidue",
           "enum": [
             "CustomPoleResidue"
           ],
           "type": "string"
         },
         "eps_inf": {
-          "title": "DataArray",
+          "title": "Epsilon at Infinity",
           "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
           "units": "None (relative permittivity)",
-          "type": "xr.DataArray",
-          "properties": {
-            "_dims": {
-              "title": "_dims",
-              "type": "Tuple[str, ...]"
+          "anyOf": [
+            {
+              "title": "DataArray",
+              "type": "xr.DataArray",
+              "properties": {
+                "_dims": {
+                  "title": "_dims",
+                  "type": "Tuple[str, ...]"
+                }
+              },
+              "required": [
+                "_dims"
+              ]
+            },
+            {
+              "oneOf": [
+                {
+                  "$ref": "#/definitions/TriangularGridDataset"
+                },
+                {
+                  "$ref": "#/definitions/TetrahedralGridDataset"
+                }
+              ]
             }
-          },
-          "required": [
-            "_dims"
           ]
         },
         "poles": {
           "title": "Poles",
           "description": "Tuple of complex-valued (:math:`a_i, c_i`) poles for the model.",
           "default": [],
           "units": [
@@ -2529,37 +2752,65 @@
           "type": "array",
           "items": {
             "type": "array",
             "minItems": 2,
             "maxItems": 2,
             "items": [
               {
-                "title": "DataArray",
-                "type": "xr.DataArray",
-                "properties": {
-                  "_dims": {
-                    "title": "_dims",
-                    "type": "Tuple[str, ...]"
+                "anyOf": [
+                  {
+                    "title": "DataArray",
+                    "type": "xr.DataArray",
+                    "properties": {
+                      "_dims": {
+                        "title": "_dims",
+                        "type": "Tuple[str, ...]"
+                      }
+                    },
+                    "required": [
+                      "_dims"
+                    ]
+                  },
+                  {
+                    "oneOf": [
+                      {
+                        "$ref": "#/definitions/TriangularGridDataset"
+                      },
+                      {
+                        "$ref": "#/definitions/TetrahedralGridDataset"
+                      }
+                    ]
                   }
-                },
-                "required": [
-                  "_dims"
                 ]
               },
               {
-                "title": "DataArray",
-                "type": "xr.DataArray",
-                "properties": {
-                  "_dims": {
-                    "title": "_dims",
-                    "type": "Tuple[str, ...]"
+                "anyOf": [
+                  {
+                    "title": "DataArray",
+                    "type": "xr.DataArray",
+                    "properties": {
+                      "_dims": {
+                        "title": "_dims",
+                        "type": "Tuple[str, ...]"
+                      }
+                    },
+                    "required": [
+                      "_dims"
+                    ]
+                  },
+                  {
+                    "oneOf": [
+                      {
+                        "$ref": "#/definitions/TriangularGridDataset"
+                      },
+                      {
+                        "$ref": "#/definitions/TetrahedralGridDataset"
+                      }
+                    ]
                   }
-                },
-                "required": [
-                  "_dims"
                 ]
               }
             ]
           }
         },
         "interp_method": {
           "title": "Interpolation method",
@@ -2581,15 +2832,15 @@
       "required": [
         "eps_inf"
       ],
       "additionalProperties": false
     },
     "CustomSellmeier": {
       "title": "CustomSellmeier",
-      "description": "A spatially varying dispersive medium described by the Sellmeier model.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\ncoeffs : Tuple[Tuple[tidy3d.components.data.data_array.SpatialDataArray, tidy3d.components.data.data_array.SpatialDataArray], ...]\n    [units = (None, um^2)].  List of Sellmeier (:math:`B_i, C_i`) coefficients.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\nsubpixel : bool = False\n    If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.\n\nNotes\n-----\n\n    The frequency-dependence of the refractive index is described by:\n\n    .. math::\n\n        n(\\lambda)^2 = 1 + \\sum_i \\frac{B_i \\lambda^2}{\\lambda^2 - C_i}\n\nExample\n-------\n>>> x = np.linspace(-1, 1, 5)\n>>> y = np.linspace(-1, 1, 6)\n>>> z = np.linspace(-1, 1, 7)\n>>> coords = dict(x=x, y=y, z=z)\n>>> b1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> c1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> sellmeier_medium = CustomSellmeier(coeffs=[(b1,c1),])\n>>> eps = sellmeier_medium.eps_model(200e12)\n\nSee Also\n--------\n\n:class:`Sellmeier`\n    A dispersive medium described by the Sellmeier model.\n\n**Notebooks**\n    * `Fitting dispersive material models <../../notebooks/Fitting.html>`_\n\n**Lectures**\n    * `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_",
+      "description": "A spatially varying dispersive medium described by the Sellmeier model.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\ncoeffs : Tuple[Tuple[Union[tidy3d.components.data.data_array.SpatialDataArray, Annotated[Union[tidy3d.components.data.dataset.TriangularGridDataset, tidy3d.components.data.dataset.TetrahedralGridDataset], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})]], Union[tidy3d.components.data.data_array.SpatialDataArray, Annotated[Union[tidy3d.components.data.dataset.TriangularGridDataset, tidy3d.components.data.dataset.TetrahedralGridDataset], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})]]], ...]\n    [units = (None, um^2)].  List of Sellmeier (:math:`B_i, C_i`) coefficients.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\nsubpixel : bool = False\n    If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.\n\nNotes\n-----\n\n    The frequency-dependence of the refractive index is described by:\n\n    .. math::\n\n        n(\\lambda)^2 = 1 + \\sum_i \\frac{B_i \\lambda^2}{\\lambda^2 - C_i}\n\nExample\n-------\n>>> x = np.linspace(-1, 1, 5)\n>>> y = np.linspace(-1, 1, 6)\n>>> z = np.linspace(-1, 1, 7)\n>>> coords = dict(x=x, y=y, z=z)\n>>> b1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> c1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> sellmeier_medium = CustomSellmeier(coeffs=[(b1,c1),])\n>>> eps = sellmeier_medium.eps_model(200e12)\n\nSee Also\n--------\n\n:class:`Sellmeier`\n    A dispersive medium described by the Sellmeier model.\n\n**Notebooks**\n    * `Fitting dispersive material models <../../notebooks/Fitting.html>`_\n\n**Lectures**\n    * `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_",
       "type": "object",
       "properties": {
         "name": {
           "title": "Name",
           "description": "Optional unique name for medium.",
           "type": "string"
         },
@@ -2676,37 +2927,65 @@
           "type": "array",
           "items": {
             "type": "array",
             "minItems": 2,
             "maxItems": 2,
             "items": [
               {
-                "title": "DataArray",
-                "type": "xr.DataArray",
-                "properties": {
-                  "_dims": {
-                    "title": "_dims",
-                    "type": "Tuple[str, ...]"
+                "anyOf": [
+                  {
+                    "title": "DataArray",
+                    "type": "xr.DataArray",
+                    "properties": {
+                      "_dims": {
+                        "title": "_dims",
+                        "type": "Tuple[str, ...]"
+                      }
+                    },
+                    "required": [
+                      "_dims"
+                    ]
+                  },
+                  {
+                    "oneOf": [
+                      {
+                        "$ref": "#/definitions/TriangularGridDataset"
+                      },
+                      {
+                        "$ref": "#/definitions/TetrahedralGridDataset"
+                      }
+                    ]
                   }
-                },
-                "required": [
-                  "_dims"
                 ]
               },
               {
-                "title": "DataArray",
-                "type": "xr.DataArray",
-                "properties": {
-                  "_dims": {
-                    "title": "_dims",
-                    "type": "Tuple[str, ...]"
+                "anyOf": [
+                  {
+                    "title": "DataArray",
+                    "type": "xr.DataArray",
+                    "properties": {
+                      "_dims": {
+                        "title": "_dims",
+                        "type": "Tuple[str, ...]"
+                      }
+                    },
+                    "required": [
+                      "_dims"
+                    ]
+                  },
+                  {
+                    "oneOf": [
+                      {
+                        "$ref": "#/definitions/TriangularGridDataset"
+                      },
+                      {
+                        "$ref": "#/definitions/TetrahedralGridDataset"
+                      }
+                    ]
                   }
-                },
-                "required": [
-                  "_dims"
                 ]
               }
             ]
           }
         },
         "interp_method": {
           "title": "Interpolation method",
@@ -2728,15 +3007,15 @@
       "required": [
         "coeffs"
       ],
       "additionalProperties": false
     },
     "CustomLorentz": {
       "title": "CustomLorentz",
-      "description": "A spatially varying dispersive medium described by the Lorentz model.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : SpatialDataArray\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : Tuple[Tuple[tidy3d.components.data.data_array.SpatialDataArray, tidy3d.components.data.data_array.SpatialDataArray, tidy3d.components.data.data_array.SpatialDataArray], ...]\n    [units = (None (relative permittivity), Hz, Hz)].  List of (:math:`\\Delta\\epsilon_i, f_i, \\delta_i`) values for model.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\nsubpixel : bool = False\n    If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.\n\nNotes\n-----\n\n    The frequency-dependence of the complex-valued permittivity is described by:\n\n    .. math::\n\n        \\epsilon(f) = \\epsilon_\\infty + \\sum_i\n        \\frac{\\Delta\\epsilon_i f_i^2}{f_i^2 - 2jf\\delta_i - f^2}\n\nExample\n-------\n>>> x = np.linspace(-1, 1, 5)\n>>> y = np.linspace(-1, 1, 6)\n>>> z = np.linspace(-1, 1, 7)\n>>> coords = dict(x=x, y=y, z=z)\n>>> eps_inf = SpatialDataArray(np.ones((5, 6, 7)), coords=coords)\n>>> d_epsilon = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> f = SpatialDataArray(1+np.random.random((5, 6, 7)), coords=coords)\n>>> delta = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> lorentz_medium = CustomLorentz(eps_inf=eps_inf, coeffs=[(d_epsilon,f,delta),])\n>>> eps = lorentz_medium.eps_model(200e12)\n\nSee Also\n--------\n\n:class:`CustomPoleResidue`:\n    A spatially varying dispersive medium described by the pole-residue pair model.\n\n**Notebooks**\n    * `Fitting dispersive material models <../../notebooks/Fitting.html>`_\n\n**Lectures**\n    * `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_",
+      "description": "A spatially varying dispersive medium described by the Lorentz model.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : Union[SpatialDataArray, Annotated[Union[tidy3d.components.data.dataset.TriangularGridDataset, tidy3d.components.data.dataset.TetrahedralGridDataset], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})]]\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : Tuple[Tuple[Union[tidy3d.components.data.data_array.SpatialDataArray, Annotated[Union[tidy3d.components.data.dataset.TriangularGridDataset, tidy3d.components.data.dataset.TetrahedralGridDataset], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})]], Union[tidy3d.components.data.data_array.SpatialDataArray, Annotated[Union[tidy3d.components.data.dataset.TriangularGridDataset, tidy3d.components.data.dataset.TetrahedralGridDataset], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})]], Union[tidy3d.components.data.data_array.SpatialDataArray, Annotated[Union[tidy3d.components.data.dataset.TriangularGridDataset, tidy3d.components.data.dataset.TetrahedralGridDataset], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})]]], ...]\n    [units = (None (relative permittivity), Hz, Hz)].  List of (:math:`\\Delta\\epsilon_i, f_i, \\delta_i`) values for model.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\nsubpixel : bool = False\n    If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.\n\nNotes\n-----\n\n    The frequency-dependence of the complex-valued permittivity is described by:\n\n    .. math::\n\n        \\epsilon(f) = \\epsilon_\\infty + \\sum_i\n        \\frac{\\Delta\\epsilon_i f_i^2}{f_i^2 - 2jf\\delta_i - f^2}\n\nExample\n-------\n>>> x = np.linspace(-1, 1, 5)\n>>> y = np.linspace(-1, 1, 6)\n>>> z = np.linspace(-1, 1, 7)\n>>> coords = dict(x=x, y=y, z=z)\n>>> eps_inf = SpatialDataArray(np.ones((5, 6, 7)), coords=coords)\n>>> d_epsilon = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> f = SpatialDataArray(1+np.random.random((5, 6, 7)), coords=coords)\n>>> delta = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> lorentz_medium = CustomLorentz(eps_inf=eps_inf, coeffs=[(d_epsilon,f,delta),])\n>>> eps = lorentz_medium.eps_model(200e12)\n\nSee Also\n--------\n\n:class:`CustomPoleResidue`:\n    A spatially varying dispersive medium described by the pole-residue pair model.\n\n**Notebooks**\n    * `Fitting dispersive material models <../../notebooks/Fitting.html>`_\n\n**Lectures**\n    * `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_",
       "type": "object",
       "properties": {
         "name": {
           "title": "Name",
           "description": "Optional unique name for medium.",
           "type": "string"
         },
@@ -2810,26 +3089,41 @@
           "default": "CustomLorentz",
           "enum": [
             "CustomLorentz"
           ],
           "type": "string"
         },
         "eps_inf": {
-          "title": "DataArray",
+          "title": "Epsilon at Infinity",
           "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
           "units": "None (relative permittivity)",
-          "type": "xr.DataArray",
-          "properties": {
-            "_dims": {
-              "title": "_dims",
-              "type": "Tuple[str, ...]"
+          "anyOf": [
+            {
+              "title": "DataArray",
+              "type": "xr.DataArray",
+              "properties": {
+                "_dims": {
+                  "title": "_dims",
+                  "type": "Tuple[str, ...]"
+                }
+              },
+              "required": [
+                "_dims"
+              ]
+            },
+            {
+              "oneOf": [
+                {
+                  "$ref": "#/definitions/TriangularGridDataset"
+                },
+                {
+                  "$ref": "#/definitions/TetrahedralGridDataset"
+                }
+              ]
             }
-          },
-          "required": [
-            "_dims"
           ]
         },
         "coeffs": {
           "title": "Coefficients",
           "description": "List of (:math:`\\Delta\\epsilon_i, f_i, \\delta_i`) values for model.",
           "units": [
             "None (relative permittivity)",
@@ -2839,50 +3133,92 @@
           "type": "array",
           "items": {
             "type": "array",
             "minItems": 3,
             "maxItems": 3,
             "items": [
               {
-                "title": "DataArray",
-                "type": "xr.DataArray",
-                "properties": {
-                  "_dims": {
-                    "title": "_dims",
-                    "type": "Tuple[str, ...]"
+                "anyOf": [
+                  {
+                    "title": "DataArray",
+                    "type": "xr.DataArray",
+                    "properties": {
+                      "_dims": {
+                        "title": "_dims",
+                        "type": "Tuple[str, ...]"
+                      }
+                    },
+                    "required": [
+                      "_dims"
+                    ]
+                  },
+                  {
+                    "oneOf": [
+                      {
+                        "$ref": "#/definitions/TriangularGridDataset"
+                      },
+                      {
+                        "$ref": "#/definitions/TetrahedralGridDataset"
+                      }
+                    ]
                   }
-                },
-                "required": [
-                  "_dims"
                 ]
               },
               {
-                "title": "DataArray",
-                "type": "xr.DataArray",
-                "properties": {
-                  "_dims": {
-                    "title": "_dims",
-                    "type": "Tuple[str, ...]"
+                "anyOf": [
+                  {
+                    "title": "DataArray",
+                    "type": "xr.DataArray",
+                    "properties": {
+                      "_dims": {
+                        "title": "_dims",
+                        "type": "Tuple[str, ...]"
+                      }
+                    },
+                    "required": [
+                      "_dims"
+                    ]
+                  },
+                  {
+                    "oneOf": [
+                      {
+                        "$ref": "#/definitions/TriangularGridDataset"
+                      },
+                      {
+                        "$ref": "#/definitions/TetrahedralGridDataset"
+                      }
+                    ]
                   }
-                },
-                "required": [
-                  "_dims"
                 ]
               },
               {
-                "title": "DataArray",
-                "type": "xr.DataArray",
-                "properties": {
-                  "_dims": {
-                    "title": "_dims",
-                    "type": "Tuple[str, ...]"
+                "anyOf": [
+                  {
+                    "title": "DataArray",
+                    "type": "xr.DataArray",
+                    "properties": {
+                      "_dims": {
+                        "title": "_dims",
+                        "type": "Tuple[str, ...]"
+                      }
+                    },
+                    "required": [
+                      "_dims"
+                    ]
+                  },
+                  {
+                    "oneOf": [
+                      {
+                        "$ref": "#/definitions/TriangularGridDataset"
+                      },
+                      {
+                        "$ref": "#/definitions/TetrahedralGridDataset"
+                      }
+                    ]
                   }
-                },
-                "required": [
-                  "_dims"
                 ]
               }
             ]
           }
         },
         "interp_method": {
           "title": "Interpolation method",
@@ -2905,15 +3241,15 @@
         "eps_inf",
         "coeffs"
       ],
       "additionalProperties": false
     },
     "CustomDebye": {
       "title": "CustomDebye",
-      "description": "A spatially varying dispersive medium described by the Debye model.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : SpatialDataArray\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : Tuple[Tuple[tidy3d.components.data.data_array.SpatialDataArray, tidy3d.components.data.data_array.SpatialDataArray], ...]\n    [units = (None (relative permittivity), sec)].  List of (:math:`\\Delta\\epsilon_i, \\tau_i`) values for model.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\nsubpixel : bool = False\n    If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.\n\nNotes\n-----\n\n    The frequency-dependence of the complex-valued permittivity is described by:\n\n    .. math::\n\n        \\epsilon(f) = \\epsilon_\\infty + \\sum_i\n        \\frac{\\Delta\\epsilon_i}{1 - jf\\tau_i}\n\nExample\n-------\n>>> x = np.linspace(-1, 1, 5)\n>>> y = np.linspace(-1, 1, 6)\n>>> z = np.linspace(-1, 1, 7)\n>>> coords = dict(x=x, y=y, z=z)\n>>> eps_inf = SpatialDataArray(1+np.random.random((5, 6, 7)), coords=coords)\n>>> eps1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> tau1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> debye_medium = CustomDebye(eps_inf=eps_inf, coeffs=[(eps1,tau1),])\n>>> eps = debye_medium.eps_model(200e12)\n\nSee Also\n--------\n\n:class:`Debye`\n    A dispersive medium described by the Debye model.\n\n**Notebooks**\n    * `Fitting dispersive material models <../../notebooks/Fitting.html>`_\n\n**Lectures**\n    * `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_",
+      "description": "A spatially varying dispersive medium described by the Debye model.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : Union[SpatialDataArray, Annotated[Union[tidy3d.components.data.dataset.TriangularGridDataset, tidy3d.components.data.dataset.TetrahedralGridDataset], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})]]\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : Tuple[Tuple[Union[tidy3d.components.data.data_array.SpatialDataArray, Annotated[Union[tidy3d.components.data.dataset.TriangularGridDataset, tidy3d.components.data.dataset.TetrahedralGridDataset], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})]], Union[tidy3d.components.data.data_array.SpatialDataArray, Annotated[Union[tidy3d.components.data.dataset.TriangularGridDataset, tidy3d.components.data.dataset.TetrahedralGridDataset], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})]]], ...]\n    [units = (None (relative permittivity), sec)].  List of (:math:`\\Delta\\epsilon_i, \\tau_i`) values for model.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\nsubpixel : bool = False\n    If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.\n\nNotes\n-----\n\n    The frequency-dependence of the complex-valued permittivity is described by:\n\n    .. math::\n\n        \\epsilon(f) = \\epsilon_\\infty + \\sum_i\n        \\frac{\\Delta\\epsilon_i}{1 - jf\\tau_i}\n\nExample\n-------\n>>> x = np.linspace(-1, 1, 5)\n>>> y = np.linspace(-1, 1, 6)\n>>> z = np.linspace(-1, 1, 7)\n>>> coords = dict(x=x, y=y, z=z)\n>>> eps_inf = SpatialDataArray(1+np.random.random((5, 6, 7)), coords=coords)\n>>> eps1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> tau1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> debye_medium = CustomDebye(eps_inf=eps_inf, coeffs=[(eps1,tau1),])\n>>> eps = debye_medium.eps_model(200e12)\n\nSee Also\n--------\n\n:class:`Debye`\n    A dispersive medium described by the Debye model.\n\n**Notebooks**\n    * `Fitting dispersive material models <../../notebooks/Fitting.html>`_\n\n**Lectures**\n    * `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_",
       "type": "object",
       "properties": {
         "name": {
           "title": "Name",
           "description": "Optional unique name for medium.",
           "type": "string"
         },
@@ -2987,26 +3323,41 @@
           "default": "CustomDebye",
           "enum": [
             "CustomDebye"
           ],
           "type": "string"
         },
         "eps_inf": {
-          "title": "DataArray",
+          "title": "Epsilon at Infinity",
           "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
           "units": "None (relative permittivity)",
-          "type": "xr.DataArray",
-          "properties": {
-            "_dims": {
-              "title": "_dims",
-              "type": "Tuple[str, ...]"
+          "anyOf": [
+            {
+              "title": "DataArray",
+              "type": "xr.DataArray",
+              "properties": {
+                "_dims": {
+                  "title": "_dims",
+                  "type": "Tuple[str, ...]"
+                }
+              },
+              "required": [
+                "_dims"
+              ]
+            },
+            {
+              "oneOf": [
+                {
+                  "$ref": "#/definitions/TriangularGridDataset"
+                },
+                {
+                  "$ref": "#/definitions/TetrahedralGridDataset"
+                }
+              ]
             }
-          },
-          "required": [
-            "_dims"
           ]
         },
         "coeffs": {
           "title": "Coefficients",
           "description": "List of (:math:`\\Delta\\epsilon_i, \\tau_i`) values for model.",
           "units": [
             "None (relative permittivity)",
@@ -3015,37 +3366,65 @@
           "type": "array",
           "items": {
             "type": "array",
             "minItems": 2,
             "maxItems": 2,
             "items": [
               {
-                "title": "DataArray",
-                "type": "xr.DataArray",
-                "properties": {
-                  "_dims": {
-                    "title": "_dims",
-                    "type": "Tuple[str, ...]"
+                "anyOf": [
+                  {
+                    "title": "DataArray",
+                    "type": "xr.DataArray",
+                    "properties": {
+                      "_dims": {
+                        "title": "_dims",
+                        "type": "Tuple[str, ...]"
+                      }
+                    },
+                    "required": [
+                      "_dims"
+                    ]
+                  },
+                  {
+                    "oneOf": [
+                      {
+                        "$ref": "#/definitions/TriangularGridDataset"
+                      },
+                      {
+                        "$ref": "#/definitions/TetrahedralGridDataset"
+                      }
+                    ]
                   }
-                },
-                "required": [
-                  "_dims"
                 ]
               },
               {
-                "title": "DataArray",
-                "type": "xr.DataArray",
-                "properties": {
-                  "_dims": {
-                    "title": "_dims",
-                    "type": "Tuple[str, ...]"
+                "anyOf": [
+                  {
+                    "title": "DataArray",
+                    "type": "xr.DataArray",
+                    "properties": {
+                      "_dims": {
+                        "title": "_dims",
+                        "type": "Tuple[str, ...]"
+                      }
+                    },
+                    "required": [
+                      "_dims"
+                    ]
+                  },
+                  {
+                    "oneOf": [
+                      {
+                        "$ref": "#/definitions/TriangularGridDataset"
+                      },
+                      {
+                        "$ref": "#/definitions/TetrahedralGridDataset"
+                      }
+                    ]
                   }
-                },
-                "required": [
-                  "_dims"
                 ]
               }
             ]
           }
         },
         "interp_method": {
           "title": "Interpolation method",
@@ -3068,15 +3447,15 @@
         "eps_inf",
         "coeffs"
       ],
       "additionalProperties": false
     },
     "CustomDrude": {
       "title": "CustomDrude",
-      "description": "A spatially varying dispersive medium described by the Drude model.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : SpatialDataArray\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : Tuple[Tuple[tidy3d.components.data.data_array.SpatialDataArray, tidy3d.components.data.data_array.SpatialDataArray], ...]\n    [units = (Hz, Hz)].  List of (:math:`f_i, \\delta_i`) values for model.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\nsubpixel : bool = False\n    If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.\n\n\nNotes\n-----\n\n    The frequency-dependence of the complex-valued permittivity is described by:\n\n    .. math::\n\n        \\epsilon(f) = \\epsilon_\\infty - \\sum_i\n        \\frac{ f_i^2}{f^2 + jf\\delta_i}\n\nExample\n-------\n>>> x = np.linspace(-1, 1, 5)\n>>> y = np.linspace(-1, 1, 6)\n>>> z = np.linspace(-1, 1, 7)\n>>> coords = dict(x=x, y=y, z=z)\n>>> eps_inf = SpatialDataArray(np.ones((5, 6, 7)), coords=coords)\n>>> f1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> delta1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> drude_medium = CustomDrude(eps_inf=eps_inf, coeffs=[(f1,delta1),])\n>>> eps = drude_medium.eps_model(200e12)\n\nSee Also\n--------\n\n:class:`Drude`:\n    A dispersive medium described by the Drude model.\n\n**Notebooks**\n    * `Fitting dispersive material models <../../notebooks/Fitting.html>`_\n\n**Lectures**\n    * `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_",
+      "description": "A spatially varying dispersive medium described by the Drude model.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional unique name for medium.\nfrequency_range : Optional[Tuple[float, float]] = None\n    [units = (Hz, Hz)].  Optional range of validity for the medium.\nallow_gain : bool = False\n    Allow the medium to be active. Caution: simulations with a gain medium are unstable, and are likely to diverge.Simulations where 'allow_gain' is set to 'True' will still be charged even if diverged. Monitor data up to the divergence point will still be returned and can be useful in some cases.\nnonlinear_spec : Union[NonlinearSpec, NonlinearSusceptibility] = None\n    Nonlinear spec applied on top of the base medium properties.\nmodulation_spec : Optional[ModulationSpec] = None\n    Modulation spec applied on top of the base medium properties.\nheat_spec : Union[FluidSpec, SolidSpec, NoneType] = None\n    Specification of the medium heat properties. They are used for solving the heat equation via the ``HeatSimulation`` interface. Such simulations can be used for investigating the influence of heat propagation on the properties of optical systems. Once the temperature distribution in the system is found using ``HeatSimulation`` object, ``Simulation.perturbed_mediums_copy()`` can be used to convert mediums with perturbation models defined into spatially dependent custom mediums. Otherwise, the ``heat_spec`` does not directly affect the running of an optical ``Simulation``.\neps_inf : Union[SpatialDataArray, Annotated[Union[tidy3d.components.data.dataset.TriangularGridDataset, tidy3d.components.data.dataset.TetrahedralGridDataset], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})]]\n    [units = None (relative permittivity)].  Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).\ncoeffs : Tuple[Tuple[Union[tidy3d.components.data.data_array.SpatialDataArray, Annotated[Union[tidy3d.components.data.dataset.TriangularGridDataset, tidy3d.components.data.dataset.TetrahedralGridDataset], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})]], Union[tidy3d.components.data.data_array.SpatialDataArray, Annotated[Union[tidy3d.components.data.dataset.TriangularGridDataset, tidy3d.components.data.dataset.TetrahedralGridDataset], FieldInfo(default=PydanticUndefined, discriminator='type', extra={})]]], ...]\n    [units = (Hz, Hz)].  List of (:math:`f_i, \\delta_i`) values for model.\ninterp_method : Literal['nearest', 'linear'] = nearest\n    Interpolation method to obtain permittivity values that are not supplied at the Yee grids; For grids outside the range of the supplied data, extrapolation will be applied. When the extrapolated value is smaller (greater) than the minimal (maximal) of the supplied data, the extrapolated value will take the minimal (maximal) of the supplied data.\nsubpixel : bool = False\n    If ``True`` and simulation's ``subpixel`` is also ``True``, applies subpixel averaging of the permittivity on the interface of the structure, including exterior boundary and intersection interfaces with other structures.\n\n\nNotes\n-----\n\n    The frequency-dependence of the complex-valued permittivity is described by:\n\n    .. math::\n\n        \\epsilon(f) = \\epsilon_\\infty - \\sum_i\n        \\frac{ f_i^2}{f^2 + jf\\delta_i}\n\nExample\n-------\n>>> x = np.linspace(-1, 1, 5)\n>>> y = np.linspace(-1, 1, 6)\n>>> z = np.linspace(-1, 1, 7)\n>>> coords = dict(x=x, y=y, z=z)\n>>> eps_inf = SpatialDataArray(np.ones((5, 6, 7)), coords=coords)\n>>> f1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> delta1 = SpatialDataArray(np.random.random((5, 6, 7)), coords=coords)\n>>> drude_medium = CustomDrude(eps_inf=eps_inf, coeffs=[(f1,delta1),])\n>>> eps = drude_medium.eps_model(200e12)\n\nSee Also\n--------\n\n:class:`Drude`:\n    A dispersive medium described by the Drude model.\n\n**Notebooks**\n    * `Fitting dispersive material models <../../notebooks/Fitting.html>`_\n\n**Lectures**\n    * `Modeling dispersive material in FDTD <https://www.flexcompute.com/fdtd101/Lecture-5-Modeling-dispersive-material-in-FDTD/>`_",
       "type": "object",
       "properties": {
         "name": {
           "title": "Name",
           "description": "Optional unique name for medium.",
           "type": "string"
         },
@@ -3150,26 +3529,41 @@
           "default": "CustomDrude",
           "enum": [
             "CustomDrude"
           ],
           "type": "string"
         },
         "eps_inf": {
-          "title": "DataArray",
+          "title": "Epsilon at Infinity",
           "description": "Relative permittivity at infinite frequency (:math:`\\epsilon_\\infty`).",
           "units": "None (relative permittivity)",
-          "type": "xr.DataArray",
-          "properties": {
-            "_dims": {
-              "title": "_dims",
-              "type": "Tuple[str, ...]"
+          "anyOf": [
+            {
+              "title": "DataArray",
+              "type": "xr.DataArray",
+              "properties": {
+                "_dims": {
+                  "title": "_dims",
+                  "type": "Tuple[str, ...]"
+                }
+              },
+              "required": [
+                "_dims"
+              ]
+            },
+            {
+              "oneOf": [
+                {
+                  "$ref": "#/definitions/TriangularGridDataset"
+                },
+                {
+                  "$ref": "#/definitions/TetrahedralGridDataset"
+                }
+              ]
             }
-          },
-          "required": [
-            "_dims"
           ]
         },
         "coeffs": {
           "title": "Coefficients",
           "description": "List of (:math:`f_i, \\delta_i`) values for model.",
           "units": [
             "Hz",
@@ -3178,37 +3572,65 @@
           "type": "array",
           "items": {
             "type": "array",
             "minItems": 2,
             "maxItems": 2,
             "items": [
               {
-                "title": "DataArray",
-                "type": "xr.DataArray",
-                "properties": {
-                  "_dims": {
-                    "title": "_dims",
-                    "type": "Tuple[str, ...]"
+                "anyOf": [
+                  {
+                    "title": "DataArray",
+                    "type": "xr.DataArray",
+                    "properties": {
+                      "_dims": {
+                        "title": "_dims",
+                        "type": "Tuple[str, ...]"
+                      }
+                    },
+                    "required": [
+                      "_dims"
+                    ]
+                  },
+                  {
+                    "oneOf": [
+                      {
+                        "$ref": "#/definitions/TriangularGridDataset"
+                      },
+                      {
+                        "$ref": "#/definitions/TetrahedralGridDataset"
+                      }
+                    ]
                   }
-                },
-                "required": [
-                  "_dims"
                 ]
               },
               {
-                "title": "DataArray",
-                "type": "xr.DataArray",
-                "properties": {
-                  "_dims": {
-                    "title": "_dims",
-                    "type": "Tuple[str, ...]"
+                "anyOf": [
+                  {
+                    "title": "DataArray",
+                    "type": "xr.DataArray",
+                    "properties": {
+                      "_dims": {
+                        "title": "_dims",
+                        "type": "Tuple[str, ...]"
+                      }
+                    },
+                    "required": [
+                      "_dims"
+                    ]
+                  },
+                  {
+                    "oneOf": [
+                      {
+                        "$ref": "#/definitions/TriangularGridDataset"
+                      },
+                      {
+                        "$ref": "#/definitions/TetrahedralGridDataset"
+                      }
+                    ]
                   }
-                },
-                "required": [
-                  "_dims"
                 ]
               }
             ]
           }
         },
         "interp_method": {
           "title": "Interpolation method",
@@ -5347,15 +5769,15 @@
         "fwidth",
         "source_time_dataset"
       ],
       "additionalProperties": false
     },
     "UniformCurrentSource": {
       "title": "UniformCurrentSource",
-      "description": "Source in a rectangular volume with uniform time dependence.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional name for the source.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave, CustomSourceTime]\n    Specification of the source time-dependence.\ninterpolate : bool = True\n    Handles reverse-interpolation of zero-size dimensions of the source. If ``False``, the source data is snapped to the nearest Yee grid point. If ``True``, equivalent source data is applied on the surrounding Yee grid points to emulate placement at the specified location using linear interpolation.\npolarization : Literal['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']\n    Specifies the direction and type of current component.\n\nNotes\n-----\n\n    Inputting the parameter ``size=(0,0,0)`` defines the equivalent of a point source.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> pt_source = UniformCurrentSource(size=(0,0,0), source_time=pulse, polarization='Ex')",
+      "description": "Source in a rectangular volume with uniform time dependence.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional name for the source.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave, CustomSourceTime]\n    Specification of the source time-dependence.\ninterpolate : bool = True\n    Handles reverse-interpolation of zero-size dimensions of the source. If ``False``, the source data is snapped to the nearest Yee grid point. If ``True``, equivalent source data is applied on the surrounding Yee grid points to emulate placement at the specified location using linear interpolation.\nconfine_to_bounds : bool = False\n    If ``True``, any source amplitudes which, after discretization, fall beyond the bounding box of the source are zeroed out, but only along directions where the source has a non-zero extent. The bounding box is inclusive. Should be set ```True`` when the current source is being used to excite a current in a conductive material.\npolarization : Literal['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']\n    Specifies the direction and type of current component.\n\nNotes\n-----\n\n    Inputting the parameter ``size=(0,0,0)`` defines the equivalent of a point source.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> pt_source = UniformCurrentSource(size=(0,0,0), source_time=pulse, polarization='Ex')",
       "type": "object",
       "properties": {
         "name": {
           "title": "Name",
           "description": "Optional name for the source.",
           "type": "string"
         },
@@ -5438,14 +5860,20 @@
         },
         "interpolate": {
           "title": "Enable Interpolation",
           "description": "Handles reverse-interpolation of zero-size dimensions of the source. If ``False``, the source data is snapped to the nearest Yee grid point. If ``True``, equivalent source data is applied on the surrounding Yee grid points to emulate placement at the specified location using linear interpolation.",
           "default": true,
           "type": "boolean"
         },
+        "confine_to_bounds": {
+          "title": "Confine to Analytical Bounds",
+          "description": "If ``True``, any source amplitudes which, after discretization, fall beyond the bounding box of the source are zeroed out, but only along directions where the source has a non-zero extent. The bounding box is inclusive. Should be set ```True`` when the current source is being used to excite a current in a conductive material.",
+          "default": false,
+          "type": "boolean"
+        },
         "polarization": {
           "title": "Polarization",
           "description": "Specifies the direction and type of current component.",
           "enum": [
             "Ex",
             "Ey",
             "Ez",
@@ -5461,15 +5889,15 @@
         "source_time",
         "polarization"
       ],
       "additionalProperties": false
     },
     "PointDipole": {
       "title": "PointDipole",
-      "description": "Uniform current source with a zero size.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional name for the source.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[Literal[0], Literal[0], Literal[0]] = (0, 0, 0)\n    [units = um].  Size in x, y, and z directions, constrained to ``(0, 0, 0)``.\nsource_time : Union[GaussianPulse, ContinuousWave, CustomSourceTime]\n    Specification of the source time-dependence.\ninterpolate : bool = True\n    Handles reverse-interpolation of zero-size dimensions of the source. If ``False``, the source data is snapped to the nearest Yee grid point. If ``True``, equivalent source data is applied on the surrounding Yee grid points to emulate placement at the specified location using linear interpolation.\npolarization : Literal['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']\n    Specifies the direction and type of current component.\n\n.. TODO add image of how it looks like based on sim 1.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> pt_dipole = PointDipole(center=(1,2,3), source_time=pulse, polarization='Ex')\n\nSee Also\n--------\n\n**Lectures:**\n    * `Prelude to Integrated Photonics Simulation: Mode Injection <https://www.flexcompute.com/fdtd101/Lecture-4-Prelude-to-Integrated-Photonics-Simulation-Mode-Injection/>`_",
+      "description": "Uniform current source with a zero size.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional name for the source.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[Literal[0], Literal[0], Literal[0]] = (0, 0, 0)\n    [units = um].  Size in x, y, and z directions, constrained to ``(0, 0, 0)``.\nsource_time : Union[GaussianPulse, ContinuousWave, CustomSourceTime]\n    Specification of the source time-dependence.\ninterpolate : bool = True\n    Handles reverse-interpolation of zero-size dimensions of the source. If ``False``, the source data is snapped to the nearest Yee grid point. If ``True``, equivalent source data is applied on the surrounding Yee grid points to emulate placement at the specified location using linear interpolation.\nconfine_to_bounds : bool = False\n    If ``True``, any source amplitudes which, after discretization, fall beyond the bounding box of the source are zeroed out, but only along directions where the source has a non-zero extent. The bounding box is inclusive. Should be set ```True`` when the current source is being used to excite a current in a conductive material.\npolarization : Literal['Ex', 'Ey', 'Ez', 'Hx', 'Hy', 'Hz']\n    Specifies the direction and type of current component.\n\n.. TODO add image of how it looks like based on sim 1.\n\nExample\n-------\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> pt_dipole = PointDipole(center=(1,2,3), source_time=pulse, polarization='Ex')\n\nSee Also\n--------\n\n**Lectures:**\n    * `Prelude to Integrated Photonics Simulation: Mode Injection <https://www.flexcompute.com/fdtd101/Lecture-4-Prelude-to-Integrated-Photonics-Simulation-Mode-Injection/>`_",
       "type": "object",
       "properties": {
         "name": {
           "title": "Name",
           "description": "Optional name for the source.",
           "type": "string"
         },
@@ -5563,14 +5991,20 @@
         },
         "interpolate": {
           "title": "Enable Interpolation",
           "description": "Handles reverse-interpolation of zero-size dimensions of the source. If ``False``, the source data is snapped to the nearest Yee grid point. If ``True``, equivalent source data is applied on the surrounding Yee grid points to emulate placement at the specified location using linear interpolation.",
           "default": true,
           "type": "boolean"
         },
+        "confine_to_bounds": {
+          "title": "Confine to Analytical Bounds",
+          "description": "If ``True``, any source amplitudes which, after discretization, fall beyond the bounding box of the source are zeroed out, but only along directions where the source has a non-zero extent. The bounding box is inclusive. Should be set ```True`` when the current source is being used to excite a current in a conductive material.",
+          "default": false,
+          "type": "boolean"
+        },
         "polarization": {
           "title": "Polarization",
           "description": "Specifies the direction and type of current component.",
           "enum": [
             "Ex",
             "Ey",
             "Ez",
@@ -6505,15 +6939,15 @@
         "source_time",
         "field_dataset"
       ],
       "additionalProperties": false
     },
     "CustomCurrentSource": {
       "title": "CustomCurrentSource",
-      "description": "Implements a source corresponding to an input dataset containing ``E`` and ``H`` fields.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional name for the source.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave, CustomSourceTime]\n    Specification of the source time-dependence.\ninterpolate : bool = True\n    Handles reverse-interpolation of zero-size dimensions of the source. If ``False``, the source data is snapped to the nearest Yee grid point. If ``True``, equivalent source data is applied on the surrounding Yee grid points to emulate placement at the specified location using linear interpolation.\ncurrent_dataset : Optional[FieldDataset]\n    :class:`.FieldDataset` containing the desired frequency-domain electric and magnetic current patterns to inject.\n\nNotes\n-----\n\n    Injects the specified components of the ``E`` and ``H`` dataset directly as ``J`` and ``M`` current\n    distributions in the FDTD solver. The coordinates of all provided fields are assumed to be relative to the\n    source center.\n\n    The syntax is very similar to :class:`CustomFieldSource`, except instead of a ``field_dataset``, the source\n    accepts a :attr:`current_dataset`. This dataset still contains :math:`E_{x,y,z}` and :math:`H_{x,y,\n    z}` field components, which correspond to :math:`J` and :math:`M` components respectively. There are also\n    fewer constraints on the data requirements for :class:`CustomCurrentSource`. It can be volumetric or planar\n    without requiring tangential components. Finally, note that the dataset is still defined w.r.t. the source\n    center, just as in the case of the :class:`CustomFieldSource`, and can then be placed anywhere in the simulation.\n\nExample\n-------\n>>> from tidy3d import ScalarFieldDataArray\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> x = np.linspace(-1, 1, 101)\n>>> y = np.linspace(-1, 1, 101)\n>>> z = np.array([0])\n>>> f = [2e14]\n>>> coords = dict(x=x, y=y, z=z, f=f)\n>>> scalar_field = ScalarFieldDataArray(np.ones((101, 101, 1, 1)), coords=coords)\n>>> dataset = FieldDataset(Ex=scalar_field)\n>>> custom_source = CustomCurrentSource(\n...     center=(1, 1, 1),\n...     size=(2, 2, 0),\n...     source_time=pulse,\n...     current_dataset=dataset)\n\nSee Also\n--------\n\n**Notebooks**\n    * `Defining spatially-varying sources <../../notebooks/CustomFieldSource.html>`_",
+      "description": "Implements a source corresponding to an input dataset containing ``E`` and ``H`` fields.\n\nParameters\n----------\nname : Optional[str] = None\n    Optional name for the source.\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nsource_time : Union[GaussianPulse, ContinuousWave, CustomSourceTime]\n    Specification of the source time-dependence.\ninterpolate : bool = True\n    Handles reverse-interpolation of zero-size dimensions of the source. If ``False``, the source data is snapped to the nearest Yee grid point. If ``True``, equivalent source data is applied on the surrounding Yee grid points to emulate placement at the specified location using linear interpolation.\nconfine_to_bounds : bool = False\n    If ``True``, any source amplitudes which, after discretization, fall beyond the bounding box of the source are zeroed out, but only along directions where the source has a non-zero extent. The bounding box is inclusive. Should be set ```True`` when the current source is being used to excite a current in a conductive material.\ncurrent_dataset : Optional[FieldDataset]\n    :class:`.FieldDataset` containing the desired frequency-domain electric and magnetic current patterns to inject.\n\nNotes\n-----\n\n    Injects the specified components of the ``E`` and ``H`` dataset directly as ``J`` and ``M`` current\n    distributions in the FDTD solver. The coordinates of all provided fields are assumed to be relative to the\n    source center.\n\n    The syntax is very similar to :class:`CustomFieldSource`, except instead of a ``field_dataset``, the source\n    accepts a :attr:`current_dataset`. This dataset still contains :math:`E_{x,y,z}` and :math:`H_{x,y,\n    z}` field components, which correspond to :math:`J` and :math:`M` components respectively. There are also\n    fewer constraints on the data requirements for :class:`CustomCurrentSource`. It can be volumetric or planar\n    without requiring tangential components. Finally, note that the dataset is still defined w.r.t. the source\n    center, just as in the case of the :class:`CustomFieldSource`, and can then be placed anywhere in the simulation.\n\nExample\n-------\n>>> from tidy3d import ScalarFieldDataArray\n>>> pulse = GaussianPulse(freq0=200e12, fwidth=20e12)\n>>> x = np.linspace(-1, 1, 101)\n>>> y = np.linspace(-1, 1, 101)\n>>> z = np.array([0])\n>>> f = [2e14]\n>>> coords = dict(x=x, y=y, z=z, f=f)\n>>> scalar_field = ScalarFieldDataArray(np.ones((101, 101, 1, 1)), coords=coords)\n>>> dataset = FieldDataset(Ex=scalar_field)\n>>> custom_source = CustomCurrentSource(\n...     center=(1, 1, 1),\n...     size=(2, 2, 0),\n...     source_time=pulse,\n...     current_dataset=dataset)\n\nSee Also\n--------\n\n**Notebooks**\n    * `Defining spatially-varying sources <../../notebooks/CustomFieldSource.html>`_",
       "type": "object",
       "properties": {
         "name": {
           "title": "Name",
           "description": "Optional name for the source.",
           "type": "string"
         },
@@ -6596,14 +7030,20 @@
         },
         "interpolate": {
           "title": "Enable Interpolation",
           "description": "Handles reverse-interpolation of zero-size dimensions of the source. If ``False``, the source data is snapped to the nearest Yee grid point. If ``True``, equivalent source data is applied on the surrounding Yee grid points to emulate placement at the specified location using linear interpolation.",
           "default": true,
           "type": "boolean"
         },
+        "confine_to_bounds": {
+          "title": "Confine to Analytical Bounds",
+          "description": "If ``True``, any source amplitudes which, after discretization, fall beyond the bounding box of the source are zeroed out, but only along directions where the source has a non-zero extent. The bounding box is inclusive. Should be set ```True`` when the current source is being used to excite a current in a conductive material.",
+          "default": false,
+          "type": "boolean"
+        },
         "current_dataset": {
           "title": "Current Dataset",
           "description": ":class:`.FieldDataset` containing the desired frequency-domain electric and magnetic current patterns to inject.",
           "allOf": [
             {
               "$ref": "#/definitions/FieldDataset"
             }
@@ -9729,15 +10169,15 @@
           "type": "string"
         }
       },
       "additionalProperties": false
     },
     "AutoGrid": {
       "title": "AutoGrid",
-      "description": "Specification for non-uniform grid along a given dimension.\n\nParameters\n----------\nmin_steps_per_wvl : ConstrainedFloatValue = 10.0\n    Minimal number of steps per wavelength in each medium.\nmax_scale : ConstrainedFloatValue = 1.4\n    Sets the maximum ratio between any two consecutive grid steps.\ndl_min : NonNegativeFloat = 0\n    Lower bound of the grid size along this dimension regardless of structures present in the simulation, including override structures with ``enforced=True``. It is a soft bound, meaning that the actual minimal grid size might be slightly smaller.\nmesher : GradedMesher = GradedMesher(type='GradedMesher')\n    The type of mesher to use to generate the grid automatically.\n\nExample\n-------\n>>> grid_1d = AutoGrid(min_steps_per_wvl=16, max_scale=1.4)\n\nSee Also\n--------\n\n:class:`UniformGrid`\n    Uniform 1D grid.\n\n:class:`GridSpec`\n    Collective grid specification for all three dimensions.\n\n**Notebooks:**\n    * `Using automatic nonuniform meshing <../../notebooks/AutoGrid.html>`_\n\n**Lectures:**\n    *  `Time step size and CFL condition in FDTD <https://www.flexcompute.com/fdtd101/Lecture-7-Time-step-size-and-CFL-condition-in-FDTD/>`_\n    *  `Numerical dispersion in FDTD <https://www.flexcompute.com/fdtd101/Lecture-8-Numerical-dispersion-in-FDTD/>`_",
+      "description": "Specification for non-uniform grid along a given dimension.\n\nParameters\n----------\nmin_steps_per_wvl : ConstrainedFloatValue = 10.0\n    Minimal number of steps per wavelength in each medium.\nmax_scale : ConstrainedFloatValue = 1.4\n    Sets the maximum ratio between any two consecutive grid steps.\ndl_min : NonNegativeFloat = 0\n    [units = um].  Lower bound of the grid size along this dimension regardless of structures present in the simulation, including override structures with ``enforced=True``. It is a soft bound, meaning that the actual minimal grid size might be slightly smaller.\nmesher : GradedMesher = GradedMesher(type='GradedMesher')\n    The type of mesher to use to generate the grid automatically.\n\nExample\n-------\n>>> grid_1d = AutoGrid(min_steps_per_wvl=16, max_scale=1.4)\n\nSee Also\n--------\n\n:class:`UniformGrid`\n    Uniform 1D grid.\n\n:class:`GridSpec`\n    Collective grid specification for all three dimensions.\n\n**Notebooks:**\n    * `Using automatic nonuniform meshing <../../notebooks/AutoGrid.html>`_\n\n**Lectures:**\n    *  `Time step size and CFL condition in FDTD <https://www.flexcompute.com/fdtd101/Lecture-7-Time-step-size-and-CFL-condition-in-FDTD/>`_\n    *  `Numerical dispersion in FDTD <https://www.flexcompute.com/fdtd101/Lecture-8-Numerical-dispersion-in-FDTD/>`_",
       "type": "object",
       "properties": {
         "type": {
           "title": "Type",
           "default": "AutoGrid",
           "enum": [
             "AutoGrid"
@@ -9759,14 +10199,15 @@
           "minimum": 1.2,
           "type": "number"
         },
         "dl_min": {
           "title": "Lower bound of grid size",
           "description": "Lower bound of the grid size along this dimension regardless of structures present in the simulation, including override structures with ``enforced=True``. It is a soft bound, meaning that the actual minimal grid size might be slightly smaller.",
           "default": 0,
+          "units": "um",
           "minimum": 0,
           "type": "number"
         },
         "mesher": {
           "title": "Grid Construction Tool",
           "description": "The type of mesher to use to generate the grid automatically.",
           "default": {
@@ -10017,10 +10458,164 @@
           "enum": [
             "GridSpec"
           ],
           "type": "string"
         }
       },
       "additionalProperties": false
+    },
+    "LumpedResistor": {
+      "title": "LumpedResistor",
+      "description": "Class representing a lumped resistor. Lumped resistors are appended to the list of structures in the simulation\nas :class:`Medium2D` with the appropriate conductivity given their size and voltage axis.\n\nParameters\n----------\ncenter : Tuple[float, float, float] = (0.0, 0.0, 0.0)\n    [units = um].  Center of object in x, y, and z.\nsize : Tuple[NonNegativeFloat, NonNegativeFloat, NonNegativeFloat]\n    [units = um].  Size in x, y, and z directions.\nname : ConstrainedStrValue\n    Unique name for the lumped element.\nvoltage_axis : Literal[0, 1, 2]\n    Specifies the axis along which the component is oriented and along which the associated voltage drop will occur. Must be in the plane of the element.\nnum_grid_cells : Optional[PositiveInt] = 3\n    Number of mesh grid cells associated with the lumped element along each direction. Used in generating the suggested list of :class:`MeshOverrideStructure` objects.A value of ``None`` will turn off mesh refinement suggestions.\nresistance : PositiveFloat\n    Resistance value in ohms.",
+      "type": "object",
+      "properties": {
+        "type": {
+          "title": "Type",
+          "default": "LumpedResistor",
+          "enum": [
+            "LumpedResistor"
+          ],
+          "type": "string"
+        },
+        "center": {
+          "title": "Center",
+          "description": "Center of object in x, y, and z.",
+          "default": [
+            0.0,
+            0.0,
+            0.0
+          ],
+          "units": "um",
+          "type": "array",
+          "minItems": 3,
+          "maxItems": 3,
+          "items": [
+            {
+              "type": "number"
+            },
+            {
+              "type": "number"
+            },
+            {
+              "type": "number"
+            }
+          ]
+        },
+        "size": {
+          "title": "Size",
+          "description": "Size in x, y, and z directions.",
+          "units": "um",
+          "type": "array",
+          "minItems": 3,
+          "maxItems": 3,
+          "items": [
+            {
+              "type": "number",
+              "minimum": 0
+            },
+            {
+              "type": "number",
+              "minimum": 0
+            },
+            {
+              "type": "number",
+              "minimum": 0
+            }
+          ]
+        },
+        "name": {
+          "title": "Name",
+          "description": "Unique name for the lumped element.",
+          "minLength": 1,
+          "type": "string"
+        },
+        "voltage_axis": {
+          "title": "Voltage Drop Axis",
+          "description": "Specifies the axis along which the component is oriented and along which the associated voltage drop will occur. Must be in the plane of the element.",
+          "enum": [
+            0,
+            1,
+            2
+          ],
+          "type": "integer"
+        },
+        "num_grid_cells": {
+          "title": "Lumped element grid cells",
+          "description": "Number of mesh grid cells associated with the lumped element along each direction. Used in generating the suggested list of :class:`MeshOverrideStructure` objects.A value of ``None`` will turn off mesh refinement suggestions.",
+          "default": 3,
+          "exclusiveMinimum": 0,
+          "type": "integer"
+        },
+        "resistance": {
+          "title": "Resistance",
+          "description": "Resistance value in ohms.",
+          "unit": "ohm",
+          "exclusiveMinimum": 0,
+          "type": "number"
+        }
+      },
+      "required": [
+        "size",
+        "name",
+        "voltage_axis",
+        "resistance"
+      ],
+      "additionalProperties": false
+    },
+    "BenklerConformalMeshSpec": {
+      "title": "BenklerConformalMeshSpec",
+      "description": "Conformal mesh scheme based on\n[S. Benkler, IEEE Transactions on Antennas and Propagation 54.6, 1843 (2006)], which is similar\nto the approach described in [S. Dey, R. Mittra, IEEE Microwave and Guided Wave Letters 7.9, 273 (1997)].\n\n\nParameters\n----------\ntimestep_reduction : ConstrainedFloatValue = 0.3\n    Reduction factor between 0 and 1 such that the simulation's time step size will be ``1 - timestep_reduction`` times its default value. Accuracy can be improved with a smaller time step size; but simulation time increased as well.",
+      "type": "object",
+      "properties": {
+        "type": {
+          "title": "Type",
+          "default": "BenklerConformalMeshSpec",
+          "enum": [
+            "BenklerConformalMeshSpec"
+          ],
+          "type": "string"
+        },
+        "timestep_reduction": {
+          "title": "Time Step Size Reduction Rate",
+          "description": "Reduction factor between 0 and 1 such that the simulation's time step size will be ``1 - timestep_reduction`` times its default value. Accuracy can be improved with a smaller time step size; but simulation time increased as well.",
+          "default": 0.3,
+          "exclusiveMaximum": 1,
+          "minimum": 0,
+          "type": "number"
+        }
+      },
+      "additionalProperties": false
+    },
+    "StaircasingConformalMeshSpec": {
+      "title": "StaircasingConformalMeshSpec",
+      "description": "Simple staircasing scheme based on\n[Taflove, The Electrical Engineering Handbook 3.629-670 (2005): 15.].\n\n\nParameters\n----------",
+      "type": "object",
+      "properties": {
+        "type": {
+          "title": "Type",
+          "default": "StaircasingConformalMeshSpec",
+          "enum": [
+            "StaircasingConformalMeshSpec"
+          ],
+          "type": "string"
+        }
+      },
+      "additionalProperties": false
+    },
+    "HeuristicConformalMeshSpec": {
+      "title": "HeuristicConformalMeshSpec",
+      "description": "Slightly different from the staircasing scheme: the field component near PEC\nis considered to be outside PEC if it's substantially normal to the interface.\n\n\nParameters\n----------",
+      "type": "object",
+      "properties": {
+        "type": {
+          "title": "Type",
+          "default": "HeuristicConformalMeshSpec",
+          "enum": [
+            "HeuristicConformalMeshSpec"
+          ],
+          "type": "string"
+        }
+      },
+      "additionalProperties": false
     }
   }
 }
```

### Comparing `tidy3d-2.6.4/tidy3d/updater.py` & `tidy3d-2.7.0rc1/tidy3d/updater.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/__init__.py` & `tidy3d-2.7.0rc1/tidy3d/web/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,12 +1,19 @@
 """ imports interfaces for interacting with server """
-from .api.container import Job, Batch, BatchData
-from .cli.migrate import migrate
-from .cli.app import configure_fn as configure
-from .api.webapi import (
+from .core import core_config
+from ..log import log, get_logging_console
+from ..version import __version__
+
+# set logger to tidy3d.log before it's invoked in other imports
+core_config.set_config(log, get_logging_console(), __version__)
+
+from .api.container import Job, Batch, BatchData  # noqa: E402
+from .cli.migrate import migrate  # noqa: E402
+from .cli.app import configure_fn as configure  # noqa: E402
+from .api.webapi import (  # noqa: E402
     run,
     upload,
     get_info,
     start,
     monitor,
     delete,
     download,
@@ -17,24 +24,19 @@
     delete_old,
     download_log,
     download_json,
     load_simulation,
     real_cost,
     test,
 )
-from .cli import tidy3d_cli
-from .api.asynchronous import run_async
-from .core import core_config
-from ..log import log, get_logging_console
-from ..version import __version__
+from .cli import tidy3d_cli  # noqa: E402
+from .api.asynchronous import run_async  # noqa: E402
 
 migrate()
 
-core_config.set_config(log, get_logging_console(), __version__)
-
 __all__ = [
     "run",
     "upload",
     "get_info",
     "start",
     "monitor",
     "delete",
```

### Comparing `tidy3d-2.6.4/tidy3d/web/api/asynchronous.py` & `tidy3d-2.7.0rc1/tidy3d/web/api/asynchronous.py`

 * *Files 4% similar despite different names*

```diff
@@ -12,22 +12,22 @@
     path_dir: str = DEFAULT_DATA_DIR,
     callback_url: str = None,
     num_workers: int = None,
     verbose: bool = True,
     simulation_type: str = "tidy3d",
     parent_tasks: Dict[str, List[str]] = None,
 ) -> BatchData:
-    """Submits a set of Union[:class:`.Simulation`, :class:`.HeatSimulation`] objects to server,
+    """Submits a set of Union[:class:`.Simulation`, :class:`.HeatSimulation`, :class:`.EMESimulation`] objects to server,
     starts running, monitors progress, downloads, and loads results as a :class:`.BatchData` object.
 
     .. TODO add example and see also reference.
 
     Parameters
     ----------
-    simulations : Dict[str, Union[:class:`.Simulation`, :class:`.HeatSimulation`]]
+    simulations : Dict[str, Union[:class:`.Simulation`, :class:`.HeatSimulation`, :class:`.EMESimulation`]]
         Mapping of task name to simulation.
     folder_name : str = "default"
         Name of folder to store each task on web UI.
     path_dir : str
         Base directory where data will be downloaded, by default current working directory.
     callback_url : str = None
         Http PUT url to receive simulation finish event. The body content is a json file with
@@ -36,16 +36,16 @@
         Number of tasks to submit at once in a batch, if None, will run all at the same time.
     verbose : bool = True
         If ``True``, will print progressbars and status, otherwise, will run silently.
 
     Returns
     ------
     :class:`BatchData`
-        Contains the Union[:class:`.SimulationData`, :class:`.HeatSimulationData`] for each
-        Union[:class:`.Simulation`, :class:`.HeatSimulation`] in :class:`Batch`.
+        Contains the Union[:class:`.SimulationData`, :class:`.HeatSimulationData`, :class:`.EMESimulationData`] for each
+        Union[:class:`.Simulation`, :class:`.HeatSimulation`, :class:`.EMESimulation`] in :class:`Batch`.
 
     See Also
     --------
 
     :class:`Job`:
         Interface for managing the running of a Simulation on server.
```

### Comparing `tidy3d-2.6.4/tidy3d/web/api/cacert.pem` & `tidy3d-2.7.0rc1/tidy3d/web/api/cacert.pem`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/api/connect_util.py` & `tidy3d-2.7.0rc1/tidy3d/web/api/connect_util.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/api/container.py` & `tidy3d-2.7.0rc1/tidy3d/web/api/container.py`

 * *Files 3% similar despite different names*

```diff
@@ -168,15 +168,15 @@
         Parameters
         ----------
         path_dir : str = "./simulation_data.hdf5"
             Base directory where data will be downloaded, by default current working directory.
 
         Returns
         -------
-        Union[:class:`.SimulationData`, :class:`.HeatSimulationData`]
+        Union[:class:`.SimulationData`, :class:`.HeatSimulationData`, :class:`.EMESimulationData`]
             Object containing simulation results.
         """
 
         self.start()
         self.monitor()
         return self.load(path=path)
 
@@ -261,15 +261,15 @@
         Parameters
         ----------
         path : str = "./simulation_data.hdf5"
             Path to download data as ``.hdf5`` file (including filename).
 
         Returns
         -------
-        Union[:class:`.SimulationData`, :class:`.HeatSimulationData`]
+        Union[:class:`.SimulationData`, :class:`.HeatSimulationData`, :class:`.EMESimulationData`]
             Object containing simulation results.
         """
         return web.load(task_id=self.task_id, path=path, verbose=self.verbose)
 
     def delete(self) -> None:
         """Delete server-side data associated with :class:`Job`."""
         web.delete(self.task_id)
@@ -303,15 +303,15 @@
             Estimated cost of the task in FlexCredits.
 
         Note
         ----
         Cost is calculated assuming the simulation runs for
         the full ``run_time``. If early shut-off is triggered, the cost is adjusted proportionately.
         """
-        return web.estimate_cost(self.task_id, verbose=verbose)
+        return web.estimate_cost(self.task_id, verbose=verbose, solver_version=self.solver_version)
 
 
 class BatchData(Tidy3dBaseModel):
     """
     Holds a collection of :class:`.SimulationData` returned by :class:`Batch`.
 
     Notes
@@ -379,16 +379,16 @@
         path_dir : str = './'
             Base directory where data will be downloaded, by default current working directory.
             A `batch.hdf5` file must be present in the directory.
 
         Returns
         ------
         :class:`BatchData`
-            Contains Union[:class:`.SimulationData`, :class:`.HeatSimulationData`]
-            for each Union[:class:`.Simulation`, :class:`.HeatSimulation`] in :class:`Batch`.
+            Contains Union[:class:`.SimulationData`, :class:`.HeatSimulationData`, :class:`.EMESimulationData`]
+            for each Union[:class:`.Simulation`, :class:`.HeatSimulation`, :class:`.EMESimulation`] in :class:`Batch`.
         """
 
         batch_file = Batch._batch_path(path_dir=path_dir)
         batch = Batch.from_file(batch_file)
         return batch.load(path_dir=path_dir)
 
 
@@ -483,16 +483,16 @@
         ----------
         path_dir : str
             Base directory where data will be downloaded, by default current working directory.
 
         Returns
         ------
         :class:`BatchData`
-            Contains Union[:class:`.SimulationData`, :class:`.HeatSimulationData`] for
-            each Union[:class:`.Simulation`, :class:`.HeatSimulation`] in :class:`Batch`.
+            Contains Union[:class:`.SimulationData`, :class:`.HeatSimulationData`, :class:`.EMESimulationData] for
+            each Union[:class:`.Simulation`, :class:`.HeatSimulation`, :class:`.EMESimulation`] in :class:`Batch`.
 
         Note
         ----
         A typical usage might look like:
 
         >>> from tidy3d.web.api.container import Batch
         >>> custom_batch = Batch()
@@ -730,16 +730,16 @@
         ----------
         path_dir : str = './'
             Base directory where data will be downloaded, by default current working directory.
 
         Returns
         ------
         :class:`BatchData`
-            Contains Union[:class:`.SimulationData`, :class:`.HeatSimulationData`] for each
-            Union[:class:`.Simulation`, :class:`.HeatSimulation`] in :class:`Batch`.
+            Contains Union[:class:`.SimulationData`, :class:`.HeatSimulationData`, :class:`.EMESimulationData`] for each
+            Union[:class:`.Simulation`, :class:`.HeatSimulation`, :class:`.EMESimulation`] in :class:`Batch`.
 
         The :class:`Batch` hdf5 file will be automatically saved as ``{path_dir}/batch.hdf5``,
         allowing one to load this :class:`Batch` later using ``batch = Batch.from_file()``.
         """
 
         self.to_file(self._batch_path(path_dir=path_dir))
```

### Comparing `tidy3d-2.6.4/tidy3d/web/api/material_fitter.py` & `tidy3d-2.7.0rc1/tidy3d/web/api/material_fitter.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/api/material_libray.py` & `tidy3d-2.7.0rc1/tidy3d/web/api/material_libray.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/api/mode.py` & `tidy3d-2.7.0rc1/tidy3d/web/api/mode.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/api/tidy3d_stub.py` & `tidy3d-2.7.0rc1/tidy3d/web/api/tidy3d_stub.py`

 * *Files 8% similar despite different names*

```diff
@@ -18,36 +18,38 @@
 from ...components.data.sim_data import SimulationData
 from ...components.data.monitor_data import ModeSolverData
 from ..core.types import TaskType
 from ...components.simulation import Simulation
 from ...plugins.mode.mode_solver import ModeSolver
 from ...components.heat.simulation import HeatSimulation
 from ...components.heat.data.sim_data import HeatSimulationData
+from ...components.eme.simulation import EMESimulation
+from ...components.eme.data.sim_data import EMESimulationData
 
-SimulationType = Union[Simulation, HeatSimulation]
-SimulationDataType = Union[SimulationData, HeatSimulationData]
+SimulationType = Union[Simulation, HeatSimulation, EMESimulation]
+SimulationDataType = Union[SimulationData, HeatSimulationData, EMESimulationData]
 
 
 class Tidy3dStub(BaseModel, TaskStub):
     simulation: SimulationType = pd.Field(discriminator="type")
 
     @classmethod
     def from_file(cls, file_path: str) -> SimulationType:
-        """Loads a Union[:class:`.Simulation`, :class:`.HeatSimulation`]
+        """Loads a Union[:class:`.Simulation`, :class:`.HeatSimulation`, :class:`.EMESimulation`]
         from .yaml, .json, or .hdf5 file.
 
         Parameters
         ----------
         file_path : str
             Full path to the .yaml or .json or .hdf5 file to load the
-            Union[:class:`.Simulation`, :class:`.HeatSimulation`] from.
+            Union[:class:`.Simulation`, :class:`.HeatSimulation`, :class:`.EMESimulation`] from.
 
         Returns
         -------
-        Union[:class:`.Simulation`, :class:`.HeatSimulation`]
+        Union[:class:`.Simulation`, :class:`.HeatSimulation`, :class:`.EMESimulation`]
             An instance of the component class calling ``load``.
 
         Example
         -------
         >>> simulation = Simulation.from_file(fname='folder/sim.json') # doctest: +SKIP
         """
         extension = _get_valid_extension(file_path)
@@ -62,43 +64,45 @@
         type_ = data["type"]
         if "Simulation" == type_:
             sim = Simulation.from_file(file_path)
         elif "ModeSolver" == type_:
             sim = ModeSolver.from_file(file_path)
         elif "HeatSimulation" == type_:
             sim = HeatSimulation.from_file(file_path)
+        elif "EMESimulation" == type_:
+            sim = EMESimulation.from_file(file_path)
 
         return sim
 
     def to_file(
         self,
         file_path: str,
     ):
-        """Exports Union[:class:`.Simulation`, :class:`.HeatSimulation`] instance to .yaml, .json,
+        """Exports Union[:class:`.Simulation`, :class:`.HeatSimulation`, :class:`.EMESimulation`] instance to .yaml, .json,
         or .hdf5 file
 
         Parameters
         ----------
         file_path : str
             Full path to the .yaml or .json or .hdf5 file to save the :class:`Stub` to.
 
         Example
         -------
         >>> simulation.to_file(fname='folder/sim.json') # doctest: +SKIP
         """
         self.simulation.to_file(file_path)
 
     def to_hdf5_gz(self, fname: str, custom_encoders: List[Callable] = None) -> None:
-        """Exports Union[:class:`.Simulation`, :class:`.HeatSimulation`] instance to .hdf5.gz file.
+        """Exports Union[:class:`.Simulation`, :class:`.HeatSimulation`, :class:`.EMESimulation`] instance to .hdf5.gz file.
 
         Parameters
         ----------
         fname : str
             Full path to the .hdf5.gz file to save
-            the Union[:class:`.Simulation`, :class:`.HeatSimulation`] to.
+            the Union[:class:`.Simulation`, :class:`.HeatSimulation`, :class:`.EMESimulation`] to.
         custom_encoders : List[Callable]
             List of functions accepting (fname: str, group_path: str, value: Any) that take
             the ``value`` supplied and write it to the hdf5 ``fname`` at ``group_path``.
 
         Example
         -------
         >>> simulation.to_hdf5_gz(fname='folder/sim.hdf5.gz') # doctest: +SKIP
@@ -116,40 +120,42 @@
         """
         if isinstance(self.simulation, Simulation):
             return TaskType.FDTD.name
         elif isinstance(self.simulation, ModeSolver):
             return TaskType.MODE_SOLVER.name
         elif isinstance(self.simulation, HeatSimulation):
             return TaskType.HEAT.name
+        elif isinstance(self.simulation, EMESimulation):
+            return TaskType.EME.name
 
     def validate_pre_upload(self, source_required) -> None:
         """Perform some pre-checks on instances of component"""
         if isinstance(self.simulation, Simulation):
             self.simulation.validate_pre_upload(source_required)
 
 
 class Tidy3dStubData(BaseModel, TaskStubData):
     """"""
 
     data: SimulationDataType
 
     @classmethod
     def from_file(cls, file_path: str) -> SimulationDataType:
-        """Loads a Union[:class:`.SimulationData`, :class:`.HeatSimulationData`]
+        """Loads a Union[:class:`.SimulationData`, :class:`.HeatSimulationData`, :class:`.EMESimulationData`]
         from .yaml, .json, or .hdf5 file.
 
         Parameters
         ----------
         file_path : str
             Full path to the .yaml or .json or .hdf5 file to load the
-            Union[:class:`.SimulationData`, :class:`.HeatSimulationData`] from.
+            Union[:class:`.SimulationData`, :class:`.HeatSimulationData`, :class:`.EMESimulationData`] from.
 
         Returns
         -------
-        Union[:class:`.SimulationData`, :class:`.HeatSimulationData`]
+        Union[:class:`.SimulationData`, :class:`.HeatSimulationData`, :class:`.EMESimulationData`]
             An instance of the component class calling ``load``.
         """
         extension = _get_valid_extension(file_path)
         if extension == ".json":
             json_str = read_simulation_from_json(file_path)
         elif extension == ".hdf5":
             json_str = read_simulation_from_hdf5(file_path)
@@ -160,47 +166,49 @@
         type_ = data["type"]
         if "SimulationData" == type_:
             sim_data = SimulationData.from_file(file_path)
         elif "ModeSolverData" == type_:
             sim_data = ModeSolverData.from_file(file_path)
         elif "HeatSimulationData" == type_:
             sim_data = HeatSimulationData.from_file(file_path)
+        elif "EMESimulationData" == type_:
+            sim_data = EMESimulationData.from_file(file_path)
 
         return sim_data
 
     def to_file(self, file_path: str):
-        """Exports Union[:class:`.SimulationData`, :class:`.HeatSimulationData`] instance
+        """Exports Union[:class:`.SimulationData`, :class:`.HeatSimulationData`, :class:`.EMESimulationData`] instance
         to .yaml, .json, or .hdf5 file
 
         Parameters
         ----------
         file_path : str
             Full path to the .yaml or .json or .hdf5 file to save the
-            Union[:class:`.SimulationData`, :class:`.HeatSimulationData`] to.
+            Union[:class:`.SimulationData`, :class:`.HeatSimulationData`, :class:`.EMESimulationData`] to.
 
         Example
         -------
         >>> simulation.to_file(fname='folder/sim.json') # doctest: +SKIP
         """
         self.data.to_file(file_path)
 
     @classmethod
     def postprocess(cls, file_path: str) -> SimulationDataType:
         """Load .yaml, .json, or .hdf5 file to
-        Union[:class:`.SimulationData`, :class:`.HeatSimulationData`] instance.
+        Union[:class:`.SimulationData`, :class:`.HeatSimulationData`, :class:`.EMESimulationData`] instance.
 
         Parameters
         ----------
         file_path : str
             Full path to the .yaml or .json or .hdf5 file to save the
-            Union[:class:`.SimulationData`, :class:`.HeatSimulationData`] to.
+            Union[:class:`.SimulationData`, :class:`.HeatSimulationData`, :class:`.EMESimulationData`] to.
 
         Returns
         -------
-        Union[:class:`.SimulationData`, :class:`.HeatSimulationData`]
+        Union[:class:`.SimulationData`, :class:`.HeatSimulationData`, :class:`.EMESimulationData`]
             An instance of the component class calling ``load``.
         """
         stub_data = Tidy3dStubData.from_file(file_path)
 
         check_log_msg = "For more information, check 'SimulationData.log' or use "
         check_log_msg += "'web.download_log(task_id)'."
         warned_about_warnings = False
```

### Comparing `tidy3d-2.6.4/tidy3d/web/api/webapi.py` & `tidy3d-2.7.0rc1/tidy3d/web/api/webapi.py`

 * *Files 1% similar despite different names*

```diff
@@ -51,15 +51,15 @@
 ) -> SimulationDataType:
     """
     Submits a :class:`.Simulation` to server, starts running, monitors progress, downloads,
     and loads results as a :class:`.SimulationDataType` object.
 
     Parameters
     ----------
-    simulation : Union[:class:`.Simulation`, :class:`.HeatSimulation`]
+    simulation : Union[:class:`.Simulation`, :class:`.HeatSimulation`, :class:`.EMESimulation`]
         Simulation to upload to server.
     task_name : str
         Name of task.
     folder_name : str = "default"
         Name of folder to store task on web UI.
     path : str = "simulation_data.hdf5"
         Path to download results file (.hdf5), including filename.
@@ -77,15 +77,15 @@
     solver_version: str = None
         target solver version.
     worker_group: str = None
         worker group
 
     Returns
     -------
-    Union[:class:`.SimulationData`, :class:`.HeatSimulationData`]
+    Union[:class:`.SimulationData`, :class:`.HeatSimulationData`, :class:`.EMESimulationData`]
         Object containing solver results for the supplied simulation.
 
     Notes
     -----
 
         Submitting a simulation to our cloud server is very easily done by a simple web API call.
 
@@ -156,15 +156,15 @@
     source_required: bool = True,
 ) -> TaskId:
     """
     Upload simulation to server, but do not start running :class:`.Simulation`.
 
     Parameters
     ----------
-    simulation : Union[:class:`.Simulation`, :class:`.HeatSimulation`]
+    simulation : Union[:class:`.Simulation`, :class:`.HeatSimulation`, :class:`.EMESimulation`]
         Simulation to upload to server.
     task_name : str
         Name of task.
     folder_name : str
         Name of folder to store task on web UI
     callback_url : str = None
         Http PUT url to receive simulation finish event. The body content is a json file with
@@ -213,17 +213,21 @@
             f"Created task '{task_name}' with task_id '{task.task_id}' and task_type '{task_type}'."
         )
         if task_type == "HEAT":
             console.log(
                 "Tidy3D's heat solver is currently in the beta stage. Cost of heat simulations "
                 "is subject to change in the future."
             )
-        else:
-            url = _get_url(task.task_id)
-            console.log(f"View task using web UI at [link={url}]'{url}'[/link].")
+        elif task_type == "EME":
+            console.log(
+                "Tidy3D's EME solver is currently in the beta stage. Cost of EME simulations "
+                "is subject to change in the future."
+            )
+        url = _get_url(task.task_id)
+        console.log(f"View task using web UI at [link={url}]'{url}'[/link].")
 
     task.upload_simulation(stub=stub, verbose=verbose, progress_callback=progress_callback)
 
     # log the url for the task in the web UI
     log.debug(f"{Env.current.website_endpoint}/folders/{task.folder_id}/tasks/{task.task_id}")
     return task.task_id
 
@@ -346,17 +350,22 @@
     To load results when finished, may call :meth:`load`.
     """
 
     console = get_logging_console() if verbose else None
 
     task_info = get_info(task_id)
 
-    if task_info.taskType in ("MODE_SOLVER", "HEAT"):
+    if task_info.taskType in ("MODE_SOLVER", "HEAT", "EME"):
         log_level = "DEBUG" if verbose else "INFO"
-        solver_name = "Mode" if task_info.taskType == "MODE_SOLVER" else "Heat"
+        if task_info.taskType == "MODE_SOLVER":
+            solver_name = "Mode"
+        elif task_info.taskType == "HEAT":
+            solver_name = "Heat"
+        elif task_info.taskType == "EME":
+            solver_name = "EME"
 
         # Wait for task to finish
         prev_status = "draft"
         status = get_status(task_id)
         while status not in ("success", "error", "diverged", "deleted"):
             if status != prev_status:
                 log.log(log_level, f"{solver_name} solver status: {status}")
@@ -577,15 +586,15 @@
     path : str = "simulation.json"
         Download path to .json file of simulation (including filename).
     verbose : bool = True
         If ``True``, will print progressbars and status, otherwise, will run silently.
 
     Returns
     -------
-    Union[:class:`.Simulation`, :class:`.HeatSimulation`]
+    Union[:class:`.Simulation`, :class:`.HeatSimulation`, :class:`.EMESimulation`]
         Simulation loaded from downloaded json file.
     """
 
     task = SimulationTask.get(task_id)
     task.get_simulation_json(path, verbose=verbose)
     return Tidy3dStub.from_file(path)
 
@@ -653,15 +662,15 @@
     verbose : bool = True
         If ``True``, will print progressbars and status, otherwise, will run silently.
     progress_callback : Callable[[float], None] = None
         Optional callback function called when downloading file with ``bytes_in_chunk`` as argument.
 
     Returns
     -------
-    Union[:class:`.SimulationData`, :class:`.HeatSimulationData`]
+    Union[:class:`.SimulationData`, :class:`.HeatSimulationData`, :class:`.EMESimulationData`]
         Object containing simulation data.
     """
     if not os.path.exists(path) or replace_existing:
         download(task_id=task_id, path=path, verbose=verbose, progress_callback=progress_callback)
 
     if verbose:
         console = get_logging_console()
@@ -777,23 +786,25 @@
         tasks = sorted(tasks, key=lambda t: t.created_at)
     if num_tasks is not None:
         tasks = tasks[:num_tasks]
     return [task.dict() for task in tasks]
 
 
 @wait_for_connection
-def estimate_cost(task_id: str, verbose: bool = True) -> float:
+def estimate_cost(task_id: str, verbose: bool = True, solver_version: str = None) -> float:
     """Compute the maximum FlexCredit charge for a given task.
 
     Parameters
     ----------
     task_id : str
         Unique identifier of task on server.  Returned by :meth:`upload`.
     verbose : bool = True
         Whether to log the cost and helpful messages.
+    solver_version : str = None
+        Target solver version.
 
     Returns
     -------
     float
         Estimated maximum cost for :class:`.Simulation` associated with given ``task_id``.
 
     Note
@@ -825,15 +836,15 @@
         print(f'The estimated maximum cost is {estimated_cost:.3f} Flex Credits.')
 
     """
     task = SimulationTask.get(task_id)
     if not task:
         raise ValueError("Task not found.")
 
-    task.estimate_cost()
+    task.estimate_cost(solver_version=solver_version)
     task_info = get_info(task_id)
     status = task_info.metadataStatus
 
     # Wait for a termination status
     while status not in ["processed", "success", "error", "failed"]:
         time.sleep(REFRESH_TIME)
         task_info = get_info(task_id)
@@ -917,15 +928,15 @@
             f"Billed FlexCredit for task '{task_id}' is not available. If the task has been "
             "successfully run, it should be available shortly."
         )
     else:
         if verbose:
             console = get_logging_console()
             console.log(f"Billed flex credit cost: {flex_unit:1.3f}.")
-            if flex_unit != ori_flex_unit:
+            if flex_unit != ori_flex_unit and task_info.taskType == "FDTD":
                 console.log(
                     "Note: the task cost pro-rated due to early shutoff was below the minimum "
                     "threshold, due to fast shutoff. Decreasing the simulation 'run_time' should "
                     "decrease the estimated, and correspondingly the billed cost of such tasks."
                 )
     return flex_unit
```

### Comparing `tidy3d-2.6.4/tidy3d/web/cli/app.py` & `tidy3d-2.7.0rc1/tidy3d/web/cli/app.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/cli/converter.py` & `tidy3d-2.7.0rc1/tidy3d/web/cli/converter.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/cli/develop/__init__.py` & `tidy3d-2.7.0rc1/tidy3d/web/cli/develop/__init__.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/cli/develop/documentation.py` & `tidy3d-2.7.0rc1/tidy3d/web/cli/develop/documentation.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/cli/develop/install.py` & `tidy3d-2.7.0rc1/tidy3d/web/cli/develop/install.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/cli/develop/packaging.py` & `tidy3d-2.7.0rc1/tidy3d/web/cli/develop/packaging.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/cli/develop/tests.py` & `tidy3d-2.7.0rc1/tidy3d/web/cli/develop/tests.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/cli/develop/utils.py` & `tidy3d-2.7.0rc1/tidy3d/web/cli/develop/utils.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/cli/migrate.py` & `tidy3d-2.7.0rc1/tidy3d/web/cli/migrate.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/cli/readme.md` & `tidy3d-2.7.0rc1/tidy3d/web/cli/readme.md`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/core/constants.py` & `tidy3d-2.7.0rc1/tidy3d/web/core/constants.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/core/core_config.py` & `tidy3d-2.7.0rc1/tidy3d/web/core/core_config.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/core/environment.py` & `tidy3d-2.7.0rc1/tidy3d/web/core/environment.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/core/file_util.py` & `tidy3d-2.7.0rc1/tidy3d/web/core/file_util.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/core/http_util.py` & `tidy3d-2.7.0rc1/tidy3d/web/core/http_util.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/core/s3utils.py` & `tidy3d-2.7.0rc1/tidy3d/web/core/s3utils.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/core/stub.py` & `tidy3d-2.7.0rc1/tidy3d/web/core/stub.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/core/task_core.py` & `tidy3d-2.7.0rc1/tidy3d/web/core/task_core.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/core/task_info.py` & `tidy3d-2.7.0rc1/tidy3d/web/core/task_info.py`

 * *Files identical despite different names*

### Comparing `tidy3d-2.6.4/tidy3d/web/core/types.py` & `tidy3d-2.7.0rc1/tidy3d/web/core/types.py`

 * *Files 1% similar despite different names*

```diff
@@ -46,7 +46,8 @@
         """List all resources of this type."""
 
 
 class TaskType(str, Enum):
     FDTD = "FDTD"
     MODE_SOLVER = "MODE_SOLVER"
     HEAT = "HEAT"
+    EME = "EME"
```

### Comparing `tidy3d-2.6.4/PKG-INFO` & `tidy3d-2.7.0rc1/PKG-INFO`

 * *Files 9% similar despite different names*

```diff
@@ -1,23 +1,24 @@
 Metadata-Version: 2.1
 Name: tidy3d
-Version: 2.6.4
+Version: 2.7.0rc1
 Summary: A fast FDTD solver
 Home-page: https://github.com/flexcompute/tidy3d
 License: LGPLv2+
 Author: Tyler Hughes
 Author-email: tyler@flexcompute.com
-Requires-Python: >=3.9,<3.12
+Requires-Python: >=3.9,<4.0.0
 Classifier: License :: OSI Approved :: GNU Lesser General Public License v2 or later (LGPLv2+)
 Classifier: License :: Other/Proprietary License
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: 3.12
 Provides-Extra: dev
 Provides-Extra: docs
 Provides-Extra: gdspy
 Provides-Extra: gdstk
 Provides-Extra: jax
 Provides-Extra: trimesh
 Provides-Extra: vtk
@@ -27,51 +28,49 @@
 Requires-Dist: bump-my-version ; extra == "dev"
 Requires-Dist: click (==8.1.*)
 Requires-Dist: cma ; extra == "dev" or extra == "docs"
 Requires-Dist: coverage ; extra == "dev"
 Requires-Dist: dask
 Requires-Dist: devsim ; extra == "dev" or extra == "docs"
 Requires-Dist: dill ; extra == "dev"
+Requires-Dist: flax (>=0.8.2)
 Requires-Dist: gdspy ; extra == "dev" or extra == "gdspy"
 Requires-Dist: gdstk (>=0.9.49) ; extra == "dev" or extra == "dev" or extra == "docs" or extra == "gdstk"
 Requires-Dist: grcwa ; extra == "dev" or extra == "docs"
 Requires-Dist: h5netcdf (==1.0.2)
 Requires-Dist: h5py (>=3.0.0,<4.0.0)
 Requires-Dist: importlib-metadata (>=6.0.0)
 Requires-Dist: ipython ; extra == "dev" or extra == "dev" or extra == "docs"
-Requires-Dist: jax[cpu] (>=0.4.1,<=0.4.14) ; (sys_platform == "darwin") and (extra == "dev" or extra == "jax")
-Requires-Dist: jax[cpu] (>=0.4.1,<=0.4.14) ; (sys_platform == "linux") and (extra == "dev" or extra == "jax")
-Requires-Dist: jax[cpu] (>=0.4.13,<=0.4.14) ; (python_version >= "3.9" and python_version < "4.0" and sys_platform == "win32") and (extra == "dev" or extra == "jax")
-Requires-Dist: jaxlib (>=0.4.1,<=0.4.14) ; (sys_platform == "darwin") and (extra == "dev" or extra == "jax")
-Requires-Dist: jaxlib (>=0.4.1,<=0.4.14) ; (sys_platform == "linux") and (extra == "dev" or extra == "jax")
-Requires-Dist: jaxlib (>=0.4.13,<=0.4.14) ; (python_version >= "3.9" and python_version < "4.0" and sys_platform == "win32") and (extra == "dev" or extra == "jax")
+Requires-Dist: jax[cpu] (>=0.4.13,<=0.4.26) ; extra == "dev" or extra == "jax"
+Requires-Dist: jaxlib (>=0.4.13,<=0.4.26) ; extra == "dev" or extra == "jax"
 Requires-Dist: jinja2 (>=3.1.2) ; extra == "dev" or extra == "docs"
 Requires-Dist: jupyter ; extra == "dev" or extra == "docs"
 Requires-Dist: matplotlib
 Requires-Dist: memory_profiler ; extra == "dev"
 Requires-Dist: myst-parser ; extra == "dev" or extra == "docs"
 Requires-Dist: nbconvert (>=7.11.0) ; extra == "dev" or extra == "docs"
 Requires-Dist: nbdime ; extra == "dev" or extra == "docs"
 Requires-Dist: nbsphinx (>=0.8.7) ; extra == "dev" or extra == "docs"
 Requires-Dist: networkx (>=2.6.3,<3.0.0) ; extra == "dev" or extra == "trimesh"
 Requires-Dist: numpy (<2)
-Requires-Dist: optax ; extra == "dev" or extra == "docs"
+Requires-Dist: optax (>=0.2.2) ; extra == "dev" or extra == "docs"
+Requires-Dist: pandas (<=2.2.1)
 Requires-Dist: pre-commit ; extra == "dev"
 Requires-Dist: pydantic (>=2.0,<3.0)
 Requires-Dist: pydata-sphinx-theme (>=0.13.3) ; extra == "dev" or extra == "docs"
 Requires-Dist: pyjwt
 Requires-Dist: pylint ; extra == "dev" or extra == "docs"
 Requires-Dist: pyroots (>=0.5.0)
 Requires-Dist: pyswarms ; extra == "dev"
 Requires-Dist: pytest ; extra == "dev"
 Requires-Dist: pytest-timeout ; extra == "dev"
 Requires-Dist: requests (==2.31.*)
 Requires-Dist: responses
 Requires-Dist: rich (<12.6.0)
-Requires-Dist: rtree (==1.0.1) ; extra == "dev" or extra == "trimesh"
+Requires-Dist: rtree (==1.2.0) ; extra == "dev" or extra == "trimesh"
 Requires-Dist: ruff (==0.3.2) ; extra == "dev"
 Requires-Dist: sax ; extra == "dev" or extra == "docs"
 Requires-Dist: scipy
 Requires-Dist: shapely (>=2.0,<3.0)
 Requires-Dist: signac ; extra == "dev" or extra == "docs"
 Requires-Dist: sphinx (>=6) ; extra == "dev" or extra == "docs"
 Requires-Dist: sphinx-book-theme (>=1.0.1) ; extra == "dev" or extra == "docs"
@@ -80,16 +79,16 @@
 Requires-Dist: sphinx-notfound-page ; extra == "dev" or extra == "docs"
 Requires-Dist: sphinx-sitemap (>=2.5.1) ; extra == "dev" or extra == "docs"
 Requires-Dist: sphinx-tabs ; extra == "dev" or extra == "docs"
 Requires-Dist: sphinxemoji ; extra == "dev" or extra == "docs"
 Requires-Dist: tmm ; extra == "dev" or extra == "docs"
 Requires-Dist: toml
 Requires-Dist: tox ; extra == "dev"
-Requires-Dist: trimesh (==3.20.0) ; extra == "dev" or extra == "trimesh"
-Requires-Dist: vtk (<=9.2.6) ; extra == "dev" or extra == "vtk"
+Requires-Dist: trimesh (>=4,<5) ; extra == "dev" or extra == "trimesh"
+Requires-Dist: vtk (>=9.2.6) ; extra == "dev" or extra == "vtk"
 Requires-Dist: xarray (>=0.16.2)
 Project-URL: Bug Tracker, https://github.com/flexcompute/tidy3d/issues
 Project-URL: Documentation, https://docs.flexcompute.com/projects/tidy3d/en/latest/
 Project-URL: Repository, https://github.com/flexcompute/tidy3d
 Description-Content-Type: text/markdown
 
 # Tidy3D
```

