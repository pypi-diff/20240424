# Comparing `tmp/azure-mgmt-devcenter-1.1.0.tar.gz` & `tmp/azure-mgmt-devcenter-1.1.0b1.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "azure-mgmt-devcenter-1.1.0.tar", last modified: Wed Apr 24 04:41:11 2024, max compression
+gzip compressed data, was "azure-mgmt-devcenter-1.1.0b1.tar", last modified: Mon Oct 23 05:53:40 2023, max compression
```

## Comparing `azure-mgmt-devcenter-1.1.0.tar` & `azure-mgmt-devcenter-1.1.0b1.tar`

### file list

```diff
@@ -1,91 +1,89 @@
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-04-24 04:41:11.820898 azure-mgmt-devcenter-1.1.0/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10163 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/CHANGELOG.md
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1074 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/LICENSE
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      215 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/MANIFEST.in
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13075 2024-04-24 04:41:11.820898 azure-mgmt-devcenter-1.1.0/PKG-INFO
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2007 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/README.md
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      628 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/_meta.json
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-04-24 04:41:11.808898 azure-mgmt-devcenter-1.1.0/azure/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       65 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/__init__.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-04-24 04:41:11.808898 azure-mgmt-devcenter-1.1.0/azure/mgmt/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       65 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/__init__.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-04-24 04:41:11.808898 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      898 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3421 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/_configuration.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12191 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/_dev_center_mgmt_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/_patch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    78873 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/_serialization.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      778 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/_vendor.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      486 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/_version.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-04-24 04:41:11.808898 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      845 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3469 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/_configuration.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12439 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/_dev_center_mgmt_client.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/_patch.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-04-24 04:41:11.816898 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3002 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    31303 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_attached_networks_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    43941 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_catalogs_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7027 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_check_name_availability_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7092 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_check_scoped_name_availability_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    39693 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_dev_box_definitions_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    33894 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_dev_centers_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    19948 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_environment_definitions_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    23741 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_environment_types_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    22740 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_galleries_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9438 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_image_versions_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13418 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_images_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    51846 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_network_connections_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4789 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_operation_statuses_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5578 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_patch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    35841 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_pools_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9189 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_project_allowed_environment_types_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5227 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_project_catalog_environment_definitions_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    43820 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_project_catalogs_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    24023 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_project_environment_types_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    33522 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_projects_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    34946 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_schedules_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5912 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_skus_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5833 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_usages_operations.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-04-24 04:41:11.816898 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/models/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11469 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/models/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8153 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/models/_dev_center_mgmt_client_enums.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   258682 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/models/_models_py3.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/models/_patch.py
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-04-24 04:41:11.820898 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3002 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/__init__.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    42007 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_attached_networks_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    57875 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_catalogs_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8239 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_check_name_availability_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8336 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_check_scoped_name_availability_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    52145 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_dev_box_definitions_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    42273 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_dev_centers_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    30061 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_environment_definitions_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    33058 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_environment_types_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    29595 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_galleries_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13819 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_image_versions_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18956 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_images_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    66935 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_network_connections_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6046 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_operation_statuses_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6279 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_patch.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    45863 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_pools_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12548 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_project_allowed_environment_types_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7403 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_project_catalog_environment_definitions_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    57642 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_project_catalogs_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    33258 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_project_environment_types_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    41842 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_projects_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    44881 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_schedules_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6984 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_skus_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6931 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_usages_operations.py
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       26 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/py.typed
-drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2024-04-24 04:41:11.820898 azure-mgmt-devcenter-1.1.0/azure_mgmt_devcenter.egg-info/
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13075 2024-04-24 04:41:11.000000 azure-mgmt-devcenter-1.1.0/azure_mgmt_devcenter.egg-info/PKG-INFO
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4195 2024-04-24 04:41:11.000000 azure-mgmt-devcenter-1.1.0/azure_mgmt_devcenter.egg-info/SOURCES.txt
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)        1 2024-04-24 04:41:11.000000 azure-mgmt-devcenter-1.1.0/azure_mgmt_devcenter.egg-info/dependency_links.txt
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)        1 2024-04-24 04:41:11.000000 azure-mgmt-devcenter-1.1.0/azure_mgmt_devcenter.egg-info/not-zip-safe
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       56 2024-04-24 04:41:11.000000 azure-mgmt-devcenter-1.1.0/azure_mgmt_devcenter.egg-info/requires.txt
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)        6 2024-04-24 04:41:11.000000 azure-mgmt-devcenter-1.1.0/azure_mgmt_devcenter.egg-info/top_level.txt
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       38 2024-04-24 04:41:11.820898 azure-mgmt-devcenter-1.1.0/setup.cfg
--rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2784 2024-04-24 04:39:43.000000 azure-mgmt-devcenter-1.1.0/setup.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-10-23 05:53:40.192941 azure-mgmt-devcenter-1.1.0b1/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5710 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/CHANGELOG.md
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     1074 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/LICENSE
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      215 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/MANIFEST.in
+-rw-r--r--   0 cloudtest  (1000) cloudtest  (1000)     8791 2023-10-23 05:53:40.192941 azure-mgmt-devcenter-1.1.0b1/PKG-INFO
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2007 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/README.md
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      626 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/_meta.json
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-10-23 05:53:40.180941 azure-mgmt-devcenter-1.1.0b1/azure/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       65 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/__init__.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-10-23 05:53:40.180941 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       65 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/__init__.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-10-23 05:53:40.184941 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      898 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3495 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/_configuration.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10655 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/_dev_center_mgmt_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/_patch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    79289 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/_serialization.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      778 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/_vendor.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      488 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/_version.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-10-23 05:53:40.184941 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      845 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     3543 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/_configuration.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    10875 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/_dev_center_mgmt_client.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/_patch.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-10-23 05:53:40.184941 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2836 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    35209 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_attached_networks_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13363 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_catalog_dev_box_definitions_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    51266 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_catalogs_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7566 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_check_name_availability_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13008 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_customization_tasks_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    45890 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_dev_box_definitions_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    39449 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_dev_centers_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13500 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_environment_definitions_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    25310 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_environment_types_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    26078 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_galleries_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9914 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_image_versions_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    14084 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_images_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    59242 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_network_connections_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4810 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_operation_statuses_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5657 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_patch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    42179 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_pools_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     9591 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_project_allowed_environment_types_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    25537 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_project_environment_types_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    39117 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_projects_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    40683 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_schedules_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6048 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_skus_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     5998 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_usages_operations.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-10-23 05:53:40.188941 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/models/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    11405 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/models/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7850 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/models/_dev_center_mgmt_client_enums.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)   250466 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/models/_models_py3.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/models/_patch.py
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-10-23 05:53:40.188941 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2836 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/__init__.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    45921 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_attached_networks_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    19528 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_catalog_dev_box_definitions_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    65174 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_catalogs_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     8786 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_check_name_availability_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    18891 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_customization_tasks_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    58328 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_dev_box_definitions_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    47806 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_dev_centers_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    19719 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_environment_definitions_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    34667 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_environment_types_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    32925 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_galleries_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    13809 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_image_versions_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    19478 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_images_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    74298 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_network_connections_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6075 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_operation_statuses_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     6366 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      674 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_patch.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    52169 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_pools_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    12966 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_project_allowed_environment_types_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    34812 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_project_environment_types_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    47415 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_projects_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)    50588 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_schedules_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7128 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_skus_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     7104 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_usages_operations.py
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       26 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/py.typed
+drwxrwxr-x   0 cloudtest  (1000) cloudtest  (1000)        0 2023-10-23 05:53:40.192941 azure-mgmt-devcenter-1.1.0b1/azure_mgmt_devcenter.egg-info/
+-rw-r--r--   0 cloudtest  (1000) cloudtest  (1000)     8791 2023-10-23 05:53:40.000000 azure-mgmt-devcenter-1.1.0b1/azure_mgmt_devcenter.egg-info/PKG-INFO
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     4017 2023-10-23 05:53:40.000000 azure-mgmt-devcenter-1.1.0b1/azure_mgmt_devcenter.egg-info/SOURCES.txt
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)        1 2023-10-23 05:53:40.000000 azure-mgmt-devcenter-1.1.0b1/azure_mgmt_devcenter.egg-info/dependency_links.txt
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)        1 2023-10-23 05:53:39.000000 azure-mgmt-devcenter-1.1.0b1/azure_mgmt_devcenter.egg-info/not-zip-safe
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)      124 2023-10-23 05:53:40.000000 azure-mgmt-devcenter-1.1.0b1/azure_mgmt_devcenter.egg-info/requires.txt
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)        6 2023-10-23 05:53:40.000000 azure-mgmt-devcenter-1.1.0b1/azure_mgmt_devcenter.egg-info/top_level.txt
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)       38 2023-10-23 05:53:40.192941 azure-mgmt-devcenter-1.1.0b1/setup.cfg
+-rw-rw-r--   0 cloudtest  (1000) cloudtest  (1000)     2844 2023-10-23 05:52:53.000000 azure-mgmt-devcenter-1.1.0b1/setup.py
```

### Comparing `azure-mgmt-devcenter-1.1.0/LICENSE` & `azure-mgmt-devcenter-1.1.0b1/LICENSE`

 * *Files identical despite different names*

### Comparing `azure-mgmt-devcenter-1.1.0/README.md` & `azure-mgmt-devcenter-1.1.0b1/README.md`

 * *Files 5% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 # Microsoft Azure SDK for Python
 
 This is the Microsoft Azure Devcenter Management Client Library.
-This package has been tested with Python 3.8+.
+This package has been tested with Python 3.7+.
 For a more complete view of Azure libraries, see the [azure sdk python release](https://aka.ms/azsdk/python/all).
 
 ## _Disclaimer_
 
 _Azure SDK Python packages support for Python 2.7 has ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691_
 
 ## Getting started
 
 ### Prerequisites
 
-- Python 3.8+ is required to use this package.
+- Python 3.7+ is required to use this package.
 - [Azure subscription](https://azure.microsoft.com/free/)
 
 ### Install the package
 
 ```bash
 pip install azure-mgmt-devcenter
 pip install azure-identity
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/__init__.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/_configuration.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/_configuration.py`

 * *Files 4% similar despite different names*

```diff
@@ -4,62 +4,63 @@
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from typing import Any, TYPE_CHECKING
 
+from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
-class DevCenterMgmtClientConfiguration:  # pylint: disable=too-many-instance-attributes,name-too-long
+class DevCenterMgmtClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DevCenterMgmtClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2024-02-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2023-10-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
-        api_version: str = kwargs.pop("api_version", "2024-02-01")
+        super(DevCenterMgmtClientConfiguration, self).__init__(**kwargs)
+        api_version: str = kwargs.pop("api_version", "2023-10-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
         self.subscription_id = subscription_id
         self.api_version = api_version
         self.credential_scopes = kwargs.pop("credential_scopes", ["https://management.azure.com/.default"])
         kwargs.setdefault("sdk_moniker", "mgmt-devcenter/{}".format(VERSION))
-        self.polling_interval = kwargs.get("polling_interval", 30)
         self._configure(**kwargs)
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
         self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
             self.authentication_policy = ARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/_dev_center_mgmt_client.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/_dev_center_mgmt_client.py`

 * *Files 12% similar despite different names*

```diff
@@ -5,41 +5,38 @@
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from copy import deepcopy
 from typing import Any, TYPE_CHECKING
 
-from azure.core.pipeline import policies
 from azure.core.rest import HttpRequest, HttpResponse
 from azure.mgmt.core import ARMPipelineClient
-from azure.mgmt.core.policies import ARMAutoResourceProviderRegistrationPolicy
 
 from . import models as _models
 from ._configuration import DevCenterMgmtClientConfiguration
 from ._serialization import Deserializer, Serializer
 from .operations import (
     AttachedNetworksOperations,
+    CatalogDevBoxDefinitionsOperations,
     CatalogsOperations,
     CheckNameAvailabilityOperations,
-    CheckScopedNameAvailabilityOperations,
+    CustomizationTasksOperations,
     DevBoxDefinitionsOperations,
     DevCentersOperations,
     EnvironmentDefinitionsOperations,
     EnvironmentTypesOperations,
     GalleriesOperations,
     ImageVersionsOperations,
     ImagesOperations,
     NetworkConnectionsOperations,
     OperationStatusesOperations,
     Operations,
     PoolsOperations,
     ProjectAllowedEnvironmentTypesOperations,
-    ProjectCatalogEnvironmentDefinitionsOperations,
-    ProjectCatalogsOperations,
     ProjectEnvironmentTypesOperations,
     ProjectsOperations,
     SchedulesOperations,
     SkusOperations,
     UsagesOperations,
 )
 
@@ -53,23 +50,14 @@
 
     :ivar dev_centers: DevCentersOperations operations
     :vartype dev_centers: azure.mgmt.devcenter.operations.DevCentersOperations
     :ivar projects: ProjectsOperations operations
     :vartype projects: azure.mgmt.devcenter.operations.ProjectsOperations
     :ivar attached_networks: AttachedNetworksOperations operations
     :vartype attached_networks: azure.mgmt.devcenter.operations.AttachedNetworksOperations
-    :ivar project_catalogs: ProjectCatalogsOperations operations
-    :vartype project_catalogs: azure.mgmt.devcenter.operations.ProjectCatalogsOperations
-    :ivar environment_definitions: EnvironmentDefinitionsOperations operations
-    :vartype environment_definitions:
-     azure.mgmt.devcenter.operations.EnvironmentDefinitionsOperations
-    :ivar project_catalog_environment_definitions: ProjectCatalogEnvironmentDefinitionsOperations
-     operations
-    :vartype project_catalog_environment_definitions:
-     azure.mgmt.devcenter.operations.ProjectCatalogEnvironmentDefinitionsOperations
     :ivar galleries: GalleriesOperations operations
     :vartype galleries: azure.mgmt.devcenter.operations.GalleriesOperations
     :ivar images: ImagesOperations operations
     :vartype images: azure.mgmt.devcenter.operations.ImagesOperations
     :ivar image_versions: ImageVersionsOperations operations
     :vartype image_versions: azure.mgmt.devcenter.operations.ImageVersionsOperations
     :ivar catalogs: CatalogsOperations operations
@@ -89,33 +77,38 @@
     :ivar operation_statuses: OperationStatusesOperations operations
     :vartype operation_statuses: azure.mgmt.devcenter.operations.OperationStatusesOperations
     :ivar usages: UsagesOperations operations
     :vartype usages: azure.mgmt.devcenter.operations.UsagesOperations
     :ivar check_name_availability: CheckNameAvailabilityOperations operations
     :vartype check_name_availability:
      azure.mgmt.devcenter.operations.CheckNameAvailabilityOperations
-    :ivar check_scoped_name_availability: CheckScopedNameAvailabilityOperations operations
-    :vartype check_scoped_name_availability:
-     azure.mgmt.devcenter.operations.CheckScopedNameAvailabilityOperations
+    :ivar catalog_dev_box_definitions: CatalogDevBoxDefinitionsOperations operations
+    :vartype catalog_dev_box_definitions:
+     azure.mgmt.devcenter.operations.CatalogDevBoxDefinitionsOperations
+    :ivar customization_tasks: CustomizationTasksOperations operations
+    :vartype customization_tasks: azure.mgmt.devcenter.operations.CustomizationTasksOperations
+    :ivar environment_definitions: EnvironmentDefinitionsOperations operations
+    :vartype environment_definitions:
+     azure.mgmt.devcenter.operations.EnvironmentDefinitionsOperations
     :ivar skus: SkusOperations operations
     :vartype skus: azure.mgmt.devcenter.operations.SkusOperations
     :ivar pools: PoolsOperations operations
     :vartype pools: azure.mgmt.devcenter.operations.PoolsOperations
     :ivar schedules: SchedulesOperations operations
     :vartype schedules: azure.mgmt.devcenter.operations.SchedulesOperations
     :ivar network_connections: NetworkConnectionsOperations operations
     :vartype network_connections: azure.mgmt.devcenter.operations.NetworkConnectionsOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2024-02-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2023-10-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(
         self,
@@ -123,52 +116,25 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DevCenterMgmtClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        _policies = kwargs.pop("policies", None)
-        if _policies is None:
-            _policies = [
-                policies.RequestIdPolicy(**kwargs),
-                self._config.headers_policy,
-                self._config.user_agent_policy,
-                self._config.proxy_policy,
-                policies.ContentDecodePolicy(**kwargs),
-                ARMAutoResourceProviderRegistrationPolicy(),
-                self._config.redirect_policy,
-                self._config.retry_policy,
-                self._config.authentication_policy,
-                self._config.custom_hook_policy,
-                self._config.logging_policy,
-                policies.DistributedTracingPolicy(**kwargs),
-                policies.SensitiveHeaderCleanupPolicy(**kwargs) if self._config.redirect_policy else None,
-                self._config.http_logging_policy,
-            ]
-        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, policies=_policies, **kwargs)
+        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.dev_centers = DevCentersOperations(self._client, self._config, self._serialize, self._deserialize)
         self.projects = ProjectsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.attached_networks = AttachedNetworksOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
-        self.project_catalogs = ProjectCatalogsOperations(
-            self._client, self._config, self._serialize, self._deserialize
-        )
-        self.environment_definitions = EnvironmentDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
-        )
-        self.project_catalog_environment_definitions = ProjectCatalogEnvironmentDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
-        )
         self.galleries = GalleriesOperations(self._client, self._config, self._serialize, self._deserialize)
         self.images = ImagesOperations(self._client, self._config, self._serialize, self._deserialize)
         self.image_versions = ImageVersionsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.catalogs = CatalogsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.environment_types = EnvironmentTypesOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
@@ -185,25 +151,31 @@
         self.operation_statuses = OperationStatusesOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.usages = UsagesOperations(self._client, self._config, self._serialize, self._deserialize)
         self.check_name_availability = CheckNameAvailabilityOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
-        self.check_scoped_name_availability = CheckScopedNameAvailabilityOperations(
+        self.catalog_dev_box_definitions = CatalogDevBoxDefinitionsOperations(
+            self._client, self._config, self._serialize, self._deserialize
+        )
+        self.customization_tasks = CustomizationTasksOperations(
+            self._client, self._config, self._serialize, self._deserialize
+        )
+        self.environment_definitions = EnvironmentDefinitionsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.skus = SkusOperations(self._client, self._config, self._serialize, self._deserialize)
         self.pools = PoolsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.schedules = SchedulesOperations(self._client, self._config, self._serialize, self._deserialize)
         self.network_connections = NetworkConnectionsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
 
-    def _send_request(self, request: HttpRequest, *, stream: bool = False, **kwargs: Any) -> HttpResponse:
+    def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
         <HttpRequest [GET], url: 'https://www.example.org/'>
         >>> response = client._send_request(request)
         <HttpResponse: 200 OK>
@@ -215,15 +187,15 @@
         :keyword bool stream: Whether the response payload will be streamed. Defaults to False.
         :return: The response of your network call. Does not do error handling on your response.
         :rtype: ~azure.core.rest.HttpResponse
         """
 
         request_copy = deepcopy(request)
         request_copy.url = self._client.format_url(request_copy.url)
-        return self._client.send_request(request_copy, stream=stream, **kwargs)  # type: ignore
+        return self._client.send_request(request_copy, **kwargs)
 
     def close(self) -> None:
         self._client.close()
 
     def __enter__(self) -> "DevCenterMgmtClient":
         self._client.__enter__()
         return self
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/_patch.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/_serialization.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/_serialization.py`

 * *Files 2% similar despite different names*

```diff
@@ -59,16 +59,16 @@
     from urllib import quote  # type: ignore
 except ImportError:
     from urllib.parse import quote
 import xml.etree.ElementTree as ET
 
 import isodate  # type: ignore
 
-from azure.core.exceptions import DeserializationError, SerializationError
-from azure.core.serialization import NULL as CoreNull
+from azure.core.exceptions import DeserializationError, SerializationError, raise_with_traceback
+from azure.core.serialization import NULL as AzureCoreNull
 
 _BOM = codecs.BOM_UTF8.decode(encoding="utf-8")
 
 ModelType = TypeVar("ModelType", bound="Model")
 JSON = MutableMapping[str, Any]
 
 
@@ -120,15 +120,15 @@
                     if isinstance(data, unicode):  # type: ignore
                         # If I'm Python 2.7 and unicode XML will scream if I try a "fromstring" on unicode string
                         data_as_str = data_as_str.encode(encoding="utf-8")  # type: ignore
                 except NameError:
                     pass
 
                 return ET.fromstring(data_as_str)  # nosec
-            except ET.ParseError as err:
+            except ET.ParseError:
                 # It might be because the server has an issue, and returned JSON with
                 # content-type XML....
                 # So let's try a JSON load, and if it's still broken
                 # let's flow the initial exception
                 def _json_attemp(data):
                     try:
                         return True, json.loads(data)
@@ -139,15 +139,15 @@
                 if success:
                     return json_result
                 # If i'm here, it's not JSON, it's not XML, let's scream
                 # and raise the last context in this block (the XML exception)
                 # The function hack is because Py2.7 messes up with exception
                 # context otherwise.
                 _LOGGER.critical("Wasn't XML not JSON, failing")
-                raise DeserializationError("XML is invalid") from err
+                raise_with_traceback(DeserializationError, "XML is invalid")
         raise DeserializationError("Cannot deserialize content-type: {}".format(content_type))
 
     @classmethod
     def deserialize_from_http_generics(cls, body_bytes: Optional[Union[AnyStr, IO]], headers: Mapping) -> Any:
         """Deserialize from HTTP response.
 
         Use bytes and headers to NOT use any requests/aiohttp or whatever
@@ -166,14 +166,21 @@
             content_type = "application/json"
 
         if body_bytes:
             return cls.deserialize_from_text(body_bytes, content_type)
         return None
 
 
+try:
+    basestring  # type: ignore
+    unicode_str = unicode  # type: ignore
+except NameError:
+    basestring = str
+    unicode_str = str
+
 _LOGGER = logging.getLogger(__name__)
 
 try:
     _long_type = long  # type: ignore
 except NameError:
     _long_type = int
 
@@ -284,15 +291,15 @@
     """
 
     _subtype_map: Dict[str, Dict[str, Any]] = {}
     _attribute_map: Dict[str, Dict[str, Any]] = {}
     _validation: Dict[str, Dict[str, Any]] = {}
 
     def __init__(self, **kwargs: Any) -> None:
-        self.additional_properties: Optional[Dict[str, Any]] = {}
+        self.additional_properties: Dict[str, Any] = {}
         for k in kwargs:
             if k not in self._attribute_map:
                 _LOGGER.warning("%s is not a known attribute of class %s and will be ignored", k, self.__class__)
             elif k in self._validation and self._validation[k].get("readonly", False):
                 _LOGGER.warning("Readonly attribute %s will be ignored in class %s", k, self.__class__)
             else:
                 setattr(self, k, kwargs[k])
@@ -329,26 +336,26 @@
             xml_map = cls._xml_map  # type: ignore
         except AttributeError:
             xml_map = {}
 
         return _create_xml_node(xml_map.get("name", cls.__name__), xml_map.get("prefix", None), xml_map.get("ns", None))
 
     def serialize(self, keep_readonly: bool = False, **kwargs: Any) -> JSON:
-        """Return the JSON that would be sent to server from this model.
+        """Return the JSON that would be sent to azure from this model.
 
         This is an alias to `as_dict(full_restapi_key_transformer, keep_readonly=False)`.
 
         If you want XML serialization, you can pass the kwargs is_xml=True.
 
         :param bool keep_readonly: If you want to serialize the readonly attributes
         :returns: A dict JSON compatible object
         :rtype: dict
         """
         serializer = Serializer(self._infer_class_models())
-        return serializer._serialize(self, keep_readonly=keep_readonly, **kwargs)  # type: ignore
+        return serializer._serialize(self, keep_readonly=keep_readonly, **kwargs)
 
     def as_dict(
         self,
         keep_readonly: bool = True,
         key_transformer: Callable[[str, Dict[str, Any], Any], Any] = attribute_transformer,
         **kwargs: Any
     ) -> JSON:
@@ -379,15 +386,15 @@
         If you want XML serialization, you can pass the kwargs is_xml=True.
 
         :param function key_transformer: A key transformer function.
         :returns: A dict JSON compatible object
         :rtype: dict
         """
         serializer = Serializer(self._infer_class_models())
-        return serializer._serialize(self, key_transformer=key_transformer, keep_readonly=keep_readonly, **kwargs)  # type: ignore
+        return serializer._serialize(self, key_transformer=key_transformer, keep_readonly=keep_readonly, **kwargs)
 
     @classmethod
     def _infer_class_models(cls):
         try:
             str_models = cls.__module__.rsplit(".", 1)[0]
             models = sys.modules[str_models]
             client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
@@ -404,15 +411,15 @@
 
         :param str data: A str using RestAPI structure. JSON by default.
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
-        return deserializer(cls.__name__, data, content_type=content_type)  # type: ignore
+        return deserializer(cls.__name__, data, content_type=content_type)
 
     @classmethod
     def from_dict(
         cls: Type[ModelType],
         data: Any,
         key_extractors: Optional[Callable[[str, Dict[str, Any], Any], Any]] = None,
         content_type: Optional[str] = None,
@@ -434,15 +441,15 @@
                 attribute_key_case_insensitive_extractor,
                 rest_key_case_insensitive_extractor,
                 last_rest_key_case_insensitive_extractor,
             ]
             if key_extractors is None
             else key_extractors
         )
-        return deserializer(cls.__name__, data, content_type=content_type)  # type: ignore
+        return deserializer(cls.__name__, data, content_type=content_type)
 
     @classmethod
     def _flatten_subtype(cls, key, objects):
         if "_subtype_map" not in cls.__dict__:
             return {}
         result = dict(cls._subtype_map[key])
         for valuetype in cls._subtype_map[key].values():
@@ -534,15 +541,15 @@
         "min_items": lambda x, y: len(x) < y,
         "max_items": lambda x, y: len(x) > y,
         "pattern": lambda x, y: not re.match(y, x, re.UNICODE),
         "unique": lambda x, y: len(x) != len(set(x)),
         "multiple": lambda x, y: x % y != 0,
     }
 
-    def __init__(self, classes: Optional[Mapping[str, type]] = None):
+    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]] = None):
         self.serialize_type = {
             "iso-8601": Serializer.serialize_iso,
             "rfc-1123": Serializer.serialize_rfc,
             "unix-time": Serializer.serialize_unix,
             "duration": Serializer.serialize_duration,
             "date": Serializer.serialize_date,
             "time": Serializer.serialize_time,
@@ -550,15 +557,15 @@
             "long": Serializer.serialize_long,
             "bytearray": Serializer.serialize_bytearray,
             "base64": Serializer.serialize_base64,
             "object": self.serialize_object,
             "[]": self.serialize_iter,
             "{}": self.serialize_dict,
         }
-        self.dependencies: Dict[str, type] = dict(classes) if classes else {}
+        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
         self.key_transformer = full_restapi_key_transformer
         self.client_side_validation = True
 
     def _serialize(self, target_obj, data_type=None, **kwargs):
         """Serialize data into a string according to type.
 
         :param target_obj: The data to be serialized.
@@ -638,15 +645,15 @@
                                     new_attr.tag = "}".join([splitted_tag[0], xml_name])
                                 else:
                                     new_attr.tag = xml_name
                             serialized.append(new_attr)  # type: ignore
                         else:  # That's a basic type
                             # Integrate namespace if necessary
                             local_node = _create_xml_node(xml_name, xml_prefix, xml_ns)
-                            local_node.text = str(new_attr)
+                            local_node.text = unicode_str(new_attr)
                             serialized.append(local_node)  # type: ignore
                     else:  # JSON
                         for k in reversed(keys):  # type: ignore
                             new_attr = {k: new_attr}
 
                         _new_attr = new_attr
                         _serialized = serialized
@@ -657,15 +664,15 @@
                             _serialized = _serialized[k]
                 except ValueError as err:
                     if isinstance(err, SerializationError):
                         raise
 
         except (AttributeError, KeyError, TypeError) as err:
             msg = "Attribute {} in object {} cannot be serialized.\n{}".format(attr_name, class_name, str(target_obj))
-            raise SerializationError(msg) from err
+            raise_with_traceback(SerializationError, msg, err)
         else:
             return serialized
 
     def body(self, data, data_type, **kwargs):
         """Serialize data intended for a request body.
 
         :param data: The data to be serialized.
@@ -699,15 +706,15 @@
                     deserializer.key_extractors = [
                         rest_key_case_insensitive_extractor,
                         attribute_key_case_insensitive_extractor,
                         last_rest_key_case_insensitive_extractor,
                     ]
                 data = deserializer._deserialize(data_type, data)
             except DeserializationError as err:
-                raise SerializationError("Unable to build a model: " + str(err)) from err
+                raise_with_traceback(SerializationError, "Unable to build a model: " + str(err), err)
 
         return self._serialize(data, data_type, **kwargs)
 
     def url(self, name, data, data_type, **kwargs):
         """Serialize data intended for a URL path.
 
         :param data: The data to be serialized.
@@ -719,39 +726,38 @@
         try:
             output = self.serialize_data(data, data_type, **kwargs)
             if data_type == "bool":
                 output = json.dumps(output)
 
             if kwargs.get("skip_quote") is True:
                 output = str(output)
-                output = output.replace("{", quote("{")).replace("}", quote("}"))
             else:
                 output = quote(str(output), safe="")
         except SerializationError:
             raise TypeError("{} must be type {}.".format(name, data_type))
         else:
             return output
 
     def query(self, name, data, data_type, **kwargs):
         """Serialize data intended for a URL query.
 
         :param data: The data to be serialized.
         :param str data_type: The type to be serialized from.
         :keyword bool skip_quote: Whether to skip quote the serialized result.
         Defaults to False.
-        :rtype: str, list
+        :rtype: str
         :raises: TypeError if serialization fails.
         :raises: ValueError if data is None
         """
         try:
             # Treat the list aside, since we don't want to encode the div separator
             if data_type.startswith("["):
                 internal_data_type = data_type[1:-1]
                 do_quote = not kwargs.get("skip_quote", False)
-                return self.serialize_iter(data, internal_data_type, do_quote=do_quote, **kwargs)
+                return str(self.serialize_iter(data, internal_data_type, do_quote=do_quote, **kwargs))
 
             # Not a list, regular serialization
             output = self.serialize_data(data, data_type, **kwargs)
             if data_type == "bool":
                 output = json.dumps(output)
             if kwargs.get("skip_quote") is True:
                 output = str(output)
@@ -794,15 +800,15 @@
         :raises: ValueError if data is None
         :raises: SerializationError if serialization fails.
         """
         if data is None:
             raise ValueError("No value for given attribute")
 
         try:
-            if data is CoreNull:
+            if data is AzureCoreNull:
                 return None
             if data_type in self.basic_types.values():
                 return self.serialize_basic(data, data_type, **kwargs)
 
             elif data_type in self.serialize_type:
                 return self.serialize_type[data_type](data, **kwargs)
 
@@ -814,15 +820,15 @@
 
             iter_type = data_type[0] + data_type[-1]
             if iter_type in self.serialize_type:
                 return self.serialize_type[iter_type](data, data_type[1:-1], **kwargs)
 
         except (ValueError, TypeError) as err:
             msg = "Unable to serialize value: {!r} as type: {!r}."
-            raise SerializationError(msg.format(data, data_type)) from err
+            raise_with_traceback(SerializationError, msg.format(data, data_type), err)
         else:
             return self._serialize(data, **kwargs)
 
     @classmethod
     def _get_custom_serializers(cls, data_type, **kwargs):
         custom_serializer = kwargs.get("basic_types_serializers", {}).get(data_type)
         if custom_serializer:
@@ -983,15 +989,15 @@
         if isinstance(attr, ET.Element):
             return attr
         obj_type = type(attr)
         if obj_type in self.basic_types:
             return self.serialize_basic(attr, self.basic_types[obj_type], **kwargs)
         if obj_type is _long_type:
             return self.serialize_long(attr)
-        if obj_type is str:
+        if obj_type is unicode_str:
             return self.serialize_unicode(attr)
         if obj_type is datetime.datetime:
             return self.serialize_iso(attr)
         if obj_type is datetime.date:
             return self.serialize_date(attr)
         if obj_type is datetime.time:
             return self.serialize_time(attr)
@@ -1160,18 +1166,18 @@
                 microseconds = "." + microseconds
             date = "{:04}-{:02}-{:02}T{:02}:{:02}:{:02}".format(
                 utc.tm_year, utc.tm_mon, utc.tm_mday, utc.tm_hour, utc.tm_min, utc.tm_sec
             )
             return date + microseconds + "Z"
         except (ValueError, OverflowError) as err:
             msg = "Unable to serialize datetime object."
-            raise SerializationError(msg) from err
+            raise_with_traceback(SerializationError, msg, err)
         except AttributeError as err:
             msg = "ISO-8601 object must be valid Datetime object."
-            raise TypeError(msg) from err
+            raise_with_traceback(TypeError, msg, err)
 
     @staticmethod
     def serialize_unix(attr, **kwargs):
         """Serialize Datetime object into IntTime format.
         This is represented as seconds.
 
         :param Datetime attr: Object to be serialized.
@@ -1199,14 +1205,15 @@
             key = _decode_attribute_map_key(dict_keys[0])
             break
         working_key = _decode_attribute_map_key(dict_keys[0])
         working_data = working_data.get(working_key, data)
         if working_data is None:
             # If at any point while following flatten JSON path see None, it means
             # that all properties under are None as well
+            # https://github.com/Azure/msrest-for-python/issues/197
             return None
         key = ".".join(dict_keys[1:])
 
     return working_data.get(key)
 
 
 def rest_key_case_insensitive_extractor(attr, attr_desc, data):
@@ -1219,14 +1226,15 @@
             key = _decode_attribute_map_key(dict_keys[0])
             break
         working_key = _decode_attribute_map_key(dict_keys[0])
         working_data = attribute_key_case_insensitive_extractor(working_key, None, working_data)
         if working_data is None:
             # If at any point while following flatten JSON path see None, it means
             # that all properties under are None as well
+            # https://github.com/Azure/msrest-for-python/issues/197
             return None
         key = ".".join(dict_keys[1:])
 
     if working_data:
         return attribute_key_case_insensitive_extractor(key, None, working_data)
 
 
@@ -1359,15 +1367,15 @@
     :ivar list key_extractors: Ordered list of extractors to be used by this deserializer.
     """
 
     basic_types = {str: "str", int: "int", bool: "bool", float: "float"}
 
     valid_date = re.compile(r"\d{4}[-]\d{2}[-]\d{2}T\d{2}:\d{2}:\d{2}" r"\.?\d*Z?[-+]?[\d{2}]?:?[\d{2}]?")
 
-    def __init__(self, classes: Optional[Mapping[str, type]] = None):
+    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]] = None):
         self.deserialize_type = {
             "iso-8601": Deserializer.deserialize_iso,
             "rfc-1123": Deserializer.deserialize_rfc,
             "unix-time": Deserializer.deserialize_unix,
             "duration": Deserializer.deserialize_duration,
             "date": Deserializer.deserialize_date,
             "time": Deserializer.deserialize_time,
@@ -1379,15 +1387,15 @@
             "[]": self.deserialize_iter,
             "{}": self.deserialize_dict,
         }
         self.deserialize_expected_types = {
             "duration": (isodate.Duration, datetime.timedelta),
             "iso-8601": (datetime.datetime),
         }
-        self.dependencies: Dict[str, type] = dict(classes) if classes else {}
+        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
         self.key_extractors = [rest_key_extractor, xml_key_extractor]
         # Additional properties only works if the "rest_key_extractor" is used to
         # extract the keys. Making it to work whatever the key extractor is too much
         # complicated, with no real scenario for now.
         # So adding a flag to disable additional properties detection. This flag should be
         # used if your expect the deserialization to NOT come from a JSON REST syntax.
         # Otherwise, result are unexpected
@@ -1432,15 +1440,15 @@
                     setattr(data, attr, self._deserialize(local_type, value))
                 return data
             except AttributeError:
                 return
 
         response, class_name = self._classify_target(target_obj, data)
 
-        if isinstance(response, str):
+        if isinstance(response, basestring):
             return self.deserialize_data(data, response)
         elif isinstance(response, type) and issubclass(response, Enum):
             return self.deserialize_enum(data, response)
 
         if data is None:
             return data
         try:
@@ -1469,15 +1477,15 @@
                             continue
                         raw_value = found_value
 
                 value = self.deserialize_data(raw_value, attr_desc["type"])
                 d_attrs[attr] = value
         except (AttributeError, TypeError, KeyError) as err:
             msg = "Unable to deserialize to object: " + class_name  # type: ignore
-            raise DeserializationError(msg) from err
+            raise_with_traceback(DeserializationError, msg, err)
         else:
             additional_properties = self._build_additional_properties(attributes, data)
             return self._instantiate_model(response, d_attrs, additional_properties)
 
     def _build_additional_properties(self, attribute_map, data):
         if not self.additional_properties_detection:
             return None
@@ -1503,22 +1511,22 @@
 
         :param str target: The target object type to deserialize to.
         :param str/dict data: The response data to deserialize.
         """
         if target is None:
             return None, None
 
-        if isinstance(target, str):
+        if isinstance(target, basestring):
             try:
                 target = self.dependencies[target]
             except KeyError:
                 return target, target
 
         try:
-            target = target._classify(data, self.dependencies)  # type: ignore
+            target = target._classify(data, self.dependencies)
         except AttributeError:
             pass  # Target is not a Model, no classify
         return target, target.__class__.__name__  # type: ignore
 
     def failsafe_deserialize(self, target_obj, data, content_type=None):
         """Ignores any errors encountered in deserialization,
         and falls back to not deserializing the object. Recommended
@@ -1566,15 +1574,15 @@
         if hasattr(raw_data, "body"):
             return RawDeserializer.deserialize_from_http_generics(raw_data.text(), raw_data.headers)
 
         # Assume this enough to recognize requests.Response without importing it.
         if hasattr(raw_data, "_content_consumed"):
             return RawDeserializer.deserialize_from_http_generics(raw_data.text, raw_data.headers)
 
-        if isinstance(raw_data, (str, bytes)) or hasattr(raw_data, "read"):
+        if isinstance(raw_data, (basestring, bytes)) or hasattr(raw_data, "read"):
             return RawDeserializer.deserialize_from_text(raw_data, content_type)  # type: ignore
         return raw_data
 
     def _instantiate_model(self, response, attrs, additional_properties=None):
         """Instantiate a response model passing in deserialized args.
 
         :param response: The response model class.
@@ -1640,15 +1648,15 @@
                 if isinstance(data, ET.Element):
                     data = data.text
                 return self.deserialize_enum(data, obj_type)
 
         except (ValueError, TypeError, AttributeError) as err:
             msg = "Unable to deserialize response data."
             msg += " Data: {}, {}".format(data, data_type)
-            raise DeserializationError(msg) from err
+            raise_with_traceback(DeserializationError, msg, err)
         else:
             return self._deserialize(obj_type, data)
 
     def deserialize_iter(self, attr, iter_type):
         """Deserialize an iterable.
 
         :param list attr: Iterable to be deserialized.
@@ -1688,15 +1696,15 @@
         :raises: TypeError if non-builtin datatype encountered.
         """
         if attr is None:
             return None
         if isinstance(attr, ET.Element):
             # Do no recurse on XML, just return the tree as-is
             return attr
-        if isinstance(attr, str):
+        if isinstance(attr, basestring):
             return self.deserialize_basic(attr, "str")
         obj_type = type(attr)
         if obj_type in self.basic_types:
             return self.deserialize_basic(attr, self.basic_types[obj_type])
         if obj_type is _long_type:
             return self.deserialize_long(attr)
 
@@ -1745,15 +1753,15 @@
                     # None or '', node <a/> with a strong type is None.
                     # Don't try to model "empty bool" or "empty int"
                     return None
 
         if data_type == "bool":
             if attr in [True, False, 1, 0]:
                 return bool(attr)
-            elif isinstance(attr, str):
+            elif isinstance(attr, basestring):
                 if attr.lower() in ["true", "1"]:
                     return True
                 elif attr.lower() in ["false", "0"]:
                     return False
             raise TypeError("Invalid boolean value: {}".format(attr))
 
         if data_type == "str":
@@ -1796,14 +1804,15 @@
         """
         if isinstance(data, enum_obj) or data is None:
             return data
         if isinstance(data, Enum):
             data = data.value
         if isinstance(data, int):
             # Workaround. We might consider remove it in the future.
+            # https://github.com/Azure/azure-rest-api-specs/issues/141
             try:
                 return list(enum_obj.__members__.values())[data]
             except IndexError:
                 error = "{!r} is not a valid index for enum {!r}"
                 raise DeserializationError(error.format(data, enum_obj))
         try:
             return enum_obj(str(data))
@@ -1849,18 +1858,18 @@
         :param str attr: response string to be deserialized.
         :rtype: Decimal
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         try:
-            return decimal.Decimal(str(attr))  # type: ignore
+            return decimal.Decimal(attr)  # type: ignore
         except decimal.DecimalException as err:
             msg = "Invalid decimal {}".format(attr)
-            raise DeserializationError(msg) from err
+            raise_with_traceback(DeserializationError, msg, err)
 
     @staticmethod
     def deserialize_long(attr):
         """Deserialize string into long (Py2) or int (Py3).
 
         :param str attr: response string to be deserialized.
         :rtype: long or int
@@ -1880,15 +1889,15 @@
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         try:
             duration = isodate.parse_duration(attr)
         except (ValueError, OverflowError, AttributeError) as err:
             msg = "Cannot deserialize duration object."
-            raise DeserializationError(msg) from err
+            raise_with_traceback(DeserializationError, msg, err)
         else:
             return duration
 
     @staticmethod
     def deserialize_date(attr):
         """Deserialize ISO-8601 formatted string into Date object.
 
@@ -1897,15 +1906,15 @@
         :raises: DeserializationError if string format invalid.
         """
         if isinstance(attr, ET.Element):
             attr = attr.text
         if re.search(r"[^\W\d_]", attr, re.I + re.U):  # type: ignore
             raise DeserializationError("Date must have only digits and -. Received: %s" % attr)
         # This must NOT use defaultmonth/defaultday. Using None ensure this raises an exception.
-        return isodate.parse_date(attr, defaultmonth=0, defaultday=0)
+        return isodate.parse_date(attr, defaultmonth=None, defaultday=None)
 
     @staticmethod
     def deserialize_time(attr):
         """Deserialize ISO-8601 formatted string into time object.
 
         :param str attr: response string to be deserialized.
         :rtype: datetime.time
@@ -1932,15 +1941,15 @@
             date_obj = datetime.datetime(
                 *parsed_date[:6], tzinfo=_FixedOffset(datetime.timedelta(minutes=(parsed_date[9] or 0) / 60))
             )
             if not date_obj.tzinfo:
                 date_obj = date_obj.astimezone(tz=TZ_UTC)
         except ValueError as err:
             msg = "Cannot deserialize to rfc datetime object."
-            raise DeserializationError(msg) from err
+            raise_with_traceback(DeserializationError, msg, err)
         else:
             return date_obj
 
     @staticmethod
     def deserialize_iso(attr):
         """Deserialize ISO-8601 formatted string into Datetime object.
 
@@ -1969,15 +1978,15 @@
 
             date_obj = isodate.parse_datetime(attr)
             test_utc = date_obj.utctimetuple()
             if test_utc.tm_year > 9999 or test_utc.tm_year < 1:
                 raise OverflowError("Hit max or min date")
         except (ValueError, OverflowError, AttributeError) as err:
             msg = "Cannot deserialize datetime object."
-            raise DeserializationError(msg) from err
+            raise_with_traceback(DeserializationError, msg, err)
         else:
             return date_obj
 
     @staticmethod
     def deserialize_unix(attr):
         """Serialize Datetime object into IntTime format.
         This is represented as seconds.
@@ -1985,14 +1994,13 @@
         :param int attr: Object to be serialized.
         :rtype: Datetime
         :raises: DeserializationError if format invalid
         """
         if isinstance(attr, ET.Element):
             attr = int(attr.text)  # type: ignore
         try:
-            attr = int(attr)
             date_obj = datetime.datetime.fromtimestamp(attr, TZ_UTC)
         except ValueError as err:
             msg = "Cannot deserialize to unix datetime object."
-            raise DeserializationError(msg) from err
+            raise_with_traceback(DeserializationError, msg, err)
         else:
             return date_obj
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/_vendor.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/_vendor.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/__init__.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/__init__.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/_configuration.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/_configuration.py`

 * *Files 11% similar despite different names*

```diff
@@ -4,62 +4,63 @@
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from typing import Any, TYPE_CHECKING
 
+from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
-class DevCenterMgmtClientConfiguration:  # pylint: disable=too-many-instance-attributes,name-too-long
+class DevCenterMgmtClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for DevCenterMgmtClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2024-02-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2023-10-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
-        api_version: str = kwargs.pop("api_version", "2024-02-01")
+        super(DevCenterMgmtClientConfiguration, self).__init__(**kwargs)
+        api_version: str = kwargs.pop("api_version", "2023-10-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
         self.subscription_id = subscription_id
         self.api_version = api_version
         self.credential_scopes = kwargs.pop("credential_scopes", ["https://management.azure.com/.default"])
         kwargs.setdefault("sdk_moniker", "mgmt-devcenter/{}".format(VERSION))
-        self.polling_interval = kwargs.get("polling_interval", 30)
         self._configure(**kwargs)
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
         self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
             self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/_dev_center_mgmt_client.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/_dev_center_mgmt_client.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,41 +5,38 @@
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from copy import deepcopy
 from typing import Any, Awaitable, TYPE_CHECKING
 
-from azure.core.pipeline import policies
 from azure.core.rest import AsyncHttpResponse, HttpRequest
 from azure.mgmt.core import AsyncARMPipelineClient
-from azure.mgmt.core.policies import AsyncARMAutoResourceProviderRegistrationPolicy
 
 from .. import models as _models
 from .._serialization import Deserializer, Serializer
 from ._configuration import DevCenterMgmtClientConfiguration
 from .operations import (
     AttachedNetworksOperations,
+    CatalogDevBoxDefinitionsOperations,
     CatalogsOperations,
     CheckNameAvailabilityOperations,
-    CheckScopedNameAvailabilityOperations,
+    CustomizationTasksOperations,
     DevBoxDefinitionsOperations,
     DevCentersOperations,
     EnvironmentDefinitionsOperations,
     EnvironmentTypesOperations,
     GalleriesOperations,
     ImageVersionsOperations,
     ImagesOperations,
     NetworkConnectionsOperations,
     OperationStatusesOperations,
     Operations,
     PoolsOperations,
     ProjectAllowedEnvironmentTypesOperations,
-    ProjectCatalogEnvironmentDefinitionsOperations,
-    ProjectCatalogsOperations,
     ProjectEnvironmentTypesOperations,
     ProjectsOperations,
     SchedulesOperations,
     SkusOperations,
     UsagesOperations,
 )
 
@@ -53,23 +50,14 @@
 
     :ivar dev_centers: DevCentersOperations operations
     :vartype dev_centers: azure.mgmt.devcenter.aio.operations.DevCentersOperations
     :ivar projects: ProjectsOperations operations
     :vartype projects: azure.mgmt.devcenter.aio.operations.ProjectsOperations
     :ivar attached_networks: AttachedNetworksOperations operations
     :vartype attached_networks: azure.mgmt.devcenter.aio.operations.AttachedNetworksOperations
-    :ivar project_catalogs: ProjectCatalogsOperations operations
-    :vartype project_catalogs: azure.mgmt.devcenter.aio.operations.ProjectCatalogsOperations
-    :ivar environment_definitions: EnvironmentDefinitionsOperations operations
-    :vartype environment_definitions:
-     azure.mgmt.devcenter.aio.operations.EnvironmentDefinitionsOperations
-    :ivar project_catalog_environment_definitions: ProjectCatalogEnvironmentDefinitionsOperations
-     operations
-    :vartype project_catalog_environment_definitions:
-     azure.mgmt.devcenter.aio.operations.ProjectCatalogEnvironmentDefinitionsOperations
     :ivar galleries: GalleriesOperations operations
     :vartype galleries: azure.mgmt.devcenter.aio.operations.GalleriesOperations
     :ivar images: ImagesOperations operations
     :vartype images: azure.mgmt.devcenter.aio.operations.ImagesOperations
     :ivar image_versions: ImageVersionsOperations operations
     :vartype image_versions: azure.mgmt.devcenter.aio.operations.ImageVersionsOperations
     :ivar catalogs: CatalogsOperations operations
@@ -89,33 +77,38 @@
     :ivar operation_statuses: OperationStatusesOperations operations
     :vartype operation_statuses: azure.mgmt.devcenter.aio.operations.OperationStatusesOperations
     :ivar usages: UsagesOperations operations
     :vartype usages: azure.mgmt.devcenter.aio.operations.UsagesOperations
     :ivar check_name_availability: CheckNameAvailabilityOperations operations
     :vartype check_name_availability:
      azure.mgmt.devcenter.aio.operations.CheckNameAvailabilityOperations
-    :ivar check_scoped_name_availability: CheckScopedNameAvailabilityOperations operations
-    :vartype check_scoped_name_availability:
-     azure.mgmt.devcenter.aio.operations.CheckScopedNameAvailabilityOperations
+    :ivar catalog_dev_box_definitions: CatalogDevBoxDefinitionsOperations operations
+    :vartype catalog_dev_box_definitions:
+     azure.mgmt.devcenter.aio.operations.CatalogDevBoxDefinitionsOperations
+    :ivar customization_tasks: CustomizationTasksOperations operations
+    :vartype customization_tasks: azure.mgmt.devcenter.aio.operations.CustomizationTasksOperations
+    :ivar environment_definitions: EnvironmentDefinitionsOperations operations
+    :vartype environment_definitions:
+     azure.mgmt.devcenter.aio.operations.EnvironmentDefinitionsOperations
     :ivar skus: SkusOperations operations
     :vartype skus: azure.mgmt.devcenter.aio.operations.SkusOperations
     :ivar pools: PoolsOperations operations
     :vartype pools: azure.mgmt.devcenter.aio.operations.PoolsOperations
     :ivar schedules: SchedulesOperations operations
     :vartype schedules: azure.mgmt.devcenter.aio.operations.SchedulesOperations
     :ivar network_connections: NetworkConnectionsOperations operations
     :vartype network_connections: azure.mgmt.devcenter.aio.operations.NetworkConnectionsOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2024-02-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2023-10-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(
         self,
@@ -123,52 +116,25 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = DevCenterMgmtClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        _policies = kwargs.pop("policies", None)
-        if _policies is None:
-            _policies = [
-                policies.RequestIdPolicy(**kwargs),
-                self._config.headers_policy,
-                self._config.user_agent_policy,
-                self._config.proxy_policy,
-                policies.ContentDecodePolicy(**kwargs),
-                AsyncARMAutoResourceProviderRegistrationPolicy(),
-                self._config.redirect_policy,
-                self._config.retry_policy,
-                self._config.authentication_policy,
-                self._config.custom_hook_policy,
-                self._config.logging_policy,
-                policies.DistributedTracingPolicy(**kwargs),
-                policies.SensitiveHeaderCleanupPolicy(**kwargs) if self._config.redirect_policy else None,
-                self._config.http_logging_policy,
-            ]
-        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, policies=_policies, **kwargs)
+        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.dev_centers = DevCentersOperations(self._client, self._config, self._serialize, self._deserialize)
         self.projects = ProjectsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.attached_networks = AttachedNetworksOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
-        self.project_catalogs = ProjectCatalogsOperations(
-            self._client, self._config, self._serialize, self._deserialize
-        )
-        self.environment_definitions = EnvironmentDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
-        )
-        self.project_catalog_environment_definitions = ProjectCatalogEnvironmentDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
-        )
         self.galleries = GalleriesOperations(self._client, self._config, self._serialize, self._deserialize)
         self.images = ImagesOperations(self._client, self._config, self._serialize, self._deserialize)
         self.image_versions = ImageVersionsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.catalogs = CatalogsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.environment_types = EnvironmentTypesOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
@@ -185,27 +151,31 @@
         self.operation_statuses = OperationStatusesOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.usages = UsagesOperations(self._client, self._config, self._serialize, self._deserialize)
         self.check_name_availability = CheckNameAvailabilityOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
-        self.check_scoped_name_availability = CheckScopedNameAvailabilityOperations(
+        self.catalog_dev_box_definitions = CatalogDevBoxDefinitionsOperations(
+            self._client, self._config, self._serialize, self._deserialize
+        )
+        self.customization_tasks = CustomizationTasksOperations(
+            self._client, self._config, self._serialize, self._deserialize
+        )
+        self.environment_definitions = EnvironmentDefinitionsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.skus = SkusOperations(self._client, self._config, self._serialize, self._deserialize)
         self.pools = PoolsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.schedules = SchedulesOperations(self._client, self._config, self._serialize, self._deserialize)
         self.network_connections = NetworkConnectionsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
 
-    def _send_request(
-        self, request: HttpRequest, *, stream: bool = False, **kwargs: Any
-    ) -> Awaitable[AsyncHttpResponse]:
+    def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
         <HttpRequest [GET], url: 'https://www.example.org/'>
         >>> response = await client._send_request(request)
         <AsyncHttpResponse: 200 OK>
@@ -217,15 +187,15 @@
         :keyword bool stream: Whether the response payload will be streamed. Defaults to False.
         :return: The response of your network call. Does not do error handling on your response.
         :rtype: ~azure.core.rest.AsyncHttpResponse
         """
 
         request_copy = deepcopy(request)
         request_copy.url = self._client.format_url(request_copy.url)
-        return self._client.send_request(request_copy, stream=stream, **kwargs)  # type: ignore
+        return self._client.send_request(request_copy, **kwargs)
 
     async def close(self) -> None:
         await self._client.close()
 
     async def __aenter__(self) -> "DevCenterMgmtClient":
         await self._client.__aenter__()
         return self
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/_patch.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/__init__.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/__init__.py`

 * *Files 9% similar despite different names*

```diff
@@ -5,59 +5,57 @@
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._dev_centers_operations import DevCentersOperations
 from ._projects_operations import ProjectsOperations
 from ._attached_networks_operations import AttachedNetworksOperations
-from ._project_catalogs_operations import ProjectCatalogsOperations
-from ._environment_definitions_operations import EnvironmentDefinitionsOperations
-from ._project_catalog_environment_definitions_operations import ProjectCatalogEnvironmentDefinitionsOperations
 from ._galleries_operations import GalleriesOperations
 from ._images_operations import ImagesOperations
 from ._image_versions_operations import ImageVersionsOperations
 from ._catalogs_operations import CatalogsOperations
 from ._environment_types_operations import EnvironmentTypesOperations
 from ._project_allowed_environment_types_operations import ProjectAllowedEnvironmentTypesOperations
 from ._project_environment_types_operations import ProjectEnvironmentTypesOperations
 from ._dev_box_definitions_operations import DevBoxDefinitionsOperations
 from ._operations import Operations
 from ._operation_statuses_operations import OperationStatusesOperations
 from ._usages_operations import UsagesOperations
 from ._check_name_availability_operations import CheckNameAvailabilityOperations
-from ._check_scoped_name_availability_operations import CheckScopedNameAvailabilityOperations
+from ._catalog_dev_box_definitions_operations import CatalogDevBoxDefinitionsOperations
+from ._customization_tasks_operations import CustomizationTasksOperations
+from ._environment_definitions_operations import EnvironmentDefinitionsOperations
 from ._skus_operations import SkusOperations
 from ._pools_operations import PoolsOperations
 from ._schedules_operations import SchedulesOperations
 from ._network_connections_operations import NetworkConnectionsOperations
 
 from ._patch import __all__ as _patch_all
 from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "DevCentersOperations",
     "ProjectsOperations",
     "AttachedNetworksOperations",
-    "ProjectCatalogsOperations",
-    "EnvironmentDefinitionsOperations",
-    "ProjectCatalogEnvironmentDefinitionsOperations",
     "GalleriesOperations",
     "ImagesOperations",
     "ImageVersionsOperations",
     "CatalogsOperations",
     "EnvironmentTypesOperations",
     "ProjectAllowedEnvironmentTypesOperations",
     "ProjectEnvironmentTypesOperations",
     "DevBoxDefinitionsOperations",
     "Operations",
     "OperationStatusesOperations",
     "UsagesOperations",
     "CheckNameAvailabilityOperations",
-    "CheckScopedNameAvailabilityOperations",
+    "CatalogDevBoxDefinitionsOperations",
+    "CustomizationTasksOperations",
+    "EnvironmentDefinitionsOperations",
     "SkusOperations",
     "PoolsOperations",
     "SchedulesOperations",
     "NetworkConnectionsOperations",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
 _patch_sdk()
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_attached_networks_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_attached_networks_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -73,14 +73,15 @@
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AttachedNetworkConnection or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.AttachedNetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
@@ -96,82 +97,87 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_project_request(
+                request = build_list_by_project_request(
                     resource_group_name=resource_group_name,
                     project_name=project_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_project.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("AttachedNetworkListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
+    list_by_project.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/attachednetworks"
+    }
+
     @distributed_trace_async
     async def get_by_project(
         self, resource_group_name: str, project_name: str, attached_network_connection_name: str, **kwargs: Any
     ) -> _models.AttachedNetworkConnection:
         """Gets an attached NetworkConnection.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param attached_network_connection_name: The name of the attached NetworkConnection. Required.
         :type attached_network_connection_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AttachedNetworkConnection or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.AttachedNetworkConnection
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -182,44 +188,48 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AttachedNetworkConnection] = kwargs.pop("cls", None)
 
-        _request = build_get_by_project_request(
+        request = build_get_by_project_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             attached_network_connection_name=attached_network_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get_by_project.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("AttachedNetworkConnection", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-        return deserialized  # type: ignore
+    get_by_project.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/attachednetworks/{attachedNetworkConnectionName}"
+    }
 
     @distributed_trace
     def list_by_dev_center(
         self, resource_group_name: str, dev_center_name: str, top: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.AttachedNetworkConnection"]:
         """Lists the attached NetworkConnections for a DevCenter.
 
@@ -227,14 +237,15 @@
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AttachedNetworkConnection or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.AttachedNetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
@@ -250,82 +261,87 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_dev_center_request(
+                request = build_list_by_dev_center_request(
                     resource_group_name=resource_group_name,
                     dev_center_name=dev_center_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_dev_center.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("AttachedNetworkListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
+    list_by_dev_center.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/attachednetworks"
+    }
+
     @distributed_trace_async
     async def get_by_dev_center(
         self, resource_group_name: str, dev_center_name: str, attached_network_connection_name: str, **kwargs: Any
     ) -> _models.AttachedNetworkConnection:
         """Gets an attached NetworkConnection.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param attached_network_connection_name: The name of the attached NetworkConnection. Required.
         :type attached_network_connection_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AttachedNetworkConnection or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.AttachedNetworkConnection
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -336,51 +352,55 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AttachedNetworkConnection] = kwargs.pop("cls", None)
 
-        _request = build_get_by_dev_center_request(
+        request = build_get_by_dev_center_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             attached_network_connection_name=attached_network_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get_by_dev_center.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("AttachedNetworkConnection", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-        return deserialized  # type: ignore
+    get_by_dev_center.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/attachednetworks/{attachedNetworkConnectionName}"
+    }
 
     async def _create_or_update_initial(
         self,
         resource_group_name: str,
         dev_center_name: str,
         attached_network_connection_name: str,
-        body: Union[_models.AttachedNetworkConnection, IO[bytes]],
+        body: Union[_models.AttachedNetworkConnection, IO],
         **kwargs: Any
     ) -> _models.AttachedNetworkConnection:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -398,51 +418,51 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "AttachedNetworkConnection")
 
-        _request = build_create_or_update_request(
+        request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             attached_network_connection_name=attached_network_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 201]:
+        if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        if response.status_code == 200:
-            deserialized = self._deserialize("AttachedNetworkConnection", pipeline_response)
-
-        if response.status_code == 201:
-            deserialized = self._deserialize("AttachedNetworkConnection", pipeline_response)
+        deserialized = self._deserialize("AttachedNetworkConnection", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    _create_or_update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/attachednetworks/{attachedNetworkConnectionName}"
+    }
 
     @overload
     async def begin_create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         attached_network_connection_name: str,
@@ -461,74 +481,101 @@
         :param attached_network_connection_name: The name of the attached NetworkConnection. Required.
         :type attached_network_connection_name: str
         :param body: Represents an attached NetworkConnection. Required.
         :type body: ~azure.mgmt.devcenter.models.AttachedNetworkConnection
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either AttachedNetworkConnection or the
          result of cls(response)
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.AttachedNetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         attached_network_connection_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.AttachedNetworkConnection]:
         """Creates or updates an attached NetworkConnection.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param attached_network_connection_name: The name of the attached NetworkConnection. Required.
         :type attached_network_connection_name: str
         :param body: Represents an attached NetworkConnection. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either AttachedNetworkConnection or the
          result of cls(response)
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.AttachedNetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         attached_network_connection_name: str,
-        body: Union[_models.AttachedNetworkConnection, IO[bytes]],
+        body: Union[_models.AttachedNetworkConnection, IO],
         **kwargs: Any
     ) -> AsyncLROPoller[_models.AttachedNetworkConnection]:
         """Creates or updates an attached NetworkConnection.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param attached_network_connection_name: The name of the attached NetworkConnection. Required.
         :type attached_network_connection_name: str
         :param body: Represents an attached NetworkConnection. Is either a AttachedNetworkConnection
-         type or a IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.AttachedNetworkConnection or IO[bytes]
+         type or a IO type. Required.
+        :type body: ~azure.mgmt.devcenter.models.AttachedNetworkConnection or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either AttachedNetworkConnection or the
          result of cls(response)
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.AttachedNetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
@@ -554,36 +601,38 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("AttachedNetworkConnection", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[_models.AttachedNetworkConnection].from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[_models.AttachedNetworkConnection](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_create_or_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/attachednetworks/{attachedNetworkConnectionName}"
+    }
 
     async def _delete_initial(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, dev_center_name: str, attached_network_connection_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -594,58 +643,66 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_delete_request(
+        request = build_delete_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             attached_network_connection_name=attached_network_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
+            return cls(pipeline_response, None, {})
+
+    _delete_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/attachednetworks/{attachedNetworkConnectionName}"
+    }
 
     @distributed_trace_async
     async def begin_delete(
         self, resource_group_name: str, dev_center_name: str, attached_network_connection_name: str, **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Un-attach a NetworkConnection.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param attached_network_connection_name: The name of the attached NetworkConnection. Required.
         :type attached_network_connection_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -665,26 +722,30 @@
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[None].from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_delete.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/attachednetworks/{attachedNetworkConnectionName}"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_catalogs_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_dev_centers_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -27,617 +27,723 @@
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._catalogs_operations import (
-    build_connect_request,
+from ...operations._dev_centers_operations import (
     build_create_or_update_request,
     build_delete_request,
     build_get_request,
-    build_get_sync_error_details_request,
-    build_list_by_dev_center_request,
-    build_sync_request,
+    build_list_by_resource_group_request,
+    build_list_by_subscription_request,
     build_update_request,
 )
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class CatalogsOperations:
+class DevCentersOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.devcenter.aio.DevCenterMgmtClient`'s
-        :attr:`catalogs` attribute.
+        :attr:`dev_centers` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def list_by_dev_center(
-        self, resource_group_name: str, dev_center_name: str, top: Optional[int] = None, **kwargs: Any
-    ) -> AsyncIterable["_models.Catalog"]:
-        """Lists catalogs for a devcenter.
+    def list_by_subscription(self, top: Optional[int] = None, **kwargs: Any) -> AsyncIterable["_models.DevCenter"]:
+        """Lists all devcenters in a subscription.
+
+        :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
+         Default value is None.
+        :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: An iterator like instance of either DevCenter or the result of cls(response)
+        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.DevCenter]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.DevCenterListResult] = kwargs.pop("cls", None)
+
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        def prepare_request(next_link=None):
+            if not next_link:
+
+                request = build_list_by_subscription_request(
+                    subscription_id=self._config.subscription_id,
+                    top=top,
+                    api_version=api_version,
+                    template_url=self.list_by_subscription.metadata["url"],
+                    headers=_headers,
+                    params=_params,
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
+
+        async def extract_data(pipeline_response):
+            deserialized = self._deserialize("DevCenterListResult", pipeline_response)
+            list_of_elem = deserialized.value
+            if cls:
+                list_of_elem = cls(list_of_elem)  # type: ignore
+            return deserialized.next_link or None, AsyncList(list_of_elem)
+
+        async def get_next(next_link=None):
+            request = prepare_request(next_link)
+
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
+            )
+            response = pipeline_response.http_response
+
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+
+            return pipeline_response
+
+        return AsyncItemPaged(get_next, extract_data)
+
+    list_by_subscription.metadata = {"url": "/subscriptions/{subscriptionId}/providers/Microsoft.DevCenter/devcenters"}
+
+    @distributed_trace
+    def list_by_resource_group(
+        self, resource_group_name: str, top: Optional[int] = None, **kwargs: Any
+    ) -> AsyncIterable["_models.DevCenter"]:
+        """Lists all devcenters in a resource group.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param dev_center_name: The name of the devcenter. Required.
-        :type dev_center_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
-        :return: An iterator like instance of either Catalog or the result of cls(response)
-        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.Catalog]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: An iterator like instance of either DevCenter or the result of cls(response)
+        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.DevCenter]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CatalogListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.DevCenterListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_dev_center_request(
+                request = build_list_by_resource_group_request(
                     resource_group_name=resource_group_name,
-                    dev_center_name=dev_center_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_resource_group.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("CatalogListResult", pipeline_response)
+            deserialized = self._deserialize("DevCenterListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
+    list_by_resource_group.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters"
+    }
+
     @distributed_trace_async
-    async def get(
-        self, resource_group_name: str, dev_center_name: str, catalog_name: str, **kwargs: Any
-    ) -> _models.Catalog:
-        """Gets a catalog.
+    async def get(self, resource_group_name: str, dev_center_name: str, **kwargs: Any) -> _models.DevCenter:
+        """Gets a devcenter.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :return: Catalog or the result of cls(response)
-        :rtype: ~azure.mgmt.devcenter.models.Catalog
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: DevCenter or the result of cls(response)
+        :rtype: ~azure.mgmt.devcenter.models.DevCenter
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.Catalog] = kwargs.pop("cls", None)
+        cls: ClsType[_models.DevCenter] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
-            catalog_name=catalog_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("Catalog", pipeline_response)
+        deserialized = self._deserialize("DevCenter", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}"
+    }
 
     async def _create_or_update_initial(
-        self,
-        resource_group_name: str,
-        dev_center_name: str,
-        catalog_name: str,
-        body: Union[_models.Catalog, IO[bytes]],
-        **kwargs: Any
-    ) -> _models.Catalog:
+        self, resource_group_name: str, dev_center_name: str, body: Union[_models.DevCenter, IO], **kwargs: Any
+    ) -> _models.DevCenter:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.Catalog] = kwargs.pop("cls", None)
+        cls: ClsType[_models.DevCenter] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "Catalog")
+            _json = self._serialize.body(body, "DevCenter")
 
-        _request = build_create_or_update_request(
+        request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
-            catalog_name=catalog_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
-            deserialized = self._deserialize("Catalog", pipeline_response)
+            deserialized = self._deserialize("DevCenter", pipeline_response)
 
         if response.status_code == 201:
-            deserialized = self._deserialize("Catalog", pipeline_response)
+            deserialized = self._deserialize("DevCenter", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
+    _create_or_update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}"
+    }
+
     @overload
     async def begin_create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
-        catalog_name: str,
-        body: _models.Catalog,
+        body: _models.DevCenter,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.Catalog]:
-        """Creates or updates a catalog.
+    ) -> AsyncLROPoller[_models.DevCenter]:
+        """Creates or updates a devcenter resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :param body: Represents a catalog. Required.
-        :type body: ~azure.mgmt.devcenter.models.Catalog
+        :param body: Represents a devcenter. Required.
+        :type body: ~azure.mgmt.devcenter.models.DevCenter
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :return: An instance of AsyncLROPoller that returns either Catalog or the result of
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either DevCenter or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Catalog]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.DevCenter]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
-        catalog_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.Catalog]:
-        """Creates or updates a catalog.
+    ) -> AsyncLROPoller[_models.DevCenter]:
+        """Creates or updates a devcenter resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :param body: Represents a catalog. Required.
-        :type body: IO[bytes]
+        :param body: Represents a devcenter. Required.
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :return: An instance of AsyncLROPoller that returns either Catalog or the result of
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either DevCenter or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Catalog]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.DevCenter]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_create_or_update(
-        self,
-        resource_group_name: str,
-        dev_center_name: str,
-        catalog_name: str,
-        body: Union[_models.Catalog, IO[bytes]],
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.Catalog]:
-        """Creates or updates a catalog.
+        self, resource_group_name: str, dev_center_name: str, body: Union[_models.DevCenter, IO], **kwargs: Any
+    ) -> AsyncLROPoller[_models.DevCenter]:
+        """Creates or updates a devcenter resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :param body: Represents a catalog. Is either a Catalog type or a IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.Catalog or IO[bytes]
-        :return: An instance of AsyncLROPoller that returns either Catalog or the result of
+        :param body: Represents a devcenter. Is either a DevCenter type or a IO type. Required.
+        :type body: ~azure.mgmt.devcenter.models.DevCenter or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either DevCenter or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Catalog]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.DevCenter]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.Catalog] = kwargs.pop("cls", None)
+        cls: ClsType[_models.DevCenter] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_or_update_initial(
                 resource_group_name=resource_group_name,
                 dev_center_name=dev_center_name,
-                catalog_name=catalog_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("Catalog", pipeline_response)
+            deserialized = self._deserialize("DevCenter", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[_models.Catalog].from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[_models.Catalog](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_create_or_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}"
+    }
 
     async def _update_initial(
-        self,
-        resource_group_name: str,
-        dev_center_name: str,
-        catalog_name: str,
-        body: Union[_models.CatalogUpdate, IO[bytes]],
-        **kwargs: Any
-    ) -> Optional[_models.Catalog]:
+        self, resource_group_name: str, dev_center_name: str, body: Union[_models.DevCenterUpdate, IO], **kwargs: Any
+    ) -> Optional[_models.DevCenter]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.Catalog]] = kwargs.pop("cls", None)
+        cls: ClsType[Optional[_models.DevCenter]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "CatalogUpdate")
+            _json = self._serialize.body(body, "DevCenterUpdate")
 
-        _request = build_update_request(
+        request = build_update_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
-            catalog_name=catalog_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = None
-        response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("Catalog", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            deserialized = self._deserialize("DevCenter", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    _update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}"
+    }
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
-        catalog_name: str,
-        body: _models.CatalogUpdate,
+        body: _models.DevCenterUpdate,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.Catalog]:
-        """Partially updates a catalog.
+    ) -> AsyncLROPoller[_models.DevCenter]:
+        """Partially updates a devcenter.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :param body: Updatable catalog properties. Required.
-        :type body: ~azure.mgmt.devcenter.models.CatalogUpdate
+        :param body: Updatable devcenter properties. Required.
+        :type body: ~azure.mgmt.devcenter.models.DevCenterUpdate
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :return: An instance of AsyncLROPoller that returns either Catalog or the result of
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either DevCenter or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Catalog]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.DevCenter]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
-        catalog_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.Catalog]:
-        """Partially updates a catalog.
+    ) -> AsyncLROPoller[_models.DevCenter]:
+        """Partially updates a devcenter.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :param body: Updatable catalog properties. Required.
-        :type body: IO[bytes]
+        :param body: Updatable devcenter properties. Required.
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :return: An instance of AsyncLROPoller that returns either Catalog or the result of
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either DevCenter or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Catalog]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.DevCenter]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_update(
-        self,
-        resource_group_name: str,
-        dev_center_name: str,
-        catalog_name: str,
-        body: Union[_models.CatalogUpdate, IO[bytes]],
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.Catalog]:
-        """Partially updates a catalog.
+        self, resource_group_name: str, dev_center_name: str, body: Union[_models.DevCenterUpdate, IO], **kwargs: Any
+    ) -> AsyncLROPoller[_models.DevCenter]:
+        """Partially updates a devcenter.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :param body: Updatable catalog properties. Is either a CatalogUpdate type or a IO[bytes] type.
+        :param body: Updatable devcenter properties. Is either a DevCenterUpdate type or a IO type.
          Required.
-        :type body: ~azure.mgmt.devcenter.models.CatalogUpdate or IO[bytes]
-        :return: An instance of AsyncLROPoller that returns either Catalog or the result of
+        :type body: ~azure.mgmt.devcenter.models.DevCenterUpdate or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either DevCenter or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Catalog]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.DevCenter]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.Catalog] = kwargs.pop("cls", None)
+        cls: ClsType[_models.DevCenter] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
                 resource_group_name=resource_group_name,
                 dev_center_name=dev_center_name,
-                catalog_name=catalog_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("Catalog", pipeline_response)
+            deserialized = self._deserialize("DevCenter", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[_models.Catalog].from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[_models.Catalog](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}"
+    }
 
     async def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, dev_center_name: str, catalog_name: str, **kwargs: Any
+        self, resource_group_name: str, dev_center_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -645,373 +751,103 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_delete_request(
-            resource_group_name=resource_group_name,
-            dev_center_name=dev_center_name,
-            catalog_name=catalog_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            headers=_headers,
-            params=_params,
-        )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [202, 204]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-        if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
-
-    @distributed_trace_async
-    async def begin_delete(
-        self, resource_group_name: str, dev_center_name: str, catalog_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[None]:
-        """Deletes a catalog resource.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param dev_center_name: The name of the devcenter. Required.
-        :type dev_center_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = await self._delete_initial(  # type: ignore
-                resource_group_name=resource_group_name,
-                dev_center_name=dev_center_name,
-                catalog_name=catalog_name,
-                api_version=api_version,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
-            if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
-
-        if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
-            )
-        elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return AsyncLROPoller[None].from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    @distributed_trace_async
-    async def get_sync_error_details(
-        self, resource_group_name: str, dev_center_name: str, catalog_name: str, **kwargs: Any
-    ) -> _models.SyncErrorDetails:
-        """Gets catalog synchronization error details.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param dev_center_name: The name of the devcenter. Required.
-        :type dev_center_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :return: SyncErrorDetails or the result of cls(response)
-        :rtype: ~azure.mgmt.devcenter.models.SyncErrorDetails
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.SyncErrorDetails] = kwargs.pop("cls", None)
-
-        _request = build_get_sync_error_details_request(
+        request = build_delete_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
-            catalog_name=catalog_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        deserialized = self._deserialize("SyncErrorDetails", pipeline_response)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, {})
 
-    async def _sync_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, dev_center_name: str, catalog_name: str, **kwargs: Any
-    ) -> None:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
-
-        _request = build_sync_request(
-            resource_group_name=resource_group_name,
-            dev_center_name=dev_center_name,
-            catalog_name=catalog_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            headers=_headers,
-            params=_params,
-        )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-        if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
+    _delete_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}"
+    }
 
     @distributed_trace_async
-    async def begin_sync(
-        self, resource_group_name: str, dev_center_name: str, catalog_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[None]:
-        """Syncs templates for a template source.
+    async def begin_delete(self, resource_group_name: str, dev_center_name: str, **kwargs: Any) -> AsyncLROPoller[None]:
+        """Deletes a devcenter.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._sync_initial(  # type: ignore
+            raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 dev_center_name=dev_center_name,
-                catalog_name=catalog_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[None].from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    async def _connect_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, dev_center_name: str, catalog_name: str, **kwargs: Any
-    ) -> None:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
-
-        _request = build_connect_request(
-            resource_group_name=resource_group_name,
-            dev_center_name=dev_center_name,
-            catalog_name=catalog_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            headers=_headers,
-            params=_params,
-        )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-        if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
-
-    @distributed_trace_async
-    async def begin_connect(
-        self, resource_group_name: str, dev_center_name: str, catalog_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[None]:
-        """Connects a catalog to enable syncing.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param dev_center_name: The name of the devcenter. Required.
-        :type dev_center_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = await self._connect_initial(  # type: ignore
-                resource_group_name=resource_group_name,
-                dev_center_name=dev_center_name,
-                catalog_name=catalog_name,
-                api_version=api_version,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
-            if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
-
-        if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
-            )
-        elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return AsyncLROPoller[None].from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+    begin_delete.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_check_name_availability_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_check_name_availability_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -63,46 +63,52 @@
 
         :param name_availability_request: The required parameters for checking if resource name is
          available. Required.
         :type name_availability_request: ~azure.mgmt.devcenter.models.CheckNameAvailabilityRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameAvailabilityResponse or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.CheckNameAvailabilityResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def execute(
-        self, name_availability_request: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
+        self, name_availability_request: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.CheckNameAvailabilityResponse:
         """Check the availability of name for resource.
 
         :param name_availability_request: The required parameters for checking if resource name is
          available. Required.
-        :type name_availability_request: IO[bytes]
+        :type name_availability_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameAvailabilityResponse or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.CheckNameAvailabilityResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def execute(
-        self, name_availability_request: Union[_models.CheckNameAvailabilityRequest, IO[bytes]], **kwargs: Any
+        self, name_availability_request: Union[_models.CheckNameAvailabilityRequest, IO], **kwargs: Any
     ) -> _models.CheckNameAvailabilityResponse:
         """Check the availability of name for resource.
 
         :param name_availability_request: The required parameters for checking if resource name is
-         available. Is either a CheckNameAvailabilityRequest type or a IO[bytes] type. Required.
+         available. Is either a CheckNameAvailabilityRequest type or a IO type. Required.
         :type name_availability_request: ~azure.mgmt.devcenter.models.CheckNameAvailabilityRequest or
-         IO[bytes]
+         IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameAvailabilityResponse or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.CheckNameAvailabilityResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -122,37 +128,40 @@
         _json = None
         _content = None
         if isinstance(name_availability_request, (IOBase, bytes)):
             _content = name_availability_request
         else:
             _json = self._serialize.body(name_availability_request, "CheckNameAvailabilityRequest")
 
-        _request = build_execute_request(
+        request = build_execute_request(
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self.execute.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CheckNameAvailabilityResponse", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-        return deserialized  # type: ignore
+    execute.metadata = {"url": "/subscriptions/{subscriptionId}/providers/Microsoft.DevCenter/checkNameAvailability"}
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_check_scoped_name_availability_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_check_name_availability_operations.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -14,96 +14,133 @@
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
+from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
-from azure.core.tracing.decorator_async import distributed_trace_async
+from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._check_scoped_name_availability_operations import build_execute_request
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import _convert_request
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
 
-class CheckScopedNameAvailabilityOperations:
+
+def build_execute_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.DevCenter/checkNameAvailability"
+    )
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+class CheckNameAvailabilityOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.devcenter.aio.DevCenterMgmtClient`'s
-        :attr:`check_scoped_name_availability` attribute.
+        :class:`~azure.mgmt.devcenter.DevCenterMgmtClient`'s
+        :attr:`check_name_availability` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @overload
-    async def execute(
+    def execute(
         self,
-        name_availability_request: _models.CheckScopedNameAvailabilityRequest,
+        name_availability_request: _models.CheckNameAvailabilityRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameAvailabilityResponse:
         """Check the availability of name for resource.
 
         :param name_availability_request: The required parameters for checking if resource name is
          available. Required.
-        :type name_availability_request:
-         ~azure.mgmt.devcenter.models.CheckScopedNameAvailabilityRequest
+        :type name_availability_request: ~azure.mgmt.devcenter.models.CheckNameAvailabilityRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameAvailabilityResponse or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.CheckNameAvailabilityResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def execute(
-        self, name_availability_request: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
+    def execute(
+        self, name_availability_request: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.CheckNameAvailabilityResponse:
         """Check the availability of name for resource.
 
         :param name_availability_request: The required parameters for checking if resource name is
          available. Required.
-        :type name_availability_request: IO[bytes]
+        :type name_availability_request: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameAvailabilityResponse or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.CheckNameAvailabilityResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def execute(
-        self, name_availability_request: Union[_models.CheckScopedNameAvailabilityRequest, IO[bytes]], **kwargs: Any
+    @distributed_trace
+    def execute(
+        self, name_availability_request: Union[_models.CheckNameAvailabilityRequest, IO], **kwargs: Any
     ) -> _models.CheckNameAvailabilityResponse:
         """Check the availability of name for resource.
 
         :param name_availability_request: The required parameters for checking if resource name is
-         available. Is either a CheckScopedNameAvailabilityRequest type or a IO[bytes] type. Required.
-        :type name_availability_request:
-         ~azure.mgmt.devcenter.models.CheckScopedNameAvailabilityRequest or IO[bytes]
+         available. Is either a CheckNameAvailabilityRequest type or a IO type. Required.
+        :type name_availability_request: ~azure.mgmt.devcenter.models.CheckNameAvailabilityRequest or
+         IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameAvailabilityResponse or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.CheckNameAvailabilityResponse
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -121,39 +158,42 @@
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(name_availability_request, (IOBase, bytes)):
             _content = name_availability_request
         else:
-            _json = self._serialize.body(name_availability_request, "CheckScopedNameAvailabilityRequest")
+            _json = self._serialize.body(name_availability_request, "CheckNameAvailabilityRequest")
 
-        _request = build_execute_request(
+        request = build_execute_request(
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self.execute.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CheckNameAvailabilityResponse", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-        return deserialized  # type: ignore
+    execute.metadata = {"url": "/subscriptions/{subscriptionId}/providers/Microsoft.DevCenter/checkNameAvailability"}
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_dev_box_definitions_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_dev_box_definitions_operations.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -74,14 +74,15 @@
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DevBoxDefinition or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.DevBoxDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -95,82 +96,87 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_dev_center_request(
+                request = build_list_by_dev_center_request(
                     resource_group_name=resource_group_name,
                     dev_center_name=dev_center_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_dev_center.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("DevBoxDefinitionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
+    list_by_dev_center.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/devboxdefinitions"
+    }
+
     @distributed_trace_async
     async def get(
         self, resource_group_name: str, dev_center_name: str, dev_box_definition_name: str, **kwargs: Any
     ) -> _models.DevBoxDefinition:
         """Gets a Dev Box definition.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param dev_box_definition_name: The name of the Dev Box definition. Required.
         :type dev_box_definition_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: DevBoxDefinition or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.DevBoxDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -181,51 +187,55 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.DevBoxDefinition] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             dev_box_definition_name=dev_box_definition_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("DevBoxDefinition", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/devboxdefinitions/{devBoxDefinitionName}"
+    }
 
     async def _create_or_update_initial(
         self,
         resource_group_name: str,
         dev_center_name: str,
         dev_box_definition_name: str,
-        body: Union[_models.DevBoxDefinition, IO[bytes]],
+        body: Union[_models.DevBoxDefinition, IO],
         **kwargs: Any
     ) -> _models.DevBoxDefinition:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -243,52 +253,56 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "DevBoxDefinition")
 
-        _request = build_create_or_update_request(
+        request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             dev_box_definition_name=dev_box_definition_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
             deserialized = self._deserialize("DevBoxDefinition", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("DevBoxDefinition", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
+    _create_or_update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/devboxdefinitions/{devBoxDefinitionName}"
+    }
+
     @overload
     async def begin_create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         dev_box_definition_name: str,
         body: _models.DevBoxDefinition,
@@ -306,72 +320,99 @@
         :param dev_box_definition_name: The name of the Dev Box definition. Required.
         :type dev_box_definition_name: str
         :param body: Represents a Dev Box definition. Required.
         :type body: ~azure.mgmt.devcenter.models.DevBoxDefinition
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either DevBoxDefinition or the result of
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.DevBoxDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         dev_box_definition_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.DevBoxDefinition]:
         """Creates or updates a Dev Box definition.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param dev_box_definition_name: The name of the Dev Box definition. Required.
         :type dev_box_definition_name: str
         :param body: Represents a Dev Box definition. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either DevBoxDefinition or the result of
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.DevBoxDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         dev_box_definition_name: str,
-        body: Union[_models.DevBoxDefinition, IO[bytes]],
+        body: Union[_models.DevBoxDefinition, IO],
         **kwargs: Any
     ) -> AsyncLROPoller[_models.DevBoxDefinition]:
         """Creates or updates a Dev Box definition.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param dev_box_definition_name: The name of the Dev Box definition. Required.
         :type dev_box_definition_name: str
-        :param body: Represents a Dev Box definition. Is either a DevBoxDefinition type or a IO[bytes]
-         type. Required.
-        :type body: ~azure.mgmt.devcenter.models.DevBoxDefinition or IO[bytes]
+        :param body: Represents a Dev Box definition. Is either a DevBoxDefinition type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.devcenter.models.DevBoxDefinition or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either DevBoxDefinition or the result of
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.DevBoxDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
@@ -396,43 +437,45 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("DevBoxDefinition", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[_models.DevBoxDefinition].from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[_models.DevBoxDefinition](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_create_or_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/devboxdefinitions/{devBoxDefinitionName}"
+    }
 
     async def _update_initial(
         self,
         resource_group_name: str,
         dev_center_name: str,
         dev_box_definition_name: str,
-        body: Union[_models.DevBoxDefinitionUpdate, IO[bytes]],
+        body: Union[_models.DevBoxDefinitionUpdate, IO],
         **kwargs: Any
     ) -> Optional[_models.DevBoxDefinition]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -450,53 +493,53 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "DevBoxDefinitionUpdate")
 
-        _request = build_update_request(
+        request = build_update_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             dev_box_definition_name=dev_box_definition_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = None
-        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("DevBoxDefinition", pipeline_response)
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    _update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/devboxdefinitions/{devBoxDefinitionName}"
+    }
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         dev_box_definition_name: str,
@@ -515,72 +558,99 @@
         :param dev_box_definition_name: The name of the Dev Box definition. Required.
         :type dev_box_definition_name: str
         :param body: Represents a Dev Box definition. Required.
         :type body: ~azure.mgmt.devcenter.models.DevBoxDefinitionUpdate
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either DevBoxDefinition or the result of
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.DevBoxDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         dev_box_definition_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.DevBoxDefinition]:
         """Partially updates a Dev Box definition.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param dev_box_definition_name: The name of the Dev Box definition. Required.
         :type dev_box_definition_name: str
         :param body: Represents a Dev Box definition. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either DevBoxDefinition or the result of
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.DevBoxDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         dev_box_definition_name: str,
-        body: Union[_models.DevBoxDefinitionUpdate, IO[bytes]],
+        body: Union[_models.DevBoxDefinitionUpdate, IO],
         **kwargs: Any
     ) -> AsyncLROPoller[_models.DevBoxDefinition]:
         """Partially updates a Dev Box definition.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param dev_box_definition_name: The name of the Dev Box definition. Required.
         :type dev_box_definition_name: str
-        :param body: Represents a Dev Box definition. Is either a DevBoxDefinitionUpdate type or a
-         IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.DevBoxDefinitionUpdate or IO[bytes]
+        :param body: Represents a Dev Box definition. Is either a DevBoxDefinitionUpdate type or a IO
+         type. Required.
+        :type body: ~azure.mgmt.devcenter.models.DevBoxDefinitionUpdate or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either DevBoxDefinition or the result of
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.DevBoxDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
@@ -605,36 +675,38 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("DevBoxDefinition", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[_models.DevBoxDefinition].from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[_models.DevBoxDefinition](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/devboxdefinitions/{devBoxDefinitionName}"
+    }
 
     async def _delete_initial(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, dev_center_name: str, dev_box_definition_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -645,58 +717,66 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_delete_request(
+        request = build_delete_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             dev_box_definition_name=dev_box_definition_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
+            return cls(pipeline_response, None, {})
+
+    _delete_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/devboxdefinitions/{devBoxDefinitionName}"
+    }
 
     @distributed_trace_async
     async def begin_delete(
         self, resource_group_name: str, dev_center_name: str, dev_box_definition_name: str, **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Deletes a Dev Box definition.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param dev_box_definition_name: The name of the Dev Box definition. Required.
         :type dev_box_definition_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -716,33 +796,37 @@
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[None].from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_delete.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/devboxdefinitions/{devBoxDefinitionName}"
+    }
 
     @distributed_trace
     def list_by_project(
         self, resource_group_name: str, project_name: str, top: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.DevBoxDefinition"]:
         """List Dev Box definitions configured for a project.
 
@@ -750,14 +834,15 @@
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DevBoxDefinition or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.DevBoxDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -771,82 +856,87 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_project_request(
+                request = build_list_by_project_request(
                     resource_group_name=resource_group_name,
                     project_name=project_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_project.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("DevBoxDefinitionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
+    list_by_project.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/devboxdefinitions"
+    }
+
     @distributed_trace_async
     async def get_by_project(
         self, resource_group_name: str, project_name: str, dev_box_definition_name: str, **kwargs: Any
     ) -> _models.DevBoxDefinition:
         """Gets a Dev Box definition configured for a project.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param dev_box_definition_name: The name of the Dev Box definition. Required.
         :type dev_box_definition_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: DevBoxDefinition or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.DevBoxDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -857,37 +947,41 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.DevBoxDefinition] = kwargs.pop("cls", None)
 
-        _request = build_get_by_project_request(
+        request = build_get_by_project_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             dev_box_definition_name=dev_box_definition_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get_by_project.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("DevBoxDefinition", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    get_by_project.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/devboxdefinitions/{devBoxDefinitionName}"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_dev_centers_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_galleries_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,682 +1,649 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 from io import IOBase
-from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
+from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
-from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
-from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
+from azure.core.pipeline.transport import HttpResponse
+from azure.core.polling import LROPoller, NoPolling, PollingMethod
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
-from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
-from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
+from azure.mgmt.core.polling.arm_polling import ARMPolling
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._dev_centers_operations import (
-    build_create_or_update_request,
-    build_delete_request,
-    build_get_request,
-    build_list_by_resource_group_request,
-    build_list_by_subscription_request,
-    build_update_request,
-)
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import _convert_request
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_list_by_dev_center_request(
+    resource_group_name: str, dev_center_name: str, subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "devCenterName": _SERIALIZER.url(
+            "dev_center_name",
+            dev_center_name,
+            "str",
+            max_length=26,
+            min_length=3,
+            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-]{2,25}$",
+        ),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+    if top is not None:
+        _params["$top"] = _SERIALIZER.query("top", top, "int")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_get_request(
+    resource_group_name: str, dev_center_name: str, gallery_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "devCenterName": _SERIALIZER.url(
+            "dev_center_name",
+            dev_center_name,
+            "str",
+            max_length=26,
+            min_length=3,
+            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-]{2,25}$",
+        ),
+        "galleryName": _SERIALIZER.url(
+            "gallery_name",
+            gallery_name,
+            "str",
+            max_length=63,
+            min_length=3,
+            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
+        ),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_create_or_update_request(
+    resource_group_name: str, dev_center_name: str, gallery_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "devCenterName": _SERIALIZER.url(
+            "dev_center_name",
+            dev_center_name,
+            "str",
+            max_length=26,
+            min_length=3,
+            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-]{2,25}$",
+        ),
+        "galleryName": _SERIALIZER.url(
+            "gallery_name",
+            gallery_name,
+            "str",
+            max_length=63,
+            min_length=3,
+            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
+        ),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_delete_request(
+    resource_group_name: str, dev_center_name: str, gallery_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "devCenterName": _SERIALIZER.url(
+            "dev_center_name",
+            dev_center_name,
+            "str",
+            max_length=26,
+            min_length=3,
+            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-]{2,25}$",
+        ),
+        "galleryName": _SERIALIZER.url(
+            "gallery_name",
+            gallery_name,
+            "str",
+            max_length=63,
+            min_length=3,
+            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
+        ),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
-class DevCentersOperations:
+    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+class GalleriesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.devcenter.aio.DevCenterMgmtClient`'s
-        :attr:`dev_centers` attribute.
+        :class:`~azure.mgmt.devcenter.DevCenterMgmtClient`'s
+        :attr:`galleries` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def list_by_subscription(self, top: Optional[int] = None, **kwargs: Any) -> AsyncIterable["_models.DevCenter"]:
-        """Lists all devcenters in a subscription.
-
-        :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
-         Default value is None.
-        :type top: int
-        :return: An iterator like instance of either DevCenter or the result of cls(response)
-        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.DevCenter]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.DevCenterListResult] = kwargs.pop("cls", None)
-
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        def prepare_request(next_link=None):
-            if not next_link:
-
-                _request = build_list_by_subscription_request(
-                    subscription_id=self._config.subscription_id,
-                    top=top,
-                    api_version=api_version,
-                    headers=_headers,
-                    params=_params,
-                )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-
-            else:
-                # make call to next link with the client's api-version
-                _parsed_next_link = urllib.parse.urlparse(next_link)
-                _next_request_params = case_insensitive_dict(
-                    {
-                        key: [urllib.parse.quote(v) for v in value]
-                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
-                    }
-                )
-                _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
-                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
-                )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
-
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("DevCenterListResult", pipeline_response)
-            list_of_elem = deserialized.value
-            if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
-
-        async def get_next(next_link=None):
-            _request = prepare_request(next_link)
-
-            _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
-            )
-            response = pipeline_response.http_response
-
-            if response.status_code not in [200]:
-                map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-            return pipeline_response
-
-        return AsyncItemPaged(get_next, extract_data)
-
-    @distributed_trace
-    def list_by_resource_group(
-        self, resource_group_name: str, top: Optional[int] = None, **kwargs: Any
-    ) -> AsyncIterable["_models.DevCenter"]:
-        """Lists all devcenters in a resource group.
+    def list_by_dev_center(
+        self, resource_group_name: str, dev_center_name: str, top: Optional[int] = None, **kwargs: Any
+    ) -> Iterable["_models.Gallery"]:
+        """Lists galleries for a devcenter.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
+        :param dev_center_name: The name of the devcenter. Required.
+        :type dev_center_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
-        :return: An iterator like instance of either DevCenter or the result of cls(response)
-        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.DevCenter]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: An iterator like instance of either Gallery or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.Gallery]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.DevCenterListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.GalleryListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_resource_group_request(
+                request = build_list_by_dev_center_request(
                     resource_group_name=resource_group_name,
+                    dev_center_name=dev_center_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_dev_center.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("DevCenterListResult", pipeline_response)
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("GalleryListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+        def get_next(next_link=None):
+            request = prepare_request(next_link)
 
             _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
+        return ItemPaged(get_next, extract_data)
+
+    list_by_dev_center.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries"
+    }
 
-    @distributed_trace_async
-    async def get(self, resource_group_name: str, dev_center_name: str, **kwargs: Any) -> _models.DevCenter:
-        """Gets a devcenter.
+    @distributed_trace
+    def get(self, resource_group_name: str, dev_center_name: str, gallery_name: str, **kwargs: Any) -> _models.Gallery:
+        """Gets a gallery.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
-        :return: DevCenter or the result of cls(response)
-        :rtype: ~azure.mgmt.devcenter.models.DevCenter
+        :param gallery_name: The name of the gallery. Required.
+        :type gallery_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: Gallery or the result of cls(response)
+        :rtype: ~azure.mgmt.devcenter.models.Gallery
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.DevCenter] = kwargs.pop("cls", None)
+        cls: ClsType[_models.Gallery] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
+            gallery_name=gallery_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("DevCenter", pipeline_response)
+        deserialized = self._deserialize("Gallery", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
 
-    async def _create_or_update_initial(
-        self, resource_group_name: str, dev_center_name: str, body: Union[_models.DevCenter, IO[bytes]], **kwargs: Any
-    ) -> _models.DevCenter:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}"
+    }
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.DevCenter] = kwargs.pop("cls", None)
-
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(body, (IOBase, bytes)):
-            _content = body
-        else:
-            _json = self._serialize.body(body, "DevCenter")
-
-        _request = build_create_or_update_request(
-            resource_group_name=resource_group_name,
-            dev_center_name=dev_center_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            headers=_headers,
-            params=_params,
-        )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200, 201]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        if response.status_code == 200:
-            deserialized = self._deserialize("DevCenter", pipeline_response)
-
-        if response.status_code == 201:
-            deserialized = self._deserialize("DevCenter", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
-
-        return deserialized  # type: ignore
-
-    @overload
-    async def begin_create_or_update(
-        self,
-        resource_group_name: str,
-        dev_center_name: str,
-        body: _models.DevCenter,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.DevCenter]:
-        """Creates or updates a devcenter resource.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param dev_center_name: The name of the devcenter. Required.
-        :type dev_center_name: str
-        :param body: Represents a devcenter. Required.
-        :type body: ~azure.mgmt.devcenter.models.DevCenter
-        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :return: An instance of AsyncLROPoller that returns either DevCenter or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.DevCenter]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @overload
-    async def begin_create_or_update(
-        self,
-        resource_group_name: str,
-        dev_center_name: str,
-        body: IO[bytes],
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.DevCenter]:
-        """Creates or updates a devcenter resource.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param dev_center_name: The name of the devcenter. Required.
-        :type dev_center_name: str
-        :param body: Represents a devcenter. Required.
-        :type body: IO[bytes]
-        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :return: An instance of AsyncLROPoller that returns either DevCenter or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.DevCenter]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @distributed_trace_async
-    async def begin_create_or_update(
-        self, resource_group_name: str, dev_center_name: str, body: Union[_models.DevCenter, IO[bytes]], **kwargs: Any
-    ) -> AsyncLROPoller[_models.DevCenter]:
-        """Creates or updates a devcenter resource.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param dev_center_name: The name of the devcenter. Required.
-        :type dev_center_name: str
-        :param body: Represents a devcenter. Is either a DevCenter type or a IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.DevCenter or IO[bytes]
-        :return: An instance of AsyncLROPoller that returns either DevCenter or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.DevCenter]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.DevCenter] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = await self._create_or_update_initial(
-                resource_group_name=resource_group_name,
-                dev_center_name=dev_center_name,
-                body=body,
-                api_version=api_version,
-                content_type=content_type,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("DevCenter", pipeline_response)
-            if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
-            return deserialized
-
-        if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
-            )
-        elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return AsyncLROPoller[_models.DevCenter].from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return AsyncLROPoller[_models.DevCenter](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
-
-    async def _update_initial(
+    def _create_or_update_initial(
         self,
         resource_group_name: str,
         dev_center_name: str,
-        body: Union[_models.DevCenterUpdate, IO[bytes]],
+        gallery_name: str,
+        body: Union[_models.Gallery, IO],
         **kwargs: Any
-    ) -> Optional[_models.DevCenter]:
+    ) -> _models.Gallery:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.DevCenter]] = kwargs.pop("cls", None)
+        cls: ClsType[_models.Gallery] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "DevCenterUpdate")
+            _json = self._serialize.body(body, "Gallery")
 
-        _request = build_update_request(
+        request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
+            gallery_name=gallery_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        deserialized = None
-        response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("DevCenter", pipeline_response)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+        deserialized = self._deserialize("Gallery", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-        return deserialized  # type: ignore
+    _create_or_update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}"
+    }
 
     @overload
-    async def begin_update(
+    def begin_create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
-        body: _models.DevCenterUpdate,
+        gallery_name: str,
+        body: _models.Gallery,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.DevCenter]:
-        """Partially updates a devcenter.
+    ) -> LROPoller[_models.Gallery]:
+        """Creates or updates a gallery.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
-        :param body: Updatable devcenter properties. Required.
-        :type body: ~azure.mgmt.devcenter.models.DevCenterUpdate
+        :param gallery_name: The name of the gallery. Required.
+        :type gallery_name: str
+        :param body: Represents a gallery. Required.
+        :type body: ~azure.mgmt.devcenter.models.Gallery
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :return: An instance of AsyncLROPoller that returns either DevCenter or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.DevCenter]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either Gallery or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Gallery]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_update(
+    def begin_create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
-        body: IO[bytes],
+        gallery_name: str,
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.DevCenter]:
-        """Partially updates a devcenter.
+    ) -> LROPoller[_models.Gallery]:
+        """Creates or updates a gallery.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
-        :param body: Updatable devcenter properties. Required.
-        :type body: IO[bytes]
+        :param gallery_name: The name of the gallery. Required.
+        :type gallery_name: str
+        :param body: Represents a gallery. Required.
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :return: An instance of AsyncLROPoller that returns either DevCenter or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.DevCenter]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either Gallery or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Gallery]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_update(
+    @distributed_trace
+    def begin_create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
-        body: Union[_models.DevCenterUpdate, IO[bytes]],
+        gallery_name: str,
+        body: Union[_models.Gallery, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.DevCenter]:
-        """Partially updates a devcenter.
+    ) -> LROPoller[_models.Gallery]:
+        """Creates or updates a gallery.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
-        :param body: Updatable devcenter properties. Is either a DevCenterUpdate type or a IO[bytes]
-         type. Required.
-        :type body: ~azure.mgmt.devcenter.models.DevCenterUpdate or IO[bytes]
-        :return: An instance of AsyncLROPoller that returns either DevCenter or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.DevCenter]
+        :param gallery_name: The name of the gallery. Required.
+        :type gallery_name: str
+        :param body: Represents a gallery. Is either a Gallery type or a IO type. Required.
+        :type body: ~azure.mgmt.devcenter.models.Gallery or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either Gallery or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Gallery]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.DevCenter] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        cls: ClsType[_models.Gallery] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._update_initial(
+            raw_result = self._create_or_update_initial(
                 resource_group_name=resource_group_name,
                 dev_center_name=dev_center_name,
+                gallery_name=gallery_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("DevCenter", pipeline_response)
+            deserialized = self._deserialize("Gallery", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[_models.DevCenter].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[_models.DevCenter](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_create_or_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}"
+    }
 
-    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, dev_center_name: str, **kwargs: Any
+    def _delete_initial(  # pylint: disable=inconsistent-return-statements
+        self, resource_group_name: str, dev_center_name: str, gallery_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -684,91 +651,108 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_delete_request(
+        request = build_delete_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
+            gallery_name=gallery_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
+            return cls(pipeline_response, None, {})
 
-    @distributed_trace_async
-    async def begin_delete(self, resource_group_name: str, dev_center_name: str, **kwargs: Any) -> AsyncLROPoller[None]:
-        """Deletes a devcenter.
+    _delete_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}"
+    }
+
+    @distributed_trace
+    def begin_delete(
+        self, resource_group_name: str, dev_center_name: str, gallery_name: str, **kwargs: Any
+    ) -> LROPoller[None]:
+        """Deletes a gallery resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :param gallery_name: The name of the gallery. Required.
+        :type gallery_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._delete_initial(  # type: ignore
+            raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 dev_center_name=dev_center_name,
+                gallery_name=gallery_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
+                return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[None].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_delete.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_environment_definitions_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_customization_tasks_operations.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,419 +1,421 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
-from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
+from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
-from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._environment_definitions_operations import (
-    build_get_by_project_catalog_request,
-    build_get_error_details_request,
-    build_get_request,
-    build_list_by_catalog_request,
-    build_list_by_project_catalog_request,
-)
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import _convert_request
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_list_by_catalog_request(
+    resource_group_name: str,
+    dev_center_name: str,
+    catalog_name: str,
+    subscription_id: str,
+    *,
+    top: Optional[int] = None,
+    **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/tasks",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "devCenterName": _SERIALIZER.url(
+            "dev_center_name",
+            dev_center_name,
+            "str",
+            max_length=26,
+            min_length=3,
+            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-]{2,25}$",
+        ),
+        "catalogName": _SERIALIZER.url(
+            "catalog_name",
+            catalog_name,
+            "str",
+            max_length=63,
+            min_length=3,
+            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
+        ),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+    if top is not None:
+        _params["$top"] = _SERIALIZER.query("top", top, "int")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_get_request(
+    resource_group_name: str,
+    dev_center_name: str,
+    catalog_name: str,
+    task_name: str,
+    subscription_id: str,
+    **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/tasks/{taskName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "devCenterName": _SERIALIZER.url(
+            "dev_center_name",
+            dev_center_name,
+            "str",
+            max_length=26,
+            min_length=3,
+            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-]{2,25}$",
+        ),
+        "catalogName": _SERIALIZER.url(
+            "catalog_name",
+            catalog_name,
+            "str",
+            max_length=63,
+            min_length=3,
+            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
+        ),
+        "taskName": _SERIALIZER.url(
+            "task_name", task_name, "str", max_length=63, min_length=3, pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$"
+        ),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_get_error_details_request(
+    resource_group_name: str,
+    dev_center_name: str,
+    catalog_name: str,
+    task_name: str,
+    subscription_id: str,
+    **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/tasks/{taskName}/getErrorDetails",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "devCenterName": _SERIALIZER.url(
+            "dev_center_name",
+            dev_center_name,
+            "str",
+            max_length=26,
+            min_length=3,
+            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-]{2,25}$",
+        ),
+        "catalogName": _SERIALIZER.url(
+            "catalog_name",
+            catalog_name,
+            "str",
+            max_length=63,
+            min_length=3,
+            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
+        ),
+        "taskName": _SERIALIZER.url(
+            "task_name", task_name, "str", max_length=63, min_length=3, pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$"
+        ),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
-class EnvironmentDefinitionsOperations:
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+class CustomizationTasksOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.devcenter.aio.DevCenterMgmtClient`'s
-        :attr:`environment_definitions` attribute.
+        :class:`~azure.mgmt.devcenter.DevCenterMgmtClient`'s
+        :attr:`customization_tasks` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def list_by_project_catalog(
-        self, resource_group_name: str, project_name: str, catalog_name: str, **kwargs: Any
-    ) -> AsyncIterable["_models.EnvironmentDefinition"]:
-        """Lists the environment definitions in this project catalog.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param project_name: The name of the project. Required.
-        :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :return: An iterator like instance of either EnvironmentDefinition or the result of
-         cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.EnvironmentDefinition]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.EnvironmentDefinitionListResult] = kwargs.pop("cls", None)
-
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        def prepare_request(next_link=None):
-            if not next_link:
-
-                _request = build_list_by_project_catalog_request(
-                    resource_group_name=resource_group_name,
-                    project_name=project_name,
-                    catalog_name=catalog_name,
-                    subscription_id=self._config.subscription_id,
-                    api_version=api_version,
-                    headers=_headers,
-                    params=_params,
-                )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-
-            else:
-                # make call to next link with the client's api-version
-                _parsed_next_link = urllib.parse.urlparse(next_link)
-                _next_request_params = case_insensitive_dict(
-                    {
-                        key: [urllib.parse.quote(v) for v in value]
-                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
-                    }
-                )
-                _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
-                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
-                )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
-
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("EnvironmentDefinitionListResult", pipeline_response)
-            list_of_elem = deserialized.value
-            if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
-
-        async def get_next(next_link=None):
-            _request = prepare_request(next_link)
-
-            _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
-            )
-            response = pipeline_response.http_response
-
-            if response.status_code not in [200]:
-                map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-            return pipeline_response
-
-        return AsyncItemPaged(get_next, extract_data)
-
-    @distributed_trace_async
-    async def get_by_project_catalog(
-        self,
-        resource_group_name: str,
-        project_name: str,
-        catalog_name: str,
-        environment_definition_name: str,
-        **kwargs: Any
-    ) -> _models.EnvironmentDefinition:
-        """Gets an environment definition from the catalog.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param project_name: The name of the project. Required.
-        :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :param environment_definition_name: The name of the Environment Definition. Required.
-        :type environment_definition_name: str
-        :return: EnvironmentDefinition or the result of cls(response)
-        :rtype: ~azure.mgmt.devcenter.models.EnvironmentDefinition
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.EnvironmentDefinition] = kwargs.pop("cls", None)
-
-        _request = build_get_by_project_catalog_request(
-            resource_group_name=resource_group_name,
-            project_name=project_name,
-            catalog_name=catalog_name,
-            environment_definition_name=environment_definition_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            headers=_headers,
-            params=_params,
-        )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        deserialized = self._deserialize("EnvironmentDefinition", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
-
-        return deserialized  # type: ignore
-
-    @distributed_trace
     def list_by_catalog(
         self,
         resource_group_name: str,
         dev_center_name: str,
         catalog_name: str,
         top: Optional[int] = None,
         **kwargs: Any
-    ) -> AsyncIterable["_models.EnvironmentDefinition"]:
-        """List environment definitions in the catalog.
+    ) -> Iterable["_models.CustomizationTask"]:
+        """List Tasks in the catalog.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param catalog_name: The name of the Catalog. Required.
         :type catalog_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
-        :return: An iterator like instance of either EnvironmentDefinition or the result of
-         cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.EnvironmentDefinition]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: An iterator like instance of either CustomizationTask or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.CustomizationTask]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.EnvironmentDefinitionListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.CustomizationTaskListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_catalog_request(
+                request = build_list_by_catalog_request(
                     resource_group_name=resource_group_name,
                     dev_center_name=dev_center_name,
                     catalog_name=catalog_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_catalog.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("EnvironmentDefinitionListResult", pipeline_response)
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("CustomizationTaskListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+        def get_next(next_link=None):
+            request = prepare_request(next_link)
 
             _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
+        return ItemPaged(get_next, extract_data)
 
-    @distributed_trace_async
-    async def get(
-        self,
-        resource_group_name: str,
-        dev_center_name: str,
-        catalog_name: str,
-        environment_definition_name: str,
-        **kwargs: Any
-    ) -> _models.EnvironmentDefinition:
-        """Gets an environment definition from the catalog.
+    list_by_catalog.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/tasks"
+    }
+
+    @distributed_trace
+    def get(
+        self, resource_group_name: str, dev_center_name: str, catalog_name: str, task_name: str, **kwargs: Any
+    ) -> _models.CustomizationTask:
+        """Gets a Task from the catalog.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param catalog_name: The name of the Catalog. Required.
         :type catalog_name: str
-        :param environment_definition_name: The name of the Environment Definition. Required.
-        :type environment_definition_name: str
-        :return: EnvironmentDefinition or the result of cls(response)
-        :rtype: ~azure.mgmt.devcenter.models.EnvironmentDefinition
+        :param task_name: The name of the Task. Required.
+        :type task_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: CustomizationTask or the result of cls(response)
+        :rtype: ~azure.mgmt.devcenter.models.CustomizationTask
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.EnvironmentDefinition] = kwargs.pop("cls", None)
+        cls: ClsType[_models.CustomizationTask] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             catalog_name=catalog_name,
-            environment_definition_name=environment_definition_name,
+            task_name=task_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("EnvironmentDefinition", pipeline_response)
+        deserialized = self._deserialize("CustomizationTask", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
 
-    @distributed_trace_async
-    async def get_error_details(
-        self,
-        resource_group_name: str,
-        dev_center_name: str,
-        catalog_name: str,
-        environment_definition_name: str,
-        **kwargs: Any
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/tasks/{taskName}"
+    }
+
+    @distributed_trace
+    def get_error_details(
+        self, resource_group_name: str, dev_center_name: str, catalog_name: str, task_name: str, **kwargs: Any
     ) -> _models.CatalogResourceValidationErrorDetails:
-        """Gets Environment Definition error details.
+        """Gets Customization Task error details.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param catalog_name: The name of the Catalog. Required.
         :type catalog_name: str
-        :param environment_definition_name: The name of the Environment Definition. Required.
-        :type environment_definition_name: str
+        :param task_name: The name of the Task. Required.
+        :type task_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CatalogResourceValidationErrorDetails or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.CatalogResourceValidationErrorDetails
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -424,38 +426,42 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.CatalogResourceValidationErrorDetails] = kwargs.pop("cls", None)
 
-        _request = build_get_error_details_request(
+        request = build_get_error_details_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             catalog_name=catalog_name,
-            environment_definition_name=environment_definition_name,
+            task_name=task_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get_error_details.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CatalogResourceValidationErrorDetails", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-        return deserialized  # type: ignore
+    get_error_details.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/tasks/{taskName}/getErrorDetails"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_environment_types_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_environment_types_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -70,14 +70,15 @@
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either EnvironmentType or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.EnvironmentType]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -91,82 +92,87 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_dev_center_request(
+                request = build_list_by_dev_center_request(
                     resource_group_name=resource_group_name,
                     dev_center_name=dev_center_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_dev_center.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("EnvironmentTypeListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
+    list_by_dev_center.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/environmentTypes"
+    }
+
     @distributed_trace_async
     async def get(
         self, resource_group_name: str, dev_center_name: str, environment_type_name: str, **kwargs: Any
     ) -> _models.EnvironmentType:
         """Gets an environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: EnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.EnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -177,44 +183,48 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.EnvironmentType] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             environment_type_name=environment_type_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("EnvironmentType", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-        return deserialized  # type: ignore
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/environmentTypes/{environmentTypeName}"
+    }
 
     @overload
     async def create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         environment_type_name: str,
@@ -233,70 +243,76 @@
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
         :param body: Represents an Environment Type. Required.
         :type body: ~azure.mgmt.devcenter.models.EnvironmentType
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: EnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.EnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         environment_type_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.EnvironmentType:
         """Creates or updates an environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
         :param body: Represents an Environment Type. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: EnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.EnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         environment_type_name: str,
-        body: Union[_models.EnvironmentType, IO[bytes]],
+        body: Union[_models.EnvironmentType, IO],
         **kwargs: Any
     ) -> _models.EnvironmentType:
         """Creates or updates an environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
-        :param body: Represents an Environment Type. Is either a EnvironmentType type or a IO[bytes]
-         type. Required.
-        :type body: ~azure.mgmt.devcenter.models.EnvironmentType or IO[bytes]
+        :param body: Represents an Environment Type. Is either a EnvironmentType type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.devcenter.models.EnvironmentType or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: EnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.EnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -316,51 +332,51 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "EnvironmentType")
 
-        _request = build_create_or_update_request(
+        request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             environment_type_name=environment_type_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 201]:
+        if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        if response.status_code == 200:
-            deserialized = self._deserialize("EnvironmentType", pipeline_response)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        if response.status_code == 201:
-            deserialized = self._deserialize("EnvironmentType", pipeline_response)
+        deserialized = self._deserialize("EnvironmentType", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-        return deserialized  # type: ignore
+    create_or_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/environmentTypes/{environmentTypeName}"
+    }
 
     @overload
     async def update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         environment_type_name: str,
@@ -379,70 +395,76 @@
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
         :param body: Updatable environment type properties. Required.
         :type body: ~azure.mgmt.devcenter.models.EnvironmentTypeUpdate
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: EnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.EnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         environment_type_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.EnvironmentType:
         """Partially updates an environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
         :param body: Updatable environment type properties. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: EnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.EnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         environment_type_name: str,
-        body: Union[_models.EnvironmentTypeUpdate, IO[bytes]],
+        body: Union[_models.EnvironmentTypeUpdate, IO],
         **kwargs: Any
     ) -> _models.EnvironmentType:
         """Partially updates an environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
         :param body: Updatable environment type properties. Is either a EnvironmentTypeUpdate type or a
-         IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.EnvironmentTypeUpdate or IO[bytes]
+         IO type. Required.
+        :type body: ~azure.mgmt.devcenter.models.EnvironmentTypeUpdate or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: EnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.EnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -462,61 +484,66 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "EnvironmentTypeUpdate")
 
-        _request = build_update_request(
+        request = build_update_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             environment_type_name=environment_type_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("EnvironmentType", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-        return deserialized  # type: ignore
+    update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/environmentTypes/{environmentTypeName}"
+    }
 
     @distributed_trace_async
     async def delete(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, dev_center_name: str, environment_type_name: str, **kwargs: Any
     ) -> None:
         """Deletes an environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -527,33 +554,37 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_delete_request(
+        request = build_delete_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             environment_type_name=environment_type_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})  # type: ignore
+            return cls(pipeline_response, None, {})
+
+    delete.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/environmentTypes/{environmentTypeName}"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_galleries_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_images_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,528 +1,476 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-from io import IOBase
-from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
+from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
-from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
-from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
+from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
-from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
-from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._galleries_operations import (
-    build_create_or_update_request,
-    build_delete_request,
-    build_get_request,
-    build_list_by_dev_center_request,
-)
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import _convert_request
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_list_by_dev_center_request(
+    resource_group_name: str, dev_center_name: str, subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/images",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "devCenterName": _SERIALIZER.url(
+            "dev_center_name",
+            dev_center_name,
+            "str",
+            max_length=26,
+            min_length=3,
+            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-]{2,25}$",
+        ),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+    if top is not None:
+        _params["$top"] = _SERIALIZER.query("top", top, "int")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_list_by_gallery_request(
+    resource_group_name: str,
+    dev_center_name: str,
+    gallery_name: str,
+    subscription_id: str,
+    *,
+    top: Optional[int] = None,
+    **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}/images",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "devCenterName": _SERIALIZER.url(
+            "dev_center_name",
+            dev_center_name,
+            "str",
+            max_length=26,
+            min_length=3,
+            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-]{2,25}$",
+        ),
+        "galleryName": _SERIALIZER.url(
+            "gallery_name",
+            gallery_name,
+            "str",
+            max_length=63,
+            min_length=3,
+            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
+        ),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+    if top is not None:
+        _params["$top"] = _SERIALIZER.query("top", top, "int")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_get_request(
+    resource_group_name: str,
+    dev_center_name: str,
+    gallery_name: str,
+    image_name: str,
+    subscription_id: str,
+    **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}/images/{imageName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "devCenterName": _SERIALIZER.url(
+            "dev_center_name",
+            dev_center_name,
+            "str",
+            max_length=26,
+            min_length=3,
+            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-]{2,25}$",
+        ),
+        "galleryName": _SERIALIZER.url(
+            "gallery_name",
+            gallery_name,
+            "str",
+            max_length=63,
+            min_length=3,
+            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
+        ),
+        "imageName": _SERIALIZER.url("image_name", image_name, "str"),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class GalleriesOperations:
+class ImagesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.devcenter.aio.DevCenterMgmtClient`'s
-        :attr:`galleries` attribute.
+        :class:`~azure.mgmt.devcenter.DevCenterMgmtClient`'s
+        :attr:`images` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def list_by_dev_center(
         self, resource_group_name: str, dev_center_name: str, top: Optional[int] = None, **kwargs: Any
-    ) -> AsyncIterable["_models.Gallery"]:
-        """Lists galleries for a devcenter.
+    ) -> Iterable["_models.Image"]:
+        """Lists images for a devcenter.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
-        :return: An iterator like instance of either Gallery or the result of cls(response)
-        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.Gallery]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: An iterator like instance of either Image or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.Image]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.GalleryListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.ImageListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_dev_center_request(
+                request = build_list_by_dev_center_request(
                     resource_group_name=resource_group_name,
                     dev_center_name=dev_center_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_dev_center.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("GalleryListResult", pipeline_response)
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("ImageListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+        def get_next(next_link=None):
+            request = prepare_request(next_link)
 
             _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
+        return ItemPaged(get_next, extract_data)
 
-    @distributed_trace_async
-    async def get(
-        self, resource_group_name: str, dev_center_name: str, gallery_name: str, **kwargs: Any
-    ) -> _models.Gallery:
-        """Gets a gallery.
+    list_by_dev_center.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/images"
+    }
+
+    @distributed_trace
+    def list_by_gallery(
+        self,
+        resource_group_name: str,
+        dev_center_name: str,
+        gallery_name: str,
+        top: Optional[int] = None,
+        **kwargs: Any
+    ) -> Iterable["_models.Image"]:
+        """Lists images for a gallery.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param gallery_name: The name of the gallery. Required.
         :type gallery_name: str
-        :return: Gallery or the result of cls(response)
-        :rtype: ~azure.mgmt.devcenter.models.Gallery
+        :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
+         Default value is None.
+        :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: An iterator like instance of either Image or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.Image]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.Gallery] = kwargs.pop("cls", None)
-
-        _request = build_get_request(
-            resource_group_name=resource_group_name,
-            dev_center_name=dev_center_name,
-            gallery_name=gallery_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            headers=_headers,
-            params=_params,
-        )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        deserialized = self._deserialize("Gallery", pipeline_response)
+        cls: ClsType[_models.ImageListResult] = kwargs.pop("cls", None)
 
-        if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
-
-        return deserialized  # type: ignore
-
-    async def _create_or_update_initial(
-        self,
-        resource_group_name: str,
-        dev_center_name: str,
-        gallery_name: str,
-        body: Union[_models.Gallery, IO[bytes]],
-        **kwargs: Any
-    ) -> _models.Gallery:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.Gallery] = kwargs.pop("cls", None)
-
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(body, (IOBase, bytes)):
-            _content = body
-        else:
-            _json = self._serialize.body(body, "Gallery")
-
-        _request = build_create_or_update_request(
-            resource_group_name=resource_group_name,
-            dev_center_name=dev_center_name,
-            gallery_name=gallery_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            headers=_headers,
-            params=_params,
-        )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
+        def prepare_request(next_link=None):
+            if not next_link:
 
-        if response.status_code not in [200, 201]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                request = build_list_by_gallery_request(
+                    resource_group_name=resource_group_name,
+                    dev_center_name=dev_center_name,
+                    gallery_name=gallery_name,
+                    subscription_id=self._config.subscription_id,
+                    top=top,
+                    api_version=api_version,
+                    template_url=self.list_by_gallery.metadata["url"],
+                    headers=_headers,
+                    params=_params,
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
-        if response.status_code == 200:
-            deserialized = self._deserialize("Gallery", pipeline_response)
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
-        if response.status_code == 201:
-            deserialized = self._deserialize("Gallery", pipeline_response)
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("ImageListResult", pipeline_response)
+            list_of_elem = deserialized.value
+            if cls:
+                list_of_elem = cls(list_of_elem)  # type: ignore
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+        def get_next(next_link=None):
+            request = prepare_request(next_link)
 
-        return deserialized  # type: ignore
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
+            )
+            response = pipeline_response.http_response
 
-    @overload
-    async def begin_create_or_update(
-        self,
-        resource_group_name: str,
-        dev_center_name: str,
-        gallery_name: str,
-        body: _models.Gallery,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.Gallery]:
-        """Creates or updates a gallery.
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param dev_center_name: The name of the devcenter. Required.
-        :type dev_center_name: str
-        :param gallery_name: The name of the gallery. Required.
-        :type gallery_name: str
-        :param body: Represents a gallery. Required.
-        :type body: ~azure.mgmt.devcenter.models.Gallery
-        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :return: An instance of AsyncLROPoller that returns either Gallery or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Gallery]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
+            return pipeline_response
 
-    @overload
-    async def begin_create_or_update(
-        self,
-        resource_group_name: str,
-        dev_center_name: str,
-        gallery_name: str,
-        body: IO[bytes],
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.Gallery]:
-        """Creates or updates a gallery.
+        return ItemPaged(get_next, extract_data)
 
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param dev_center_name: The name of the devcenter. Required.
-        :type dev_center_name: str
-        :param gallery_name: The name of the gallery. Required.
-        :type gallery_name: str
-        :param body: Represents a gallery. Required.
-        :type body: IO[bytes]
-        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :return: An instance of AsyncLROPoller that returns either Gallery or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Gallery]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
+    list_by_gallery.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}/images"
+    }
 
-    @distributed_trace_async
-    async def begin_create_or_update(
-        self,
-        resource_group_name: str,
-        dev_center_name: str,
-        gallery_name: str,
-        body: Union[_models.Gallery, IO[bytes]],
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.Gallery]:
-        """Creates or updates a gallery.
+    @distributed_trace
+    def get(
+        self, resource_group_name: str, dev_center_name: str, gallery_name: str, image_name: str, **kwargs: Any
+    ) -> _models.Image:
+        """Gets a gallery image.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param gallery_name: The name of the gallery. Required.
         :type gallery_name: str
-        :param body: Represents a gallery. Is either a Gallery type or a IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.Gallery or IO[bytes]
-        :return: An instance of AsyncLROPoller that returns either Gallery or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Gallery]
+        :param image_name: The name of the image. Required.
+        :type image_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: Image or the result of cls(response)
+        :rtype: ~azure.mgmt.devcenter.models.Image
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.Gallery] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = await self._create_or_update_initial(
-                resource_group_name=resource_group_name,
-                dev_center_name=dev_center_name,
-                gallery_name=gallery_name,
-                body=body,
-                api_version=api_version,
-                content_type=content_type,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("Gallery", pipeline_response)
-            if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
-            return deserialized
-
-        if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
-            )
-        elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return AsyncLROPoller[_models.Gallery].from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return AsyncLROPoller[_models.Gallery](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
-
-    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, dev_center_name: str, gallery_name: str, **kwargs: Any
-    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
+        cls: ClsType[_models.Image] = kwargs.pop("cls", None)
 
-        _request = build_delete_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             gallery_name=gallery_name,
+            image_name=image_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+        deserialized = self._deserialize("Image", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
-
-    @distributed_trace_async
-    async def begin_delete(
-        self, resource_group_name: str, dev_center_name: str, gallery_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[None]:
-        """Deletes a gallery resource.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param dev_center_name: The name of the devcenter. Required.
-        :type dev_center_name: str
-        :param gallery_name: The name of the gallery. Required.
-        :type gallery_name: str
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = await self._delete_initial(  # type: ignore
-                resource_group_name=resource_group_name,
-                dev_center_name=dev_center_name,
-                gallery_name=gallery_name,
-                api_version=api_version,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
+            return cls(pipeline_response, deserialized, {})
 
-        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
-            if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
+        return deserialized
 
-        if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
-            )
-        elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return AsyncLROPoller[None].from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}/images/{imageName}"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_image_versions_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_image_versions_operations.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -64,14 +64,15 @@
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param gallery_name: The name of the gallery. Required.
         :type gallery_name: str
         :param image_name: The name of the image. Required.
         :type image_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either ImageVersion or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.ImageVersion]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -85,70 +86,74 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_image_request(
+                request = build_list_by_image_request(
                     resource_group_name=resource_group_name,
                     dev_center_name=dev_center_name,
                     gallery_name=gallery_name,
                     image_name=image_name,
                     subscription_id=self._config.subscription_id,
                     api_version=api_version,
+                    template_url=self.list_by_image.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("ImageVersionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
+    list_by_image.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}/images/{imageName}/versions"
+    }
+
     @distributed_trace_async
     async def get(
         self,
         resource_group_name: str,
         dev_center_name: str,
         gallery_name: str,
         image_name: str,
@@ -164,14 +169,15 @@
         :type dev_center_name: str
         :param gallery_name: The name of the gallery. Required.
         :type gallery_name: str
         :param image_name: The name of the image. Required.
         :type image_name: str
         :param version_name: The version of the image. Required.
         :type version_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ImageVersion or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.ImageVersion
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -182,39 +188,43 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ImageVersion] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             gallery_name=gallery_name,
             image_name=image_name,
             version_name=version_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ImageVersion", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-        return deserialized  # type: ignore
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}/images/{imageName}/versions/{versionName}"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_images_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_images_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -67,14 +67,15 @@
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Image or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.Image]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -88,69 +89,73 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_dev_center_request(
+                request = build_list_by_dev_center_request(
                     resource_group_name=resource_group_name,
                     dev_center_name=dev_center_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_dev_center.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("ImageListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
+    list_by_dev_center.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/images"
+    }
+
     @distributed_trace
     def list_by_gallery(
         self,
         resource_group_name: str,
         dev_center_name: str,
         gallery_name: str,
         top: Optional[int] = None,
@@ -164,14 +169,15 @@
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param gallery_name: The name of the gallery. Required.
         :type gallery_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Image or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.Image]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -185,70 +191,74 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_gallery_request(
+                request = build_list_by_gallery_request(
                     resource_group_name=resource_group_name,
                     dev_center_name=dev_center_name,
                     gallery_name=gallery_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_gallery.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("ImageListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
+    list_by_gallery.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}/images"
+    }
+
     @distributed_trace_async
     async def get(
         self, resource_group_name: str, dev_center_name: str, gallery_name: str, image_name: str, **kwargs: Any
     ) -> _models.Image:
         """Gets a gallery image.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
@@ -256,14 +266,15 @@
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param gallery_name: The name of the gallery. Required.
         :type gallery_name: str
         :param image_name: The name of the image. Required.
         :type image_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Image or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.Image
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -274,38 +285,42 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.Image] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             gallery_name=gallery_name,
             image_name=image_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("Image", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-        return deserialized  # type: ignore
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}/images/{imageName}"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_network_connections_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_network_connections_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -72,14 +72,15 @@
         self, top: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.NetworkConnection"]:
         """Lists network connections in a subscription.
 
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either NetworkConnection or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.NetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -93,79 +94,84 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_subscription_request(
+                request = build_list_by_subscription_request(
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_subscription.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("NetworkConnectionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
+    list_by_subscription.metadata = {
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.DevCenter/networkConnections"
+    }
+
     @distributed_trace
     def list_by_resource_group(
         self, resource_group_name: str, top: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.NetworkConnection"]:
         """Lists network connections in a resource group.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either NetworkConnection or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.NetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -179,80 +185,85 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_resource_group_request(
+                request = build_list_by_resource_group_request(
                     resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_resource_group.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("NetworkConnectionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
+    list_by_resource_group.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections"
+    }
+
     @distributed_trace_async
     async def get(
         self, resource_group_name: str, network_connection_name: str, **kwargs: Any
     ) -> _models.NetworkConnection:
         """Gets a network connection resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param network_connection_name: Name of the Network Connection that can be applied to a Pool.
          Required.
         :type network_connection_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: NetworkConnection or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.NetworkConnection
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -263,49 +274,53 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.NetworkConnection] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             network_connection_name=network_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("NetworkConnection", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}"
+    }
 
     async def _create_or_update_initial(
         self,
         resource_group_name: str,
         network_connection_name: str,
-        body: Union[_models.NetworkConnection, IO[bytes]],
+        body: Union[_models.NetworkConnection, IO],
         **kwargs: Any
     ) -> _models.NetworkConnection:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -323,51 +338,55 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "NetworkConnection")
 
-        _request = build_create_or_update_request(
+        request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             network_connection_name=network_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
             deserialized = self._deserialize("NetworkConnection", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("NetworkConnection", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
+    _create_or_update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}"
+    }
+
     @overload
     async def begin_create_or_update(
         self,
         resource_group_name: str,
         network_connection_name: str,
         body: _models.NetworkConnection,
         *,
@@ -383,68 +402,95 @@
          Required.
         :type network_connection_name: str
         :param body: Represents network connection. Required.
         :type body: ~azure.mgmt.devcenter.models.NetworkConnection
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either NetworkConnection or the result of
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.NetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_create_or_update(
         self,
         resource_group_name: str,
         network_connection_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.NetworkConnection]:
         """Creates or updates a Network Connections resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param network_connection_name: Name of the Network Connection that can be applied to a Pool.
          Required.
         :type network_connection_name: str
         :param body: Represents network connection. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either NetworkConnection or the result of
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.NetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_create_or_update(
         self,
         resource_group_name: str,
         network_connection_name: str,
-        body: Union[_models.NetworkConnection, IO[bytes]],
+        body: Union[_models.NetworkConnection, IO],
         **kwargs: Any
     ) -> AsyncLROPoller[_models.NetworkConnection]:
         """Creates or updates a Network Connections resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param network_connection_name: Name of the Network Connection that can be applied to a Pool.
          Required.
         :type network_connection_name: str
-        :param body: Represents network connection. Is either a NetworkConnection type or a IO[bytes]
-         type. Required.
-        :type body: ~azure.mgmt.devcenter.models.NetworkConnection or IO[bytes]
+        :param body: Represents network connection. Is either a NetworkConnection type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.devcenter.models.NetworkConnection or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either NetworkConnection or the result of
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.NetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
@@ -468,42 +514,44 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("NetworkConnection", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[_models.NetworkConnection].from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[_models.NetworkConnection](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_create_or_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}"
+    }
 
     async def _update_initial(
         self,
         resource_group_name: str,
         network_connection_name: str,
-        body: Union[_models.NetworkConnectionUpdate, IO[bytes]],
+        body: Union[_models.NetworkConnectionUpdate, IO],
         **kwargs: Any
     ) -> Optional[_models.NetworkConnection]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -521,52 +569,52 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "NetworkConnectionUpdate")
 
-        _request = build_update_request(
+        request = build_update_request(
             resource_group_name=resource_group_name,
             network_connection_name=network_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = None
-        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("NetworkConnection", pipeline_response)
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    _update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}"
+    }
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
         network_connection_name: str,
         body: _models.NetworkConnectionUpdate,
@@ -583,68 +631,95 @@
          Required.
         :type network_connection_name: str
         :param body: Represents network connection. Required.
         :type body: ~azure.mgmt.devcenter.models.NetworkConnectionUpdate
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either NetworkConnection or the result of
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.NetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
         network_connection_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.NetworkConnection]:
         """Partially updates a Network Connection.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param network_connection_name: Name of the Network Connection that can be applied to a Pool.
          Required.
         :type network_connection_name: str
         :param body: Represents network connection. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either NetworkConnection or the result of
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.NetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_update(
         self,
         resource_group_name: str,
         network_connection_name: str,
-        body: Union[_models.NetworkConnectionUpdate, IO[bytes]],
+        body: Union[_models.NetworkConnectionUpdate, IO],
         **kwargs: Any
     ) -> AsyncLROPoller[_models.NetworkConnection]:
         """Partially updates a Network Connection.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param network_connection_name: Name of the Network Connection that can be applied to a Pool.
          Required.
         :type network_connection_name: str
-        :param body: Represents network connection. Is either a NetworkConnectionUpdate type or a
-         IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.NetworkConnectionUpdate or IO[bytes]
+        :param body: Represents network connection. Is either a NetworkConnectionUpdate type or a IO
+         type. Required.
+        :type body: ~azure.mgmt.devcenter.models.NetworkConnectionUpdate or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either NetworkConnection or the result of
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.NetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
@@ -668,36 +743,38 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("NetworkConnection", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[_models.NetworkConnection].from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[_models.NetworkConnection](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}"
+    }
 
     async def _delete_initial(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, network_connection_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -708,56 +785,64 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_delete_request(
+        request = build_delete_request(
             resource_group_name=resource_group_name,
             network_connection_name=network_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
+            return cls(pipeline_response, None, {})
+
+    _delete_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}"
+    }
 
     @distributed_trace_async
     async def begin_delete(
         self, resource_group_name: str, network_connection_name: str, **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Deletes a Network Connections resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param network_connection_name: Name of the Network Connection that can be applied to a Pool.
          Required.
         :type network_connection_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -776,33 +861,37 @@
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[None].from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_delete.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}"
+    }
 
     @distributed_trace
     def list_health_details(
         self, resource_group_name: str, network_connection_name: str, top: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.HealthCheckStatusDetails"]:
         """Lists health check status details.
 
@@ -811,14 +900,15 @@
         :type resource_group_name: str
         :param network_connection_name: Name of the Network Connection that can be applied to a Pool.
          Required.
         :type network_connection_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either HealthCheckStatusDetails or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.HealthCheckStatusDetails]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
@@ -834,81 +924,86 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_health_details_request(
+                request = build_list_health_details_request(
                     resource_group_name=resource_group_name,
                     network_connection_name=network_connection_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_health_details.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("HealthCheckStatusDetailsListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
+    list_health_details.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}/healthChecks"
+    }
+
     @distributed_trace_async
     async def get_health_details(
         self, resource_group_name: str, network_connection_name: str, **kwargs: Any
     ) -> _models.HealthCheckStatusDetails:
         """Gets health check status details.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param network_connection_name: Name of the Network Connection that can be applied to a Pool.
          Required.
         :type network_connection_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: HealthCheckStatusDetails or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.HealthCheckStatusDetails
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -919,43 +1014,47 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.HealthCheckStatusDetails] = kwargs.pop("cls", None)
 
-        _request = build_get_health_details_request(
+        request = build_get_health_details_request(
             resource_group_name=resource_group_name,
             network_connection_name=network_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get_health_details.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("HealthCheckStatusDetails", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    get_health_details.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}/healthChecks/latest"
+    }
 
     async def _run_health_checks_initial(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, network_connection_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -966,56 +1065,65 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_run_health_checks_request(
+        request = build_run_health_checks_request(
             resource_group_name=resource_group_name,
             network_connection_name=network_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self._run_health_checks_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202]:
+        if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
+            return cls(pipeline_response, None, {})
+
+    _run_health_checks_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}/runHealthChecks"
+    }
 
     @distributed_trace_async
     async def begin_run_health_checks(
         self, resource_group_name: str, network_connection_name: str, **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Triggers a new health check run. The execution and health check result can be tracked via the
         network Connection health check details.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param network_connection_name: Name of the Network Connection that can be applied to a Pool.
          Required.
         :type network_connection_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -1034,50 +1142,55 @@
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[None].from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_run_health_checks.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}/runHealthChecks"
+    }
 
     @distributed_trace
-    def list_outbound_network_dependencies_endpoints(  # pylint: disable=name-too-long
+    def list_outbound_network_dependencies_endpoints(
         self, resource_group_name: str, network_connection_name: str, top: Optional[int] = None, **kwargs: Any
     ) -> AsyncIterable["_models.OutboundEnvironmentEndpoint"]:
         """Lists the endpoints that agents may call as part of Dev Box service administration. These FQDNs
         should be allowed for outbound access in order for the Dev Box service to function.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param network_connection_name: Name of the Network Connection that can be applied to a Pool.
          Required.
         :type network_connection_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either OutboundEnvironmentEndpoint or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.OutboundEnvironmentEndpoint]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
@@ -1093,61 +1206,65 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_outbound_network_dependencies_endpoints_request(
+                request = build_list_outbound_network_dependencies_endpoints_request(
                     resource_group_name=resource_group_name,
                     network_connection_name=network_connection_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_outbound_network_dependencies_endpoints.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("OutboundEnvironmentEndpointCollection", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
+
+    list_outbound_network_dependencies_endpoints.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}/outboundNetworkDependenciesEndpoints"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_operation_statuses_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_operation_statuses_operations.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -13,57 +13,90 @@
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
+from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
-from azure.core.tracing.decorator_async import distributed_trace_async
+from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._operation_statuses_operations import build_get_request
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import _convert_request
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_get_request(location: str, operation_id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/providers/Microsoft.DevCenter/locations/{location}/operationStatuses/{operationId}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "location": _SERIALIZER.url("location", location, "str"),
+        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 class OperationStatusesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.devcenter.aio.DevCenterMgmtClient`'s
+        :class:`~azure.mgmt.devcenter.DevCenterMgmtClient`'s
         :attr:`operation_statuses` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
-    @distributed_trace_async
-    async def get(self, location: str, operation_id: str, **kwargs: Any) -> _models.OperationStatus:
+    @distributed_trace
+    def get(self, location: str, operation_id: str, **kwargs: Any) -> _models.OperationStatus:
         """Get Operation Status.
 
         Gets the current status of an async operation.
 
         :param location: The Azure region. Required.
         :type location: str
         :param operation_id: The ID of an ongoing async operation. Required.
         :type operation_id: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: OperationStatus or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.OperationStatus
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -74,43 +107,44 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             location=location,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("OperationStatus", pipeline_response)
 
         if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
             deserialized = self._deserialize("OperationStatus", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
+
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.DevCenter/locations/{location}/operationStatuses/{operationId}"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -52,14 +52,15 @@
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
         """Lists all of the available resource provider operations.
 
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -73,57 +74,59 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_request(
+                request = build_list_request(
                     api_version=api_version,
+                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("OperationListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
+
+    list.metadata = {"url": "/providers/Microsoft.DevCenter/operations"}
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_patch.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_pools_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_pools_operations.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -73,14 +73,15 @@
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Pool or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.Pool]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -94,80 +95,85 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_project_request(
+                request = build_list_by_project_request(
                     resource_group_name=resource_group_name,
                     project_name=project_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_project.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("PoolListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
+    list_by_project.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools"
+    }
+
     @distributed_trace_async
     async def get(self, resource_group_name: str, project_name: str, pool_name: str, **kwargs: Any) -> _models.Pool:
         """Gets a machine pool.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Pool or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.Pool
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -178,52 +184,51 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.Pool] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             pool_name=pool_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("Pool", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}"
+    }
 
     async def _create_or_update_initial(
-        self,
-        resource_group_name: str,
-        project_name: str,
-        pool_name: str,
-        body: Union[_models.Pool, IO[bytes]],
-        **kwargs: Any
+        self, resource_group_name: str, project_name: str, pool_name: str, body: Union[_models.Pool, IO], **kwargs: Any
     ) -> _models.Pool:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -240,52 +245,56 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "Pool")
 
-        _request = build_create_or_update_request(
+        request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             pool_name=pool_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
             deserialized = self._deserialize("Pool", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("Pool", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
+    _create_or_update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}"
+    }
+
     @overload
     async def begin_create_or_update(
         self,
         resource_group_name: str,
         project_name: str,
         pool_name: str,
         body: _models.Pool,
@@ -303,69 +312,91 @@
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
         :param body: Represents a machine pool. Required.
         :type body: ~azure.mgmt.devcenter.models.Pool
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either Pool or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Pool]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_create_or_update(
         self,
         resource_group_name: str,
         project_name: str,
         pool_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Pool]:
         """Creates or updates a machine pool.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
         :param body: Represents a machine pool. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either Pool or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Pool]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_create_or_update(
-        self,
-        resource_group_name: str,
-        project_name: str,
-        pool_name: str,
-        body: Union[_models.Pool, IO[bytes]],
-        **kwargs: Any
+        self, resource_group_name: str, project_name: str, pool_name: str, body: Union[_models.Pool, IO], **kwargs: Any
     ) -> AsyncLROPoller[_models.Pool]:
         """Creates or updates a machine pool.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
-        :param body: Represents a machine pool. Is either a Pool type or a IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.Pool or IO[bytes]
+        :param body: Represents a machine pool. Is either a Pool type or a IO type. Required.
+        :type body: ~azure.mgmt.devcenter.models.Pool or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either Pool or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Pool]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -389,43 +420,45 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Pool", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[_models.Pool].from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[_models.Pool](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_create_or_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}"
+    }
 
     async def _update_initial(
         self,
         resource_group_name: str,
         project_name: str,
         pool_name: str,
-        body: Union[_models.PoolUpdate, IO[bytes]],
+        body: Union[_models.PoolUpdate, IO],
         **kwargs: Any
     ) -> Optional[_models.Pool]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -443,53 +476,53 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "PoolUpdate")
 
-        _request = build_update_request(
+        request = build_update_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             pool_name=pool_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = None
-        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("Pool", pipeline_response)
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    _update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}"
+    }
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
         project_name: str,
         pool_name: str,
@@ -508,70 +541,96 @@
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
         :param body: Represents a machine pool. Required.
         :type body: ~azure.mgmt.devcenter.models.PoolUpdate
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either Pool or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Pool]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
         project_name: str,
         pool_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Pool]:
         """Partially updates a machine pool.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
         :param body: Represents a machine pool. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either Pool or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Pool]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_update(
         self,
         resource_group_name: str,
         project_name: str,
         pool_name: str,
-        body: Union[_models.PoolUpdate, IO[bytes]],
+        body: Union[_models.PoolUpdate, IO],
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Pool]:
         """Partially updates a machine pool.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
-        :param body: Represents a machine pool. Is either a PoolUpdate type or a IO[bytes] type.
-         Required.
-        :type body: ~azure.mgmt.devcenter.models.PoolUpdate or IO[bytes]
+        :param body: Represents a machine pool. Is either a PoolUpdate type or a IO type. Required.
+        :type body: ~azure.mgmt.devcenter.models.PoolUpdate or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either Pool or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Pool]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -595,36 +654,38 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Pool", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[_models.Pool].from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[_models.Pool](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}"
+    }
 
     async def _delete_initial(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, project_name: str, pool_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -635,58 +696,66 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_delete_request(
+        request = build_delete_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             pool_name=pool_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
+            return cls(pipeline_response, None, {})
+
+    _delete_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}"
+    }
 
     @distributed_trace_async
     async def begin_delete(
         self, resource_group_name: str, project_name: str, pool_name: str, **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Deletes a machine pool.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -706,33 +775,37 @@
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[None].from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_delete.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}"
+    }
 
     async def _run_health_checks_initial(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, project_name: str, pool_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -743,57 +816,66 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_run_health_checks_request(
+        request = build_run_health_checks_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             pool_name=pool_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self._run_health_checks_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202]:
+        if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
+            return cls(pipeline_response, None, {})
+
+    _run_health_checks_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/runHealthChecks"
+    }
 
     @distributed_trace_async
     async def begin_run_health_checks(
         self, resource_group_name: str, project_name: str, pool_name: str, **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Triggers a refresh of the pool status.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -813,26 +895,30 @@
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[None].from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_run_health_checks.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/runHealthChecks"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_project_allowed_environment_types_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_project_allowed_environment_types_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -63,14 +63,15 @@
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AllowedEnvironmentType or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.AllowedEnvironmentType]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
@@ -86,82 +87,87 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_request(
+                request = build_list_request(
                     resource_group_name=resource_group_name,
                     project_name=project_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("AllowedEnvironmentTypeListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
+    list.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/allowedEnvironmentTypes"
+    }
+
     @distributed_trace_async
     async def get(
         self, resource_group_name: str, project_name: str, environment_type_name: str, **kwargs: Any
     ) -> _models.AllowedEnvironmentType:
         """Gets an allowed environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AllowedEnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.AllowedEnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -172,37 +178,41 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AllowedEnvironmentType] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             environment_type_name=environment_type_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("AllowedEnvironmentType", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-        return deserialized  # type: ignore
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/allowedEnvironmentTypes/{environmentTypeName}"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_project_catalog_environment_definitions_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_operation_statuses_operations.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -21,101 +21,98 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._project_catalog_environment_definitions_operations import build_get_error_details_request
+from ...operations._operation_statuses_operations import build_get_request
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class ProjectCatalogEnvironmentDefinitionsOperations:  # pylint: disable=name-too-long
+class OperationStatusesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.devcenter.aio.DevCenterMgmtClient`'s
-        :attr:`project_catalog_environment_definitions` attribute.
+        :attr:`operation_statuses` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace_async
-    async def get_error_details(
-        self,
-        resource_group_name: str,
-        project_name: str,
-        catalog_name: str,
-        environment_definition_name: str,
-        **kwargs: Any
-    ) -> _models.CatalogResourceValidationErrorDetails:
-        """Gets Environment Definition error details.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param project_name: The name of the project. Required.
-        :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :param environment_definition_name: The name of the Environment Definition. Required.
-        :type environment_definition_name: str
-        :return: CatalogResourceValidationErrorDetails or the result of cls(response)
-        :rtype: ~azure.mgmt.devcenter.models.CatalogResourceValidationErrorDetails
+    async def get(self, location: str, operation_id: str, **kwargs: Any) -> _models.OperationStatus:
+        """Get Operation Status.
+
+        Gets the current status of an async operation.
+
+        :param location: The Azure region. Required.
+        :type location: str
+        :param operation_id: The ID of an ongoing async operation. Required.
+        :type operation_id: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: OperationStatus or the result of cls(response)
+        :rtype: ~azure.mgmt.devcenter.models.OperationStatus
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CatalogResourceValidationErrorDetails] = kwargs.pop("cls", None)
+        cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
 
-        _request = build_get_error_details_request(
-            resource_group_name=resource_group_name,
-            project_name=project_name,
-            catalog_name=catalog_name,
-            environment_definition_name=environment_definition_name,
+        request = build_get_request(
+            location=location,
+            operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200]:
+        if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("CatalogResourceValidationErrorDetails", pipeline_response)
+        if response.status_code == 200:
+            deserialized = self._deserialize("OperationStatus", pipeline_response)
+
+        if response.status_code == 202:
+            deserialized = self._deserialize("OperationStatus", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
+
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.DevCenter/locations/{location}/operationStatuses/{operationId}"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_project_catalogs_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_projects_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,813 +1,962 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 from io import IOBase
-from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
+from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
-from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
-from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
+from azure.core.pipeline.transport import HttpResponse
+from azure.core.polling import LROPoller, NoPolling, PollingMethod
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
-from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
-from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
+from azure.mgmt.core.polling.arm_polling import ARMPolling
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._project_catalogs_operations import (
-    build_connect_request,
-    build_create_or_update_request,
-    build_delete_request,
-    build_get_request,
-    build_get_sync_error_details_request,
-    build_list_request,
-    build_patch_request,
-    build_sync_request,
-)
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import _convert_request
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_list_by_subscription_request(
+    subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.DevCenter/projects")
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+    if top is not None:
+        _params["$top"] = _SERIALIZER.query("top", top, "int")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_list_by_resource_group_request(
+    resource_group_name: str, subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+    if top is not None:
+        _params["$top"] = _SERIALIZER.query("top", top, "int")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_get_request(resource_group_name: str, project_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "projectName": _SERIALIZER.url(
+            "project_name",
+            project_name,
+            "str",
+            max_length=63,
+            min_length=3,
+            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
+        ),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_create_or_update_request(
+    resource_group_name: str, project_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "projectName": _SERIALIZER.url(
+            "project_name",
+            project_name,
+            "str",
+            max_length=63,
+            min_length=3,
+            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
+        ),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_update_request(
+    resource_group_name: str, project_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "projectName": _SERIALIZER.url(
+            "project_name",
+            project_name,
+            "str",
+            max_length=63,
+            min_length=3,
+            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
+        ),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_delete_request(
+    resource_group_name: str, project_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "projectName": _SERIALIZER.url(
+            "project_name",
+            project_name,
+            "str",
+            max_length=63,
+            min_length=3,
+            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
+        ),
+    }
+
+    _url: str = _url.format(**path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
+    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
-class ProjectCatalogsOperations:
+
+class ProjectsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.devcenter.aio.DevCenterMgmtClient`'s
-        :attr:`project_catalogs` attribute.
+        :class:`~azure.mgmt.devcenter.DevCenterMgmtClient`'s
+        :attr:`projects` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def list(
-        self, resource_group_name: str, project_name: str, top: Optional[int] = None, **kwargs: Any
-    ) -> AsyncIterable["_models.Catalog"]:
-        """Lists the catalogs associated with a project.
+    def list_by_subscription(self, top: Optional[int] = None, **kwargs: Any) -> Iterable["_models.Project"]:
+        """Lists all projects in the subscription.
+
+        :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
+         Default value is None.
+        :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: An iterator like instance of either Project or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.Project]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.ProjectListResult] = kwargs.pop("cls", None)
+
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        def prepare_request(next_link=None):
+            if not next_link:
+
+                request = build_list_by_subscription_request(
+                    subscription_id=self._config.subscription_id,
+                    top=top,
+                    api_version=api_version,
+                    template_url=self.list_by_subscription.metadata["url"],
+                    headers=_headers,
+                    params=_params,
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
+
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("ProjectListResult", pipeline_response)
+            list_of_elem = deserialized.value
+            if cls:
+                list_of_elem = cls(list_of_elem)  # type: ignore
+            return deserialized.next_link or None, iter(list_of_elem)
+
+        def get_next(next_link=None):
+            request = prepare_request(next_link)
+
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
+            )
+            response = pipeline_response.http_response
+
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+
+            return pipeline_response
+
+        return ItemPaged(get_next, extract_data)
+
+    list_by_subscription.metadata = {"url": "/subscriptions/{subscriptionId}/providers/Microsoft.DevCenter/projects"}
+
+    @distributed_trace
+    def list_by_resource_group(
+        self, resource_group_name: str, top: Optional[int] = None, **kwargs: Any
+    ) -> Iterable["_models.Project"]:
+        """Lists all projects in the resource group.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param project_name: The name of the project. Required.
-        :type project_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
-        :return: An iterator like instance of either Catalog or the result of cls(response)
-        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.Catalog]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: An iterator like instance of either Project or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.Project]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CatalogListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.ProjectListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_request(
+                request = build_list_by_resource_group_request(
                     resource_group_name=resource_group_name,
-                    project_name=project_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_resource_group.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("CatalogListResult", pipeline_response)
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("ProjectListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+        def get_next(next_link=None):
+            request = prepare_request(next_link)
 
             _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
+        return ItemPaged(get_next, extract_data)
 
-    @distributed_trace_async
-    async def get(
-        self, resource_group_name: str, project_name: str, catalog_name: str, **kwargs: Any
-    ) -> _models.Catalog:
-        """Gets an associated project catalog.
+    list_by_resource_group.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects"
+    }
+
+    @distributed_trace
+    def get(self, resource_group_name: str, project_name: str, **kwargs: Any) -> _models.Project:
+        """Gets a specific project.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :return: Catalog or the result of cls(response)
-        :rtype: ~azure.mgmt.devcenter.models.Catalog
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: Project or the result of cls(response)
+        :rtype: ~azure.mgmt.devcenter.models.Project
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.Catalog] = kwargs.pop("cls", None)
+        cls: ClsType[_models.Project] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
-            catalog_name=catalog_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("Catalog", pipeline_response)
+        deserialized = self._deserialize("Project", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
 
-    async def _create_or_update_initial(
-        self,
-        resource_group_name: str,
-        project_name: str,
-        catalog_name: str,
-        body: Union[_models.Catalog, IO[bytes]],
-        **kwargs: Any
-    ) -> _models.Catalog:
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}"
+    }
+
+    def _create_or_update_initial(
+        self, resource_group_name: str, project_name: str, body: Union[_models.Project, IO], **kwargs: Any
+    ) -> _models.Project:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.Catalog] = kwargs.pop("cls", None)
+        cls: ClsType[_models.Project] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "Catalog")
+            _json = self._serialize.body(body, "Project")
 
-        _request = build_create_or_update_request(
+        request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
-            catalog_name=catalog_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
-            deserialized = self._deserialize("Catalog", pipeline_response)
+            deserialized = self._deserialize("Project", pipeline_response)
 
         if response.status_code == 201:
-            deserialized = self._deserialize("Catalog", pipeline_response)
+            deserialized = self._deserialize("Project", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
+    _create_or_update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}"
+    }
+
     @overload
-    async def begin_create_or_update(
+    def begin_create_or_update(
         self,
         resource_group_name: str,
         project_name: str,
-        catalog_name: str,
-        body: _models.Catalog,
+        body: _models.Project,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.Catalog]:
-        """Creates or updates a project catalog.
+    ) -> LROPoller[_models.Project]:
+        """Creates or updates a project.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :param body: Represents a catalog. Required.
-        :type body: ~azure.mgmt.devcenter.models.Catalog
+        :param body: Represents a project. Required.
+        :type body: ~azure.mgmt.devcenter.models.Project
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :return: An instance of AsyncLROPoller that returns either Catalog or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Catalog]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either Project or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Project]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_create_or_update(
+    def begin_create_or_update(
         self,
         resource_group_name: str,
         project_name: str,
-        catalog_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.Catalog]:
-        """Creates or updates a project catalog.
+    ) -> LROPoller[_models.Project]:
+        """Creates or updates a project.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :param body: Represents a catalog. Required.
-        :type body: IO[bytes]
+        :param body: Represents a project. Required.
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :return: An instance of AsyncLROPoller that returns either Catalog or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Catalog]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either Project or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Project]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_create_or_update(
-        self,
-        resource_group_name: str,
-        project_name: str,
-        catalog_name: str,
-        body: Union[_models.Catalog, IO[bytes]],
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.Catalog]:
-        """Creates or updates a project catalog.
+    @distributed_trace
+    def begin_create_or_update(
+        self, resource_group_name: str, project_name: str, body: Union[_models.Project, IO], **kwargs: Any
+    ) -> LROPoller[_models.Project]:
+        """Creates or updates a project.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :param body: Represents a catalog. Is either a Catalog type or a IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.Catalog or IO[bytes]
-        :return: An instance of AsyncLROPoller that returns either Catalog or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Catalog]
+        :param body: Represents a project. Is either a Project type or a IO type. Required.
+        :type body: ~azure.mgmt.devcenter.models.Project or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either Project or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Project]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.Catalog] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        cls: ClsType[_models.Project] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._create_or_update_initial(
+            raw_result = self._create_or_update_initial(
                 resource_group_name=resource_group_name,
                 project_name=project_name,
-                catalog_name=catalog_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("Catalog", pipeline_response)
+            deserialized = self._deserialize("Project", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[_models.Catalog].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[_models.Catalog](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    async def _patch_initial(
-        self,
-        resource_group_name: str,
-        project_name: str,
-        catalog_name: str,
-        body: Union[_models.CatalogUpdate, IO[bytes]],
-        **kwargs: Any
-    ) -> Optional[_models.Catalog]:
+    begin_create_or_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}"
+    }
+
+    def _update_initial(
+        self, resource_group_name: str, project_name: str, body: Union[_models.ProjectUpdate, IO], **kwargs: Any
+    ) -> Optional[_models.Project]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.Catalog]] = kwargs.pop("cls", None)
+        cls: ClsType[Optional[_models.Project]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "CatalogUpdate")
+            _json = self._serialize.body(body, "ProjectUpdate")
 
-        _request = build_patch_request(
+        request = build_update_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
-            catalog_name=catalog_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = None
-        response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("Catalog", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            deserialized = self._deserialize("Project", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    _update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}"
+    }
 
     @overload
-    async def begin_patch(
+    def begin_update(
         self,
         resource_group_name: str,
         project_name: str,
-        catalog_name: str,
-        body: _models.CatalogUpdate,
+        body: _models.ProjectUpdate,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.Catalog]:
-        """Partially updates a project catalog.
+    ) -> LROPoller[_models.Project]:
+        """Partially updates a project.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :param body: Updatable project catalog properties. Required.
-        :type body: ~azure.mgmt.devcenter.models.CatalogUpdate
+        :param body: Updatable project properties. Required.
+        :type body: ~azure.mgmt.devcenter.models.ProjectUpdate
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :return: An instance of AsyncLROPoller that returns either Catalog or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Catalog]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either Project or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Project]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_patch(
+    def begin_update(
         self,
         resource_group_name: str,
         project_name: str,
-        catalog_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.Catalog]:
-        """Partially updates a project catalog.
+    ) -> LROPoller[_models.Project]:
+        """Partially updates a project.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :param body: Updatable project catalog properties. Required.
-        :type body: IO[bytes]
+        :param body: Updatable project properties. Required.
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :return: An instance of AsyncLROPoller that returns either Catalog or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Catalog]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either Project or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Project]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_patch(
-        self,
-        resource_group_name: str,
-        project_name: str,
-        catalog_name: str,
-        body: Union[_models.CatalogUpdate, IO[bytes]],
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.Catalog]:
-        """Partially updates a project catalog.
+    @distributed_trace
+    def begin_update(
+        self, resource_group_name: str, project_name: str, body: Union[_models.ProjectUpdate, IO], **kwargs: Any
+    ) -> LROPoller[_models.Project]:
+        """Partially updates a project.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :param body: Updatable project catalog properties. Is either a CatalogUpdate type or a
-         IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.CatalogUpdate or IO[bytes]
-        :return: An instance of AsyncLROPoller that returns either Catalog or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Catalog]
+        :param body: Updatable project properties. Is either a ProjectUpdate type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.devcenter.models.ProjectUpdate or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either Project or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Project]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.Catalog] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        cls: ClsType[_models.Project] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._patch_initial(
+            raw_result = self._update_initial(
                 resource_group_name=resource_group_name,
                 project_name=project_name,
-                catalog_name=catalog_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("Catalog", pipeline_response)
+            deserialized = self._deserialize("Project", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[_models.Catalog].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[_models.Catalog](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, project_name: str, catalog_name: str, **kwargs: Any
-    ) -> None:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
+    begin_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}"
+    }
 
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
-
-        _request = build_delete_request(
-            resource_group_name=resource_group_name,
-            project_name=project_name,
-            catalog_name=catalog_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            headers=_headers,
-            params=_params,
-        )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [202, 204]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-        if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
-
-    @distributed_trace_async
-    async def begin_delete(
-        self, resource_group_name: str, project_name: str, catalog_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[None]:
-        """Deletes a project catalog resource.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param project_name: The name of the project. Required.
-        :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = await self._delete_initial(  # type: ignore
-                resource_group_name=resource_group_name,
-                project_name=project_name,
-                catalog_name=catalog_name,
-                api_version=api_version,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
-            if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
-
-        if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
-            )
-        elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return AsyncLROPoller[None].from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    @distributed_trace_async
-    async def get_sync_error_details(
-        self, resource_group_name: str, project_name: str, catalog_name: str, **kwargs: Any
-    ) -> _models.SyncErrorDetails:
-        """Gets project catalog synchronization error details.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param project_name: The name of the project. Required.
-        :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :return: SyncErrorDetails or the result of cls(response)
-        :rtype: ~azure.mgmt.devcenter.models.SyncErrorDetails
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.SyncErrorDetails] = kwargs.pop("cls", None)
-
-        _request = build_get_sync_error_details_request(
-            resource_group_name=resource_group_name,
-            project_name=project_name,
-            catalog_name=catalog_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            headers=_headers,
-            params=_params,
-        )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        deserialized = self._deserialize("SyncErrorDetails", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
-
-        return deserialized  # type: ignore
-
-    async def _sync_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, project_name: str, catalog_name: str, **kwargs: Any
+    def _delete_initial(  # pylint: disable=inconsistent-return-statements
+        self, resource_group_name: str, project_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -815,203 +964,102 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_sync_request(
+        request = build_delete_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
-            catalog_name=catalog_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
-
-    @distributed_trace_async
-    async def begin_sync(
-        self, resource_group_name: str, project_name: str, catalog_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[None]:
-        """Syncs templates for a template source.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param project_name: The name of the project. Required.
-        :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+            return cls(pipeline_response, None, {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = await self._sync_initial(  # type: ignore
-                resource_group_name=resource_group_name,
-                project_name=project_name,
-                catalog_name=catalog_name,
-                api_version=api_version,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
+    _delete_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}"
+    }
 
-        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
-            if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
-
-        if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
-            )
-        elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return AsyncLROPoller[None].from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    async def _connect_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, project_name: str, catalog_name: str, **kwargs: Any
-    ) -> None:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
-
-        _request = build_connect_request(
-            resource_group_name=resource_group_name,
-            project_name=project_name,
-            catalog_name=catalog_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            headers=_headers,
-            params=_params,
-        )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-        if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
-
-    @distributed_trace_async
-    async def begin_connect(
-        self, resource_group_name: str, project_name: str, catalog_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[None]:
-        """Connects a project catalog to enable syncing.
+    @distributed_trace
+    def begin_delete(self, resource_group_name: str, project_name: str, **kwargs: Any) -> LROPoller[None]:
+        """Deletes a project resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._connect_initial(  # type: ignore
+            raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 project_name=project_name,
-                catalog_name=catalog_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
+                return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[None].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_delete.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_project_environment_types_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_project_environment_types_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -70,14 +70,15 @@
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either ProjectEnvironmentType or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.ProjectEnvironmentType]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
@@ -93,82 +94,87 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_request(
+                request = build_list_request(
                     resource_group_name=resource_group_name,
                     project_name=project_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("ProjectEnvironmentTypeListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
+    list.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/environmentTypes"
+    }
+
     @distributed_trace_async
     async def get(
         self, resource_group_name: str, project_name: str, environment_type_name: str, **kwargs: Any
     ) -> _models.ProjectEnvironmentType:
         """Gets a project environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProjectEnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.ProjectEnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -179,44 +185,48 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ProjectEnvironmentType] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             environment_type_name=environment_type_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ProjectEnvironmentType", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-        return deserialized  # type: ignore
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/environmentTypes/{environmentTypeName}"
+    }
 
     @overload
     async def create_or_update(
         self,
         resource_group_name: str,
         project_name: str,
         environment_type_name: str,
@@ -235,70 +245,76 @@
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
         :param body: Represents a Project Environment Type. Required.
         :type body: ~azure.mgmt.devcenter.models.ProjectEnvironmentType
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProjectEnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.ProjectEnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def create_or_update(
         self,
         resource_group_name: str,
         project_name: str,
         environment_type_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.ProjectEnvironmentType:
         """Creates or updates a project environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
         :param body: Represents a Project Environment Type. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProjectEnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.ProjectEnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def create_or_update(
         self,
         resource_group_name: str,
         project_name: str,
         environment_type_name: str,
-        body: Union[_models.ProjectEnvironmentType, IO[bytes]],
+        body: Union[_models.ProjectEnvironmentType, IO],
         **kwargs: Any
     ) -> _models.ProjectEnvironmentType:
         """Creates or updates a project environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
         :param body: Represents a Project Environment Type. Is either a ProjectEnvironmentType type or
-         a IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.ProjectEnvironmentType or IO[bytes]
+         a IO type. Required.
+        :type body: ~azure.mgmt.devcenter.models.ProjectEnvironmentType or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProjectEnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.ProjectEnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -318,51 +334,51 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "ProjectEnvironmentType")
 
-        _request = build_create_or_update_request(
+        request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             environment_type_name=environment_type_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 201]:
+        if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        if response.status_code == 200:
-            deserialized = self._deserialize("ProjectEnvironmentType", pipeline_response)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        if response.status_code == 201:
-            deserialized = self._deserialize("ProjectEnvironmentType", pipeline_response)
+        deserialized = self._deserialize("ProjectEnvironmentType", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-        return deserialized  # type: ignore
+    create_or_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/environmentTypes/{environmentTypeName}"
+    }
 
     @overload
     async def update(
         self,
         resource_group_name: str,
         project_name: str,
         environment_type_name: str,
@@ -381,70 +397,76 @@
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
         :param body: Updatable project environment type properties. Required.
         :type body: ~azure.mgmt.devcenter.models.ProjectEnvironmentTypeUpdate
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProjectEnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.ProjectEnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def update(
         self,
         resource_group_name: str,
         project_name: str,
         environment_type_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.ProjectEnvironmentType:
         """Partially updates a project environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
         :param body: Updatable project environment type properties. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProjectEnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.ProjectEnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def update(
         self,
         resource_group_name: str,
         project_name: str,
         environment_type_name: str,
-        body: Union[_models.ProjectEnvironmentTypeUpdate, IO[bytes]],
+        body: Union[_models.ProjectEnvironmentTypeUpdate, IO],
         **kwargs: Any
     ) -> _models.ProjectEnvironmentType:
         """Partially updates a project environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
         :param body: Updatable project environment type properties. Is either a
-         ProjectEnvironmentTypeUpdate type or a IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.ProjectEnvironmentTypeUpdate or IO[bytes]
+         ProjectEnvironmentTypeUpdate type or a IO type. Required.
+        :type body: ~azure.mgmt.devcenter.models.ProjectEnvironmentTypeUpdate or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProjectEnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.ProjectEnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -464,61 +486,66 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "ProjectEnvironmentTypeUpdate")
 
-        _request = build_update_request(
+        request = build_update_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             environment_type_name=environment_type_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ProjectEnvironmentType", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-        return deserialized  # type: ignore
+    update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/environmentTypes/{environmentTypeName}"
+    }
 
     @distributed_trace_async
     async def delete(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, project_name: str, environment_type_name: str, **kwargs: Any
     ) -> None:
         """Deletes a project environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -529,33 +556,37 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_delete_request(
+        request = build_delete_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             environment_type_name=environment_type_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})  # type: ignore
+            return cls(pipeline_response, None, {})
+
+    delete.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/environmentTypes/{environmentTypeName}"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_projects_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_galleries_operations.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -27,648 +27,443 @@
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._projects_operations import (
+from ...operations._galleries_operations import (
     build_create_or_update_request,
     build_delete_request,
     build_get_request,
-    build_list_by_resource_group_request,
-    build_list_by_subscription_request,
-    build_update_request,
+    build_list_by_dev_center_request,
 )
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class ProjectsOperations:
+class GalleriesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.devcenter.aio.DevCenterMgmtClient`'s
-        :attr:`projects` attribute.
+        :attr:`galleries` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def list_by_subscription(self, top: Optional[int] = None, **kwargs: Any) -> AsyncIterable["_models.Project"]:
-        """Lists all projects in the subscription.
-
-        :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
-         Default value is None.
-        :type top: int
-        :return: An iterator like instance of either Project or the result of cls(response)
-        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.Project]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ProjectListResult] = kwargs.pop("cls", None)
-
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        def prepare_request(next_link=None):
-            if not next_link:
-
-                _request = build_list_by_subscription_request(
-                    subscription_id=self._config.subscription_id,
-                    top=top,
-                    api_version=api_version,
-                    headers=_headers,
-                    params=_params,
-                )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-
-            else:
-                # make call to next link with the client's api-version
-                _parsed_next_link = urllib.parse.urlparse(next_link)
-                _next_request_params = case_insensitive_dict(
-                    {
-                        key: [urllib.parse.quote(v) for v in value]
-                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
-                    }
-                )
-                _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
-                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
-                )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
-
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("ProjectListResult", pipeline_response)
-            list_of_elem = deserialized.value
-            if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
-
-        async def get_next(next_link=None):
-            _request = prepare_request(next_link)
-
-            _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
-            )
-            response = pipeline_response.http_response
-
-            if response.status_code not in [200]:
-                map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-            return pipeline_response
-
-        return AsyncItemPaged(get_next, extract_data)
-
-    @distributed_trace
-    def list_by_resource_group(
-        self, resource_group_name: str, top: Optional[int] = None, **kwargs: Any
-    ) -> AsyncIterable["_models.Project"]:
-        """Lists all projects in the resource group.
+    def list_by_dev_center(
+        self, resource_group_name: str, dev_center_name: str, top: Optional[int] = None, **kwargs: Any
+    ) -> AsyncIterable["_models.Gallery"]:
+        """Lists galleries for a devcenter.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
+        :param dev_center_name: The name of the devcenter. Required.
+        :type dev_center_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
-        :return: An iterator like instance of either Project or the result of cls(response)
-        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.Project]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: An iterator like instance of either Gallery or the result of cls(response)
+        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.Gallery]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ProjectListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.GalleryListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_resource_group_request(
+                request = build_list_by_dev_center_request(
                     resource_group_name=resource_group_name,
+                    dev_center_name=dev_center_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_dev_center.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("ProjectListResult", pipeline_response)
+            deserialized = self._deserialize("GalleryListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
+    list_by_dev_center.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries"
+    }
+
     @distributed_trace_async
-    async def get(self, resource_group_name: str, project_name: str, **kwargs: Any) -> _models.Project:
-        """Gets a specific project.
+    async def get(
+        self, resource_group_name: str, dev_center_name: str, gallery_name: str, **kwargs: Any
+    ) -> _models.Gallery:
+        """Gets a gallery.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param project_name: The name of the project. Required.
-        :type project_name: str
-        :return: Project or the result of cls(response)
-        :rtype: ~azure.mgmt.devcenter.models.Project
+        :param dev_center_name: The name of the devcenter. Required.
+        :type dev_center_name: str
+        :param gallery_name: The name of the gallery. Required.
+        :type gallery_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: Gallery or the result of cls(response)
+        :rtype: ~azure.mgmt.devcenter.models.Gallery
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.Project] = kwargs.pop("cls", None)
+        cls: ClsType[_models.Gallery] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
-            project_name=project_name,
+            dev_center_name=dev_center_name,
+            gallery_name=gallery_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("Project", pipeline_response)
+        deserialized = self._deserialize("Gallery", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}"
+    }
 
     async def _create_or_update_initial(
-        self, resource_group_name: str, project_name: str, body: Union[_models.Project, IO[bytes]], **kwargs: Any
-    ) -> _models.Project:
+        self,
+        resource_group_name: str,
+        dev_center_name: str,
+        gallery_name: str,
+        body: Union[_models.Gallery, IO],
+        **kwargs: Any
+    ) -> _models.Gallery:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.Project] = kwargs.pop("cls", None)
+        cls: ClsType[_models.Gallery] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "Project")
+            _json = self._serialize.body(body, "Gallery")
 
-        _request = build_create_or_update_request(
+        request = build_create_or_update_request(
             resource_group_name=resource_group_name,
-            project_name=project_name,
+            dev_center_name=dev_center_name,
+            gallery_name=gallery_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 201]:
+        if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        if response.status_code == 200:
-            deserialized = self._deserialize("Project", pipeline_response)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        if response.status_code == 201:
-            deserialized = self._deserialize("Project", pipeline_response)
+        deserialized = self._deserialize("Gallery", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-        return deserialized  # type: ignore
+    _create_or_update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}"
+    }
 
     @overload
     async def begin_create_or_update(
         self,
         resource_group_name: str,
-        project_name: str,
-        body: _models.Project,
+        dev_center_name: str,
+        gallery_name: str,
+        body: _models.Gallery,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.Project]:
-        """Creates or updates a project.
+    ) -> AsyncLROPoller[_models.Gallery]:
+        """Creates or updates a gallery.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param project_name: The name of the project. Required.
-        :type project_name: str
-        :param body: Represents a project. Required.
-        :type body: ~azure.mgmt.devcenter.models.Project
+        :param dev_center_name: The name of the devcenter. Required.
+        :type dev_center_name: str
+        :param gallery_name: The name of the gallery. Required.
+        :type gallery_name: str
+        :param body: Represents a gallery. Required.
+        :type body: ~azure.mgmt.devcenter.models.Gallery
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :return: An instance of AsyncLROPoller that returns either Project or the result of
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either Gallery or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Project]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Gallery]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_create_or_update(
         self,
         resource_group_name: str,
-        project_name: str,
-        body: IO[bytes],
+        dev_center_name: str,
+        gallery_name: str,
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.Project]:
-        """Creates or updates a project.
+    ) -> AsyncLROPoller[_models.Gallery]:
+        """Creates or updates a gallery.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param project_name: The name of the project. Required.
-        :type project_name: str
-        :param body: Represents a project. Required.
-        :type body: IO[bytes]
+        :param dev_center_name: The name of the devcenter. Required.
+        :type dev_center_name: str
+        :param gallery_name: The name of the gallery. Required.
+        :type gallery_name: str
+        :param body: Represents a gallery. Required.
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :return: An instance of AsyncLROPoller that returns either Project or the result of
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either Gallery or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Project]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Gallery]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_create_or_update(
-        self, resource_group_name: str, project_name: str, body: Union[_models.Project, IO[bytes]], **kwargs: Any
-    ) -> AsyncLROPoller[_models.Project]:
-        """Creates or updates a project.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param project_name: The name of the project. Required.
-        :type project_name: str
-        :param body: Represents a project. Is either a Project type or a IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.Project or IO[bytes]
-        :return: An instance of AsyncLROPoller that returns either Project or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Project]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.Project] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = await self._create_or_update_initial(
-                resource_group_name=resource_group_name,
-                project_name=project_name,
-                body=body,
-                api_version=api_version,
-                content_type=content_type,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("Project", pipeline_response)
-            if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
-            return deserialized
-
-        if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
-            )
-        elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return AsyncLROPoller[_models.Project].from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return AsyncLROPoller[_models.Project](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
-
-    async def _update_initial(
-        self, resource_group_name: str, project_name: str, body: Union[_models.ProjectUpdate, IO[bytes]], **kwargs: Any
-    ) -> Optional[_models.Project]:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.Project]] = kwargs.pop("cls", None)
-
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(body, (IOBase, bytes)):
-            _content = body
-        else:
-            _json = self._serialize.body(body, "ProjectUpdate")
-
-        _request = build_update_request(
-            resource_group_name=resource_group_name,
-            project_name=project_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            headers=_headers,
-            params=_params,
-        )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200, 202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        deserialized = None
-        response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("Project", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
-
-    @overload
-    async def begin_update(
-        self,
-        resource_group_name: str,
-        project_name: str,
-        body: _models.ProjectUpdate,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.Project]:
-        """Partially updates a project.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param project_name: The name of the project. Required.
-        :type project_name: str
-        :param body: Updatable project properties. Required.
-        :type body: ~azure.mgmt.devcenter.models.ProjectUpdate
-        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :return: An instance of AsyncLROPoller that returns either Project or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Project]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @overload
-    async def begin_update(
         self,
         resource_group_name: str,
-        project_name: str,
-        body: IO[bytes],
-        *,
-        content_type: str = "application/json",
+        dev_center_name: str,
+        gallery_name: str,
+        body: Union[_models.Gallery, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.Project]:
-        """Partially updates a project.
+    ) -> AsyncLROPoller[_models.Gallery]:
+        """Creates or updates a gallery.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param project_name: The name of the project. Required.
-        :type project_name: str
-        :param body: Updatable project properties. Required.
-        :type body: IO[bytes]
-        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
-         Default value is "application/json".
+        :param dev_center_name: The name of the devcenter. Required.
+        :type dev_center_name: str
+        :param gallery_name: The name of the gallery. Required.
+        :type gallery_name: str
+        :param body: Represents a gallery. Is either a Gallery type or a IO type. Required.
+        :type body: ~azure.mgmt.devcenter.models.Gallery or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
         :paramtype content_type: str
-        :return: An instance of AsyncLROPoller that returns either Project or the result of
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either Gallery or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Project]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @distributed_trace_async
-    async def begin_update(
-        self, resource_group_name: str, project_name: str, body: Union[_models.ProjectUpdate, IO[bytes]], **kwargs: Any
-    ) -> AsyncLROPoller[_models.Project]:
-        """Partially updates a project.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param project_name: The name of the project. Required.
-        :type project_name: str
-        :param body: Updatable project properties. Is either a ProjectUpdate type or a IO[bytes] type.
-         Required.
-        :type body: ~azure.mgmt.devcenter.models.ProjectUpdate or IO[bytes]
-        :return: An instance of AsyncLROPoller that returns either Project or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Project]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Gallery]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.Project] = kwargs.pop("cls", None)
+        cls: ClsType[_models.Gallery] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._update_initial(
+            raw_result = await self._create_or_update_initial(
                 resource_group_name=resource_group_name,
-                project_name=project_name,
+                dev_center_name=dev_center_name,
+                gallery_name=gallery_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("Project", pipeline_response)
+            deserialized = self._deserialize("Gallery", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[_models.Project].from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[_models.Project](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_create_or_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}"
+    }
 
     async def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, project_name: str, **kwargs: Any
+        self, resource_group_name: str, dev_center_name: str, gallery_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -676,53 +471,66 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_delete_request(
+        request = build_delete_request(
             resource_group_name=resource_group_name,
-            project_name=project_name,
+            dev_center_name=dev_center_name,
+            gallery_name=gallery_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
+            return cls(pipeline_response, None, {})
+
+    _delete_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}"
+    }
 
     @distributed_trace_async
-    async def begin_delete(self, resource_group_name: str, project_name: str, **kwargs: Any) -> AsyncLROPoller[None]:
-        """Deletes a project resource.
+    async def begin_delete(
+        self, resource_group_name: str, dev_center_name: str, gallery_name: str, **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Deletes a gallery resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param project_name: The name of the project. Required.
-        :type project_name: str
+        :param dev_center_name: The name of the devcenter. Required.
+        :type dev_center_name: str
+        :param gallery_name: The name of the gallery. Required.
+        :type gallery_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -730,37 +538,42 @@
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                project_name=project_name,
+                dev_center_name=dev_center_name,
+                gallery_name=gallery_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[None].from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_delete.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_schedules_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_schedules_operations.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -74,14 +74,15 @@
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Schedule or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.Schedule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -95,70 +96,74 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_pool_request(
+                request = build_list_by_pool_request(
                     resource_group_name=resource_group_name,
                     project_name=project_name,
                     pool_name=pool_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_pool.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("ScheduleListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
+    list_by_pool.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/schedules"
+    }
+
     @distributed_trace_async
     async def get(
         self,
         resource_group_name: str,
         project_name: str,
         pool_name: str,
         schedule_name: str,
@@ -175,14 +180,15 @@
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
         :param schedule_name: The name of the schedule that uniquely identifies it. Required.
         :type schedule_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Schedule or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.Schedule
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -193,54 +199,58 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.Schedule] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             pool_name=pool_name,
             schedule_name=schedule_name,
             subscription_id=self._config.subscription_id,
             top=top,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("Schedule", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/schedules/{scheduleName}"
+    }
 
     async def _create_or_update_initial(
         self,
         resource_group_name: str,
         project_name: str,
         pool_name: str,
         schedule_name: str,
-        body: Union[_models.Schedule, IO[bytes]],
+        body: Union[_models.Schedule, IO],
         top: Optional[int] = None,
         **kwargs: Any
     ) -> _models.Schedule:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -259,54 +269,58 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "Schedule")
 
-        _request = build_create_or_update_request(
+        request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             pool_name=pool_name,
             schedule_name=schedule_name,
             subscription_id=self._config.subscription_id,
             top=top,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
             deserialized = self._deserialize("Schedule", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("Schedule", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
+    _create_or_update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/schedules/{scheduleName}"
+    }
+
     @overload
     async def begin_create_or_update(
         self,
         resource_group_name: str,
         project_name: str,
         pool_name: str,
         schedule_name: str,
@@ -331,28 +345,36 @@
         :type body: ~azure.mgmt.devcenter.models.Schedule
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either Schedule or the result of
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Schedule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_create_or_update(
         self,
         resource_group_name: str,
         project_name: str,
         pool_name: str,
         schedule_name: str,
-        body: IO[bytes],
+        body: IO,
         top: Optional[int] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Schedule]:
         """Creates or updates a Schedule.
 
@@ -362,55 +384,73 @@
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
         :param schedule_name: The name of the schedule that uniquely identifies it. Required.
         :type schedule_name: str
         :param body: Represents a scheduled task. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either Schedule or the result of
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Schedule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_create_or_update(
         self,
         resource_group_name: str,
         project_name: str,
         pool_name: str,
         schedule_name: str,
-        body: Union[_models.Schedule, IO[bytes]],
+        body: Union[_models.Schedule, IO],
         top: Optional[int] = None,
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Schedule]:
         """Creates or updates a Schedule.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
         :param schedule_name: The name of the schedule that uniquely identifies it. Required.
         :type schedule_name: str
-        :param body: Represents a scheduled task. Is either a Schedule type or a IO[bytes] type.
-         Required.
-        :type body: ~azure.mgmt.devcenter.models.Schedule or IO[bytes]
+        :param body: Represents a scheduled task. Is either a Schedule type or a IO type. Required.
+        :type body: ~azure.mgmt.devcenter.models.Schedule or IO
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either Schedule or the result of
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Schedule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
@@ -437,44 +477,46 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Schedule", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[_models.Schedule].from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[_models.Schedule](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_create_or_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/schedules/{scheduleName}"
+    }
 
     async def _update_initial(
         self,
         resource_group_name: str,
         project_name: str,
         pool_name: str,
         schedule_name: str,
-        body: Union[_models.ScheduleUpdate, IO[bytes]],
+        body: Union[_models.ScheduleUpdate, IO],
         top: Optional[int] = None,
         **kwargs: Any
     ) -> Optional[_models.Schedule]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -493,55 +535,55 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "ScheduleUpdate")
 
-        _request = build_update_request(
+        request = build_update_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             pool_name=pool_name,
             schedule_name=schedule_name,
             subscription_id=self._config.subscription_id,
             top=top,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = None
-        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("Schedule", pipeline_response)
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    _update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/schedules/{scheduleName}"
+    }
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
         project_name: str,
         pool_name: str,
@@ -567,28 +609,36 @@
         :type body: ~azure.mgmt.devcenter.models.ScheduleUpdate
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either Schedule or the result of
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Schedule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
         project_name: str,
         pool_name: str,
         schedule_name: str,
-        body: IO[bytes],
+        body: IO,
         top: Optional[int] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Schedule]:
         """Partially updates a Scheduled.
 
@@ -598,55 +648,74 @@
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
         :param schedule_name: The name of the schedule that uniquely identifies it. Required.
         :type schedule_name: str
         :param body: Represents a scheduled task. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either Schedule or the result of
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Schedule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_update(
         self,
         resource_group_name: str,
         project_name: str,
         pool_name: str,
         schedule_name: str,
-        body: Union[_models.ScheduleUpdate, IO[bytes]],
+        body: Union[_models.ScheduleUpdate, IO],
         top: Optional[int] = None,
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Schedule]:
         """Partially updates a Scheduled.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
         :param schedule_name: The name of the schedule that uniquely identifies it. Required.
         :type schedule_name: str
-        :param body: Represents a scheduled task. Is either a ScheduleUpdate type or a IO[bytes] type.
+        :param body: Represents a scheduled task. Is either a ScheduleUpdate type or a IO type.
          Required.
-        :type body: ~azure.mgmt.devcenter.models.ScheduleUpdate or IO[bytes]
+        :type body: ~azure.mgmt.devcenter.models.ScheduleUpdate or IO
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either Schedule or the result of
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Schedule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
@@ -673,36 +742,38 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Schedule", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[_models.Schedule].from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[_models.Schedule](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/schedules/{scheduleName}"
+    }
 
     async def _delete_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         project_name: str,
         pool_name: str,
         schedule_name: str,
@@ -719,46 +790,46 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_delete_request(
+        request = build_delete_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             pool_name=pool_name,
             schedule_name=schedule_name,
             subscription_id=self._config.subscription_id,
             top=top,
             api_version=api_version,
+            template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
+            return cls(pipeline_response, None, {})
+
+    _delete_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/schedules/{scheduleName}"
+    }
 
     @distributed_trace_async
     async def begin_delete(
         self,
         resource_group_name: str,
         project_name: str,
         pool_name: str,
@@ -776,14 +847,22 @@
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
         :param schedule_name: The name of the schedule that uniquely identifies it. Required.
         :type schedule_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -805,26 +884,30 @@
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
                 AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller[None].from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_delete.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/schedules/{scheduleName}"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_skus_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_skus_operations.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -55,14 +55,15 @@
     @distributed_trace
     def list_by_subscription(self, top: Optional[int] = None, **kwargs: Any) -> AsyncIterable["_models.DevCenterSku"]:
         """Lists the Microsoft.DevCenter SKUs available in a subscription.
 
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DevCenterSku or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.DevCenterSku]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -76,59 +77,61 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_subscription_request(
+                request = build_list_by_subscription_request(
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_subscription.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("SkuListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
+
+    list_by_subscription.metadata = {"url": "/subscriptions/{subscriptionId}/providers/Microsoft.DevCenter/skus"}
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/aio/operations/_usages_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_usages_operations.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -54,14 +54,15 @@
 
     @distributed_trace
     def list_by_location(self, location: str, **kwargs: Any) -> AsyncIterable["_models.Usage"]:
         """Lists the current usages and limits in this location for the provided subscription.
 
         :param location: The Azure region. Required.
         :type location: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Usage or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.Usage]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -75,59 +76,63 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_location_request(
+                request = build_list_by_location_request(
                     location=location,
                     subscription_id=self._config.subscription_id,
                     api_version=api_version,
+                    template_url=self.list_by_location.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("ListUsagesResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
+
+    list_by_location.metadata = {
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.DevCenter/locations/{location}/usages"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/models/__init__.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/models/__init__.py`

 * *Files 5% similar despite different names*

```diff
@@ -18,25 +18,27 @@
 from ._models_py3 import CatalogProperties
 from ._models_py3 import CatalogResourceValidationErrorDetails
 from ._models_py3 import CatalogSyncError
 from ._models_py3 import CatalogUpdate
 from ._models_py3 import CatalogUpdateProperties
 from ._models_py3 import CheckNameAvailabilityRequest
 from ._models_py3 import CheckNameAvailabilityResponse
-from ._models_py3 import CheckScopedNameAvailabilityRequest
+from ._models_py3 import CloudErrorBody
 from ._models_py3 import CustomerManagedKeyEncryption
 from ._models_py3 import CustomerManagedKeyEncryptionKeyIdentity
+from ._models_py3 import CustomizationTask
+from ._models_py3 import CustomizationTaskInput
+from ._models_py3 import CustomizationTaskListResult
 from ._models_py3 import DevBoxDefinition
 from ._models_py3 import DevBoxDefinitionListResult
 from ._models_py3 import DevBoxDefinitionProperties
 from ._models_py3 import DevBoxDefinitionUpdate
 from ._models_py3 import DevBoxDefinitionUpdateProperties
 from ._models_py3 import DevCenter
 from ._models_py3 import DevCenterListResult
-from ._models_py3 import DevCenterProjectCatalogSettings
 from ._models_py3 import DevCenterProperties
 from ._models_py3 import DevCenterSku
 from ._models_py3 import DevCenterUpdate
 from ._models_py3 import DevCenterUpdateProperties
 from ._models_py3 import Encryption
 from ._models_py3 import EndpointDependency
 from ._models_py3 import EndpointDetail
@@ -81,15 +83,14 @@
 from ._models_py3 import OutboundEnvironmentEndpointCollection
 from ._models_py3 import Pool
 from ._models_py3 import PoolListResult
 from ._models_py3 import PoolProperties
 from ._models_py3 import PoolUpdate
 from ._models_py3 import PoolUpdateProperties
 from ._models_py3 import Project
-from ._models_py3 import ProjectCatalogSettings
 from ._models_py3 import ProjectEnvironmentType
 from ._models_py3 import ProjectEnvironmentTypeListResult
 from ._models_py3 import ProjectEnvironmentTypeProperties
 from ._models_py3 import ProjectEnvironmentTypeUpdate
 from ._models_py3 import ProjectEnvironmentTypeUpdateProperties
 from ._models_py3 import ProjectEnvironmentTypeUpdatePropertiesCreatorRoleAssignment
 from ._models_py3 import ProjectListResult
@@ -116,21 +117,20 @@
 from ._models_py3 import Usage
 from ._models_py3 import UsageName
 from ._models_py3 import UserAssignedIdentity
 from ._models_py3 import UserRoleAssignmentValue
 
 from ._dev_center_mgmt_client_enums import ActionType
 from ._dev_center_mgmt_client_enums import CatalogConnectionState
-from ._dev_center_mgmt_client_enums import CatalogItemSyncEnableStatus
-from ._dev_center_mgmt_client_enums import CatalogItemType
 from ._dev_center_mgmt_client_enums import CatalogResourceValidationStatus
 from ._dev_center_mgmt_client_enums import CatalogSyncState
 from ._dev_center_mgmt_client_enums import CatalogSyncType
 from ._dev_center_mgmt_client_enums import CheckNameAvailabilityReason
 from ._dev_center_mgmt_client_enums import CreatedByType
+from ._dev_center_mgmt_client_enums import CustomizationTaskInputType
 from ._dev_center_mgmt_client_enums import DomainJoinType
 from ._dev_center_mgmt_client_enums import EnvironmentTypeEnableStatus
 from ._dev_center_mgmt_client_enums import HealthCheckStatus
 from ._dev_center_mgmt_client_enums import HealthStatus
 from ._dev_center_mgmt_client_enums import HibernateSupport
 from ._dev_center_mgmt_client_enums import IdentityType
 from ._dev_center_mgmt_client_enums import ImageValidationStatus
@@ -165,25 +165,27 @@
     "CatalogProperties",
     "CatalogResourceValidationErrorDetails",
     "CatalogSyncError",
     "CatalogUpdate",
     "CatalogUpdateProperties",
     "CheckNameAvailabilityRequest",
     "CheckNameAvailabilityResponse",
-    "CheckScopedNameAvailabilityRequest",
+    "CloudErrorBody",
     "CustomerManagedKeyEncryption",
     "CustomerManagedKeyEncryptionKeyIdentity",
+    "CustomizationTask",
+    "CustomizationTaskInput",
+    "CustomizationTaskListResult",
     "DevBoxDefinition",
     "DevBoxDefinitionListResult",
     "DevBoxDefinitionProperties",
     "DevBoxDefinitionUpdate",
     "DevBoxDefinitionUpdateProperties",
     "DevCenter",
     "DevCenterListResult",
-    "DevCenterProjectCatalogSettings",
     "DevCenterProperties",
     "DevCenterSku",
     "DevCenterUpdate",
     "DevCenterUpdateProperties",
     "Encryption",
     "EndpointDependency",
     "EndpointDetail",
@@ -228,15 +230,14 @@
     "OutboundEnvironmentEndpointCollection",
     "Pool",
     "PoolListResult",
     "PoolProperties",
     "PoolUpdate",
     "PoolUpdateProperties",
     "Project",
-    "ProjectCatalogSettings",
     "ProjectEnvironmentType",
     "ProjectEnvironmentTypeListResult",
     "ProjectEnvironmentTypeProperties",
     "ProjectEnvironmentTypeUpdate",
     "ProjectEnvironmentTypeUpdateProperties",
     "ProjectEnvironmentTypeUpdatePropertiesCreatorRoleAssignment",
     "ProjectListResult",
@@ -262,21 +263,20 @@
     "TrackedResourceUpdate",
     "Usage",
     "UsageName",
     "UserAssignedIdentity",
     "UserRoleAssignmentValue",
     "ActionType",
     "CatalogConnectionState",
-    "CatalogItemSyncEnableStatus",
-    "CatalogItemType",
     "CatalogResourceValidationStatus",
     "CatalogSyncState",
     "CatalogSyncType",
     "CheckNameAvailabilityReason",
     "CreatedByType",
+    "CustomizationTaskInputType",
     "DomainJoinType",
     "EnvironmentTypeEnableStatus",
     "HealthCheckStatus",
     "HealthStatus",
     "HibernateSupport",
     "IdentityType",
     "ImageValidationStatus",
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/models/_dev_center_mgmt_client_enums.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/models/_dev_center_mgmt_client_enums.py`

 * *Files 2% similar despite different names*

```diff
@@ -19,29 +19,14 @@
 class CatalogConnectionState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The connection state of the catalog."""
 
     CONNECTED = "Connected"
     DISCONNECTED = "Disconnected"
 
 
-class CatalogItemSyncEnableStatus(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Catalog item sync types enable or disable status. Indicates whether project catalogs are
-    allowed to sync catalog items under projects associated to this dev center.
-    """
-
-    ENABLED = "Enabled"
-    DISABLED = "Disabled"
-
-
-class CatalogItemType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Indicates catalog item types."""
-
-    ENVIRONMENT_DEFINITION = "EnvironmentDefinition"
-
-
 class CatalogResourceValidationStatus(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Catalog resource validation status."""
 
     UNKNOWN = "Unknown"
     PENDING = "Pending"
     SUCCEEDED = "Succeeded"
     FAILED = "Failed"
@@ -75,14 +60,22 @@
 
     USER = "User"
     APPLICATION = "Application"
     MANAGED_IDENTITY = "ManagedIdentity"
     KEY = "Key"
 
 
+class CustomizationTaskInputType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """Type of the input."""
+
+    STRING = "string"
+    NUMBER = "number"
+    BOOLEAN = "boolean"
+
+
 class DomainJoinType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Active Directory join type."""
 
     HYBRID_AZURE_AD_JOIN = "HybridAzureADJoin"
     AZURE_AD_JOIN = "AzureADJoin"
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/models/_models_py3.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/models/_models_py3.py`

 * *Files 3% similar despite different names*

```diff
@@ -18,16 +18,16 @@
 
 
 class Resource(_serialization.Model):
     """Common fields that are returned in the response for all Azure Resource Manager resources.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".  # pylint: disable=line-too-long
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -59,16 +59,16 @@
 
 
 class AllowedEnvironmentType(Resource):
     """Represents an allowed environment type.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".  # pylint: disable=line-too-long
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -137,16 +137,16 @@
 
 
 class AttachedNetworkConnection(Resource):
     """Represents an attached NetworkConnection.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".  # pylint: disable=line-too-long
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -263,16 +263,16 @@
 
 
 class Catalog(Resource):  # pylint: disable=too-many-instance-attributes
     """Represents a catalog.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".  # pylint: disable=line-too-long
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -281,16 +281,14 @@
     :ivar git_hub: Properties for a GitHub catalog type.
     :vartype git_hub: ~azure.mgmt.devcenter.models.GitCatalog
     :ivar ado_git: Properties for an Azure DevOps catalog type.
     :vartype ado_git: ~azure.mgmt.devcenter.models.GitCatalog
     :ivar sync_type: Indicates the type of sync that is configured for the catalog. Known values
      are: "Manual" and "Scheduled".
     :vartype sync_type: str or ~azure.mgmt.devcenter.models.CatalogSyncType
-    :ivar tags: Resource tags.
-    :vartype tags: dict[str, str]
     :ivar provisioning_state: The provisioning state of the resource. Known values are:
      "NotSpecified", "Accepted", "Running", "Creating", "Created", "Updating", "Updated",
      "Deleting", "Deleted", "Succeeded", "Failed", "Canceled", "MovingResources",
      "TransientFailure", "RolloutInProgress", and "StorageProvisioningFailed".
     :vartype provisioning_state: str or ~azure.mgmt.devcenter.models.ProvisioningState
     :ivar sync_state: The synchronization state of the catalog. Known values are: "Succeeded",
      "InProgress", "Failed", and "Canceled".
@@ -323,48 +321,43 @@
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
         "git_hub": {"key": "properties.gitHub", "type": "GitCatalog"},
         "ado_git": {"key": "properties.adoGit", "type": "GitCatalog"},
         "sync_type": {"key": "properties.syncType", "type": "str"},
-        "tags": {"key": "properties.tags", "type": "{str}"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
         "sync_state": {"key": "properties.syncState", "type": "str"},
         "last_sync_stats": {"key": "properties.lastSyncStats", "type": "SyncStats"},
         "connection_state": {"key": "properties.connectionState", "type": "str"},
         "last_connection_time": {"key": "properties.lastConnectionTime", "type": "iso-8601"},
         "last_sync_time": {"key": "properties.lastSyncTime", "type": "iso-8601"},
     }
 
     def __init__(
         self,
         *,
         git_hub: Optional["_models.GitCatalog"] = None,
         ado_git: Optional["_models.GitCatalog"] = None,
         sync_type: Optional[Union[str, "_models.CatalogSyncType"]] = None,
-        tags: Optional[Dict[str, str]] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword git_hub: Properties for a GitHub catalog type.
         :paramtype git_hub: ~azure.mgmt.devcenter.models.GitCatalog
         :keyword ado_git: Properties for an Azure DevOps catalog type.
         :paramtype ado_git: ~azure.mgmt.devcenter.models.GitCatalog
         :keyword sync_type: Indicates the type of sync that is configured for the catalog. Known values
          are: "Manual" and "Scheduled".
         :paramtype sync_type: str or ~azure.mgmt.devcenter.models.CatalogSyncType
-        :keyword tags: Resource tags.
-        :paramtype tags: dict[str, str]
         """
         super().__init__(**kwargs)
         self.git_hub = git_hub
         self.ado_git = ado_git
         self.sync_type = sync_type
-        self.tags = tags
         self.provisioning_state = None
         self.sync_state = None
         self.last_sync_stats = None
         self.connection_state = None
         self.last_connection_time = None
         self.last_sync_time = None
 
@@ -457,66 +450,57 @@
     :ivar git_hub: Properties for a GitHub catalog type.
     :vartype git_hub: ~azure.mgmt.devcenter.models.GitCatalog
     :ivar ado_git: Properties for an Azure DevOps catalog type.
     :vartype ado_git: ~azure.mgmt.devcenter.models.GitCatalog
     :ivar sync_type: Indicates the type of sync that is configured for the catalog. Known values
      are: "Manual" and "Scheduled".
     :vartype sync_type: str or ~azure.mgmt.devcenter.models.CatalogSyncType
-    :ivar tags: Resource tags.
-    :vartype tags: dict[str, str]
     """
 
     _attribute_map = {
         "git_hub": {"key": "gitHub", "type": "GitCatalog"},
         "ado_git": {"key": "adoGit", "type": "GitCatalog"},
         "sync_type": {"key": "syncType", "type": "str"},
-        "tags": {"key": "tags", "type": "{str}"},
     }
 
     def __init__(
         self,
         *,
         git_hub: Optional["_models.GitCatalog"] = None,
         ado_git: Optional["_models.GitCatalog"] = None,
         sync_type: Optional[Union[str, "_models.CatalogSyncType"]] = None,
-        tags: Optional[Dict[str, str]] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword git_hub: Properties for a GitHub catalog type.
         :paramtype git_hub: ~azure.mgmt.devcenter.models.GitCatalog
         :keyword ado_git: Properties for an Azure DevOps catalog type.
         :paramtype ado_git: ~azure.mgmt.devcenter.models.GitCatalog
         :keyword sync_type: Indicates the type of sync that is configured for the catalog. Known values
          are: "Manual" and "Scheduled".
         :paramtype sync_type: str or ~azure.mgmt.devcenter.models.CatalogSyncType
-        :keyword tags: Resource tags.
-        :paramtype tags: dict[str, str]
         """
         super().__init__(**kwargs)
         self.git_hub = git_hub
         self.ado_git = ado_git
         self.sync_type = sync_type
-        self.tags = tags
 
 
 class CatalogProperties(CatalogUpdateProperties):
     """Properties of a catalog.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar git_hub: Properties for a GitHub catalog type.
     :vartype git_hub: ~azure.mgmt.devcenter.models.GitCatalog
     :ivar ado_git: Properties for an Azure DevOps catalog type.
     :vartype ado_git: ~azure.mgmt.devcenter.models.GitCatalog
     :ivar sync_type: Indicates the type of sync that is configured for the catalog. Known values
      are: "Manual" and "Scheduled".
     :vartype sync_type: str or ~azure.mgmt.devcenter.models.CatalogSyncType
-    :ivar tags: Resource tags.
-    :vartype tags: dict[str, str]
     :ivar provisioning_state: The provisioning state of the resource. Known values are:
      "NotSpecified", "Accepted", "Running", "Creating", "Created", "Updating", "Updated",
      "Deleting", "Deleted", "Succeeded", "Failed", "Canceled", "MovingResources",
      "TransientFailure", "RolloutInProgress", and "StorageProvisioningFailed".
     :vartype provisioning_state: str or ~azure.mgmt.devcenter.models.ProvisioningState
     :ivar sync_state: The synchronization state of the catalog. Known values are: "Succeeded",
      "InProgress", "Failed", and "Canceled".
@@ -541,44 +525,40 @@
         "last_sync_time": {"readonly": True},
     }
 
     _attribute_map = {
         "git_hub": {"key": "gitHub", "type": "GitCatalog"},
         "ado_git": {"key": "adoGit", "type": "GitCatalog"},
         "sync_type": {"key": "syncType", "type": "str"},
-        "tags": {"key": "tags", "type": "{str}"},
         "provisioning_state": {"key": "provisioningState", "type": "str"},
         "sync_state": {"key": "syncState", "type": "str"},
         "last_sync_stats": {"key": "lastSyncStats", "type": "SyncStats"},
         "connection_state": {"key": "connectionState", "type": "str"},
         "last_connection_time": {"key": "lastConnectionTime", "type": "iso-8601"},
         "last_sync_time": {"key": "lastSyncTime", "type": "iso-8601"},
     }
 
     def __init__(
         self,
         *,
         git_hub: Optional["_models.GitCatalog"] = None,
         ado_git: Optional["_models.GitCatalog"] = None,
         sync_type: Optional[Union[str, "_models.CatalogSyncType"]] = None,
-        tags: Optional[Dict[str, str]] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword git_hub: Properties for a GitHub catalog type.
         :paramtype git_hub: ~azure.mgmt.devcenter.models.GitCatalog
         :keyword ado_git: Properties for an Azure DevOps catalog type.
         :paramtype ado_git: ~azure.mgmt.devcenter.models.GitCatalog
         :keyword sync_type: Indicates the type of sync that is configured for the catalog. Known values
          are: "Manual" and "Scheduled".
         :paramtype sync_type: str or ~azure.mgmt.devcenter.models.CatalogSyncType
-        :keyword tags: Resource tags.
-        :paramtype tags: dict[str, str]
         """
-        super().__init__(git_hub=git_hub, ado_git=ado_git, sync_type=sync_type, tags=tags, **kwargs)
+        super().__init__(git_hub=git_hub, ado_git=ado_git, sync_type=sync_type, **kwargs)
         self.provisioning_state = None
         self.sync_state = None
         self.last_sync_stats = None
         self.connection_state = None
         self.last_connection_time = None
         self.last_sync_time = None
 
@@ -635,57 +615,57 @@
         self.error_details = None
 
 
 class CatalogUpdate(_serialization.Model):
     """The catalog's properties for partial update. Properties not provided in the update request will
     not be changed.
 
+    :ivar tags: Resource tags.
+    :vartype tags: dict[str, str]
     :ivar git_hub: Properties for a GitHub catalog type.
     :vartype git_hub: ~azure.mgmt.devcenter.models.GitCatalog
     :ivar ado_git: Properties for an Azure DevOps catalog type.
     :vartype ado_git: ~azure.mgmt.devcenter.models.GitCatalog
     :ivar sync_type: Indicates the type of sync that is configured for the catalog. Known values
      are: "Manual" and "Scheduled".
     :vartype sync_type: str or ~azure.mgmt.devcenter.models.CatalogSyncType
-    :ivar tags: Resource tags.
-    :vartype tags: dict[str, str]
     """
 
     _attribute_map = {
+        "tags": {"key": "tags", "type": "{str}"},
         "git_hub": {"key": "properties.gitHub", "type": "GitCatalog"},
         "ado_git": {"key": "properties.adoGit", "type": "GitCatalog"},
         "sync_type": {"key": "properties.syncType", "type": "str"},
-        "tags": {"key": "properties.tags", "type": "{str}"},
     }
 
     def __init__(
         self,
         *,
+        tags: Optional[Dict[str, str]] = None,
         git_hub: Optional["_models.GitCatalog"] = None,
         ado_git: Optional["_models.GitCatalog"] = None,
         sync_type: Optional[Union[str, "_models.CatalogSyncType"]] = None,
-        tags: Optional[Dict[str, str]] = None,
         **kwargs: Any
     ) -> None:
         """
+        :keyword tags: Resource tags.
+        :paramtype tags: dict[str, str]
         :keyword git_hub: Properties for a GitHub catalog type.
         :paramtype git_hub: ~azure.mgmt.devcenter.models.GitCatalog
         :keyword ado_git: Properties for an Azure DevOps catalog type.
         :paramtype ado_git: ~azure.mgmt.devcenter.models.GitCatalog
         :keyword sync_type: Indicates the type of sync that is configured for the catalog. Known values
          are: "Manual" and "Scheduled".
         :paramtype sync_type: str or ~azure.mgmt.devcenter.models.CatalogSyncType
-        :keyword tags: Resource tags.
-        :paramtype tags: dict[str, str]
         """
         super().__init__(**kwargs)
+        self.tags = tags
         self.git_hub = git_hub
         self.ado_git = ado_git
         self.sync_type = sync_type
-        self.tags = tags
 
 
 class CheckNameAvailabilityRequest(_serialization.Model):
     """The check availability request body.
 
     :ivar name: The name of the resource for which availability needs to be checked.
     :vartype name: str
@@ -747,46 +727,71 @@
         """
         super().__init__(**kwargs)
         self.name_available = name_available
         self.reason = reason
         self.message = message
 
 
-class CheckScopedNameAvailabilityRequest(_serialization.Model):
-    """The scoped name check availability request body.
+class CloudErrorBody(_serialization.Model):
+    """An error response from the DevCenter service.
 
-    :ivar name: The name of the resource for which availability needs to be checked.
-    :vartype name: str
-    :ivar type: The resource type.
-    :vartype type: str
-    :ivar scope: The resource id to scope the name check.
-    :vartype scope: str
+    All required parameters must be populated in order to send to Azure.
+
+    :ivar code: An identifier for the error. Codes are invariant and are intended to be consumed
+     programmatically. Required.
+    :vartype code: str
+    :ivar message: A message describing the error, intended to be suitable for display in a user
+     interface. Required.
+    :vartype message: str
+    :ivar target: The target of the particular error. For example, the name of the property in
+     error.
+    :vartype target: str
+    :ivar details: A list of additional details about the error.
+    :vartype details: list[~azure.mgmt.devcenter.models.CloudErrorBody]
     """
 
+    _validation = {
+        "code": {"required": True},
+        "message": {"required": True},
+    }
+
     _attribute_map = {
-        "name": {"key": "name", "type": "str"},
-        "type": {"key": "type", "type": "str"},
-        "scope": {"key": "scope", "type": "str"},
+        "code": {"key": "code", "type": "str"},
+        "message": {"key": "message", "type": "str"},
+        "target": {"key": "target", "type": "str"},
+        "details": {"key": "details", "type": "[CloudErrorBody]"},
     }
 
     def __init__(
-        self, *, name: Optional[str] = None, type: Optional[str] = None, scope: Optional[str] = None, **kwargs: Any
+        self,
+        *,
+        code: str,
+        message: str,
+        target: Optional[str] = None,
+        details: Optional[List["_models.CloudErrorBody"]] = None,
+        **kwargs: Any
     ) -> None:
         """
-        :keyword name: The name of the resource for which availability needs to be checked.
-        :paramtype name: str
-        :keyword type: The resource type.
-        :paramtype type: str
-        :keyword scope: The resource id to scope the name check.
-        :paramtype scope: str
+        :keyword code: An identifier for the error. Codes are invariant and are intended to be consumed
+         programmatically. Required.
+        :paramtype code: str
+        :keyword message: A message describing the error, intended to be suitable for display in a user
+         interface. Required.
+        :paramtype message: str
+        :keyword target: The target of the particular error. For example, the name of the property in
+         error.
+        :paramtype target: str
+        :keyword details: A list of additional details about the error.
+        :paramtype details: list[~azure.mgmt.devcenter.models.CloudErrorBody]
         """
         super().__init__(**kwargs)
-        self.name = name
-        self.type = type
-        self.scope = scope
+        self.code = code
+        self.message = message
+        self.target = target
+        self.details = details
 
 
 class CustomerManagedKeyEncryption(_serialization.Model):
     """All Customer-managed key encryption properties for the resource.
 
     :ivar key_encryption_key_identity: All identity configuration for Customer-managed key settings
      defining which identity should be used to auth to Key Vault.
@@ -881,24 +886,176 @@
         """
         super().__init__(**kwargs)
         self.identity_type = identity_type
         self.user_assigned_identity_resource_id = user_assigned_identity_resource_id
         self.delegated_identity_client_id = delegated_identity_client_id
 
 
+class ProxyResource(Resource):
+    """The resource model definition for a Azure Resource Manager proxy resource. It will not have
+    tags and a location.
+
+    Variables are only populated by the server, and will be ignored when sending a request.
+
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
+    :vartype id: str
+    :ivar name: The name of the resource.
+    :vartype name: str
+    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
+     "Microsoft.Storage/storageAccounts".
+    :vartype type: str
+    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
+     information.
+    :vartype system_data: ~azure.mgmt.devcenter.models.SystemData
+    """
+
+    _validation = {
+        "id": {"readonly": True},
+        "name": {"readonly": True},
+        "type": {"readonly": True},
+        "system_data": {"readonly": True},
+    }
+
+    _attribute_map = {
+        "id": {"key": "id", "type": "str"},
+        "name": {"key": "name", "type": "str"},
+        "type": {"key": "type", "type": "str"},
+        "system_data": {"key": "systemData", "type": "SystemData"},
+    }
+
+    def __init__(self, **kwargs: Any) -> None:
+        """ """
+        super().__init__(**kwargs)
+
+
+class CustomizationTask(ProxyResource):
+    """Represents a Task to be used in customizing a Dev Box.
+
+    Variables are only populated by the server, and will be ignored when sending a request.
+
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
+    :vartype id: str
+    :ivar name: The name of the resource.
+    :vartype name: str
+    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
+     "Microsoft.Storage/storageAccounts".
+    :vartype type: str
+    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
+     information.
+    :vartype system_data: ~azure.mgmt.devcenter.models.SystemData
+    :ivar inputs: Inputs to the task.
+    :vartype inputs: dict[str, ~azure.mgmt.devcenter.models.CustomizationTaskInput]
+    :ivar timeout: The default timeout for the task.
+    :vartype timeout: int
+    :ivar validation_status: Validation status for the Task. Known values are: "Unknown",
+     "Pending", "Succeeded", and "Failed".
+    :vartype validation_status: str or ~azure.mgmt.devcenter.models.CatalogResourceValidationStatus
+    """
+
+    _validation = {
+        "id": {"readonly": True},
+        "name": {"readonly": True},
+        "type": {"readonly": True},
+        "system_data": {"readonly": True},
+        "inputs": {"readonly": True},
+        "timeout": {"readonly": True},
+        "validation_status": {"readonly": True},
+    }
+
+    _attribute_map = {
+        "id": {"key": "id", "type": "str"},
+        "name": {"key": "name", "type": "str"},
+        "type": {"key": "type", "type": "str"},
+        "system_data": {"key": "systemData", "type": "SystemData"},
+        "inputs": {"key": "properties.inputs", "type": "{CustomizationTaskInput}"},
+        "timeout": {"key": "properties.timeout", "type": "int"},
+        "validation_status": {"key": "properties.validationStatus", "type": "str"},
+    }
+
+    def __init__(self, **kwargs: Any) -> None:
+        """ """
+        super().__init__(**kwargs)
+        self.inputs = None
+        self.timeout = None
+        self.validation_status = None
+
+
+class CustomizationTaskInput(_serialization.Model):
+    """Input for a Task.
+
+    Variables are only populated by the server, and will be ignored when sending a request.
+
+    :ivar description: Description of the input.
+    :vartype description: str
+    :ivar type: Type of the input. Known values are: "string", "number", and "boolean".
+    :vartype type: str or ~azure.mgmt.devcenter.models.CustomizationTaskInputType
+    :ivar required: Whether or not the input is required.
+    :vartype required: bool
+    """
+
+    _validation = {
+        "description": {"readonly": True},
+        "type": {"readonly": True},
+        "required": {"readonly": True},
+    }
+
+    _attribute_map = {
+        "description": {"key": "description", "type": "str"},
+        "type": {"key": "type", "type": "str"},
+        "required": {"key": "required", "type": "bool"},
+    }
+
+    def __init__(self, **kwargs: Any) -> None:
+        """ """
+        super().__init__(**kwargs)
+        self.description = None
+        self.type = None
+        self.required = None
+
+
+class CustomizationTaskListResult(_serialization.Model):
+    """Results of the Task list operation.
+
+    Variables are only populated by the server, and will be ignored when sending a request.
+
+    :ivar value: Current page of results.
+    :vartype value: list[~azure.mgmt.devcenter.models.CustomizationTask]
+    :ivar next_link: URL to get the next set of results if there are any.
+    :vartype next_link: str
+    """
+
+    _validation = {
+        "value": {"readonly": True},
+        "next_link": {"readonly": True},
+    }
+
+    _attribute_map = {
+        "value": {"key": "value", "type": "[CustomizationTask]"},
+        "next_link": {"key": "nextLink", "type": "str"},
+    }
+
+    def __init__(self, **kwargs: Any) -> None:
+        """ """
+        super().__init__(**kwargs)
+        self.value = None
+        self.next_link = None
+
+
 class TrackedResource(Resource):
     """The resource model definition for an Azure Resource Manager tracked top level resource which
     has 'tags' and a 'location'.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to server.
+    All required parameters must be populated in order to send to Azure.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".  # pylint: disable=line-too-long
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -940,18 +1097,18 @@
 
 
 class DevBoxDefinition(TrackedResource):  # pylint: disable=too-many-instance-attributes
     """Represents a definition for a Developer Machine.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to server.
+    All required parameters must be populated in order to send to Azure.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".  # pylint: disable=line-too-long
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -1330,18 +1487,18 @@
 
 
 class DevCenter(TrackedResource):  # pylint: disable=too-many-instance-attributes
     """Represents a devcenter resource.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to server.
+    All required parameters must be populated in order to send to Azure.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".  # pylint: disable=line-too-long
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -1354,17 +1511,14 @@
     :ivar identity: Managed identity properties.
     :vartype identity: ~azure.mgmt.devcenter.models.ManagedServiceIdentity
     :ivar encryption: Encryption settings to be used for server-side encryption for proprietary
      content (such as catalogs, logs, customizations).
     :vartype encryption: ~azure.mgmt.devcenter.models.Encryption
     :ivar display_name: The display name of the devcenter.
     :vartype display_name: str
-    :ivar project_catalog_settings: Dev Center settings to be used when associating a project with
-     a catalog.
-    :vartype project_catalog_settings: ~azure.mgmt.devcenter.models.DevCenterProjectCatalogSettings
     :ivar provisioning_state: The provisioning state of the resource. Known values are:
      "NotSpecified", "Accepted", "Running", "Creating", "Created", "Updating", "Updated",
      "Deleting", "Deleted", "Succeeded", "Failed", "Canceled", "MovingResources",
      "TransientFailure", "RolloutInProgress", and "StorageProvisioningFailed".
     :vartype provisioning_state: str or ~azure.mgmt.devcenter.models.ProvisioningState
     :ivar dev_center_uri: The URI of the Dev Center.
     :vartype dev_center_uri: str
@@ -1386,55 +1540,45 @@
         "type": {"key": "type", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
         "tags": {"key": "tags", "type": "{str}"},
         "location": {"key": "location", "type": "str"},
         "identity": {"key": "identity", "type": "ManagedServiceIdentity"},
         "encryption": {"key": "properties.encryption", "type": "Encryption"},
         "display_name": {"key": "properties.displayName", "type": "str"},
-        "project_catalog_settings": {
-            "key": "properties.projectCatalogSettings",
-            "type": "DevCenterProjectCatalogSettings",
-        },
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
         "dev_center_uri": {"key": "properties.devCenterUri", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         location: str,
         tags: Optional[Dict[str, str]] = None,
         identity: Optional["_models.ManagedServiceIdentity"] = None,
         encryption: Optional["_models.Encryption"] = None,
         display_name: Optional[str] = None,
-        project_catalog_settings: Optional["_models.DevCenterProjectCatalogSettings"] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: The geo-location where the resource lives. Required.
         :paramtype location: str
         :keyword identity: Managed identity properties.
         :paramtype identity: ~azure.mgmt.devcenter.models.ManagedServiceIdentity
         :keyword encryption: Encryption settings to be used for server-side encryption for proprietary
          content (such as catalogs, logs, customizations).
         :paramtype encryption: ~azure.mgmt.devcenter.models.Encryption
         :keyword display_name: The display name of the devcenter.
         :paramtype display_name: str
-        :keyword project_catalog_settings: Dev Center settings to be used when associating a project
-         with a catalog.
-        :paramtype project_catalog_settings:
-         ~azure.mgmt.devcenter.models.DevCenterProjectCatalogSettings
         """
         super().__init__(tags=tags, location=location, **kwargs)
         self.identity = identity
         self.encryption = encryption
         self.display_name = display_name
-        self.project_catalog_settings = project_catalog_settings
         self.provisioning_state = None
         self.dev_center_uri = None
 
 
 class DevCenterListResult(_serialization.Model):
     """Result of the list devcenters operation.
 
@@ -1459,103 +1603,55 @@
     def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
-class DevCenterProjectCatalogSettings(_serialization.Model):
-    """Project catalog settings for project catalogs under a project associated to this dev center.
-
-    :ivar catalog_item_sync_enable_status: Whether project catalogs associated with projects in
-     this dev center can be configured to sync catalog items. Known values are: "Enabled" and
-     "Disabled".
-    :vartype catalog_item_sync_enable_status: str or
-     ~azure.mgmt.devcenter.models.CatalogItemSyncEnableStatus
-    """
-
-    _attribute_map = {
-        "catalog_item_sync_enable_status": {"key": "catalogItemSyncEnableStatus", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        catalog_item_sync_enable_status: Optional[Union[str, "_models.CatalogItemSyncEnableStatus"]] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword catalog_item_sync_enable_status: Whether project catalogs associated with projects in
-         this dev center can be configured to sync catalog items. Known values are: "Enabled" and
-         "Disabled".
-        :paramtype catalog_item_sync_enable_status: str or
-         ~azure.mgmt.devcenter.models.CatalogItemSyncEnableStatus
-        """
-        super().__init__(**kwargs)
-        self.catalog_item_sync_enable_status = catalog_item_sync_enable_status
-
-
 class DevCenterUpdateProperties(_serialization.Model):
     """Properties of the devcenter. These properties can be updated after the resource has been
     created.
 
     :ivar encryption: Encryption settings to be used for server-side encryption for proprietary
      content (such as catalogs, logs, customizations).
     :vartype encryption: ~azure.mgmt.devcenter.models.Encryption
     :ivar display_name: The display name of the devcenter.
     :vartype display_name: str
-    :ivar project_catalog_settings: Dev Center settings to be used when associating a project with
-     a catalog.
-    :vartype project_catalog_settings: ~azure.mgmt.devcenter.models.DevCenterProjectCatalogSettings
     """
 
     _attribute_map = {
         "encryption": {"key": "encryption", "type": "Encryption"},
         "display_name": {"key": "displayName", "type": "str"},
-        "project_catalog_settings": {"key": "projectCatalogSettings", "type": "DevCenterProjectCatalogSettings"},
     }
 
     def __init__(
-        self,
-        *,
-        encryption: Optional["_models.Encryption"] = None,
-        display_name: Optional[str] = None,
-        project_catalog_settings: Optional["_models.DevCenterProjectCatalogSettings"] = None,
-        **kwargs: Any
+        self, *, encryption: Optional["_models.Encryption"] = None, display_name: Optional[str] = None, **kwargs: Any
     ) -> None:
         """
         :keyword encryption: Encryption settings to be used for server-side encryption for proprietary
          content (such as catalogs, logs, customizations).
         :paramtype encryption: ~azure.mgmt.devcenter.models.Encryption
         :keyword display_name: The display name of the devcenter.
         :paramtype display_name: str
-        :keyword project_catalog_settings: Dev Center settings to be used when associating a project
-         with a catalog.
-        :paramtype project_catalog_settings:
-         ~azure.mgmt.devcenter.models.DevCenterProjectCatalogSettings
         """
         super().__init__(**kwargs)
         self.encryption = encryption
         self.display_name = display_name
-        self.project_catalog_settings = project_catalog_settings
 
 
 class DevCenterProperties(DevCenterUpdateProperties):
     """Properties of the devcenter.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar encryption: Encryption settings to be used for server-side encryption for proprietary
      content (such as catalogs, logs, customizations).
     :vartype encryption: ~azure.mgmt.devcenter.models.Encryption
     :ivar display_name: The display name of the devcenter.
     :vartype display_name: str
-    :ivar project_catalog_settings: Dev Center settings to be used when associating a project with
-     a catalog.
-    :vartype project_catalog_settings: ~azure.mgmt.devcenter.models.DevCenterProjectCatalogSettings
     :ivar provisioning_state: The provisioning state of the resource. Known values are:
      "NotSpecified", "Accepted", "Running", "Creating", "Created", "Updating", "Updated",
      "Deleting", "Deleted", "Succeeded", "Failed", "Canceled", "MovingResources",
      "TransientFailure", "RolloutInProgress", and "StorageProvisioningFailed".
     :vartype provisioning_state: str or ~azure.mgmt.devcenter.models.ProvisioningState
     :ivar dev_center_uri: The URI of the Dev Center.
     :vartype dev_center_uri: str
@@ -1565,52 +1661,37 @@
         "provisioning_state": {"readonly": True},
         "dev_center_uri": {"readonly": True},
     }
 
     _attribute_map = {
         "encryption": {"key": "encryption", "type": "Encryption"},
         "display_name": {"key": "displayName", "type": "str"},
-        "project_catalog_settings": {"key": "projectCatalogSettings", "type": "DevCenterProjectCatalogSettings"},
         "provisioning_state": {"key": "provisioningState", "type": "str"},
         "dev_center_uri": {"key": "devCenterUri", "type": "str"},
     }
 
     def __init__(
-        self,
-        *,
-        encryption: Optional["_models.Encryption"] = None,
-        display_name: Optional[str] = None,
-        project_catalog_settings: Optional["_models.DevCenterProjectCatalogSettings"] = None,
-        **kwargs: Any
+        self, *, encryption: Optional["_models.Encryption"] = None, display_name: Optional[str] = None, **kwargs: Any
     ) -> None:
         """
         :keyword encryption: Encryption settings to be used for server-side encryption for proprietary
          content (such as catalogs, logs, customizations).
         :paramtype encryption: ~azure.mgmt.devcenter.models.Encryption
         :keyword display_name: The display name of the devcenter.
         :paramtype display_name: str
-        :keyword project_catalog_settings: Dev Center settings to be used when associating a project
-         with a catalog.
-        :paramtype project_catalog_settings:
-         ~azure.mgmt.devcenter.models.DevCenterProjectCatalogSettings
         """
-        super().__init__(
-            encryption=encryption,
-            display_name=display_name,
-            project_catalog_settings=project_catalog_settings,
-            **kwargs
-        )
+        super().__init__(encryption=encryption, display_name=display_name, **kwargs)
         self.provisioning_state = None
         self.dev_center_uri = None
 
 
 class Sku(_serialization.Model):
     """The resource model definition representing SKU.
 
-    All required parameters must be populated in order to send to server.
+    All required parameters must be populated in order to send to Azure.
 
     :ivar name: The name of the SKU. Ex - P3. It is typically a letter+number code. Required.
     :vartype name: str
     :ivar tier: This field is required to be implemented by the Resource Provider if the service
      has more than one tier, but is not required on a PUT. Known values are: "Free", "Basic",
      "Standard", and "Premium".
     :vartype tier: str or ~azure.mgmt.devcenter.models.SkuTier
@@ -1673,15 +1754,15 @@
 
 
 class DevCenterSku(Sku):
     """The resource model definition representing SKU for DevCenter resources.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to server.
+    All required parameters must be populated in order to send to Azure.
 
     :ivar name: The name of the SKU. Ex - P3. It is typically a letter+number code. Required.
     :vartype name: str
     :ivar tier: This field is required to be implemented by the Resource Provider if the service
      has more than one tier, but is not required on a PUT. Known values are: "Free", "Basic",
      "Standard", and "Premium".
     :vartype tier: str or ~azure.mgmt.devcenter.models.SkuTier
@@ -1764,64 +1845,51 @@
     :ivar identity: Managed identity properties.
     :vartype identity: ~azure.mgmt.devcenter.models.ManagedServiceIdentity
     :ivar encryption: Encryption settings to be used for server-side encryption for proprietary
      content (such as catalogs, logs, customizations).
     :vartype encryption: ~azure.mgmt.devcenter.models.Encryption
     :ivar display_name: The display name of the devcenter.
     :vartype display_name: str
-    :ivar project_catalog_settings: Dev Center settings to be used when associating a project with
-     a catalog.
-    :vartype project_catalog_settings: ~azure.mgmt.devcenter.models.DevCenterProjectCatalogSettings
     """
 
     _attribute_map = {
         "tags": {"key": "tags", "type": "{str}"},
         "location": {"key": "location", "type": "str"},
         "identity": {"key": "identity", "type": "ManagedServiceIdentity"},
         "encryption": {"key": "properties.encryption", "type": "Encryption"},
         "display_name": {"key": "properties.displayName", "type": "str"},
-        "project_catalog_settings": {
-            "key": "properties.projectCatalogSettings",
-            "type": "DevCenterProjectCatalogSettings",
-        },
     }
 
     def __init__(
         self,
         *,
         tags: Optional[Dict[str, str]] = None,
         location: Optional[str] = None,
         identity: Optional["_models.ManagedServiceIdentity"] = None,
         encryption: Optional["_models.Encryption"] = None,
         display_name: Optional[str] = None,
-        project_catalog_settings: Optional["_models.DevCenterProjectCatalogSettings"] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: The geo-location where the resource lives.
         :paramtype location: str
         :keyword identity: Managed identity properties.
         :paramtype identity: ~azure.mgmt.devcenter.models.ManagedServiceIdentity
         :keyword encryption: Encryption settings to be used for server-side encryption for proprietary
          content (such as catalogs, logs, customizations).
         :paramtype encryption: ~azure.mgmt.devcenter.models.Encryption
         :keyword display_name: The display name of the devcenter.
         :paramtype display_name: str
-        :keyword project_catalog_settings: Dev Center settings to be used when associating a project
-         with a catalog.
-        :paramtype project_catalog_settings:
-         ~azure.mgmt.devcenter.models.DevCenterProjectCatalogSettings
         """
         super().__init__(tags=tags, location=location, **kwargs)
         self.identity = identity
         self.encryption = encryption
         self.display_name = display_name
-        self.project_catalog_settings = project_catalog_settings
 
 
 class Encryption(_serialization.Model):
     """Encryption.
 
     :ivar customer_managed_key_encryption: All Customer-managed key encryption properties for the
      resource.
@@ -1903,41 +1971,21 @@
 
     def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.port = None
 
 
-class ProxyResource(Resource):
-    """The resource model definition for a Azure Resource Manager proxy resource. It will not have
-    tags and a location.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".  # pylint: disable=line-too-long
-    :vartype id: str
-    :ivar name: The name of the resource.
-    :vartype name: str
-    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
-     "Microsoft.Storage/storageAccounts".
-    :vartype type: str
-    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
-     information.
-    :vartype system_data: ~azure.mgmt.devcenter.models.SystemData
-    """
-
-
 class EnvironmentDefinition(ProxyResource):
     """Represents an environment definition catalog item.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".  # pylint: disable=line-too-long
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -2093,16 +2141,16 @@
 
 
 class EnvironmentType(Resource):
     """Represents an environment type.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".  # pylint: disable=line-too-long
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -2355,16 +2403,16 @@
 
 
 class Gallery(Resource):
     """Represents a gallery.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".  # pylint: disable=line-too-long
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -2537,16 +2585,16 @@
 
 
 class HealthCheckStatusDetails(Resource):
     """Health Check details.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".  # pylint: disable=line-too-long
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -2646,16 +2694,16 @@
 
 
 class Image(ProxyResource):  # pylint: disable=too-many-instance-attributes
     """Represents an image.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".  # pylint: disable=line-too-long
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -2815,16 +2863,16 @@
 
 
 class ImageVersion(ProxyResource):
     """Represents an image version.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".  # pylint: disable=line-too-long
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -2937,29 +2985,29 @@
 
 
 class ManagedServiceIdentity(_serialization.Model):
     """Managed service identity (system assigned and/or user assigned identities).
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to server.
+    All required parameters must be populated in order to send to Azure.
 
     :ivar principal_id: The service principal ID of the system assigned identity. This property
      will only be provided for a system assigned identity.
     :vartype principal_id: str
     :ivar tenant_id: The tenant ID of the system assigned identity. This property will only be
      provided for a system assigned identity.
     :vartype tenant_id: str
     :ivar type: Type of managed service identity (where both SystemAssigned and UserAssigned types
      are allowed). Required. Known values are: "None", "SystemAssigned", "UserAssigned", and
      "SystemAssigned, UserAssigned".
     :vartype type: str or ~azure.mgmt.devcenter.models.ManagedServiceIdentityType
     :ivar user_assigned_identities: The set of user assigned identities associated with the
      resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form:
-     '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}.  # pylint: disable=line-too-long
+     '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}.
      The dictionary values can be empty objects ({}) in requests.
     :vartype user_assigned_identities: dict[str, ~azure.mgmt.devcenter.models.UserAssignedIdentity]
     """
 
     _validation = {
         "principal_id": {"readonly": True},
         "tenant_id": {"readonly": True},
@@ -2983,15 +3031,15 @@
         """
         :keyword type: Type of managed service identity (where both SystemAssigned and UserAssigned
          types are allowed). Required. Known values are: "None", "SystemAssigned", "UserAssigned", and
          "SystemAssigned, UserAssigned".
         :paramtype type: str or ~azure.mgmt.devcenter.models.ManagedServiceIdentityType
         :keyword user_assigned_identities: The set of user assigned identities associated with the
          resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form:
-         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}.  # pylint: disable=line-too-long
+         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}.
          The dictionary values can be empty objects ({}) in requests.
         :paramtype user_assigned_identities: dict[str,
          ~azure.mgmt.devcenter.models.UserAssignedIdentity]
         """
         super().__init__(**kwargs)
         self.principal_id = None
         self.tenant_id = None
@@ -3000,18 +3048,18 @@
 
 
 class NetworkConnection(TrackedResource):  # pylint: disable=too-many-instance-attributes
     """Network related settings.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to server.
+    All required parameters must be populated in order to send to Azure.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".  # pylint: disable=line-too-long
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -3282,15 +3330,15 @@
 
 
 class NetworkProperties(NetworkConnectionUpdateProperties):
     """Network properties.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to server.
+    All required parameters must be populated in order to send to Azure.
 
     :ivar subnet_id: The subnet to attach Virtual Machines to.
     :vartype subnet_id: str
     :ivar domain_name: Active Directory domain name.
     :vartype domain_name: str
     :ivar organization_unit: Active Directory domain Organization Unit (OU).
     :vartype organization_unit: str
@@ -3499,23 +3547,18 @@
         self.value = None
         self.next_link = None
 
 
 class OperationStatusResult(_serialization.Model):
     """The current status of an async operation.
 
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    All required parameters must be populated in order to send to server.
+    All required parameters must be populated in order to send to Azure.
 
     :ivar id: Fully qualified ID for the async operation.
     :vartype id: str
-    :ivar resource_id: Fully qualified ID of the resource against which the original async
-     operation was started.
-    :vartype resource_id: str
     :ivar name: Name of the async operation.
     :vartype name: str
     :ivar status: Operation status. Required.
     :vartype status: str
     :ivar percent_complete: Percent of the operation that is complete.
     :vartype percent_complete: float
     :ivar start_time: The start time of the operation.
@@ -3525,22 +3568,20 @@
     :ivar operations: The operations list.
     :vartype operations: list[~azure.mgmt.devcenter.models.OperationStatusResult]
     :ivar error: If present, details of the operation error.
     :vartype error: ~azure.mgmt.devcenter.models.ErrorDetail
     """
 
     _validation = {
-        "resource_id": {"readonly": True},
         "status": {"required": True},
         "percent_complete": {"maximum": 100, "minimum": 0},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
-        "resource_id": {"key": "resourceId", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "status": {"key": "status", "type": "str"},
         "percent_complete": {"key": "percentComplete", "type": "float"},
         "start_time": {"key": "startTime", "type": "iso-8601"},
         "end_time": {"key": "endTime", "type": "iso-8601"},
         "operations": {"key": "operations", "type": "[OperationStatusResult]"},
         "error": {"key": "error", "type": "ErrorDetail"},
@@ -3575,71 +3616,69 @@
         :keyword operations: The operations list.
         :paramtype operations: list[~azure.mgmt.devcenter.models.OperationStatusResult]
         :keyword error: If present, details of the operation error.
         :paramtype error: ~azure.mgmt.devcenter.models.ErrorDetail
         """
         super().__init__(**kwargs)
         self.id = id
-        self.resource_id = None
         self.name = name
         self.status = status
         self.percent_complete = percent_complete
         self.start_time = start_time
         self.end_time = end_time
         self.operations = operations
         self.error = error
 
 
 class OperationStatus(OperationStatusResult):
     """The current status of an async operation.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to server.
+    All required parameters must be populated in order to send to Azure.
 
     :ivar id: Fully qualified ID for the async operation.
     :vartype id: str
-    :ivar resource_id: Fully qualified ID of the resource against which the original async
-     operation was started.
-    :vartype resource_id: str
     :ivar name: Name of the async operation.
     :vartype name: str
     :ivar status: Operation status. Required.
     :vartype status: str
     :ivar percent_complete: Percent of the operation that is complete.
     :vartype percent_complete: float
     :ivar start_time: The start time of the operation.
     :vartype start_time: ~datetime.datetime
     :ivar end_time: The end time of the operation.
     :vartype end_time: ~datetime.datetime
     :ivar operations: The operations list.
     :vartype operations: list[~azure.mgmt.devcenter.models.OperationStatusResult]
     :ivar error: If present, details of the operation error.
     :vartype error: ~azure.mgmt.devcenter.models.ErrorDetail
+    :ivar resource_id: The id of the resource.
+    :vartype resource_id: str
     :ivar properties: Custom operation properties, populated only for a successful operation.
     :vartype properties: JSON
     """
 
     _validation = {
-        "resource_id": {"readonly": True},
         "status": {"required": True},
         "percent_complete": {"maximum": 100, "minimum": 0},
+        "resource_id": {"readonly": True},
         "properties": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
-        "resource_id": {"key": "resourceId", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "status": {"key": "status", "type": "str"},
         "percent_complete": {"key": "percentComplete", "type": "float"},
         "start_time": {"key": "startTime", "type": "iso-8601"},
         "end_time": {"key": "endTime", "type": "iso-8601"},
         "operations": {"key": "operations", "type": "[OperationStatusResult]"},
         "error": {"key": "error", "type": "ErrorDetail"},
+        "resource_id": {"key": "resourceId", "type": "str"},
         "properties": {"key": "properties", "type": "object"},
     }
 
     def __init__(
         self,
         *,
         status: str,
@@ -3677,14 +3716,15 @@
             percent_complete=percent_complete,
             start_time=start_time,
             end_time=end_time,
             operations=operations,
             error=error,
             **kwargs
         )
+        self.resource_id = None
         self.properties = None
 
 
 class OutboundEnvironmentEndpoint(_serialization.Model):
     """A collection of related endpoints from the same service for which the agent requires outbound
     access.
 
@@ -3745,18 +3785,18 @@
 
 
 class Pool(TrackedResource):  # pylint: disable=too-many-instance-attributes
     """A pool of Virtual Machines.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to server.
+    All required parameters must be populated in order to send to Azure.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".  # pylint: disable=line-too-long
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -4264,45 +4304,41 @@
 
 
 class Project(TrackedResource):  # pylint: disable=too-many-instance-attributes
     """Represents a project resource.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to server.
+    All required parameters must be populated in order to send to Azure.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".  # pylint: disable=line-too-long
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
      information.
     :vartype system_data: ~azure.mgmt.devcenter.models.SystemData
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
     :ivar location: The geo-location where the resource lives. Required.
     :vartype location: str
-    :ivar identity: Managed identity properties.
-    :vartype identity: ~azure.mgmt.devcenter.models.ManagedServiceIdentity
     :ivar dev_center_id: Resource Id of an associated DevCenter.
     :vartype dev_center_id: str
     :ivar description: Description of the project.
     :vartype description: str
     :ivar max_dev_boxes_per_user: When specified, limits the maximum number of Dev Boxes a single
      user can create across all pools in the project. This will have no effect on existing Dev Boxes
      when reduced.
     :vartype max_dev_boxes_per_user: int
     :ivar display_name: The display name of the project.
     :vartype display_name: str
-    :ivar catalog_settings: Settings to be used when associating a project with a catalog.
-    :vartype catalog_settings: ~azure.mgmt.devcenter.models.ProjectCatalogSettings
     :ivar provisioning_state: The provisioning state of the resource. Known values are:
      "NotSpecified", "Accepted", "Running", "Creating", "Created", "Updating", "Updated",
      "Deleting", "Deleted", "Succeeded", "Failed", "Canceled", "MovingResources",
      "TransientFailure", "RolloutInProgress", and "StorageProvisioningFailed".
     :vartype provisioning_state: str or ~azure.mgmt.devcenter.models.ProvisioningState
     :ivar dev_center_uri: The URI of the Dev Center resource this project is associated with.
     :vartype dev_center_uri: str
@@ -4322,97 +4358,65 @@
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
         "tags": {"key": "tags", "type": "{str}"},
         "location": {"key": "location", "type": "str"},
-        "identity": {"key": "identity", "type": "ManagedServiceIdentity"},
         "dev_center_id": {"key": "properties.devCenterId", "type": "str"},
         "description": {"key": "properties.description", "type": "str"},
         "max_dev_boxes_per_user": {"key": "properties.maxDevBoxesPerUser", "type": "int"},
         "display_name": {"key": "properties.displayName", "type": "str"},
-        "catalog_settings": {"key": "properties.catalogSettings", "type": "ProjectCatalogSettings"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
         "dev_center_uri": {"key": "properties.devCenterUri", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         location: str,
         tags: Optional[Dict[str, str]] = None,
-        identity: Optional["_models.ManagedServiceIdentity"] = None,
         dev_center_id: Optional[str] = None,
         description: Optional[str] = None,
         max_dev_boxes_per_user: Optional[int] = None,
         display_name: Optional[str] = None,
-        catalog_settings: Optional["_models.ProjectCatalogSettings"] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: The geo-location where the resource lives. Required.
         :paramtype location: str
-        :keyword identity: Managed identity properties.
-        :paramtype identity: ~azure.mgmt.devcenter.models.ManagedServiceIdentity
         :keyword dev_center_id: Resource Id of an associated DevCenter.
         :paramtype dev_center_id: str
         :keyword description: Description of the project.
         :paramtype description: str
         :keyword max_dev_boxes_per_user: When specified, limits the maximum number of Dev Boxes a
          single user can create across all pools in the project. This will have no effect on existing
          Dev Boxes when reduced.
         :paramtype max_dev_boxes_per_user: int
         :keyword display_name: The display name of the project.
         :paramtype display_name: str
-        :keyword catalog_settings: Settings to be used when associating a project with a catalog.
-        :paramtype catalog_settings: ~azure.mgmt.devcenter.models.ProjectCatalogSettings
         """
         super().__init__(tags=tags, location=location, **kwargs)
-        self.identity = identity
         self.dev_center_id = dev_center_id
         self.description = description
         self.max_dev_boxes_per_user = max_dev_boxes_per_user
         self.display_name = display_name
-        self.catalog_settings = catalog_settings
         self.provisioning_state = None
         self.dev_center_uri = None
 
 
-class ProjectCatalogSettings(_serialization.Model):
-    """Settings to be used when associating a project with a catalog.
-
-    :ivar catalog_item_sync_types: Indicates catalog item types that can be synced.
-    :vartype catalog_item_sync_types: list[str or ~azure.mgmt.devcenter.models.CatalogItemType]
-    """
-
-    _attribute_map = {
-        "catalog_item_sync_types": {"key": "catalogItemSyncTypes", "type": "[str]"},
-    }
-
-    def __init__(
-        self, *, catalog_item_sync_types: Optional[List[Union[str, "_models.CatalogItemType"]]] = None, **kwargs: Any
-    ) -> None:
-        """
-        :keyword catalog_item_sync_types: Indicates catalog item types that can be synced.
-        :paramtype catalog_item_sync_types: list[str or ~azure.mgmt.devcenter.models.CatalogItemType]
-        """
-        super().__init__(**kwargs)
-        self.catalog_item_sync_types = catalog_item_sync_types
-
-
 class ProjectEnvironmentType(Resource):  # pylint: disable=too-many-instance-attributes
     """Represents an environment type.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".  # pylint: disable=line-too-long
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -4423,16 +4427,14 @@
     :ivar identity: Managed identity properties.
     :vartype identity: ~azure.mgmt.devcenter.models.ManagedServiceIdentity
     :ivar location: The geo-location for the environment type.
     :vartype location: str
     :ivar deployment_target_id: Id of a subscription that the environment type will be mapped to.
      The environment's resources will be deployed into this subscription.
     :vartype deployment_target_id: str
-    :ivar display_name: The display name of the project environment type.
-    :vartype display_name: str
     :ivar status: Defines whether this Environment Type can be used in this Project. Known values
      are: "Enabled" and "Disabled".
     :vartype status: str or ~azure.mgmt.devcenter.models.EnvironmentTypeEnableStatus
     :ivar creator_role_assignment: The role definition assigned to the environment creator on
      backing resources.
     :vartype creator_role_assignment:
      ~azure.mgmt.devcenter.models.ProjectEnvironmentTypeUpdatePropertiesCreatorRoleAssignment
@@ -4440,14 +4442,16 @@
      a mapping from a user object ID to an object of role definition IDs.
     :vartype user_role_assignments: dict[str, ~azure.mgmt.devcenter.models.UserRoleAssignmentValue]
     :ivar provisioning_state: The provisioning state of the resource. Known values are:
      "NotSpecified", "Accepted", "Running", "Creating", "Created", "Updating", "Updated",
      "Deleting", "Deleted", "Succeeded", "Failed", "Canceled", "MovingResources",
      "TransientFailure", "RolloutInProgress", and "StorageProvisioningFailed".
     :vartype provisioning_state: str or ~azure.mgmt.devcenter.models.ProvisioningState
+    :ivar display_name: The display name of the project environment type.
+    :vartype display_name: str
     :ivar environment_count: The number of environments of this type.
     :vartype environment_count: int
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
@@ -4462,72 +4466,72 @@
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
         "tags": {"key": "tags", "type": "{str}"},
         "identity": {"key": "identity", "type": "ManagedServiceIdentity"},
         "location": {"key": "location", "type": "str"},
         "deployment_target_id": {"key": "properties.deploymentTargetId", "type": "str"},
-        "display_name": {"key": "properties.displayName", "type": "str"},
         "status": {"key": "properties.status", "type": "str"},
         "creator_role_assignment": {
             "key": "properties.creatorRoleAssignment",
             "type": "ProjectEnvironmentTypeUpdatePropertiesCreatorRoleAssignment",
         },
         "user_role_assignments": {"key": "properties.userRoleAssignments", "type": "{UserRoleAssignmentValue}"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
+        "display_name": {"key": "properties.displayName", "type": "str"},
         "environment_count": {"key": "properties.environmentCount", "type": "int"},
     }
 
     def __init__(
         self,
         *,
         tags: Optional[Dict[str, str]] = None,
         identity: Optional["_models.ManagedServiceIdentity"] = None,
         location: Optional[str] = None,
         deployment_target_id: Optional[str] = None,
-        display_name: Optional[str] = None,
         status: Optional[Union[str, "_models.EnvironmentTypeEnableStatus"]] = None,
         creator_role_assignment: Optional["_models.ProjectEnvironmentTypeUpdatePropertiesCreatorRoleAssignment"] = None,
         user_role_assignments: Optional[Dict[str, "_models.UserRoleAssignmentValue"]] = None,
+        display_name: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword identity: Managed identity properties.
         :paramtype identity: ~azure.mgmt.devcenter.models.ManagedServiceIdentity
         :keyword location: The geo-location for the environment type.
         :paramtype location: str
         :keyword deployment_target_id: Id of a subscription that the environment type will be mapped
          to. The environment's resources will be deployed into this subscription.
         :paramtype deployment_target_id: str
-        :keyword display_name: The display name of the project environment type.
-        :paramtype display_name: str
         :keyword status: Defines whether this Environment Type can be used in this Project. Known
          values are: "Enabled" and "Disabled".
         :paramtype status: str or ~azure.mgmt.devcenter.models.EnvironmentTypeEnableStatus
         :keyword creator_role_assignment: The role definition assigned to the environment creator on
          backing resources.
         :paramtype creator_role_assignment:
          ~azure.mgmt.devcenter.models.ProjectEnvironmentTypeUpdatePropertiesCreatorRoleAssignment
         :keyword user_role_assignments: Role Assignments created on environment backing resources. This
          is a mapping from a user object ID to an object of role definition IDs.
         :paramtype user_role_assignments: dict[str,
          ~azure.mgmt.devcenter.models.UserRoleAssignmentValue]
+        :keyword display_name: The display name of the project environment type.
+        :paramtype display_name: str
         """
         super().__init__(**kwargs)
         self.tags = tags
         self.identity = identity
         self.location = location
         self.deployment_target_id = deployment_target_id
-        self.display_name = display_name
         self.status = status
         self.creator_role_assignment = creator_role_assignment
         self.user_role_assignments = user_role_assignments
         self.provisioning_state = None
+        self.display_name = display_name
         self.environment_count = None
 
 
 class ProjectEnvironmentTypeListResult(_serialization.Model):
     """Result of the project environment type list operation.
 
     Variables are only populated by the server, and will be ignored when sending a request.
@@ -4558,85 +4562,76 @@
 class ProjectEnvironmentTypeUpdateProperties(_serialization.Model):
     """Properties of a project environment type. These properties can be updated after the resource
     has been created.
 
     :ivar deployment_target_id: Id of a subscription that the environment type will be mapped to.
      The environment's resources will be deployed into this subscription.
     :vartype deployment_target_id: str
-    :ivar display_name: The display name of the project environment type.
-    :vartype display_name: str
     :ivar status: Defines whether this Environment Type can be used in this Project. Known values
      are: "Enabled" and "Disabled".
     :vartype status: str or ~azure.mgmt.devcenter.models.EnvironmentTypeEnableStatus
     :ivar creator_role_assignment: The role definition assigned to the environment creator on
      backing resources.
     :vartype creator_role_assignment:
      ~azure.mgmt.devcenter.models.ProjectEnvironmentTypeUpdatePropertiesCreatorRoleAssignment
     :ivar user_role_assignments: Role Assignments created on environment backing resources. This is
      a mapping from a user object ID to an object of role definition IDs.
     :vartype user_role_assignments: dict[str, ~azure.mgmt.devcenter.models.UserRoleAssignmentValue]
     """
 
     _attribute_map = {
         "deployment_target_id": {"key": "deploymentTargetId", "type": "str"},
-        "display_name": {"key": "displayName", "type": "str"},
         "status": {"key": "status", "type": "str"},
         "creator_role_assignment": {
             "key": "creatorRoleAssignment",
             "type": "ProjectEnvironmentTypeUpdatePropertiesCreatorRoleAssignment",
         },
         "user_role_assignments": {"key": "userRoleAssignments", "type": "{UserRoleAssignmentValue}"},
     }
 
     def __init__(
         self,
         *,
         deployment_target_id: Optional[str] = None,
-        display_name: Optional[str] = None,
         status: Optional[Union[str, "_models.EnvironmentTypeEnableStatus"]] = None,
         creator_role_assignment: Optional["_models.ProjectEnvironmentTypeUpdatePropertiesCreatorRoleAssignment"] = None,
         user_role_assignments: Optional[Dict[str, "_models.UserRoleAssignmentValue"]] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword deployment_target_id: Id of a subscription that the environment type will be mapped
          to. The environment's resources will be deployed into this subscription.
         :paramtype deployment_target_id: str
-        :keyword display_name: The display name of the project environment type.
-        :paramtype display_name: str
         :keyword status: Defines whether this Environment Type can be used in this Project. Known
          values are: "Enabled" and "Disabled".
         :paramtype status: str or ~azure.mgmt.devcenter.models.EnvironmentTypeEnableStatus
         :keyword creator_role_assignment: The role definition assigned to the environment creator on
          backing resources.
         :paramtype creator_role_assignment:
          ~azure.mgmt.devcenter.models.ProjectEnvironmentTypeUpdatePropertiesCreatorRoleAssignment
         :keyword user_role_assignments: Role Assignments created on environment backing resources. This
          is a mapping from a user object ID to an object of role definition IDs.
         :paramtype user_role_assignments: dict[str,
          ~azure.mgmt.devcenter.models.UserRoleAssignmentValue]
         """
         super().__init__(**kwargs)
         self.deployment_target_id = deployment_target_id
-        self.display_name = display_name
         self.status = status
         self.creator_role_assignment = creator_role_assignment
         self.user_role_assignments = user_role_assignments
 
 
 class ProjectEnvironmentTypeProperties(ProjectEnvironmentTypeUpdateProperties):
     """Properties of a project environment type.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar deployment_target_id: Id of a subscription that the environment type will be mapped to.
      The environment's resources will be deployed into this subscription.
     :vartype deployment_target_id: str
-    :ivar display_name: The display name of the project environment type.
-    :vartype display_name: str
     :ivar status: Defines whether this Environment Type can be used in this Project. Known values
      are: "Enabled" and "Disabled".
     :vartype status: str or ~azure.mgmt.devcenter.models.EnvironmentTypeEnableStatus
     :ivar creator_role_assignment: The role definition assigned to the environment creator on
      backing resources.
     :vartype creator_role_assignment:
      ~azure.mgmt.devcenter.models.ProjectEnvironmentTypeUpdatePropertiesCreatorRoleAssignment
@@ -4644,89 +4639,89 @@
      a mapping from a user object ID to an object of role definition IDs.
     :vartype user_role_assignments: dict[str, ~azure.mgmt.devcenter.models.UserRoleAssignmentValue]
     :ivar provisioning_state: The provisioning state of the resource. Known values are:
      "NotSpecified", "Accepted", "Running", "Creating", "Created", "Updating", "Updated",
      "Deleting", "Deleted", "Succeeded", "Failed", "Canceled", "MovingResources",
      "TransientFailure", "RolloutInProgress", and "StorageProvisioningFailed".
     :vartype provisioning_state: str or ~azure.mgmt.devcenter.models.ProvisioningState
+    :ivar display_name: The display name of the project environment type.
+    :vartype display_name: str
     :ivar environment_count: The number of environments of this type.
     :vartype environment_count: int
     """
 
     _validation = {
         "provisioning_state": {"readonly": True},
         "environment_count": {"readonly": True, "minimum": 0},
     }
 
     _attribute_map = {
         "deployment_target_id": {"key": "deploymentTargetId", "type": "str"},
-        "display_name": {"key": "displayName", "type": "str"},
         "status": {"key": "status", "type": "str"},
         "creator_role_assignment": {
             "key": "creatorRoleAssignment",
             "type": "ProjectEnvironmentTypeUpdatePropertiesCreatorRoleAssignment",
         },
         "user_role_assignments": {"key": "userRoleAssignments", "type": "{UserRoleAssignmentValue}"},
         "provisioning_state": {"key": "provisioningState", "type": "str"},
+        "display_name": {"key": "displayName", "type": "str"},
         "environment_count": {"key": "environmentCount", "type": "int"},
     }
 
     def __init__(
         self,
         *,
         deployment_target_id: Optional[str] = None,
-        display_name: Optional[str] = None,
         status: Optional[Union[str, "_models.EnvironmentTypeEnableStatus"]] = None,
         creator_role_assignment: Optional["_models.ProjectEnvironmentTypeUpdatePropertiesCreatorRoleAssignment"] = None,
         user_role_assignments: Optional[Dict[str, "_models.UserRoleAssignmentValue"]] = None,
+        display_name: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword deployment_target_id: Id of a subscription that the environment type will be mapped
          to. The environment's resources will be deployed into this subscription.
         :paramtype deployment_target_id: str
-        :keyword display_name: The display name of the project environment type.
-        :paramtype display_name: str
         :keyword status: Defines whether this Environment Type can be used in this Project. Known
          values are: "Enabled" and "Disabled".
         :paramtype status: str or ~azure.mgmt.devcenter.models.EnvironmentTypeEnableStatus
         :keyword creator_role_assignment: The role definition assigned to the environment creator on
          backing resources.
         :paramtype creator_role_assignment:
          ~azure.mgmt.devcenter.models.ProjectEnvironmentTypeUpdatePropertiesCreatorRoleAssignment
         :keyword user_role_assignments: Role Assignments created on environment backing resources. This
          is a mapping from a user object ID to an object of role definition IDs.
         :paramtype user_role_assignments: dict[str,
          ~azure.mgmt.devcenter.models.UserRoleAssignmentValue]
+        :keyword display_name: The display name of the project environment type.
+        :paramtype display_name: str
         """
         super().__init__(
             deployment_target_id=deployment_target_id,
-            display_name=display_name,
             status=status,
             creator_role_assignment=creator_role_assignment,
             user_role_assignments=user_role_assignments,
             **kwargs
         )
         self.provisioning_state = None
+        self.display_name = display_name
         self.environment_count = None
 
 
 class ProjectEnvironmentTypeUpdate(_serialization.Model):
     """The project environment type for partial update. Properties not provided in the update request
     will not be changed.
 
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
     :ivar identity: Managed identity properties.
     :vartype identity: ~azure.mgmt.devcenter.models.ManagedServiceIdentity
     :ivar deployment_target_id: Id of a subscription that the environment type will be mapped to.
      The environment's resources will be deployed into this subscription.
     :vartype deployment_target_id: str
-    :ivar display_name: The display name of the project environment type.
-    :vartype display_name: str
     :ivar status: Defines whether this Environment Type can be used in this Project. Known values
      are: "Enabled" and "Disabled".
     :vartype status: str or ~azure.mgmt.devcenter.models.EnvironmentTypeEnableStatus
     :ivar creator_role_assignment: The role definition assigned to the environment creator on
      backing resources.
     :vartype creator_role_assignment:
      ~azure.mgmt.devcenter.models.ProjectEnvironmentTypeUpdatePropertiesCreatorRoleAssignment
@@ -4735,45 +4730,41 @@
     :vartype user_role_assignments: dict[str, ~azure.mgmt.devcenter.models.UserRoleAssignmentValue]
     """
 
     _attribute_map = {
         "tags": {"key": "tags", "type": "{str}"},
         "identity": {"key": "identity", "type": "ManagedServiceIdentity"},
         "deployment_target_id": {"key": "properties.deploymentTargetId", "type": "str"},
-        "display_name": {"key": "properties.displayName", "type": "str"},
         "status": {"key": "properties.status", "type": "str"},
         "creator_role_assignment": {
             "key": "properties.creatorRoleAssignment",
             "type": "ProjectEnvironmentTypeUpdatePropertiesCreatorRoleAssignment",
         },
         "user_role_assignments": {"key": "properties.userRoleAssignments", "type": "{UserRoleAssignmentValue}"},
     }
 
     def __init__(
         self,
         *,
         tags: Optional[Dict[str, str]] = None,
         identity: Optional["_models.ManagedServiceIdentity"] = None,
         deployment_target_id: Optional[str] = None,
-        display_name: Optional[str] = None,
         status: Optional[Union[str, "_models.EnvironmentTypeEnableStatus"]] = None,
         creator_role_assignment: Optional["_models.ProjectEnvironmentTypeUpdatePropertiesCreatorRoleAssignment"] = None,
         user_role_assignments: Optional[Dict[str, "_models.UserRoleAssignmentValue"]] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword identity: Managed identity properties.
         :paramtype identity: ~azure.mgmt.devcenter.models.ManagedServiceIdentity
         :keyword deployment_target_id: Id of a subscription that the environment type will be mapped
          to. The environment's resources will be deployed into this subscription.
         :paramtype deployment_target_id: str
-        :keyword display_name: The display name of the project environment type.
-        :paramtype display_name: str
         :keyword status: Defines whether this Environment Type can be used in this Project. Known
          values are: "Enabled" and "Disabled".
         :paramtype status: str or ~azure.mgmt.devcenter.models.EnvironmentTypeEnableStatus
         :keyword creator_role_assignment: The role definition assigned to the environment creator on
          backing resources.
         :paramtype creator_role_assignment:
          ~azure.mgmt.devcenter.models.ProjectEnvironmentTypeUpdatePropertiesCreatorRoleAssignment
@@ -4782,23 +4773,20 @@
         :paramtype user_role_assignments: dict[str,
          ~azure.mgmt.devcenter.models.UserRoleAssignmentValue]
         """
         super().__init__(**kwargs)
         self.tags = tags
         self.identity = identity
         self.deployment_target_id = deployment_target_id
-        self.display_name = display_name
         self.status = status
         self.creator_role_assignment = creator_role_assignment
         self.user_role_assignments = user_role_assignments
 
 
-class ProjectEnvironmentTypeUpdatePropertiesCreatorRoleAssignment(
-    _serialization.Model
-):  # pylint: disable=name-too-long
+class ProjectEnvironmentTypeUpdatePropertiesCreatorRoleAssignment(_serialization.Model):
     """The role definition assigned to the environment creator on backing resources.
 
     :ivar roles: A map of roles to assign to the environment creator.
     :vartype roles: dict[str, ~azure.mgmt.devcenter.models.EnvironmentRole]
     """
 
     _attribute_map = {
@@ -4851,60 +4839,53 @@
     :vartype description: str
     :ivar max_dev_boxes_per_user: When specified, limits the maximum number of Dev Boxes a single
      user can create across all pools in the project. This will have no effect on existing Dev Boxes
      when reduced.
     :vartype max_dev_boxes_per_user: int
     :ivar display_name: The display name of the project.
     :vartype display_name: str
-    :ivar catalog_settings: Settings to be used when associating a project with a catalog.
-    :vartype catalog_settings: ~azure.mgmt.devcenter.models.ProjectCatalogSettings
     """
 
     _validation = {
         "max_dev_boxes_per_user": {"minimum": 0},
     }
 
     _attribute_map = {
         "dev_center_id": {"key": "devCenterId", "type": "str"},
         "description": {"key": "description", "type": "str"},
         "max_dev_boxes_per_user": {"key": "maxDevBoxesPerUser", "type": "int"},
         "display_name": {"key": "displayName", "type": "str"},
-        "catalog_settings": {"key": "catalogSettings", "type": "ProjectCatalogSettings"},
     }
 
     def __init__(
         self,
         *,
         dev_center_id: Optional[str] = None,
         description: Optional[str] = None,
         max_dev_boxes_per_user: Optional[int] = None,
         display_name: Optional[str] = None,
-        catalog_settings: Optional["_models.ProjectCatalogSettings"] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword dev_center_id: Resource Id of an associated DevCenter.
         :paramtype dev_center_id: str
         :keyword description: Description of the project.
         :paramtype description: str
         :keyword max_dev_boxes_per_user: When specified, limits the maximum number of Dev Boxes a
          single user can create across all pools in the project. This will have no effect on existing
          Dev Boxes when reduced.
         :paramtype max_dev_boxes_per_user: int
         :keyword display_name: The display name of the project.
         :paramtype display_name: str
-        :keyword catalog_settings: Settings to be used when associating a project with a catalog.
-        :paramtype catalog_settings: ~azure.mgmt.devcenter.models.ProjectCatalogSettings
         """
         super().__init__(**kwargs)
         self.dev_center_id = dev_center_id
         self.description = description
         self.max_dev_boxes_per_user = max_dev_boxes_per_user
         self.display_name = display_name
-        self.catalog_settings = catalog_settings
 
 
 class ProjectProperties(ProjectUpdateProperties):
     """Properties of a project.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
@@ -4914,16 +4895,14 @@
     :vartype description: str
     :ivar max_dev_boxes_per_user: When specified, limits the maximum number of Dev Boxes a single
      user can create across all pools in the project. This will have no effect on existing Dev Boxes
      when reduced.
     :vartype max_dev_boxes_per_user: int
     :ivar display_name: The display name of the project.
     :vartype display_name: str
-    :ivar catalog_settings: Settings to be used when associating a project with a catalog.
-    :vartype catalog_settings: ~azure.mgmt.devcenter.models.ProjectCatalogSettings
     :ivar provisioning_state: The provisioning state of the resource. Known values are:
      "NotSpecified", "Accepted", "Running", "Creating", "Created", "Updating", "Updated",
      "Deleting", "Deleted", "Succeeded", "Failed", "Canceled", "MovingResources",
      "TransientFailure", "RolloutInProgress", and "StorageProvisioningFailed".
     :vartype provisioning_state: str or ~azure.mgmt.devcenter.models.ProvisioningState
     :ivar dev_center_uri: The URI of the Dev Center resource this project is associated with.
     :vartype dev_center_uri: str
@@ -4936,134 +4915,115 @@
     }
 
     _attribute_map = {
         "dev_center_id": {"key": "devCenterId", "type": "str"},
         "description": {"key": "description", "type": "str"},
         "max_dev_boxes_per_user": {"key": "maxDevBoxesPerUser", "type": "int"},
         "display_name": {"key": "displayName", "type": "str"},
-        "catalog_settings": {"key": "catalogSettings", "type": "ProjectCatalogSettings"},
         "provisioning_state": {"key": "provisioningState", "type": "str"},
         "dev_center_uri": {"key": "devCenterUri", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         dev_center_id: Optional[str] = None,
         description: Optional[str] = None,
         max_dev_boxes_per_user: Optional[int] = None,
         display_name: Optional[str] = None,
-        catalog_settings: Optional["_models.ProjectCatalogSettings"] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword dev_center_id: Resource Id of an associated DevCenter.
         :paramtype dev_center_id: str
         :keyword description: Description of the project.
         :paramtype description: str
         :keyword max_dev_boxes_per_user: When specified, limits the maximum number of Dev Boxes a
          single user can create across all pools in the project. This will have no effect on existing
          Dev Boxes when reduced.
         :paramtype max_dev_boxes_per_user: int
         :keyword display_name: The display name of the project.
         :paramtype display_name: str
-        :keyword catalog_settings: Settings to be used when associating a project with a catalog.
-        :paramtype catalog_settings: ~azure.mgmt.devcenter.models.ProjectCatalogSettings
         """
         super().__init__(
             dev_center_id=dev_center_id,
             description=description,
             max_dev_boxes_per_user=max_dev_boxes_per_user,
             display_name=display_name,
-            catalog_settings=catalog_settings,
             **kwargs
         )
         self.provisioning_state = None
         self.dev_center_uri = None
 
 
 class ProjectUpdate(TrackedResourceUpdate):
     """The project properties for partial update. Properties not provided in the update request will
     not be changed.
 
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
     :ivar location: The geo-location where the resource lives.
     :vartype location: str
-    :ivar identity: Managed identity properties.
-    :vartype identity: ~azure.mgmt.devcenter.models.ManagedServiceIdentity
     :ivar dev_center_id: Resource Id of an associated DevCenter.
     :vartype dev_center_id: str
     :ivar description: Description of the project.
     :vartype description: str
     :ivar max_dev_boxes_per_user: When specified, limits the maximum number of Dev Boxes a single
      user can create across all pools in the project. This will have no effect on existing Dev Boxes
      when reduced.
     :vartype max_dev_boxes_per_user: int
     :ivar display_name: The display name of the project.
     :vartype display_name: str
-    :ivar catalog_settings: Settings to be used when associating a project with a catalog.
-    :vartype catalog_settings: ~azure.mgmt.devcenter.models.ProjectCatalogSettings
     """
 
     _validation = {
         "max_dev_boxes_per_user": {"minimum": 0},
     }
 
     _attribute_map = {
         "tags": {"key": "tags", "type": "{str}"},
         "location": {"key": "location", "type": "str"},
-        "identity": {"key": "identity", "type": "ManagedServiceIdentity"},
         "dev_center_id": {"key": "properties.devCenterId", "type": "str"},
         "description": {"key": "properties.description", "type": "str"},
         "max_dev_boxes_per_user": {"key": "properties.maxDevBoxesPerUser", "type": "int"},
         "display_name": {"key": "properties.displayName", "type": "str"},
-        "catalog_settings": {"key": "properties.catalogSettings", "type": "ProjectCatalogSettings"},
     }
 
     def __init__(
         self,
         *,
         tags: Optional[Dict[str, str]] = None,
         location: Optional[str] = None,
-        identity: Optional["_models.ManagedServiceIdentity"] = None,
         dev_center_id: Optional[str] = None,
         description: Optional[str] = None,
         max_dev_boxes_per_user: Optional[int] = None,
         display_name: Optional[str] = None,
-        catalog_settings: Optional["_models.ProjectCatalogSettings"] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: The geo-location where the resource lives.
         :paramtype location: str
-        :keyword identity: Managed identity properties.
-        :paramtype identity: ~azure.mgmt.devcenter.models.ManagedServiceIdentity
         :keyword dev_center_id: Resource Id of an associated DevCenter.
         :paramtype dev_center_id: str
         :keyword description: Description of the project.
         :paramtype description: str
         :keyword max_dev_boxes_per_user: When specified, limits the maximum number of Dev Boxes a
          single user can create across all pools in the project. This will have no effect on existing
          Dev Boxes when reduced.
         :paramtype max_dev_boxes_per_user: int
         :keyword display_name: The display name of the project.
         :paramtype display_name: str
-        :keyword catalog_settings: Settings to be used when associating a project with a catalog.
-        :paramtype catalog_settings: ~azure.mgmt.devcenter.models.ProjectCatalogSettings
         """
         super().__init__(tags=tags, location=location, **kwargs)
-        self.identity = identity
         self.dev_center_id = dev_center_id
         self.description = description
         self.max_dev_boxes_per_user = max_dev_boxes_per_user
         self.display_name = display_name
-        self.catalog_settings = catalog_settings
 
 
 class RecommendedMachineConfiguration(_serialization.Model):
     """Properties for a recommended machine configuration.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
@@ -5114,34 +5074,30 @@
     def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.min = None
         self.max = None
 
 
-class Schedule(Resource):  # pylint: disable=too-many-instance-attributes
+class Schedule(Resource):
     """Represents a Schedule to execute a task.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".  # pylint: disable=line-too-long
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
      information.
     :vartype system_data: ~azure.mgmt.devcenter.models.SystemData
-    :ivar tags: Resource tags.
-    :vartype tags: dict[str, str]
-    :ivar location: The geo-location where the resource lives.
-    :vartype location: str
     :ivar type_properties_type: Supported type this scheduled task represents. "StopDevBox"
     :vartype type_properties_type: str or ~azure.mgmt.devcenter.models.ScheduledType
     :ivar frequency: The frequency of this scheduled task. "Daily"
     :vartype frequency: str or ~azure.mgmt.devcenter.models.ScheduledFrequency
     :ivar time: The target time to trigger the action. The format is HH:MM.
     :vartype time: str
     :ivar time_zone: The IANA timezone id at which the schedule should execute.
@@ -5165,56 +5121,46 @@
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
-        "tags": {"key": "properties.tags", "type": "{str}"},
-        "location": {"key": "properties.location", "type": "str"},
         "type_properties_type": {"key": "properties.type", "type": "str"},
         "frequency": {"key": "properties.frequency", "type": "str"},
         "time": {"key": "properties.time", "type": "str"},
         "time_zone": {"key": "properties.timeZone", "type": "str"},
         "state": {"key": "properties.state", "type": "str"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
     }
 
     def __init__(
         self,
         *,
-        tags: Optional[Dict[str, str]] = None,
-        location: Optional[str] = None,
         type_properties_type: Optional[Union[str, "_models.ScheduledType"]] = None,
         frequency: Optional[Union[str, "_models.ScheduledFrequency"]] = None,
         time: Optional[str] = None,
         time_zone: Optional[str] = None,
         state: Optional[Union[str, "_models.ScheduleEnableStatus"]] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword tags: Resource tags.
-        :paramtype tags: dict[str, str]
-        :keyword location: The geo-location where the resource lives.
-        :paramtype location: str
         :keyword type_properties_type: Supported type this scheduled task represents. "StopDevBox"
         :paramtype type_properties_type: str or ~azure.mgmt.devcenter.models.ScheduledType
         :keyword frequency: The frequency of this scheduled task. "Daily"
         :paramtype frequency: str or ~azure.mgmt.devcenter.models.ScheduledFrequency
         :keyword time: The target time to trigger the action. The format is HH:MM.
         :paramtype time: str
         :keyword time_zone: The IANA timezone id at which the schedule should execute.
         :paramtype time_zone: str
         :keyword state: Indicates whether or not this scheduled task is enabled. Known values are:
          "Enabled" and "Disabled".
         :paramtype state: str or ~azure.mgmt.devcenter.models.ScheduleEnableStatus
         """
         super().__init__(**kwargs)
-        self.tags = tags
-        self.location = location
         self.type_properties_type = type_properties_type
         self.frequency = frequency
         self.time = time
         self.time_zone = time_zone
         self.state = state
         self.provisioning_state = None
 
@@ -5243,90 +5189,74 @@
     def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
-class ScheduleUpdateProperties(TrackedResourceUpdate):
+class ScheduleUpdateProperties(_serialization.Model):
     """Updatable properties of a Schedule.
 
-    :ivar tags: Resource tags.
-    :vartype tags: dict[str, str]
-    :ivar location: The geo-location where the resource lives.
-    :vartype location: str
     :ivar type: Supported type this scheduled task represents. "StopDevBox"
     :vartype type: str or ~azure.mgmt.devcenter.models.ScheduledType
     :ivar frequency: The frequency of this scheduled task. "Daily"
     :vartype frequency: str or ~azure.mgmt.devcenter.models.ScheduledFrequency
     :ivar time: The target time to trigger the action. The format is HH:MM.
     :vartype time: str
     :ivar time_zone: The IANA timezone id at which the schedule should execute.
     :vartype time_zone: str
     :ivar state: Indicates whether or not this scheduled task is enabled. Known values are:
      "Enabled" and "Disabled".
     :vartype state: str or ~azure.mgmt.devcenter.models.ScheduleEnableStatus
     """
 
     _attribute_map = {
-        "tags": {"key": "tags", "type": "{str}"},
-        "location": {"key": "location", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "frequency": {"key": "frequency", "type": "str"},
         "time": {"key": "time", "type": "str"},
         "time_zone": {"key": "timeZone", "type": "str"},
         "state": {"key": "state", "type": "str"},
     }
 
     def __init__(
         self,
         *,
-        tags: Optional[Dict[str, str]] = None,
-        location: Optional[str] = None,
         type: Optional[Union[str, "_models.ScheduledType"]] = None,
         frequency: Optional[Union[str, "_models.ScheduledFrequency"]] = None,
         time: Optional[str] = None,
         time_zone: Optional[str] = None,
         state: Optional[Union[str, "_models.ScheduleEnableStatus"]] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword tags: Resource tags.
-        :paramtype tags: dict[str, str]
-        :keyword location: The geo-location where the resource lives.
-        :paramtype location: str
         :keyword type: Supported type this scheduled task represents. "StopDevBox"
         :paramtype type: str or ~azure.mgmt.devcenter.models.ScheduledType
         :keyword frequency: The frequency of this scheduled task. "Daily"
         :paramtype frequency: str or ~azure.mgmt.devcenter.models.ScheduledFrequency
         :keyword time: The target time to trigger the action. The format is HH:MM.
         :paramtype time: str
         :keyword time_zone: The IANA timezone id at which the schedule should execute.
         :paramtype time_zone: str
         :keyword state: Indicates whether or not this scheduled task is enabled. Known values are:
          "Enabled" and "Disabled".
         :paramtype state: str or ~azure.mgmt.devcenter.models.ScheduleEnableStatus
         """
-        super().__init__(tags=tags, location=location, **kwargs)
+        super().__init__(**kwargs)
         self.type = type
         self.frequency = frequency
         self.time = time
         self.time_zone = time_zone
         self.state = state
 
 
 class ScheduleProperties(ScheduleUpdateProperties):
     """The Schedule properties defining when and what to execute.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    :ivar tags: Resource tags.
-    :vartype tags: dict[str, str]
-    :ivar location: The geo-location where the resource lives.
-    :vartype location: str
     :ivar type: Supported type this scheduled task represents. "StopDevBox"
     :vartype type: str or ~azure.mgmt.devcenter.models.ScheduledType
     :ivar frequency: The frequency of this scheduled task. "Daily"
     :vartype frequency: str or ~azure.mgmt.devcenter.models.ScheduledFrequency
     :ivar time: The target time to trigger the action. The format is HH:MM.
     :vartype time: str
     :ivar time_zone: The IANA timezone id at which the schedule should execute.
@@ -5342,67 +5272,50 @@
     """
 
     _validation = {
         "provisioning_state": {"readonly": True},
     }
 
     _attribute_map = {
-        "tags": {"key": "tags", "type": "{str}"},
-        "location": {"key": "location", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "frequency": {"key": "frequency", "type": "str"},
         "time": {"key": "time", "type": "str"},
         "time_zone": {"key": "timeZone", "type": "str"},
         "state": {"key": "state", "type": "str"},
         "provisioning_state": {"key": "provisioningState", "type": "str"},
     }
 
     def __init__(
         self,
         *,
-        tags: Optional[Dict[str, str]] = None,
-        location: Optional[str] = None,
         type: Optional[Union[str, "_models.ScheduledType"]] = None,
         frequency: Optional[Union[str, "_models.ScheduledFrequency"]] = None,
         time: Optional[str] = None,
         time_zone: Optional[str] = None,
         state: Optional[Union[str, "_models.ScheduleEnableStatus"]] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword tags: Resource tags.
-        :paramtype tags: dict[str, str]
-        :keyword location: The geo-location where the resource lives.
-        :paramtype location: str
         :keyword type: Supported type this scheduled task represents. "StopDevBox"
         :paramtype type: str or ~azure.mgmt.devcenter.models.ScheduledType
         :keyword frequency: The frequency of this scheduled task. "Daily"
         :paramtype frequency: str or ~azure.mgmt.devcenter.models.ScheduledFrequency
         :keyword time: The target time to trigger the action. The format is HH:MM.
         :paramtype time: str
         :keyword time_zone: The IANA timezone id at which the schedule should execute.
         :paramtype time_zone: str
         :keyword state: Indicates whether or not this scheduled task is enabled. Known values are:
          "Enabled" and "Disabled".
         :paramtype state: str or ~azure.mgmt.devcenter.models.ScheduleEnableStatus
         """
-        super().__init__(
-            tags=tags,
-            location=location,
-            type=type,
-            frequency=frequency,
-            time=time,
-            time_zone=time_zone,
-            state=state,
-            **kwargs
-        )
+        super().__init__(type=type, frequency=frequency, time=time, time_zone=time_zone, state=state, **kwargs)
         self.provisioning_state = None
 
 
-class ScheduleUpdate(_serialization.Model):
+class ScheduleUpdate(TrackedResourceUpdate):
     """The schedule properties for partial update. Properties not provided in the update request will
     not be changed.
 
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
     :ivar location: The geo-location where the resource lives.
     :vartype location: str
@@ -5416,16 +5329,16 @@
     :vartype time_zone: str
     :ivar state: Indicates whether or not this scheduled task is enabled. Known values are:
      "Enabled" and "Disabled".
     :vartype state: str or ~azure.mgmt.devcenter.models.ScheduleEnableStatus
     """
 
     _attribute_map = {
-        "tags": {"key": "properties.tags", "type": "{str}"},
-        "location": {"key": "properties.location", "type": "str"},
+        "tags": {"key": "tags", "type": "{str}"},
+        "location": {"key": "location", "type": "str"},
         "type": {"key": "properties.type", "type": "str"},
         "frequency": {"key": "properties.frequency", "type": "str"},
         "time": {"key": "properties.time", "type": "str"},
         "time_zone": {"key": "properties.timeZone", "type": "str"},
         "state": {"key": "properties.state", "type": "str"},
     }
 
@@ -5454,17 +5367,15 @@
         :paramtype time: str
         :keyword time_zone: The IANA timezone id at which the schedule should execute.
         :paramtype time_zone: str
         :keyword state: Indicates whether or not this scheduled task is enabled. Known values are:
          "Enabled" and "Disabled".
         :paramtype state: str or ~azure.mgmt.devcenter.models.ScheduleEnableStatus
         """
-        super().__init__(**kwargs)
-        self.tags = tags
-        self.location = location
+        super().__init__(tags=tags, location=location, **kwargs)
         self.type = type
         self.frequency = frequency
         self.time = time
         self.time_zone = time_zone
         self.state = state
 
 
@@ -5580,16 +5491,14 @@
     :vartype removed: int
     :ivar validation_errors: Count of catalog items that had validation errors during
      synchronization.
     :vartype validation_errors: int
     :ivar synchronization_errors: Count of synchronization errors that occured during
      synchronization.
     :vartype synchronization_errors: int
-    :ivar synced_catalog_item_types: Indicates catalog item types that were synced.
-    :vartype synced_catalog_item_types: list[str or ~azure.mgmt.devcenter.models.CatalogItemType]
     """
 
     _validation = {
         "added": {"readonly": True, "minimum": 0},
         "updated": {"readonly": True, "minimum": 0},
         "unchanged": {"readonly": True, "minimum": 0},
         "removed": {"readonly": True, "minimum": 0},
@@ -5600,32 +5509,25 @@
     _attribute_map = {
         "added": {"key": "added", "type": "int"},
         "updated": {"key": "updated", "type": "int"},
         "unchanged": {"key": "unchanged", "type": "int"},
         "removed": {"key": "removed", "type": "int"},
         "validation_errors": {"key": "validationErrors", "type": "int"},
         "synchronization_errors": {"key": "synchronizationErrors", "type": "int"},
-        "synced_catalog_item_types": {"key": "syncedCatalogItemTypes", "type": "[str]"},
     }
 
-    def __init__(
-        self, *, synced_catalog_item_types: Optional[List[Union[str, "_models.CatalogItemType"]]] = None, **kwargs: Any
-    ) -> None:
-        """
-        :keyword synced_catalog_item_types: Indicates catalog item types that were synced.
-        :paramtype synced_catalog_item_types: list[str or ~azure.mgmt.devcenter.models.CatalogItemType]
-        """
+    def __init__(self, **kwargs: Any) -> None:
+        """ """
         super().__init__(**kwargs)
         self.added = None
         self.updated = None
         self.unchanged = None
         self.removed = None
         self.validation_errors = None
         self.synchronization_errors = None
-        self.synced_catalog_item_types = synced_catalog_item_types
 
 
 class SystemData(_serialization.Model):
     """Metadata pertaining to creation and last modification of the resource.
 
     :ivar created_by: The identity that created the resource.
     :vartype created_by: str
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/models/_patch.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/models/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/__init__.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/__init__.py`

 * *Files 9% similar despite different names*

```diff
@@ -5,59 +5,57 @@
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._dev_centers_operations import DevCentersOperations
 from ._projects_operations import ProjectsOperations
 from ._attached_networks_operations import AttachedNetworksOperations
-from ._project_catalogs_operations import ProjectCatalogsOperations
-from ._environment_definitions_operations import EnvironmentDefinitionsOperations
-from ._project_catalog_environment_definitions_operations import ProjectCatalogEnvironmentDefinitionsOperations
 from ._galleries_operations import GalleriesOperations
 from ._images_operations import ImagesOperations
 from ._image_versions_operations import ImageVersionsOperations
 from ._catalogs_operations import CatalogsOperations
 from ._environment_types_operations import EnvironmentTypesOperations
 from ._project_allowed_environment_types_operations import ProjectAllowedEnvironmentTypesOperations
 from ._project_environment_types_operations import ProjectEnvironmentTypesOperations
 from ._dev_box_definitions_operations import DevBoxDefinitionsOperations
 from ._operations import Operations
 from ._operation_statuses_operations import OperationStatusesOperations
 from ._usages_operations import UsagesOperations
 from ._check_name_availability_operations import CheckNameAvailabilityOperations
-from ._check_scoped_name_availability_operations import CheckScopedNameAvailabilityOperations
+from ._catalog_dev_box_definitions_operations import CatalogDevBoxDefinitionsOperations
+from ._customization_tasks_operations import CustomizationTasksOperations
+from ._environment_definitions_operations import EnvironmentDefinitionsOperations
 from ._skus_operations import SkusOperations
 from ._pools_operations import PoolsOperations
 from ._schedules_operations import SchedulesOperations
 from ._network_connections_operations import NetworkConnectionsOperations
 
 from ._patch import __all__ as _patch_all
 from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "DevCentersOperations",
     "ProjectsOperations",
     "AttachedNetworksOperations",
-    "ProjectCatalogsOperations",
-    "EnvironmentDefinitionsOperations",
-    "ProjectCatalogEnvironmentDefinitionsOperations",
     "GalleriesOperations",
     "ImagesOperations",
     "ImageVersionsOperations",
     "CatalogsOperations",
     "EnvironmentTypesOperations",
     "ProjectAllowedEnvironmentTypesOperations",
     "ProjectEnvironmentTypesOperations",
     "DevBoxDefinitionsOperations",
     "Operations",
     "OperationStatusesOperations",
     "UsagesOperations",
     "CheckNameAvailabilityOperations",
-    "CheckScopedNameAvailabilityOperations",
+    "CatalogDevBoxDefinitionsOperations",
+    "CustomizationTasksOperations",
+    "EnvironmentDefinitionsOperations",
     "SkusOperations",
     "PoolsOperations",
     "SchedulesOperations",
     "NetworkConnectionsOperations",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
 _patch_sdk()
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_attached_networks_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_attached_networks_operations.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -41,15 +41,15 @@
 
 def build_list_by_project_request(
     resource_group_name: str, project_name: str, subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/attachednetworks",
     )  # pylint: disable=line-too-long
@@ -87,15 +87,15 @@
     attached_network_connection_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/attachednetworks/{attachedNetworkConnectionName}",
     )  # pylint: disable=line-too-long
@@ -135,15 +135,15 @@
 
 def build_list_by_dev_center_request(
     resource_group_name: str, dev_center_name: str, subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/attachednetworks",
     )  # pylint: disable=line-too-long
@@ -181,15 +181,15 @@
     attached_network_connection_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/attachednetworks/{attachedNetworkConnectionName}",
     )  # pylint: disable=line-too-long
@@ -233,15 +233,15 @@
     attached_network_connection_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/attachednetworks/{attachedNetworkConnectionName}",
@@ -288,15 +288,15 @@
     attached_network_connection_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/attachednetworks/{attachedNetworkConnectionName}",
     )  # pylint: disable=line-too-long
@@ -363,14 +363,15 @@
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AttachedNetworkConnection or the result of
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.AttachedNetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
@@ -385,82 +386,87 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_project_request(
+                request = build_list_by_project_request(
                     resource_group_name=resource_group_name,
                     project_name=project_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_project.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("AttachedNetworkListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
+    list_by_project.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/attachednetworks"
+    }
+
     @distributed_trace
     def get_by_project(
         self, resource_group_name: str, project_name: str, attached_network_connection_name: str, **kwargs: Any
     ) -> _models.AttachedNetworkConnection:
         """Gets an attached NetworkConnection.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param attached_network_connection_name: The name of the attached NetworkConnection. Required.
         :type attached_network_connection_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AttachedNetworkConnection or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.AttachedNetworkConnection
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -471,44 +477,48 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AttachedNetworkConnection] = kwargs.pop("cls", None)
 
-        _request = build_get_by_project_request(
+        request = build_get_by_project_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             attached_network_connection_name=attached_network_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get_by_project.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("AttachedNetworkConnection", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-        return deserialized  # type: ignore
+    get_by_project.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/attachednetworks/{attachedNetworkConnectionName}"
+    }
 
     @distributed_trace
     def list_by_dev_center(
         self, resource_group_name: str, dev_center_name: str, top: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.AttachedNetworkConnection"]:
         """Lists the attached NetworkConnections for a DevCenter.
 
@@ -516,14 +526,15 @@
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AttachedNetworkConnection or the result of
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.AttachedNetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
@@ -538,82 +549,87 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_dev_center_request(
+                request = build_list_by_dev_center_request(
                     resource_group_name=resource_group_name,
                     dev_center_name=dev_center_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_dev_center.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("AttachedNetworkListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
+    list_by_dev_center.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/attachednetworks"
+    }
+
     @distributed_trace
     def get_by_dev_center(
         self, resource_group_name: str, dev_center_name: str, attached_network_connection_name: str, **kwargs: Any
     ) -> _models.AttachedNetworkConnection:
         """Gets an attached NetworkConnection.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param attached_network_connection_name: The name of the attached NetworkConnection. Required.
         :type attached_network_connection_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AttachedNetworkConnection or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.AttachedNetworkConnection
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -624,51 +640,55 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AttachedNetworkConnection] = kwargs.pop("cls", None)
 
-        _request = build_get_by_dev_center_request(
+        request = build_get_by_dev_center_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             attached_network_connection_name=attached_network_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get_by_dev_center.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("AttachedNetworkConnection", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    get_by_dev_center.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/attachednetworks/{attachedNetworkConnectionName}"
+    }
 
     def _create_or_update_initial(
         self,
         resource_group_name: str,
         dev_center_name: str,
         attached_network_connection_name: str,
-        body: Union[_models.AttachedNetworkConnection, IO[bytes]],
+        body: Union[_models.AttachedNetworkConnection, IO],
         **kwargs: Any
     ) -> _models.AttachedNetworkConnection:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -686,51 +706,51 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "AttachedNetworkConnection")
 
-        _request = build_create_or_update_request(
+        request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             attached_network_connection_name=attached_network_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 201]:
+        if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        if response.status_code == 200:
-            deserialized = self._deserialize("AttachedNetworkConnection", pipeline_response)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        if response.status_code == 201:
-            deserialized = self._deserialize("AttachedNetworkConnection", pipeline_response)
+        deserialized = self._deserialize("AttachedNetworkConnection", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    _create_or_update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/attachednetworks/{attachedNetworkConnectionName}"
+    }
 
     @overload
     def begin_create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         attached_network_connection_name: str,
@@ -749,72 +769,99 @@
         :param attached_network_connection_name: The name of the attached NetworkConnection. Required.
         :type attached_network_connection_name: str
         :param body: Represents an attached NetworkConnection. Required.
         :type body: ~azure.mgmt.devcenter.models.AttachedNetworkConnection
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either AttachedNetworkConnection or the result
          of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.AttachedNetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         attached_network_connection_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.AttachedNetworkConnection]:
         """Creates or updates an attached NetworkConnection.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param attached_network_connection_name: The name of the attached NetworkConnection. Required.
         :type attached_network_connection_name: str
         :param body: Represents an attached NetworkConnection. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either AttachedNetworkConnection or the result
          of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.AttachedNetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         attached_network_connection_name: str,
-        body: Union[_models.AttachedNetworkConnection, IO[bytes]],
+        body: Union[_models.AttachedNetworkConnection, IO],
         **kwargs: Any
     ) -> LROPoller[_models.AttachedNetworkConnection]:
         """Creates or updates an attached NetworkConnection.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param attached_network_connection_name: The name of the attached NetworkConnection. Required.
         :type attached_network_connection_name: str
         :param body: Represents an attached NetworkConnection. Is either a AttachedNetworkConnection
-         type or a IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.AttachedNetworkConnection or IO[bytes]
+         type or a IO type. Required.
+        :type body: ~azure.mgmt.devcenter.models.AttachedNetworkConnection or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either AttachedNetworkConnection or the result
          of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.AttachedNetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
@@ -839,35 +886,37 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("AttachedNetworkConnection", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[_models.AttachedNetworkConnection].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[_models.AttachedNetworkConnection](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_create_or_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/attachednetworks/{attachedNetworkConnectionName}"
+    }
 
     def _delete_initial(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, dev_center_name: str, attached_network_connection_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -878,58 +927,66 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_delete_request(
+        request = build_delete_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             attached_network_connection_name=attached_network_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
+            return cls(pipeline_response, None, {})
+
+    _delete_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/attachednetworks/{attachedNetworkConnectionName}"
+    }
 
     @distributed_trace
     def begin_delete(
         self, resource_group_name: str, dev_center_name: str, attached_network_connection_name: str, **kwargs: Any
     ) -> LROPoller[None]:
         """Un-attach a NetworkConnection.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param attached_network_connection_name: The name of the attached NetworkConnection. Required.
         :type attached_network_connection_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -949,25 +1006,29 @@
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[None].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_delete.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/attachednetworks/{attachedNetworkConnectionName}"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_catalogs_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_catalogs_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -41,15 +41,15 @@
 
 def build_list_by_dev_center_request(
     resource_group_name: str, dev_center_name: str, subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs",
     )  # pylint: disable=line-too-long
@@ -83,15 +83,15 @@
 
 def build_get_request(
     resource_group_name: str, dev_center_name: str, catalog_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}",
     )  # pylint: disable=line-too-long
@@ -131,15 +131,15 @@
 
 def build_create_or_update_request(
     resource_group_name: str, dev_center_name: str, catalog_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}",
@@ -182,15 +182,15 @@
 
 def build_update_request(
     resource_group_name: str, dev_center_name: str, catalog_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}",
@@ -233,15 +233,15 @@
 
 def build_delete_request(
     resource_group_name: str, dev_center_name: str, catalog_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}",
     )  # pylint: disable=line-too-long
@@ -281,15 +281,15 @@
 
 def build_get_sync_error_details_request(
     resource_group_name: str, dev_center_name: str, catalog_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/getSyncErrorDetails",
     )  # pylint: disable=line-too-long
@@ -329,15 +329,15 @@
 
 def build_sync_request(
     resource_group_name: str, dev_center_name: str, catalog_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/sync",
     )  # pylint: disable=line-too-long
@@ -377,15 +377,15 @@
 
 def build_connect_request(
     resource_group_name: str, dev_center_name: str, catalog_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/connect",
     )  # pylint: disable=line-too-long
@@ -452,14 +452,15 @@
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Catalog or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.Catalog]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -473,80 +474,85 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_dev_center_request(
+                request = build_list_by_dev_center_request(
                     resource_group_name=resource_group_name,
                     dev_center_name=dev_center_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_dev_center.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("CatalogListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
+    list_by_dev_center.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs"
+    }
+
     @distributed_trace
     def get(self, resource_group_name: str, dev_center_name: str, catalog_name: str, **kwargs: Any) -> _models.Catalog:
         """Gets a catalog.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param catalog_name: The name of the Catalog. Required.
         :type catalog_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Catalog or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.Catalog
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -557,51 +563,55 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.Catalog] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             catalog_name=catalog_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("Catalog", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-        return deserialized  # type: ignore
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}"
+    }
 
     def _create_or_update_initial(
         self,
         resource_group_name: str,
         dev_center_name: str,
         catalog_name: str,
-        body: Union[_models.Catalog, IO[bytes]],
+        body: Union[_models.Catalog, IO],
         **kwargs: Any
     ) -> _models.Catalog:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -619,51 +629,51 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "Catalog")
 
-        _request = build_create_or_update_request(
+        request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             catalog_name=catalog_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 201]:
+        if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        if response.status_code == 200:
-            deserialized = self._deserialize("Catalog", pipeline_response)
-
-        if response.status_code == 201:
-            deserialized = self._deserialize("Catalog", pipeline_response)
+        deserialized = self._deserialize("Catalog", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    _create_or_update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}"
+    }
 
     @overload
     def begin_create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         catalog_name: str,
@@ -682,69 +692,96 @@
         :param catalog_name: The name of the Catalog. Required.
         :type catalog_name: str
         :param body: Represents a catalog. Required.
         :type body: ~azure.mgmt.devcenter.models.Catalog
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either Catalog or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Catalog]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         catalog_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.Catalog]:
         """Creates or updates a catalog.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param catalog_name: The name of the Catalog. Required.
         :type catalog_name: str
         :param body: Represents a catalog. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either Catalog or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Catalog]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         catalog_name: str,
-        body: Union[_models.Catalog, IO[bytes]],
+        body: Union[_models.Catalog, IO],
         **kwargs: Any
     ) -> LROPoller[_models.Catalog]:
         """Creates or updates a catalog.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param catalog_name: The name of the Catalog. Required.
         :type catalog_name: str
-        :param body: Represents a catalog. Is either a Catalog type or a IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.Catalog or IO[bytes]
+        :param body: Represents a catalog. Is either a Catalog type or a IO type. Required.
+        :type body: ~azure.mgmt.devcenter.models.Catalog or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either Catalog or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Catalog]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -768,42 +805,44 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Catalog", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[_models.Catalog].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[_models.Catalog](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_create_or_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}"
+    }
 
     def _update_initial(
         self,
         resource_group_name: str,
         dev_center_name: str,
         catalog_name: str,
-        body: Union[_models.CatalogUpdate, IO[bytes]],
+        body: Union[_models.CatalogUpdate, IO],
         **kwargs: Any
     ) -> Optional[_models.Catalog]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -821,53 +860,53 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "CatalogUpdate")
 
-        _request = build_update_request(
+        request = build_update_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             catalog_name=catalog_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = None
-        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("Catalog", pipeline_response)
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-        return deserialized  # type: ignore
+    _update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}"
+    }
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         catalog_name: str,
@@ -886,70 +925,97 @@
         :param catalog_name: The name of the Catalog. Required.
         :type catalog_name: str
         :param body: Updatable catalog properties. Required.
         :type body: ~azure.mgmt.devcenter.models.CatalogUpdate
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either Catalog or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Catalog]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         catalog_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.Catalog]:
         """Partially updates a catalog.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param catalog_name: The name of the Catalog. Required.
         :type catalog_name: str
         :param body: Updatable catalog properties. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either Catalog or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Catalog]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         catalog_name: str,
-        body: Union[_models.CatalogUpdate, IO[bytes]],
+        body: Union[_models.CatalogUpdate, IO],
         **kwargs: Any
     ) -> LROPoller[_models.Catalog]:
         """Partially updates a catalog.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param catalog_name: The name of the Catalog. Required.
         :type catalog_name: str
-        :param body: Updatable catalog properties. Is either a CatalogUpdate type or a IO[bytes] type.
+        :param body: Updatable catalog properties. Is either a CatalogUpdate type or a IO type.
          Required.
-        :type body: ~azure.mgmt.devcenter.models.CatalogUpdate or IO[bytes]
+        :type body: ~azure.mgmt.devcenter.models.CatalogUpdate or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either Catalog or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Catalog]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -973,35 +1039,37 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Catalog", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[_models.Catalog].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[_models.Catalog](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}"
+    }
 
     def _delete_initial(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, dev_center_name: str, catalog_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -1012,58 +1080,66 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_delete_request(
+        request = build_delete_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             catalog_name=catalog_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
+            return cls(pipeline_response, None, {})
+
+    _delete_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}"
+    }
 
     @distributed_trace
     def begin_delete(
         self, resource_group_name: str, dev_center_name: str, catalog_name: str, **kwargs: Any
     ) -> LROPoller[None]:
         """Deletes a catalog resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param catalog_name: The name of the Catalog. Required.
         :type catalog_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -1083,46 +1159,51 @@
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[None].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_delete.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}"
+    }
 
     @distributed_trace
     def get_sync_error_details(
         self, resource_group_name: str, dev_center_name: str, catalog_name: str, **kwargs: Any
     ) -> _models.SyncErrorDetails:
         """Gets catalog synchronization error details.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param catalog_name: The name of the Catalog. Required.
         :type catalog_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: SyncErrorDetails or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.SyncErrorDetails
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -1133,44 +1214,48 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.SyncErrorDetails] = kwargs.pop("cls", None)
 
-        _request = build_get_sync_error_details_request(
+        request = build_get_sync_error_details_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             catalog_name=catalog_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get_sync_error_details.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("SyncErrorDetails", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    get_sync_error_details.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/getSyncErrorDetails"
+    }
 
     def _sync_initial(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, dev_center_name: str, catalog_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -1181,57 +1266,66 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_sync_request(
+        request = build_sync_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             catalog_name=catalog_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self._sync_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
+            return cls(pipeline_response, None, {})
+
+    _sync_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/sync"
+    }
 
     @distributed_trace
     def begin_sync(
         self, resource_group_name: str, dev_center_name: str, catalog_name: str, **kwargs: Any
     ) -> LROPoller[None]:
         """Syncs templates for a template source.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param catalog_name: The name of the Catalog. Required.
         :type catalog_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -1251,32 +1345,36 @@
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[None].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_sync.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/sync"
+    }
 
     def _connect_initial(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, dev_center_name: str, catalog_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -1287,57 +1385,66 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_connect_request(
+        request = build_connect_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             catalog_name=catalog_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self._connect_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
+            return cls(pipeline_response, None, {})
+
+    _connect_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/connect"
+    }
 
     @distributed_trace
     def begin_connect(
         self, resource_group_name: str, dev_center_name: str, catalog_name: str, **kwargs: Any
     ) -> LROPoller[None]:
         """Connects a catalog to enable syncing.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param catalog_name: The name of the Catalog. Required.
         :type catalog_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -1357,25 +1464,29 @@
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[None].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_connect.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/connect"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_check_name_availability_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_usages_operations.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,26 +1,27 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-from io import IOBase
-from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
+from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
@@ -31,160 +32,137 @@
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_execute_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
+def build_list_by_location_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
-        "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.DevCenter/checkNameAvailability"
-    )
+        "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.DevCenter/locations/{location}/usages"
+    )  # pylint: disable=line-too-long
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "location": _SERIALIZER.url("location", location, "str"),
     }
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
-    if content_type is not None:
-        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class CheckNameAvailabilityOperations:
+class UsagesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.devcenter.DevCenterMgmtClient`'s
-        :attr:`check_name_availability` attribute.
+        :attr:`usages` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
-    @overload
-    def execute(
-        self,
-        name_availability_request: _models.CheckNameAvailabilityRequest,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> _models.CheckNameAvailabilityResponse:
-        """Check the availability of name for resource.
-
-        :param name_availability_request: The required parameters for checking if resource name is
-         available. Required.
-        :type name_availability_request: ~azure.mgmt.devcenter.models.CheckNameAvailabilityRequest
-        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :return: CheckNameAvailabilityResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.devcenter.models.CheckNameAvailabilityResponse
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
+    @distributed_trace
+    def list_by_location(self, location: str, **kwargs: Any) -> Iterable["_models.Usage"]:
+        """Lists the current usages and limits in this location for the provided subscription.
 
-    @overload
-    def execute(
-        self, name_availability_request: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
-    ) -> _models.CheckNameAvailabilityResponse:
-        """Check the availability of name for resource.
-
-        :param name_availability_request: The required parameters for checking if resource name is
-         available. Required.
-        :type name_availability_request: IO[bytes]
-        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :return: CheckNameAvailabilityResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.devcenter.models.CheckNameAvailabilityResponse
+        :param location: The Azure region. Required.
+        :type location: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: An iterator like instance of either Usage or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.Usage]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.ListUsagesResult] = kwargs.pop("cls", None)
 
-    @distributed_trace
-    def execute(
-        self, name_availability_request: Union[_models.CheckNameAvailabilityRequest, IO[bytes]], **kwargs: Any
-    ) -> _models.CheckNameAvailabilityResponse:
-        """Check the availability of name for resource.
-
-        :param name_availability_request: The required parameters for checking if resource name is
-         available. Is either a CheckNameAvailabilityRequest type or a IO[bytes] type. Required.
-        :type name_availability_request: ~azure.mgmt.devcenter.models.CheckNameAvailabilityRequest or
-         IO[bytes]
-        :return: CheckNameAvailabilityResponse or the result of cls(response)
-        :rtype: ~azure.mgmt.devcenter.models.CheckNameAvailabilityResponse
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CheckNameAvailabilityResponse] = kwargs.pop("cls", None)
+        def prepare_request(next_link=None):
+            if not next_link:
 
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(name_availability_request, (IOBase, bytes)):
-            _content = name_availability_request
-        else:
-            _json = self._serialize.body(name_availability_request, "CheckNameAvailabilityRequest")
-
-        _request = build_execute_request(
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            headers=_headers,
-            params=_params,
-        )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                request = build_list_by_location_request(
+                    location=location,
+                    subscription_id=self._config.subscription_id,
+                    api_version=api_version,
+                    template_url=self.list_by_location.metadata["url"],
+                    headers=_headers,
+                    params=_params,
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
+
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("ListUsagesResult", pipeline_response)
+            list_of_elem = deserialized.value
+            if cls:
+                list_of_elem = cls(list_of_elem)  # type: ignore
+            return deserialized.next_link or None, iter(list_of_elem)
+
+        def get_next(next_link=None):
+            request = prepare_request(next_link)
+
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
+            )
+            response = pipeline_response.http_response
+
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("CheckNameAvailabilityResponse", pipeline_response)
+            return pipeline_response
 
-        if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+        return ItemPaged(get_next, extract_data)
 
-        return deserialized  # type: ignore
+    list_by_location.metadata = {
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.DevCenter/locations/{location}/usages"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_dev_box_definitions_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_dev_box_definitions_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -41,15 +41,15 @@
 
 def build_list_by_dev_center_request(
     resource_group_name: str, dev_center_name: str, subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/devboxdefinitions",
     )  # pylint: disable=line-too-long
@@ -83,15 +83,15 @@
 
 def build_get_request(
     resource_group_name: str, dev_center_name: str, dev_box_definition_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/devboxdefinitions/{devBoxDefinitionName}",
     )  # pylint: disable=line-too-long
@@ -131,15 +131,15 @@
 
 def build_create_or_update_request(
     resource_group_name: str, dev_center_name: str, dev_box_definition_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/devboxdefinitions/{devBoxDefinitionName}",
@@ -182,15 +182,15 @@
 
 def build_update_request(
     resource_group_name: str, dev_center_name: str, dev_box_definition_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/devboxdefinitions/{devBoxDefinitionName}",
@@ -233,15 +233,15 @@
 
 def build_delete_request(
     resource_group_name: str, dev_center_name: str, dev_box_definition_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/devboxdefinitions/{devBoxDefinitionName}",
     )  # pylint: disable=line-too-long
@@ -281,15 +281,15 @@
 
 def build_list_by_project_request(
     resource_group_name: str, project_name: str, subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/devboxdefinitions",
     )  # pylint: disable=line-too-long
@@ -323,15 +323,15 @@
 
 def build_get_by_project_request(
     resource_group_name: str, project_name: str, dev_box_definition_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/devboxdefinitions/{devBoxDefinitionName}",
     )  # pylint: disable=line-too-long
@@ -398,14 +398,15 @@
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DevBoxDefinition or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.DevBoxDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -419,82 +420,87 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_dev_center_request(
+                request = build_list_by_dev_center_request(
                     resource_group_name=resource_group_name,
                     dev_center_name=dev_center_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_dev_center.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("DevBoxDefinitionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
+    list_by_dev_center.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/devboxdefinitions"
+    }
+
     @distributed_trace
     def get(
         self, resource_group_name: str, dev_center_name: str, dev_box_definition_name: str, **kwargs: Any
     ) -> _models.DevBoxDefinition:
         """Gets a Dev Box definition.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param dev_box_definition_name: The name of the Dev Box definition. Required.
         :type dev_box_definition_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: DevBoxDefinition or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.DevBoxDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -505,51 +511,55 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.DevBoxDefinition] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             dev_box_definition_name=dev_box_definition_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("DevBoxDefinition", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/devboxdefinitions/{devBoxDefinitionName}"
+    }
 
     def _create_or_update_initial(
         self,
         resource_group_name: str,
         dev_center_name: str,
         dev_box_definition_name: str,
-        body: Union[_models.DevBoxDefinition, IO[bytes]],
+        body: Union[_models.DevBoxDefinition, IO],
         **kwargs: Any
     ) -> _models.DevBoxDefinition:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -567,52 +577,56 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "DevBoxDefinition")
 
-        _request = build_create_or_update_request(
+        request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             dev_box_definition_name=dev_box_definition_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
             deserialized = self._deserialize("DevBoxDefinition", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("DevBoxDefinition", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
+    _create_or_update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/devboxdefinitions/{devBoxDefinitionName}"
+    }
+
     @overload
     def begin_create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         dev_box_definition_name: str,
         body: _models.DevBoxDefinition,
@@ -630,72 +644,99 @@
         :param dev_box_definition_name: The name of the Dev Box definition. Required.
         :type dev_box_definition_name: str
         :param body: Represents a Dev Box definition. Required.
         :type body: ~azure.mgmt.devcenter.models.DevBoxDefinition
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either DevBoxDefinition or the result of
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.DevBoxDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         dev_box_definition_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.DevBoxDefinition]:
         """Creates or updates a Dev Box definition.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param dev_box_definition_name: The name of the Dev Box definition. Required.
         :type dev_box_definition_name: str
         :param body: Represents a Dev Box definition. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either DevBoxDefinition or the result of
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.DevBoxDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         dev_box_definition_name: str,
-        body: Union[_models.DevBoxDefinition, IO[bytes]],
+        body: Union[_models.DevBoxDefinition, IO],
         **kwargs: Any
     ) -> LROPoller[_models.DevBoxDefinition]:
         """Creates or updates a Dev Box definition.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param dev_box_definition_name: The name of the Dev Box definition. Required.
         :type dev_box_definition_name: str
-        :param body: Represents a Dev Box definition. Is either a DevBoxDefinition type or a IO[bytes]
-         type. Required.
-        :type body: ~azure.mgmt.devcenter.models.DevBoxDefinition or IO[bytes]
+        :param body: Represents a Dev Box definition. Is either a DevBoxDefinition type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.devcenter.models.DevBoxDefinition or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either DevBoxDefinition or the result of
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.DevBoxDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
@@ -720,42 +761,44 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("DevBoxDefinition", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[_models.DevBoxDefinition].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[_models.DevBoxDefinition](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_create_or_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/devboxdefinitions/{devBoxDefinitionName}"
+    }
 
     def _update_initial(
         self,
         resource_group_name: str,
         dev_center_name: str,
         dev_box_definition_name: str,
-        body: Union[_models.DevBoxDefinitionUpdate, IO[bytes]],
+        body: Union[_models.DevBoxDefinitionUpdate, IO],
         **kwargs: Any
     ) -> Optional[_models.DevBoxDefinition]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -773,53 +816,53 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "DevBoxDefinitionUpdate")
 
-        _request = build_update_request(
+        request = build_update_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             dev_box_definition_name=dev_box_definition_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = None
-        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("DevBoxDefinition", pipeline_response)
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    _update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/devboxdefinitions/{devBoxDefinitionName}"
+    }
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         dev_box_definition_name: str,
@@ -838,72 +881,99 @@
         :param dev_box_definition_name: The name of the Dev Box definition. Required.
         :type dev_box_definition_name: str
         :param body: Represents a Dev Box definition. Required.
         :type body: ~azure.mgmt.devcenter.models.DevBoxDefinitionUpdate
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either DevBoxDefinition or the result of
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.DevBoxDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         dev_box_definition_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.DevBoxDefinition]:
         """Partially updates a Dev Box definition.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param dev_box_definition_name: The name of the Dev Box definition. Required.
         :type dev_box_definition_name: str
         :param body: Represents a Dev Box definition. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either DevBoxDefinition or the result of
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.DevBoxDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         dev_box_definition_name: str,
-        body: Union[_models.DevBoxDefinitionUpdate, IO[bytes]],
+        body: Union[_models.DevBoxDefinitionUpdate, IO],
         **kwargs: Any
     ) -> LROPoller[_models.DevBoxDefinition]:
         """Partially updates a Dev Box definition.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param dev_box_definition_name: The name of the Dev Box definition. Required.
         :type dev_box_definition_name: str
-        :param body: Represents a Dev Box definition. Is either a DevBoxDefinitionUpdate type or a
-         IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.DevBoxDefinitionUpdate or IO[bytes]
+        :param body: Represents a Dev Box definition. Is either a DevBoxDefinitionUpdate type or a IO
+         type. Required.
+        :type body: ~azure.mgmt.devcenter.models.DevBoxDefinitionUpdate or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either DevBoxDefinition or the result of
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.DevBoxDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
@@ -928,35 +998,37 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("DevBoxDefinition", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[_models.DevBoxDefinition].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[_models.DevBoxDefinition](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/devboxdefinitions/{devBoxDefinitionName}"
+    }
 
     def _delete_initial(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, dev_center_name: str, dev_box_definition_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -967,58 +1039,66 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_delete_request(
+        request = build_delete_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             dev_box_definition_name=dev_box_definition_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
+            return cls(pipeline_response, None, {})
+
+    _delete_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/devboxdefinitions/{devBoxDefinitionName}"
+    }
 
     @distributed_trace
     def begin_delete(
         self, resource_group_name: str, dev_center_name: str, dev_box_definition_name: str, **kwargs: Any
     ) -> LROPoller[None]:
         """Deletes a Dev Box definition.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param dev_box_definition_name: The name of the Dev Box definition. Required.
         :type dev_box_definition_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -1038,32 +1118,36 @@
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[None].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_delete.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/devboxdefinitions/{devBoxDefinitionName}"
+    }
 
     @distributed_trace
     def list_by_project(
         self, resource_group_name: str, project_name: str, top: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.DevBoxDefinition"]:
         """List Dev Box definitions configured for a project.
 
@@ -1071,14 +1155,15 @@
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DevBoxDefinition or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.DevBoxDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -1092,82 +1177,87 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_project_request(
+                request = build_list_by_project_request(
                     resource_group_name=resource_group_name,
                     project_name=project_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_project.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("DevBoxDefinitionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
+    list_by_project.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/devboxdefinitions"
+    }
+
     @distributed_trace
     def get_by_project(
         self, resource_group_name: str, project_name: str, dev_box_definition_name: str, **kwargs: Any
     ) -> _models.DevBoxDefinition:
         """Gets a Dev Box definition configured for a project.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param dev_box_definition_name: The name of the Dev Box definition. Required.
         :type dev_box_definition_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: DevBoxDefinition or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.DevBoxDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -1178,37 +1268,41 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.DevBoxDefinition] = kwargs.pop("cls", None)
 
-        _request = build_get_by_project_request(
+        request = build_get_by_project_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             dev_box_definition_name=dev_box_definition_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get_by_project.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("DevBoxDefinition", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    get_by_project.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/devboxdefinitions/{devBoxDefinitionName}"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_dev_centers_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_dev_centers_operations.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -41,15 +41,15 @@
 
 def build_list_by_subscription_request(
     subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.DevCenter/devcenters")
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
@@ -69,15 +69,15 @@
 
 def build_list_by_resource_group_request(
     resource_group_name: str, subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters",
     )  # pylint: disable=line-too-long
@@ -103,15 +103,15 @@
 
 def build_get_request(
     resource_group_name: str, dev_center_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}",
     )  # pylint: disable=line-too-long
@@ -143,15 +143,15 @@
 
 def build_create_or_update_request(
     resource_group_name: str, dev_center_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}",
@@ -186,15 +186,15 @@
 
 def build_update_request(
     resource_group_name: str, dev_center_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}",
@@ -229,15 +229,15 @@
 
 def build_delete_request(
     resource_group_name: str, dev_center_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}",
     )  # pylint: disable=line-too-long
@@ -289,14 +289,15 @@
     @distributed_trace
     def list_by_subscription(self, top: Optional[int] = None, **kwargs: Any) -> Iterable["_models.DevCenter"]:
         """Lists all devcenters in a subscription.
 
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DevCenter or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.DevCenter]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -310,79 +311,82 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_subscription_request(
+                request = build_list_by_subscription_request(
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_subscription.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("DevCenterListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
+    list_by_subscription.metadata = {"url": "/subscriptions/{subscriptionId}/providers/Microsoft.DevCenter/devcenters"}
+
     @distributed_trace
     def list_by_resource_group(
         self, resource_group_name: str, top: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.DevCenter"]:
         """Lists all devcenters in a resource group.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DevCenter or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.DevCenter]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -396,77 +400,82 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_resource_group_request(
+                request = build_list_by_resource_group_request(
                     resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_resource_group.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("DevCenterListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
+    list_by_resource_group.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters"
+    }
+
     @distributed_trace
     def get(self, resource_group_name: str, dev_center_name: str, **kwargs: Any) -> _models.DevCenter:
         """Gets a devcenter.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: DevCenter or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.DevCenter
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -477,46 +486,50 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.DevCenter] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("DevCenter", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}"
+    }
 
     def _create_or_update_initial(
-        self, resource_group_name: str, dev_center_name: str, body: Union[_models.DevCenter, IO[bytes]], **kwargs: Any
+        self, resource_group_name: str, dev_center_name: str, body: Union[_models.DevCenter, IO], **kwargs: Any
     ) -> _models.DevCenter:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -533,51 +546,55 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "DevCenter")
 
-        _request = build_create_or_update_request(
+        request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
             deserialized = self._deserialize("DevCenter", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("DevCenter", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
+    _create_or_update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}"
+    }
+
     @overload
     def begin_create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         body: _models.DevCenter,
         *,
@@ -592,59 +609,86 @@
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param body: Represents a devcenter. Required.
         :type body: ~azure.mgmt.devcenter.models.DevCenter
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either DevCenter or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.DevCenter]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.DevCenter]:
         """Creates or updates a devcenter resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param body: Represents a devcenter. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either DevCenter or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.DevCenter]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create_or_update(
-        self, resource_group_name: str, dev_center_name: str, body: Union[_models.DevCenter, IO[bytes]], **kwargs: Any
+        self, resource_group_name: str, dev_center_name: str, body: Union[_models.DevCenter, IO], **kwargs: Any
     ) -> LROPoller[_models.DevCenter]:
         """Creates or updates a devcenter resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
-        :param body: Represents a devcenter. Is either a DevCenter type or a IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.DevCenter or IO[bytes]
+        :param body: Represents a devcenter. Is either a DevCenter type or a IO type. Required.
+        :type body: ~azure.mgmt.devcenter.models.DevCenter or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either DevCenter or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.DevCenter]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -667,42 +711,40 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("DevCenter", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[_models.DevCenter].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[_models.DevCenter](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_create_or_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}"
+    }
 
     def _update_initial(
-        self,
-        resource_group_name: str,
-        dev_center_name: str,
-        body: Union[_models.DevCenterUpdate, IO[bytes]],
-        **kwargs: Any
+        self, resource_group_name: str, dev_center_name: str, body: Union[_models.DevCenterUpdate, IO], **kwargs: Any
     ) -> Optional[_models.DevCenter]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -719,52 +761,52 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "DevCenterUpdate")
 
-        _request = build_update_request(
+        request = build_update_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = None
-        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("DevCenter", pipeline_response)
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    _update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}"
+    }
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         body: _models.DevCenterUpdate,
@@ -780,64 +822,87 @@
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param body: Updatable devcenter properties. Required.
         :type body: ~azure.mgmt.devcenter.models.DevCenterUpdate
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either DevCenter or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.DevCenter]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.DevCenter]:
         """Partially updates a devcenter.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param body: Updatable devcenter properties. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either DevCenter or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.DevCenter]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_update(
-        self,
-        resource_group_name: str,
-        dev_center_name: str,
-        body: Union[_models.DevCenterUpdate, IO[bytes]],
-        **kwargs: Any
+        self, resource_group_name: str, dev_center_name: str, body: Union[_models.DevCenterUpdate, IO], **kwargs: Any
     ) -> LROPoller[_models.DevCenter]:
         """Partially updates a devcenter.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
-        :param body: Updatable devcenter properties. Is either a DevCenterUpdate type or a IO[bytes]
-         type. Required.
-        :type body: ~azure.mgmt.devcenter.models.DevCenterUpdate or IO[bytes]
+        :param body: Updatable devcenter properties. Is either a DevCenterUpdate type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.devcenter.models.DevCenterUpdate or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either DevCenter or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.DevCenter]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -860,35 +925,37 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("DevCenter", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[_models.DevCenter].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[_models.DevCenter](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}"
+    }
 
     def _delete_initial(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, dev_center_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -899,53 +966,61 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_delete_request(
+        request = build_delete_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
+            return cls(pipeline_response, None, {})
+
+    _delete_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}"
+    }
 
     @distributed_trace
     def begin_delete(self, resource_group_name: str, dev_center_name: str, **kwargs: Any) -> LROPoller[None]:
         """Deletes a devcenter.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -964,25 +1039,29 @@
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[None].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_delete.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_environment_definitions_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_environment_definitions_operations.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -32,136 +32,27 @@
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_by_project_catalog_request(
-    resource_group_name: str, project_name: str, catalog_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/catalogs/{catalogName}/environmentDefinitions",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "projectName": _SERIALIZER.url(
-            "project_name",
-            project_name,
-            "str",
-            max_length=63,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
-        ),
-        "catalogName": _SERIALIZER.url(
-            "catalog_name",
-            catalog_name,
-            "str",
-            max_length=63,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
-        ),
-    }
-
-    _url: str = _url.format(**path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_get_by_project_catalog_request(
-    resource_group_name: str,
-    project_name: str,
-    catalog_name: str,
-    environment_definition_name: str,
-    subscription_id: str,
-    **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/catalogs/{catalogName}/environmentDefinitions/{environmentDefinitionName}",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "projectName": _SERIALIZER.url(
-            "project_name",
-            project_name,
-            "str",
-            max_length=63,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
-        ),
-        "catalogName": _SERIALIZER.url(
-            "catalog_name",
-            catalog_name,
-            "str",
-            max_length=63,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
-        ),
-        "environmentDefinitionName": _SERIALIZER.url(
-            "environment_definition_name",
-            environment_definition_name,
-            "str",
-            max_length=63,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
-        ),
-    }
-
-    _url: str = _url.format(**path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
-
-
 def build_list_by_catalog_request(
     resource_group_name: str,
     dev_center_name: str,
     catalog_name: str,
     subscription_id: str,
     *,
     top: Optional[int] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/environmentDefinitions",
     )  # pylint: disable=line-too-long
@@ -208,15 +99,15 @@
     environment_definition_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/environmentDefinitions/{environmentDefinitionName}",
     )  # pylint: disable=line-too-long
@@ -269,15 +160,15 @@
     environment_definition_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/environmentDefinitions/{environmentDefinitionName}/getErrorDetails",
     )  # pylint: disable=line-too-long
@@ -339,174 +230,14 @@
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def list_by_project_catalog(
-        self, resource_group_name: str, project_name: str, catalog_name: str, **kwargs: Any
-    ) -> Iterable["_models.EnvironmentDefinition"]:
-        """Lists the environment definitions in this project catalog.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param project_name: The name of the project. Required.
-        :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :return: An iterator like instance of either EnvironmentDefinition or the result of
-         cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.EnvironmentDefinition]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.EnvironmentDefinitionListResult] = kwargs.pop("cls", None)
-
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        def prepare_request(next_link=None):
-            if not next_link:
-
-                _request = build_list_by_project_catalog_request(
-                    resource_group_name=resource_group_name,
-                    project_name=project_name,
-                    catalog_name=catalog_name,
-                    subscription_id=self._config.subscription_id,
-                    api_version=api_version,
-                    headers=_headers,
-                    params=_params,
-                )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-
-            else:
-                # make call to next link with the client's api-version
-                _parsed_next_link = urllib.parse.urlparse(next_link)
-                _next_request_params = case_insensitive_dict(
-                    {
-                        key: [urllib.parse.quote(v) for v in value]
-                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
-                    }
-                )
-                _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
-                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
-                )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
-
-        def extract_data(pipeline_response):
-            deserialized = self._deserialize("EnvironmentDefinitionListResult", pipeline_response)
-            list_of_elem = deserialized.value
-            if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, iter(list_of_elem)
-
-        def get_next(next_link=None):
-            _request = prepare_request(next_link)
-
-            _stream = False
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
-            )
-            response = pipeline_response.http_response
-
-            if response.status_code not in [200]:
-                map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-            return pipeline_response
-
-        return ItemPaged(get_next, extract_data)
-
-    @distributed_trace
-    def get_by_project_catalog(
-        self,
-        resource_group_name: str,
-        project_name: str,
-        catalog_name: str,
-        environment_definition_name: str,
-        **kwargs: Any
-    ) -> _models.EnvironmentDefinition:
-        """Gets an environment definition from the catalog.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param project_name: The name of the project. Required.
-        :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :param environment_definition_name: The name of the Environment Definition. Required.
-        :type environment_definition_name: str
-        :return: EnvironmentDefinition or the result of cls(response)
-        :rtype: ~azure.mgmt.devcenter.models.EnvironmentDefinition
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.EnvironmentDefinition] = kwargs.pop("cls", None)
-
-        _request = build_get_by_project_catalog_request(
-            resource_group_name=resource_group_name,
-            project_name=project_name,
-            catalog_name=catalog_name,
-            environment_definition_name=environment_definition_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            headers=_headers,
-            params=_params,
-        )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        deserialized = self._deserialize("EnvironmentDefinition", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
-
-        return deserialized  # type: ignore
-
-    @distributed_trace
     def list_by_catalog(
         self,
         resource_group_name: str,
         dev_center_name: str,
         catalog_name: str,
         top: Optional[int] = None,
         **kwargs: Any
@@ -519,14 +250,15 @@
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param catalog_name: The name of the Catalog. Required.
         :type catalog_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either EnvironmentDefinition or the result of
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.EnvironmentDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
@@ -541,70 +273,74 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_catalog_request(
+                request = build_list_by_catalog_request(
                     resource_group_name=resource_group_name,
                     dev_center_name=dev_center_name,
                     catalog_name=catalog_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_catalog.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("EnvironmentDefinitionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
+    list_by_catalog.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/environmentDefinitions"
+    }
+
     @distributed_trace
     def get(
         self,
         resource_group_name: str,
         dev_center_name: str,
         catalog_name: str,
         environment_definition_name: str,
@@ -617,14 +353,15 @@
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param catalog_name: The name of the Catalog. Required.
         :type catalog_name: str
         :param environment_definition_name: The name of the Environment Definition. Required.
         :type environment_definition_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: EnvironmentDefinition or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.EnvironmentDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -635,45 +372,49 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.EnvironmentDefinition] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             catalog_name=catalog_name,
             environment_definition_name=environment_definition_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("EnvironmentDefinition", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/environmentDefinitions/{environmentDefinitionName}"
+    }
 
     @distributed_trace
     def get_error_details(
         self,
         resource_group_name: str,
         dev_center_name: str,
         catalog_name: str,
@@ -687,14 +428,15 @@
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param catalog_name: The name of the Catalog. Required.
         :type catalog_name: str
         :param environment_definition_name: The name of the Environment Definition. Required.
         :type environment_definition_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CatalogResourceValidationErrorDetails or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.CatalogResourceValidationErrorDetails
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -705,38 +447,42 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.CatalogResourceValidationErrorDetails] = kwargs.pop("cls", None)
 
-        _request = build_get_error_details_request(
+        request = build_get_error_details_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             catalog_name=catalog_name,
             environment_definition_name=environment_definition_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get_error_details.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CatalogResourceValidationErrorDetails", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-        return deserialized  # type: ignore
+    get_error_details.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/environmentDefinitions/{environmentDefinitionName}/getErrorDetails"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_environment_types_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_environment_types_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -39,15 +39,15 @@
 
 def build_list_by_dev_center_request(
     resource_group_name: str, dev_center_name: str, subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/environmentTypes",
     )  # pylint: disable=line-too-long
@@ -81,15 +81,15 @@
 
 def build_get_request(
     resource_group_name: str, dev_center_name: str, environment_type_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/environmentTypes/{environmentTypeName}",
     )  # pylint: disable=line-too-long
@@ -129,15 +129,15 @@
 
 def build_create_or_update_request(
     resource_group_name: str, dev_center_name: str, environment_type_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/environmentTypes/{environmentTypeName}",
@@ -180,15 +180,15 @@
 
 def build_update_request(
     resource_group_name: str, dev_center_name: str, environment_type_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/environmentTypes/{environmentTypeName}",
@@ -231,15 +231,15 @@
 
 def build_delete_request(
     resource_group_name: str, dev_center_name: str, environment_type_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/environmentTypes/{environmentTypeName}",
     )  # pylint: disable=line-too-long
@@ -306,14 +306,15 @@
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either EnvironmentType or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.EnvironmentType]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -327,82 +328,87 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_dev_center_request(
+                request = build_list_by_dev_center_request(
                     resource_group_name=resource_group_name,
                     dev_center_name=dev_center_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_dev_center.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("EnvironmentTypeListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
+    list_by_dev_center.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/environmentTypes"
+    }
+
     @distributed_trace
     def get(
         self, resource_group_name: str, dev_center_name: str, environment_type_name: str, **kwargs: Any
     ) -> _models.EnvironmentType:
         """Gets an environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: EnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.EnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -413,44 +419,48 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.EnvironmentType] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             environment_type_name=environment_type_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("EnvironmentType", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/environmentTypes/{environmentTypeName}"
+    }
 
     @overload
     def create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         environment_type_name: str,
@@ -469,70 +479,76 @@
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
         :param body: Represents an Environment Type. Required.
         :type body: ~azure.mgmt.devcenter.models.EnvironmentType
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: EnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.EnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         environment_type_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.EnvironmentType:
         """Creates or updates an environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
         :param body: Represents an Environment Type. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: EnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.EnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def create_or_update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         environment_type_name: str,
-        body: Union[_models.EnvironmentType, IO[bytes]],
+        body: Union[_models.EnvironmentType, IO],
         **kwargs: Any
     ) -> _models.EnvironmentType:
         """Creates or updates an environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
-        :param body: Represents an Environment Type. Is either a EnvironmentType type or a IO[bytes]
-         type. Required.
-        :type body: ~azure.mgmt.devcenter.models.EnvironmentType or IO[bytes]
+        :param body: Represents an Environment Type. Is either a EnvironmentType type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.devcenter.models.EnvironmentType or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: EnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.EnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -552,51 +568,51 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "EnvironmentType")
 
-        _request = build_create_or_update_request(
+        request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             environment_type_name=environment_type_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 201]:
+        if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        if response.status_code == 200:
-            deserialized = self._deserialize("EnvironmentType", pipeline_response)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        if response.status_code == 201:
-            deserialized = self._deserialize("EnvironmentType", pipeline_response)
+        deserialized = self._deserialize("EnvironmentType", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-        return deserialized  # type: ignore
+    create_or_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/environmentTypes/{environmentTypeName}"
+    }
 
     @overload
     def update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         environment_type_name: str,
@@ -615,70 +631,76 @@
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
         :param body: Updatable environment type properties. Required.
         :type body: ~azure.mgmt.devcenter.models.EnvironmentTypeUpdate
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: EnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.EnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         environment_type_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.EnvironmentType:
         """Partially updates an environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
         :param body: Updatable environment type properties. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: EnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.EnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def update(
         self,
         resource_group_name: str,
         dev_center_name: str,
         environment_type_name: str,
-        body: Union[_models.EnvironmentTypeUpdate, IO[bytes]],
+        body: Union[_models.EnvironmentTypeUpdate, IO],
         **kwargs: Any
     ) -> _models.EnvironmentType:
         """Partially updates an environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
         :param body: Updatable environment type properties. Is either a EnvironmentTypeUpdate type or a
-         IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.EnvironmentTypeUpdate or IO[bytes]
+         IO type. Required.
+        :type body: ~azure.mgmt.devcenter.models.EnvironmentTypeUpdate or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: EnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.EnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -698,61 +720,66 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "EnvironmentTypeUpdate")
 
-        _request = build_update_request(
+        request = build_update_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             environment_type_name=environment_type_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("EnvironmentType", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/environmentTypes/{environmentTypeName}"
+    }
 
     @distributed_trace
     def delete(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, dev_center_name: str, environment_type_name: str, **kwargs: Any
     ) -> None:
         """Deletes an environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -763,33 +790,37 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_delete_request(
+        request = build_delete_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             environment_type_name=environment_type_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})  # type: ignore
+            return cls(pipeline_response, None, {})
+
+    delete.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/environmentTypes/{environmentTypeName}"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_galleries_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_catalog_dev_box_definitions_operations.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,75 +1,86 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-from io import IOBase
-from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
+from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
 from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import HttpResponse
-from azure.core.polling import LROPoller, NoPolling, PollingMethod
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
-from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_by_dev_center_request(
-    resource_group_name: str, dev_center_name: str, subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
+def build_list_by_catalog_request(
+    resource_group_name: str,
+    dev_center_name: str,
+    catalog_name: str,
+    subscription_id: str,
+    *,
+    top: Optional[int] = None,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/devboxdefinitions",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
         "devCenterName": _SERIALIZER.url(
             "dev_center_name",
             dev_center_name,
             "str",
             max_length=26,
             min_length=3,
             pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-]{2,25}$",
         ),
+        "catalogName": _SERIALIZER.url(
+            "catalog_name",
+            catalog_name,
+            "str",
+            max_length=63,
+            min_length=3,
+            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
+        ),
     }
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
     if top is not None:
@@ -78,43 +89,56 @@
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(
-    resource_group_name: str, dev_center_name: str, gallery_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str,
+    dev_center_name: str,
+    catalog_name: str,
+    dev_box_definition_name: str,
+    subscription_id: str,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/devboxdefinitions/{devBoxDefinitionName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
         "devCenterName": _SERIALIZER.url(
             "dev_center_name",
             dev_center_name,
             "str",
             max_length=26,
             min_length=3,
             pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-]{2,25}$",
         ),
-        "galleryName": _SERIALIZER.url(
-            "gallery_name",
-            gallery_name,
+        "catalogName": _SERIALIZER.url(
+            "catalog_name",
+            catalog_name,
+            "str",
+            max_length=63,
+            min_length=3,
+            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
+        ),
+        "devBoxDefinitionName": _SERIALIZER.url(
+            "dev_box_definition_name",
+            dev_box_definition_name,
             "str",
             max_length=63,
             min_length=3,
             pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
         ),
     }
 
@@ -125,95 +149,57 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_create_or_update_request(
-    resource_group_name: str, dev_center_name: str, gallery_name: str, subscription_id: str, **kwargs: Any
+def build_get_error_details_request(
+    resource_group_name: str,
+    dev_center_name: str,
+    catalog_name: str,
+    dev_box_definition_name: str,
+    subscription_id: str,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/devboxdefinitions/{devBoxDefinitionName}/getErrorDetails",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
         "devCenterName": _SERIALIZER.url(
             "dev_center_name",
             dev_center_name,
             "str",
             max_length=26,
             min_length=3,
             pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-]{2,25}$",
         ),
-        "galleryName": _SERIALIZER.url(
-            "gallery_name",
-            gallery_name,
+        "catalogName": _SERIALIZER.url(
+            "catalog_name",
+            catalog_name,
             "str",
             max_length=63,
             min_length=3,
             pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
         ),
-    }
-
-    _url: str = _url.format(**path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    if content_type is not None:
-        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_delete_request(
-    resource_group_name: str, dev_center_name: str, gallery_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "devCenterName": _SERIALIZER.url(
-            "dev_center_name",
-            dev_center_name,
-            "str",
-            max_length=26,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-]{2,25}$",
-        ),
-        "galleryName": _SERIALIZER.url(
-            "gallery_name",
-            gallery_name,
+        "devBoxDefinitionName": _SERIALIZER.url(
+            "dev_box_definition_name",
+            dev_box_definition_name,
             "str",
             max_length=63,
             min_length=3,
             pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
         ),
     }
 
@@ -221,487 +207,281 @@
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
-    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class GalleriesOperations:
+class CatalogDevBoxDefinitionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.devcenter.DevCenterMgmtClient`'s
-        :attr:`galleries` attribute.
+        :attr:`catalog_dev_box_definitions` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def list_by_dev_center(
-        self, resource_group_name: str, dev_center_name: str, top: Optional[int] = None, **kwargs: Any
-    ) -> Iterable["_models.Gallery"]:
-        """Lists galleries for a devcenter.
+    def list_by_catalog(
+        self,
+        resource_group_name: str,
+        dev_center_name: str,
+        catalog_name: str,
+        top: Optional[int] = None,
+        **kwargs: Any
+    ) -> Iterable["_models.DevBoxDefinition"]:
+        """List Dev Box definitions in the catalog.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
+        :param catalog_name: The name of the Catalog. Required.
+        :type catalog_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
-        :return: An iterator like instance of either Gallery or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.Gallery]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: An iterator like instance of either DevBoxDefinition or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.DevBoxDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.GalleryListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.DevBoxDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_dev_center_request(
+                request = build_list_by_catalog_request(
                     resource_group_name=resource_group_name,
                     dev_center_name=dev_center_name,
+                    catalog_name=catalog_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_catalog.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("GalleryListResult", pipeline_response)
+            deserialized = self._deserialize("DevBoxDefinitionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
+    list_by_catalog.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/devboxdefinitions"
+    }
+
     @distributed_trace
-    def get(self, resource_group_name: str, dev_center_name: str, gallery_name: str, **kwargs: Any) -> _models.Gallery:
-        """Gets a gallery.
+    def get(
+        self,
+        resource_group_name: str,
+        dev_center_name: str,
+        catalog_name: str,
+        dev_box_definition_name: str,
+        **kwargs: Any
+    ) -> _models.DevBoxDefinition:
+        """Gets a Dev Box definition from the catalog.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
-        :param gallery_name: The name of the gallery. Required.
-        :type gallery_name: str
-        :return: Gallery or the result of cls(response)
-        :rtype: ~azure.mgmt.devcenter.models.Gallery
+        :param catalog_name: The name of the Catalog. Required.
+        :type catalog_name: str
+        :param dev_box_definition_name: The name of the Dev Box definition. Required.
+        :type dev_box_definition_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: DevBoxDefinition or the result of cls(response)
+        :rtype: ~azure.mgmt.devcenter.models.DevBoxDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.Gallery] = kwargs.pop("cls", None)
+        cls: ClsType[_models.DevBoxDefinition] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
-            gallery_name=gallery_name,
+            catalog_name=catalog_name,
+            dev_box_definition_name=dev_box_definition_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        deserialized = self._deserialize("Gallery", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
-
-        return deserialized  # type: ignore
-
-    def _create_or_update_initial(
-        self,
-        resource_group_name: str,
-        dev_center_name: str,
-        gallery_name: str,
-        body: Union[_models.Gallery, IO[bytes]],
-        **kwargs: Any
-    ) -> _models.Gallery:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.Gallery] = kwargs.pop("cls", None)
-
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(body, (IOBase, bytes)):
-            _content = body
-        else:
-            _json = self._serialize.body(body, "Gallery")
-
-        _request = build_create_or_update_request(
-            resource_group_name=resource_group_name,
-            dev_center_name=dev_center_name,
-            gallery_name=gallery_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            headers=_headers,
-            params=_params,
-        )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200, 201]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        if response.status_code == 200:
-            deserialized = self._deserialize("Gallery", pipeline_response)
-
-        if response.status_code == 201:
-            deserialized = self._deserialize("Gallery", pipeline_response)
+        deserialized = self._deserialize("DevBoxDefinition", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-    @overload
-    def begin_create_or_update(
-        self,
-        resource_group_name: str,
-        dev_center_name: str,
-        gallery_name: str,
-        body: _models.Gallery,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> LROPoller[_models.Gallery]:
-        """Creates or updates a gallery.
+        return deserialized
 
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param dev_center_name: The name of the devcenter. Required.
-        :type dev_center_name: str
-        :param gallery_name: The name of the gallery. Required.
-        :type gallery_name: str
-        :param body: Represents a gallery. Required.
-        :type body: ~azure.mgmt.devcenter.models.Gallery
-        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :return: An instance of LROPoller that returns either Gallery or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Gallery]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @overload
-    def begin_create_or_update(
-        self,
-        resource_group_name: str,
-        dev_center_name: str,
-        gallery_name: str,
-        body: IO[bytes],
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> LROPoller[_models.Gallery]:
-        """Creates or updates a gallery.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param dev_center_name: The name of the devcenter. Required.
-        :type dev_center_name: str
-        :param gallery_name: The name of the gallery. Required.
-        :type gallery_name: str
-        :param body: Represents a gallery. Required.
-        :type body: IO[bytes]
-        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :return: An instance of LROPoller that returns either Gallery or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Gallery]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/devboxdefinitions/{devBoxDefinitionName}"
+    }
 
     @distributed_trace
-    def begin_create_or_update(
+    def get_error_details(
         self,
         resource_group_name: str,
         dev_center_name: str,
-        gallery_name: str,
-        body: Union[_models.Gallery, IO[bytes]],
+        catalog_name: str,
+        dev_box_definition_name: str,
         **kwargs: Any
-    ) -> LROPoller[_models.Gallery]:
-        """Creates or updates a gallery.
+    ) -> _models.CatalogResourceValidationErrorDetails:
+        """Gets Catalog Devbox Definition error details.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
-        :param gallery_name: The name of the gallery. Required.
-        :type gallery_name: str
-        :param body: Represents a gallery. Is either a Gallery type or a IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.Gallery or IO[bytes]
-        :return: An instance of LROPoller that returns either Gallery or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Gallery]
+        :param catalog_name: The name of the Catalog. Required.
+        :type catalog_name: str
+        :param dev_box_definition_name: The name of the Dev Box definition. Required.
+        :type dev_box_definition_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: CatalogResourceValidationErrorDetails or the result of cls(response)
+        :rtype: ~azure.mgmt.devcenter.models.CatalogResourceValidationErrorDetails
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.Gallery] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = self._create_or_update_initial(
-                resource_group_name=resource_group_name,
-                dev_center_name=dev_center_name,
-                gallery_name=gallery_name,
-                body=body,
-                api_version=api_version,
-                content_type=content_type,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("Gallery", pipeline_response)
-            if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
-            return deserialized
-
-        if polling is True:
-            polling_method: PollingMethod = cast(
-                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
-            )
-        elif polling is False:
-            polling_method = cast(PollingMethod, NoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return LROPoller[_models.Gallery].from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return LROPoller[_models.Gallery](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
-
-    def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, dev_center_name: str, gallery_name: str, **kwargs: Any
-    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
+        cls: ClsType[_models.CatalogResourceValidationErrorDetails] = kwargs.pop("cls", None)
 
-        _request = build_delete_request(
+        request = build_get_error_details_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
-            gallery_name=gallery_name,
+            catalog_name=catalog_name,
+            dev_box_definition_name=dev_box_definition_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get_error_details.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+        deserialized = self._deserialize("CatalogResourceValidationErrorDetails", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-    @distributed_trace
-    def begin_delete(
-        self, resource_group_name: str, dev_center_name: str, gallery_name: str, **kwargs: Any
-    ) -> LROPoller[None]:
-        """Deletes a gallery resource.
+        return deserialized
 
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param dev_center_name: The name of the devcenter. Required.
-        :type dev_center_name: str
-        :param gallery_name: The name of the gallery. Required.
-        :type gallery_name: str
-        :return: An instance of LROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[None]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = self._delete_initial(  # type: ignore
-                resource_group_name=resource_group_name,
-                dev_center_name=dev_center_name,
-                gallery_name=gallery_name,
-                api_version=api_version,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
-            if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
-
-        if polling is True:
-            polling_method: PollingMethod = cast(
-                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
-            )
-        elif polling is False:
-            polling_method = cast(PollingMethod, NoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return LROPoller[None].from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+    get_error_details.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/devboxdefinitions/{devBoxDefinitionName}/getErrorDetails"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_image_versions_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_image_versions_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -43,15 +43,15 @@
     image_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}/images/{imageName}/versions",
     )  # pylint: disable=line-too-long
@@ -72,22 +72,15 @@
             "gallery_name",
             gallery_name,
             "str",
             max_length=63,
             min_length=3,
             pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
         ),
-        "imageName": _SERIALIZER.url(
-            "image_name",
-            image_name,
-            "str",
-            max_length=80,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-.]{0,78}[a-zA-Z0-9]$",
-        ),
+        "imageName": _SERIALIZER.url("image_name", image_name, "str"),
     }
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -105,15 +98,15 @@
     version_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}/images/{imageName}/versions/{versionName}",
     )  # pylint: disable=line-too-long
@@ -134,30 +127,16 @@
             "gallery_name",
             gallery_name,
             "str",
             max_length=63,
             min_length=3,
             pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
         ),
-        "imageName": _SERIALIZER.url(
-            "image_name",
-            image_name,
-            "str",
-            max_length=80,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-.]{0,78}[a-zA-Z0-9]$",
-        ),
-        "versionName": _SERIALIZER.url(
-            "version_name",
-            version_name,
-            "str",
-            max_length=32,
-            min_length=5,
-            pattern=r"^[0-9]{1,10}[.][0-9]{1,10}[.][0-9]{1,10}$",
-        ),
+        "imageName": _SERIALIZER.url("image_name", image_name, "str"),
+        "versionName": _SERIALIZER.url("version_name", version_name, "str"),
     }
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -197,14 +176,15 @@
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
         :param gallery_name: The name of the gallery. Required.
         :type gallery_name: str
         :param image_name: The name of the image. Required.
         :type image_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either ImageVersion or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.ImageVersion]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -218,70 +198,74 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_image_request(
+                request = build_list_by_image_request(
                     resource_group_name=resource_group_name,
                     dev_center_name=dev_center_name,
                     gallery_name=gallery_name,
                     image_name=image_name,
                     subscription_id=self._config.subscription_id,
                     api_version=api_version,
+                    template_url=self.list_by_image.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("ImageVersionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
+    list_by_image.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}/images/{imageName}/versions"
+    }
+
     @distributed_trace
     def get(
         self,
         resource_group_name: str,
         dev_center_name: str,
         gallery_name: str,
         image_name: str,
@@ -297,14 +281,15 @@
         :type dev_center_name: str
         :param gallery_name: The name of the gallery. Required.
         :type gallery_name: str
         :param image_name: The name of the image. Required.
         :type image_name: str
         :param version_name: The version of the image. Required.
         :type version_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ImageVersion or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.ImageVersion
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -315,39 +300,43 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ImageVersion] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
             gallery_name=gallery_name,
             image_name=image_name,
             version_name=version_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ImageVersion", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-        return deserialized  # type: ignore
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}/images/{imageName}/versions/{versionName}"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_images_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_environment_definitions_operations.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,468 +1,313 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
+from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
-from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import HttpResponse
+from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
+from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from .. import models as _models
-from .._serialization import Serializer
-from .._vendor import _convert_request
+from ... import models as _models
+from ..._vendor import _convert_request
+from ...operations._environment_definitions_operations import (
+    build_get_error_details_request,
+    build_get_request,
+    build_list_by_catalog_request,
+)
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
-
-_SERIALIZER = Serializer()
-_SERIALIZER.client_side_validation = False
-
-
-def build_list_by_dev_center_request(
-    resource_group_name: str, dev_center_name: str, subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/images",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "devCenterName": _SERIALIZER.url(
-            "dev_center_name",
-            dev_center_name,
-            "str",
-            max_length=26,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-]{2,25}$",
-        ),
-    }
-
-    _url: str = _url.format(**path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-    if top is not None:
-        _params["$top"] = _SERIALIZER.query("top", top, "int")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_list_by_gallery_request(
-    resource_group_name: str,
-    dev_center_name: str,
-    gallery_name: str,
-    subscription_id: str,
-    *,
-    top: Optional[int] = None,
-    **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}/images",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "devCenterName": _SERIALIZER.url(
-            "dev_center_name",
-            dev_center_name,
-            "str",
-            max_length=26,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-]{2,25}$",
-        ),
-        "galleryName": _SERIALIZER.url(
-            "gallery_name",
-            gallery_name,
-            "str",
-            max_length=63,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
-        ),
-    }
-
-    _url: str = _url.format(**path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-    if top is not None:
-        _params["$top"] = _SERIALIZER.query("top", top, "int")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_get_request(
-    resource_group_name: str,
-    dev_center_name: str,
-    gallery_name: str,
-    image_name: str,
-    subscription_id: str,
-    **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/galleries/{galleryName}/images/{imageName}",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "devCenterName": _SERIALIZER.url(
-            "dev_center_name",
-            dev_center_name,
-            "str",
-            max_length=26,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-]{2,25}$",
-        ),
-        "galleryName": _SERIALIZER.url(
-            "gallery_name",
-            gallery_name,
-            "str",
-            max_length=63,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
-        ),
-        "imageName": _SERIALIZER.url(
-            "image_name",
-            image_name,
-            "str",
-            max_length=80,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-.]{0,78}[a-zA-Z0-9]$",
-        ),
-    }
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
-    _url: str = _url.format(**path_format_arguments)  # type: ignore
 
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-class ImagesOperations:
+class EnvironmentDefinitionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.devcenter.DevCenterMgmtClient`'s
-        :attr:`images` attribute.
+        :class:`~azure.mgmt.devcenter.aio.DevCenterMgmtClient`'s
+        :attr:`environment_definitions` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def list_by_dev_center(
-        self, resource_group_name: str, dev_center_name: str, top: Optional[int] = None, **kwargs: Any
-    ) -> Iterable["_models.Image"]:
-        """Lists images for a devcenter.
+    def list_by_catalog(
+        self,
+        resource_group_name: str,
+        dev_center_name: str,
+        catalog_name: str,
+        top: Optional[int] = None,
+        **kwargs: Any
+    ) -> AsyncIterable["_models.EnvironmentDefinition"]:
+        """List environment definitions in the catalog.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
+        :param catalog_name: The name of the Catalog. Required.
+        :type catalog_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
-        :return: An iterator like instance of either Image or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.Image]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: An iterator like instance of either EnvironmentDefinition or the result of
+         cls(response)
+        :rtype:
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.EnvironmentDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ImageListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.EnvironmentDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_dev_center_request(
+                request = build_list_by_catalog_request(
                     resource_group_name=resource_group_name,
                     dev_center_name=dev_center_name,
+                    catalog_name=catalog_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_catalog.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
-        def extract_data(pipeline_response):
-            deserialized = self._deserialize("ImageListResult", pipeline_response)
+        async def extract_data(pipeline_response):
+            deserialized = self._deserialize("EnvironmentDefinitionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, iter(list_of_elem)
+            return deserialized.next_link or None, AsyncList(list_of_elem)
 
-        def get_next(next_link=None):
-            _request = prepare_request(next_link)
+        async def get_next(next_link=None):
+            request = prepare_request(next_link)
 
             _stream = False
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return ItemPaged(get_next, extract_data)
+        return AsyncItemPaged(get_next, extract_data)
 
-    @distributed_trace
-    def list_by_gallery(
+    list_by_catalog.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/environmentDefinitions"
+    }
+
+    @distributed_trace_async
+    async def get(
         self,
         resource_group_name: str,
         dev_center_name: str,
-        gallery_name: str,
-        top: Optional[int] = None,
+        catalog_name: str,
+        environment_definition_name: str,
         **kwargs: Any
-    ) -> Iterable["_models.Image"]:
-        """Lists images for a gallery.
+    ) -> _models.EnvironmentDefinition:
+        """Gets an environment definition from the catalog.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
-        :param gallery_name: The name of the gallery. Required.
-        :type gallery_name: str
-        :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
-         Default value is None.
-        :type top: int
-        :return: An iterator like instance of either Image or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.Image]
+        :param catalog_name: The name of the Catalog. Required.
+        :type catalog_name: str
+        :param environment_definition_name: The name of the Environment Definition. Required.
+        :type environment_definition_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: EnvironmentDefinition or the result of cls(response)
+        :rtype: ~azure.mgmt.devcenter.models.EnvironmentDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ImageListResult] = kwargs.pop("cls", None)
-
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        def prepare_request(next_link=None):
-            if not next_link:
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-                _request = build_list_by_gallery_request(
-                    resource_group_name=resource_group_name,
-                    dev_center_name=dev_center_name,
-                    gallery_name=gallery_name,
-                    subscription_id=self._config.subscription_id,
-                    top=top,
-                    api_version=api_version,
-                    headers=_headers,
-                    params=_params,
-                )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.EnvironmentDefinition] = kwargs.pop("cls", None)
 
-            else:
-                # make call to next link with the client's api-version
-                _parsed_next_link = urllib.parse.urlparse(next_link)
-                _next_request_params = case_insensitive_dict(
-                    {
-                        key: [urllib.parse.quote(v) for v in value]
-                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
-                    }
-                )
-                _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
-                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
-                )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+        request = build_get_request(
+            resource_group_name=resource_group_name,
+            dev_center_name=dev_center_name,
+            catalog_name=catalog_name,
+            environment_definition_name=environment_definition_name,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            template_url=self.get.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
-        def extract_data(pipeline_response):
-            deserialized = self._deserialize("ImageListResult", pipeline_response)
-            list_of_elem = deserialized.value
-            if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, iter(list_of_elem)
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
 
-        def get_next(next_link=None):
-            _request = prepare_request(next_link)
+        response = pipeline_response.http_response
 
-            _stream = False
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
-            )
-            response = pipeline_response.http_response
+        if response.status_code not in [200]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-            if response.status_code not in [200]:
-                map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+        deserialized = self._deserialize("EnvironmentDefinition", pipeline_response)
 
-            return pipeline_response
+        if cls:
+            return cls(pipeline_response, deserialized, {})
 
-        return ItemPaged(get_next, extract_data)
+        return deserialized
 
-    @distributed_trace
-    def get(
-        self, resource_group_name: str, dev_center_name: str, gallery_name: str, image_name: str, **kwargs: Any
-    ) -> _models.Image:
-        """Gets a gallery image.
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/environmentDefinitions/{environmentDefinitionName}"
+    }
+
+    @distributed_trace_async
+    async def get_error_details(
+        self,
+        resource_group_name: str,
+        dev_center_name: str,
+        catalog_name: str,
+        environment_definition_name: str,
+        **kwargs: Any
+    ) -> _models.CatalogResourceValidationErrorDetails:
+        """Gets Environment Definition error details.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param dev_center_name: The name of the devcenter. Required.
         :type dev_center_name: str
-        :param gallery_name: The name of the gallery. Required.
-        :type gallery_name: str
-        :param image_name: The name of the image. Required.
-        :type image_name: str
-        :return: Image or the result of cls(response)
-        :rtype: ~azure.mgmt.devcenter.models.Image
+        :param catalog_name: The name of the Catalog. Required.
+        :type catalog_name: str
+        :param environment_definition_name: The name of the Environment Definition. Required.
+        :type environment_definition_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: CatalogResourceValidationErrorDetails or the result of cls(response)
+        :rtype: ~azure.mgmt.devcenter.models.CatalogResourceValidationErrorDetails
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.Image] = kwargs.pop("cls", None)
+        cls: ClsType[_models.CatalogResourceValidationErrorDetails] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_error_details_request(
             resource_group_name=resource_group_name,
             dev_center_name=dev_center_name,
-            gallery_name=gallery_name,
-            image_name=image_name,
+            catalog_name=catalog_name,
+            environment_definition_name=environment_definition_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get_error_details.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("Image", pipeline_response)
+        deserialized = self._deserialize("CatalogResourceValidationErrorDetails", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    get_error_details.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/devcenters/{devCenterName}/catalogs/{catalogName}/environmentDefinitions/{environmentDefinitionName}/getErrorDetails"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_network_connections_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_network_connections_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -41,15 +41,15 @@
 
 def build_list_by_subscription_request(
     subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.DevCenter/networkConnections"
     )
     path_format_arguments = {
@@ -71,15 +71,15 @@
 
 def build_list_by_resource_group_request(
     resource_group_name: str, subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections",
     )  # pylint: disable=line-too-long
@@ -105,15 +105,15 @@
 
 def build_get_request(
     resource_group_name: str, network_connection_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}",
     )  # pylint: disable=line-too-long
@@ -145,15 +145,15 @@
 
 def build_create_or_update_request(
     resource_group_name: str, network_connection_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}",
@@ -188,15 +188,15 @@
 
 def build_update_request(
     resource_group_name: str, network_connection_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}",
@@ -231,15 +231,15 @@
 
 def build_delete_request(
     resource_group_name: str, network_connection_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}",
     )  # pylint: disable=line-too-long
@@ -276,15 +276,15 @@
     *,
     top: Optional[int] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}/healthChecks",
     )  # pylint: disable=line-too-long
@@ -318,15 +318,15 @@
 
 def build_get_health_details_request(
     resource_group_name: str, network_connection_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}/healthChecks/latest",
     )  # pylint: disable=line-too-long
@@ -358,15 +358,15 @@
 
 def build_run_health_checks_request(
     resource_group_name: str, network_connection_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}/runHealthChecks",
     )  # pylint: disable=line-too-long
@@ -392,26 +392,26 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_list_outbound_network_dependencies_endpoints_request(  # pylint: disable=name-too-long
+def build_list_outbound_network_dependencies_endpoints_request(
     resource_group_name: str,
     network_connection_name: str,
     subscription_id: str,
     *,
     top: Optional[int] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}/outboundNetworkDependenciesEndpoints",
     )  # pylint: disable=line-too-long
@@ -465,14 +465,15 @@
     @distributed_trace
     def list_by_subscription(self, top: Optional[int] = None, **kwargs: Any) -> Iterable["_models.NetworkConnection"]:
         """Lists network connections in a subscription.
 
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either NetworkConnection or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.NetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -486,79 +487,84 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_subscription_request(
+                request = build_list_by_subscription_request(
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_subscription.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("NetworkConnectionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
+    list_by_subscription.metadata = {
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.DevCenter/networkConnections"
+    }
+
     @distributed_trace
     def list_by_resource_group(
         self, resource_group_name: str, top: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.NetworkConnection"]:
         """Lists network connections in a resource group.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either NetworkConnection or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.NetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -572,78 +578,83 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_resource_group_request(
+                request = build_list_by_resource_group_request(
                     resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_resource_group.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("NetworkConnectionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
+    list_by_resource_group.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections"
+    }
+
     @distributed_trace
     def get(self, resource_group_name: str, network_connection_name: str, **kwargs: Any) -> _models.NetworkConnection:
         """Gets a network connection resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param network_connection_name: Name of the Network Connection that can be applied to a Pool.
          Required.
         :type network_connection_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: NetworkConnection or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.NetworkConnection
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -654,49 +665,53 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.NetworkConnection] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             network_connection_name=network_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("NetworkConnection", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}"
+    }
 
     def _create_or_update_initial(
         self,
         resource_group_name: str,
         network_connection_name: str,
-        body: Union[_models.NetworkConnection, IO[bytes]],
+        body: Union[_models.NetworkConnection, IO],
         **kwargs: Any
     ) -> _models.NetworkConnection:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -714,51 +729,55 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "NetworkConnection")
 
-        _request = build_create_or_update_request(
+        request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             network_connection_name=network_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
             deserialized = self._deserialize("NetworkConnection", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("NetworkConnection", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
+    _create_or_update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}"
+    }
+
     @overload
     def begin_create_or_update(
         self,
         resource_group_name: str,
         network_connection_name: str,
         body: _models.NetworkConnection,
         *,
@@ -774,68 +793,95 @@
          Required.
         :type network_connection_name: str
         :param body: Represents network connection. Required.
         :type body: ~azure.mgmt.devcenter.models.NetworkConnection
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either NetworkConnection or the result of
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.NetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create_or_update(
         self,
         resource_group_name: str,
         network_connection_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.NetworkConnection]:
         """Creates or updates a Network Connections resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param network_connection_name: Name of the Network Connection that can be applied to a Pool.
          Required.
         :type network_connection_name: str
         :param body: Represents network connection. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either NetworkConnection or the result of
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.NetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create_or_update(
         self,
         resource_group_name: str,
         network_connection_name: str,
-        body: Union[_models.NetworkConnection, IO[bytes]],
+        body: Union[_models.NetworkConnection, IO],
         **kwargs: Any
     ) -> LROPoller[_models.NetworkConnection]:
         """Creates or updates a Network Connections resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param network_connection_name: Name of the Network Connection that can be applied to a Pool.
          Required.
         :type network_connection_name: str
-        :param body: Represents network connection. Is either a NetworkConnection type or a IO[bytes]
-         type. Required.
-        :type body: ~azure.mgmt.devcenter.models.NetworkConnection or IO[bytes]
+        :param body: Represents network connection. Is either a NetworkConnection type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.devcenter.models.NetworkConnection or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either NetworkConnection or the result of
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.NetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
@@ -859,41 +905,43 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("NetworkConnection", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[_models.NetworkConnection].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[_models.NetworkConnection](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_create_or_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}"
+    }
 
     def _update_initial(
         self,
         resource_group_name: str,
         network_connection_name: str,
-        body: Union[_models.NetworkConnectionUpdate, IO[bytes]],
+        body: Union[_models.NetworkConnectionUpdate, IO],
         **kwargs: Any
     ) -> Optional[_models.NetworkConnection]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -911,52 +959,52 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "NetworkConnectionUpdate")
 
-        _request = build_update_request(
+        request = build_update_request(
             resource_group_name=resource_group_name,
             network_connection_name=network_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = None
-        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("NetworkConnection", pipeline_response)
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    _update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}"
+    }
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
         network_connection_name: str,
         body: _models.NetworkConnectionUpdate,
@@ -973,68 +1021,95 @@
          Required.
         :type network_connection_name: str
         :param body: Represents network connection. Required.
         :type body: ~azure.mgmt.devcenter.models.NetworkConnectionUpdate
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either NetworkConnection or the result of
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.NetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
         network_connection_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.NetworkConnection]:
         """Partially updates a Network Connection.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param network_connection_name: Name of the Network Connection that can be applied to a Pool.
          Required.
         :type network_connection_name: str
         :param body: Represents network connection. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either NetworkConnection or the result of
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.NetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_update(
         self,
         resource_group_name: str,
         network_connection_name: str,
-        body: Union[_models.NetworkConnectionUpdate, IO[bytes]],
+        body: Union[_models.NetworkConnectionUpdate, IO],
         **kwargs: Any
     ) -> LROPoller[_models.NetworkConnection]:
         """Partially updates a Network Connection.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param network_connection_name: Name of the Network Connection that can be applied to a Pool.
          Required.
         :type network_connection_name: str
-        :param body: Represents network connection. Is either a NetworkConnectionUpdate type or a
-         IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.NetworkConnectionUpdate or IO[bytes]
+        :param body: Represents network connection. Is either a NetworkConnectionUpdate type or a IO
+         type. Required.
+        :type body: ~azure.mgmt.devcenter.models.NetworkConnectionUpdate or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either NetworkConnection or the result of
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.NetworkConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
@@ -1058,35 +1133,37 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("NetworkConnection", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[_models.NetworkConnection].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[_models.NetworkConnection](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}"
+    }
 
     def _delete_initial(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, network_connection_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -1097,54 +1174,62 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_delete_request(
+        request = build_delete_request(
             resource_group_name=resource_group_name,
             network_connection_name=network_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
+            return cls(pipeline_response, None, {})
+
+    _delete_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}"
+    }
 
     @distributed_trace
     def begin_delete(self, resource_group_name: str, network_connection_name: str, **kwargs: Any) -> LROPoller[None]:
         """Deletes a Network Connections resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param network_connection_name: Name of the Network Connection that can be applied to a Pool.
          Required.
         :type network_connection_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -1163,32 +1248,36 @@
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[None].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_delete.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}"
+    }
 
     @distributed_trace
     def list_health_details(
         self, resource_group_name: str, network_connection_name: str, top: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.HealthCheckStatusDetails"]:
         """Lists health check status details.
 
@@ -1197,14 +1286,15 @@
         :type resource_group_name: str
         :param network_connection_name: Name of the Network Connection that can be applied to a Pool.
          Required.
         :type network_connection_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either HealthCheckStatusDetails or the result of
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.HealthCheckStatusDetails]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
@@ -1219,81 +1309,86 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_health_details_request(
+                request = build_list_health_details_request(
                     resource_group_name=resource_group_name,
                     network_connection_name=network_connection_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_health_details.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("HealthCheckStatusDetailsListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return None, iter(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
+    list_health_details.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}/healthChecks"
+    }
+
     @distributed_trace
     def get_health_details(
         self, resource_group_name: str, network_connection_name: str, **kwargs: Any
     ) -> _models.HealthCheckStatusDetails:
         """Gets health check status details.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param network_connection_name: Name of the Network Connection that can be applied to a Pool.
          Required.
         :type network_connection_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: HealthCheckStatusDetails or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.HealthCheckStatusDetails
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -1304,43 +1399,47 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.HealthCheckStatusDetails] = kwargs.pop("cls", None)
 
-        _request = build_get_health_details_request(
+        request = build_get_health_details_request(
             resource_group_name=resource_group_name,
             network_connection_name=network_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get_health_details.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("HealthCheckStatusDetails", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    get_health_details.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}/healthChecks/latest"
+    }
 
     def _run_health_checks_initial(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, network_connection_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -1351,56 +1450,65 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_run_health_checks_request(
+        request = build_run_health_checks_request(
             resource_group_name=resource_group_name,
             network_connection_name=network_connection_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self._run_health_checks_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202]:
+        if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
+            return cls(pipeline_response, None, {})
+
+    _run_health_checks_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}/runHealthChecks"
+    }
 
     @distributed_trace
     def begin_run_health_checks(
         self, resource_group_name: str, network_connection_name: str, **kwargs: Any
     ) -> LROPoller[None]:
         """Triggers a new health check run. The execution and health check result can be tracked via the
         network Connection health check details.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param network_connection_name: Name of the Network Connection that can be applied to a Pool.
          Required.
         :type network_connection_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -1419,49 +1527,54 @@
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[None].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_run_health_checks.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}/runHealthChecks"
+    }
 
     @distributed_trace
-    def list_outbound_network_dependencies_endpoints(  # pylint: disable=name-too-long
+    def list_outbound_network_dependencies_endpoints(
         self, resource_group_name: str, network_connection_name: str, top: Optional[int] = None, **kwargs: Any
     ) -> Iterable["_models.OutboundEnvironmentEndpoint"]:
         """Lists the endpoints that agents may call as part of Dev Box service administration. These FQDNs
         should be allowed for outbound access in order for the Dev Box service to function.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param network_connection_name: Name of the Network Connection that can be applied to a Pool.
          Required.
         :type network_connection_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either OutboundEnvironmentEndpoint or the result of
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.OutboundEnvironmentEndpoint]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
@@ -1476,61 +1589,65 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_outbound_network_dependencies_endpoints_request(
+                request = build_list_outbound_network_dependencies_endpoints_request(
                     resource_group_name=resource_group_name,
                     network_connection_name=network_connection_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_outbound_network_dependencies_endpoints.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("OutboundEnvironmentEndpointCollection", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
+
+    list_outbound_network_dependencies_endpoints.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/networkConnections/{networkConnectionName}/outboundNetworkDependenciesEndpoints"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_operation_statuses_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_skus_operations.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,25 +1,27 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-from typing import Any, Callable, Dict, Optional, TypeVar
+from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
@@ -30,119 +32,137 @@
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_get_request(location: str, operation_id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
+def build_list_by_subscription_request(
+    subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/providers/Microsoft.DevCenter/locations/{location}/operationStatuses/{operationId}",
-    )  # pylint: disable=line-too-long
+    _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.DevCenter/skus")
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-        "location": _SERIALIZER.url("location", location, "str"),
-        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
     }
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+    if top is not None:
+        _params["$top"] = _SERIALIZER.query("top", top, "int")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class OperationStatusesOperations:
+class SkusOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.devcenter.DevCenterMgmtClient`'s
-        :attr:`operation_statuses` attribute.
+        :attr:`skus` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def get(self, location: str, operation_id: str, **kwargs: Any) -> _models.OperationStatus:
-        """Get Operation Status.
+    def list_by_subscription(self, top: Optional[int] = None, **kwargs: Any) -> Iterable["_models.DevCenterSku"]:
+        """Lists the Microsoft.DevCenter SKUs available in a subscription.
 
-        Gets the current status of an async operation.
-
-        :param location: The Azure region. Required.
-        :type location: str
-        :param operation_id: The ID of an ongoing async operation. Required.
-        :type operation_id: str
-        :return: OperationStatus or the result of cls(response)
-        :rtype: ~azure.mgmt.devcenter.models.OperationStatus
+        :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
+         Default value is None.
+        :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: An iterator like instance of either DevCenterSku or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.DevCenterSku]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.SkuListResult] = kwargs.pop("cls", None)
+
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.OperationStatus] = kwargs.pop("cls", None)
+        def prepare_request(next_link=None):
+            if not next_link:
 
-        _request = build_get_request(
-            location=location,
-            operation_id=operation_id,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            headers=_headers,
-            params=_params,
-        )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200, 202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("OperationStatus", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+                request = build_list_by_subscription_request(
+                    subscription_id=self._config.subscription_id,
+                    top=top,
+                    api_version=api_version,
+                    template_url=self.list_by_subscription.metadata["url"],
+                    headers=_headers,
+                    params=_params,
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
+
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("SkuListResult", pipeline_response)
+            list_of_elem = deserialized.value
+            if cls:
+                list_of_elem = cls(list_of_elem)  # type: ignore
+            return deserialized.next_link or None, iter(list_of_elem)
+
+        def get_next(next_link=None):
+            request = prepare_request(next_link)
+
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
+            )
+            response = pipeline_response.http_response
+
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-            deserialized = self._deserialize("OperationStatus", pipeline_response)
+            return pipeline_response
 
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+        return ItemPaged(get_next, extract_data)
 
-        return deserialized  # type: ignore
+    list_by_subscription.metadata = {"url": "/subscriptions/{subscriptionId}/providers/Microsoft.DevCenter/skus"}
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_operations.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -36,15 +36,15 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.DevCenter/operations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -74,14 +74,15 @@
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
         """Lists all of the available resource provider operations.
 
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -95,57 +96,59 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_request(
+                request = build_list_request(
                     api_version=api_version,
+                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("OperationListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
+
+    list.metadata = {"url": "/providers/Microsoft.DevCenter/operations"}
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_patch.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_patch.py`

 * *Files identical despite different names*

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_pools_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_pools_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -41,15 +41,15 @@
 
 def build_list_by_project_request(
     resource_group_name: str, project_name: str, subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools",
     )  # pylint: disable=line-too-long
@@ -83,15 +83,15 @@
 
 def build_get_request(
     resource_group_name: str, project_name: str, pool_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}",
     )  # pylint: disable=line-too-long
@@ -126,15 +126,15 @@
 
 def build_create_or_update_request(
     resource_group_name: str, project_name: str, pool_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}",
@@ -172,15 +172,15 @@
 
 def build_update_request(
     resource_group_name: str, project_name: str, pool_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}",
@@ -218,15 +218,15 @@
 
 def build_delete_request(
     resource_group_name: str, project_name: str, pool_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}",
     )  # pylint: disable=line-too-long
@@ -261,15 +261,15 @@
 
 def build_run_health_checks_request(
     resource_group_name: str, project_name: str, pool_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/runHealthChecks",
     )  # pylint: disable=line-too-long
@@ -331,14 +331,15 @@
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Pool or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.Pool]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -352,80 +353,85 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_project_request(
+                request = build_list_by_project_request(
                     resource_group_name=resource_group_name,
                     project_name=project_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_project.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("PoolListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
+    list_by_project.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools"
+    }
+
     @distributed_trace
     def get(self, resource_group_name: str, project_name: str, pool_name: str, **kwargs: Any) -> _models.Pool:
         """Gets a machine pool.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Pool or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.Pool
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -436,52 +442,51 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.Pool] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             pool_name=pool_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("Pool", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}"
+    }
 
     def _create_or_update_initial(
-        self,
-        resource_group_name: str,
-        project_name: str,
-        pool_name: str,
-        body: Union[_models.Pool, IO[bytes]],
-        **kwargs: Any
+        self, resource_group_name: str, project_name: str, pool_name: str, body: Union[_models.Pool, IO], **kwargs: Any
     ) -> _models.Pool:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -498,52 +503,56 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "Pool")
 
-        _request = build_create_or_update_request(
+        request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             pool_name=pool_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
             deserialized = self._deserialize("Pool", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("Pool", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
+    _create_or_update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}"
+    }
+
     @overload
     def begin_create_or_update(
         self,
         resource_group_name: str,
         project_name: str,
         pool_name: str,
         body: _models.Pool,
@@ -561,69 +570,91 @@
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
         :param body: Represents a machine pool. Required.
         :type body: ~azure.mgmt.devcenter.models.Pool
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either Pool or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Pool]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create_or_update(
         self,
         resource_group_name: str,
         project_name: str,
         pool_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.Pool]:
         """Creates or updates a machine pool.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
         :param body: Represents a machine pool. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either Pool or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Pool]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create_or_update(
-        self,
-        resource_group_name: str,
-        project_name: str,
-        pool_name: str,
-        body: Union[_models.Pool, IO[bytes]],
-        **kwargs: Any
+        self, resource_group_name: str, project_name: str, pool_name: str, body: Union[_models.Pool, IO], **kwargs: Any
     ) -> LROPoller[_models.Pool]:
         """Creates or updates a machine pool.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
-        :param body: Represents a machine pool. Is either a Pool type or a IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.Pool or IO[bytes]
+        :param body: Represents a machine pool. Is either a Pool type or a IO type. Required.
+        :type body: ~azure.mgmt.devcenter.models.Pool or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either Pool or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Pool]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -647,42 +678,44 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Pool", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[_models.Pool].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[_models.Pool](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_create_or_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}"
+    }
 
     def _update_initial(
         self,
         resource_group_name: str,
         project_name: str,
         pool_name: str,
-        body: Union[_models.PoolUpdate, IO[bytes]],
+        body: Union[_models.PoolUpdate, IO],
         **kwargs: Any
     ) -> Optional[_models.Pool]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -700,53 +733,53 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "PoolUpdate")
 
-        _request = build_update_request(
+        request = build_update_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             pool_name=pool_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = None
-        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("Pool", pipeline_response)
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    _update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}"
+    }
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
         project_name: str,
         pool_name: str,
@@ -765,70 +798,96 @@
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
         :param body: Represents a machine pool. Required.
         :type body: ~azure.mgmt.devcenter.models.PoolUpdate
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either Pool or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Pool]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
         project_name: str,
         pool_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.Pool]:
         """Partially updates a machine pool.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
         :param body: Represents a machine pool. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either Pool or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Pool]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_update(
         self,
         resource_group_name: str,
         project_name: str,
         pool_name: str,
-        body: Union[_models.PoolUpdate, IO[bytes]],
+        body: Union[_models.PoolUpdate, IO],
         **kwargs: Any
     ) -> LROPoller[_models.Pool]:
         """Partially updates a machine pool.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
-        :param body: Represents a machine pool. Is either a PoolUpdate type or a IO[bytes] type.
-         Required.
-        :type body: ~azure.mgmt.devcenter.models.PoolUpdate or IO[bytes]
+        :param body: Represents a machine pool. Is either a PoolUpdate type or a IO type. Required.
+        :type body: ~azure.mgmt.devcenter.models.PoolUpdate or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either Pool or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Pool]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -852,35 +911,37 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Pool", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[_models.Pool].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[_models.Pool](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}"
+    }
 
     def _delete_initial(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, project_name: str, pool_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -891,58 +952,66 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_delete_request(
+        request = build_delete_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             pool_name=pool_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
+            return cls(pipeline_response, None, {})
+
+    _delete_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}"
+    }
 
     @distributed_trace
     def begin_delete(
         self, resource_group_name: str, project_name: str, pool_name: str, **kwargs: Any
     ) -> LROPoller[None]:
         """Deletes a machine pool.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -962,32 +1031,36 @@
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[None].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_delete.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}"
+    }
 
     def _run_health_checks_initial(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, project_name: str, pool_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -998,57 +1071,66 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_run_health_checks_request(
+        request = build_run_health_checks_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             pool_name=pool_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self._run_health_checks_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202]:
+        if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
+            return cls(pipeline_response, None, {})
+
+    _run_health_checks_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/runHealthChecks"
+    }
 
     @distributed_trace
     def begin_run_health_checks(
         self, resource_group_name: str, project_name: str, pool_name: str, **kwargs: Any
     ) -> LROPoller[None]:
         """Triggers a refresh of the pool status.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param pool_name: Name of the pool. Required.
         :type pool_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -1068,25 +1150,29 @@
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[None].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_run_health_checks.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/runHealthChecks"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_project_allowed_environment_types_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_project_allowed_environment_types_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -38,15 +38,15 @@
 
 def build_list_request(
     resource_group_name: str, project_name: str, subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/allowedEnvironmentTypes",
     )  # pylint: disable=line-too-long
@@ -80,15 +80,15 @@
 
 def build_get_request(
     resource_group_name: str, project_name: str, environment_type_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/allowedEnvironmentTypes/{environmentTypeName}",
     )  # pylint: disable=line-too-long
@@ -155,14 +155,15 @@
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AllowedEnvironmentType or the result of
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.AllowedEnvironmentType]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
@@ -177,82 +178,87 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_request(
+                request = build_list_request(
                     resource_group_name=resource_group_name,
                     project_name=project_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("AllowedEnvironmentTypeListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
+    list.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/allowedEnvironmentTypes"
+    }
+
     @distributed_trace
     def get(
         self, resource_group_name: str, project_name: str, environment_type_name: str, **kwargs: Any
     ) -> _models.AllowedEnvironmentType:
         """Gets an allowed environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AllowedEnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.AllowedEnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -263,37 +269,41 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AllowedEnvironmentType] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             environment_type_name=environment_type_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("AllowedEnvironmentType", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/allowedEnvironmentTypes/{environmentTypeName}"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_project_catalogs_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_schedules_operations.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -35,41 +35,50 @@
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_request(
-    resource_group_name: str, project_name: str, subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
+def build_list_by_pool_request(
+    resource_group_name: str,
+    project_name: str,
+    pool_name: str,
+    subscription_id: str,
+    *,
+    top: Optional[int] = None,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/catalogs",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/schedules",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
         "projectName": _SERIALIZER.url(
             "project_name",
             project_name,
             "str",
             max_length=63,
             min_length=3,
             pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
         ),
+        "poolName": _SERIALIZER.url(
+            "pool_name", pool_name, "str", max_length=63, min_length=3, pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$"
+        ),
     }
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
     if top is not None:
@@ -78,933 +87,967 @@
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(
-    resource_group_name: str, project_name: str, catalog_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str,
+    project_name: str,
+    pool_name: str,
+    schedule_name: str,
+    subscription_id: str,
+    *,
+    top: Optional[int] = None,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/catalogs/{catalogName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/schedules/{scheduleName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
         "projectName": _SERIALIZER.url(
             "project_name",
             project_name,
             "str",
             max_length=63,
             min_length=3,
             pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
         ),
-        "catalogName": _SERIALIZER.url(
-            "catalog_name",
-            catalog_name,
-            "str",
-            max_length=63,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
+        "poolName": _SERIALIZER.url(
+            "pool_name", pool_name, "str", max_length=63, min_length=3, pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$"
+        ),
+        "scheduleName": _SERIALIZER.url(
+            "schedule_name", schedule_name, "str", max_length=100, min_length=1, pattern=r"^[-\w]+$"
         ),
     }
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+    if top is not None:
+        _params["$top"] = _SERIALIZER.query("top", top, "int")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_or_update_request(
-    resource_group_name: str, project_name: str, catalog_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str,
+    project_name: str,
+    pool_name: str,
+    schedule_name: str,
+    subscription_id: str,
+    *,
+    top: Optional[int] = None,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/catalogs/{catalogName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/schedules/{scheduleName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
         "projectName": _SERIALIZER.url(
             "project_name",
             project_name,
             "str",
             max_length=63,
             min_length=3,
             pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
         ),
-        "catalogName": _SERIALIZER.url(
-            "catalog_name",
-            catalog_name,
-            "str",
-            max_length=63,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
+        "poolName": _SERIALIZER.url(
+            "pool_name", pool_name, "str", max_length=63, min_length=3, pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$"
+        ),
+        "scheduleName": _SERIALIZER.url(
+            "schedule_name", schedule_name, "str", max_length=100, min_length=1, pattern=r"^[-\w]+$"
         ),
     }
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+    if top is not None:
+        _params["$top"] = _SERIALIZER.query("top", top, "int")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_patch_request(
-    resource_group_name: str, project_name: str, catalog_name: str, subscription_id: str, **kwargs: Any
+def build_update_request(
+    resource_group_name: str,
+    project_name: str,
+    pool_name: str,
+    schedule_name: str,
+    subscription_id: str,
+    *,
+    top: Optional[int] = None,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/catalogs/{catalogName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/schedules/{scheduleName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
         "projectName": _SERIALIZER.url(
             "project_name",
             project_name,
             "str",
             max_length=63,
             min_length=3,
             pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
         ),
-        "catalogName": _SERIALIZER.url(
-            "catalog_name",
-            catalog_name,
-            "str",
-            max_length=63,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
+        "poolName": _SERIALIZER.url(
+            "pool_name", pool_name, "str", max_length=63, min_length=3, pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$"
+        ),
+        "scheduleName": _SERIALIZER.url(
+            "schedule_name", schedule_name, "str", max_length=100, min_length=1, pattern=r"^[-\w]+$"
         ),
     }
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+    if top is not None:
+        _params["$top"] = _SERIALIZER.query("top", top, "int")
 
     # Construct headers
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(
-    resource_group_name: str, project_name: str, catalog_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/catalogs/{catalogName}",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "projectName": _SERIALIZER.url(
-            "project_name",
-            project_name,
-            "str",
-            max_length=63,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
-        ),
-        "catalogName": _SERIALIZER.url(
-            "catalog_name",
-            catalog_name,
-            "str",
-            max_length=63,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
-        ),
-    }
-
-    _url: str = _url.format(**path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_get_sync_error_details_request(
-    resource_group_name: str, project_name: str, catalog_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str,
+    project_name: str,
+    pool_name: str,
+    schedule_name: str,
+    subscription_id: str,
+    *,
+    top: Optional[int] = None,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/catalogs/{catalogName}/getSyncErrorDetails",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/schedules/{scheduleName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
         "projectName": _SERIALIZER.url(
             "project_name",
             project_name,
             "str",
             max_length=63,
             min_length=3,
             pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
         ),
-        "catalogName": _SERIALIZER.url(
-            "catalog_name",
-            catalog_name,
-            "str",
-            max_length=63,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
+        "poolName": _SERIALIZER.url(
+            "pool_name", pool_name, "str", max_length=63, min_length=3, pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$"
         ),
-    }
-
-    _url: str = _url.format(**path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_sync_request(
-    resource_group_name: str, project_name: str, catalog_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/catalogs/{catalogName}/sync",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "projectName": _SERIALIZER.url(
-            "project_name",
-            project_name,
-            "str",
-            max_length=63,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
-        ),
-        "catalogName": _SERIALIZER.url(
-            "catalog_name",
-            catalog_name,
-            "str",
-            max_length=63,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
-        ),
-    }
-
-    _url: str = _url.format(**path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_connect_request(
-    resource_group_name: str, project_name: str, catalog_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/catalogs/{catalogName}/connect",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "projectName": _SERIALIZER.url(
-            "project_name",
-            project_name,
-            "str",
-            max_length=63,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
-        ),
-        "catalogName": _SERIALIZER.url(
-            "catalog_name",
-            catalog_name,
-            "str",
-            max_length=63,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
+        "scheduleName": _SERIALIZER.url(
+            "schedule_name", schedule_name, "str", max_length=100, min_length=1, pattern=r"^[-\w]+$"
         ),
     }
 
     _url: str = _url.format(**path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+    if top is not None:
+        _params["$top"] = _SERIALIZER.query("top", top, "int")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class ProjectCatalogsOperations:
+class SchedulesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.devcenter.DevCenterMgmtClient`'s
-        :attr:`project_catalogs` attribute.
+        :attr:`schedules` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def list(
-        self, resource_group_name: str, project_name: str, top: Optional[int] = None, **kwargs: Any
-    ) -> Iterable["_models.Catalog"]:
-        """Lists the catalogs associated with a project.
+    def list_by_pool(
+        self, resource_group_name: str, project_name: str, pool_name: str, top: Optional[int] = None, **kwargs: Any
+    ) -> Iterable["_models.Schedule"]:
+        """Lists schedules for a pool.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
+        :param pool_name: Name of the pool. Required.
+        :type pool_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
-        :return: An iterator like instance of either Catalog or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.Catalog]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: An iterator like instance of either Schedule or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.Schedule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CatalogListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.ScheduleListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_request(
+                request = build_list_by_pool_request(
                     resource_group_name=resource_group_name,
                     project_name=project_name,
+                    pool_name=pool_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_pool.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("CatalogListResult", pipeline_response)
+            deserialized = self._deserialize("ScheduleListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
+    list_by_pool.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/schedules"
+    }
+
     @distributed_trace
-    def get(self, resource_group_name: str, project_name: str, catalog_name: str, **kwargs: Any) -> _models.Catalog:
-        """Gets an associated project catalog.
+    def get(
+        self,
+        resource_group_name: str,
+        project_name: str,
+        pool_name: str,
+        schedule_name: str,
+        top: Optional[int] = None,
+        **kwargs: Any
+    ) -> _models.Schedule:
+        """Gets a schedule resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :return: Catalog or the result of cls(response)
-        :rtype: ~azure.mgmt.devcenter.models.Catalog
+        :param pool_name: Name of the pool. Required.
+        :type pool_name: str
+        :param schedule_name: The name of the schedule that uniquely identifies it. Required.
+        :type schedule_name: str
+        :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
+         Default value is None.
+        :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: Schedule or the result of cls(response)
+        :rtype: ~azure.mgmt.devcenter.models.Schedule
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.Catalog] = kwargs.pop("cls", None)
+        cls: ClsType[_models.Schedule] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
-            catalog_name=catalog_name,
+            pool_name=pool_name,
+            schedule_name=schedule_name,
             subscription_id=self._config.subscription_id,
+            top=top,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("Catalog", pipeline_response)
+        deserialized = self._deserialize("Schedule", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/schedules/{scheduleName}"
+    }
 
     def _create_or_update_initial(
         self,
         resource_group_name: str,
         project_name: str,
-        catalog_name: str,
-        body: Union[_models.Catalog, IO[bytes]],
+        pool_name: str,
+        schedule_name: str,
+        body: Union[_models.Schedule, IO],
+        top: Optional[int] = None,
         **kwargs: Any
-    ) -> _models.Catalog:
+    ) -> _models.Schedule:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.Catalog] = kwargs.pop("cls", None)
+        cls: ClsType[_models.Schedule] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "Catalog")
+            _json = self._serialize.body(body, "Schedule")
 
-        _request = build_create_or_update_request(
+        request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
-            catalog_name=catalog_name,
+            pool_name=pool_name,
+            schedule_name=schedule_name,
             subscription_id=self._config.subscription_id,
+            top=top,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
-            deserialized = self._deserialize("Catalog", pipeline_response)
+            deserialized = self._deserialize("Schedule", pipeline_response)
 
         if response.status_code == 201:
-            deserialized = self._deserialize("Catalog", pipeline_response)
+            deserialized = self._deserialize("Schedule", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
+    _create_or_update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/schedules/{scheduleName}"
+    }
+
     @overload
     def begin_create_or_update(
         self,
         resource_group_name: str,
         project_name: str,
-        catalog_name: str,
-        body: _models.Catalog,
+        pool_name: str,
+        schedule_name: str,
+        body: _models.Schedule,
+        top: Optional[int] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.Catalog]:
-        """Creates or updates a project catalog.
+    ) -> LROPoller[_models.Schedule]:
+        """Creates or updates a Schedule.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :param body: Represents a catalog. Required.
-        :type body: ~azure.mgmt.devcenter.models.Catalog
+        :param pool_name: Name of the pool. Required.
+        :type pool_name: str
+        :param schedule_name: The name of the schedule that uniquely identifies it. Required.
+        :type schedule_name: str
+        :param body: Represents a scheduled task. Required.
+        :type body: ~azure.mgmt.devcenter.models.Schedule
+        :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
+         Default value is None.
+        :type top: int
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :return: An instance of LROPoller that returns either Catalog or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Catalog]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either Schedule or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Schedule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create_or_update(
         self,
         resource_group_name: str,
         project_name: str,
-        catalog_name: str,
-        body: IO[bytes],
+        pool_name: str,
+        schedule_name: str,
+        body: IO,
+        top: Optional[int] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.Catalog]:
-        """Creates or updates a project catalog.
+    ) -> LROPoller[_models.Schedule]:
+        """Creates or updates a Schedule.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :param body: Represents a catalog. Required.
-        :type body: IO[bytes]
+        :param pool_name: Name of the pool. Required.
+        :type pool_name: str
+        :param schedule_name: The name of the schedule that uniquely identifies it. Required.
+        :type schedule_name: str
+        :param body: Represents a scheduled task. Required.
+        :type body: IO
+        :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
+         Default value is None.
+        :type top: int
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :return: An instance of LROPoller that returns either Catalog or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Catalog]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either Schedule or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Schedule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create_or_update(
         self,
         resource_group_name: str,
         project_name: str,
-        catalog_name: str,
-        body: Union[_models.Catalog, IO[bytes]],
+        pool_name: str,
+        schedule_name: str,
+        body: Union[_models.Schedule, IO],
+        top: Optional[int] = None,
         **kwargs: Any
-    ) -> LROPoller[_models.Catalog]:
-        """Creates or updates a project catalog.
+    ) -> LROPoller[_models.Schedule]:
+        """Creates or updates a Schedule.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :param body: Represents a catalog. Is either a Catalog type or a IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.Catalog or IO[bytes]
-        :return: An instance of LROPoller that returns either Catalog or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Catalog]
+        :param pool_name: Name of the pool. Required.
+        :type pool_name: str
+        :param schedule_name: The name of the schedule that uniquely identifies it. Required.
+        :type schedule_name: str
+        :param body: Represents a scheduled task. Is either a Schedule type or a IO type. Required.
+        :type body: ~azure.mgmt.devcenter.models.Schedule or IO
+        :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
+         Default value is None.
+        :type top: int
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either Schedule or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Schedule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.Catalog] = kwargs.pop("cls", None)
+        cls: ClsType[_models.Schedule] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_or_update_initial(
                 resource_group_name=resource_group_name,
                 project_name=project_name,
-                catalog_name=catalog_name,
+                pool_name=pool_name,
+                schedule_name=schedule_name,
                 body=body,
+                top=top,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("Catalog", pipeline_response)
+            deserialized = self._deserialize("Schedule", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[_models.Catalog].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[_models.Catalog](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    def _patch_initial(
+    begin_create_or_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/schedules/{scheduleName}"
+    }
+
+    def _update_initial(
         self,
         resource_group_name: str,
         project_name: str,
-        catalog_name: str,
-        body: Union[_models.CatalogUpdate, IO[bytes]],
+        pool_name: str,
+        schedule_name: str,
+        body: Union[_models.ScheduleUpdate, IO],
+        top: Optional[int] = None,
         **kwargs: Any
-    ) -> Optional[_models.Catalog]:
+    ) -> Optional[_models.Schedule]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.Catalog]] = kwargs.pop("cls", None)
+        cls: ClsType[Optional[_models.Schedule]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "CatalogUpdate")
+            _json = self._serialize.body(body, "ScheduleUpdate")
 
-        _request = build_patch_request(
+        request = build_update_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
-            catalog_name=catalog_name,
+            pool_name=pool_name,
+            schedule_name=schedule_name,
             subscription_id=self._config.subscription_id,
+            top=top,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = None
-        response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("Catalog", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            deserialized = self._deserialize("Schedule", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    _update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/schedules/{scheduleName}"
+    }
 
     @overload
-    def begin_patch(
+    def begin_update(
         self,
         resource_group_name: str,
         project_name: str,
-        catalog_name: str,
-        body: _models.CatalogUpdate,
+        pool_name: str,
+        schedule_name: str,
+        body: _models.ScheduleUpdate,
+        top: Optional[int] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.Catalog]:
-        """Partially updates a project catalog.
+    ) -> LROPoller[_models.Schedule]:
+        """Partially updates a Scheduled.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :param body: Updatable project catalog properties. Required.
-        :type body: ~azure.mgmt.devcenter.models.CatalogUpdate
+        :param pool_name: Name of the pool. Required.
+        :type pool_name: str
+        :param schedule_name: The name of the schedule that uniquely identifies it. Required.
+        :type schedule_name: str
+        :param body: Represents a scheduled task. Required.
+        :type body: ~azure.mgmt.devcenter.models.ScheduleUpdate
+        :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
+         Default value is None.
+        :type top: int
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :return: An instance of LROPoller that returns either Catalog or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Catalog]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either Schedule or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Schedule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    def begin_patch(
+    def begin_update(
         self,
         resource_group_name: str,
         project_name: str,
-        catalog_name: str,
-        body: IO[bytes],
+        pool_name: str,
+        schedule_name: str,
+        body: IO,
+        top: Optional[int] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.Catalog]:
-        """Partially updates a project catalog.
+    ) -> LROPoller[_models.Schedule]:
+        """Partially updates a Scheduled.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :param body: Updatable project catalog properties. Required.
-        :type body: IO[bytes]
+        :param pool_name: Name of the pool. Required.
+        :type pool_name: str
+        :param schedule_name: The name of the schedule that uniquely identifies it. Required.
+        :type schedule_name: str
+        :param body: Represents a scheduled task. Required.
+        :type body: IO
+        :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
+         Default value is None.
+        :type top: int
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :return: An instance of LROPoller that returns either Catalog or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Catalog]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either Schedule or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Schedule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
-    def begin_patch(
+    def begin_update(
         self,
         resource_group_name: str,
         project_name: str,
-        catalog_name: str,
-        body: Union[_models.CatalogUpdate, IO[bytes]],
+        pool_name: str,
+        schedule_name: str,
+        body: Union[_models.ScheduleUpdate, IO],
+        top: Optional[int] = None,
         **kwargs: Any
-    ) -> LROPoller[_models.Catalog]:
-        """Partially updates a project catalog.
+    ) -> LROPoller[_models.Schedule]:
+        """Partially updates a Scheduled.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :param body: Updatable project catalog properties. Is either a CatalogUpdate type or a
-         IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.CatalogUpdate or IO[bytes]
-        :return: An instance of LROPoller that returns either Catalog or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Catalog]
+        :param pool_name: Name of the pool. Required.
+        :type pool_name: str
+        :param schedule_name: The name of the schedule that uniquely identifies it. Required.
+        :type schedule_name: str
+        :param body: Represents a scheduled task. Is either a ScheduleUpdate type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.devcenter.models.ScheduleUpdate or IO
+        :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
+         Default value is None.
+        :type top: int
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either Schedule or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Schedule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.Catalog] = kwargs.pop("cls", None)
+        cls: ClsType[_models.Schedule] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._patch_initial(
+            raw_result = self._update_initial(
                 resource_group_name=resource_group_name,
                 project_name=project_name,
-                catalog_name=catalog_name,
+                pool_name=pool_name,
+                schedule_name=schedule_name,
                 body=body,
+                top=top,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("Catalog", pipeline_response)
+            deserialized = self._deserialize("Schedule", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[_models.Catalog].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[_models.Catalog](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/schedules/{scheduleName}"
+    }
 
     def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, project_name: str, catalog_name: str, **kwargs: Any
+        self,
+        resource_group_name: str,
+        project_name: str,
+        pool_name: str,
+        schedule_name: str,
+        top: Optional[int] = None,
+        **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -1012,58 +1055,79 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_delete_request(
+        request = build_delete_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
-            catalog_name=catalog_name,
+            pool_name=pool_name,
+            schedule_name=schedule_name,
             subscription_id=self._config.subscription_id,
+            top=top,
             api_version=api_version,
+            template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
+            return cls(pipeline_response, None, {})
+
+    _delete_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/schedules/{scheduleName}"
+    }
 
     @distributed_trace
     def begin_delete(
-        self, resource_group_name: str, project_name: str, catalog_name: str, **kwargs: Any
+        self,
+        resource_group_name: str,
+        project_name: str,
+        pool_name: str,
+        schedule_name: str,
+        top: Optional[int] = None,
+        **kwargs: Any
     ) -> LROPoller[None]:
-        """Deletes a project catalog resource.
+        """Deletes a Scheduled.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
+        :param pool_name: Name of the pool. Required.
+        :type pool_name: str
+        :param schedule_name: The name of the schedule that uniquely identifies it. Required.
+        :type schedule_name: str
+        :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
+         Default value is None.
+        :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
@@ -1072,310 +1136,42 @@
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 project_name=project_name,
-                catalog_name=catalog_name,
+                pool_name=pool_name,
+                schedule_name=schedule_name,
+                top=top,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[None].from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    @distributed_trace
-    def get_sync_error_details(
-        self, resource_group_name: str, project_name: str, catalog_name: str, **kwargs: Any
-    ) -> _models.SyncErrorDetails:
-        """Gets project catalog synchronization error details.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param project_name: The name of the project. Required.
-        :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :return: SyncErrorDetails or the result of cls(response)
-        :rtype: ~azure.mgmt.devcenter.models.SyncErrorDetails
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.SyncErrorDetails] = kwargs.pop("cls", None)
-
-        _request = build_get_sync_error_details_request(
-            resource_group_name=resource_group_name,
-            project_name=project_name,
-            catalog_name=catalog_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            headers=_headers,
-            params=_params,
-        )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        deserialized = self._deserialize("SyncErrorDetails", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
-
-        return deserialized  # type: ignore
-
-    def _sync_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, project_name: str, catalog_name: str, **kwargs: Any
-    ) -> None:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
-
-        _request = build_sync_request(
-            resource_group_name=resource_group_name,
-            project_name=project_name,
-            catalog_name=catalog_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            headers=_headers,
-            params=_params,
-        )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-        if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
-
-    @distributed_trace
-    def begin_sync(
-        self, resource_group_name: str, project_name: str, catalog_name: str, **kwargs: Any
-    ) -> LROPoller[None]:
-        """Syncs templates for a template source.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param project_name: The name of the project. Required.
-        :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :return: An instance of LROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[None]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = self._sync_initial(  # type: ignore
-                resource_group_name=resource_group_name,
-                project_name=project_name,
-                catalog_name=catalog_name,
-                api_version=api_version,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
-            if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
-
-        if polling is True:
-            polling_method: PollingMethod = cast(
-                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
-            )
-        elif polling is False:
-            polling_method = cast(PollingMethod, NoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return LROPoller[None].from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    def _connect_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, project_name: str, catalog_name: str, **kwargs: Any
-    ) -> None:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
-
-        _request = build_connect_request(
-            resource_group_name=resource_group_name,
-            project_name=project_name,
-            catalog_name=catalog_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            headers=_headers,
-            params=_params,
-        )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-        if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
-
-    @distributed_trace
-    def begin_connect(
-        self, resource_group_name: str, project_name: str, catalog_name: str, **kwargs: Any
-    ) -> LROPoller[None]:
-        """Connects a project catalog to enable syncing.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param project_name: The name of the project. Required.
-        :type project_name: str
-        :param catalog_name: The name of the Catalog. Required.
-        :type catalog_name: str
-        :return: An instance of LROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[None]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = self._connect_initial(  # type: ignore
-                resource_group_name=resource_group_name,
-                project_name=project_name,
-                catalog_name=catalog_name,
-                api_version=api_version,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
-            if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
-
-        if polling is True:
-            polling_method: PollingMethod = cast(
-                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
-            )
-        elif polling is False:
-            polling_method = cast(PollingMethod, NoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return LROPoller[None].from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+    begin_delete.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/pools/{poolName}/schedules/{scheduleName}"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_project_environment_types_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/operations/_project_environment_types_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
@@ -39,15 +39,15 @@
 
 def build_list_request(
     resource_group_name: str, project_name: str, subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/environmentTypes",
     )  # pylint: disable=line-too-long
@@ -81,15 +81,15 @@
 
 def build_get_request(
     resource_group_name: str, project_name: str, environment_type_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/environmentTypes/{environmentTypeName}",
     )  # pylint: disable=line-too-long
@@ -129,15 +129,15 @@
 
 def build_create_or_update_request(
     resource_group_name: str, project_name: str, environment_type_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/environmentTypes/{environmentTypeName}",
@@ -180,15 +180,15 @@
 
 def build_update_request(
     resource_group_name: str, project_name: str, environment_type_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/environmentTypes/{environmentTypeName}",
@@ -231,15 +231,15 @@
 
 def build_delete_request(
     resource_group_name: str, project_name: str, environment_type_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/environmentTypes/{environmentTypeName}",
     )  # pylint: disable=line-too-long
@@ -306,14 +306,15 @@
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either ProjectEnvironmentType or the result of
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.ProjectEnvironmentType]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
@@ -328,82 +329,87 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_request(
+                request = build_list_request(
                     resource_group_name=resource_group_name,
                     project_name=project_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("ProjectEnvironmentTypeListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
-            _request = prepare_request(next_link)
+            request = prepare_request(next_link)
 
             _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
+    list.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/environmentTypes"
+    }
+
     @distributed_trace
     def get(
         self, resource_group_name: str, project_name: str, environment_type_name: str, **kwargs: Any
     ) -> _models.ProjectEnvironmentType:
         """Gets a project environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProjectEnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.ProjectEnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -414,44 +420,48 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ProjectEnvironmentType] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             environment_type_name=environment_type_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ProjectEnvironmentType", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/environmentTypes/{environmentTypeName}"
+    }
 
     @overload
     def create_or_update(
         self,
         resource_group_name: str,
         project_name: str,
         environment_type_name: str,
@@ -470,70 +480,76 @@
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
         :param body: Represents a Project Environment Type. Required.
         :type body: ~azure.mgmt.devcenter.models.ProjectEnvironmentType
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProjectEnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.ProjectEnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def create_or_update(
         self,
         resource_group_name: str,
         project_name: str,
         environment_type_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.ProjectEnvironmentType:
         """Creates or updates a project environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
         :param body: Represents a Project Environment Type. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProjectEnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.ProjectEnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def create_or_update(
         self,
         resource_group_name: str,
         project_name: str,
         environment_type_name: str,
-        body: Union[_models.ProjectEnvironmentType, IO[bytes]],
+        body: Union[_models.ProjectEnvironmentType, IO],
         **kwargs: Any
     ) -> _models.ProjectEnvironmentType:
         """Creates or updates a project environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
         :param body: Represents a Project Environment Type. Is either a ProjectEnvironmentType type or
-         a IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.ProjectEnvironmentType or IO[bytes]
+         a IO type. Required.
+        :type body: ~azure.mgmt.devcenter.models.ProjectEnvironmentType or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProjectEnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.ProjectEnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -553,51 +569,51 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "ProjectEnvironmentType")
 
-        _request = build_create_or_update_request(
+        request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             environment_type_name=environment_type_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 201]:
+        if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        if response.status_code == 200:
-            deserialized = self._deserialize("ProjectEnvironmentType", pipeline_response)
-
-        if response.status_code == 201:
-            deserialized = self._deserialize("ProjectEnvironmentType", pipeline_response)
+        deserialized = self._deserialize("ProjectEnvironmentType", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    create_or_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/environmentTypes/{environmentTypeName}"
+    }
 
     @overload
     def update(
         self,
         resource_group_name: str,
         project_name: str,
         environment_type_name: str,
@@ -616,70 +632,76 @@
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
         :param body: Updatable project environment type properties. Required.
         :type body: ~azure.mgmt.devcenter.models.ProjectEnvironmentTypeUpdate
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProjectEnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.ProjectEnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def update(
         self,
         resource_group_name: str,
         project_name: str,
         environment_type_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.ProjectEnvironmentType:
         """Partially updates a project environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
         :param body: Updatable project environment type properties. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProjectEnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.ProjectEnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def update(
         self,
         resource_group_name: str,
         project_name: str,
         environment_type_name: str,
-        body: Union[_models.ProjectEnvironmentTypeUpdate, IO[bytes]],
+        body: Union[_models.ProjectEnvironmentTypeUpdate, IO],
         **kwargs: Any
     ) -> _models.ProjectEnvironmentType:
         """Partially updates a project environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
         :param body: Updatable project environment type properties. Is either a
-         ProjectEnvironmentTypeUpdate type or a IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.ProjectEnvironmentTypeUpdate or IO[bytes]
+         ProjectEnvironmentTypeUpdate type or a IO type. Required.
+        :type body: ~azure.mgmt.devcenter.models.ProjectEnvironmentTypeUpdate or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProjectEnvironmentType or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.ProjectEnvironmentType
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -699,61 +721,66 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "ProjectEnvironmentTypeUpdate")
 
-        _request = build_update_request(
+        request = build_update_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             environment_type_name=environment_type_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ProjectEnvironmentType", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/environmentTypes/{environmentTypeName}"
+    }
 
     @distributed_trace
     def delete(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, project_name: str, environment_type_name: str, **kwargs: Any
     ) -> None:
         """Deletes a project environment type.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param environment_type_name: The name of the environment type. Required.
         :type environment_type_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -764,33 +791,37 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_delete_request(
+        request = build_delete_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             environment_type_name=environment_type_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, {})  # type: ignore
+            return cls(pipeline_response, None, {})
+
+    delete.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}/environmentTypes/{environmentTypeName}"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure/mgmt/devcenter/operations/_projects_operations.py` & `azure-mgmt-devcenter-1.1.0b1/azure/mgmt/devcenter/aio/operations/_projects_operations.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,302 +1,82 @@
-# pylint: disable=too-many-lines,too-many-statements
+# pylint: disable=too-many-lines
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 from io import IOBase
-from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
+from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
+from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
-from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import HttpResponse
-from azure.core.polling import LROPoller, NoPolling, PollingMethod
+from azure.core.pipeline.transport import AsyncHttpResponse
+from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
+from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
-from azure.mgmt.core.polling.arm_polling import ARMPolling
+from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
-from .. import models as _models
-from .._serialization import Serializer
-from .._vendor import _convert_request
+from ... import models as _models
+from ..._vendor import _convert_request
+from ...operations._projects_operations import (
+    build_create_or_update_request,
+    build_delete_request,
+    build_get_request,
+    build_list_by_resource_group_request,
+    build_list_by_subscription_request,
+    build_update_request,
+)
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
-
-_SERIALIZER = Serializer()
-_SERIALIZER.client_side_validation = False
-
-
-def build_list_by_subscription_request(
-    subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.DevCenter/projects")
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-    }
-
-    _url: str = _url.format(**path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-    if top is not None:
-        _params["$top"] = _SERIALIZER.query("top", top, "int")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_list_by_resource_group_request(
-    resource_group_name: str, subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-    }
-
-    _url: str = _url.format(**path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-    if top is not None:
-        _params["$top"] = _SERIALIZER.query("top", top, "int")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_get_request(resource_group_name: str, project_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "projectName": _SERIALIZER.url(
-            "project_name",
-            project_name,
-            "str",
-            max_length=63,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
-        ),
-    }
-
-    _url: str = _url.format(**path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_create_or_update_request(
-    resource_group_name: str, project_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "projectName": _SERIALIZER.url(
-            "project_name",
-            project_name,
-            "str",
-            max_length=63,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
-        ),
-    }
-
-    _url: str = _url.format(**path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    if content_type is not None:
-        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_update_request(
-    resource_group_name: str, project_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "projectName": _SERIALIZER.url(
-            "project_name",
-            project_name,
-            "str",
-            max_length=63,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
-        ),
-    }
-
-    _url: str = _url.format(**path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    if content_type is not None:
-        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_delete_request(
-    resource_group_name: str, project_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-02-01"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "projectName": _SERIALIZER.url(
-            "project_name",
-            project_name,
-            "str",
-            max_length=63,
-            min_length=3,
-            pattern=r"^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,62}$",
-        ),
-    }
-
-    _url: str = _url.format(**path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ProjectsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.devcenter.DevCenterMgmtClient`'s
+        :class:`~azure.mgmt.devcenter.aio.DevCenterMgmtClient`'s
         :attr:`projects` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def list_by_subscription(self, top: Optional[int] = None, **kwargs: Any) -> Iterable["_models.Project"]:
+    def list_by_subscription(self, top: Optional[int] = None, **kwargs: Any) -> AsyncIterable["_models.Project"]:
         """Lists all projects in the subscription.
 
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Project or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.Project]
+        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.Project]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ProjectListResult] = kwargs.pop("cls", None)
@@ -308,81 +88,84 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_subscription_request(
+                request = build_list_by_subscription_request(
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_subscription.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
-        def extract_data(pipeline_response):
+        async def extract_data(pipeline_response):
             deserialized = self._deserialize("ProjectListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, iter(list_of_elem)
+            return deserialized.next_link or None, AsyncList(list_of_elem)
 
-        def get_next(next_link=None):
-            _request = prepare_request(next_link)
+        async def get_next(next_link=None):
+            request = prepare_request(next_link)
 
             _stream = False
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return ItemPaged(get_next, extract_data)
+        return AsyncItemPaged(get_next, extract_data)
+
+    list_by_subscription.metadata = {"url": "/subscriptions/{subscriptionId}/providers/Microsoft.DevCenter/projects"}
 
     @distributed_trace
     def list_by_resource_group(
         self, resource_group_name: str, top: Optional[int] = None, **kwargs: Any
-    ) -> Iterable["_models.Project"]:
+    ) -> AsyncIterable["_models.Project"]:
         """Lists all projects in the resource group.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param top: The maximum number of resources to return from the operation. Example: '$top=10'.
          Default value is None.
         :type top: int
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Project or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.devcenter.models.Project]
+        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.devcenter.models.Project]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ProjectListResult] = kwargs.pop("cls", None)
@@ -394,77 +177,82 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                _request = build_list_by_resource_group_request(
+                request = build_list_by_resource_group_request(
                     resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
                     top=top,
                     api_version=api_version,
+                    template_url=self.list_by_resource_group.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
             else:
                 # make call to next link with the client's api-version
                 _parsed_next_link = urllib.parse.urlparse(next_link)
                 _next_request_params = case_insensitive_dict(
                     {
                         key: [urllib.parse.quote(v) for v in value]
                         for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                     }
                 )
                 _next_request_params["api-version"] = self._config.api_version
-                _request = HttpRequest(
+                request = HttpRequest(
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
-                _request = _convert_request(_request)
-                _request.url = self._client.format_url(_request.url)
-                _request.method = "GET"
-            return _request
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
-        def extract_data(pipeline_response):
+        async def extract_data(pipeline_response):
             deserialized = self._deserialize("ProjectListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, iter(list_of_elem)
+            return deserialized.next_link or None, AsyncList(list_of_elem)
 
-        def get_next(next_link=None):
-            _request = prepare_request(next_link)
+        async def get_next(next_link=None):
+            request = prepare_request(next_link)
 
             _stream = False
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                _request, stream=_stream, **kwargs
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return ItemPaged(get_next, extract_data)
+        return AsyncItemPaged(get_next, extract_data)
 
-    @distributed_trace
-    def get(self, resource_group_name: str, project_name: str, **kwargs: Any) -> _models.Project:
+    list_by_resource_group.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects"
+    }
+
+    @distributed_trace_async
+    async def get(self, resource_group_name: str, project_name: str, **kwargs: Any) -> _models.Project:
         """Gets a specific project.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Project or the result of cls(response)
         :rtype: ~azure.mgmt.devcenter.models.Project
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
@@ -475,46 +263,50 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.Project] = kwargs.pop("cls", None)
 
-        _request = build_get_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("Project", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}"
+    }
 
-    def _create_or_update_initial(
-        self, resource_group_name: str, project_name: str, body: Union[_models.Project, IO[bytes]], **kwargs: Any
+    async def _create_or_update_initial(
+        self, resource_group_name: str, project_name: str, body: Union[_models.Project, IO], **kwargs: Any
     ) -> _models.Project:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -531,133 +323,167 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "Project")
 
-        _request = build_create_or_update_request(
+        request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
             deserialized = self._deserialize("Project", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("Project", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
+    _create_or_update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}"
+    }
+
     @overload
-    def begin_create_or_update(
+    async def begin_create_or_update(
         self,
         resource_group_name: str,
         project_name: str,
         body: _models.Project,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.Project]:
+    ) -> AsyncLROPoller[_models.Project]:
         """Creates or updates a project.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param body: Represents a project. Required.
         :type body: ~azure.mgmt.devcenter.models.Project
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :return: An instance of LROPoller that returns either Project or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Project]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either Project or the result of
+         cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Project]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    def begin_create_or_update(
+    async def begin_create_or_update(
         self,
         resource_group_name: str,
         project_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.Project]:
+    ) -> AsyncLROPoller[_models.Project]:
         """Creates or updates a project.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param body: Represents a project. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :return: An instance of LROPoller that returns either Project or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Project]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either Project or the result of
+         cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Project]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace
-    def begin_create_or_update(
-        self, resource_group_name: str, project_name: str, body: Union[_models.Project, IO[bytes]], **kwargs: Any
-    ) -> LROPoller[_models.Project]:
+    @distributed_trace_async
+    async def begin_create_or_update(
+        self, resource_group_name: str, project_name: str, body: Union[_models.Project, IO], **kwargs: Any
+    ) -> AsyncLROPoller[_models.Project]:
         """Creates or updates a project.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
-        :param body: Represents a project. Is either a Project type or a IO[bytes] type. Required.
-        :type body: ~azure.mgmt.devcenter.models.Project or IO[bytes]
-        :return: An instance of LROPoller that returns either Project or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Project]
+        :param body: Represents a project. Is either a Project type or a IO type. Required.
+        :type body: ~azure.mgmt.devcenter.models.Project or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either Project or the result of
+         cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Project]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Project] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._create_or_update_initial(
+            raw_result = await self._create_or_update_initial(
                 resource_group_name=resource_group_name,
                 project_name=project_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
@@ -665,38 +491,41 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Project", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: PollingMethod = cast(
-                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod,
+                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
-            polling_method = cast(PollingMethod, NoPolling())
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[_models.Project].from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[_models.Project](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_create_or_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}"
+    }
 
-    def _update_initial(
-        self, resource_group_name: str, project_name: str, body: Union[_models.ProjectUpdate, IO[bytes]], **kwargs: Any
+    async def _update_initial(
+        self, resource_group_name: str, project_name: str, body: Union[_models.ProjectUpdate, IO], **kwargs: Any
     ) -> Optional[_models.Project]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -713,136 +542,166 @@
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "ProjectUpdate")
 
-        _request = build_update_request(
+        request = build_update_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
+            template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         deserialized = None
-        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("Project", pipeline_response)
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})
 
-        return deserialized  # type: ignore
+        return deserialized
+
+    _update_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}"
+    }
 
     @overload
-    def begin_update(
+    async def begin_update(
         self,
         resource_group_name: str,
         project_name: str,
         body: _models.ProjectUpdate,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.Project]:
+    ) -> AsyncLROPoller[_models.Project]:
         """Partially updates a project.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param body: Updatable project properties. Required.
         :type body: ~azure.mgmt.devcenter.models.ProjectUpdate
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
-        :return: An instance of LROPoller that returns either Project or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Project]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either Project or the result of
+         cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Project]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    def begin_update(
+    async def begin_update(
         self,
         resource_group_name: str,
         project_name: str,
-        body: IO[bytes],
+        body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.Project]:
+    ) -> AsyncLROPoller[_models.Project]:
         """Partially updates a project.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
         :param body: Updatable project properties. Required.
-        :type body: IO[bytes]
+        :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
-        :return: An instance of LROPoller that returns either Project or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Project]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either Project or the result of
+         cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Project]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace
-    def begin_update(
-        self, resource_group_name: str, project_name: str, body: Union[_models.ProjectUpdate, IO[bytes]], **kwargs: Any
-    ) -> LROPoller[_models.Project]:
+    @distributed_trace_async
+    async def begin_update(
+        self, resource_group_name: str, project_name: str, body: Union[_models.ProjectUpdate, IO], **kwargs: Any
+    ) -> AsyncLROPoller[_models.Project]:
         """Partially updates a project.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
-        :param body: Updatable project properties. Is either a ProjectUpdate type or a IO[bytes] type.
+        :param body: Updatable project properties. Is either a ProjectUpdate type or a IO type.
          Required.
-        :type body: ~azure.mgmt.devcenter.models.ProjectUpdate or IO[bytes]
-        :return: An instance of LROPoller that returns either Project or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.devcenter.models.Project]
+        :type body: ~azure.mgmt.devcenter.models.ProjectUpdate or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either Project or the result of
+         cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.devcenter.models.Project]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Project] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._update_initial(
+            raw_result = await self._update_initial(
                 resource_group_name=resource_group_name,
                 project_name=project_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
@@ -850,37 +709,40 @@
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Project", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})  # type: ignore
+                return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: PollingMethod = cast(
-                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod,
+                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
-            polling_method = cast(PollingMethod, NoPolling())
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[_models.Project].from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[_models.Project](
-            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
-        )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    def _delete_initial(  # pylint: disable=inconsistent-return-statements
+    begin_update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}"
+    }
+
+    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, project_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -889,90 +751,103 @@
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
-        _request = build_delete_request(
+        request = build_delete_request(
             resource_group_name=resource_group_name,
             project_name=project_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
+            template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
-        _request = _convert_request(_request)
-        _request.url = self._client.format_url(_request.url)
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            _request, stream=_stream, **kwargs
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)  # type: ignore
+            return cls(pipeline_response, None, {})
 
-    @distributed_trace
-    def begin_delete(self, resource_group_name: str, project_name: str, **kwargs: Any) -> LROPoller[None]:
+    _delete_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}"
+    }
+
+    @distributed_trace_async
+    async def begin_delete(self, resource_group_name: str, project_name: str, **kwargs: Any) -> AsyncLROPoller[None]:
         """Deletes a project resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param project_name: The name of the project. Required.
         :type project_name: str
-        :return: An instance of LROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[None]
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._delete_initial(  # type: ignore
+            raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 project_name=project_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, None, {})  # type: ignore
+                return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: PollingMethod = cast(
-                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod,
+                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
-            polling_method = cast(PollingMethod, NoPolling())
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return LROPoller[None].from_continuation_token(
+            return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_delete.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevCenter/projects/{projectName}"
+    }
```

### Comparing `azure-mgmt-devcenter-1.1.0/azure_mgmt_devcenter.egg-info/SOURCES.txt` & `azure-mgmt-devcenter-1.1.0b1/azure_mgmt_devcenter.egg-info/SOURCES.txt`

 * *Files 0% similar despite different names*

```diff
@@ -16,61 +16,59 @@
 azure/mgmt/devcenter/py.typed
 azure/mgmt/devcenter/aio/__init__.py
 azure/mgmt/devcenter/aio/_configuration.py
 azure/mgmt/devcenter/aio/_dev_center_mgmt_client.py
 azure/mgmt/devcenter/aio/_patch.py
 azure/mgmt/devcenter/aio/operations/__init__.py
 azure/mgmt/devcenter/aio/operations/_attached_networks_operations.py
+azure/mgmt/devcenter/aio/operations/_catalog_dev_box_definitions_operations.py
 azure/mgmt/devcenter/aio/operations/_catalogs_operations.py
 azure/mgmt/devcenter/aio/operations/_check_name_availability_operations.py
-azure/mgmt/devcenter/aio/operations/_check_scoped_name_availability_operations.py
+azure/mgmt/devcenter/aio/operations/_customization_tasks_operations.py
 azure/mgmt/devcenter/aio/operations/_dev_box_definitions_operations.py
 azure/mgmt/devcenter/aio/operations/_dev_centers_operations.py
 azure/mgmt/devcenter/aio/operations/_environment_definitions_operations.py
 azure/mgmt/devcenter/aio/operations/_environment_types_operations.py
 azure/mgmt/devcenter/aio/operations/_galleries_operations.py
 azure/mgmt/devcenter/aio/operations/_image_versions_operations.py
 azure/mgmt/devcenter/aio/operations/_images_operations.py
 azure/mgmt/devcenter/aio/operations/_network_connections_operations.py
 azure/mgmt/devcenter/aio/operations/_operation_statuses_operations.py
 azure/mgmt/devcenter/aio/operations/_operations.py
 azure/mgmt/devcenter/aio/operations/_patch.py
 azure/mgmt/devcenter/aio/operations/_pools_operations.py
 azure/mgmt/devcenter/aio/operations/_project_allowed_environment_types_operations.py
-azure/mgmt/devcenter/aio/operations/_project_catalog_environment_definitions_operations.py
-azure/mgmt/devcenter/aio/operations/_project_catalogs_operations.py
 azure/mgmt/devcenter/aio/operations/_project_environment_types_operations.py
 azure/mgmt/devcenter/aio/operations/_projects_operations.py
 azure/mgmt/devcenter/aio/operations/_schedules_operations.py
 azure/mgmt/devcenter/aio/operations/_skus_operations.py
 azure/mgmt/devcenter/aio/operations/_usages_operations.py
 azure/mgmt/devcenter/models/__init__.py
 azure/mgmt/devcenter/models/_dev_center_mgmt_client_enums.py
 azure/mgmt/devcenter/models/_models_py3.py
 azure/mgmt/devcenter/models/_patch.py
 azure/mgmt/devcenter/operations/__init__.py
 azure/mgmt/devcenter/operations/_attached_networks_operations.py
+azure/mgmt/devcenter/operations/_catalog_dev_box_definitions_operations.py
 azure/mgmt/devcenter/operations/_catalogs_operations.py
 azure/mgmt/devcenter/operations/_check_name_availability_operations.py
-azure/mgmt/devcenter/operations/_check_scoped_name_availability_operations.py
+azure/mgmt/devcenter/operations/_customization_tasks_operations.py
 azure/mgmt/devcenter/operations/_dev_box_definitions_operations.py
 azure/mgmt/devcenter/operations/_dev_centers_operations.py
 azure/mgmt/devcenter/operations/_environment_definitions_operations.py
 azure/mgmt/devcenter/operations/_environment_types_operations.py
 azure/mgmt/devcenter/operations/_galleries_operations.py
 azure/mgmt/devcenter/operations/_image_versions_operations.py
 azure/mgmt/devcenter/operations/_images_operations.py
 azure/mgmt/devcenter/operations/_network_connections_operations.py
 azure/mgmt/devcenter/operations/_operation_statuses_operations.py
 azure/mgmt/devcenter/operations/_operations.py
 azure/mgmt/devcenter/operations/_patch.py
 azure/mgmt/devcenter/operations/_pools_operations.py
 azure/mgmt/devcenter/operations/_project_allowed_environment_types_operations.py
-azure/mgmt/devcenter/operations/_project_catalog_environment_definitions_operations.py
-azure/mgmt/devcenter/operations/_project_catalogs_operations.py
 azure/mgmt/devcenter/operations/_project_environment_types_operations.py
 azure/mgmt/devcenter/operations/_projects_operations.py
 azure/mgmt/devcenter/operations/_schedules_operations.py
 azure/mgmt/devcenter/operations/_skus_operations.py
 azure/mgmt/devcenter/operations/_usages_operations.py
 azure_mgmt_devcenter.egg-info/PKG-INFO
 azure_mgmt_devcenter.egg-info/SOURCES.txt
```

### Comparing `azure-mgmt-devcenter-1.1.0/setup.py` & `azure-mgmt-devcenter-1.1.0b1/setup.py`

 * *Files 3% similar despite different names*

```diff
@@ -45,23 +45,23 @@
     long_description_content_type="text/markdown",
     license="MIT License",
     author="Microsoft Corporation",
     author_email="azpysdkhelp@microsoft.com",
     url="https://github.com/Azure/azure-sdk-for-python",
     keywords="azure, azure sdk",  # update with search keywords relevant to the azure service / product
     classifiers=[
-        "Development Status :: 5 - Production/Stable",
+        "Development Status :: 4 - Beta",
         "Programming Language :: Python",
         "Programming Language :: Python :: 3 :: Only",
         "Programming Language :: Python :: 3",
+        "Programming Language :: Python :: 3.7",
         "Programming Language :: Python :: 3.8",
         "Programming Language :: Python :: 3.9",
         "Programming Language :: Python :: 3.10",
         "Programming Language :: Python :: 3.11",
-        "Programming Language :: Python :: 3.12",
         "License :: OSI Approved :: MIT License",
     ],
     zip_safe=False,
     packages=find_packages(
         exclude=[
             "tests",
             # Exclude packages that will be covered by PEP420 or nspkg
@@ -70,13 +70,14 @@
         ]
     ),
     include_package_data=True,
     package_data={
         "pytyped": ["py.typed"],
     },
     install_requires=[
-        "isodate>=0.6.1",
-        "azure-common>=1.1",
-        "azure-mgmt-core>=1.3.2",
+        "isodate<1.0.0,>=0.6.1",
+        "azure-common~=1.1",
+        "azure-mgmt-core>=1.3.2,<2.0.0",
+        "typing-extensions>=4.3.0; python_version<'3.8.0'",
     ],
-    python_requires=">=3.8",
+    python_requires=">=3.7",
 )
```

