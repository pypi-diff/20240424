# Comparing `tmp/freechat_sdk-0.1.0-py3-none-any.whl.zip` & `tmp/freechat_sdk-1.0.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,84 +1,97 @@
-Zip file size: 177876 bytes, number of entries: 82
--rw-r--r--  2.0 unx     5525 b- defN 23-Dec-06 07:39 freechat-sdk/__init__.py
--rw-r--r--  2.0 unx    24849 b- defN 23-Dec-06 07:39 freechat-sdk/api_client.py
--rw-r--r--  2.0 unx      674 b- defN 23-Dec-06 07:39 freechat-sdk/api_response.py
--rw-r--r--  2.0 unx    14134 b- defN 23-Dec-06 07:39 freechat-sdk/configuration.py
--rw-r--r--  2.0 unx     5395 b- defN 23-Dec-06 07:39 freechat-sdk/exceptions.py
--rw-r--r--  2.0 unx        0 b- defN 23-Dec-06 07:39 freechat-sdk/py.typed
--rw-r--r--  2.0 unx     8241 b- defN 23-Dec-06 07:39 freechat-sdk/rest.py
--rw-r--r--  2.0 unx      883 b- defN 23-Dec-06 07:39 freechat-sdk/api/__init__.py
--rw-r--r--  2.0 unx    89401 b- defN 23-Dec-06 07:39 freechat-sdk/api/account_api.py
--rw-r--r--  2.0 unx   142954 b- defN 23-Dec-06 07:39 freechat-sdk/api/account_manager_for_admin_api.py
--rw-r--r--  2.0 unx   101657 b- defN 23-Dec-06 07:39 freechat-sdk/api/ai_service_api.py
--rw-r--r--  2.0 unx    41941 b- defN 23-Dec-06 07:39 freechat-sdk/api/app_config_for_admin_api.py
--rw-r--r--  2.0 unx    21622 b- defN 23-Dec-06 07:39 freechat-sdk/api/app_meta_for_admin_api.py
--rw-r--r--  2.0 unx   323407 b- defN 23-Dec-06 07:39 freechat-sdk/api/character_api.py
--rw-r--r--  2.0 unx    10888 b- defN 23-Dec-06 07:39 freechat-sdk/api/encryption_manager_for_admin_api.py
--rw-r--r--  2.0 unx   172654 b- defN 23-Dec-06 07:39 freechat-sdk/api/flow_api.py
--rw-r--r--  2.0 unx   204587 b- defN 23-Dec-06 07:39 freechat-sdk/api/interactive_statistics_api.py
--rw-r--r--  2.0 unx   125270 b- defN 23-Dec-06 07:39 freechat-sdk/api/organization_api.py
--rw-r--r--  2.0 unx   142616 b- defN 23-Dec-06 07:39 freechat-sdk/api/plugin_api.py
--rw-r--r--  2.0 unx   217596 b- defN 23-Dec-06 07:39 freechat-sdk/api/prompt_api.py
--rw-r--r--  2.0 unx    43184 b- defN 23-Dec-06 07:39 freechat-sdk/api/prompt_task_api.py
--rw-r--r--  2.0 unx     4164 b- defN 23-Dec-06 07:39 freechat-sdk/models/__init__.py
--rw-r--r--  2.0 unx     3510 b- defN 23-Dec-06 07:39 freechat-sdk/models/ai_api_key_create_dto.py
--rw-r--r--  2.0 unx     4508 b- defN 23-Dec-06 07:39 freechat-sdk/models/ai_api_key_info_dto.py
--rw-r--r--  2.0 unx     3906 b- defN 23-Dec-06 07:39 freechat-sdk/models/ai_model_info_dto.py
--rw-r--r--  2.0 unx     3322 b- defN 23-Dec-06 07:39 freechat-sdk/models/app_config_create_dto.py
--rw-r--r--  2.0 unx     3659 b- defN 23-Dec-06 07:39 freechat-sdk/models/app_config_info_dto.py
--rw-r--r--  2.0 unx     4040 b- defN 23-Dec-06 07:39 freechat-sdk/models/app_meta_dto.py
--rw-r--r--  2.0 unx     5015 b- defN 23-Dec-06 07:39 freechat-sdk/models/character_backend_details_dto.py
--rw-r--r--  2.0 unx     4999 b- defN 23-Dec-06 07:39 freechat-sdk/models/character_backend_dto.py
--rw-r--r--  2.0 unx     5667 b- defN 23-Dec-06 07:39 freechat-sdk/models/character_create_dto.py
--rw-r--r--  2.0 unx     6991 b- defN 23-Dec-06 07:39 freechat-sdk/models/character_details_dto.py
--rw-r--r--  2.0 unx     3729 b- defN 23-Dec-06 07:39 freechat-sdk/models/character_info_draft_dto.py
--rw-r--r--  2.0 unx     3652 b- defN 23-Dec-06 07:39 freechat-sdk/models/character_item_for_name_dto.py
--rw-r--r--  2.0 unx     4069 b- defN 23-Dec-06 07:39 freechat-sdk/models/character_query_dto.py
--rw-r--r--  2.0 unx     4949 b- defN 23-Dec-06 07:39 freechat-sdk/models/character_summary_dto.py
--rw-r--r--  2.0 unx     5844 b- defN 23-Dec-06 07:39 freechat-sdk/models/character_summary_stats_dto.py
--rw-r--r--  2.0 unx     5663 b- defN 23-Dec-06 07:39 freechat-sdk/models/character_update_dto.py
--rw-r--r--  2.0 unx     3346 b- defN 23-Dec-06 07:39 freechat-sdk/models/chat_content_dto.py
--rw-r--r--  2.0 unx     3823 b- defN 23-Dec-06 07:39 freechat-sdk/models/chat_create_dto.py
--rw-r--r--  2.0 unx     4091 b- defN 23-Dec-06 07:39 freechat-sdk/models/chat_message_dto.py
--rw-r--r--  2.0 unx     4137 b- defN 23-Dec-06 07:39 freechat-sdk/models/chat_prompt_content_dto.py
--rw-r--r--  2.0 unx     3182 b- defN 23-Dec-06 07:39 freechat-sdk/models/chat_tool_call_dto.py
--rw-r--r--  2.0 unx     4724 b- defN 23-Dec-06 07:39 freechat-sdk/models/flow_create_dto.py
--rw-r--r--  2.0 unx     6141 b- defN 23-Dec-06 07:39 freechat-sdk/models/flow_details_dto.py
--rw-r--r--  2.0 unx     3602 b- defN 23-Dec-06 07:39 freechat-sdk/models/flow_item_for_name_dto.py
--rw-r--r--  2.0 unx     4042 b- defN 23-Dec-06 07:39 freechat-sdk/models/flow_query_dto.py
--rw-r--r--  2.0 unx     5429 b- defN 23-Dec-06 07:39 freechat-sdk/models/flow_summary_dto.py
--rw-r--r--  2.0 unx     6329 b- defN 23-Dec-06 07:39 freechat-sdk/models/flow_summary_stats_dto.py
--rw-r--r--  2.0 unx     4720 b- defN 23-Dec-06 07:39 freechat-sdk/models/flow_update_dto.py
--rw-r--r--  2.0 unx     4629 b- defN 23-Dec-06 07:39 freechat-sdk/models/interactive_stats_dto.py
--rw-r--r--  2.0 unx     4505 b- defN 23-Dec-06 07:39 freechat-sdk/models/llm_result_dto.py
--rw-r--r--  2.0 unx     3502 b- defN 23-Dec-06 07:39 freechat-sdk/models/llm_token_usage_dto.py
--rw-r--r--  2.0 unx     6141 b- defN 23-Dec-06 07:39 freechat-sdk/models/open_ai_param_dto.py
--rw-r--r--  2.0 unx     4742 b- defN 23-Dec-06 07:39 freechat-sdk/models/plugin_create_dto.py
--rw-r--r--  2.0 unx     6434 b- defN 23-Dec-06 07:39 freechat-sdk/models/plugin_details_dto.py
--rw-r--r--  2.0 unx     4051 b- defN 23-Dec-06 07:39 freechat-sdk/models/plugin_query_dto.py
--rw-r--r--  2.0 unx     5426 b- defN 23-Dec-06 07:39 freechat-sdk/models/plugin_summary_dto.py
--rw-r--r--  2.0 unx     6337 b- defN 23-Dec-06 07:39 freechat-sdk/models/plugin_summary_stats_dto.py
--rw-r--r--  2.0 unx     4738 b- defN 23-Dec-06 07:39 freechat-sdk/models/plugin_update_dto.py
--rw-r--r--  2.0 unx     4338 b- defN 23-Dec-06 07:39 freechat-sdk/models/prompt_ai_param_dto.py
--rw-r--r--  2.0 unx     5495 b- defN 23-Dec-06 07:39 freechat-sdk/models/prompt_create_dto.py
--rw-r--r--  2.0 unx     6872 b- defN 23-Dec-06 07:39 freechat-sdk/models/prompt_details_dto.py
--rw-r--r--  2.0 unx     3622 b- defN 23-Dec-06 07:39 freechat-sdk/models/prompt_item_for_name_dto.py
--rw-r--r--  2.0 unx     4066 b- defN 23-Dec-06 07:39 freechat-sdk/models/prompt_query_dto.py
--rw-r--r--  2.0 unx     3389 b- defN 23-Dec-06 07:39 freechat-sdk/models/prompt_ref_dto.py
--rw-r--r--  2.0 unx     5645 b- defN 23-Dec-06 07:39 freechat-sdk/models/prompt_summary_dto.py
--rw-r--r--  2.0 unx     6549 b- defN 23-Dec-06 07:39 freechat-sdk/models/prompt_summary_stats_dto.py
--rw-r--r--  2.0 unx     5107 b- defN 23-Dec-06 07:39 freechat-sdk/models/prompt_task_details_dto.py
--rw-r--r--  2.0 unx     4167 b- defN 23-Dec-06 07:39 freechat-sdk/models/prompt_task_dto.py
--rw-r--r--  2.0 unx     4014 b- defN 23-Dec-06 07:39 freechat-sdk/models/prompt_template_dto.py
--rw-r--r--  2.0 unx     5491 b- defN 23-Dec-06 07:39 freechat-sdk/models/prompt_update_dto.py
--rw-r--r--  2.0 unx     5282 b- defN 23-Dec-06 07:39 freechat-sdk/models/qwen_param_dto.py
--rw-r--r--  2.0 unx     2929 b- defN 23-Dec-06 07:39 freechat-sdk/models/sse_emitter.py
--rw-r--r--  2.0 unx     3470 b- defN 23-Dec-06 07:39 freechat-sdk/models/user_basic_info_dto.py
--rw-r--r--  2.0 unx     5619 b- defN 23-Dec-06 07:39 freechat-sdk/models/user_details_dto.py
--rw-r--r--  2.0 unx     5750 b- defN 23-Dec-06 07:39 freechat-sdk/models/user_full_details_dto.py
--rw-r--r--  2.0 unx     4644 b- defN 23-Dec-06 07:39 freechat-sdk/models/where.py
--rw-r--r--  2.0 unx      534 b- defN 23-Dec-07 06:39 freechat_sdk-0.1.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Dec-07 06:39 freechat_sdk-0.1.0.dist-info/WHEEL
--rw-r--r--  2.0 unx       13 b- defN 23-Dec-07 06:39 freechat_sdk-0.1.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     7829 b- defN 23-Dec-07 06:39 freechat_sdk-0.1.0.dist-info/RECORD
-82 files, 1974153 bytes uncompressed, 165230 bytes compressed:  91.6%
+Zip file size: 582170 bytes, number of entries: 95
+-rw-r--r--  2.0 unx    16780 b- defN 24-Apr-24 10:03 freechat_sdk/__init__.py
+-rw-r--r--  2.0 unx    36703 b- defN 24-Apr-24 10:03 freechat_sdk/api_client.py
+-rw-r--r--  2.0 unx      652 b- defN 24-Apr-24 10:03 freechat_sdk/api_response.py
+-rw-r--r--  2.0 unx    25132 b- defN 24-Apr-24 10:03 freechat_sdk/configuration.py
+-rw-r--r--  2.0 unx    16350 b- defN 24-Apr-24 10:03 freechat_sdk/exceptions.py
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-24 10:03 freechat_sdk/py.typed
+-rw-r--r--  2.0 unx    19784 b- defN 24-Apr-24 10:03 freechat_sdk/rest.py
+-rw-r--r--  2.0 unx      975 b- defN 24-Apr-24 10:03 freechat_sdk/api/__init__.py
+-rw-r--r--  2.0 unx   137802 b- defN 24-Apr-24 10:03 freechat_sdk/api/account_api.py
+-rw-r--r--  2.0 unx   153078 b- defN 24-Apr-24 10:03 freechat_sdk/api/account_manager_for_admin_api.py
+-rw-r--r--  2.0 unx   183377 b- defN 24-Apr-24 10:03 freechat_sdk/api/agent_api.py
+-rw-r--r--  2.0 unx   111746 b- defN 24-Apr-24 10:03 freechat_sdk/api/ai_service_api.py
+-rw-r--r--  2.0 unx    52195 b- defN 24-Apr-24 10:03 freechat_sdk/api/app_config_for_admin_api.py
+-rw-r--r--  2.0 unx    31148 b- defN 24-Apr-24 10:03 freechat_sdk/api/app_meta_for_admin_api.py
+-rw-r--r--  2.0 unx   350522 b- defN 24-Apr-24 10:03 freechat_sdk/api/character_api.py
+-rw-r--r--  2.0 unx   146848 b- defN 24-Apr-24 10:03 freechat_sdk/api/chat_api.py
+-rw-r--r--  2.0 unx    21212 b- defN 24-Apr-24 10:03 freechat_sdk/api/encryption_manager_for_admin_api.py
+-rw-r--r--  2.0 unx   226091 b- defN 24-Apr-24 10:03 freechat_sdk/api/interactive_statistics_api.py
+-rw-r--r--  2.0 unx   135375 b- defN 24-Apr-24 10:03 freechat_sdk/api/organization_api.py
+-rw-r--r--  2.0 unx   152753 b- defN 24-Apr-24 10:03 freechat_sdk/api/plugin_api.py
+-rw-r--r--  2.0 unx   256858 b- defN 24-Apr-24 10:03 freechat_sdk/api/prompt_api.py
+-rw-r--r--  2.0 unx    53469 b- defN 24-Apr-24 10:03 freechat_sdk/api/prompt_task_api.py
+-rw-r--r--  2.0 unx    93080 b- defN 24-Apr-24 10:03 freechat_sdk/api/rag_api.py
+-rw-r--r--  2.0 unx    15327 b- defN 24-Apr-24 10:03 freechat_sdk/models/__init__.py
+-rw-r--r--  2.0 unx    15259 b- defN 24-Apr-24 10:03 freechat_sdk/models/agent_create_dto.py
+-rw-r--r--  2.0 unx    16881 b- defN 24-Apr-24 10:03 freechat_sdk/models/agent_details_dto.py
+-rw-r--r--  2.0 unx    14116 b- defN 24-Apr-24 10:03 freechat_sdk/models/agent_item_for_name_dto.py
+-rw-r--r--  2.0 unx    14603 b- defN 24-Apr-24 10:03 freechat_sdk/models/agent_query_dto.py
+-rw-r--r--  2.0 unx    15076 b- defN 24-Apr-24 10:03 freechat_sdk/models/agent_query_where.py
+-rw-r--r--  2.0 unx    16166 b- defN 24-Apr-24 10:03 freechat_sdk/models/agent_summary_dto.py
+-rw-r--r--  2.0 unx    17066 b- defN 24-Apr-24 10:03 freechat_sdk/models/agent_summary_stats_dto.py
+-rw-r--r--  2.0 unx    15255 b- defN 24-Apr-24 10:03 freechat_sdk/models/agent_update_dto.py
+-rw-r--r--  2.0 unx    14029 b- defN 24-Apr-24 10:03 freechat_sdk/models/ai_api_key_create_dto.py
+-rw-r--r--  2.0 unx    15028 b- defN 24-Apr-24 10:03 freechat_sdk/models/ai_api_key_info_dto.py
+-rw-r--r--  2.0 unx    14425 b- defN 24-Apr-24 10:03 freechat_sdk/models/ai_model_info_dto.py
+-rw-r--r--  2.0 unx    14949 b- defN 24-Apr-24 10:03 freechat_sdk/models/api_token_info_dto.py
+-rw-r--r--  2.0 unx    13841 b- defN 24-Apr-24 10:03 freechat_sdk/models/app_config_create_dto.py
+-rw-r--r--  2.0 unx    14178 b- defN 24-Apr-24 10:03 freechat_sdk/models/app_config_info_dto.py
+-rw-r--r--  2.0 unx    14559 b- defN 24-Apr-24 10:03 freechat_sdk/models/app_meta_dto.py
+-rw-r--r--  2.0 unx    16712 b- defN 24-Apr-24 10:03 freechat_sdk/models/character_backend_details_dto.py
+-rw-r--r--  2.0 unx    15772 b- defN 24-Apr-24 10:03 freechat_sdk/models/character_backend_dto.py
+-rw-r--r--  2.0 unx    15889 b- defN 24-Apr-24 10:03 freechat_sdk/models/character_create_dto.py
+-rw-r--r--  2.0 unx    17801 b- defN 24-Apr-24 10:03 freechat_sdk/models/character_details_dto.py
+-rw-r--r--  2.0 unx    14156 b- defN 24-Apr-24 10:03 freechat_sdk/models/character_item_for_name_dto.py
+-rw-r--r--  2.0 unx    14642 b- defN 24-Apr-24 10:03 freechat_sdk/models/character_query_dto.py
+-rw-r--r--  2.0 unx    14851 b- defN 24-Apr-24 10:03 freechat_sdk/models/character_query_where.py
+-rw-r--r--  2.0 unx    16332 b- defN 24-Apr-24 10:03 freechat_sdk/models/character_summary_dto.py
+-rw-r--r--  2.0 unx    17227 b- defN 24-Apr-24 10:03 freechat_sdk/models/character_summary_stats_dto.py
+-rw-r--r--  2.0 unx    15885 b- defN 24-Apr-24 10:03 freechat_sdk/models/character_update_dto.py
+-rw-r--r--  2.0 unx    13703 b- defN 24-Apr-24 10:03 freechat_sdk/models/chat_content_dto.py
+-rw-r--r--  2.0 unx    16038 b- defN 24-Apr-24 10:03 freechat_sdk/models/chat_context_dto.py
+-rw-r--r--  2.0 unx    15068 b- defN 24-Apr-24 10:03 freechat_sdk/models/chat_create_dto.py
+-rw-r--r--  2.0 unx    15497 b- defN 24-Apr-24 10:03 freechat_sdk/models/chat_message_dto.py
+-rw-r--r--  2.0 unx    14322 b- defN 24-Apr-24 10:03 freechat_sdk/models/chat_message_record_dto.py
+-rw-r--r--  2.0 unx    14638 b- defN 24-Apr-24 10:03 freechat_sdk/models/chat_prompt_content_dto.py
+-rw-r--r--  2.0 unx    15440 b- defN 24-Apr-24 10:03 freechat_sdk/models/chat_session_dto.py
+-rw-r--r--  2.0 unx    13813 b- defN 24-Apr-24 10:03 freechat_sdk/models/chat_tool_call_dto.py
+-rw-r--r--  2.0 unx    15249 b- defN 24-Apr-24 10:03 freechat_sdk/models/chat_update_dto.py
+-rw-r--r--  2.0 unx    13648 b- defN 24-Apr-24 10:03 freechat_sdk/models/hot_tag_dto.py
+-rw-r--r--  2.0 unx    15149 b- defN 24-Apr-24 10:03 freechat_sdk/models/interactive_stats_dto.py
+-rw-r--r--  2.0 unx    15003 b- defN 24-Apr-24 10:03 freechat_sdk/models/llm_result_dto.py
+-rw-r--r--  2.0 unx    14239 b- defN 24-Apr-24 10:03 freechat_sdk/models/memory_usage_dto.py
+-rw-r--r--  2.0 unx    16669 b- defN 24-Apr-24 10:03 freechat_sdk/models/open_ai_param_dto.py
+-rw-r--r--  2.0 unx    15261 b- defN 24-Apr-24 10:03 freechat_sdk/models/plugin_create_dto.py
+-rw-r--r--  2.0 unx    17141 b- defN 24-Apr-24 10:03 freechat_sdk/models/plugin_details_dto.py
+-rw-r--r--  2.0 unx    14612 b- defN 24-Apr-24 10:03 freechat_sdk/models/plugin_query_dto.py
+-rw-r--r--  2.0 unx    15569 b- defN 24-Apr-24 10:03 freechat_sdk/models/plugin_query_where.py
+-rw-r--r--  2.0 unx    16133 b- defN 24-Apr-24 10:03 freechat_sdk/models/plugin_summary_dto.py
+-rw-r--r--  2.0 unx    17033 b- defN 24-Apr-24 10:03 freechat_sdk/models/plugin_summary_stats_dto.py
+-rw-r--r--  2.0 unx    15257 b- defN 24-Apr-24 10:03 freechat_sdk/models/plugin_update_dto.py
+-rw-r--r--  2.0 unx    14841 b- defN 24-Apr-24 10:03 freechat_sdk/models/prompt_ai_param_dto.py
+-rw-r--r--  2.0 unx    16015 b- defN 24-Apr-24 10:03 freechat_sdk/models/prompt_create_dto.py
+-rw-r--r--  2.0 unx    17758 b- defN 24-Apr-24 10:03 freechat_sdk/models/prompt_details_dto.py
+-rw-r--r--  2.0 unx    14126 b- defN 24-Apr-24 10:03 freechat_sdk/models/prompt_item_for_name_dto.py
+-rw-r--r--  2.0 unx    14662 b- defN 24-Apr-24 10:03 freechat_sdk/models/prompt_query_dto.py
+-rw-r--r--  2.0 unx    15196 b- defN 24-Apr-24 10:03 freechat_sdk/models/prompt_query_where.py
+-rw-r--r--  2.0 unx    13900 b- defN 24-Apr-24 10:03 freechat_sdk/models/prompt_ref_dto.py
+-rw-r--r--  2.0 unx    16535 b- defN 24-Apr-24 10:03 freechat_sdk/models/prompt_summary_dto.py
+-rw-r--r--  2.0 unx    17439 b- defN 24-Apr-24 10:03 freechat_sdk/models/prompt_summary_stats_dto.py
+-rw-r--r--  2.0 unx    16097 b- defN 24-Apr-24 10:03 freechat_sdk/models/prompt_task_details_dto.py
+-rw-r--r--  2.0 unx    14887 b- defN 24-Apr-24 10:03 freechat_sdk/models/prompt_task_dto.py
+-rw-r--r--  2.0 unx    14521 b- defN 24-Apr-24 10:03 freechat_sdk/models/prompt_template_dto.py
+-rw-r--r--  2.0 unx    16011 b- defN 24-Apr-24 10:03 freechat_sdk/models/prompt_update_dto.py
+-rw-r--r--  2.0 unx    17074 b- defN 24-Apr-24 10:03 freechat_sdk/models/qwen_param_dto.py
+-rw-r--r--  2.0 unx    15772 b- defN 24-Apr-24 10:03 freechat_sdk/models/rag_task_details_dto.py
+-rw-r--r--  2.0 unx    14213 b- defN 24-Apr-24 10:03 freechat_sdk/models/rag_task_dto.py
+-rw-r--r--  2.0 unx    13468 b- defN 24-Apr-24 10:03 freechat_sdk/models/sse_emitter.py
+-rw-r--r--  2.0 unx    14012 b- defN 24-Apr-24 10:03 freechat_sdk/models/token_usage_dto.py
+-rw-r--r--  2.0 unx    13989 b- defN 24-Apr-24 10:03 freechat_sdk/models/user_basic_info_dto.py
+-rw-r--r--  2.0 unx    16139 b- defN 24-Apr-24 10:03 freechat_sdk/models/user_details_dto.py
+-rw-r--r--  2.0 unx    16270 b- defN 24-Apr-24 10:03 freechat_sdk/models/user_full_details_dto.py
+-rw-r--r--  2.0 unx    11783 b- defN 24-Apr-24 11:26 freechat_sdk-1.0.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-Apr-24 11:26 freechat_sdk-1.0.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       13 b- defN 24-Apr-24 11:26 freechat_sdk-1.0.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     9151 b- defN 24-Apr-24 11:26 freechat_sdk-1.0.0.dist-info/RECORD
+95 files, 3285401 bytes uncompressed, 567528 bytes compressed:  82.7%
```

## zipnote {}

```diff
@@ -1,247 +1,286 @@
-Filename: freechat-sdk/__init__.py
+Filename: freechat_sdk/__init__.py
 Comment: 
 
-Filename: freechat-sdk/api_client.py
+Filename: freechat_sdk/api_client.py
 Comment: 
 
-Filename: freechat-sdk/api_response.py
+Filename: freechat_sdk/api_response.py
 Comment: 
 
-Filename: freechat-sdk/configuration.py
+Filename: freechat_sdk/configuration.py
 Comment: 
 
-Filename: freechat-sdk/exceptions.py
+Filename: freechat_sdk/exceptions.py
 Comment: 
 
-Filename: freechat-sdk/py.typed
+Filename: freechat_sdk/py.typed
 Comment: 
 
-Filename: freechat-sdk/rest.py
+Filename: freechat_sdk/rest.py
 Comment: 
 
-Filename: freechat-sdk/api/__init__.py
+Filename: freechat_sdk/api/__init__.py
 Comment: 
 
-Filename: freechat-sdk/api/account_api.py
+Filename: freechat_sdk/api/account_api.py
 Comment: 
 
-Filename: freechat-sdk/api/account_manager_for_admin_api.py
+Filename: freechat_sdk/api/account_manager_for_admin_api.py
 Comment: 
 
-Filename: freechat-sdk/api/ai_service_api.py
+Filename: freechat_sdk/api/agent_api.py
 Comment: 
 
-Filename: freechat-sdk/api/app_config_for_admin_api.py
+Filename: freechat_sdk/api/ai_service_api.py
 Comment: 
 
-Filename: freechat-sdk/api/app_meta_for_admin_api.py
+Filename: freechat_sdk/api/app_config_for_admin_api.py
 Comment: 
 
-Filename: freechat-sdk/api/character_api.py
+Filename: freechat_sdk/api/app_meta_for_admin_api.py
 Comment: 
 
-Filename: freechat-sdk/api/encryption_manager_for_admin_api.py
+Filename: freechat_sdk/api/character_api.py
 Comment: 
 
-Filename: freechat-sdk/api/flow_api.py
+Filename: freechat_sdk/api/chat_api.py
 Comment: 
 
-Filename: freechat-sdk/api/interactive_statistics_api.py
+Filename: freechat_sdk/api/encryption_manager_for_admin_api.py
 Comment: 
 
-Filename: freechat-sdk/api/organization_api.py
+Filename: freechat_sdk/api/interactive_statistics_api.py
 Comment: 
 
-Filename: freechat-sdk/api/plugin_api.py
+Filename: freechat_sdk/api/organization_api.py
 Comment: 
 
-Filename: freechat-sdk/api/prompt_api.py
+Filename: freechat_sdk/api/plugin_api.py
 Comment: 
 
-Filename: freechat-sdk/api/prompt_task_api.py
+Filename: freechat_sdk/api/prompt_api.py
 Comment: 
 
-Filename: freechat-sdk/models/__init__.py
+Filename: freechat_sdk/api/prompt_task_api.py
 Comment: 
 
-Filename: freechat-sdk/models/ai_api_key_create_dto.py
+Filename: freechat_sdk/api/rag_api.py
 Comment: 
 
-Filename: freechat-sdk/models/ai_api_key_info_dto.py
+Filename: freechat_sdk/models/__init__.py
 Comment: 
 
-Filename: freechat-sdk/models/ai_model_info_dto.py
+Filename: freechat_sdk/models/agent_create_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/app_config_create_dto.py
+Filename: freechat_sdk/models/agent_details_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/app_config_info_dto.py
+Filename: freechat_sdk/models/agent_item_for_name_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/app_meta_dto.py
+Filename: freechat_sdk/models/agent_query_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/character_backend_details_dto.py
+Filename: freechat_sdk/models/agent_query_where.py
 Comment: 
 
-Filename: freechat-sdk/models/character_backend_dto.py
+Filename: freechat_sdk/models/agent_summary_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/character_create_dto.py
+Filename: freechat_sdk/models/agent_summary_stats_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/character_details_dto.py
+Filename: freechat_sdk/models/agent_update_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/character_info_draft_dto.py
+Filename: freechat_sdk/models/ai_api_key_create_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/character_item_for_name_dto.py
+Filename: freechat_sdk/models/ai_api_key_info_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/character_query_dto.py
+Filename: freechat_sdk/models/ai_model_info_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/character_summary_dto.py
+Filename: freechat_sdk/models/api_token_info_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/character_summary_stats_dto.py
+Filename: freechat_sdk/models/app_config_create_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/character_update_dto.py
+Filename: freechat_sdk/models/app_config_info_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/chat_content_dto.py
+Filename: freechat_sdk/models/app_meta_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/chat_create_dto.py
+Filename: freechat_sdk/models/character_backend_details_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/chat_message_dto.py
+Filename: freechat_sdk/models/character_backend_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/chat_prompt_content_dto.py
+Filename: freechat_sdk/models/character_create_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/chat_tool_call_dto.py
+Filename: freechat_sdk/models/character_details_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/flow_create_dto.py
+Filename: freechat_sdk/models/character_item_for_name_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/flow_details_dto.py
+Filename: freechat_sdk/models/character_query_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/flow_item_for_name_dto.py
+Filename: freechat_sdk/models/character_query_where.py
 Comment: 
 
-Filename: freechat-sdk/models/flow_query_dto.py
+Filename: freechat_sdk/models/character_summary_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/flow_summary_dto.py
+Filename: freechat_sdk/models/character_summary_stats_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/flow_summary_stats_dto.py
+Filename: freechat_sdk/models/character_update_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/flow_update_dto.py
+Filename: freechat_sdk/models/chat_content_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/interactive_stats_dto.py
+Filename: freechat_sdk/models/chat_context_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/llm_result_dto.py
+Filename: freechat_sdk/models/chat_create_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/llm_token_usage_dto.py
+Filename: freechat_sdk/models/chat_message_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/open_ai_param_dto.py
+Filename: freechat_sdk/models/chat_message_record_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/plugin_create_dto.py
+Filename: freechat_sdk/models/chat_prompt_content_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/plugin_details_dto.py
+Filename: freechat_sdk/models/chat_session_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/plugin_query_dto.py
+Filename: freechat_sdk/models/chat_tool_call_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/plugin_summary_dto.py
+Filename: freechat_sdk/models/chat_update_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/plugin_summary_stats_dto.py
+Filename: freechat_sdk/models/hot_tag_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/plugin_update_dto.py
+Filename: freechat_sdk/models/interactive_stats_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/prompt_ai_param_dto.py
+Filename: freechat_sdk/models/llm_result_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/prompt_create_dto.py
+Filename: freechat_sdk/models/memory_usage_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/prompt_details_dto.py
+Filename: freechat_sdk/models/open_ai_param_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/prompt_item_for_name_dto.py
+Filename: freechat_sdk/models/plugin_create_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/prompt_query_dto.py
+Filename: freechat_sdk/models/plugin_details_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/prompt_ref_dto.py
+Filename: freechat_sdk/models/plugin_query_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/prompt_summary_dto.py
+Filename: freechat_sdk/models/plugin_query_where.py
 Comment: 
 
-Filename: freechat-sdk/models/prompt_summary_stats_dto.py
+Filename: freechat_sdk/models/plugin_summary_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/prompt_task_details_dto.py
+Filename: freechat_sdk/models/plugin_summary_stats_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/prompt_task_dto.py
+Filename: freechat_sdk/models/plugin_update_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/prompt_template_dto.py
+Filename: freechat_sdk/models/prompt_ai_param_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/prompt_update_dto.py
+Filename: freechat_sdk/models/prompt_create_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/qwen_param_dto.py
+Filename: freechat_sdk/models/prompt_details_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/sse_emitter.py
+Filename: freechat_sdk/models/prompt_item_for_name_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/user_basic_info_dto.py
+Filename: freechat_sdk/models/prompt_query_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/user_details_dto.py
+Filename: freechat_sdk/models/prompt_query_where.py
 Comment: 
 
-Filename: freechat-sdk/models/user_full_details_dto.py
+Filename: freechat_sdk/models/prompt_ref_dto.py
 Comment: 
 
-Filename: freechat-sdk/models/where.py
+Filename: freechat_sdk/models/prompt_summary_dto.py
 Comment: 
 
-Filename: freechat_sdk-0.1.0.dist-info/METADATA
+Filename: freechat_sdk/models/prompt_summary_stats_dto.py
 Comment: 
 
-Filename: freechat_sdk-0.1.0.dist-info/WHEEL
+Filename: freechat_sdk/models/prompt_task_details_dto.py
 Comment: 
 
-Filename: freechat_sdk-0.1.0.dist-info/top_level.txt
+Filename: freechat_sdk/models/prompt_task_dto.py
 Comment: 
 
-Filename: freechat_sdk-0.1.0.dist-info/RECORD
+Filename: freechat_sdk/models/prompt_template_dto.py
+Comment: 
+
+Filename: freechat_sdk/models/prompt_update_dto.py
+Comment: 
+
+Filename: freechat_sdk/models/qwen_param_dto.py
+Comment: 
+
+Filename: freechat_sdk/models/rag_task_details_dto.py
+Comment: 
+
+Filename: freechat_sdk/models/rag_task_dto.py
+Comment: 
+
+Filename: freechat_sdk/models/sse_emitter.py
+Comment: 
+
+Filename: freechat_sdk/models/token_usage_dto.py
+Comment: 
+
+Filename: freechat_sdk/models/user_basic_info_dto.py
+Comment: 
+
+Filename: freechat_sdk/models/user_details_dto.py
+Comment: 
+
+Filename: freechat_sdk/models/user_full_details_dto.py
+Comment: 
+
+Filename: freechat_sdk-1.0.0.dist-info/METADATA
+Comment: 
+
+Filename: freechat_sdk-1.0.0.dist-info/WHEEL
+Comment: 
+
+Filename: freechat_sdk-1.0.0.dist-info/top_level.txt
+Comment: 
+
+Filename: freechat_sdk-1.0.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## Comparing `freechat-sdk/api/__init__.py` & `freechat_sdk/api/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,17 +1,19 @@
 # flake8: noqa
 
 # import apis into api package
-from freechat-sdk.api.ai_service_api import AIServiceApi
-from freechat-sdk.api.account_api import AccountApi
-from freechat-sdk.api.account_manager_for_admin_api import AccountManagerForAdminApi
-from freechat-sdk.api.app_config_for_admin_api import AppConfigForAdminApi
-from freechat-sdk.api.app_meta_for_admin_api import AppMetaForAdminApi
-from freechat-sdk.api.character_api import CharacterApi
-from freechat-sdk.api.encryption_manager_for_admin_api import EncryptionManagerForAdminApi
-from freechat-sdk.api.flow_api import FlowApi
-from freechat-sdk.api.interactive_statistics_api import InteractiveStatisticsApi
-from freechat-sdk.api.organization_api import OrganizationApi
-from freechat-sdk.api.plugin_api import PluginApi
-from freechat-sdk.api.prompt_api import PromptApi
-from freechat-sdk.api.prompt_task_api import PromptTaskApi
+from freechat_sdk.api.ai_service_api import AIServiceApi
+from freechat_sdk.api.account_api import AccountApi
+from freechat_sdk.api.account_manager_for_admin_api import AccountManagerForAdminApi
+from freechat_sdk.api.agent_api import AgentApi
+from freechat_sdk.api.app_config_for_admin_api import AppConfigForAdminApi
+from freechat_sdk.api.app_meta_for_admin_api import AppMetaForAdminApi
+from freechat_sdk.api.character_api import CharacterApi
+from freechat_sdk.api.chat_api import ChatApi
+from freechat_sdk.api.encryption_manager_for_admin_api import EncryptionManagerForAdminApi
+from freechat_sdk.api.interactive_statistics_api import InteractiveStatisticsApi
+from freechat_sdk.api.organization_api import OrganizationApi
+from freechat_sdk.api.plugin_api import PluginApi
+from freechat_sdk.api.prompt_api import PromptApi
+from freechat_sdk.api.prompt_task_api import PromptTaskApi
+from freechat_sdk.api.rag_api import RagApi
```

## Comparing `freechat-sdk/api/account_api.py` & `freechat_sdk/api/account_manager_for_admin_api.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,79 +1,77 @@
 # coding: utf-8
 
 """
     FreeChat OpenAPI Definition
 
-    https://github.com/freechat-fun/freechat
+    # FreeChat: Create Some Friends for Yourself with AI  English | [中文版](https://github.com/freechat-fun/freechat/blob/main/README.zh-CN.md)  ## Introduction Welcome! FreeChat aims to build a cloud-native, robust, and quickly commercializable enterprise-level AI virtual character platform.  ## Features - Primarily uses Java and emphasizes **security, robustness, scalability, traceability, and maintainability**. - oasts **account systems and permission management**, supporting OAuth2 authentication. Introduces the \"organization\" concept and related permission constraint functions. - Extensively employs **distributed technologies and caching** to support **high concurrency** access. - Provides flexible character customization options, supports direct intervention in prompts, and supports **configuring multiple backends for each character**. - **Offers a comprehensive range of Open APIs**, with more than 180 interfaces and provides java/python/typescript SDKs. These interfaces enable easy construction of systems for end-users. - Supports setting **RAG** (Retrieval Augmented Generation) for characters. - Supports **long-term memory** for characters. - Supports setting **quota limits** for characters.  ## System Snapshots  ## Character Design ```mermaid flowchart TD     A(Character) --> B(Profile)     A --> C(Knowledge/RAG)     A --> D(Album)     A --> E(Backend-1)     A --> F(Backend-n...)     E --> G(Message Window)     E --> H(Long Term Memory Settings)     E --> I(Quota Limit)     E --> J(Chat Prompt Task)     E --> K(Greeting Prompt Task)     E --> L(Moderation Settings)     J --> M(Model & Parameters)     J --> N(API Keys)     J --> O(Prompt Refence)     J --> P(Tool Specifications)     O --> Q(Template)     O --> R(Variables)     O --> S(Version)     O --> T(...)     style K stroke-dasharray: 5, 5     style L stroke-dasharray: 5, 5     style P stroke-dasharray: 5, 5 ```  After setting up a unified persona and knowledge for a character, different backends can be configured. For example, different model may be adopted for different users based on cost considerations.  ## How to Play ### Online Website You can visit [freechat.fun](https://freechat.fun) to experience FreeChat. Share your designed AI character!  ### Running in a Kubernetes Cluster FreeChat is dedicated to the principles of cloud-native design. If you have a Kubernetes cluster, you can deploy FreeChat to your environment by following these steps:  1. Put the Kubernetes configuration file in the `configs/helm/` directory, named `kube-private.conf`. 2. Place the Helm configuration file in the same directory, named `values-private.yaml`. Make sure to reference the default `values.yaml` and customize the variables as needed. 3. Switch to the `scripts/` directory. 4. If needed, execute `install-in.sh` to deploy `ingress-nginx` to the Kubernetes cluster. 5. If needed, run `install-cm.sh` to deploy `cert-manager` on the Kubernetes cluster, which automatically issues certificates for domains specified in `ingress.hosts`. 6. Run `install-pvc.sh` to install PersistentVolumeClaim resources.      > By default, FreeChat operates files by accessing the \"local file system.\" You may want to use high-availability distributed storage in the cloud. As a cloud-native-designed system, we recommend interfacing through Kubernetes CSI to avoid individually adapting storage products for each cloud platform. Most cloud service providers offer cloud storage drivers for Kubernetes, with a series of predefined StorageClass resources. Please choose the appropriate configuration according to your actual needs and set it in Helm's `global.storageClass` option.     >      > *In the future, FreeChat may be refactored to use MinIO's APIs directly, as it is now installed in the Kubernetes cluster as a dependency (serving Milvus).*  7. Execute the `install.sh` script to install FreeChat and its dependencies. 8. FreeChat aims to provide Open API services. If you like the interactive experience of [freechat.fun](https://freechat.fun), run `install-web.sh` to deploy the front-end application. 9. Execute `restart.sh` to restart the service. 10. If you modified any Helm configuration files, use `upgrade.sh` to update the corresponding Kubernetes resources. 11. To remove specific resources, run the `uninstall*.sh` script corresponding to the resource you want to uninstall.  As a cloud-native application, the services FreeChat relies on are obtained and deployed to your cluster through the helm repository.  If you prefer cloud services with SLA (Service Level Agreement) guarantees, simply make the relevant settings in `configs/helm/values-private.yaml`: ```yaml bitnami:   mysql:     enabled: false   redis:     enabled: false   milvus:     enabled: false  mysql:   url: <your mysql url>   auth:     rootPassword: <your mysql root password>     username: <your mysql username>     password: <your mysql password for the username>  redis:   url: <your redis url>   auth:     password: <your redis password>   milvus:   url: <your milvus url>   milvus:     auth:       token: <your milvus api-key> ```  With this, FreeChat will not automatically install these services, but rather use the configuration information to connect directly.  ### Running Locally You can also run FreeChat locally. Currently supported on MacOS and Linux (although only tested on MacOS). You need to install the Docker toolset and have a network that can access [Docker Hub](https://hub.docker.com/).  Once ready, enter the `scripts/` directory and run `local-run.sh`, which will download and run the necessary docker containers. After a successful startup, you can access `http://localhost` via a browser to see the locally running freechat.fun. Use `local-run.sh --help` to view the supported options of the script. Good luck!  ### Running in an IDE To run FreeChat in an IDE, you need to start all dependent services first but do not need to run the container for the FreeChat application itself. You can execute the `scripts/local-deps.sh` script to start services like `MySQL`, `Redis`, `Milvus`, etc., locally. Once done, open and debug `freechat-start/src/main/java/fun/freechat/Application.java`。Make sure you have set the following startup parameters: ```shell -Dspring.config.location=classpath:/application.yml,classpath:/application-local.yml \\ -DAPP_HOME=local-data/freechat \\ -Dspring.profiles.active=local ```  ### 使用 SDK #### Java - **Dependency** ```xml <dependency>   <groupId>fun.freechat</groupId>   <artifactId>freechat-sdk</artifactId>   <version>${freechat-sdk.version}</version> </dependency> ```  - **Example** ```java import fun.freechat.client.ApiClient; import fun.freechat.client.ApiException; import fun.freechat.client.Configuration; import fun.freechat.client.api.AccountApi; import fun.freechat.client.auth.ApiKeyAuth; import fun.freechat.client.model.UserDetailsDTO;  public class AccountClientExample {     public static void main(String[] args) {         ApiClient defaultClient = Configuration.getDefaultApiClient();         defaultClient.setBasePath(\"https://freechat.fun\");                  // Configure HTTP bearer authorization: bearerAuth         HttpBearerAuth bearerAuth = (HttpBearerAuth) defaultClient.getAuthentication(\"bearerAuth\");         bearerAuth.setBearerToken(\"FREECHAT_TOKEN\");          AccountApi apiInstance = new AccountApi(defaultClient);         try {             UserDetailsDTO result = apiInstance.getUserDetails();             System.out.println(result);         } catch (ApiException e) {             e.printStackTrace();         }     } } ```  #### Python - **Installation** ```shell pip install freechat-sdk ```  - **Example** ```python import freechat_sdk from freechat_sdk.rest import ApiException from pprint import pprint  # Defining the host is optional and defaults to https://freechat.fun # See configuration.py for a list of all supported configuration parameters. configuration = freechat_sdk.Configuration(     host = \"https://freechat.fun\" )  # Configure Bearer authorization: bearerAuth configuration = freechat_sdk.Configuration(     access_token = os.environ[\"FREECHAT_TOKEN\"] )  # Enter a context with an instance of the API client with freechat_sdk.ApiClient(configuration) as api_client:     # Create an instance of the API class     api_instance = freechat_sdk.AccountApi(api_client)      try:         details = api_instance.get_user_details()         pprint(details)     except ApiException as e:         print(\"Exception when calling AccountClient->get_user_details: %s\\n\" % e) ```  #### TypeScript - **Installation** ```shell npm install freechat-sdk --save ```  - **Example** Refer to [FreeChatApiContext.tsx](https://github.com/freechat-fun/freechat/blob/main/freechat-web/src/contexts/FreeChatApiProvider.tsx)  ## System Dependencies | | Projects | ---- | ---- | Application Framework | [Spring Boot](https://spring.io/projects/spring-boot/) | LLM Framework | [LangChain4j](https://docs.langchain4j.dev/) | Model Providers | [OpenAI](https://platform.openai.com/), [DashScope](https://dashscope.aliyun.com/) | Database Systems | [MySQL](https://www.mysql.com/), [Redis](https://redis.io/), [Milvus](https://milvus.io/) | OpenAPI Tools | [Springdoc-openapi](https://springdoc.org/), [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator), [OpenAPI Explorer](https://github.com/Authress-Engineering/openapi-explorer)  ## Collaboration ### Application Integration The FreeChat system is entirely oriented towards Open APIs. The site [freechat.fun](https://freechat.fun) is developed using its TypeScript SDK and hardly depends on private interfaces. You can use these online interfaces to develop your own applications or sites, making them fit your preferences. Currently, FreeChat is completely free with no paid plans (after all, users use their own API Key to call LLM services).  ### Model Integration FreeChat aims to explore AI virtual character technology with anthropomorphic characteristics. So far, it supports model services from OpenAI and DashScope ([HuggingFace](https://huggingface.co/) is also expected to be supported soon). However, we are more interested in supporting models that are under research and can endow AI with more personality traits. If you are researching this area and hope FreeChat supports your model, please contact us. We look forward to AI technology helping people create their own \"soul mates\" in the future.
 
-    The version of the OpenAPI document: 0.1.0
+    The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
-import io
 import warnings
-
 from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
-
-try:
-    from typing import Annotated
-except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import Field
+from typing import Any, Dict, List, Optional, Tuple, Union
 from typing_extensions import Annotated
-from pydantic import StrictBytes, StrictInt, StrictStr
-
-from typing import List, Union
 
-from freechat-sdk.models.user_basic_info_dto import UserBasicInfoDTO
-from freechat-sdk.models.user_details_dto import UserDetailsDTO
+from pydantic import Field, StrictBool, StrictInt, StrictStr
+from typing import List
+from typing_extensions import Annotated
+from freechat_sdk.models.api_token_info_dto import ApiTokenInfoDTO
+from freechat_sdk.models.user_basic_info_dto import UserBasicInfoDTO
+from freechat_sdk.models.user_details_dto import UserDetailsDTO
+from freechat_sdk.models.user_full_details_dto import UserFullDetailsDTO
 
-from freechat-sdk.api_client import ApiClient
-from freechat-sdk.api_response import ApiResponse
-from freechat-sdk.rest import RESTResponseType
+from freechat_sdk.api_client import ApiClient, RequestSerialized
+from freechat_sdk.api_response import ApiResponse
+from freechat_sdk.rest import RESTResponseType
 
 
-class AccountApi:
+class AccountManagerForAdminApi:
     """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     def __init__(self, api_client=None) -> None:
         if api_client is None:
             api_client = ApiClient.get_default()
         self.api_client = api_client
 
 
     @validate_call
-    def create_token(
+    def create_token_for_user(
         self,
+        username: Annotated[StrictStr, Field(description="Username")],
+        duration: Annotated[int, Field(strict=True, ge=0, description="Validity period (seconds)")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> str:
-        """Create API Token
+        """Create API Token for User.
 
-        Create an unlimited duration API Token.
+        Create an API Token for a specified user, valid for duration seconds.
 
+        :param username: Username (required)
+        :type username: str
+        :param duration: Validity period (seconds) (required)
+        :type duration: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -88,56 +86,63 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_token_serialize(
+        _param = self._create_token_for_user_serialize(
+            username=username,
+            duration=duration,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def create_token_with_http_info(
+    def create_token_for_user_with_http_info(
         self,
+        username: Annotated[StrictStr, Field(description="Username")],
+        duration: Annotated[int, Field(strict=True, ge=0, description="Validity period (seconds)")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[str]:
-        """Create API Token
+        """Create API Token for User.
 
-        Create an unlimited duration API Token.
+        Create an API Token for a specified user, valid for duration seconds.
 
+        :param username: Username (required)
+        :type username: str
+        :param duration: Validity period (seconds) (required)
+        :type duration: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -152,56 +157,63 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_token_serialize(
+        _param = self._create_token_for_user_serialize(
+            username=username,
+            duration=duration,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def create_token_without_preload_content(
+    def create_token_for_user_without_preload_content(
         self,
+        username: Annotated[StrictStr, Field(description="Username")],
+        duration: Annotated[int, Field(strict=True, ge=0, description="Validity period (seconds)")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Create API Token
+        """Create API Token for User.
 
-        Create an unlimited duration API Token.
+        Create an API Token for a specified user, valid for duration seconds.
 
+        :param username: Username (required)
+        :type username: str
+        :param duration: Validity period (seconds) (required)
+        :type duration: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -216,54 +228,60 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_token_serialize(
+        _param = self._create_token_for_user_serialize(
+            username=username,
+            duration=duration,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _create_token_serialize(
+    def _create_token_for_user_serialize(
         self,
+        username,
+        duration,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
+        if username is not None:
+            _path_params['username'] = username
+        if duration is not None:
+            _path_params['duration'] = duration
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
@@ -277,15 +295,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/account/token',
+            resource_path='/api/v1/admin/token/{username}/{duration}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -294,36 +312,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def create_token_with_duration(
+    def create_user(
         self,
-        duration: Annotated[StrictInt, Field(description="Token validity duration (seconds)")],
+        user_full_details_dto: Annotated[UserFullDetailsDTO, Field(description="User information")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> str:
-        """Create Timed API Token
+    ) -> bool:
+        """Create User
 
-        Create a timed API Token, valid for {duration} seconds.
+        Create user.
 
-        :param duration: Token validity duration (seconds) (required)
-        :type duration: int
+        :param user_full_details_dto: User information (required)
+        :type user_full_details_dto: UserFullDetailsDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -338,60 +356,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_token_with_duration_serialize(
-            duration=duration,
+        _param = self._create_user_serialize(
+            user_full_details_dto=user_full_details_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def create_token_with_duration_with_http_info(
+    def create_user_with_http_info(
         self,
-        duration: Annotated[StrictInt, Field(description="Token validity duration (seconds)")],
+        user_full_details_dto: Annotated[UserFullDetailsDTO, Field(description="User information")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[str]:
-        """Create Timed API Token
+    ) -> ApiResponse[bool]:
+        """Create User
 
-        Create a timed API Token, valid for {duration} seconds.
+        Create user.
 
-        :param duration: Token validity duration (seconds) (required)
-        :type duration: int
+        :param user_full_details_dto: User information (required)
+        :type user_full_details_dto: UserFullDetailsDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -406,60 +423,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_token_with_duration_serialize(
-            duration=duration,
+        _param = self._create_user_serialize(
+            user_full_details_dto=user_full_details_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def create_token_with_duration_without_preload_content(
+    def create_user_without_preload_content(
         self,
-        duration: Annotated[StrictInt, Field(description="Token validity duration (seconds)")],
+        user_full_details_dto: Annotated[UserFullDetailsDTO, Field(description="User information")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Create Timed API Token
+        """Create User
 
-        Create a timed API Token, valid for {duration} seconds.
+        Create user.
 
-        :param duration: Token validity duration (seconds) (required)
-        :type duration: int
+        :param user_full_details_dto: User information (required)
+        :type user_full_details_dto: UserFullDetailsDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -474,80 +490,91 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_token_with_duration_serialize(
-            duration=duration,
+        _param = self._create_user_serialize(
+            user_full_details_dto=user_full_details_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _create_token_with_duration_serialize(
+    def _create_user_serialize(
         self,
-        duration,
+        user_full_details_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if duration is not None:
-            _path_params['duration'] = duration
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
+        if user_full_details_dto is not None:
+            _body_params = user_full_details_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
-                'text/plain'
+                'application/json'
             ]
         )
 
+        # set the HTTP header `Content-Type`
+        if _content_type:
+            _header_params['Content-Type'] = _content_type
+        else:
+            _default_content_type = (
+                self.api_client.select_header_content_type(
+                    [
+                        'application/json'
+                    ]
+                )
+            )
+            if _default_content_type is not None:
+                _header_params['Content-Type'] = _default_content_type
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/account/token/{duration}',
+            resource_path='/api/v1/admin/user',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -556,35 +583,35 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def delete_token(
+    def delete_token_for_user(
         self,
-        token: Annotated[StrictStr, Field(description="Token content")],
+        token: Annotated[StrictStr, Field(description="API Token")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> str:
+    ) -> bool:
         """Delete API Token
 
-        Delete an API Token.
+        Delete the specified API Token.
 
-        :param token: Token content (required)
+        :param token: API Token (required)
         :type token: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
@@ -600,59 +627,58 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_token_serialize(
+        _param = self._delete_token_for_user_serialize(
             token=token,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def delete_token_with_http_info(
+    def delete_token_for_user_with_http_info(
         self,
-        token: Annotated[StrictStr, Field(description="Token content")],
+        token: Annotated[StrictStr, Field(description="API Token")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[str]:
+    ) -> ApiResponse[bool]:
         """Delete API Token
 
-        Delete an API Token.
+        Delete the specified API Token.
 
-        :param token: Token content (required)
+        :param token: API Token (required)
         :type token: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
@@ -668,41 +694,40 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_token_serialize(
+        _param = self._delete_token_for_user_serialize(
             token=token,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def delete_token_without_preload_content(
+    def delete_token_for_user_without_preload_content(
         self,
-        token: Annotated[StrictStr, Field(description="Token content")],
+        token: Annotated[StrictStr, Field(description="API Token")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
@@ -710,17 +735,17 @@
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
         """Delete API Token
 
-        Delete an API Token.
+        Delete the specified API Token.
 
-        :param token: Token content (required)
+        :param token: API Token (required)
         :type token: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
@@ -736,80 +761,78 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_token_serialize(
+        _param = self._delete_token_for_user_serialize(
             token=token,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _delete_token_serialize(
+    def _delete_token_for_user_serialize(
         self,
         token,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if token is not None:
             _path_params['token'] = token
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
-                'text/plain'
+                'application/json'
             ]
         )
 
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='DELETE',
-            resource_path='/api/v1/account/token/{token}',
+            resource_path='/api/v1/admin/token/{token}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -818,35 +841,293 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def disable_token(
+    def delete_user(
         self,
-        token: Annotated[StrictStr, Field(description="Token content")],
+        username: Annotated[StrictStr, Field(description="Username")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> str:
+    ) -> bool:
+        """Delete User
+
+        Delete user by username.
+
+        :param username: Username (required)
+        :type username: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._delete_user_serialize(
+            username=username,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "bool",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        ).data
+
+
+    @validate_call
+    def delete_user_with_http_info(
+        self,
+        username: Annotated[StrictStr, Field(description="Username")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> ApiResponse[bool]:
+        """Delete User
+
+        Delete user by username.
+
+        :param username: Username (required)
+        :type username: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._delete_user_serialize(
+            username=username,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "bool",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        )
+
+
+    @validate_call
+    def delete_user_without_preload_content(
+        self,
+        username: Annotated[StrictStr, Field(description="Username")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> RESTResponseType:
+        """Delete User
+
+        Delete user by username.
+
+        :param username: Username (required)
+        :type username: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._delete_user_serialize(
+            username=username,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "bool",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        return response_data.response
+
+
+    def _delete_user_serialize(
+        self,
+        username,
+        _request_auth,
+        _content_type,
+        _headers,
+        _host_index,
+    ) -> RequestSerialized:
+
+        _host = None
+
+        _collection_formats: Dict[str, str] = {
+        }
+
+        _path_params: Dict[str, str] = {}
+        _query_params: List[Tuple[str, str]] = []
+        _header_params: Dict[str, Optional[str]] = _headers or {}
+        _form_params: List[Tuple[str, str]] = []
+        _files: Dict[str, Union[str, bytes]] = {}
+        _body_params: Optional[bytes] = None
+
+        # process the path parameters
+        if username is not None:
+            _path_params['username'] = username
+        # process the query parameters
+        # process the header parameters
+        # process the form parameters
+        # process the body parameter
+
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            [
+                'application/json'
+            ]
+        )
+
+
+        # authentication setting
+        _auth_settings: List[str] = [
+            'bearerAuth'
+        ]
+
+        return self.api_client.param_serialize(
+            method='DELETE',
+            resource_path='/api/v1/admin/user/{username}',
+            path_params=_path_params,
+            query_params=_query_params,
+            header_params=_header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            auth_settings=_auth_settings,
+            collection_formats=_collection_formats,
+            _host=_host,
+            _request_auth=_request_auth
+        )
+
+
+
+
+    @validate_call
+    def disable_token_for_user(
+        self,
+        token: Annotated[StrictStr, Field(description="API Token")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> bool:
         """Disable API Token
 
-        Disable an API Token, the token is not deleted.
+        Disable the specified API Token.
 
-        :param token: Token content (required)
+        :param token: API Token (required)
         :type token: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
@@ -862,59 +1143,58 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._disable_token_serialize(
+        _param = self._disable_token_for_user_serialize(
             token=token,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def disable_token_with_http_info(
+    def disable_token_for_user_with_http_info(
         self,
-        token: Annotated[StrictStr, Field(description="Token content")],
+        token: Annotated[StrictStr, Field(description="API Token")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[str]:
+    ) -> ApiResponse[bool]:
         """Disable API Token
 
-        Disable an API Token, the token is not deleted.
+        Disable the specified API Token.
 
-        :param token: Token content (required)
+        :param token: API Token (required)
         :type token: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
@@ -930,41 +1210,40 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._disable_token_serialize(
+        _param = self._disable_token_for_user_serialize(
             token=token,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def disable_token_without_preload_content(
+    def disable_token_for_user_without_preload_content(
         self,
-        token: Annotated[StrictStr, Field(description="Token content")],
+        token: Annotated[StrictStr, Field(description="API Token")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
@@ -972,17 +1251,17 @@
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
         """Disable API Token
 
-        Disable an API Token, the token is not deleted.
+        Disable the specified API Token.
 
-        :param token: Token content (required)
+        :param token: API Token (required)
         :type token: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
@@ -998,80 +1277,78 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._disable_token_serialize(
+        _param = self._disable_token_for_user_serialize(
             token=token,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _disable_token_serialize(
+    def _disable_token_for_user_serialize(
         self,
         token,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if token is not None:
             _path_params['token'] = token
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
-                'text/plain'
+                'application/json'
             ]
         )
 
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='PUT',
-            resource_path='/api/v1/account/token/{token}',
+            resource_path='/api/v1/admin/token/{token}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -1080,33 +1357,33 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def get_user_basic(
+    def get_details_of_user(
         self,
         username: Annotated[StrictStr, Field(description="Username")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> UserBasicInfoDTO:
-        """Get User Basic Information
+    ) -> UserDetailsDTO:
+        """Get User Details
 
-        Return user basic information, including: username, nickname, avatar link.
+        Return detailed user information.
 
         :param username: Username (required)
         :type username: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
@@ -1124,57 +1401,56 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_user_basic_serialize(
+        _param = self._get_details_of_user_serialize(
             username=username,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "UserBasicInfoDTO"
-            
+            '200': "UserDetailsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def get_user_basic_with_http_info(
+    def get_details_of_user_with_http_info(
         self,
         username: Annotated[StrictStr, Field(description="Username")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[UserBasicInfoDTO]:
-        """Get User Basic Information
+    ) -> ApiResponse[UserDetailsDTO]:
+        """Get User Details
 
-        Return user basic information, including: username, nickname, avatar link.
+        Return detailed user information.
 
         :param username: Username (required)
         :type username: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
@@ -1192,39 +1468,38 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_user_basic_serialize(
+        _param = self._get_details_of_user_serialize(
             username=username,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "UserBasicInfoDTO"
-            
+            '200': "UserDetailsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def get_user_basic_without_preload_content(
+    def get_details_of_user_without_preload_content(
         self,
         username: Annotated[StrictStr, Field(description="Username")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
@@ -1232,17 +1507,17 @@
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Get User Basic Information
+        """Get User Details
 
-        Return user basic information, including: username, nickname, avatar link.
+        Return detailed user information.
 
         :param username: Username (required)
         :type username: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
@@ -1260,53 +1535,51 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_user_basic_serialize(
+        _param = self._get_details_of_user_serialize(
             username=username,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "UserBasicInfoDTO"
-            
+            '200': "UserDetailsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _get_user_basic_serialize(
+    def _get_details_of_user_serialize(
         self,
         username,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if username is not None:
             _path_params['username'] = username
         # process the query parameters
         # process the header parameters
@@ -1325,15 +1598,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='GET',
-            resource_path='/api/v1/account/basic/{username}',
+            resource_path='/api/v1/admin/user/{username}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -1342,33 +1615,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def get_user_details(
+    def get_user_by_token(
         self,
+        token: Annotated[StrictStr, Field(description="API Token")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> UserDetailsDTO:
-        """Get User Details
+        """Get User by API Token
 
-        Return the detailed user information of the current account, the fields refer to the [standard claims](https://openid.net/specs/openid-connect-core-1_0.html#Claims) of OpenID Connect (OIDC).
+        Get the detailed user information corresponding to the API Token.
 
+        :param token: API Token (required)
+        :type token: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1383,56 +1659,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_user_details_serialize(
+        _param = self._get_user_by_token_serialize(
+            token=token,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "UserDetailsDTO"
-            
+            '200': "UserDetailsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def get_user_details_with_http_info(
+    def get_user_by_token_with_http_info(
         self,
+        token: Annotated[StrictStr, Field(description="API Token")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[UserDetailsDTO]:
-        """Get User Details
+        """Get User by API Token
 
-        Return the detailed user information of the current account, the fields refer to the [standard claims](https://openid.net/specs/openid-connect-core-1_0.html#Claims) of OpenID Connect (OIDC).
+        Get the detailed user information corresponding to the API Token.
 
+        :param token: API Token (required)
+        :type token: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1447,56 +1726,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_user_details_serialize(
+        _param = self._get_user_by_token_serialize(
+            token=token,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "UserDetailsDTO"
-            
+            '200': "UserDetailsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def get_user_details_without_preload_content(
+    def get_user_by_token_without_preload_content(
         self,
+        token: Annotated[StrictStr, Field(description="API Token")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Get User Details
+        """Get User by API Token
 
-        Return the detailed user information of the current account, the fields refer to the [standard claims](https://openid.net/specs/openid-connect-core-1_0.html#Claims) of OpenID Connect (OIDC).
+        Get the detailed user information corresponding to the API Token.
 
+        :param token: API Token (required)
+        :type token: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1511,54 +1793,56 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_user_details_serialize(
+        _param = self._get_user_by_token_serialize(
+            token=token,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "UserDetailsDTO"
-            
+            '200': "UserDetailsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _get_user_details_serialize(
+    def _get_user_by_token_serialize(
         self,
+        token,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
+        if token is not None:
+            _path_params['token'] = token
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
@@ -1572,15 +1856,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='GET',
-            resource_path='/api/v1/account/details',
+            resource_path='/api/v1/admin/tokenBy/{token}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -1589,33 +1873,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def list_tokens(
+    def list_authorities_of_user(
         self,
+        username: Annotated[StrictStr, Field(description="Username")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> List[str]:
-        """List API Tokens
+        """List User Permissions
 
-        List currently valid tokens.
+        List the user's permissions.
 
+        :param username: Username (required)
+        :type username: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1630,56 +1917,848 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_tokens_serialize(
+        _param = self._list_authorities_of_user_serialize(
+            username=username,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def list_tokens_with_http_info(
+    def list_authorities_of_user_with_http_info(
         self,
+        username: Annotated[StrictStr, Field(description="Username")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[List[str]]:
-        """List API Tokens
+        """List User Permissions
+
+        List the user's permissions.
+
+        :param username: Username (required)
+        :type username: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._list_authorities_of_user_serialize(
+            username=username,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "List[str]",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        )
+
+
+    @validate_call
+    def list_authorities_of_user_without_preload_content(
+        self,
+        username: Annotated[StrictStr, Field(description="Username")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> RESTResponseType:
+        """List User Permissions
+
+        List the user's permissions.
+
+        :param username: Username (required)
+        :type username: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._list_authorities_of_user_serialize(
+            username=username,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "List[str]",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        return response_data.response
+
+
+    def _list_authorities_of_user_serialize(
+        self,
+        username,
+        _request_auth,
+        _content_type,
+        _headers,
+        _host_index,
+    ) -> RequestSerialized:
+
+        _host = None
+
+        _collection_formats: Dict[str, str] = {
+        }
+
+        _path_params: Dict[str, str] = {}
+        _query_params: List[Tuple[str, str]] = []
+        _header_params: Dict[str, Optional[str]] = _headers or {}
+        _form_params: List[Tuple[str, str]] = []
+        _files: Dict[str, Union[str, bytes]] = {}
+        _body_params: Optional[bytes] = None
+
+        # process the path parameters
+        if username is not None:
+            _path_params['username'] = username
+        # process the query parameters
+        # process the header parameters
+        # process the form parameters
+        # process the body parameter
+
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            [
+                'application/json'
+            ]
+        )
+
+
+        # authentication setting
+        _auth_settings: List[str] = [
+            'bearerAuth'
+        ]
+
+        return self.api_client.param_serialize(
+            method='GET',
+            resource_path='/api/v1/admin/authority/{username}',
+            path_params=_path_params,
+            query_params=_query_params,
+            header_params=_header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            auth_settings=_auth_settings,
+            collection_formats=_collection_formats,
+            _host=_host,
+            _request_auth=_request_auth
+        )
+
+
+
+
+    @validate_call
+    def list_tokens_of_user(
+        self,
+        username: Annotated[StrictStr, Field(description="Username")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> List[ApiTokenInfoDTO]:
+        """Get API Token of User
+
+        Get the list of API Tokens of the user.
+
+        :param username: Username (required)
+        :type username: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._list_tokens_of_user_serialize(
+            username=username,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "List[ApiTokenInfoDTO]",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        ).data
+
+
+    @validate_call
+    def list_tokens_of_user_with_http_info(
+        self,
+        username: Annotated[StrictStr, Field(description="Username")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> ApiResponse[List[ApiTokenInfoDTO]]:
+        """Get API Token of User
+
+        Get the list of API Tokens of the user.
+
+        :param username: Username (required)
+        :type username: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._list_tokens_of_user_serialize(
+            username=username,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "List[ApiTokenInfoDTO]",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        )
+
+
+    @validate_call
+    def list_tokens_of_user_without_preload_content(
+        self,
+        username: Annotated[StrictStr, Field(description="Username")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> RESTResponseType:
+        """Get API Token of User
+
+        Get the list of API Tokens of the user.
+
+        :param username: Username (required)
+        :type username: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._list_tokens_of_user_serialize(
+            username=username,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "List[ApiTokenInfoDTO]",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        return response_data.response
+
+
+    def _list_tokens_of_user_serialize(
+        self,
+        username,
+        _request_auth,
+        _content_type,
+        _headers,
+        _host_index,
+    ) -> RequestSerialized:
+
+        _host = None
+
+        _collection_formats: Dict[str, str] = {
+        }
+
+        _path_params: Dict[str, str] = {}
+        _query_params: List[Tuple[str, str]] = []
+        _header_params: Dict[str, Optional[str]] = _headers or {}
+        _form_params: List[Tuple[str, str]] = []
+        _files: Dict[str, Union[str, bytes]] = {}
+        _body_params: Optional[bytes] = None
+
+        # process the path parameters
+        if username is not None:
+            _path_params['username'] = username
+        # process the query parameters
+        # process the header parameters
+        # process the form parameters
+        # process the body parameter
+
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            [
+                'application/json'
+            ]
+        )
+
+
+        # authentication setting
+        _auth_settings: List[str] = [
+            'bearerAuth'
+        ]
+
+        return self.api_client.param_serialize(
+            method='GET',
+            resource_path='/api/v1/admin/token/{username}',
+            path_params=_path_params,
+            query_params=_query_params,
+            header_params=_header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            auth_settings=_auth_settings,
+            collection_formats=_collection_formats,
+            _host=_host,
+            _request_auth=_request_auth
+        )
+
+
+
+
+    @validate_call
+    def list_users(
+        self,
+        page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
+        page_num: Annotated[StrictInt, Field(description="Current page number")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> List[UserBasicInfoDTO]:
+        """List User Information
+
+        Return user information by page, return the pageNum page, up to pageSize user information.
+
+        :param page_size: Maximum quantity (required)
+        :type page_size: int
+        :param page_num: Current page number (required)
+        :type page_num: int
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._list_users_serialize(
+            page_size=page_size,
+            page_num=page_num,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "List[UserBasicInfoDTO]",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        ).data
+
+
+    @validate_call
+    def list_users_with_http_info(
+        self,
+        page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
+        page_num: Annotated[StrictInt, Field(description="Current page number")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> ApiResponse[List[UserBasicInfoDTO]]:
+        """List User Information
+
+        Return user information by page, return the pageNum page, up to pageSize user information.
+
+        :param page_size: Maximum quantity (required)
+        :type page_size: int
+        :param page_num: Current page number (required)
+        :type page_num: int
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._list_users_serialize(
+            page_size=page_size,
+            page_num=page_num,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "List[UserBasicInfoDTO]",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        )
+
+
+    @validate_call
+    def list_users_without_preload_content(
+        self,
+        page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
+        page_num: Annotated[StrictInt, Field(description="Current page number")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> RESTResponseType:
+        """List User Information
+
+        Return user information by page, return the pageNum page, up to pageSize user information.
+
+        :param page_size: Maximum quantity (required)
+        :type page_size: int
+        :param page_num: Current page number (required)
+        :type page_num: int
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._list_users_serialize(
+            page_size=page_size,
+            page_num=page_num,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "List[UserBasicInfoDTO]",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        return response_data.response
+
+
+    def _list_users_serialize(
+        self,
+        page_size,
+        page_num,
+        _request_auth,
+        _content_type,
+        _headers,
+        _host_index,
+    ) -> RequestSerialized:
+
+        _host = None
+
+        _collection_formats: Dict[str, str] = {
+        }
+
+        _path_params: Dict[str, str] = {}
+        _query_params: List[Tuple[str, str]] = []
+        _header_params: Dict[str, Optional[str]] = _headers or {}
+        _form_params: List[Tuple[str, str]] = []
+        _files: Dict[str, Union[str, bytes]] = {}
+        _body_params: Optional[bytes] = None
+
+        # process the path parameters
+        if page_size is not None:
+            _path_params['pageSize'] = page_size
+        if page_num is not None:
+            _path_params['pageNum'] = page_num
+        # process the query parameters
+        # process the header parameters
+        # process the form parameters
+        # process the body parameter
+
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            [
+                'application/json'
+            ]
+        )
+
+
+        # authentication setting
+        _auth_settings: List[str] = [
+            'bearerAuth'
+        ]
+
+        return self.api_client.param_serialize(
+            method='GET',
+            resource_path='/api/v1/admin/users/{pageSize}/{pageNum}',
+            path_params=_path_params,
+            query_params=_query_params,
+            header_params=_header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            auth_settings=_auth_settings,
+            collection_formats=_collection_formats,
+            _host=_host,
+            _request_auth=_request_auth
+        )
+
+
+
+
+    @validate_call
+    def list_users1(
+        self,
+        page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> List[UserBasicInfoDTO]:
+        """List User Information
+
+        Return user information by page, return the pageNum page, up to pageSize user information.
+
+        :param page_size: Maximum quantity (required)
+        :type page_size: int
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._list_users1_serialize(
+            page_size=page_size,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "List[UserBasicInfoDTO]",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        ).data
+
+
+    @validate_call
+    def list_users1_with_http_info(
+        self,
+        page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> ApiResponse[List[UserBasicInfoDTO]]:
+        """List User Information
 
-        List currently valid tokens.
+        Return user information by page, return the pageNum page, up to pageSize user information.
 
+        :param page_size: Maximum quantity (required)
+        :type page_size: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1694,56 +2773,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_tokens_serialize(
+        _param = self._list_users1_serialize(
+            page_size=page_size,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[UserBasicInfoDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def list_tokens_without_preload_content(
+    def list_users1_without_preload_content(
         self,
+        page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """List API Tokens
+        """List User Information
 
-        List currently valid tokens.
+        Return user information by page, return the pageNum page, up to pageSize user information.
 
+        :param page_size: Maximum quantity (required)
+        :type page_size: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1758,54 +2840,56 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_tokens_serialize(
+        _param = self._list_users1_serialize(
+            page_size=page_size,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[UserBasicInfoDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _list_tokens_serialize(
+    def _list_users1_serialize(
         self,
+        page_size,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
+        if page_size is not None:
+            _path_params['pageSize'] = page_size
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
@@ -1819,15 +2903,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='GET',
-            resource_path='/api/v1/account/tokens',
+            resource_path='/api/v1/admin/users/{pageSize}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -1836,36 +2920,282 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def update_user_info(
+    def list_users2(
         self,
-        user_details_dto: Annotated[UserDetailsDTO, Field(description="User information")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> List[UserBasicInfoDTO]:
+        """List User Information
+
+        Return user information by page, return the pageNum page, up to pageSize user information.
+
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._list_users2_serialize(
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "List[UserBasicInfoDTO]",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        ).data
+
+
+    @validate_call
+    def list_users2_with_http_info(
+        self,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> ApiResponse[List[UserBasicInfoDTO]]:
+        """List User Information
+
+        Return user information by page, return the pageNum page, up to pageSize user information.
+
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._list_users2_serialize(
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "List[UserBasicInfoDTO]",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        )
+
+
+    @validate_call
+    def list_users2_without_preload_content(
+        self,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> RESTResponseType:
+        """List User Information
+
+        Return user information by page, return the pageNum page, up to pageSize user information.
+
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._list_users2_serialize(
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "List[UserBasicInfoDTO]",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        return response_data.response
+
+
+    def _list_users2_serialize(
+        self,
+        _request_auth,
+        _content_type,
+        _headers,
+        _host_index,
+    ) -> RequestSerialized:
+
+        _host = None
+
+        _collection_formats: Dict[str, str] = {
+        }
+
+        _path_params: Dict[str, str] = {}
+        _query_params: List[Tuple[str, str]] = []
+        _header_params: Dict[str, Optional[str]] = _headers or {}
+        _form_params: List[Tuple[str, str]] = []
+        _files: Dict[str, Union[str, bytes]] = {}
+        _body_params: Optional[bytes] = None
+
+        # process the path parameters
+        # process the query parameters
+        # process the header parameters
+        # process the form parameters
+        # process the body parameter
+
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            [
+                'application/json'
+            ]
+        )
+
+
+        # authentication setting
+        _auth_settings: List[str] = [
+            'bearerAuth'
+        ]
+
+        return self.api_client.param_serialize(
+            method='GET',
+            resource_path='/api/v1/admin/users',
+            path_params=_path_params,
+            query_params=_query_params,
+            header_params=_header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            auth_settings=_auth_settings,
+            collection_formats=_collection_formats,
+            _host=_host,
+            _request_auth=_request_auth
+        )
+
+
+
+
+    @validate_call
+    def update_authorities_of_user(
+        self,
+        username: Annotated[StrictStr, Field(description="Username")],
+        request_body: Annotated[List[StrictStr], Field(description="Permission list")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> bool:
-        """Update User Details
+        """Update User Permissions
 
-        Update the detailed user information of the current account.
+        Update the user's permission list.
 
-        :param user_details_dto: User information (required)
-        :type user_details_dto: UserDetailsDTO
+        :param username: Username (required)
+        :type username: str
+        :param request_body: Permission list (required)
+        :type request_body: List[str]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1880,60 +3210,63 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_user_info_serialize(
-            user_details_dto=user_details_dto,
+        _param = self._update_authorities_of_user_serialize(
+            username=username,
+            request_body=request_body,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def update_user_info_with_http_info(
+    def update_authorities_of_user_with_http_info(
         self,
-        user_details_dto: Annotated[UserDetailsDTO, Field(description="User information")],
+        username: Annotated[StrictStr, Field(description="Username")],
+        request_body: Annotated[List[StrictStr], Field(description="Permission list")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[bool]:
-        """Update User Details
+        """Update User Permissions
 
-        Update the detailed user information of the current account.
+        Update the user's permission list.
 
-        :param user_details_dto: User information (required)
-        :type user_details_dto: UserDetailsDTO
+        :param username: Username (required)
+        :type username: str
+        :param request_body: Permission list (required)
+        :type request_body: List[str]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1948,60 +3281,63 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_user_info_serialize(
-            user_details_dto=user_details_dto,
+        _param = self._update_authorities_of_user_serialize(
+            username=username,
+            request_body=request_body,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def update_user_info_without_preload_content(
+    def update_authorities_of_user_without_preload_content(
         self,
-        user_details_dto: Annotated[UserDetailsDTO, Field(description="User information")],
+        username: Annotated[StrictStr, Field(description="Username")],
+        request_body: Annotated[List[StrictStr], Field(description="Permission list")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Update User Details
+        """Update User Permissions
 
-        Update the detailed user information of the current account.
+        Update the user's permission list.
 
-        :param user_details_dto: User information (required)
-        :type user_details_dto: UserDetailsDTO
+        :param username: Username (required)
+        :type username: str
+        :param request_body: Permission list (required)
+        :type request_body: List[str]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2016,62 +3352,65 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_user_info_serialize(
-            user_details_dto=user_details_dto,
+        _param = self._update_authorities_of_user_serialize(
+            username=username,
+            request_body=request_body,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _update_user_info_serialize(
+    def _update_authorities_of_user_serialize(
         self,
-        user_details_dto,
+        username,
+        request_body,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
+            'request_body': '',
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
+        if username is not None:
+            _path_params['username'] = username
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
-        if user_details_dto is not None:
-            _body_params = user_details_dto
+        if request_body is not None:
+            _body_params = request_body
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
                 'application/json'
             ]
@@ -2094,15 +3433,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='PUT',
-            resource_path='/api/v1/account/details',
+            resource_path='/api/v1/admin/authority/{username}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -2111,36 +3450,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def upload_user_picture(
+    def update_user(
         self,
-        file: Annotated[Union[StrictBytes, StrictStr], Field(description="User picture")],
+        user_full_details_dto: Annotated[UserFullDetailsDTO, Field(description="User information")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> str:
-        """Upload User Picture
+    ) -> bool:
+        """Update User
 
-        Upload a picture of the user.
+        Update user information.
 
-        :param file: User picture (required)
-        :type file: bytearray
+        :param user_full_details_dto: User information (required)
+        :type user_full_details_dto: UserFullDetailsDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2155,60 +3494,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._upload_user_picture_serialize(
-            file=file,
+        _param = self._update_user_serialize(
+            user_full_details_dto=user_full_details_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def upload_user_picture_with_http_info(
+    def update_user_with_http_info(
         self,
-        file: Annotated[Union[StrictBytes, StrictStr], Field(description="User picture")],
+        user_full_details_dto: Annotated[UserFullDetailsDTO, Field(description="User information")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[str]:
-        """Upload User Picture
+    ) -> ApiResponse[bool]:
+        """Update User
 
-        Upload a picture of the user.
+        Update user information.
 
-        :param file: User picture (required)
-        :type file: bytearray
+        :param user_full_details_dto: User information (required)
+        :type user_full_details_dto: UserFullDetailsDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2223,60 +3561,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._upload_user_picture_serialize(
-            file=file,
+        _param = self._update_user_serialize(
+            user_full_details_dto=user_full_details_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def upload_user_picture_without_preload_content(
+    def update_user_without_preload_content(
         self,
-        file: Annotated[Union[StrictBytes, StrictStr], Field(description="User picture")],
+        user_full_details_dto: Annotated[UserFullDetailsDTO, Field(description="User information")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Upload User Picture
+        """Update User
 
-        Upload a picture of the user.
+        Update user information.
 
-        :param file: User picture (required)
-        :type file: bytearray
+        :param user_full_details_dto: User information (required)
+        :type user_full_details_dto: UserFullDetailsDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2291,93 +3628,91 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._upload_user_picture_serialize(
-            file=file,
+        _param = self._update_user_serialize(
+            user_full_details_dto=user_full_details_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _upload_user_picture_serialize(
+    def _update_user_serialize(
         self,
-        file,
+        user_full_details_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
-        if file is not None:
-            _files['file'] = file
         # process the body parameter
+        if user_full_details_dto is not None:
+            _body_params = user_full_details_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
-                'text/plain'
+                'application/json'
             ]
         )
 
         # set the HTTP header `Content-Type`
         if _content_type:
             _header_params['Content-Type'] = _content_type
         else:
             _default_content_type = (
                 self.api_client.select_header_content_type(
                     [
-                        'multipart/form-data'
+                        'application/json'
                     ]
                 )
             )
             if _default_content_type is not None:
                 _header_params['Content-Type'] = _default_content_type
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/api/v1/account/picture',
+            method='PUT',
+            resource_path='/api/v1/admin/user',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## Comparing `freechat-sdk/api/account_manager_for_admin_api.py` & `freechat_sdk/api/account_api.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,86 +1,70 @@
 # coding: utf-8
 
 """
     FreeChat OpenAPI Definition
 
-    https://github.com/freechat-fun/freechat
+    # FreeChat: Create Some Friends for Yourself with AI  English | [中文版](https://github.com/freechat-fun/freechat/blob/main/README.zh-CN.md)  ## Introduction Welcome! FreeChat aims to build a cloud-native, robust, and quickly commercializable enterprise-level AI virtual character platform.  ## Features - Primarily uses Java and emphasizes **security, robustness, scalability, traceability, and maintainability**. - oasts **account systems and permission management**, supporting OAuth2 authentication. Introduces the \"organization\" concept and related permission constraint functions. - Extensively employs **distributed technologies and caching** to support **high concurrency** access. - Provides flexible character customization options, supports direct intervention in prompts, and supports **configuring multiple backends for each character**. - **Offers a comprehensive range of Open APIs**, with more than 180 interfaces and provides java/python/typescript SDKs. These interfaces enable easy construction of systems for end-users. - Supports setting **RAG** (Retrieval Augmented Generation) for characters. - Supports **long-term memory** for characters. - Supports setting **quota limits** for characters.  ## System Snapshots  ## Character Design ```mermaid flowchart TD     A(Character) --> B(Profile)     A --> C(Knowledge/RAG)     A --> D(Album)     A --> E(Backend-1)     A --> F(Backend-n...)     E --> G(Message Window)     E --> H(Long Term Memory Settings)     E --> I(Quota Limit)     E --> J(Chat Prompt Task)     E --> K(Greeting Prompt Task)     E --> L(Moderation Settings)     J --> M(Model & Parameters)     J --> N(API Keys)     J --> O(Prompt Refence)     J --> P(Tool Specifications)     O --> Q(Template)     O --> R(Variables)     O --> S(Version)     O --> T(...)     style K stroke-dasharray: 5, 5     style L stroke-dasharray: 5, 5     style P stroke-dasharray: 5, 5 ```  After setting up a unified persona and knowledge for a character, different backends can be configured. For example, different model may be adopted for different users based on cost considerations.  ## How to Play ### Online Website You can visit [freechat.fun](https://freechat.fun) to experience FreeChat. Share your designed AI character!  ### Running in a Kubernetes Cluster FreeChat is dedicated to the principles of cloud-native design. If you have a Kubernetes cluster, you can deploy FreeChat to your environment by following these steps:  1. Put the Kubernetes configuration file in the `configs/helm/` directory, named `kube-private.conf`. 2. Place the Helm configuration file in the same directory, named `values-private.yaml`. Make sure to reference the default `values.yaml` and customize the variables as needed. 3. Switch to the `scripts/` directory. 4. If needed, execute `install-in.sh` to deploy `ingress-nginx` to the Kubernetes cluster. 5. If needed, run `install-cm.sh` to deploy `cert-manager` on the Kubernetes cluster, which automatically issues certificates for domains specified in `ingress.hosts`. 6. Run `install-pvc.sh` to install PersistentVolumeClaim resources.      > By default, FreeChat operates files by accessing the \"local file system.\" You may want to use high-availability distributed storage in the cloud. As a cloud-native-designed system, we recommend interfacing through Kubernetes CSI to avoid individually adapting storage products for each cloud platform. Most cloud service providers offer cloud storage drivers for Kubernetes, with a series of predefined StorageClass resources. Please choose the appropriate configuration according to your actual needs and set it in Helm's `global.storageClass` option.     >      > *In the future, FreeChat may be refactored to use MinIO's APIs directly, as it is now installed in the Kubernetes cluster as a dependency (serving Milvus).*  7. Execute the `install.sh` script to install FreeChat and its dependencies. 8. FreeChat aims to provide Open API services. If you like the interactive experience of [freechat.fun](https://freechat.fun), run `install-web.sh` to deploy the front-end application. 9. Execute `restart.sh` to restart the service. 10. If you modified any Helm configuration files, use `upgrade.sh` to update the corresponding Kubernetes resources. 11. To remove specific resources, run the `uninstall*.sh` script corresponding to the resource you want to uninstall.  As a cloud-native application, the services FreeChat relies on are obtained and deployed to your cluster through the helm repository.  If you prefer cloud services with SLA (Service Level Agreement) guarantees, simply make the relevant settings in `configs/helm/values-private.yaml`: ```yaml bitnami:   mysql:     enabled: false   redis:     enabled: false   milvus:     enabled: false  mysql:   url: <your mysql url>   auth:     rootPassword: <your mysql root password>     username: <your mysql username>     password: <your mysql password for the username>  redis:   url: <your redis url>   auth:     password: <your redis password>   milvus:   url: <your milvus url>   milvus:     auth:       token: <your milvus api-key> ```  With this, FreeChat will not automatically install these services, but rather use the configuration information to connect directly.  ### Running Locally You can also run FreeChat locally. Currently supported on MacOS and Linux (although only tested on MacOS). You need to install the Docker toolset and have a network that can access [Docker Hub](https://hub.docker.com/).  Once ready, enter the `scripts/` directory and run `local-run.sh`, which will download and run the necessary docker containers. After a successful startup, you can access `http://localhost` via a browser to see the locally running freechat.fun. Use `local-run.sh --help` to view the supported options of the script. Good luck!  ### Running in an IDE To run FreeChat in an IDE, you need to start all dependent services first but do not need to run the container for the FreeChat application itself. You can execute the `scripts/local-deps.sh` script to start services like `MySQL`, `Redis`, `Milvus`, etc., locally. Once done, open and debug `freechat-start/src/main/java/fun/freechat/Application.java`。Make sure you have set the following startup parameters: ```shell -Dspring.config.location=classpath:/application.yml,classpath:/application-local.yml \\ -DAPP_HOME=local-data/freechat \\ -Dspring.profiles.active=local ```  ### 使用 SDK #### Java - **Dependency** ```xml <dependency>   <groupId>fun.freechat</groupId>   <artifactId>freechat-sdk</artifactId>   <version>${freechat-sdk.version}</version> </dependency> ```  - **Example** ```java import fun.freechat.client.ApiClient; import fun.freechat.client.ApiException; import fun.freechat.client.Configuration; import fun.freechat.client.api.AccountApi; import fun.freechat.client.auth.ApiKeyAuth; import fun.freechat.client.model.UserDetailsDTO;  public class AccountClientExample {     public static void main(String[] args) {         ApiClient defaultClient = Configuration.getDefaultApiClient();         defaultClient.setBasePath(\"https://freechat.fun\");                  // Configure HTTP bearer authorization: bearerAuth         HttpBearerAuth bearerAuth = (HttpBearerAuth) defaultClient.getAuthentication(\"bearerAuth\");         bearerAuth.setBearerToken(\"FREECHAT_TOKEN\");          AccountApi apiInstance = new AccountApi(defaultClient);         try {             UserDetailsDTO result = apiInstance.getUserDetails();             System.out.println(result);         } catch (ApiException e) {             e.printStackTrace();         }     } } ```  #### Python - **Installation** ```shell pip install freechat-sdk ```  - **Example** ```python import freechat_sdk from freechat_sdk.rest import ApiException from pprint import pprint  # Defining the host is optional and defaults to https://freechat.fun # See configuration.py for a list of all supported configuration parameters. configuration = freechat_sdk.Configuration(     host = \"https://freechat.fun\" )  # Configure Bearer authorization: bearerAuth configuration = freechat_sdk.Configuration(     access_token = os.environ[\"FREECHAT_TOKEN\"] )  # Enter a context with an instance of the API client with freechat_sdk.ApiClient(configuration) as api_client:     # Create an instance of the API class     api_instance = freechat_sdk.AccountApi(api_client)      try:         details = api_instance.get_user_details()         pprint(details)     except ApiException as e:         print(\"Exception when calling AccountClient->get_user_details: %s\\n\" % e) ```  #### TypeScript - **Installation** ```shell npm install freechat-sdk --save ```  - **Example** Refer to [FreeChatApiContext.tsx](https://github.com/freechat-fun/freechat/blob/main/freechat-web/src/contexts/FreeChatApiProvider.tsx)  ## System Dependencies | | Projects | ---- | ---- | Application Framework | [Spring Boot](https://spring.io/projects/spring-boot/) | LLM Framework | [LangChain4j](https://docs.langchain4j.dev/) | Model Providers | [OpenAI](https://platform.openai.com/), [DashScope](https://dashscope.aliyun.com/) | Database Systems | [MySQL](https://www.mysql.com/), [Redis](https://redis.io/), [Milvus](https://milvus.io/) | OpenAPI Tools | [Springdoc-openapi](https://springdoc.org/), [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator), [OpenAPI Explorer](https://github.com/Authress-Engineering/openapi-explorer)  ## Collaboration ### Application Integration The FreeChat system is entirely oriented towards Open APIs. The site [freechat.fun](https://freechat.fun) is developed using its TypeScript SDK and hardly depends on private interfaces. You can use these online interfaces to develop your own applications or sites, making them fit your preferences. Currently, FreeChat is completely free with no paid plans (after all, users use their own API Key to call LLM services).  ### Model Integration FreeChat aims to explore AI virtual character technology with anthropomorphic characteristics. So far, it supports model services from OpenAI and DashScope ([HuggingFace](https://huggingface.co/) is also expected to be supported soon). However, we are more interested in supporting models that are under research and can endow AI with more personality traits. If you are researching this area and hope FreeChat supports your model, please contact us. We look forward to AI technology helping people create their own \"soul mates\" in the future.
 
-    The version of the OpenAPI document: 0.1.0
+    The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
-import io
 import warnings
-
 from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
-
-try:
-    from typing import Annotated
-except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import Field
+from typing import Any, Dict, List, Optional, Tuple, Union
 from typing_extensions import Annotated
-from pydantic import StrictInt, StrictStr
 
-from typing import List
-
-from freechat-sdk.models.user_basic_info_dto import UserBasicInfoDTO
-from freechat-sdk.models.user_details_dto import UserDetailsDTO
-from freechat-sdk.models.user_full_details_dto import UserFullDetailsDTO
+from pydantic import Field, StrictBool, StrictBytes, StrictInt, StrictStr
+from typing import List, Union
+from typing_extensions import Annotated
+from freechat_sdk.models.api_token_info_dto import ApiTokenInfoDTO
+from freechat_sdk.models.user_basic_info_dto import UserBasicInfoDTO
+from freechat_sdk.models.user_details_dto import UserDetailsDTO
 
-from freechat-sdk.api_client import ApiClient
-from freechat-sdk.api_response import ApiResponse
-from freechat-sdk.rest import RESTResponseType
+from freechat_sdk.api_client import ApiClient, RequestSerialized
+from freechat_sdk.api_response import ApiResponse
+from freechat_sdk.rest import RESTResponseType
 
 
-class AccountManagerForAdminApi:
+class AccountApi:
     """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     def __init__(self, api_client=None) -> None:
         if api_client is None:
             api_client = ApiClient.get_default()
         self.api_client = api_client
 
 
     @validate_call
-    def create_token_for_user(
+    def create_token(
         self,
-        username: Annotated[StrictStr, Field(description="Username")],
-        duration: Annotated[int, Field(strict=True, ge=0, description="Validity period (seconds)")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> str:
-        """Create API Token for User.
+        """Create API Token
 
-        Create an API Token for a specified user, valid for duration seconds.
+        Create a timed API Token, valid for {duration} seconds.
 
-        :param username: Username (required)
-        :type username: str
-        :param duration: Validity period (seconds) (required)
-        :type duration: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -95,64 +79,55 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_token_for_user_serialize(
-            username=username,
-            duration=duration,
+        _param = self._create_token_serialize(
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def create_token_for_user_with_http_info(
+    def create_token_with_http_info(
         self,
-        username: Annotated[StrictStr, Field(description="Username")],
-        duration: Annotated[int, Field(strict=True, ge=0, description="Validity period (seconds)")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[str]:
-        """Create API Token for User.
+        """Create API Token
 
-        Create an API Token for a specified user, valid for duration seconds.
+        Create a timed API Token, valid for {duration} seconds.
 
-        :param username: Username (required)
-        :type username: str
-        :param duration: Validity period (seconds) (required)
-        :type duration: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -167,64 +142,55 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_token_for_user_serialize(
-            username=username,
-            duration=duration,
+        _param = self._create_token_serialize(
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def create_token_for_user_without_preload_content(
+    def create_token_without_preload_content(
         self,
-        username: Annotated[StrictStr, Field(description="Username")],
-        duration: Annotated[int, Field(strict=True, ge=0, description="Validity period (seconds)")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Create API Token for User.
+        """Create API Token
 
-        Create an API Token for a specified user, valid for duration seconds.
+        Create a timed API Token, valid for {duration} seconds.
 
-        :param username: Username (required)
-        :type username: str
-        :param duration: Validity period (seconds) (required)
-        :type duration: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -239,62 +205,52 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_token_for_user_serialize(
-            username=username,
-            duration=duration,
+        _param = self._create_token_serialize(
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _create_token_for_user_serialize(
+    def _create_token_serialize(
         self,
-        username,
-        duration,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if username is not None:
-            _path_params['username'] = username
-        if duration is not None:
-            _path_params['duration'] = duration
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
@@ -308,15 +264,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/admin/token/{username}/{duration}',
+            resource_path='/api/v1/account/token',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -325,36 +281,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def create_user(
+    def create_token1(
         self,
-        user_full_details_dto: Annotated[UserFullDetailsDTO, Field(description="User information")],
+        duration: Annotated[StrictInt, Field(description="Token validity duration (seconds)")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> bool:
-        """Create User
+    ) -> str:
+        """Create API Token
 
-        Create user.
+        Create a timed API Token, valid for {duration} seconds.
 
-        :param user_full_details_dto: User information (required)
-        :type user_full_details_dto: UserFullDetailsDTO
+        :param duration: Token validity duration (seconds) (required)
+        :type duration: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -369,60 +325,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_user_serialize(
-            user_full_details_dto=user_full_details_dto,
+        _param = self._create_token1_serialize(
+            duration=duration,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def create_user_with_http_info(
+    def create_token1_with_http_info(
         self,
-        user_full_details_dto: Annotated[UserFullDetailsDTO, Field(description="User information")],
+        duration: Annotated[StrictInt, Field(description="Token validity duration (seconds)")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[bool]:
-        """Create User
+    ) -> ApiResponse[str]:
+        """Create API Token
 
-        Create user.
+        Create a timed API Token, valid for {duration} seconds.
 
-        :param user_full_details_dto: User information (required)
-        :type user_full_details_dto: UserFullDetailsDTO
+        :param duration: Token validity duration (seconds) (required)
+        :type duration: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -437,60 +392,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_user_serialize(
-            user_full_details_dto=user_full_details_dto,
+        _param = self._create_token1_serialize(
+            duration=duration,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def create_user_without_preload_content(
+    def create_token1_without_preload_content(
         self,
-        user_full_details_dto: Annotated[UserFullDetailsDTO, Field(description="User information")],
+        duration: Annotated[StrictInt, Field(description="Token validity duration (seconds)")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Create User
+        """Create API Token
 
-        Create user.
+        Create a timed API Token, valid for {duration} seconds.
 
-        :param user_full_details_dto: User information (required)
-        :type user_full_details_dto: UserFullDetailsDTO
+        :param duration: Token validity duration (seconds) (required)
+        :type duration: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -505,93 +459,78 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_user_serialize(
-            user_full_details_dto=user_full_details_dto,
+        _param = self._create_token1_serialize(
+            duration=duration,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _create_user_serialize(
+    def _create_token1_serialize(
         self,
-        user_full_details_dto,
+        duration,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
+        if duration is not None:
+            _path_params['duration'] = duration
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
-        if user_full_details_dto is not None:
-            _body_params = user_full_details_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
-                'application/json'
+                'text/plain'
             ]
         )
 
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/admin/user',
+            resource_path='/api/v1/account/token/{duration}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -600,35 +539,35 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def delete_token_for_user(
+    def delete_token(
         self,
-        token: Annotated[StrictStr, Field(description="API Token")],
+        token: Annotated[StrictStr, Field(description="Token content")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> bool:
+    ) -> str:
         """Delete API Token
 
-        Delete the specified API Token.
+        Delete an API Token.
 
-        :param token: API Token (required)
+        :param token: Token content (required)
         :type token: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
@@ -644,59 +583,58 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_token_for_user_serialize(
+        _param = self._delete_token_serialize(
             token=token,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def delete_token_for_user_with_http_info(
+    def delete_token_with_http_info(
         self,
-        token: Annotated[StrictStr, Field(description="API Token")],
+        token: Annotated[StrictStr, Field(description="Token content")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[bool]:
+    ) -> ApiResponse[str]:
         """Delete API Token
 
-        Delete the specified API Token.
+        Delete an API Token.
 
-        :param token: API Token (required)
+        :param token: Token content (required)
         :type token: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
@@ -712,41 +650,40 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_token_for_user_serialize(
+        _param = self._delete_token_serialize(
             token=token,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def delete_token_for_user_without_preload_content(
+    def delete_token_without_preload_content(
         self,
-        token: Annotated[StrictStr, Field(description="API Token")],
+        token: Annotated[StrictStr, Field(description="Token content")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
@@ -754,17 +691,17 @@
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
         """Delete API Token
 
-        Delete the specified API Token.
+        Delete an API Token.
 
-        :param token: API Token (required)
+        :param token: Token content (required)
         :type token: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
@@ -780,80 +717,78 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_token_for_user_serialize(
+        _param = self._delete_token_serialize(
             token=token,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _delete_token_for_user_serialize(
+    def _delete_token_serialize(
         self,
         token,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if token is not None:
             _path_params['token'] = token
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
-                'application/json'
+                'text/plain'
             ]
         )
 
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='DELETE',
-            resource_path='/api/v1/admin/token/{token}',
+            resource_path='/api/v1/account/token/{token}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -862,36 +797,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def delete_user(
+    def delete_token_by_id(
         self,
-        username: Annotated[StrictStr, Field(description="Username")],
+        id: Annotated[StrictInt, Field(description="Token id")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> bool:
-        """Delete User
+        """Delete API Token by Id
 
-        Delete user by username.
+        Delete the API token by id.
 
-        :param username: Username (required)
-        :type username: str
+        :param id: Token id (required)
+        :type id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -906,60 +841,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_user_serialize(
-            username=username,
+        _param = self._delete_token_by_id_serialize(
+            id=id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def delete_user_with_http_info(
+    def delete_token_by_id_with_http_info(
         self,
-        username: Annotated[StrictStr, Field(description="Username")],
+        id: Annotated[StrictInt, Field(description="Token id")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[bool]:
-        """Delete User
+        """Delete API Token by Id
 
-        Delete user by username.
+        Delete the API token by id.
 
-        :param username: Username (required)
-        :type username: str
+        :param id: Token id (required)
+        :type id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -974,60 +908,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_user_serialize(
-            username=username,
+        _param = self._delete_token_by_id_serialize(
+            id=id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def delete_user_without_preload_content(
+    def delete_token_by_id_without_preload_content(
         self,
-        username: Annotated[StrictStr, Field(description="Username")],
+        id: Annotated[StrictInt, Field(description="Token id")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Delete User
+        """Delete API Token by Id
 
-        Delete user by username.
+        Delete the API token by id.
 
-        :param username: Username (required)
-        :type username: str
+        :param id: Token id (required)
+        :type id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1042,58 +975,56 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_user_serialize(
-            username=username,
+        _param = self._delete_token_by_id_serialize(
+            id=id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _delete_user_serialize(
+    def _delete_token_by_id_serialize(
         self,
-        username,
+        id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if username is not None:
-            _path_params['username'] = username
+        if id is not None:
+            _path_params['id'] = id
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
@@ -1107,15 +1038,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='DELETE',
-            resource_path='/api/v1/admin/user/{username}',
+            resource_path='/api/v1/account/token/id/{id}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -1124,35 +1055,35 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def disable_token_for_user(
+    def disable_token(
         self,
-        token: Annotated[StrictStr, Field(description="API Token")],
+        token: Annotated[StrictStr, Field(description="Token content")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> bool:
+    ) -> str:
         """Disable API Token
 
-        Disable the specified API Token.
+        Disable an API Token, the token is not deleted.
 
-        :param token: API Token (required)
+        :param token: Token content (required)
         :type token: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
@@ -1168,59 +1099,58 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._disable_token_for_user_serialize(
+        _param = self._disable_token_serialize(
             token=token,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def disable_token_for_user_with_http_info(
+    def disable_token_with_http_info(
         self,
-        token: Annotated[StrictStr, Field(description="API Token")],
+        token: Annotated[StrictStr, Field(description="Token content")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[bool]:
+    ) -> ApiResponse[str]:
         """Disable API Token
 
-        Disable the specified API Token.
+        Disable an API Token, the token is not deleted.
 
-        :param token: API Token (required)
+        :param token: Token content (required)
         :type token: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
@@ -1236,41 +1166,40 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._disable_token_for_user_serialize(
+        _param = self._disable_token_serialize(
             token=token,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def disable_token_for_user_without_preload_content(
+    def disable_token_without_preload_content(
         self,
-        token: Annotated[StrictStr, Field(description="API Token")],
+        token: Annotated[StrictStr, Field(description="Token content")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
@@ -1278,17 +1207,17 @@
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
         """Disable API Token
 
-        Disable the specified API Token.
+        Disable an API Token, the token is not deleted.
 
-        :param token: API Token (required)
+        :param token: Token content (required)
         :type token: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
@@ -1304,80 +1233,78 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._disable_token_for_user_serialize(
+        _param = self._disable_token_serialize(
             token=token,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _disable_token_for_user_serialize(
+    def _disable_token_serialize(
         self,
         token,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if token is not None:
             _path_params['token'] = token
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
-                'application/json'
+                'text/plain'
             ]
         )
 
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='PUT',
-            resource_path='/api/v1/admin/token/{token}',
+            resource_path='/api/v1/account/token/{token}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -1386,36 +1313,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def get_details_of_user(
+    def disable_token_by_id(
         self,
-        username: Annotated[StrictStr, Field(description="Username")],
+        id: Annotated[StrictInt, Field(description="Token id")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> UserDetailsDTO:
-        """Get User Details
+    ) -> bool:
+        """Disable API Token by Id
 
-        Return detailed user information.
+        Disable the API token by id.
 
-        :param username: Username (required)
-        :type username: str
+        :param id: Token id (required)
+        :type id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1430,60 +1357,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_details_of_user_serialize(
-            username=username,
+        _param = self._disable_token_by_id_serialize(
+            id=id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "UserDetailsDTO"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def get_details_of_user_with_http_info(
+    def disable_token_by_id_with_http_info(
         self,
-        username: Annotated[StrictStr, Field(description="Username")],
+        id: Annotated[StrictInt, Field(description="Token id")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[UserDetailsDTO]:
-        """Get User Details
+    ) -> ApiResponse[bool]:
+        """Disable API Token by Id
 
-        Return detailed user information.
+        Disable the API token by id.
 
-        :param username: Username (required)
-        :type username: str
+        :param id: Token id (required)
+        :type id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1498,60 +1424,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_details_of_user_serialize(
-            username=username,
+        _param = self._disable_token_by_id_serialize(
+            id=id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "UserDetailsDTO"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def get_details_of_user_without_preload_content(
+    def disable_token_by_id_without_preload_content(
         self,
-        username: Annotated[StrictStr, Field(description="Username")],
+        id: Annotated[StrictInt, Field(description="Token id")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Get User Details
+        """Disable API Token by Id
 
-        Return detailed user information.
+        Disable the API token by id.
 
-        :param username: Username (required)
-        :type username: str
+        :param id: Token id (required)
+        :type id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1566,58 +1491,56 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_details_of_user_serialize(
-            username=username,
+        _param = self._disable_token_by_id_serialize(
+            id=id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "UserDetailsDTO"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _get_details_of_user_serialize(
+    def _disable_token_by_id_serialize(
         self,
-        username,
+        id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if username is not None:
-            _path_params['username'] = username
+        if id is not None:
+            _path_params['id'] = id
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
@@ -1630,16 +1553,16 @@
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
-            method='GET',
-            resource_path='/api/v1/admin/user/{username}',
+            method='PUT',
+            resource_path='/api/v1/account/token/id/{id}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -1648,36 +1571,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def get_user_by_token(
+    def get_token_by_id(
         self,
-        token: Annotated[StrictStr, Field(description="API Token")],
+        id: Annotated[StrictInt, Field(description="Token id")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> UserDetailsDTO:
-        """Get User by API Token
+    ) -> str:
+        """Get API Token by Id
 
-        Get the detailed user information corresponding to the API Token.
+        Get the API token by id.
 
-        :param token: API Token (required)
-        :type token: str
+        :param id: Token id (required)
+        :type id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1692,60 +1615,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_user_by_token_serialize(
-            token=token,
+        _param = self._get_token_by_id_serialize(
+            id=id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "UserDetailsDTO"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def get_user_by_token_with_http_info(
+    def get_token_by_id_with_http_info(
         self,
-        token: Annotated[StrictStr, Field(description="API Token")],
+        id: Annotated[StrictInt, Field(description="Token id")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[UserDetailsDTO]:
-        """Get User by API Token
+    ) -> ApiResponse[str]:
+        """Get API Token by Id
 
-        Get the detailed user information corresponding to the API Token.
+        Get the API token by id.
 
-        :param token: API Token (required)
-        :type token: str
+        :param id: Token id (required)
+        :type id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1760,60 +1682,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_user_by_token_serialize(
-            token=token,
+        _param = self._get_token_by_id_serialize(
+            id=id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "UserDetailsDTO"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def get_user_by_token_without_preload_content(
+    def get_token_by_id_without_preload_content(
         self,
-        token: Annotated[StrictStr, Field(description="API Token")],
+        id: Annotated[StrictInt, Field(description="Token id")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Get User by API Token
+        """Get API Token by Id
 
-        Get the detailed user information corresponding to the API Token.
+        Get the API token by id.
 
-        :param token: API Token (required)
-        :type token: str
+        :param id: Token id (required)
+        :type id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1828,80 +1749,78 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_user_by_token_serialize(
-            token=token,
+        _param = self._get_token_by_id_serialize(
+            id=id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "UserDetailsDTO"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _get_user_by_token_serialize(
+    def _get_token_by_id_serialize(
         self,
-        token,
+        id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if token is not None:
-            _path_params['token'] = token
+        if id is not None:
+            _path_params['id'] = id
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
-                'application/json'
+                'text/plain'
             ]
         )
 
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='GET',
-            resource_path='/api/v1/admin/tokenBy/{token}',
+            resource_path='/api/v1/account/token/id/{id}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -1910,36 +1829,33 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def list_authorities_of_user(
+    def get_user_basic(
         self,
-        username: Annotated[StrictStr, Field(description="Username")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[str]:
-        """List User Permissions
+    ) -> UserBasicInfoDTO:
+        """Get User Basic Information
 
-        List the user's permissions.
+        Return user basic information, including: username, nickname, avatar link.
 
-        :param username: Username (required)
-        :type username: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1954,60 +1870,55 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_authorities_of_user_serialize(
-            username=username,
+        _param = self._get_user_basic_serialize(
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "UserBasicInfoDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def list_authorities_of_user_with_http_info(
+    def get_user_basic_with_http_info(
         self,
-        username: Annotated[StrictStr, Field(description="Username")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[str]]:
-        """List User Permissions
+    ) -> ApiResponse[UserBasicInfoDTO]:
+        """Get User Basic Information
 
-        List the user's permissions.
+        Return user basic information, including: username, nickname, avatar link.
 
-        :param username: Username (required)
-        :type username: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2022,60 +1933,55 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_authorities_of_user_serialize(
-            username=username,
+        _param = self._get_user_basic_serialize(
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "UserBasicInfoDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def list_authorities_of_user_without_preload_content(
+    def get_user_basic_without_preload_content(
         self,
-        username: Annotated[StrictStr, Field(description="Username")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """List User Permissions
+        """Get User Basic Information
 
-        List the user's permissions.
+        Return user basic information, including: username, nickname, avatar link.
 
-        :param username: Username (required)
-        :type username: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2090,58 +1996,52 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_authorities_of_user_serialize(
-            username=username,
+        _param = self._get_user_basic_serialize(
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "UserBasicInfoDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _list_authorities_of_user_serialize(
+    def _get_user_basic_serialize(
         self,
-        username,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if username is not None:
-            _path_params['username'] = username
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
@@ -2155,15 +2055,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='GET',
-            resource_path='/api/v1/admin/authority/{username}',
+            resource_path='/api/v1/account/basic',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -2172,33 +2072,33 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def list_tokens_of_user(
+    def get_user_basic1(
         self,
         username: Annotated[StrictStr, Field(description="Username")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[str]:
-        """Get API Token of User
+    ) -> UserBasicInfoDTO:
+        """Get User Basic Information
 
-        Get the list of API Tokens of the user.
+        Return user basic information, including: username, nickname, avatar link.
 
         :param username: Username (required)
         :type username: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
@@ -2216,57 +2116,56 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_tokens_of_user_serialize(
+        _param = self._get_user_basic1_serialize(
             username=username,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "UserBasicInfoDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def list_tokens_of_user_with_http_info(
+    def get_user_basic1_with_http_info(
         self,
         username: Annotated[StrictStr, Field(description="Username")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[str]]:
-        """Get API Token of User
+    ) -> ApiResponse[UserBasicInfoDTO]:
+        """Get User Basic Information
 
-        Get the list of API Tokens of the user.
+        Return user basic information, including: username, nickname, avatar link.
 
         :param username: Username (required)
         :type username: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
@@ -2284,39 +2183,38 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_tokens_of_user_serialize(
+        _param = self._get_user_basic1_serialize(
             username=username,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "UserBasicInfoDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def list_tokens_of_user_without_preload_content(
+    def get_user_basic1_without_preload_content(
         self,
         username: Annotated[StrictStr, Field(description="Username")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
@@ -2324,17 +2222,17 @@
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Get API Token of User
+        """Get User Basic Information
 
-        Get the list of API Tokens of the user.
+        Return user basic information, including: username, nickname, avatar link.
 
         :param username: Username (required)
         :type username: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
@@ -2352,53 +2250,51 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_tokens_of_user_serialize(
+        _param = self._get_user_basic1_serialize(
             username=username,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "UserBasicInfoDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _list_tokens_of_user_serialize(
+    def _get_user_basic1_serialize(
         self,
         username,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if username is not None:
             _path_params['username'] = username
         # process the query parameters
         # process the header parameters
@@ -2417,292 +2313,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='GET',
-            resource_path='/api/v1/admin/token/{username}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def list_users(
-        self,
-        page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
-        page_num: Annotated[int, Field(strict=True, ge=0, description="Current page number")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[UserBasicInfoDTO]:
-        """List User Information
-
-        Return user information by page, return the pageNum page, up to pageSize user information.
-
-        :param page_size: Maximum quantity (required)
-        :type page_size: int
-        :param page_num: Current page number (required)
-        :type page_num: int
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :type _request_timeout: int, tuple(int, int), optional
-        :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the
-                              authentication in the spec for a single request.
-        :type _request_auth: dict, optional
-        :param _content_type: force content-type for the request.
-        :type _content_type: str, Optional
-        :param _headers: set to override the headers for a single
-                         request; this effectively ignores the headers
-                         in the spec for a single request.
-        :type _headers: dict, optional
-        :param _host_index: set to override the host_index for a single
-                            request; this effectively ignores the host_index
-                            in the spec for a single request.
-        :type _host_index: int, optional
-        :return: Returns the result object.
-        """ # noqa: E501
-
-        _param = self._list_users_serialize(
-            page_size=page_size,
-            page_num=page_num,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[UserBasicInfoDTO]"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def list_users_with_http_info(
-        self,
-        page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
-        page_num: Annotated[int, Field(strict=True, ge=0, description="Current page number")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[UserBasicInfoDTO]]:
-        """List User Information
-
-        Return user information by page, return the pageNum page, up to pageSize user information.
-
-        :param page_size: Maximum quantity (required)
-        :type page_size: int
-        :param page_num: Current page number (required)
-        :type page_num: int
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :type _request_timeout: int, tuple(int, int), optional
-        :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the
-                              authentication in the spec for a single request.
-        :type _request_auth: dict, optional
-        :param _content_type: force content-type for the request.
-        :type _content_type: str, Optional
-        :param _headers: set to override the headers for a single
-                         request; this effectively ignores the headers
-                         in the spec for a single request.
-        :type _headers: dict, optional
-        :param _host_index: set to override the host_index for a single
-                            request; this effectively ignores the host_index
-                            in the spec for a single request.
-        :type _host_index: int, optional
-        :return: Returns the result object.
-        """ # noqa: E501
-
-        _param = self._list_users_serialize(
-            page_size=page_size,
-            page_num=page_num,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[UserBasicInfoDTO]"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def list_users_without_preload_content(
-        self,
-        page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
-        page_num: Annotated[int, Field(strict=True, ge=0, description="Current page number")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """List User Information
-
-        Return user information by page, return the pageNum page, up to pageSize user information.
-
-        :param page_size: Maximum quantity (required)
-        :type page_size: int
-        :param page_num: Current page number (required)
-        :type page_num: int
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :type _request_timeout: int, tuple(int, int), optional
-        :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the
-                              authentication in the spec for a single request.
-        :type _request_auth: dict, optional
-        :param _content_type: force content-type for the request.
-        :type _content_type: str, Optional
-        :param _headers: set to override the headers for a single
-                         request; this effectively ignores the headers
-                         in the spec for a single request.
-        :type _headers: dict, optional
-        :param _host_index: set to override the host_index for a single
-                            request; this effectively ignores the host_index
-                            in the spec for a single request.
-        :type _host_index: int, optional
-        :return: Returns the result object.
-        """ # noqa: E501
-
-        _param = self._list_users_serialize(
-            page_size=page_size,
-            page_num=page_num,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[UserBasicInfoDTO]"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _list_users_serialize(
-        self,
-        page_size,
-        page_num,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if page_size is not None:
-            _path_params['pageSize'] = page_size
-        if page_num is not None:
-            _path_params['pageNum'] = page_num
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'bearerAuth'
-        ]
-
-        return self.api_client.param_serialize(
-            method='GET',
-            resource_path='/api/v1/admin/users/{pageSize}/{pageNum}',
+            resource_path='/api/v1/account/basic/{username}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -2711,36 +2330,33 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def list_users1(
+    def get_user_details(
         self,
-        page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[UserBasicInfoDTO]:
-        """List User Information
+    ) -> UserDetailsDTO:
+        """Get User Details
 
-        Return user information by page, return the pageNum page, up to pageSize user information.
+        Return the detailed user information of the current account, the fields refer to the [standard claims](https://openid.net/specs/openid-connect-core-1_0.html#Claims) of OpenID Connect (OIDC).
 
-        :param page_size: Maximum quantity (required)
-        :type page_size: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2755,60 +2371,55 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_users1_serialize(
-            page_size=page_size,
+        _param = self._get_user_details_serialize(
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[UserBasicInfoDTO]"
-            
+            '200': "UserDetailsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def list_users1_with_http_info(
+    def get_user_details_with_http_info(
         self,
-        page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[UserBasicInfoDTO]]:
-        """List User Information
+    ) -> ApiResponse[UserDetailsDTO]:
+        """Get User Details
 
-        Return user information by page, return the pageNum page, up to pageSize user information.
+        Return the detailed user information of the current account, the fields refer to the [standard claims](https://openid.net/specs/openid-connect-core-1_0.html#Claims) of OpenID Connect (OIDC).
 
-        :param page_size: Maximum quantity (required)
-        :type page_size: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2823,60 +2434,55 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_users1_serialize(
-            page_size=page_size,
+        _param = self._get_user_details_serialize(
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[UserBasicInfoDTO]"
-            
+            '200': "UserDetailsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def list_users1_without_preload_content(
+    def get_user_details_without_preload_content(
         self,
-        page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """List User Information
+        """Get User Details
 
-        Return user information by page, return the pageNum page, up to pageSize user information.
+        Return the detailed user information of the current account, the fields refer to the [standard claims](https://openid.net/specs/openid-connect-core-1_0.html#Claims) of OpenID Connect (OIDC).
 
-        :param page_size: Maximum quantity (required)
-        :type page_size: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2891,58 +2497,52 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_users1_serialize(
-            page_size=page_size,
+        _param = self._get_user_details_serialize(
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[UserBasicInfoDTO]"
-            
+            '200': "UserDetailsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _list_users1_serialize(
+    def _get_user_details_serialize(
         self,
-        page_size,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if page_size is not None:
-            _path_params['pageSize'] = page_size
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
@@ -2956,15 +2556,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='GET',
-            resource_path='/api/v1/admin/users/{pageSize}',
+            resource_path='/api/v1/account/details',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -2973,32 +2573,32 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def list_users2(
+    def list_tokens(
         self,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[UserBasicInfoDTO]:
-        """List User Information
+    ) -> List[ApiTokenInfoDTO]:
+        """List API Tokens
 
-        Return user information by page, return the pageNum page, up to pageSize user information.
+        List currently valid tokens.
 
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
@@ -3014,55 +2614,54 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_users2_serialize(
+        _param = self._list_tokens_serialize(
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[UserBasicInfoDTO]"
-            
+            '200': "List[ApiTokenInfoDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def list_users2_with_http_info(
+    def list_tokens_with_http_info(
         self,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[UserBasicInfoDTO]]:
-        """List User Information
+    ) -> ApiResponse[List[ApiTokenInfoDTO]]:
+        """List API Tokens
 
-        Return user information by page, return the pageNum page, up to pageSize user information.
+        List currently valid tokens.
 
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
@@ -3078,55 +2677,54 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_users2_serialize(
+        _param = self._list_tokens_serialize(
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[UserBasicInfoDTO]"
-            
+            '200': "List[ApiTokenInfoDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def list_users2_without_preload_content(
+    def list_tokens_without_preload_content(
         self,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """List User Information
+        """List API Tokens
 
-        Return user information by page, return the pageNum page, up to pageSize user information.
+        List currently valid tokens.
 
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
@@ -3142,51 +2740,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_users2_serialize(
+        _param = self._list_tokens_serialize(
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[UserBasicInfoDTO]"
-            
+            '200': "List[ApiTokenInfoDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _list_users2_serialize(
+    def _list_tokens_serialize(
         self,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
@@ -3203,15 +2799,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='GET',
-            resource_path='/api/v1/admin/users',
+            resource_path='/api/v1/account/tokens',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -3220,39 +2816,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def update_authorities_of_user(
+    def update_user_info(
         self,
-        username: Annotated[StrictStr, Field(description="Username")],
-        request_body: Annotated[List[StrictStr], Field(description="Permission list")],
+        user_details_dto: Annotated[UserDetailsDTO, Field(description="User information")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> bool:
-        """Update User Permissions
+        """Update User Details
 
-        Update the user's permission list.
+        Update the detailed user information of the current account.
 
-        :param username: Username (required)
-        :type username: str
-        :param request_body: Permission list (required)
-        :type request_body: List[str]
+        :param user_details_dto: User information (required)
+        :type user_details_dto: UserDetailsDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3267,64 +2860,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_authorities_of_user_serialize(
-            username=username,
-            request_body=request_body,
+        _param = self._update_user_info_serialize(
+            user_details_dto=user_details_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def update_authorities_of_user_with_http_info(
+    def update_user_info_with_http_info(
         self,
-        username: Annotated[StrictStr, Field(description="Username")],
-        request_body: Annotated[List[StrictStr], Field(description="Permission list")],
+        user_details_dto: Annotated[UserDetailsDTO, Field(description="User information")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[bool]:
-        """Update User Permissions
+        """Update User Details
 
-        Update the user's permission list.
+        Update the detailed user information of the current account.
 
-        :param username: Username (required)
-        :type username: str
-        :param request_body: Permission list (required)
-        :type request_body: List[str]
+        :param user_details_dto: User information (required)
+        :type user_details_dto: UserDetailsDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3339,64 +2927,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_authorities_of_user_serialize(
-            username=username,
-            request_body=request_body,
+        _param = self._update_user_info_serialize(
+            user_details_dto=user_details_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def update_authorities_of_user_without_preload_content(
+    def update_user_info_without_preload_content(
         self,
-        username: Annotated[StrictStr, Field(description="Username")],
-        request_body: Annotated[List[StrictStr], Field(description="Permission list")],
+        user_details_dto: Annotated[UserDetailsDTO, Field(description="User information")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Update User Permissions
+        """Update User Details
 
-        Update the user's permission list.
+        Update the detailed user information of the current account.
 
-        :param username: Username (required)
-        :type username: str
-        :param request_body: Permission list (required)
-        :type request_body: List[str]
+        :param user_details_dto: User information (required)
+        :type user_details_dto: UserDetailsDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3411,67 +2994,60 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_authorities_of_user_serialize(
-            username=username,
-            request_body=request_body,
+        _param = self._update_user_info_serialize(
+            user_details_dto=user_details_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _update_authorities_of_user_serialize(
+    def _update_user_info_serialize(
         self,
-        username,
-        request_body,
+        user_details_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
-            'request_body': '',
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if username is not None:
-            _path_params['username'] = username
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
-        if request_body is not None:
-            _body_params = request_body
+        if user_details_dto is not None:
+            _body_params = user_details_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
                 'application/json'
             ]
@@ -3494,15 +3070,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='PUT',
-            resource_path='/api/v1/admin/authority/{username}',
+            resource_path='/api/v1/account/details',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -3511,36 +3087,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def update_user(
+    def upload_user_picture(
         self,
-        user_full_details_dto: Annotated[UserFullDetailsDTO, Field(description="User information")],
+        file: Annotated[Union[StrictBytes, StrictStr], Field(description="User picture")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> bool:
-        """Update User
+    ) -> str:
+        """Upload User Picture
 
-        Update user information.
+        Upload a picture of the user.
 
-        :param user_full_details_dto: User information (required)
-        :type user_full_details_dto: UserFullDetailsDTO
+        :param file: User picture (required)
+        :type file: bytearray
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3555,60 +3131,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_user_serialize(
-            user_full_details_dto=user_full_details_dto,
+        _param = self._upload_user_picture_serialize(
+            file=file,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def update_user_with_http_info(
+    def upload_user_picture_with_http_info(
         self,
-        user_full_details_dto: Annotated[UserFullDetailsDTO, Field(description="User information")],
+        file: Annotated[Union[StrictBytes, StrictStr], Field(description="User picture")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[bool]:
-        """Update User
+    ) -> ApiResponse[str]:
+        """Upload User Picture
 
-        Update user information.
+        Upload a picture of the user.
 
-        :param user_full_details_dto: User information (required)
-        :type user_full_details_dto: UserFullDetailsDTO
+        :param file: User picture (required)
+        :type file: bytearray
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3623,60 +3198,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_user_serialize(
-            user_full_details_dto=user_full_details_dto,
+        _param = self._upload_user_picture_serialize(
+            file=file,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def update_user_without_preload_content(
+    def upload_user_picture_without_preload_content(
         self,
-        user_full_details_dto: Annotated[UserFullDetailsDTO, Field(description="User information")],
+        file: Annotated[Union[StrictBytes, StrictStr], Field(description="User picture")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Update User
+        """Upload User Picture
 
-        Update user information.
+        Upload a picture of the user.
 
-        :param user_full_details_dto: User information (required)
-        :type user_full_details_dto: UserFullDetailsDTO
+        :param file: User picture (required)
+        :type file: bytearray
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3691,93 +3265,91 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_user_serialize(
-            user_full_details_dto=user_full_details_dto,
+        _param = self._upload_user_picture_serialize(
+            file=file,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _update_user_serialize(
+    def _upload_user_picture_serialize(
         self,
-        user_full_details_dto,
+        file,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
+        if file is not None:
+            _files['file'] = file
         # process the body parameter
-        if user_full_details_dto is not None:
-            _body_params = user_full_details_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
-                'application/json'
+                'text/plain'
             ]
         )
 
         # set the HTTP header `Content-Type`
         if _content_type:
             _header_params['Content-Type'] = _content_type
         else:
             _default_content_type = (
                 self.api_client.select_header_content_type(
                     [
-                        'application/json'
+                        'multipart/form-data'
                     ]
                 )
             )
             if _default_content_type is not None:
                 _header_params['Content-Type'] = _default_content_type
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
-            method='PUT',
-            resource_path='/api/v1/admin/user',
+            method='POST',
+            resource_path='/api/v1/account/picture',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## Comparing `freechat-sdk/api/ai_service_api.py` & `freechat_sdk/api/ai_service_api.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,45 +1,35 @@
 # coding: utf-8
 
 """
     FreeChat OpenAPI Definition
 
-    https://github.com/freechat-fun/freechat
+    # FreeChat: Create Some Friends for Yourself with AI  English | [中文版](https://github.com/freechat-fun/freechat/blob/main/README.zh-CN.md)  ## Introduction Welcome! FreeChat aims to build a cloud-native, robust, and quickly commercializable enterprise-level AI virtual character platform.  ## Features - Primarily uses Java and emphasizes **security, robustness, scalability, traceability, and maintainability**. - oasts **account systems and permission management**, supporting OAuth2 authentication. Introduces the \"organization\" concept and related permission constraint functions. - Extensively employs **distributed technologies and caching** to support **high concurrency** access. - Provides flexible character customization options, supports direct intervention in prompts, and supports **configuring multiple backends for each character**. - **Offers a comprehensive range of Open APIs**, with more than 180 interfaces and provides java/python/typescript SDKs. These interfaces enable easy construction of systems for end-users. - Supports setting **RAG** (Retrieval Augmented Generation) for characters. - Supports **long-term memory** for characters. - Supports setting **quota limits** for characters.  ## System Snapshots  ## Character Design ```mermaid flowchart TD     A(Character) --> B(Profile)     A --> C(Knowledge/RAG)     A --> D(Album)     A --> E(Backend-1)     A --> F(Backend-n...)     E --> G(Message Window)     E --> H(Long Term Memory Settings)     E --> I(Quota Limit)     E --> J(Chat Prompt Task)     E --> K(Greeting Prompt Task)     E --> L(Moderation Settings)     J --> M(Model & Parameters)     J --> N(API Keys)     J --> O(Prompt Refence)     J --> P(Tool Specifications)     O --> Q(Template)     O --> R(Variables)     O --> S(Version)     O --> T(...)     style K stroke-dasharray: 5, 5     style L stroke-dasharray: 5, 5     style P stroke-dasharray: 5, 5 ```  After setting up a unified persona and knowledge for a character, different backends can be configured. For example, different model may be adopted for different users based on cost considerations.  ## How to Play ### Online Website You can visit [freechat.fun](https://freechat.fun) to experience FreeChat. Share your designed AI character!  ### Running in a Kubernetes Cluster FreeChat is dedicated to the principles of cloud-native design. If you have a Kubernetes cluster, you can deploy FreeChat to your environment by following these steps:  1. Put the Kubernetes configuration file in the `configs/helm/` directory, named `kube-private.conf`. 2. Place the Helm configuration file in the same directory, named `values-private.yaml`. Make sure to reference the default `values.yaml` and customize the variables as needed. 3. Switch to the `scripts/` directory. 4. If needed, execute `install-in.sh` to deploy `ingress-nginx` to the Kubernetes cluster. 5. If needed, run `install-cm.sh` to deploy `cert-manager` on the Kubernetes cluster, which automatically issues certificates for domains specified in `ingress.hosts`. 6. Run `install-pvc.sh` to install PersistentVolumeClaim resources.      > By default, FreeChat operates files by accessing the \"local file system.\" You may want to use high-availability distributed storage in the cloud. As a cloud-native-designed system, we recommend interfacing through Kubernetes CSI to avoid individually adapting storage products for each cloud platform. Most cloud service providers offer cloud storage drivers for Kubernetes, with a series of predefined StorageClass resources. Please choose the appropriate configuration according to your actual needs and set it in Helm's `global.storageClass` option.     >      > *In the future, FreeChat may be refactored to use MinIO's APIs directly, as it is now installed in the Kubernetes cluster as a dependency (serving Milvus).*  7. Execute the `install.sh` script to install FreeChat and its dependencies. 8. FreeChat aims to provide Open API services. If you like the interactive experience of [freechat.fun](https://freechat.fun), run `install-web.sh` to deploy the front-end application. 9. Execute `restart.sh` to restart the service. 10. If you modified any Helm configuration files, use `upgrade.sh` to update the corresponding Kubernetes resources. 11. To remove specific resources, run the `uninstall*.sh` script corresponding to the resource you want to uninstall.  As a cloud-native application, the services FreeChat relies on are obtained and deployed to your cluster through the helm repository.  If you prefer cloud services with SLA (Service Level Agreement) guarantees, simply make the relevant settings in `configs/helm/values-private.yaml`: ```yaml bitnami:   mysql:     enabled: false   redis:     enabled: false   milvus:     enabled: false  mysql:   url: <your mysql url>   auth:     rootPassword: <your mysql root password>     username: <your mysql username>     password: <your mysql password for the username>  redis:   url: <your redis url>   auth:     password: <your redis password>   milvus:   url: <your milvus url>   milvus:     auth:       token: <your milvus api-key> ```  With this, FreeChat will not automatically install these services, but rather use the configuration information to connect directly.  ### Running Locally You can also run FreeChat locally. Currently supported on MacOS and Linux (although only tested on MacOS). You need to install the Docker toolset and have a network that can access [Docker Hub](https://hub.docker.com/).  Once ready, enter the `scripts/` directory and run `local-run.sh`, which will download and run the necessary docker containers. After a successful startup, you can access `http://localhost` via a browser to see the locally running freechat.fun. Use `local-run.sh --help` to view the supported options of the script. Good luck!  ### Running in an IDE To run FreeChat in an IDE, you need to start all dependent services first but do not need to run the container for the FreeChat application itself. You can execute the `scripts/local-deps.sh` script to start services like `MySQL`, `Redis`, `Milvus`, etc., locally. Once done, open and debug `freechat-start/src/main/java/fun/freechat/Application.java`。Make sure you have set the following startup parameters: ```shell -Dspring.config.location=classpath:/application.yml,classpath:/application-local.yml \\ -DAPP_HOME=local-data/freechat \\ -Dspring.profiles.active=local ```  ### 使用 SDK #### Java - **Dependency** ```xml <dependency>   <groupId>fun.freechat</groupId>   <artifactId>freechat-sdk</artifactId>   <version>${freechat-sdk.version}</version> </dependency> ```  - **Example** ```java import fun.freechat.client.ApiClient; import fun.freechat.client.ApiException; import fun.freechat.client.Configuration; import fun.freechat.client.api.AccountApi; import fun.freechat.client.auth.ApiKeyAuth; import fun.freechat.client.model.UserDetailsDTO;  public class AccountClientExample {     public static void main(String[] args) {         ApiClient defaultClient = Configuration.getDefaultApiClient();         defaultClient.setBasePath(\"https://freechat.fun\");                  // Configure HTTP bearer authorization: bearerAuth         HttpBearerAuth bearerAuth = (HttpBearerAuth) defaultClient.getAuthentication(\"bearerAuth\");         bearerAuth.setBearerToken(\"FREECHAT_TOKEN\");          AccountApi apiInstance = new AccountApi(defaultClient);         try {             UserDetailsDTO result = apiInstance.getUserDetails();             System.out.println(result);         } catch (ApiException e) {             e.printStackTrace();         }     } } ```  #### Python - **Installation** ```shell pip install freechat-sdk ```  - **Example** ```python import freechat_sdk from freechat_sdk.rest import ApiException from pprint import pprint  # Defining the host is optional and defaults to https://freechat.fun # See configuration.py for a list of all supported configuration parameters. configuration = freechat_sdk.Configuration(     host = \"https://freechat.fun\" )  # Configure Bearer authorization: bearerAuth configuration = freechat_sdk.Configuration(     access_token = os.environ[\"FREECHAT_TOKEN\"] )  # Enter a context with an instance of the API client with freechat_sdk.ApiClient(configuration) as api_client:     # Create an instance of the API class     api_instance = freechat_sdk.AccountApi(api_client)      try:         details = api_instance.get_user_details()         pprint(details)     except ApiException as e:         print(\"Exception when calling AccountClient->get_user_details: %s\\n\" % e) ```  #### TypeScript - **Installation** ```shell npm install freechat-sdk --save ```  - **Example** Refer to [FreeChatApiContext.tsx](https://github.com/freechat-fun/freechat/blob/main/freechat-web/src/contexts/FreeChatApiProvider.tsx)  ## System Dependencies | | Projects | ---- | ---- | Application Framework | [Spring Boot](https://spring.io/projects/spring-boot/) | LLM Framework | [LangChain4j](https://docs.langchain4j.dev/) | Model Providers | [OpenAI](https://platform.openai.com/), [DashScope](https://dashscope.aliyun.com/) | Database Systems | [MySQL](https://www.mysql.com/), [Redis](https://redis.io/), [Milvus](https://milvus.io/) | OpenAPI Tools | [Springdoc-openapi](https://springdoc.org/), [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator), [OpenAPI Explorer](https://github.com/Authress-Engineering/openapi-explorer)  ## Collaboration ### Application Integration The FreeChat system is entirely oriented towards Open APIs. The site [freechat.fun](https://freechat.fun) is developed using its TypeScript SDK and hardly depends on private interfaces. You can use these online interfaces to develop your own applications or sites, making them fit your preferences. Currently, FreeChat is completely free with no paid plans (after all, users use their own API Key to call LLM services).  ### Model Integration FreeChat aims to explore AI virtual character technology with anthropomorphic characteristics. So far, it supports model services from OpenAI and DashScope ([HuggingFace](https://huggingface.co/) is also expected to be supported soon). However, we are more interested in supporting models that are under research and can endow AI with more personality traits. If you are researching this area and hope FreeChat supports your model, please contact us. We look forward to AI technology helping people create their own \"soul mates\" in the future.
 
-    The version of the OpenAPI document: 0.1.0
+    The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
-import io
 import warnings
-
 from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
-
-try:
-    from typing import Annotated
-except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import Field
+from typing import Any, Dict, List, Optional, Tuple, Union
 from typing_extensions import Annotated
-from pydantic import StrictInt, StrictStr
 
+from pydantic import Field, StrictBool, StrictInt, StrictStr
 from typing import List
-
-from freechat-sdk.models.ai_api_key_create_dto import AiApiKeyCreateDTO
-from freechat-sdk.models.ai_api_key_info_dto import AiApiKeyInfoDTO
-from freechat-sdk.models.ai_model_info_dto import AiModelInfoDTO
-
-from freechat-sdk.api_client import ApiClient
-from freechat-sdk.api_response import ApiResponse
-from freechat-sdk.rest import RESTResponseType
+from typing_extensions import Annotated
+from freechat_sdk.models.ai_api_key_create_dto import AiApiKeyCreateDTO
+from freechat_sdk.models.ai_api_key_info_dto import AiApiKeyInfoDTO
+from freechat_sdk.models.ai_model_info_dto import AiModelInfoDTO
+
+from freechat_sdk.api_client import ApiClient, RequestSerialized
+from freechat_sdk.api_response import ApiResponse
+from freechat_sdk.rest import RESTResponseType
 
 
 class AIServiceApi:
     """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
@@ -101,16 +91,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -169,16 +158,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -237,16 +225,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -254,27 +241,26 @@
     def _add_ai_api_key_serialize(
         self,
         ai_api_key_create_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
@@ -376,16 +362,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -444,16 +429,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -512,16 +496,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -529,27 +512,26 @@
     def _delete_ai_api_key_serialize(
         self,
         id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if id is not None:
             _path_params['id'] = id
         # process the query parameters
         # process the header parameters
@@ -638,16 +620,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -706,16 +687,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -774,16 +754,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -791,27 +770,26 @@
     def _disable_ai_api_key_serialize(
         self,
         id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if id is not None:
             _path_params['id'] = id
         # process the query parameters
         # process the header parameters
@@ -900,16 +878,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -968,16 +945,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1036,16 +1012,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -1053,27 +1028,26 @@
     def _enable_ai_api_key_serialize(
         self,
         id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if id is not None:
             _path_params['id'] = id
         # process the query parameters
         # process the header parameters
@@ -1162,16 +1136,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "AiApiKeyInfoDTO"
-            
+            '200': "AiApiKeyInfoDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1230,16 +1203,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "AiApiKeyInfoDTO"
-            
+            '200': "AiApiKeyInfoDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1298,16 +1270,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "AiApiKeyInfoDTO"
-            
+            '200': "AiApiKeyInfoDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -1315,27 +1286,26 @@
     def _get_ai_api_key_serialize(
         self,
         id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if id is not None:
             _path_params['id'] = id
         # process the query parameters
         # process the header parameters
@@ -1424,16 +1394,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "AiModelInfoDTO"
-            
+            '200': "AiModelInfoDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1492,16 +1461,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "AiModelInfoDTO"
-            
+            '200': "AiModelInfoDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1560,16 +1528,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "AiModelInfoDTO"
-            
+            '200': "AiModelInfoDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -1577,27 +1544,26 @@
     def _get_ai_model_info_serialize(
         self,
         model_id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if model_id is not None:
             _path_params['modelId'] = model_id
         # process the query parameters
         # process the header parameters
@@ -1686,16 +1652,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[AiApiKeyInfoDTO]"
-            
+            '200': "List[AiApiKeyInfoDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1754,16 +1719,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[AiApiKeyInfoDTO]"
-            
+            '200': "List[AiApiKeyInfoDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1822,16 +1786,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[AiApiKeyInfoDTO]"
-            
+            '200': "List[AiApiKeyInfoDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -1839,27 +1802,26 @@
     def _list_ai_api_keys_serialize(
         self,
         provider,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if provider is not None:
             _path_params['provider'] = provider
         # process the query parameters
         # process the header parameters
@@ -1948,16 +1910,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[AiModelInfoDTO]"
-            
+            '200': "List[AiModelInfoDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -2016,16 +1977,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[AiModelInfoDTO]"
-            
+            '200': "List[AiModelInfoDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -2084,16 +2044,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[AiModelInfoDTO]"
-            
+            '200': "List[AiModelInfoDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -2101,27 +2060,26 @@
     def _list_ai_model_info_serialize(
         self,
         page_size,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if page_size is not None:
             _path_params['pageSize'] = page_size
         # process the query parameters
         # process the header parameters
@@ -2206,16 +2164,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[AiModelInfoDTO]"
-            
+            '200': "List[AiModelInfoDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -2270,16 +2227,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[AiModelInfoDTO]"
-            
+            '200': "List[AiModelInfoDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -2334,43 +2290,41 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[AiModelInfoDTO]"
-            
+            '200': "List[AiModelInfoDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
     def _list_ai_model_info1_serialize(
         self,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
@@ -2407,15 +2361,15 @@
 
 
 
     @validate_call
     def list_ai_model_info2(
         self,
         page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
-        page_num: Annotated[int, Field(strict=True, ge=0, description="Current page number")],
+        page_num: Annotated[StrictInt, Field(description="Current page number")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
@@ -2461,16 +2415,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[AiModelInfoDTO]"
-            
+            '200': "List[AiModelInfoDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -2479,15 +2432,15 @@
         ).data
 
 
     @validate_call
     def list_ai_model_info2_with_http_info(
         self,
         page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
-        page_num: Annotated[int, Field(strict=True, ge=0, description="Current page number")],
+        page_num: Annotated[StrictInt, Field(description="Current page number")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
@@ -2533,16 +2486,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[AiModelInfoDTO]"
-            
+            '200': "List[AiModelInfoDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -2551,15 +2503,15 @@
         )
 
 
     @validate_call
     def list_ai_model_info2_without_preload_content(
         self,
         page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
-        page_num: Annotated[int, Field(strict=True, ge=0, description="Current page number")],
+        page_num: Annotated[StrictInt, Field(description="Current page number")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
@@ -2605,16 +2557,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[AiModelInfoDTO]"
-            
+            '200': "List[AiModelInfoDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -2623,27 +2574,26 @@
         self,
         page_size,
         page_num,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if page_size is not None:
             _path_params['pageSize'] = page_size
         if page_num is not None:
             _path_params['pageNum'] = page_num
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## Comparing `freechat-sdk/api/app_config_for_admin_api.py` & `freechat_sdk/api/app_config_for_admin_api.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,44 +1,34 @@
 # coding: utf-8
 
 """
     FreeChat OpenAPI Definition
 
-    https://github.com/freechat-fun/freechat
+    # FreeChat: Create Some Friends for Yourself with AI  English | [中文版](https://github.com/freechat-fun/freechat/blob/main/README.zh-CN.md)  ## Introduction Welcome! FreeChat aims to build a cloud-native, robust, and quickly commercializable enterprise-level AI virtual character platform.  ## Features - Primarily uses Java and emphasizes **security, robustness, scalability, traceability, and maintainability**. - oasts **account systems and permission management**, supporting OAuth2 authentication. Introduces the \"organization\" concept and related permission constraint functions. - Extensively employs **distributed technologies and caching** to support **high concurrency** access. - Provides flexible character customization options, supports direct intervention in prompts, and supports **configuring multiple backends for each character**. - **Offers a comprehensive range of Open APIs**, with more than 180 interfaces and provides java/python/typescript SDKs. These interfaces enable easy construction of systems for end-users. - Supports setting **RAG** (Retrieval Augmented Generation) for characters. - Supports **long-term memory** for characters. - Supports setting **quota limits** for characters.  ## System Snapshots  ## Character Design ```mermaid flowchart TD     A(Character) --> B(Profile)     A --> C(Knowledge/RAG)     A --> D(Album)     A --> E(Backend-1)     A --> F(Backend-n...)     E --> G(Message Window)     E --> H(Long Term Memory Settings)     E --> I(Quota Limit)     E --> J(Chat Prompt Task)     E --> K(Greeting Prompt Task)     E --> L(Moderation Settings)     J --> M(Model & Parameters)     J --> N(API Keys)     J --> O(Prompt Refence)     J --> P(Tool Specifications)     O --> Q(Template)     O --> R(Variables)     O --> S(Version)     O --> T(...)     style K stroke-dasharray: 5, 5     style L stroke-dasharray: 5, 5     style P stroke-dasharray: 5, 5 ```  After setting up a unified persona and knowledge for a character, different backends can be configured. For example, different model may be adopted for different users based on cost considerations.  ## How to Play ### Online Website You can visit [freechat.fun](https://freechat.fun) to experience FreeChat. Share your designed AI character!  ### Running in a Kubernetes Cluster FreeChat is dedicated to the principles of cloud-native design. If you have a Kubernetes cluster, you can deploy FreeChat to your environment by following these steps:  1. Put the Kubernetes configuration file in the `configs/helm/` directory, named `kube-private.conf`. 2. Place the Helm configuration file in the same directory, named `values-private.yaml`. Make sure to reference the default `values.yaml` and customize the variables as needed. 3. Switch to the `scripts/` directory. 4. If needed, execute `install-in.sh` to deploy `ingress-nginx` to the Kubernetes cluster. 5. If needed, run `install-cm.sh` to deploy `cert-manager` on the Kubernetes cluster, which automatically issues certificates for domains specified in `ingress.hosts`. 6. Run `install-pvc.sh` to install PersistentVolumeClaim resources.      > By default, FreeChat operates files by accessing the \"local file system.\" You may want to use high-availability distributed storage in the cloud. As a cloud-native-designed system, we recommend interfacing through Kubernetes CSI to avoid individually adapting storage products for each cloud platform. Most cloud service providers offer cloud storage drivers for Kubernetes, with a series of predefined StorageClass resources. Please choose the appropriate configuration according to your actual needs and set it in Helm's `global.storageClass` option.     >      > *In the future, FreeChat may be refactored to use MinIO's APIs directly, as it is now installed in the Kubernetes cluster as a dependency (serving Milvus).*  7. Execute the `install.sh` script to install FreeChat and its dependencies. 8. FreeChat aims to provide Open API services. If you like the interactive experience of [freechat.fun](https://freechat.fun), run `install-web.sh` to deploy the front-end application. 9. Execute `restart.sh` to restart the service. 10. If you modified any Helm configuration files, use `upgrade.sh` to update the corresponding Kubernetes resources. 11. To remove specific resources, run the `uninstall*.sh` script corresponding to the resource you want to uninstall.  As a cloud-native application, the services FreeChat relies on are obtained and deployed to your cluster through the helm repository.  If you prefer cloud services with SLA (Service Level Agreement) guarantees, simply make the relevant settings in `configs/helm/values-private.yaml`: ```yaml bitnami:   mysql:     enabled: false   redis:     enabled: false   milvus:     enabled: false  mysql:   url: <your mysql url>   auth:     rootPassword: <your mysql root password>     username: <your mysql username>     password: <your mysql password for the username>  redis:   url: <your redis url>   auth:     password: <your redis password>   milvus:   url: <your milvus url>   milvus:     auth:       token: <your milvus api-key> ```  With this, FreeChat will not automatically install these services, but rather use the configuration information to connect directly.  ### Running Locally You can also run FreeChat locally. Currently supported on MacOS and Linux (although only tested on MacOS). You need to install the Docker toolset and have a network that can access [Docker Hub](https://hub.docker.com/).  Once ready, enter the `scripts/` directory and run `local-run.sh`, which will download and run the necessary docker containers. After a successful startup, you can access `http://localhost` via a browser to see the locally running freechat.fun. Use `local-run.sh --help` to view the supported options of the script. Good luck!  ### Running in an IDE To run FreeChat in an IDE, you need to start all dependent services first but do not need to run the container for the FreeChat application itself. You can execute the `scripts/local-deps.sh` script to start services like `MySQL`, `Redis`, `Milvus`, etc., locally. Once done, open and debug `freechat-start/src/main/java/fun/freechat/Application.java`。Make sure you have set the following startup parameters: ```shell -Dspring.config.location=classpath:/application.yml,classpath:/application-local.yml \\ -DAPP_HOME=local-data/freechat \\ -Dspring.profiles.active=local ```  ### 使用 SDK #### Java - **Dependency** ```xml <dependency>   <groupId>fun.freechat</groupId>   <artifactId>freechat-sdk</artifactId>   <version>${freechat-sdk.version}</version> </dependency> ```  - **Example** ```java import fun.freechat.client.ApiClient; import fun.freechat.client.ApiException; import fun.freechat.client.Configuration; import fun.freechat.client.api.AccountApi; import fun.freechat.client.auth.ApiKeyAuth; import fun.freechat.client.model.UserDetailsDTO;  public class AccountClientExample {     public static void main(String[] args) {         ApiClient defaultClient = Configuration.getDefaultApiClient();         defaultClient.setBasePath(\"https://freechat.fun\");                  // Configure HTTP bearer authorization: bearerAuth         HttpBearerAuth bearerAuth = (HttpBearerAuth) defaultClient.getAuthentication(\"bearerAuth\");         bearerAuth.setBearerToken(\"FREECHAT_TOKEN\");          AccountApi apiInstance = new AccountApi(defaultClient);         try {             UserDetailsDTO result = apiInstance.getUserDetails();             System.out.println(result);         } catch (ApiException e) {             e.printStackTrace();         }     } } ```  #### Python - **Installation** ```shell pip install freechat-sdk ```  - **Example** ```python import freechat_sdk from freechat_sdk.rest import ApiException from pprint import pprint  # Defining the host is optional and defaults to https://freechat.fun # See configuration.py for a list of all supported configuration parameters. configuration = freechat_sdk.Configuration(     host = \"https://freechat.fun\" )  # Configure Bearer authorization: bearerAuth configuration = freechat_sdk.Configuration(     access_token = os.environ[\"FREECHAT_TOKEN\"] )  # Enter a context with an instance of the API client with freechat_sdk.ApiClient(configuration) as api_client:     # Create an instance of the API class     api_instance = freechat_sdk.AccountApi(api_client)      try:         details = api_instance.get_user_details()         pprint(details)     except ApiException as e:         print(\"Exception when calling AccountClient->get_user_details: %s\\n\" % e) ```  #### TypeScript - **Installation** ```shell npm install freechat-sdk --save ```  - **Example** Refer to [FreeChatApiContext.tsx](https://github.com/freechat-fun/freechat/blob/main/freechat-web/src/contexts/FreeChatApiProvider.tsx)  ## System Dependencies | | Projects | ---- | ---- | Application Framework | [Spring Boot](https://spring.io/projects/spring-boot/) | LLM Framework | [LangChain4j](https://docs.langchain4j.dev/) | Model Providers | [OpenAI](https://platform.openai.com/), [DashScope](https://dashscope.aliyun.com/) | Database Systems | [MySQL](https://www.mysql.com/), [Redis](https://redis.io/), [Milvus](https://milvus.io/) | OpenAPI Tools | [Springdoc-openapi](https://springdoc.org/), [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator), [OpenAPI Explorer](https://github.com/Authress-Engineering/openapi-explorer)  ## Collaboration ### Application Integration The FreeChat system is entirely oriented towards Open APIs. The site [freechat.fun](https://freechat.fun) is developed using its TypeScript SDK and hardly depends on private interfaces. You can use these online interfaces to develop your own applications or sites, making them fit your preferences. Currently, FreeChat is completely free with no paid plans (after all, users use their own API Key to call LLM services).  ### Model Integration FreeChat aims to explore AI virtual character technology with anthropomorphic characteristics. So far, it supports model services from OpenAI and DashScope ([HuggingFace](https://huggingface.co/) is also expected to be supported soon). However, we are more interested in supporting models that are under research and can endow AI with more personality traits. If you are researching this area and hope FreeChat supports your model, please contact us. We look forward to AI technology helping people create their own \"soul mates\" in the future.
 
-    The version of the OpenAPI document: 0.1.0
+    The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
-import io
 import warnings
-
 from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
-
-try:
-    from typing import Annotated
-except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import Field
+from typing import Any, Dict, List, Optional, Tuple, Union
 from typing_extensions import Annotated
-from pydantic import StrictInt, StrictStr
 
+from pydantic import Field, StrictInt, StrictStr
 from typing import List
+from typing_extensions import Annotated
+from freechat_sdk.models.app_config_create_dto import AppConfigCreateDTO
+from freechat_sdk.models.app_config_info_dto import AppConfigInfoDTO
 
-from freechat-sdk.models.app_config_create_dto import AppConfigCreateDTO
-from freechat-sdk.models.app_config_info_dto import AppConfigInfoDTO
-
-from freechat-sdk.api_client import ApiClient
-from freechat-sdk.api_response import ApiResponse
-from freechat-sdk.rest import RESTResponseType
+from freechat_sdk.api_client import ApiClient, RequestSerialized
+from freechat_sdk.api_response import ApiResponse
+from freechat_sdk.rest import RESTResponseType
 
 
 class AppConfigForAdminApi:
     """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
@@ -100,16 +90,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "AppConfigInfoDTO"
-            
+            '200': "AppConfigInfoDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -168,16 +157,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "AppConfigInfoDTO"
-            
+            '200': "AppConfigInfoDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -236,16 +224,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "AppConfigInfoDTO"
-            
+            '200': "AppConfigInfoDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -253,27 +240,26 @@
     def _get_app_config_serialize(
         self,
         name,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if name is not None:
             _path_params['name'] = name
         # process the query parameters
         # process the header parameters
@@ -366,16 +352,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "AppConfigInfoDTO"
-            
+            '200': "AppConfigInfoDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -438,16 +423,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "AppConfigInfoDTO"
-            
+            '200': "AppConfigInfoDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -510,16 +494,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "AppConfigInfoDTO"
-            
+            '200': "AppConfigInfoDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -528,27 +511,26 @@
         self,
         name,
         version,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if name is not None:
             _path_params['name'] = name
         if version is not None:
             _path_params['version'] = version
@@ -635,16 +617,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -699,16 +680,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -763,43 +743,41 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
     def _list_app_config_names_serialize(
         self,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
@@ -886,16 +864,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -954,16 +931,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1022,16 +998,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -1039,27 +1014,26 @@
     def _publish_app_config_serialize(
         self,
         app_config_create_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## Comparing `freechat-sdk/api/character_api.py` & `freechat_sdk/api/character_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,55 +1,40 @@
 # coding: utf-8
 
 """
     FreeChat OpenAPI Definition
 
-    https://github.com/freechat-fun/freechat
+    # FreeChat: Create Some Friends for Yourself with AI  English | [中文版](https://github.com/freechat-fun/freechat/blob/main/README.zh-CN.md)  ## Introduction Welcome! FreeChat aims to build a cloud-native, robust, and quickly commercializable enterprise-level AI virtual character platform.  ## Features - Primarily uses Java and emphasizes **security, robustness, scalability, traceability, and maintainability**. - oasts **account systems and permission management**, supporting OAuth2 authentication. Introduces the \"organization\" concept and related permission constraint functions. - Extensively employs **distributed technologies and caching** to support **high concurrency** access. - Provides flexible character customization options, supports direct intervention in prompts, and supports **configuring multiple backends for each character**. - **Offers a comprehensive range of Open APIs**, with more than 180 interfaces and provides java/python/typescript SDKs. These interfaces enable easy construction of systems for end-users. - Supports setting **RAG** (Retrieval Augmented Generation) for characters. - Supports **long-term memory** for characters. - Supports setting **quota limits** for characters.  ## System Snapshots  ## Character Design ```mermaid flowchart TD     A(Character) --> B(Profile)     A --> C(Knowledge/RAG)     A --> D(Album)     A --> E(Backend-1)     A --> F(Backend-n...)     E --> G(Message Window)     E --> H(Long Term Memory Settings)     E --> I(Quota Limit)     E --> J(Chat Prompt Task)     E --> K(Greeting Prompt Task)     E --> L(Moderation Settings)     J --> M(Model & Parameters)     J --> N(API Keys)     J --> O(Prompt Refence)     J --> P(Tool Specifications)     O --> Q(Template)     O --> R(Variables)     O --> S(Version)     O --> T(...)     style K stroke-dasharray: 5, 5     style L stroke-dasharray: 5, 5     style P stroke-dasharray: 5, 5 ```  After setting up a unified persona and knowledge for a character, different backends can be configured. For example, different model may be adopted for different users based on cost considerations.  ## How to Play ### Online Website You can visit [freechat.fun](https://freechat.fun) to experience FreeChat. Share your designed AI character!  ### Running in a Kubernetes Cluster FreeChat is dedicated to the principles of cloud-native design. If you have a Kubernetes cluster, you can deploy FreeChat to your environment by following these steps:  1. Put the Kubernetes configuration file in the `configs/helm/` directory, named `kube-private.conf`. 2. Place the Helm configuration file in the same directory, named `values-private.yaml`. Make sure to reference the default `values.yaml` and customize the variables as needed. 3. Switch to the `scripts/` directory. 4. If needed, execute `install-in.sh` to deploy `ingress-nginx` to the Kubernetes cluster. 5. If needed, run `install-cm.sh` to deploy `cert-manager` on the Kubernetes cluster, which automatically issues certificates for domains specified in `ingress.hosts`. 6. Run `install-pvc.sh` to install PersistentVolumeClaim resources.      > By default, FreeChat operates files by accessing the \"local file system.\" You may want to use high-availability distributed storage in the cloud. As a cloud-native-designed system, we recommend interfacing through Kubernetes CSI to avoid individually adapting storage products for each cloud platform. Most cloud service providers offer cloud storage drivers for Kubernetes, with a series of predefined StorageClass resources. Please choose the appropriate configuration according to your actual needs and set it in Helm's `global.storageClass` option.     >      > *In the future, FreeChat may be refactored to use MinIO's APIs directly, as it is now installed in the Kubernetes cluster as a dependency (serving Milvus).*  7. Execute the `install.sh` script to install FreeChat and its dependencies. 8. FreeChat aims to provide Open API services. If you like the interactive experience of [freechat.fun](https://freechat.fun), run `install-web.sh` to deploy the front-end application. 9. Execute `restart.sh` to restart the service. 10. If you modified any Helm configuration files, use `upgrade.sh` to update the corresponding Kubernetes resources. 11. To remove specific resources, run the `uninstall*.sh` script corresponding to the resource you want to uninstall.  As a cloud-native application, the services FreeChat relies on are obtained and deployed to your cluster through the helm repository.  If you prefer cloud services with SLA (Service Level Agreement) guarantees, simply make the relevant settings in `configs/helm/values-private.yaml`: ```yaml bitnami:   mysql:     enabled: false   redis:     enabled: false   milvus:     enabled: false  mysql:   url: <your mysql url>   auth:     rootPassword: <your mysql root password>     username: <your mysql username>     password: <your mysql password for the username>  redis:   url: <your redis url>   auth:     password: <your redis password>   milvus:   url: <your milvus url>   milvus:     auth:       token: <your milvus api-key> ```  With this, FreeChat will not automatically install these services, but rather use the configuration information to connect directly.  ### Running Locally You can also run FreeChat locally. Currently supported on MacOS and Linux (although only tested on MacOS). You need to install the Docker toolset and have a network that can access [Docker Hub](https://hub.docker.com/).  Once ready, enter the `scripts/` directory and run `local-run.sh`, which will download and run the necessary docker containers. After a successful startup, you can access `http://localhost` via a browser to see the locally running freechat.fun. Use `local-run.sh --help` to view the supported options of the script. Good luck!  ### Running in an IDE To run FreeChat in an IDE, you need to start all dependent services first but do not need to run the container for the FreeChat application itself. You can execute the `scripts/local-deps.sh` script to start services like `MySQL`, `Redis`, `Milvus`, etc., locally. Once done, open and debug `freechat-start/src/main/java/fun/freechat/Application.java`。Make sure you have set the following startup parameters: ```shell -Dspring.config.location=classpath:/application.yml,classpath:/application-local.yml \\ -DAPP_HOME=local-data/freechat \\ -Dspring.profiles.active=local ```  ### 使用 SDK #### Java - **Dependency** ```xml <dependency>   <groupId>fun.freechat</groupId>   <artifactId>freechat-sdk</artifactId>   <version>${freechat-sdk.version}</version> </dependency> ```  - **Example** ```java import fun.freechat.client.ApiClient; import fun.freechat.client.ApiException; import fun.freechat.client.Configuration; import fun.freechat.client.api.AccountApi; import fun.freechat.client.auth.ApiKeyAuth; import fun.freechat.client.model.UserDetailsDTO;  public class AccountClientExample {     public static void main(String[] args) {         ApiClient defaultClient = Configuration.getDefaultApiClient();         defaultClient.setBasePath(\"https://freechat.fun\");                  // Configure HTTP bearer authorization: bearerAuth         HttpBearerAuth bearerAuth = (HttpBearerAuth) defaultClient.getAuthentication(\"bearerAuth\");         bearerAuth.setBearerToken(\"FREECHAT_TOKEN\");          AccountApi apiInstance = new AccountApi(defaultClient);         try {             UserDetailsDTO result = apiInstance.getUserDetails();             System.out.println(result);         } catch (ApiException e) {             e.printStackTrace();         }     } } ```  #### Python - **Installation** ```shell pip install freechat-sdk ```  - **Example** ```python import freechat_sdk from freechat_sdk.rest import ApiException from pprint import pprint  # Defining the host is optional and defaults to https://freechat.fun # See configuration.py for a list of all supported configuration parameters. configuration = freechat_sdk.Configuration(     host = \"https://freechat.fun\" )  # Configure Bearer authorization: bearerAuth configuration = freechat_sdk.Configuration(     access_token = os.environ[\"FREECHAT_TOKEN\"] )  # Enter a context with an instance of the API client with freechat_sdk.ApiClient(configuration) as api_client:     # Create an instance of the API class     api_instance = freechat_sdk.AccountApi(api_client)      try:         details = api_instance.get_user_details()         pprint(details)     except ApiException as e:         print(\"Exception when calling AccountClient->get_user_details: %s\\n\" % e) ```  #### TypeScript - **Installation** ```shell npm install freechat-sdk --save ```  - **Example** Refer to [FreeChatApiContext.tsx](https://github.com/freechat-fun/freechat/blob/main/freechat-web/src/contexts/FreeChatApiProvider.tsx)  ## System Dependencies | | Projects | ---- | ---- | Application Framework | [Spring Boot](https://spring.io/projects/spring-boot/) | LLM Framework | [LangChain4j](https://docs.langchain4j.dev/) | Model Providers | [OpenAI](https://platform.openai.com/), [DashScope](https://dashscope.aliyun.com/) | Database Systems | [MySQL](https://www.mysql.com/), [Redis](https://redis.io/), [Milvus](https://milvus.io/) | OpenAPI Tools | [Springdoc-openapi](https://springdoc.org/), [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator), [OpenAPI Explorer](https://github.com/Authress-Engineering/openapi-explorer)  ## Collaboration ### Application Integration The FreeChat system is entirely oriented towards Open APIs. The site [freechat.fun](https://freechat.fun) is developed using its TypeScript SDK and hardly depends on private interfaces. You can use these online interfaces to develop your own applications or sites, making them fit your preferences. Currently, FreeChat is completely free with no paid plans (after all, users use their own API Key to call LLM services).  ### Model Integration FreeChat aims to explore AI virtual character technology with anthropomorphic characteristics. So far, it supports model services from OpenAI and DashScope ([HuggingFace](https://huggingface.co/) is also expected to be supported soon). However, we are more interested in supporting models that are under research and can endow AI with more personality traits. If you are researching this area and hope FreeChat supports your model, please contact us. We look forward to AI technology helping people create their own \"soul mates\" in the future.
 
-    The version of the OpenAPI document: 0.1.0
+    The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
-import io
 import warnings
-
 from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
-
-try:
-    from typing import Annotated
-except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import Field
+from typing import Any, Dict, List, Optional, Tuple, Union
 from typing_extensions import Annotated
-from pydantic import StrictBytes, StrictInt, StrictStr
 
+from pydantic import Field, StrictBool, StrictBytes, StrictInt, StrictStr
 from typing import List, Union
-
-from freechat-sdk.models.character_backend_dto import CharacterBackendDTO
-from freechat-sdk.models.character_backend_details_dto import CharacterBackendDetailsDTO
-from freechat-sdk.models.character_create_dto import CharacterCreateDTO
-from freechat-sdk.models.character_details_dto import CharacterDetailsDTO
-from freechat-sdk.models.character_item_for_name_dto import CharacterItemForNameDTO
-from freechat-sdk.models.character_query_dto import CharacterQueryDTO
-from freechat-sdk.models.character_summary_dto import CharacterSummaryDTO
-from freechat-sdk.models.character_update_dto import CharacterUpdateDTO
-from freechat-sdk.models.chat_content_dto import ChatContentDTO
-from freechat-sdk.models.chat_create_dto import ChatCreateDTO
-from freechat-sdk.models.chat_message_dto import ChatMessageDTO
-from freechat-sdk.models.llm_result_dto import LlmResultDTO
-from freechat-sdk.models.sse_emitter import SseEmitter
-
-from freechat-sdk.api_client import ApiClient
-from freechat-sdk.api_response import ApiResponse
-from freechat-sdk.rest import RESTResponseType
+from typing_extensions import Annotated
+from freechat_sdk.models.character_backend_dto import CharacterBackendDTO
+from freechat_sdk.models.character_backend_details_dto import CharacterBackendDetailsDTO
+from freechat_sdk.models.character_create_dto import CharacterCreateDTO
+from freechat_sdk.models.character_details_dto import CharacterDetailsDTO
+from freechat_sdk.models.character_item_for_name_dto import CharacterItemForNameDTO
+from freechat_sdk.models.character_query_dto import CharacterQueryDTO
+from freechat_sdk.models.character_summary_dto import CharacterSummaryDTO
+from freechat_sdk.models.character_update_dto import CharacterUpdateDTO
+
+from freechat_sdk.api_client import ApiClient, RequestSerialized
+from freechat_sdk.api_response import ApiResponse
+from freechat_sdk.rest import RESTResponseType
 
 
 class CharacterApi:
     """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
@@ -60,15 +45,15 @@
             api_client = ApiClient.get_default()
         self.api_client = api_client
 
 
     @validate_call
     def add_character_backend(
         self,
-        character_id: Annotated[StrictStr, Field(description="The characterId to be added a backend")],
+        character_id: Annotated[StrictInt, Field(description="The characterId to be added a backend")],
         character_backend_dto: Annotated[CharacterBackendDTO, Field(description="The character backend to be added")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -80,15 +65,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> str:
         """Add Character Backend
 
         Add a backend configuration for a character.
 
         :param character_id: The characterId to be added a backend (required)
-        :type character_id: str
+        :type character_id: int
         :param character_backend_dto: The character backend to be added (required)
         :type character_backend_dto: CharacterBackendDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
@@ -115,16 +100,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -132,15 +116,15 @@
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
     def add_character_backend_with_http_info(
         self,
-        character_id: Annotated[StrictStr, Field(description="The characterId to be added a backend")],
+        character_id: Annotated[StrictInt, Field(description="The characterId to be added a backend")],
         character_backend_dto: Annotated[CharacterBackendDTO, Field(description="The character backend to be added")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -152,15 +136,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[str]:
         """Add Character Backend
 
         Add a backend configuration for a character.
 
         :param character_id: The characterId to be added a backend (required)
-        :type character_id: str
+        :type character_id: int
         :param character_backend_dto: The character backend to be added (required)
         :type character_backend_dto: CharacterBackendDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
@@ -187,16 +171,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -204,15 +187,15 @@
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
     def add_character_backend_without_preload_content(
         self,
-        character_id: Annotated[StrictStr, Field(description="The characterId to be added a backend")],
+        character_id: Annotated[StrictInt, Field(description="The characterId to be added a backend")],
         character_backend_dto: Annotated[CharacterBackendDTO, Field(description="The character backend to be added")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -224,15 +207,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
         """Add Character Backend
 
         Add a backend configuration for a character.
 
         :param character_id: The characterId to be added a backend (required)
-        :type character_id: str
+        :type character_id: int
         :param character_backend_dto: The character backend to be added (required)
         :type character_backend_dto: CharacterBackendDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
@@ -259,16 +242,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -277,27 +259,26 @@
         self,
         character_id,
         character_backend_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if character_id is not None:
             _path_params['characterId'] = character_id
         # process the query parameters
         # process the header parameters
@@ -401,16 +382,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[List[CharacterDetailsDTO]]"
-            
+            '200': "List[List[CharacterDetailsDTO]]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -469,16 +449,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[List[CharacterDetailsDTO]]"
-            
+            '200': "List[List[CharacterDetailsDTO]]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -537,16 +516,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[List[CharacterDetailsDTO]]"
-            
+            '200': "List[List[CharacterDetailsDTO]]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -554,28 +532,27 @@
     def _batch_search_character_details_serialize(
         self,
         character_query_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
             'CharacterQueryDTO': '',
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
@@ -677,16 +654,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[List[CharacterSummaryDTO]]"
-            
+            '200': "List[List[CharacterSummaryDTO]]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -745,16 +721,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[List[CharacterSummaryDTO]]"
-            
+            '200': "List[List[CharacterSummaryDTO]]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -813,16 +788,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[List[CharacterSummaryDTO]]"
-            
+            '200': "List[List[CharacterSummaryDTO]]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -830,28 +804,27 @@
     def _batch_search_character_summary_serialize(
         self,
         character_query_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
             'CharacterQueryDTO': '',
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
@@ -902,34 +875,34 @@
 
 
 
 
     @validate_call
     def clone_character(
         self,
-        character_id: Annotated[StrictStr, Field(description="The referenced characterId")],
+        character_id: Annotated[StrictInt, Field(description="The referenced characterId")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> str:
+    ) -> int:
         """Clone Character
 
         Enter the characterId, generate a new record, the content is basically the same as the original character, but the following fields are different: - Version number is 1 - Visibility is private - The parent character is the source characterId - The creation time is the current moment. - All statistical indicators are zeroed.  Return the new characterId. 
 
         :param character_id: The referenced characterId (required)
-        :type character_id: str
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -953,16 +926,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -970,34 +942,34 @@
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
     def clone_character_with_http_info(
         self,
-        character_id: Annotated[StrictStr, Field(description="The referenced characterId")],
+        character_id: Annotated[StrictInt, Field(description="The referenced characterId")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[str]:
+    ) -> ApiResponse[int]:
         """Clone Character
 
         Enter the characterId, generate a new record, the content is basically the same as the original character, but the following fields are different: - Version number is 1 - Visibility is private - The parent character is the source characterId - The creation time is the current moment. - All statistical indicators are zeroed.  Return the new characterId. 
 
         :param character_id: The referenced characterId (required)
-        :type character_id: str
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1021,16 +993,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1038,15 +1009,15 @@
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
     def clone_character_without_preload_content(
         self,
-        character_id: Annotated[StrictStr, Field(description="The referenced characterId")],
+        character_id: Annotated[StrictInt, Field(description="The referenced characterId")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
@@ -1057,15 +1028,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
         """Clone Character
 
         Enter the characterId, generate a new record, the content is basically the same as the original character, but the following fields are different: - Version number is 1 - Visibility is private - The parent character is the source characterId - The creation time is the current moment. - All statistical indicators are zeroed.  Return the new characterId. 
 
         :param character_id: The referenced characterId (required)
-        :type character_id: str
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1089,16 +1060,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -1106,42 +1076,41 @@
     def _clone_character_serialize(
         self,
         character_id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if character_id is not None:
             _path_params['characterId'] = character_id
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
-                'text/plain'
+                'application/json'
             ]
         )
 
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
@@ -1215,16 +1184,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1283,16 +1251,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1351,16 +1318,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -1368,27 +1334,26 @@
     def _count_characters_serialize(
         self,
         character_query_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
@@ -1452,15 +1417,15 @@
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> str:
+    ) -> int:
         """Create Character
 
         Create a character.
 
         :param character_create_dto: Information of the character to be created (required)
         :type character_create_dto: CharacterCreateDTO
         :param _request_timeout: timeout setting for this request. If one
@@ -1490,16 +1455,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1520,15 +1484,15 @@
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[str]:
+    ) -> ApiResponse[int]:
         """Create Character
 
         Create a character.
 
         :param character_create_dto: Information of the character to be created (required)
         :type character_create_dto: CharacterCreateDTO
         :param _request_timeout: timeout setting for this request. If one
@@ -1558,16 +1522,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1626,16 +1589,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -1643,42 +1605,41 @@
     def _create_character_serialize(
         self,
         character_create_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
         if character_create_dto is not None:
             _body_params = character_create_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
-                'text/plain'
+                'application/json'
             ]
         )
 
         # set the HTTP header `Content-Type`
         if _content_type:
             _header_params['Content-Type'] = _content_type
         else:
@@ -1714,15 +1675,15 @@
 
 
 
 
     @validate_call
     def delete_character(
         self,
-        character_id: Annotated[StrictStr, Field(description="The characterId to be deleted")],
+        character_id: Annotated[StrictInt, Field(description="The characterId to be deleted")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
@@ -1733,15 +1694,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> bool:
         """Delete Character
 
         Delete character. Returns success or failure.
 
         :param character_id: The characterId to be deleted (required)
-        :type character_id: str
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1765,16 +1726,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1782,15 +1742,15 @@
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
     def delete_character_with_http_info(
         self,
-        character_id: Annotated[StrictStr, Field(description="The characterId to be deleted")],
+        character_id: Annotated[StrictInt, Field(description="The characterId to be deleted")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
@@ -1801,15 +1761,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[bool]:
         """Delete Character
 
         Delete character. Returns success or failure.
 
         :param character_id: The characterId to be deleted (required)
-        :type character_id: str
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1833,16 +1793,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1850,15 +1809,15 @@
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
     def delete_character_without_preload_content(
         self,
-        character_id: Annotated[StrictStr, Field(description="The characterId to be deleted")],
+        character_id: Annotated[StrictInt, Field(description="The characterId to be deleted")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
@@ -1869,15 +1828,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
         """Delete Character
 
         Delete character. Returns success or failure.
 
         :param character_id: The characterId to be deleted (required)
-        :type character_id: str
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1901,16 +1860,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -1918,27 +1876,26 @@
     def _delete_character_serialize(
         self,
         character_id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if character_id is not None:
             _path_params['characterId'] = character_id
         # process the query parameters
         # process the header parameters
@@ -1974,36 +1931,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def delete_chat(
+    def delete_character_by_name(
         self,
-        chat_id: Annotated[StrictStr, Field(description="Chat session identifier")],
+        name: Annotated[StrictStr, Field(description="The character name to be deleted")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> bool:
-        """Delete Chat Session
+    ) -> List[int]:
+        """Delete Character by Name
 
-        Delete the chat session.
+        Delete character by name. return the list of successfully deleted characterIds.
 
-        :param chat_id: Chat session identifier (required)
-        :type chat_id: str
+        :param name: The character name to be deleted (required)
+        :type name: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2018,60 +1975,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_chat_serialize(
-            chat_id=chat_id,
+        _param = self._delete_character_by_name_serialize(
+            name=name,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "List[int]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def delete_chat_with_http_info(
+    def delete_character_by_name_with_http_info(
         self,
-        chat_id: Annotated[StrictStr, Field(description="Chat session identifier")],
+        name: Annotated[StrictStr, Field(description="The character name to be deleted")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[bool]:
-        """Delete Chat Session
+    ) -> ApiResponse[List[int]]:
+        """Delete Character by Name
 
-        Delete the chat session.
+        Delete character by name. return the list of successfully deleted characterIds.
 
-        :param chat_id: Chat session identifier (required)
-        :type chat_id: str
+        :param name: The character name to be deleted (required)
+        :type name: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2086,60 +2042,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_chat_serialize(
-            chat_id=chat_id,
+        _param = self._delete_character_by_name_serialize(
+            name=name,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "List[int]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def delete_chat_without_preload_content(
+    def delete_character_by_name_without_preload_content(
         self,
-        chat_id: Annotated[StrictStr, Field(description="Chat session identifier")],
+        name: Annotated[StrictStr, Field(description="The character name to be deleted")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Delete Chat Session
+        """Delete Character by Name
 
-        Delete the chat session.
+        Delete character by name. return the list of successfully deleted characterIds.
 
-        :param chat_id: Chat session identifier (required)
-        :type chat_id: str
+        :param name: The character name to be deleted (required)
+        :type name: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2154,58 +2109,56 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_chat_serialize(
-            chat_id=chat_id,
+        _param = self._delete_character_by_name_serialize(
+            name=name,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "List[int]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _delete_chat_serialize(
+    def _delete_character_by_name_serialize(
         self,
-        chat_id,
+        name,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if chat_id is not None:
-            _path_params['chatId'] = chat_id
+        if name is not None:
+            _path_params['name'] = name
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
@@ -2219,15 +2172,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='DELETE',
-            resource_path='/api/v1/character/chat/{chatId}',
+            resource_path='/api/v1/character/name/{name}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -2236,36 +2189,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def get_character_details(
+    def delete_character_document(
         self,
-        character_id: Annotated[StrictStr, Field(description="CharacterId to be obtained")],
+        key: Annotated[StrictStr, Field(description="Document key")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> CharacterDetailsDTO:
-        """Get Character Details
+    ) -> bool:
+        """Delete Character Document
 
-        Get character detailed information.
+        Delete a document of the character by key.
 
-        :param character_id: CharacterId to be obtained (required)
-        :type character_id: str
+        :param key: Document key (required)
+        :type key: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2280,60 +2233,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_character_details_serialize(
-            character_id=character_id,
+        _param = self._delete_character_document_serialize(
+            key=key,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CharacterDetailsDTO"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def get_character_details_with_http_info(
+    def delete_character_document_with_http_info(
         self,
-        character_id: Annotated[StrictStr, Field(description="CharacterId to be obtained")],
+        key: Annotated[StrictStr, Field(description="Document key")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[CharacterDetailsDTO]:
-        """Get Character Details
+    ) -> ApiResponse[bool]:
+        """Delete Character Document
 
-        Get character detailed information.
+        Delete a document of the character by key.
 
-        :param character_id: CharacterId to be obtained (required)
-        :type character_id: str
+        :param key: Document key (required)
+        :type key: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2348,60 +2300,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_character_details_serialize(
-            character_id=character_id,
+        _param = self._delete_character_document_serialize(
+            key=key,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CharacterDetailsDTO"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def get_character_details_without_preload_content(
+    def delete_character_document_without_preload_content(
         self,
-        character_id: Annotated[StrictStr, Field(description="CharacterId to be obtained")],
+        key: Annotated[StrictStr, Field(description="Document key")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Get Character Details
+        """Delete Character Document
 
-        Get character detailed information.
+        Delete a document of the character by key.
 
-        :param character_id: CharacterId to be obtained (required)
-        :type character_id: str
+        :param key: Document key (required)
+        :type key: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2416,58 +2367,56 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_character_details_serialize(
-            character_id=character_id,
+        _param = self._delete_character_document_serialize(
+            key=key,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CharacterDetailsDTO"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _get_character_details_serialize(
+    def _delete_character_document_serialize(
         self,
-        character_id,
+        key,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if character_id is not None:
-            _path_params['characterId'] = character_id
+        if key is not None:
+            _path_params['key'] = key
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
@@ -2480,16 +2429,16 @@
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
-            method='GET',
-            resource_path='/api/v1/character/details/{characterId}',
+            method='DELETE',
+            resource_path='/api/v1/character/document/{key}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -2498,36 +2447,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def get_character_latest_id_by_name(
+    def delete_character_picture(
         self,
-        name: Annotated[StrictStr, Field(description="Character name")],
+        key: Annotated[StrictStr, Field(description="Image key")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> str:
-        """Get Latest Character Id by Name
+    ) -> bool:
+        """Delete Character Picture
 
-        Get latest characterId by character name.
+        Delete a picture of the character by key.
 
-        :param name: Character name (required)
-        :type name: str
+        :param key: Image key (required)
+        :type key: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2542,60 +2491,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_character_latest_id_by_name_serialize(
-            name=name,
+        _param = self._delete_character_picture_serialize(
+            key=key,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def get_character_latest_id_by_name_with_http_info(
+    def delete_character_picture_with_http_info(
         self,
-        name: Annotated[StrictStr, Field(description="Character name")],
+        key: Annotated[StrictStr, Field(description="Image key")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[str]:
-        """Get Latest Character Id by Name
+    ) -> ApiResponse[bool]:
+        """Delete Character Picture
 
-        Get latest characterId by character name.
+        Delete a picture of the character by key.
 
-        :param name: Character name (required)
-        :type name: str
+        :param key: Image key (required)
+        :type key: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2610,60 +2558,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_character_latest_id_by_name_serialize(
-            name=name,
+        _param = self._delete_character_picture_serialize(
+            key=key,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def get_character_latest_id_by_name_without_preload_content(
+    def delete_character_picture_without_preload_content(
         self,
-        name: Annotated[StrictStr, Field(description="Character name")],
+        key: Annotated[StrictStr, Field(description="Image key")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Get Latest Character Id by Name
+        """Delete Character Picture
 
-        Get latest characterId by character name.
+        Delete a picture of the character by key.
 
-        :param name: Character name (required)
-        :type name: str
+        :param key: Image key (required)
+        :type key: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2678,80 +2625,78 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_character_latest_id_by_name_serialize(
-            name=name,
+        _param = self._delete_character_picture_serialize(
+            key=key,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _get_character_latest_id_by_name_serialize(
+    def _delete_character_picture_serialize(
         self,
-        name,
+        key,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if name is not None:
-            _path_params['name'] = name
+        if key is not None:
+            _path_params['key'] = key
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
-                'text/plain'
+                'application/json'
             ]
         )
 
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/api/v1/character/latest/{name}',
+            method='DELETE',
+            resource_path='/api/v1/character/picture/{key}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -2760,36 +2705,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def get_character_summary(
+    def exists_character_name(
         self,
-        character_id: Annotated[StrictStr, Field(description="CharacterId to be obtained")],
+        name: Annotated[StrictStr, Field(description="Name")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> CharacterSummaryDTO:
-        """Get Character Summary
+    ) -> bool:
+        """Check If Character Name Exists
 
-        Get character summary information.
+        Check if the character name already exists.
 
-        :param character_id: CharacterId to be obtained (required)
-        :type character_id: str
+        :param name: Name (required)
+        :type name: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2804,60 +2749,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_character_summary_serialize(
-            character_id=character_id,
+        _param = self._exists_character_name_serialize(
+            name=name,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CharacterSummaryDTO"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def get_character_summary_with_http_info(
+    def exists_character_name_with_http_info(
         self,
-        character_id: Annotated[StrictStr, Field(description="CharacterId to be obtained")],
+        name: Annotated[StrictStr, Field(description="Name")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[CharacterSummaryDTO]:
-        """Get Character Summary
+    ) -> ApiResponse[bool]:
+        """Check If Character Name Exists
 
-        Get character summary information.
+        Check if the character name already exists.
 
-        :param character_id: CharacterId to be obtained (required)
-        :type character_id: str
+        :param name: Name (required)
+        :type name: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2872,60 +2816,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_character_summary_serialize(
-            character_id=character_id,
+        _param = self._exists_character_name_serialize(
+            name=name,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CharacterSummaryDTO"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def get_character_summary_without_preload_content(
+    def exists_character_name_without_preload_content(
         self,
-        character_id: Annotated[StrictStr, Field(description="CharacterId to be obtained")],
+        name: Annotated[StrictStr, Field(description="Name")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Get Character Summary
+        """Check If Character Name Exists
 
-        Get character summary information.
+        Check if the character name already exists.
 
-        :param character_id: CharacterId to be obtained (required)
-        :type character_id: str
+        :param name: Name (required)
+        :type name: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2940,58 +2883,56 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_character_summary_serialize(
-            character_id=character_id,
+        _param = self._exists_character_name_serialize(
+            name=name,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CharacterSummaryDTO"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _get_character_summary_serialize(
+    def _exists_character_name_serialize(
         self,
-        character_id,
+        name,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if character_id is not None:
-            _path_params['characterId'] = character_id
+        if name is not None:
+            _path_params['name'] = name
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
@@ -3005,15 +2946,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='GET',
-            resource_path='/api/v1/character/summary/{characterId}',
+            resource_path='/api/v1/character/exists/name/{name}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -3022,36 +2963,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def get_default_character_backend(
+    def get_character_details(
         self,
-        character_id: Annotated[StrictStr, Field(description="The characterId to be queried")],
+        character_id: Annotated[StrictInt, Field(description="CharacterId to be obtained")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> CharacterBackendDetailsDTO:
-        """Get Default Character Backend
+    ) -> CharacterDetailsDTO:
+        """Get Character Details
 
-        Get the default backend configuration.
+        Get character detailed information.
 
-        :param character_id: The characterId to be queried (required)
-        :type character_id: str
+        :param character_id: CharacterId to be obtained (required)
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3066,60 +3007,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_default_character_backend_serialize(
+        _param = self._get_character_details_serialize(
             character_id=character_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CharacterBackendDetailsDTO"
-            
+            '200': "CharacterDetailsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def get_default_character_backend_with_http_info(
+    def get_character_details_with_http_info(
         self,
-        character_id: Annotated[StrictStr, Field(description="The characterId to be queried")],
+        character_id: Annotated[StrictInt, Field(description="CharacterId to be obtained")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[CharacterBackendDetailsDTO]:
-        """Get Default Character Backend
+    ) -> ApiResponse[CharacterDetailsDTO]:
+        """Get Character Details
 
-        Get the default backend configuration.
+        Get character detailed information.
 
-        :param character_id: The characterId to be queried (required)
-        :type character_id: str
+        :param character_id: CharacterId to be obtained (required)
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3134,60 +3074,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_default_character_backend_serialize(
+        _param = self._get_character_details_serialize(
             character_id=character_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CharacterBackendDetailsDTO"
-            
+            '200': "CharacterDetailsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def get_default_character_backend_without_preload_content(
+    def get_character_details_without_preload_content(
         self,
-        character_id: Annotated[StrictStr, Field(description="The characterId to be queried")],
+        character_id: Annotated[StrictInt, Field(description="CharacterId to be obtained")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Get Default Character Backend
+        """Get Character Details
 
-        Get the default backend configuration.
+        Get character detailed information.
 
-        :param character_id: The characterId to be queried (required)
-        :type character_id: str
+        :param character_id: CharacterId to be obtained (required)
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3202,53 +3141,51 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_default_character_backend_serialize(
+        _param = self._get_character_details_serialize(
             character_id=character_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CharacterBackendDetailsDTO"
-            
+            '200': "CharacterDetailsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _get_default_character_backend_serialize(
+    def _get_character_details_serialize(
         self,
         character_id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if character_id is not None:
             _path_params['characterId'] = character_id
         # process the query parameters
         # process the header parameters
@@ -3267,15 +3204,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='GET',
-            resource_path='/api/v1/character/backend/default/{characterId}',
+            resource_path='/api/v1/character/details/{characterId}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -3284,36 +3221,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def list_character_backend_ids(
+    def get_character_latest_id_by_name(
         self,
-        character_id: Annotated[StrictStr, Field(description="The characterId to be queried")],
+        name: Annotated[StrictStr, Field(description="Character name")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[str]:
-        """List Character Backend ids
+    ) -> int:
+        """Get Latest Character Id by Name
 
-        List Character Backend identifiers.
+        Get latest characterId by character name.
 
-        :param character_id: The characterId to be queried (required)
-        :type character_id: str
+        :param name: Character name (required)
+        :type name: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3328,60 +3265,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_character_backend_ids_serialize(
-            character_id=character_id,
+        _param = self._get_character_latest_id_by_name_serialize(
+            name=name,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def list_character_backend_ids_with_http_info(
+    def get_character_latest_id_by_name_with_http_info(
         self,
-        character_id: Annotated[StrictStr, Field(description="The characterId to be queried")],
+        name: Annotated[StrictStr, Field(description="Character name")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[str]]:
-        """List Character Backend ids
+    ) -> ApiResponse[int]:
+        """Get Latest Character Id by Name
 
-        List Character Backend identifiers.
+        Get latest characterId by character name.
 
-        :param character_id: The characterId to be queried (required)
-        :type character_id: str
+        :param name: Character name (required)
+        :type name: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3396,60 +3332,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_character_backend_ids_serialize(
-            character_id=character_id,
+        _param = self._get_character_latest_id_by_name_serialize(
+            name=name,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def list_character_backend_ids_without_preload_content(
+    def get_character_latest_id_by_name_without_preload_content(
         self,
-        character_id: Annotated[StrictStr, Field(description="The characterId to be queried")],
+        name: Annotated[StrictStr, Field(description="Character name")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """List Character Backend ids
+        """Get Latest Character Id by Name
 
-        List Character Backend identifiers.
+        Get latest characterId by character name.
 
-        :param character_id: The characterId to be queried (required)
-        :type character_id: str
+        :param name: Character name (required)
+        :type name: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3464,58 +3399,56 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_character_backend_ids_serialize(
-            character_id=character_id,
+        _param = self._get_character_latest_id_by_name_serialize(
+            name=name,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _list_character_backend_ids_serialize(
+    def _get_character_latest_id_by_name_serialize(
         self,
-        character_id,
+        name,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if character_id is not None:
-            _path_params['characterId'] = character_id
+        if name is not None:
+            _path_params['name'] = name
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
@@ -3528,16 +3461,16 @@
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
-            method='GET',
-            resource_path='/api/v1/character/backends/{characterId}',
+            method='POST',
+            resource_path='/api/v1/character/latest/{name}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -3546,36 +3479,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def list_character_versions_by_name(
+    def get_character_summary(
         self,
-        name: Annotated[StrictStr, Field(description="Character name")],
+        character_id: Annotated[StrictInt, Field(description="CharacterId to be obtained")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[CharacterItemForNameDTO]:
-        """List Versions by Character Name
+    ) -> CharacterSummaryDTO:
+        """Get Character Summary
 
-        List the versions and corresponding characterIds by character name.
+        Get character summary information.
 
-        :param name: Character name (required)
-        :type name: str
+        :param character_id: CharacterId to be obtained (required)
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3590,60 +3523,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_character_versions_by_name_serialize(
-            name=name,
+        _param = self._get_character_summary_serialize(
+            character_id=character_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[CharacterItemForNameDTO]"
-            
+            '200': "CharacterSummaryDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def list_character_versions_by_name_with_http_info(
+    def get_character_summary_with_http_info(
         self,
-        name: Annotated[StrictStr, Field(description="Character name")],
+        character_id: Annotated[StrictInt, Field(description="CharacterId to be obtained")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[CharacterItemForNameDTO]]:
-        """List Versions by Character Name
+    ) -> ApiResponse[CharacterSummaryDTO]:
+        """Get Character Summary
 
-        List the versions and corresponding characterIds by character name.
+        Get character summary information.
 
-        :param name: Character name (required)
-        :type name: str
+        :param character_id: CharacterId to be obtained (required)
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3658,60 +3590,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_character_versions_by_name_serialize(
-            name=name,
+        _param = self._get_character_summary_serialize(
+            character_id=character_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[CharacterItemForNameDTO]"
-            
+            '200': "CharacterSummaryDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def list_character_versions_by_name_without_preload_content(
+    def get_character_summary_without_preload_content(
         self,
-        name: Annotated[StrictStr, Field(description="Character name")],
+        character_id: Annotated[StrictInt, Field(description="CharacterId to be obtained")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """List Versions by Character Name
+        """Get Character Summary
 
-        List the versions and corresponding characterIds by character name.
+        Get character summary information.
 
-        :param name: Character name (required)
-        :type name: str
+        :param character_id: CharacterId to be obtained (required)
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3726,58 +3657,56 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_character_versions_by_name_serialize(
-            name=name,
+        _param = self._get_character_summary_serialize(
+            character_id=character_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[CharacterItemForNameDTO]"
-            
+            '200': "CharacterSummaryDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _list_character_versions_by_name_serialize(
+    def _get_character_summary_serialize(
         self,
-        name,
+        character_id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if name is not None:
-            _path_params['name'] = name
+        if character_id is not None:
+            _path_params['characterId'] = character_id
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
@@ -3790,16 +3719,16 @@
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/api/v1/character/versions/{name}',
+            method='GET',
+            resource_path='/api/v1/character/summary/{characterId}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -3808,39 +3737,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def list_messages(
+    def get_default_character_backend(
         self,
-        chat_id: Annotated[StrictStr, Field(description="Chat session identifier")],
-        limit: Annotated[StrictInt, Field(description="Messages limit")],
+        character_id: Annotated[StrictInt, Field(description="The characterId to be queried")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[ChatMessageDTO]:
-        """List Chat Messages
+    ) -> CharacterBackendDetailsDTO:
+        """Get Default Character Backend
 
-        List messages of a chat.
+        Get the default backend configuration.
 
-        :param chat_id: Chat session identifier (required)
-        :type chat_id: str
-        :param limit: Messages limit (required)
-        :type limit: int
+        :param character_id: The characterId to be queried (required)
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3855,64 +3781,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_messages_serialize(
-            chat_id=chat_id,
-            limit=limit,
+        _param = self._get_default_character_backend_serialize(
+            character_id=character_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[ChatMessageDTO]"
-            
+            '200': "CharacterBackendDetailsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def list_messages_with_http_info(
+    def get_default_character_backend_with_http_info(
         self,
-        chat_id: Annotated[StrictStr, Field(description="Chat session identifier")],
-        limit: Annotated[StrictInt, Field(description="Messages limit")],
+        character_id: Annotated[StrictInt, Field(description="The characterId to be queried")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[ChatMessageDTO]]:
-        """List Chat Messages
+    ) -> ApiResponse[CharacterBackendDetailsDTO]:
+        """Get Default Character Backend
 
-        List messages of a chat.
+        Get the default backend configuration.
 
-        :param chat_id: Chat session identifier (required)
-        :type chat_id: str
-        :param limit: Messages limit (required)
-        :type limit: int
+        :param character_id: The characterId to be queried (required)
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3927,64 +3848,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_messages_serialize(
-            chat_id=chat_id,
-            limit=limit,
+        _param = self._get_default_character_backend_serialize(
+            character_id=character_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[ChatMessageDTO]"
-            
+            '200': "CharacterBackendDetailsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def list_messages_without_preload_content(
+    def get_default_character_backend_without_preload_content(
         self,
-        chat_id: Annotated[StrictStr, Field(description="Chat session identifier")],
-        limit: Annotated[StrictInt, Field(description="Messages limit")],
+        character_id: Annotated[StrictInt, Field(description="The characterId to be queried")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """List Chat Messages
+        """Get Default Character Backend
 
-        List messages of a chat.
+        Get the default backend configuration.
 
-        :param chat_id: Chat session identifier (required)
-        :type chat_id: str
-        :param limit: Messages limit (required)
-        :type limit: int
+        :param character_id: The characterId to be queried (required)
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3999,62 +3915,56 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_messages_serialize(
-            chat_id=chat_id,
-            limit=limit,
+        _param = self._get_default_character_backend_serialize(
+            character_id=character_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[ChatMessageDTO]"
-            
+            '200': "CharacterBackendDetailsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _list_messages_serialize(
+    def _get_default_character_backend_serialize(
         self,
-        chat_id,
-        limit,
+        character_id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if chat_id is not None:
-            _path_params['chatId'] = chat_id
-        if limit is not None:
-            _path_params['limit'] = limit
+        if character_id is not None:
+            _path_params['characterId'] = character_id
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
@@ -4068,15 +3978,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='GET',
-            resource_path='/api/v1/character/chat/messages/{chatId}/{limit}',
+            resource_path='/api/v1/character/backend/default/{characterId}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -4085,42 +3995,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def list_messages1(
+    def list_character_backend_ids(
         self,
-        chat_id: Annotated[StrictStr, Field(description="Chat session identifier")],
-        limit: Annotated[StrictInt, Field(description="Messages limit")],
-        offset: Annotated[int, Field(strict=True, ge=0, description="Messages offset (from new to old)")],
+        character_id: Annotated[StrictInt, Field(description="The characterId to be queried")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[ChatMessageDTO]:
-        """List Chat Messages
+    ) -> List[str]:
+        """List Character Backend ids
 
-        List messages of a chat.
+        List character backend identifiers.
 
-        :param chat_id: Chat session identifier (required)
-        :type chat_id: str
-        :param limit: Messages limit (required)
-        :type limit: int
-        :param offset: Messages offset (from new to old) (required)
-        :type offset: int
+        :param character_id: The characterId to be queried (required)
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -4135,68 +4039,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_messages1_serialize(
-            chat_id=chat_id,
-            limit=limit,
-            offset=offset,
+        _param = self._list_character_backend_ids_serialize(
+            character_id=character_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[ChatMessageDTO]"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def list_messages1_with_http_info(
+    def list_character_backend_ids_with_http_info(
         self,
-        chat_id: Annotated[StrictStr, Field(description="Chat session identifier")],
-        limit: Annotated[StrictInt, Field(description="Messages limit")],
-        offset: Annotated[int, Field(strict=True, ge=0, description="Messages offset (from new to old)")],
+        character_id: Annotated[StrictInt, Field(description="The characterId to be queried")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[ChatMessageDTO]]:
-        """List Chat Messages
+    ) -> ApiResponse[List[str]]:
+        """List Character Backend ids
 
-        List messages of a chat.
+        List character backend identifiers.
 
-        :param chat_id: Chat session identifier (required)
-        :type chat_id: str
-        :param limit: Messages limit (required)
-        :type limit: int
-        :param offset: Messages offset (from new to old) (required)
-        :type offset: int
+        :param character_id: The characterId to be queried (required)
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -4211,68 +4106,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_messages1_serialize(
-            chat_id=chat_id,
-            limit=limit,
-            offset=offset,
+        _param = self._list_character_backend_ids_serialize(
+            character_id=character_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[ChatMessageDTO]"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def list_messages1_without_preload_content(
+    def list_character_backend_ids_without_preload_content(
         self,
-        chat_id: Annotated[StrictStr, Field(description="Chat session identifier")],
-        limit: Annotated[StrictInt, Field(description="Messages limit")],
-        offset: Annotated[int, Field(strict=True, ge=0, description="Messages offset (from new to old)")],
+        character_id: Annotated[StrictInt, Field(description="The characterId to be queried")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """List Chat Messages
+        """List Character Backend ids
 
-        List messages of a chat.
+        List character backend identifiers.
 
-        :param chat_id: Chat session identifier (required)
-        :type chat_id: str
-        :param limit: Messages limit (required)
-        :type limit: int
-        :param offset: Messages offset (from new to old) (required)
-        :type offset: int
+        :param character_id: The characterId to be queried (required)
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -4287,66 +4173,56 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_messages1_serialize(
-            chat_id=chat_id,
-            limit=limit,
-            offset=offset,
+        _param = self._list_character_backend_ids_serialize(
+            character_id=character_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[ChatMessageDTO]"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _list_messages1_serialize(
+    def _list_character_backend_ids_serialize(
         self,
-        chat_id,
-        limit,
-        offset,
+        character_id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if chat_id is not None:
-            _path_params['chatId'] = chat_id
-        if limit is not None:
-            _path_params['limit'] = limit
-        if offset is not None:
-            _path_params['offset'] = offset
+        if character_id is not None:
+            _path_params['characterId'] = character_id
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
@@ -4360,15 +4236,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='GET',
-            resource_path='/api/v1/character/chat/messages/{chatId}/{limit}/{offset}',
+            resource_path='/api/v1/character/backend/ids/{characterId}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -4377,36 +4253,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def list_messages2(
+    def list_character_backends(
         self,
-        chat_id: Annotated[StrictStr, Field(description="Chat session identifier")],
+        character_id: Annotated[StrictInt, Field(description="The characterId to be queried")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[ChatMessageDTO]:
-        """List Chat Messages
+    ) -> List[CharacterBackendDetailsDTO]:
+        """List Character Backends
 
-        List messages of a chat.
+        List character backends.
 
-        :param chat_id: Chat session identifier (required)
-        :type chat_id: str
+        :param character_id: The characterId to be queried (required)
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -4421,60 +4297,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_messages2_serialize(
-            chat_id=chat_id,
+        _param = self._list_character_backends_serialize(
+            character_id=character_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[ChatMessageDTO]"
-            
+            '200': "List[CharacterBackendDetailsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def list_messages2_with_http_info(
+    def list_character_backends_with_http_info(
         self,
-        chat_id: Annotated[StrictStr, Field(description="Chat session identifier")],
+        character_id: Annotated[StrictInt, Field(description="The characterId to be queried")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[ChatMessageDTO]]:
-        """List Chat Messages
+    ) -> ApiResponse[List[CharacterBackendDetailsDTO]]:
+        """List Character Backends
 
-        List messages of a chat.
+        List character backends.
 
-        :param chat_id: Chat session identifier (required)
-        :type chat_id: str
+        :param character_id: The characterId to be queried (required)
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -4489,60 +4364,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_messages2_serialize(
-            chat_id=chat_id,
+        _param = self._list_character_backends_serialize(
+            character_id=character_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[ChatMessageDTO]"
-            
+            '200': "List[CharacterBackendDetailsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def list_messages2_without_preload_content(
+    def list_character_backends_without_preload_content(
         self,
-        chat_id: Annotated[StrictStr, Field(description="Chat session identifier")],
+        character_id: Annotated[StrictInt, Field(description="The characterId to be queried")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """List Chat Messages
+        """List Character Backends
 
-        List messages of a chat.
+        List character backends.
 
-        :param chat_id: Chat session identifier (required)
-        :type chat_id: str
+        :param character_id: The characterId to be queried (required)
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -4557,58 +4431,56 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_messages2_serialize(
-            chat_id=chat_id,
+        _param = self._list_character_backends_serialize(
+            character_id=character_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[ChatMessageDTO]"
-            
+            '200': "List[CharacterBackendDetailsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _list_messages2_serialize(
+    def _list_character_backends_serialize(
         self,
-        chat_id,
+        character_id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if chat_id is not None:
-            _path_params['chatId'] = chat_id
+        if character_id is not None:
+            _path_params['characterId'] = character_id
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
@@ -4622,15 +4494,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='GET',
-            resource_path='/api/v1/character/chat/messages/{chatId}',
+            resource_path='/api/v1/character/backends/{characterId}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -4639,36 +4511,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def publish_character(
+    def list_character_documents(
         self,
-        character_id: Annotated[StrictStr, Field(description="The characterId to be published")],
+        character_id: Annotated[StrictInt, Field(description="Character identifier")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> str:
-        """Publish Character
+    ) -> List[str]:
+        """List Character Documents
 
-        Publish character, draft content becomes formal content, version number increases by 1. After successful publication, a new characterId will be generated and returned. You need to specify the visibility for publication.
+        List documents of the character.
 
-        :param character_id: The characterId to be published (required)
-        :type character_id: str
+        :param character_id: Character identifier (required)
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -4683,60 +4555,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._publish_character_serialize(
+        _param = self._list_character_documents_serialize(
             character_id=character_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def publish_character_with_http_info(
+    def list_character_documents_with_http_info(
         self,
-        character_id: Annotated[StrictStr, Field(description="The characterId to be published")],
+        character_id: Annotated[StrictInt, Field(description="Character identifier")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[str]:
-        """Publish Character
+    ) -> ApiResponse[List[str]]:
+        """List Character Documents
 
-        Publish character, draft content becomes formal content, version number increases by 1. After successful publication, a new characterId will be generated and returned. You need to specify the visibility for publication.
+        List documents of the character.
 
-        :param character_id: The characterId to be published (required)
-        :type character_id: str
+        :param character_id: Character identifier (required)
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -4751,60 +4622,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._publish_character_serialize(
+        _param = self._list_character_documents_serialize(
             character_id=character_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def publish_character_without_preload_content(
+    def list_character_documents_without_preload_content(
         self,
-        character_id: Annotated[StrictStr, Field(description="The characterId to be published")],
+        character_id: Annotated[StrictInt, Field(description="Character identifier")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Publish Character
+        """List Character Documents
 
-        Publish character, draft content becomes formal content, version number increases by 1. After successful publication, a new characterId will be generated and returned. You need to specify the visibility for publication.
+        List documents of the character.
 
-        :param character_id: The characterId to be published (required)
-        :type character_id: str
+        :param character_id: Character identifier (required)
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -4819,80 +4689,78 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._publish_character_serialize(
+        _param = self._list_character_documents_serialize(
             character_id=character_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _publish_character_serialize(
+    def _list_character_documents_serialize(
         self,
         character_id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if character_id is not None:
             _path_params['characterId'] = character_id
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
-                'text/plain'
+                'application/json'
             ]
         )
 
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/api/v1/character/publish/{characterId}',
+            method='GET',
+            resource_path='/api/v1/character/documents/{characterId}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -4901,39 +4769,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def publish_character1(
+    def list_character_pictures(
         self,
-        character_id: Annotated[StrictStr, Field(description="The characterId to be published")],
-        visibility: Annotated[StrictStr, Field(description="Visibility: public | private | ...")],
+        character_id: Annotated[StrictInt, Field(description="Character identifier")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> str:
-        """Publish Character
+    ) -> List[str]:
+        """List Character Pictures
 
-        Publish character, draft content becomes formal content, version number increases by 1. After successful publication, a new characterId will be generated and returned. You need to specify the visibility for publication.
+        List pictures of the character.
 
-        :param character_id: The characterId to be published (required)
-        :type character_id: str
-        :param visibility: Visibility: public | private | ... (required)
-        :type visibility: str
+        :param character_id: Character identifier (required)
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -4948,64 +4813,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._publish_character1_serialize(
+        _param = self._list_character_pictures_serialize(
             character_id=character_id,
-            visibility=visibility,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def publish_character1_with_http_info(
+    def list_character_pictures_with_http_info(
         self,
-        character_id: Annotated[StrictStr, Field(description="The characterId to be published")],
-        visibility: Annotated[StrictStr, Field(description="Visibility: public | private | ...")],
+        character_id: Annotated[StrictInt, Field(description="Character identifier")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[str]:
-        """Publish Character
+    ) -> ApiResponse[List[str]]:
+        """List Character Pictures
 
-        Publish character, draft content becomes formal content, version number increases by 1. After successful publication, a new characterId will be generated and returned. You need to specify the visibility for publication.
+        List pictures of the character.
 
-        :param character_id: The characterId to be published (required)
-        :type character_id: str
-        :param visibility: Visibility: public | private | ... (required)
-        :type visibility: str
+        :param character_id: Character identifier (required)
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -5020,64 +4880,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._publish_character1_serialize(
+        _param = self._list_character_pictures_serialize(
             character_id=character_id,
-            visibility=visibility,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def publish_character1_without_preload_content(
+    def list_character_pictures_without_preload_content(
         self,
-        character_id: Annotated[StrictStr, Field(description="The characterId to be published")],
-        visibility: Annotated[StrictStr, Field(description="Visibility: public | private | ...")],
+        character_id: Annotated[StrictInt, Field(description="Character identifier")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Publish Character
+        """List Character Pictures
 
-        Publish character, draft content becomes formal content, version number increases by 1. After successful publication, a new characterId will be generated and returned. You need to specify the visibility for publication.
+        List pictures of the character.
 
-        :param character_id: The characterId to be published (required)
-        :type character_id: str
-        :param visibility: Visibility: public | private | ... (required)
-        :type visibility: str
+        :param character_id: Character identifier (required)
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -5092,84 +4947,78 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._publish_character1_serialize(
+        _param = self._list_character_pictures_serialize(
             character_id=character_id,
-            visibility=visibility,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _publish_character1_serialize(
+    def _list_character_pictures_serialize(
         self,
         character_id,
-        visibility,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if character_id is not None:
             _path_params['characterId'] = character_id
-        if visibility is not None:
-            _path_params['visibility'] = visibility
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
-                'text/plain'
+                'application/json'
             ]
         )
 
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/api/v1/character/publish/{characterId}/{visibility}',
+            method='GET',
+            resource_path='/api/v1/character/pictures/{characterId}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -5178,36 +5027,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def remove_character_backend(
+    def list_character_versions_by_name(
         self,
-        character_backend_id: Annotated[StrictStr, Field(description="The characterBackendId to be removed")],
+        name: Annotated[StrictStr, Field(description="Character name")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> bool:
-        """Remove Character Backend
+    ) -> List[CharacterItemForNameDTO]:
+        """List Versions by Character Name
 
-        Remove a backend configuration.
+        List the versions and corresponding characterIds by character name.
 
-        :param character_backend_id: The characterBackendId to be removed (required)
-        :type character_backend_id: str
+        :param name: Character name (required)
+        :type name: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -5222,60 +5071,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._remove_character_backend_serialize(
-            character_backend_id=character_backend_id,
+        _param = self._list_character_versions_by_name_serialize(
+            name=name,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "List[CharacterItemForNameDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def remove_character_backend_with_http_info(
+    def list_character_versions_by_name_with_http_info(
         self,
-        character_backend_id: Annotated[StrictStr, Field(description="The characterBackendId to be removed")],
+        name: Annotated[StrictStr, Field(description="Character name")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[bool]:
-        """Remove Character Backend
+    ) -> ApiResponse[List[CharacterItemForNameDTO]]:
+        """List Versions by Character Name
 
-        Remove a backend configuration.
+        List the versions and corresponding characterIds by character name.
 
-        :param character_backend_id: The characterBackendId to be removed (required)
-        :type character_backend_id: str
+        :param name: Character name (required)
+        :type name: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -5290,60 +5138,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._remove_character_backend_serialize(
-            character_backend_id=character_backend_id,
+        _param = self._list_character_versions_by_name_serialize(
+            name=name,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "List[CharacterItemForNameDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def remove_character_backend_without_preload_content(
+    def list_character_versions_by_name_without_preload_content(
         self,
-        character_backend_id: Annotated[StrictStr, Field(description="The characterBackendId to be removed")],
+        name: Annotated[StrictStr, Field(description="Character name")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Remove Character Backend
+        """List Versions by Character Name
 
-        Remove a backend configuration.
+        List the versions and corresponding characterIds by character name.
 
-        :param character_backend_id: The characterBackendId to be removed (required)
-        :type character_backend_id: str
+        :param name: Character name (required)
+        :type name: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -5358,58 +5205,56 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._remove_character_backend_serialize(
-            character_backend_id=character_backend_id,
+        _param = self._list_character_versions_by_name_serialize(
+            name=name,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "List[CharacterItemForNameDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _remove_character_backend_serialize(
+    def _list_character_versions_by_name_serialize(
         self,
-        character_backend_id,
+        name,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if character_backend_id is not None:
-            _path_params['characterBackendId'] = character_backend_id
+        if name is not None:
+            _path_params['name'] = name
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
@@ -5422,16 +5267,16 @@
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
-            method='DELETE',
-            resource_path='/api/v1/character/backend/{characterBackendId}',
+            method='POST',
+            resource_path='/api/v1/character/versions/{name}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -5440,36 +5285,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def search_character_details(
+    def new_character_name(
         self,
-        character_query_dto: Annotated[CharacterQueryDTO, Field(description="Query conditions")],
+        desired: Annotated[StrictStr, Field(description="Desired name")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[CharacterDetailsDTO]:
-        """Search Character Details
+    ) -> str:
+        """Create New Character Name
 
-        Same as /api/v1/character/search, but returns detailed information of the character.
+        Create a new character name starting with a desired name.
 
-        :param character_query_dto: Query conditions (required)
-        :type character_query_dto: CharacterQueryDTO
+        :param desired: Desired name (required)
+        :type desired: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -5484,60 +5329,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_character_details_serialize(
-            character_query_dto=character_query_dto,
+        _param = self._new_character_name_serialize(
+            desired=desired,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[CharacterDetailsDTO]"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def search_character_details_with_http_info(
+    def new_character_name_with_http_info(
         self,
-        character_query_dto: Annotated[CharacterQueryDTO, Field(description="Query conditions")],
+        desired: Annotated[StrictStr, Field(description="Desired name")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[CharacterDetailsDTO]]:
-        """Search Character Details
+    ) -> ApiResponse[str]:
+        """Create New Character Name
 
-        Same as /api/v1/character/search, but returns detailed information of the character.
+        Create a new character name starting with a desired name.
 
-        :param character_query_dto: Query conditions (required)
-        :type character_query_dto: CharacterQueryDTO
+        :param desired: Desired name (required)
+        :type desired: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -5552,60 +5396,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_character_details_serialize(
-            character_query_dto=character_query_dto,
+        _param = self._new_character_name_serialize(
+            desired=desired,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[CharacterDetailsDTO]"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def search_character_details_without_preload_content(
+    def new_character_name_without_preload_content(
         self,
-        character_query_dto: Annotated[CharacterQueryDTO, Field(description="Query conditions")],
+        desired: Annotated[StrictStr, Field(description="Desired name")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Search Character Details
+        """Create New Character Name
 
-        Same as /api/v1/character/search, but returns detailed information of the character.
+        Create a new character name starting with a desired name.
 
-        :param character_query_dto: Query conditions (required)
-        :type character_query_dto: CharacterQueryDTO
+        :param desired: Desired name (required)
+        :type desired: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -5620,93 +5463,78 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_character_details_serialize(
-            character_query_dto=character_query_dto,
+        _param = self._new_character_name_serialize(
+            desired=desired,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[CharacterDetailsDTO]"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _search_character_details_serialize(
+    def _new_character_name_serialize(
         self,
-        character_query_dto,
+        desired,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
+        if desired is not None:
+            _path_params['desired'] = desired
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
-        if character_query_dto is not None:
-            _body_params = character_query_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
-                'application/json'
+                'text/plain'
             ]
         )
 
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/api/v1/character/details/search',
+            method='GET',
+            resource_path='/api/v1/character/create/name/{desired}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -5715,36 +5543,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def search_character_summary(
+    def publish_character(
         self,
-        character_query_dto: Annotated[CharacterQueryDTO, Field(description="Query conditions")],
+        character_id: Annotated[StrictInt, Field(description="The characterId to be published")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[CharacterSummaryDTO]:
-        """Search Character Summary
+    ) -> int:
+        """Publish Character
 
-        Search characters: - Specifiable query fields, and relationship:   - Scope: private, public_org or public. Private can only search this account.   - Username: exact match, only valid when searching public, public_org. If not specified, search all users.   - Tags: exact match (support and, or logic).   - Name: left match.   - Language, exact match.   - General: name, description, profile, chat style, experience, fuzzy match, one hit is enough; public scope + all user's general search does not guarantee timeliness. - A certain sorting rule can be specified, such as view count, reference count, rating, time, descending or ascending. - The search result is the character summary content. - Support pagination. 
+        Publish character, draft content becomes formal content, version number increases by 1. After successful publication, a new characterId will be generated and returned. You need to specify the visibility for publication.
 
-        :param character_query_dto: Query conditions (required)
-        :type character_query_dto: CharacterQueryDTO
+        :param character_id: The characterId to be published (required)
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -5759,60 +5587,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_character_summary_serialize(
-            character_query_dto=character_query_dto,
+        _param = self._publish_character_serialize(
+            character_id=character_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[CharacterSummaryDTO]"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def search_character_summary_with_http_info(
+    def publish_character_with_http_info(
         self,
-        character_query_dto: Annotated[CharacterQueryDTO, Field(description="Query conditions")],
+        character_id: Annotated[StrictInt, Field(description="The characterId to be published")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[CharacterSummaryDTO]]:
-        """Search Character Summary
+    ) -> ApiResponse[int]:
+        """Publish Character
 
-        Search characters: - Specifiable query fields, and relationship:   - Scope: private, public_org or public. Private can only search this account.   - Username: exact match, only valid when searching public, public_org. If not specified, search all users.   - Tags: exact match (support and, or logic).   - Name: left match.   - Language, exact match.   - General: name, description, profile, chat style, experience, fuzzy match, one hit is enough; public scope + all user's general search does not guarantee timeliness. - A certain sorting rule can be specified, such as view count, reference count, rating, time, descending or ascending. - The search result is the character summary content. - Support pagination. 
+        Publish character, draft content becomes formal content, version number increases by 1. After successful publication, a new characterId will be generated and returned. You need to specify the visibility for publication.
 
-        :param character_query_dto: Query conditions (required)
-        :type character_query_dto: CharacterQueryDTO
+        :param character_id: The characterId to be published (required)
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -5827,60 +5654,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_character_summary_serialize(
-            character_query_dto=character_query_dto,
+        _param = self._publish_character_serialize(
+            character_id=character_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[CharacterSummaryDTO]"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def search_character_summary_without_preload_content(
+    def publish_character_without_preload_content(
         self,
-        character_query_dto: Annotated[CharacterQueryDTO, Field(description="Query conditions")],
+        character_id: Annotated[StrictInt, Field(description="The characterId to be published")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Search Character Summary
+        """Publish Character
 
-        Search characters: - Specifiable query fields, and relationship:   - Scope: private, public_org or public. Private can only search this account.   - Username: exact match, only valid when searching public, public_org. If not specified, search all users.   - Tags: exact match (support and, or logic).   - Name: left match.   - Language, exact match.   - General: name, description, profile, chat style, experience, fuzzy match, one hit is enough; public scope + all user's general search does not guarantee timeliness. - A certain sorting rule can be specified, such as view count, reference count, rating, time, descending or ascending. - The search result is the character summary content. - Support pagination. 
+        Publish character, draft content becomes formal content, version number increases by 1. After successful publication, a new characterId will be generated and returned. You need to specify the visibility for publication.
 
-        :param character_query_dto: Query conditions (required)
-        :type character_query_dto: CharacterQueryDTO
+        :param character_id: The characterId to be published (required)
+        :type character_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -5895,93 +5721,78 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_character_summary_serialize(
-            character_query_dto=character_query_dto,
+        _param = self._publish_character_serialize(
+            character_id=character_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[CharacterSummaryDTO]"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _search_character_summary_serialize(
+    def _publish_character_serialize(
         self,
-        character_query_dto,
+        character_id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
+        if character_id is not None:
+            _path_params['characterId'] = character_id
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
-        if character_query_dto is not None:
-            _body_params = character_query_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
                 'application/json'
             ]
         )
 
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/character/search',
+            resource_path='/api/v1/character/publish/{characterId}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -5990,39 +5801,39 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def send_message(
+    def publish_character1(
         self,
-        chat_id: Annotated[StrictStr, Field(description="Chat session identifier")],
-        chat_content_dto: Annotated[ChatContentDTO, Field(description="Chat content")],
+        character_id: Annotated[StrictInt, Field(description="The characterId to be published")],
+        visibility: Annotated[StrictStr, Field(description="Visibility: public | private | ...")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> LlmResultDTO:
-        """Send Chat Message
+    ) -> int:
+        """Publish Character
 
-        Send a chat message to character.
+        Publish character, draft content becomes formal content, version number increases by 1. After successful publication, a new characterId will be generated and returned. You need to specify the visibility for publication.
 
-        :param chat_id: Chat session identifier (required)
-        :type chat_id: str
-        :param chat_content_dto: Chat content (required)
-        :type chat_content_dto: ChatContentDTO
+        :param character_id: The characterId to be published (required)
+        :type character_id: int
+        :param visibility: Visibility: public | private | ... (required)
+        :type visibility: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -6037,64 +5848,63 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._send_message_serialize(
-            chat_id=chat_id,
-            chat_content_dto=chat_content_dto,
+        _param = self._publish_character1_serialize(
+            character_id=character_id,
+            visibility=visibility,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "LlmResultDTO"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def send_message_with_http_info(
+    def publish_character1_with_http_info(
         self,
-        chat_id: Annotated[StrictStr, Field(description="Chat session identifier")],
-        chat_content_dto: Annotated[ChatContentDTO, Field(description="Chat content")],
+        character_id: Annotated[StrictInt, Field(description="The characterId to be published")],
+        visibility: Annotated[StrictStr, Field(description="Visibility: public | private | ...")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[LlmResultDTO]:
-        """Send Chat Message
+    ) -> ApiResponse[int]:
+        """Publish Character
 
-        Send a chat message to character.
+        Publish character, draft content becomes formal content, version number increases by 1. After successful publication, a new characterId will be generated and returned. You need to specify the visibility for publication.
 
-        :param chat_id: Chat session identifier (required)
-        :type chat_id: str
-        :param chat_content_dto: Chat content (required)
-        :type chat_content_dto: ChatContentDTO
+        :param character_id: The characterId to be published (required)
+        :type character_id: int
+        :param visibility: Visibility: public | private | ... (required)
+        :type visibility: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -6109,64 +5919,63 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._send_message_serialize(
-            chat_id=chat_id,
-            chat_content_dto=chat_content_dto,
+        _param = self._publish_character1_serialize(
+            character_id=character_id,
+            visibility=visibility,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "LlmResultDTO"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def send_message_without_preload_content(
+    def publish_character1_without_preload_content(
         self,
-        chat_id: Annotated[StrictStr, Field(description="Chat session identifier")],
-        chat_content_dto: Annotated[ChatContentDTO, Field(description="Chat content")],
+        character_id: Annotated[StrictInt, Field(description="The characterId to be published")],
+        visibility: Annotated[StrictStr, Field(description="Visibility: public | private | ...")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Send Chat Message
+        """Publish Character
 
-        Send a chat message to character.
+        Publish character, draft content becomes formal content, version number increases by 1. After successful publication, a new characterId will be generated and returned. You need to specify the visibility for publication.
 
-        :param chat_id: Chat session identifier (required)
-        :type chat_id: str
-        :param chat_content_dto: Chat content (required)
-        :type chat_content_dto: ChatContentDTO
+        :param character_id: The characterId to be published (required)
+        :type character_id: int
+        :param visibility: Visibility: public | private | ... (required)
+        :type visibility: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -6181,97 +5990,82 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._send_message_serialize(
-            chat_id=chat_id,
-            chat_content_dto=chat_content_dto,
+        _param = self._publish_character1_serialize(
+            character_id=character_id,
+            visibility=visibility,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "LlmResultDTO"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _send_message_serialize(
+    def _publish_character1_serialize(
         self,
-        chat_id,
-        chat_content_dto,
+        character_id,
+        visibility,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if chat_id is not None:
-            _path_params['chatId'] = chat_id
+        if character_id is not None:
+            _path_params['characterId'] = character_id
+        if visibility is not None:
+            _path_params['visibility'] = visibility
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
-        if chat_content_dto is not None:
-            _body_params = chat_content_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
                 'application/json'
             ]
         )
 
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/character/chat/send/{chatId}',
+            resource_path='/api/v1/character/publish/{characterId}/{visibility}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -6280,35 +6074,35 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def set_default_character_backend(
+    def remove_character_backend(
         self,
-        character_backend_id: Annotated[StrictStr, Field(description="The characterBackendId to be set to default")],
+        character_backend_id: Annotated[StrictStr, Field(description="The characterBackendId to be removed")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> bool:
-        """Set Default Character Backend
+        """Remove Character Backend
 
-        Set the default backend configuration.
+        Remove a backend configuration.
 
-        :param character_backend_id: The characterBackendId to be set to default (required)
+        :param character_backend_id: The characterBackendId to be removed (required)
         :type character_backend_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
@@ -6324,59 +6118,58 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._set_default_character_backend_serialize(
+        _param = self._remove_character_backend_serialize(
             character_backend_id=character_backend_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def set_default_character_backend_with_http_info(
+    def remove_character_backend_with_http_info(
         self,
-        character_backend_id: Annotated[StrictStr, Field(description="The characterBackendId to be set to default")],
+        character_backend_id: Annotated[StrictStr, Field(description="The characterBackendId to be removed")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[bool]:
-        """Set Default Character Backend
+        """Remove Character Backend
 
-        Set the default backend configuration.
+        Remove a backend configuration.
 
-        :param character_backend_id: The characterBackendId to be set to default (required)
+        :param character_backend_id: The characterBackendId to be removed (required)
         :type character_backend_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
@@ -6392,59 +6185,58 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._set_default_character_backend_serialize(
+        _param = self._remove_character_backend_serialize(
             character_backend_id=character_backend_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def set_default_character_backend_without_preload_content(
+    def remove_character_backend_without_preload_content(
         self,
-        character_backend_id: Annotated[StrictStr, Field(description="The characterBackendId to be set to default")],
+        character_backend_id: Annotated[StrictStr, Field(description="The characterBackendId to be removed")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Set Default Character Backend
+        """Remove Character Backend
 
-        Set the default backend configuration.
+        Remove a backend configuration.
 
-        :param character_backend_id: The characterBackendId to be set to default (required)
+        :param character_backend_id: The characterBackendId to be removed (required)
         :type character_backend_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
@@ -6460,53 +6252,51 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._set_default_character_backend_serialize(
+        _param = self._remove_character_backend_serialize(
             character_backend_id=character_backend_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _set_default_character_backend_serialize(
+    def _remove_character_backend_serialize(
         self,
         character_backend_id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if character_backend_id is not None:
             _path_params['characterBackendId'] = character_backend_id
         # process the query parameters
         # process the header parameters
@@ -6524,16 +6314,16 @@
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
-            method='PUT',
-            resource_path='/api/v1/character/backend/default/{characterBackendId}',
+            method='DELETE',
+            resource_path='/api/v1/character/backend/{characterBackendId}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -6542,36 +6332,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def start_chat(
+    def search_character_details(
         self,
-        chat_create_dto: Annotated[ChatCreateDTO, Field(description="Parameters for starting a chat session")],
+        character_query_dto: Annotated[CharacterQueryDTO, Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> str:
-        """Start Chat Session
+    ) -> List[CharacterDetailsDTO]:
+        """Search Character Details
 
-        Start a chat session.
+        Same as /api/v1/character/search, but returns detailed information of the character.
 
-        :param chat_create_dto: Parameters for starting a chat session (required)
-        :type chat_create_dto: ChatCreateDTO
+        :param character_query_dto: Query conditions (required)
+        :type character_query_dto: CharacterQueryDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -6586,60 +6376,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._start_chat_serialize(
-            chat_create_dto=chat_create_dto,
+        _param = self._search_character_details_serialize(
+            character_query_dto=character_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "List[CharacterDetailsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def start_chat_with_http_info(
+    def search_character_details_with_http_info(
         self,
-        chat_create_dto: Annotated[ChatCreateDTO, Field(description="Parameters for starting a chat session")],
+        character_query_dto: Annotated[CharacterQueryDTO, Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[str]:
-        """Start Chat Session
+    ) -> ApiResponse[List[CharacterDetailsDTO]]:
+        """Search Character Details
 
-        Start a chat session.
+        Same as /api/v1/character/search, but returns detailed information of the character.
 
-        :param chat_create_dto: Parameters for starting a chat session (required)
-        :type chat_create_dto: ChatCreateDTO
+        :param character_query_dto: Query conditions (required)
+        :type character_query_dto: CharacterQueryDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -6654,60 +6443,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._start_chat_serialize(
-            chat_create_dto=chat_create_dto,
+        _param = self._search_character_details_serialize(
+            character_query_dto=character_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "List[CharacterDetailsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def start_chat_without_preload_content(
+    def search_character_details_without_preload_content(
         self,
-        chat_create_dto: Annotated[ChatCreateDTO, Field(description="Parameters for starting a chat session")],
+        character_query_dto: Annotated[CharacterQueryDTO, Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Start Chat Session
+        """Search Character Details
 
-        Start a chat session.
+        Same as /api/v1/character/search, but returns detailed information of the character.
 
-        :param chat_create_dto: Parameters for starting a chat session (required)
-        :type chat_create_dto: ChatCreateDTO
+        :param character_query_dto: Query conditions (required)
+        :type character_query_dto: CharacterQueryDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -6722,68 +6510,66 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._start_chat_serialize(
-            chat_create_dto=chat_create_dto,
+        _param = self._search_character_details_serialize(
+            character_query_dto=character_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "List[CharacterDetailsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _start_chat_serialize(
+    def _search_character_details_serialize(
         self,
-        chat_create_dto,
+        character_query_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
-        if chat_create_dto is not None:
-            _body_params = chat_create_dto
+        if character_query_dto is not None:
+            _body_params = character_query_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
-                'text/plain'
+                'application/json'
             ]
         )
 
         # set the HTTP header `Content-Type`
         if _content_type:
             _header_params['Content-Type'] = _content_type
         else:
@@ -6800,15 +6586,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/character/chat',
+            resource_path='/api/v1/character/details/search',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -6817,39 +6603,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def stream_send_message(
+    def search_character_summary(
         self,
-        chat_id: Annotated[StrictStr, Field(description="Chat session identifier")],
-        chat_content_dto: Annotated[ChatContentDTO, Field(description="Chat content")],
+        character_query_dto: Annotated[CharacterQueryDTO, Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> SseEmitter:
-        """Send Chat Message by Streaming Back
+    ) -> List[CharacterSummaryDTO]:
+        """Search Character Summary
 
-        Refer to /api/v1/chat/send/{chatId}, stream back chunks of the response.
+        Search characters: - Specifiable query fields, and relationship:   - Scope: private, public_org or public. Private can only search this account.   - Username: exact match, only valid when searching public, public_org. If not specified, search all users.   - Tags: exact match (support and, or logic).   - Name: left match.   - Language, exact match.   - General: name, description, profile, chat style, experience, fuzzy match, one hit is enough; public scope + all user's general search does not guarantee timeliness. - A certain sorting rule can be specified, such as view count, reference count, rating, time, descending or ascending. - The search result is the character summary content. - Support pagination. 
 
-        :param chat_id: Chat session identifier (required)
-        :type chat_id: str
-        :param chat_content_dto: Chat content (required)
-        :type chat_content_dto: ChatContentDTO
+        :param character_query_dto: Query conditions (required)
+        :type character_query_dto: CharacterQueryDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -6864,64 +6647,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._stream_send_message_serialize(
-            chat_id=chat_id,
-            chat_content_dto=chat_content_dto,
+        _param = self._search_character_summary_serialize(
+            character_query_dto=character_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SseEmitter"
-            
+            '200': "List[CharacterSummaryDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def stream_send_message_with_http_info(
+    def search_character_summary_with_http_info(
         self,
-        chat_id: Annotated[StrictStr, Field(description="Chat session identifier")],
-        chat_content_dto: Annotated[ChatContentDTO, Field(description="Chat content")],
+        character_query_dto: Annotated[CharacterQueryDTO, Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[SseEmitter]:
-        """Send Chat Message by Streaming Back
+    ) -> ApiResponse[List[CharacterSummaryDTO]]:
+        """Search Character Summary
 
-        Refer to /api/v1/chat/send/{chatId}, stream back chunks of the response.
+        Search characters: - Specifiable query fields, and relationship:   - Scope: private, public_org or public. Private can only search this account.   - Username: exact match, only valid when searching public, public_org. If not specified, search all users.   - Tags: exact match (support and, or logic).   - Name: left match.   - Language, exact match.   - General: name, description, profile, chat style, experience, fuzzy match, one hit is enough; public scope + all user's general search does not guarantee timeliness. - A certain sorting rule can be specified, such as view count, reference count, rating, time, descending or ascending. - The search result is the character summary content. - Support pagination. 
 
-        :param chat_id: Chat session identifier (required)
-        :type chat_id: str
-        :param chat_content_dto: Chat content (required)
-        :type chat_content_dto: ChatContentDTO
+        :param character_query_dto: Query conditions (required)
+        :type character_query_dto: CharacterQueryDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -6936,64 +6714,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._stream_send_message_serialize(
-            chat_id=chat_id,
-            chat_content_dto=chat_content_dto,
+        _param = self._search_character_summary_serialize(
+            character_query_dto=character_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SseEmitter"
-            
+            '200': "List[CharacterSummaryDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def stream_send_message_without_preload_content(
+    def search_character_summary_without_preload_content(
         self,
-        chat_id: Annotated[StrictStr, Field(description="Chat session identifier")],
-        chat_content_dto: Annotated[ChatContentDTO, Field(description="Chat content")],
+        character_query_dto: Annotated[CharacterQueryDTO, Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Send Chat Message by Streaming Back
+        """Search Character Summary
 
-        Refer to /api/v1/chat/send/{chatId}, stream back chunks of the response.
+        Search characters: - Specifiable query fields, and relationship:   - Scope: private, public_org or public. Private can only search this account.   - Username: exact match, only valid when searching public, public_org. If not specified, search all users.   - Tags: exact match (support and, or logic).   - Name: left match.   - Language, exact match.   - General: name, description, profile, chat style, experience, fuzzy match, one hit is enough; public scope + all user's general search does not guarantee timeliness. - A certain sorting rule can be specified, such as view count, reference count, rating, time, descending or ascending. - The search result is the character summary content. - Support pagination. 
 
-        :param chat_id: Chat session identifier (required)
-        :type chat_id: str
-        :param chat_content_dto: Chat content (required)
-        :type chat_content_dto: ChatContentDTO
+        :param character_query_dto: Query conditions (required)
+        :type character_query_dto: CharacterQueryDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -7008,72 +6781,66 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._stream_send_message_serialize(
-            chat_id=chat_id,
-            chat_content_dto=chat_content_dto,
+        _param = self._search_character_summary_serialize(
+            character_query_dto=character_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SseEmitter"
-            
+            '200': "List[CharacterSummaryDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _stream_send_message_serialize(
+    def _search_character_summary_serialize(
         self,
-        chat_id,
-        chat_content_dto,
+        character_query_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if chat_id is not None:
-            _path_params['chatId'] = chat_id
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
-        if chat_content_dto is not None:
-            _body_params = chat_content_dto
+        if character_query_dto is not None:
+            _body_params = character_query_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
-                'text/event-stream'
+                'application/json'
             ]
         )
 
         # set the HTTP header `Content-Type`
         if _content_type:
             _header_params['Content-Type'] = _content_type
         else:
@@ -7090,15 +6857,273 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/character/chat/send/stream/{chatId}',
+            resource_path='/api/v1/character/search',
+            path_params=_path_params,
+            query_params=_query_params,
+            header_params=_header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            auth_settings=_auth_settings,
+            collection_formats=_collection_formats,
+            _host=_host,
+            _request_auth=_request_auth
+        )
+
+
+
+
+    @validate_call
+    def set_default_character_backend(
+        self,
+        character_backend_id: Annotated[StrictStr, Field(description="The characterBackendId to be set to default")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> bool:
+        """Set Default Character Backend
+
+        Set the default backend configuration.
+
+        :param character_backend_id: The characterBackendId to be set to default (required)
+        :type character_backend_id: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._set_default_character_backend_serialize(
+            character_backend_id=character_backend_id,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "bool",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        ).data
+
+
+    @validate_call
+    def set_default_character_backend_with_http_info(
+        self,
+        character_backend_id: Annotated[StrictStr, Field(description="The characterBackendId to be set to default")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> ApiResponse[bool]:
+        """Set Default Character Backend
+
+        Set the default backend configuration.
+
+        :param character_backend_id: The characterBackendId to be set to default (required)
+        :type character_backend_id: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._set_default_character_backend_serialize(
+            character_backend_id=character_backend_id,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "bool",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        )
+
+
+    @validate_call
+    def set_default_character_backend_without_preload_content(
+        self,
+        character_backend_id: Annotated[StrictStr, Field(description="The characterBackendId to be set to default")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> RESTResponseType:
+        """Set Default Character Backend
+
+        Set the default backend configuration.
+
+        :param character_backend_id: The characterBackendId to be set to default (required)
+        :type character_backend_id: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._set_default_character_backend_serialize(
+            character_backend_id=character_backend_id,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "bool",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        return response_data.response
+
+
+    def _set_default_character_backend_serialize(
+        self,
+        character_backend_id,
+        _request_auth,
+        _content_type,
+        _headers,
+        _host_index,
+    ) -> RequestSerialized:
+
+        _host = None
+
+        _collection_formats: Dict[str, str] = {
+        }
+
+        _path_params: Dict[str, str] = {}
+        _query_params: List[Tuple[str, str]] = []
+        _header_params: Dict[str, Optional[str]] = _headers or {}
+        _form_params: List[Tuple[str, str]] = []
+        _files: Dict[str, Union[str, bytes]] = {}
+        _body_params: Optional[bytes] = None
+
+        # process the path parameters
+        if character_backend_id is not None:
+            _path_params['characterBackendId'] = character_backend_id
+        # process the query parameters
+        # process the header parameters
+        # process the form parameters
+        # process the body parameter
+
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            [
+                'application/json'
+            ]
+        )
+
+
+        # authentication setting
+        _auth_settings: List[str] = [
+            'bearerAuth'
+        ]
+
+        return self.api_client.param_serialize(
+            method='PUT',
+            resource_path='/api/v1/character/backend/default/{characterBackendId}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -7109,15 +7134,15 @@
 
 
 
 
     @validate_call
     def update_character(
         self,
-        character_id: Annotated[StrictStr, Field(description="The characterId to be updated")],
+        character_id: Annotated[StrictInt, Field(description="The characterId to be updated")],
         character_update_dto: Annotated[CharacterUpdateDTO, Field(description="The character information to be updated")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -7129,15 +7154,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> bool:
         """Update Character
 
         Update character, refer to /api/v1/character/create, required field: characterId. Returns success or failure.
 
         :param character_id: The characterId to be updated (required)
-        :type character_id: str
+        :type character_id: int
         :param character_update_dto: The character information to be updated (required)
         :type character_update_dto: CharacterUpdateDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
@@ -7164,16 +7189,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -7181,15 +7205,15 @@
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
     def update_character_with_http_info(
         self,
-        character_id: Annotated[StrictStr, Field(description="The characterId to be updated")],
+        character_id: Annotated[StrictInt, Field(description="The characterId to be updated")],
         character_update_dto: Annotated[CharacterUpdateDTO, Field(description="The character information to be updated")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -7201,15 +7225,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[bool]:
         """Update Character
 
         Update character, refer to /api/v1/character/create, required field: characterId. Returns success or failure.
 
         :param character_id: The characterId to be updated (required)
-        :type character_id: str
+        :type character_id: int
         :param character_update_dto: The character information to be updated (required)
         :type character_update_dto: CharacterUpdateDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
@@ -7236,16 +7260,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -7253,15 +7276,15 @@
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
     def update_character_without_preload_content(
         self,
-        character_id: Annotated[StrictStr, Field(description="The characterId to be updated")],
+        character_id: Annotated[StrictInt, Field(description="The characterId to be updated")],
         character_update_dto: Annotated[CharacterUpdateDTO, Field(description="The character information to be updated")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -7273,15 +7296,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
         """Update Character
 
         Update character, refer to /api/v1/character/create, required field: characterId. Returns success or failure.
 
         :param character_id: The characterId to be updated (required)
-        :type character_id: str
+        :type character_id: int
         :param character_update_dto: The character information to be updated (required)
         :type character_update_dto: CharacterUpdateDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
@@ -7308,16 +7331,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -7326,27 +7348,26 @@
         self,
         character_id,
         character_update_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if character_id is not None:
             _path_params['characterId'] = character_id
         # process the query parameters
         # process the header parameters
@@ -7454,16 +7475,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -7526,16 +7546,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -7598,16 +7617,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -7616,27 +7634,26 @@
         self,
         character_backend_id,
         character_backend_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if character_backend_id is not None:
             _path_params['characterBackendId'] = character_backend_id
         # process the query parameters
         # process the header parameters
@@ -7689,14 +7706,15 @@
 
 
 
 
     @validate_call
     def upload_character_avatar(
         self,
+        character_id: Annotated[StrictInt, Field(description="Character identifier")],
         file: Annotated[Union[StrictBytes, StrictStr], Field(description="Character avatar")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -7707,14 +7725,16 @@
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> str:
         """Upload Character Avatar
 
         Upload an avatar of the character.
 
+        :param character_id: Character identifier (required)
+        :type character_id: int
         :param file: Character avatar (required)
         :type file: bytearray
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
@@ -7732,24 +7752,24 @@
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
         _param = self._upload_character_avatar_serialize(
+            character_id=character_id,
             file=file,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -7757,14 +7777,15 @@
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
     def upload_character_avatar_with_http_info(
         self,
+        character_id: Annotated[StrictInt, Field(description="Character identifier")],
         file: Annotated[Union[StrictBytes, StrictStr], Field(description="Character avatar")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -7775,14 +7796,16 @@
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[str]:
         """Upload Character Avatar
 
         Upload an avatar of the character.
 
+        :param character_id: Character identifier (required)
+        :type character_id: int
         :param file: Character avatar (required)
         :type file: bytearray
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
@@ -7800,24 +7823,24 @@
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
         _param = self._upload_character_avatar_serialize(
+            character_id=character_id,
             file=file,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -7825,14 +7848,15 @@
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
     def upload_character_avatar_without_preload_content(
         self,
+        character_id: Annotated[StrictInt, Field(description="Character identifier")],
         file: Annotated[Union[StrictBytes, StrictStr], Field(description="Character avatar")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -7843,14 +7867,16 @@
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
         """Upload Character Avatar
 
         Upload an avatar of the character.
 
+        :param character_id: Character identifier (required)
+        :type character_id: int
         :param file: Character avatar (required)
         :type file: bytearray
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
@@ -7868,55 +7894,343 @@
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
         _param = self._upload_character_avatar_serialize(
+            character_id=character_id,
             file=file,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
     def _upload_character_avatar_serialize(
         self,
+        character_id,
+        file,
+        _request_auth,
+        _content_type,
+        _headers,
+        _host_index,
+    ) -> RequestSerialized:
+
+        _host = None
+
+        _collection_formats: Dict[str, str] = {
+        }
+
+        _path_params: Dict[str, str] = {}
+        _query_params: List[Tuple[str, str]] = []
+        _header_params: Dict[str, Optional[str]] = _headers or {}
+        _form_params: List[Tuple[str, str]] = []
+        _files: Dict[str, Union[str, bytes]] = {}
+        _body_params: Optional[bytes] = None
+
+        # process the path parameters
+        if character_id is not None:
+            _path_params['characterId'] = character_id
+        # process the query parameters
+        # process the header parameters
+        # process the form parameters
+        if file is not None:
+            _files['file'] = file
+        # process the body parameter
+
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            [
+                'text/plain'
+            ]
+        )
+
+        # set the HTTP header `Content-Type`
+        if _content_type:
+            _header_params['Content-Type'] = _content_type
+        else:
+            _default_content_type = (
+                self.api_client.select_header_content_type(
+                    [
+                        'multipart/form-data'
+                    ]
+                )
+            )
+            if _default_content_type is not None:
+                _header_params['Content-Type'] = _default_content_type
+
+        # authentication setting
+        _auth_settings: List[str] = [
+            'bearerAuth'
+        ]
+
+        return self.api_client.param_serialize(
+            method='POST',
+            resource_path='/api/v1/character/avatar/{characterId}',
+            path_params=_path_params,
+            query_params=_query_params,
+            header_params=_header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            auth_settings=_auth_settings,
+            collection_formats=_collection_formats,
+            _host=_host,
+            _request_auth=_request_auth
+        )
+
+
+
+
+    @validate_call
+    def upload_character_document(
+        self,
+        character_id: Annotated[StrictInt, Field(description="Character identifier")],
+        file: Annotated[Union[StrictBytes, StrictStr], Field(description="Character document")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> str:
+        """Upload Character Document
+
+        Upload a document of the character.
+
+        :param character_id: Character identifier (required)
+        :type character_id: int
+        :param file: Character document (required)
+        :type file: bytearray
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._upload_character_document_serialize(
+            character_id=character_id,
+            file=file,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "str",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        ).data
+
+
+    @validate_call
+    def upload_character_document_with_http_info(
+        self,
+        character_id: Annotated[StrictInt, Field(description="Character identifier")],
+        file: Annotated[Union[StrictBytes, StrictStr], Field(description="Character document")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> ApiResponse[str]:
+        """Upload Character Document
+
+        Upload a document of the character.
+
+        :param character_id: Character identifier (required)
+        :type character_id: int
+        :param file: Character document (required)
+        :type file: bytearray
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._upload_character_document_serialize(
+            character_id=character_id,
+            file=file,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "str",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        )
+
+
+    @validate_call
+    def upload_character_document_without_preload_content(
+        self,
+        character_id: Annotated[StrictInt, Field(description="Character identifier")],
+        file: Annotated[Union[StrictBytes, StrictStr], Field(description="Character document")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> RESTResponseType:
+        """Upload Character Document
+
+        Upload a document of the character.
+
+        :param character_id: Character identifier (required)
+        :type character_id: int
+        :param file: Character document (required)
+        :type file: bytearray
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._upload_character_document_serialize(
+            character_id=character_id,
+            file=file,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "str",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        return response_data.response
+
+
+    def _upload_character_document_serialize(
+        self,
+        character_id,
         file,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
+        if character_id is not None:
+            _path_params['characterId'] = character_id
         # process the query parameters
         # process the header parameters
         # process the form parameters
         if file is not None:
             _files['file'] = file
         # process the body parameter
 
@@ -7945,15 +8259,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/character/avatar',
+            resource_path='/api/v1/character/document/{characterId}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -7964,14 +8278,15 @@
 
 
 
 
     @validate_call
     def upload_character_picture(
         self,
+        character_id: Annotated[StrictInt, Field(description="Character identifier")],
         file: Annotated[Union[StrictBytes, StrictStr], Field(description="Character picture")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -7982,14 +8297,16 @@
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> str:
         """Upload Character Picture
 
         Upload a picture of the character.
 
+        :param character_id: Character identifier (required)
+        :type character_id: int
         :param file: Character picture (required)
         :type file: bytearray
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
@@ -8007,24 +8324,24 @@
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
         _param = self._upload_character_picture_serialize(
+            character_id=character_id,
             file=file,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -8032,14 +8349,15 @@
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
     def upload_character_picture_with_http_info(
         self,
+        character_id: Annotated[StrictInt, Field(description="Character identifier")],
         file: Annotated[Union[StrictBytes, StrictStr], Field(description="Character picture")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -8050,14 +8368,16 @@
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[str]:
         """Upload Character Picture
 
         Upload a picture of the character.
 
+        :param character_id: Character identifier (required)
+        :type character_id: int
         :param file: Character picture (required)
         :type file: bytearray
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
@@ -8075,24 +8395,24 @@
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
         _param = self._upload_character_picture_serialize(
+            character_id=character_id,
             file=file,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -8100,14 +8420,15 @@
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
     def upload_character_picture_without_preload_content(
         self,
+        character_id: Annotated[StrictInt, Field(description="Character identifier")],
         file: Annotated[Union[StrictBytes, StrictStr], Field(description="Character picture")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -8118,14 +8439,16 @@
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
         """Upload Character Picture
 
         Upload a picture of the character.
 
+        :param character_id: Character identifier (required)
+        :type character_id: int
         :param file: Character picture (required)
         :type file: bytearray
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
@@ -8143,55 +8466,57 @@
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
         _param = self._upload_character_picture_serialize(
+            character_id=character_id,
             file=file,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
     def _upload_character_picture_serialize(
         self,
+        character_id,
         file,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
+        if character_id is not None:
+            _path_params['characterId'] = character_id
         # process the query parameters
         # process the header parameters
         # process the form parameters
         if file is not None:
             _files['file'] = file
         # process the body parameter
 
@@ -8220,15 +8545,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/character/picture',
+            resource_path='/api/v1/character/picture/{characterId}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## Comparing `freechat-sdk/api/flow_api.py` & `freechat_sdk/api/plugin_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,86 +1,75 @@
 # coding: utf-8
 
 """
     FreeChat OpenAPI Definition
 
-    https://github.com/freechat-fun/freechat
+    # FreeChat: Create Some Friends for Yourself with AI  English | [中文版](https://github.com/freechat-fun/freechat/blob/main/README.zh-CN.md)  ## Introduction Welcome! FreeChat aims to build a cloud-native, robust, and quickly commercializable enterprise-level AI virtual character platform.  ## Features - Primarily uses Java and emphasizes **security, robustness, scalability, traceability, and maintainability**. - oasts **account systems and permission management**, supporting OAuth2 authentication. Introduces the \"organization\" concept and related permission constraint functions. - Extensively employs **distributed technologies and caching** to support **high concurrency** access. - Provides flexible character customization options, supports direct intervention in prompts, and supports **configuring multiple backends for each character**. - **Offers a comprehensive range of Open APIs**, with more than 180 interfaces and provides java/python/typescript SDKs. These interfaces enable easy construction of systems for end-users. - Supports setting **RAG** (Retrieval Augmented Generation) for characters. - Supports **long-term memory** for characters. - Supports setting **quota limits** for characters.  ## System Snapshots  ## Character Design ```mermaid flowchart TD     A(Character) --> B(Profile)     A --> C(Knowledge/RAG)     A --> D(Album)     A --> E(Backend-1)     A --> F(Backend-n...)     E --> G(Message Window)     E --> H(Long Term Memory Settings)     E --> I(Quota Limit)     E --> J(Chat Prompt Task)     E --> K(Greeting Prompt Task)     E --> L(Moderation Settings)     J --> M(Model & Parameters)     J --> N(API Keys)     J --> O(Prompt Refence)     J --> P(Tool Specifications)     O --> Q(Template)     O --> R(Variables)     O --> S(Version)     O --> T(...)     style K stroke-dasharray: 5, 5     style L stroke-dasharray: 5, 5     style P stroke-dasharray: 5, 5 ```  After setting up a unified persona and knowledge for a character, different backends can be configured. For example, different model may be adopted for different users based on cost considerations.  ## How to Play ### Online Website You can visit [freechat.fun](https://freechat.fun) to experience FreeChat. Share your designed AI character!  ### Running in a Kubernetes Cluster FreeChat is dedicated to the principles of cloud-native design. If you have a Kubernetes cluster, you can deploy FreeChat to your environment by following these steps:  1. Put the Kubernetes configuration file in the `configs/helm/` directory, named `kube-private.conf`. 2. Place the Helm configuration file in the same directory, named `values-private.yaml`. Make sure to reference the default `values.yaml` and customize the variables as needed. 3. Switch to the `scripts/` directory. 4. If needed, execute `install-in.sh` to deploy `ingress-nginx` to the Kubernetes cluster. 5. If needed, run `install-cm.sh` to deploy `cert-manager` on the Kubernetes cluster, which automatically issues certificates for domains specified in `ingress.hosts`. 6. Run `install-pvc.sh` to install PersistentVolumeClaim resources.      > By default, FreeChat operates files by accessing the \"local file system.\" You may want to use high-availability distributed storage in the cloud. As a cloud-native-designed system, we recommend interfacing through Kubernetes CSI to avoid individually adapting storage products for each cloud platform. Most cloud service providers offer cloud storage drivers for Kubernetes, with a series of predefined StorageClass resources. Please choose the appropriate configuration according to your actual needs and set it in Helm's `global.storageClass` option.     >      > *In the future, FreeChat may be refactored to use MinIO's APIs directly, as it is now installed in the Kubernetes cluster as a dependency (serving Milvus).*  7. Execute the `install.sh` script to install FreeChat and its dependencies. 8. FreeChat aims to provide Open API services. If you like the interactive experience of [freechat.fun](https://freechat.fun), run `install-web.sh` to deploy the front-end application. 9. Execute `restart.sh` to restart the service. 10. If you modified any Helm configuration files, use `upgrade.sh` to update the corresponding Kubernetes resources. 11. To remove specific resources, run the `uninstall*.sh` script corresponding to the resource you want to uninstall.  As a cloud-native application, the services FreeChat relies on are obtained and deployed to your cluster through the helm repository.  If you prefer cloud services with SLA (Service Level Agreement) guarantees, simply make the relevant settings in `configs/helm/values-private.yaml`: ```yaml bitnami:   mysql:     enabled: false   redis:     enabled: false   milvus:     enabled: false  mysql:   url: <your mysql url>   auth:     rootPassword: <your mysql root password>     username: <your mysql username>     password: <your mysql password for the username>  redis:   url: <your redis url>   auth:     password: <your redis password>   milvus:   url: <your milvus url>   milvus:     auth:       token: <your milvus api-key> ```  With this, FreeChat will not automatically install these services, but rather use the configuration information to connect directly.  ### Running Locally You can also run FreeChat locally. Currently supported on MacOS and Linux (although only tested on MacOS). You need to install the Docker toolset and have a network that can access [Docker Hub](https://hub.docker.com/).  Once ready, enter the `scripts/` directory and run `local-run.sh`, which will download and run the necessary docker containers. After a successful startup, you can access `http://localhost` via a browser to see the locally running freechat.fun. Use `local-run.sh --help` to view the supported options of the script. Good luck!  ### Running in an IDE To run FreeChat in an IDE, you need to start all dependent services first but do not need to run the container for the FreeChat application itself. You can execute the `scripts/local-deps.sh` script to start services like `MySQL`, `Redis`, `Milvus`, etc., locally. Once done, open and debug `freechat-start/src/main/java/fun/freechat/Application.java`。Make sure you have set the following startup parameters: ```shell -Dspring.config.location=classpath:/application.yml,classpath:/application-local.yml \\ -DAPP_HOME=local-data/freechat \\ -Dspring.profiles.active=local ```  ### 使用 SDK #### Java - **Dependency** ```xml <dependency>   <groupId>fun.freechat</groupId>   <artifactId>freechat-sdk</artifactId>   <version>${freechat-sdk.version}</version> </dependency> ```  - **Example** ```java import fun.freechat.client.ApiClient; import fun.freechat.client.ApiException; import fun.freechat.client.Configuration; import fun.freechat.client.api.AccountApi; import fun.freechat.client.auth.ApiKeyAuth; import fun.freechat.client.model.UserDetailsDTO;  public class AccountClientExample {     public static void main(String[] args) {         ApiClient defaultClient = Configuration.getDefaultApiClient();         defaultClient.setBasePath(\"https://freechat.fun\");                  // Configure HTTP bearer authorization: bearerAuth         HttpBearerAuth bearerAuth = (HttpBearerAuth) defaultClient.getAuthentication(\"bearerAuth\");         bearerAuth.setBearerToken(\"FREECHAT_TOKEN\");          AccountApi apiInstance = new AccountApi(defaultClient);         try {             UserDetailsDTO result = apiInstance.getUserDetails();             System.out.println(result);         } catch (ApiException e) {             e.printStackTrace();         }     } } ```  #### Python - **Installation** ```shell pip install freechat-sdk ```  - **Example** ```python import freechat_sdk from freechat_sdk.rest import ApiException from pprint import pprint  # Defining the host is optional and defaults to https://freechat.fun # See configuration.py for a list of all supported configuration parameters. configuration = freechat_sdk.Configuration(     host = \"https://freechat.fun\" )  # Configure Bearer authorization: bearerAuth configuration = freechat_sdk.Configuration(     access_token = os.environ[\"FREECHAT_TOKEN\"] )  # Enter a context with an instance of the API client with freechat_sdk.ApiClient(configuration) as api_client:     # Create an instance of the API class     api_instance = freechat_sdk.AccountApi(api_client)      try:         details = api_instance.get_user_details()         pprint(details)     except ApiException as e:         print(\"Exception when calling AccountClient->get_user_details: %s\\n\" % e) ```  #### TypeScript - **Installation** ```shell npm install freechat-sdk --save ```  - **Example** Refer to [FreeChatApiContext.tsx](https://github.com/freechat-fun/freechat/blob/main/freechat-web/src/contexts/FreeChatApiProvider.tsx)  ## System Dependencies | | Projects | ---- | ---- | Application Framework | [Spring Boot](https://spring.io/projects/spring-boot/) | LLM Framework | [LangChain4j](https://docs.langchain4j.dev/) | Model Providers | [OpenAI](https://platform.openai.com/), [DashScope](https://dashscope.aliyun.com/) | Database Systems | [MySQL](https://www.mysql.com/), [Redis](https://redis.io/), [Milvus](https://milvus.io/) | OpenAPI Tools | [Springdoc-openapi](https://springdoc.org/), [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator), [OpenAPI Explorer](https://github.com/Authress-Engineering/openapi-explorer)  ## Collaboration ### Application Integration The FreeChat system is entirely oriented towards Open APIs. The site [freechat.fun](https://freechat.fun) is developed using its TypeScript SDK and hardly depends on private interfaces. You can use these online interfaces to develop your own applications or sites, making them fit your preferences. Currently, FreeChat is completely free with no paid plans (after all, users use their own API Key to call LLM services).  ### Model Integration FreeChat aims to explore AI virtual character technology with anthropomorphic characteristics. So far, it supports model services from OpenAI and DashScope ([HuggingFace](https://huggingface.co/) is also expected to be supported soon). However, we are more interested in supporting models that are under research and can endow AI with more personality traits. If you are researching this area and hope FreeChat supports your model, please contact us. We look forward to AI technology helping people create their own \"soul mates\" in the future.
 
-    The version of the OpenAPI document: 0.1.0
+    The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
-import io
 import warnings
-
 from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
-
-try:
-    from typing import Annotated
-except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import Field
+from typing import Any, Dict, List, Optional, Tuple, Union
 from typing_extensions import Annotated
-from pydantic import StrictStr
 
+from pydantic import Field, StrictBool, StrictInt
 from typing import List
-
-from freechat-sdk.models.flow_create_dto import FlowCreateDTO
-from freechat-sdk.models.flow_details_dto import FlowDetailsDTO
-from freechat-sdk.models.flow_item_for_name_dto import FlowItemForNameDTO
-from freechat-sdk.models.flow_query_dto import FlowQueryDTO
-from freechat-sdk.models.flow_summary_dto import FlowSummaryDTO
-from freechat-sdk.models.flow_update_dto import FlowUpdateDTO
-
-from freechat-sdk.api_client import ApiClient
-from freechat-sdk.api_response import ApiResponse
-from freechat-sdk.rest import RESTResponseType
+from typing_extensions import Annotated
+from freechat_sdk.models.plugin_create_dto import PluginCreateDTO
+from freechat_sdk.models.plugin_details_dto import PluginDetailsDTO
+from freechat_sdk.models.plugin_query_dto import PluginQueryDTO
+from freechat_sdk.models.plugin_summary_dto import PluginSummaryDTO
+from freechat_sdk.models.plugin_update_dto import PluginUpdateDTO
+
+from freechat_sdk.api_client import ApiClient, RequestSerialized
+from freechat_sdk.api_response import ApiResponse
+from freechat_sdk.rest import RESTResponseType
 
 
-class FlowApi:
+class PluginApi:
     """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     def __init__(self, api_client=None) -> None:
         if api_client is None:
             api_client = ApiClient.get_default()
         self.api_client = api_client
 
 
     @validate_call
-    def batch_search_flow_details(
+    def batch_search_plugin_details(
         self,
-        flow_query_dto: Annotated[List[FlowQueryDTO], Field(description="Query conditions")],
+        plugin_query_dto: Annotated[List[PluginQueryDTO], Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[List[FlowDetailsDTO]]:
-        """Batch Search Flow Details
+    ) -> List[List[PluginDetailsDTO]]:
+        """Batch Search Plugin Details
 
-        Batch call shortcut for /api/v1/flow/details/search.
+        Batch call shortcut for /api/v1/plugin/details/search.
 
-        :param flow_query_dto: Query conditions (required)
-        :type flow_query_dto: List[FlowQueryDTO]
+        :param plugin_query_dto: Query conditions (required)
+        :type plugin_query_dto: List[PluginQueryDTO]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -95,60 +84,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._batch_search_flow_details_serialize(
-            flow_query_dto=flow_query_dto,
+        _param = self._batch_search_plugin_details_serialize(
+            plugin_query_dto=plugin_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[List[FlowDetailsDTO]]"
-            
+            '200': "List[List[PluginDetailsDTO]]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def batch_search_flow_details_with_http_info(
+    def batch_search_plugin_details_with_http_info(
         self,
-        flow_query_dto: Annotated[List[FlowQueryDTO], Field(description="Query conditions")],
+        plugin_query_dto: Annotated[List[PluginQueryDTO], Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[List[FlowDetailsDTO]]]:
-        """Batch Search Flow Details
+    ) -> ApiResponse[List[List[PluginDetailsDTO]]]:
+        """Batch Search Plugin Details
 
-        Batch call shortcut for /api/v1/flow/details/search.
+        Batch call shortcut for /api/v1/plugin/details/search.
 
-        :param flow_query_dto: Query conditions (required)
-        :type flow_query_dto: List[FlowQueryDTO]
+        :param plugin_query_dto: Query conditions (required)
+        :type plugin_query_dto: List[PluginQueryDTO]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -163,60 +151,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._batch_search_flow_details_serialize(
-            flow_query_dto=flow_query_dto,
+        _param = self._batch_search_plugin_details_serialize(
+            plugin_query_dto=plugin_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[List[FlowDetailsDTO]]"
-            
+            '200': "List[List[PluginDetailsDTO]]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def batch_search_flow_details_without_preload_content(
+    def batch_search_plugin_details_without_preload_content(
         self,
-        flow_query_dto: Annotated[List[FlowQueryDTO], Field(description="Query conditions")],
+        plugin_query_dto: Annotated[List[PluginQueryDTO], Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Batch Search Flow Details
+        """Batch Search Plugin Details
 
-        Batch call shortcut for /api/v1/flow/details/search.
+        Batch call shortcut for /api/v1/plugin/details/search.
 
-        :param flow_query_dto: Query conditions (required)
-        :type flow_query_dto: List[FlowQueryDTO]
+        :param plugin_query_dto: Query conditions (required)
+        :type plugin_query_dto: List[PluginQueryDTO]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -231,63 +218,61 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._batch_search_flow_details_serialize(
-            flow_query_dto=flow_query_dto,
+        _param = self._batch_search_plugin_details_serialize(
+            plugin_query_dto=plugin_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[List[FlowDetailsDTO]]"
-            
+            '200': "List[List[PluginDetailsDTO]]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _batch_search_flow_details_serialize(
+    def _batch_search_plugin_details_serialize(
         self,
-        flow_query_dto,
+        plugin_query_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
-            'FlowQueryDTO': '',
+            'PluginQueryDTO': '',
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
-        if flow_query_dto is not None:
-            _body_params = flow_query_dto
+        if plugin_query_dto is not None:
+            _body_params = plugin_query_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
                 'application/json'
             ]
@@ -310,15 +295,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/flow/batch/details/search',
+            resource_path='/api/v1/plugin/batch/details/search',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -327,36 +312,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def batch_search_flow_summary(
+    def batch_search_plugin_summary(
         self,
-        flow_query_dto: Annotated[List[FlowQueryDTO], Field(description="Query conditions")],
+        plugin_query_dto: Annotated[List[PluginQueryDTO], Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[List[FlowSummaryDTO]]:
-        """Batch Search Flow Summaries
+    ) -> List[List[PluginSummaryDTO]]:
+        """Batch Search Plugin Summaries
 
-        Batch call shortcut for /api/v1/flow/search.
+        Batch call shortcut for /api/v1/plugin/search.
 
-        :param flow_query_dto: Query conditions (required)
-        :type flow_query_dto: List[FlowQueryDTO]
+        :param plugin_query_dto: Query conditions (required)
+        :type plugin_query_dto: List[PluginQueryDTO]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -371,60 +356,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._batch_search_flow_summary_serialize(
-            flow_query_dto=flow_query_dto,
+        _param = self._batch_search_plugin_summary_serialize(
+            plugin_query_dto=plugin_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[List[FlowSummaryDTO]]"
-            
+            '200': "List[List[PluginSummaryDTO]]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def batch_search_flow_summary_with_http_info(
+    def batch_search_plugin_summary_with_http_info(
         self,
-        flow_query_dto: Annotated[List[FlowQueryDTO], Field(description="Query conditions")],
+        plugin_query_dto: Annotated[List[PluginQueryDTO], Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[List[FlowSummaryDTO]]]:
-        """Batch Search Flow Summaries
+    ) -> ApiResponse[List[List[PluginSummaryDTO]]]:
+        """Batch Search Plugin Summaries
 
-        Batch call shortcut for /api/v1/flow/search.
+        Batch call shortcut for /api/v1/plugin/search.
 
-        :param flow_query_dto: Query conditions (required)
-        :type flow_query_dto: List[FlowQueryDTO]
+        :param plugin_query_dto: Query conditions (required)
+        :type plugin_query_dto: List[PluginQueryDTO]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -439,60 +423,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._batch_search_flow_summary_serialize(
-            flow_query_dto=flow_query_dto,
+        _param = self._batch_search_plugin_summary_serialize(
+            plugin_query_dto=plugin_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[List[FlowSummaryDTO]]"
-            
+            '200': "List[List[PluginSummaryDTO]]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def batch_search_flow_summary_without_preload_content(
+    def batch_search_plugin_summary_without_preload_content(
         self,
-        flow_query_dto: Annotated[List[FlowQueryDTO], Field(description="Query conditions")],
+        plugin_query_dto: Annotated[List[PluginQueryDTO], Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Batch Search Flow Summaries
+        """Batch Search Plugin Summaries
 
-        Batch call shortcut for /api/v1/flow/search.
+        Batch call shortcut for /api/v1/plugin/search.
 
-        :param flow_query_dto: Query conditions (required)
-        :type flow_query_dto: List[FlowQueryDTO]
+        :param plugin_query_dto: Query conditions (required)
+        :type plugin_query_dto: List[PluginQueryDTO]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -507,63 +490,61 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._batch_search_flow_summary_serialize(
-            flow_query_dto=flow_query_dto,
+        _param = self._batch_search_plugin_summary_serialize(
+            plugin_query_dto=plugin_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[List[FlowSummaryDTO]]"
-            
+            '200': "List[List[PluginSummaryDTO]]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _batch_search_flow_summary_serialize(
+    def _batch_search_plugin_summary_serialize(
         self,
-        flow_query_dto,
+        plugin_query_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
-            'FlowQueryDTO': '',
+            'PluginQueryDTO': '',
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
-        if flow_query_dto is not None:
-            _body_params = flow_query_dto
+        if plugin_query_dto is not None:
+            _body_params = plugin_query_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
                 'application/json'
             ]
@@ -586,277 +567,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/flow/batch/search',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def clone_flow(
-        self,
-        flow_id: Annotated[StrictStr, Field(description="The referenced flowId")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> str:
-        """Clone Flow
-
-        Enter the flowId, generate a new record, the content is basically the same as the original flow, but the following fields are different: - Version number is 1 - Visibility is private - The parent flow is the source flowId - The creation time is the current moment.  - All statistical indicators are zeroed.  Return the new flowId. 
-
-        :param flow_id: The referenced flowId (required)
-        :type flow_id: str
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :type _request_timeout: int, tuple(int, int), optional
-        :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the
-                              authentication in the spec for a single request.
-        :type _request_auth: dict, optional
-        :param _content_type: force content-type for the request.
-        :type _content_type: str, Optional
-        :param _headers: set to override the headers for a single
-                         request; this effectively ignores the headers
-                         in the spec for a single request.
-        :type _headers: dict, optional
-        :param _host_index: set to override the host_index for a single
-                            request; this effectively ignores the host_index
-                            in the spec for a single request.
-        :type _host_index: int, optional
-        :return: Returns the result object.
-        """ # noqa: E501
-
-        _param = self._clone_flow_serialize(
-            flow_id=flow_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def clone_flow_with_http_info(
-        self,
-        flow_id: Annotated[StrictStr, Field(description="The referenced flowId")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[str]:
-        """Clone Flow
-
-        Enter the flowId, generate a new record, the content is basically the same as the original flow, but the following fields are different: - Version number is 1 - Visibility is private - The parent flow is the source flowId - The creation time is the current moment.  - All statistical indicators are zeroed.  Return the new flowId. 
-
-        :param flow_id: The referenced flowId (required)
-        :type flow_id: str
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :type _request_timeout: int, tuple(int, int), optional
-        :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the
-                              authentication in the spec for a single request.
-        :type _request_auth: dict, optional
-        :param _content_type: force content-type for the request.
-        :type _content_type: str, Optional
-        :param _headers: set to override the headers for a single
-                         request; this effectively ignores the headers
-                         in the spec for a single request.
-        :type _headers: dict, optional
-        :param _host_index: set to override the host_index for a single
-                            request; this effectively ignores the host_index
-                            in the spec for a single request.
-        :type _host_index: int, optional
-        :return: Returns the result object.
-        """ # noqa: E501
-
-        _param = self._clone_flow_serialize(
-            flow_id=flow_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def clone_flow_without_preload_content(
-        self,
-        flow_id: Annotated[StrictStr, Field(description="The referenced flowId")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Clone Flow
-
-        Enter the flowId, generate a new record, the content is basically the same as the original flow, but the following fields are different: - Version number is 1 - Visibility is private - The parent flow is the source flowId - The creation time is the current moment.  - All statistical indicators are zeroed.  Return the new flowId. 
-
-        :param flow_id: The referenced flowId (required)
-        :type flow_id: str
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :type _request_timeout: int, tuple(int, int), optional
-        :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the
-                              authentication in the spec for a single request.
-        :type _request_auth: dict, optional
-        :param _content_type: force content-type for the request.
-        :type _content_type: str, Optional
-        :param _headers: set to override the headers for a single
-                         request; this effectively ignores the headers
-                         in the spec for a single request.
-        :type _headers: dict, optional
-        :param _host_index: set to override the host_index for a single
-                            request; this effectively ignores the host_index
-                            in the spec for a single request.
-        :type _host_index: int, optional
-        :return: Returns the result object.
-        """ # noqa: E501
-
-        _param = self._clone_flow_serialize(
-            flow_id=flow_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _clone_flow_serialize(
-        self,
-        flow_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if flow_id is not None:
-            _path_params['flowId'] = flow_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'text/plain'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'bearerAuth'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/api/v1/flow/clone/{flowId}',
+            resource_path='/api/v1/plugin/batch/search',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -865,36 +584,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def clone_flows(
+    def count_plugins(
         self,
-        request_body: Annotated[List[StrictStr], Field(description="List of flow information to be created")],
+        plugin_query_dto: Annotated[PluginQueryDTO, Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[str]:
-        """Batch Clone Flows
+    ) -> int:
+        """Calculate Number of Plugins
 
-        Batch clone multiple flows. Ensure transactionality, return the flowId list after success.
+        Calculate the number of plugins according to the specified query conditions.
 
-        :param request_body: List of flow information to be created (required)
-        :type request_body: List[str]
+        :param plugin_query_dto: Query conditions (required)
+        :type plugin_query_dto: PluginQueryDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -909,60 +628,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._clone_flows_serialize(
-            request_body=request_body,
+        _param = self._count_plugins_serialize(
+            plugin_query_dto=plugin_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def clone_flows_with_http_info(
+    def count_plugins_with_http_info(
         self,
-        request_body: Annotated[List[StrictStr], Field(description="List of flow information to be created")],
+        plugin_query_dto: Annotated[PluginQueryDTO, Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[str]]:
-        """Batch Clone Flows
+    ) -> ApiResponse[int]:
+        """Calculate Number of Plugins
 
-        Batch clone multiple flows. Ensure transactionality, return the flowId list after success.
+        Calculate the number of plugins according to the specified query conditions.
 
-        :param request_body: List of flow information to be created (required)
-        :type request_body: List[str]
+        :param plugin_query_dto: Query conditions (required)
+        :type plugin_query_dto: PluginQueryDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -977,60 +695,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._clone_flows_serialize(
-            request_body=request_body,
+        _param = self._count_plugins_serialize(
+            plugin_query_dto=plugin_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def clone_flows_without_preload_content(
+    def count_plugins_without_preload_content(
         self,
-        request_body: Annotated[List[StrictStr], Field(description="List of flow information to be created")],
+        plugin_query_dto: Annotated[PluginQueryDTO, Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Batch Clone Flows
+        """Calculate Number of Plugins
 
-        Batch clone multiple flows. Ensure transactionality, return the flowId list after success.
+        Calculate the number of plugins according to the specified query conditions.
 
-        :param request_body: List of flow information to be created (required)
-        :type request_body: List[str]
+        :param plugin_query_dto: Query conditions (required)
+        :type plugin_query_dto: PluginQueryDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1045,63 +762,60 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._clone_flows_serialize(
-            request_body=request_body,
+        _param = self._count_plugins_serialize(
+            plugin_query_dto=plugin_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _clone_flows_serialize(
+    def _count_plugins_serialize(
         self,
-        request_body,
+        plugin_query_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
-            'request_body': '',
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
-        if request_body is not None:
-            _body_params = request_body
+        if plugin_query_dto is not None:
+            _body_params = plugin_query_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
                 'application/json'
             ]
@@ -1124,15 +838,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/flow/batch/clone',
+            resource_path='/api/v1/plugin/count',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -1141,36 +855,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def count_flows(
+    def create_plugin(
         self,
-        flow_query_dto: Annotated[FlowQueryDTO, Field(description="Query conditions")],
+        plugin_create_dto: Annotated[PluginCreateDTO, Field(description="Information of the plugin to be created")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> int:
-        """Calculate Number of Flows
+        """Create Plugin
 
-        Calculate the number of flows according to the specified query conditions.
+        Create a plugin, required fields: - Plugin name - Plugin manifestInfo (URL or JSON) - Plugin apiInfo (URL or JSON)  Limitations: - Name: 100 characters - Example: 2000 characters - Tags: 5 
 
-        :param flow_query_dto: Query conditions (required)
-        :type flow_query_dto: FlowQueryDTO
+        :param plugin_create_dto: Information of the plugin to be created (required)
+        :type plugin_create_dto: PluginCreateDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1185,60 +899,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._count_flows_serialize(
-            flow_query_dto=flow_query_dto,
+        _param = self._create_plugin_serialize(
+            plugin_create_dto=plugin_create_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def count_flows_with_http_info(
+    def create_plugin_with_http_info(
         self,
-        flow_query_dto: Annotated[FlowQueryDTO, Field(description="Query conditions")],
+        plugin_create_dto: Annotated[PluginCreateDTO, Field(description="Information of the plugin to be created")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[int]:
-        """Calculate Number of Flows
+        """Create Plugin
 
-        Calculate the number of flows according to the specified query conditions.
+        Create a plugin, required fields: - Plugin name - Plugin manifestInfo (URL or JSON) - Plugin apiInfo (URL or JSON)  Limitations: - Name: 100 characters - Example: 2000 characters - Tags: 5 
 
-        :param flow_query_dto: Query conditions (required)
-        :type flow_query_dto: FlowQueryDTO
+        :param plugin_create_dto: Information of the plugin to be created (required)
+        :type plugin_create_dto: PluginCreateDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1253,60 +966,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._count_flows_serialize(
-            flow_query_dto=flow_query_dto,
+        _param = self._create_plugin_serialize(
+            plugin_create_dto=plugin_create_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def count_flows_without_preload_content(
+    def create_plugin_without_preload_content(
         self,
-        flow_query_dto: Annotated[FlowQueryDTO, Field(description="Query conditions")],
+        plugin_create_dto: Annotated[PluginCreateDTO, Field(description="Information of the plugin to be created")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Calculate Number of Flows
+        """Create Plugin
 
-        Calculate the number of flows according to the specified query conditions.
+        Create a plugin, required fields: - Plugin name - Plugin manifestInfo (URL or JSON) - Plugin apiInfo (URL or JSON)  Limitations: - Name: 100 characters - Example: 2000 characters - Tags: 5 
 
-        :param flow_query_dto: Query conditions (required)
-        :type flow_query_dto: FlowQueryDTO
+        :param plugin_create_dto: Information of the plugin to be created (required)
+        :type plugin_create_dto: PluginCreateDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1321,62 +1033,60 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._count_flows_serialize(
-            flow_query_dto=flow_query_dto,
+        _param = self._create_plugin_serialize(
+            plugin_create_dto=plugin_create_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _count_flows_serialize(
+    def _create_plugin_serialize(
         self,
-        flow_query_dto,
+        plugin_create_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
-        if flow_query_dto is not None:
-            _body_params = flow_query_dto
+        if plugin_create_dto is not None:
+            _body_params = plugin_create_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
                 'application/json'
             ]
@@ -1399,15 +1109,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/flow/count',
+            resource_path='/api/v1/plugin',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -1416,36 +1126,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def create_flow(
+    def create_plugins(
         self,
-        flow_create_dto: Annotated[FlowCreateDTO, Field(description="Information of the flow to be created")],
+        plugin_create_dto: Annotated[List[PluginCreateDTO], Field(description="List of plugin information to be created")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> str:
-        """Create Flow
+    ) -> List[int]:
+        """Batch Create Plugins
 
-        Create a flow, ignore required fields: - Flow name - Flow configuration  Limitations: - Description: 300 characters - Configuration: 2000 characters - Example: 2000 characters - Tags: 5 - Parameters: 10 
+        Batch create multiple plugins. Ensure transactionality, return the pluginId list after success.
 
-        :param flow_create_dto: Information of the flow to be created (required)
-        :type flow_create_dto: FlowCreateDTO
+        :param plugin_create_dto: List of plugin information to be created (required)
+        :type plugin_create_dto: List[PluginCreateDTO]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1460,60 +1170,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_flow_serialize(
-            flow_create_dto=flow_create_dto,
+        _param = self._create_plugins_serialize(
+            plugin_create_dto=plugin_create_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "List[int]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def create_flow_with_http_info(
+    def create_plugins_with_http_info(
         self,
-        flow_create_dto: Annotated[FlowCreateDTO, Field(description="Information of the flow to be created")],
+        plugin_create_dto: Annotated[List[PluginCreateDTO], Field(description="List of plugin information to be created")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[str]:
-        """Create Flow
+    ) -> ApiResponse[List[int]]:
+        """Batch Create Plugins
 
-        Create a flow, ignore required fields: - Flow name - Flow configuration  Limitations: - Description: 300 characters - Configuration: 2000 characters - Example: 2000 characters - Tags: 5 - Parameters: 10 
+        Batch create multiple plugins. Ensure transactionality, return the pluginId list after success.
 
-        :param flow_create_dto: Information of the flow to be created (required)
-        :type flow_create_dto: FlowCreateDTO
+        :param plugin_create_dto: List of plugin information to be created (required)
+        :type plugin_create_dto: List[PluginCreateDTO]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1528,60 +1237,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_flow_serialize(
-            flow_create_dto=flow_create_dto,
+        _param = self._create_plugins_serialize(
+            plugin_create_dto=plugin_create_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "List[int]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def create_flow_without_preload_content(
+    def create_plugins_without_preload_content(
         self,
-        flow_create_dto: Annotated[FlowCreateDTO, Field(description="Information of the flow to be created")],
+        plugin_create_dto: Annotated[List[PluginCreateDTO], Field(description="List of plugin information to be created")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Create Flow
+        """Batch Create Plugins
 
-        Create a flow, ignore required fields: - Flow name - Flow configuration  Limitations: - Description: 300 characters - Configuration: 2000 characters - Example: 2000 characters - Tags: 5 - Parameters: 10 
+        Batch create multiple plugins. Ensure transactionality, return the pluginId list after success.
 
-        :param flow_create_dto: Information of the flow to be created (required)
-        :type flow_create_dto: FlowCreateDTO
+        :param plugin_create_dto: List of plugin information to be created (required)
+        :type plugin_create_dto: List[PluginCreateDTO]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1596,338 +1304,61 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_flow_serialize(
-            flow_create_dto=flow_create_dto,
+        _param = self._create_plugins_serialize(
+            plugin_create_dto=plugin_create_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "List[int]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _create_flow_serialize(
+    def _create_plugins_serialize(
         self,
-        flow_create_dto,
+        plugin_create_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
+            'PluginCreateDTO': '',
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
-        if flow_create_dto is not None:
-            _body_params = flow_create_dto
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'text/plain'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'bearerAuth'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/api/v1/flow',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def create_flows(
-        self,
-        flow_create_dto: Annotated[List[FlowCreateDTO], Field(description="List of flow information to be created")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[str]:
-        """Batch Create Flows
-
-        Batch create multiple flows. Ensure transactionality, return the flowId list after success.
-
-        :param flow_create_dto: List of flow information to be created (required)
-        :type flow_create_dto: List[FlowCreateDTO]
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :type _request_timeout: int, tuple(int, int), optional
-        :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the
-                              authentication in the spec for a single request.
-        :type _request_auth: dict, optional
-        :param _content_type: force content-type for the request.
-        :type _content_type: str, Optional
-        :param _headers: set to override the headers for a single
-                         request; this effectively ignores the headers
-                         in the spec for a single request.
-        :type _headers: dict, optional
-        :param _host_index: set to override the host_index for a single
-                            request; this effectively ignores the host_index
-                            in the spec for a single request.
-        :type _host_index: int, optional
-        :return: Returns the result object.
-        """ # noqa: E501
-
-        _param = self._create_flows_serialize(
-            flow_create_dto=flow_create_dto,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def create_flows_with_http_info(
-        self,
-        flow_create_dto: Annotated[List[FlowCreateDTO], Field(description="List of flow information to be created")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[str]]:
-        """Batch Create Flows
-
-        Batch create multiple flows. Ensure transactionality, return the flowId list after success.
-
-        :param flow_create_dto: List of flow information to be created (required)
-        :type flow_create_dto: List[FlowCreateDTO]
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :type _request_timeout: int, tuple(int, int), optional
-        :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the
-                              authentication in the spec for a single request.
-        :type _request_auth: dict, optional
-        :param _content_type: force content-type for the request.
-        :type _content_type: str, Optional
-        :param _headers: set to override the headers for a single
-                         request; this effectively ignores the headers
-                         in the spec for a single request.
-        :type _headers: dict, optional
-        :param _host_index: set to override the host_index for a single
-                            request; this effectively ignores the host_index
-                            in the spec for a single request.
-        :type _host_index: int, optional
-        :return: Returns the result object.
-        """ # noqa: E501
-
-        _param = self._create_flows_serialize(
-            flow_create_dto=flow_create_dto,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def create_flows_without_preload_content(
-        self,
-        flow_create_dto: Annotated[List[FlowCreateDTO], Field(description="List of flow information to be created")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Batch Create Flows
-
-        Batch create multiple flows. Ensure transactionality, return the flowId list after success.
-
-        :param flow_create_dto: List of flow information to be created (required)
-        :type flow_create_dto: List[FlowCreateDTO]
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :type _request_timeout: int, tuple(int, int), optional
-        :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the
-                              authentication in the spec for a single request.
-        :type _request_auth: dict, optional
-        :param _content_type: force content-type for the request.
-        :type _content_type: str, Optional
-        :param _headers: set to override the headers for a single
-                         request; this effectively ignores the headers
-                         in the spec for a single request.
-        :type _headers: dict, optional
-        :param _host_index: set to override the host_index for a single
-                            request; this effectively ignores the host_index
-                            in the spec for a single request.
-        :type _host_index: int, optional
-        :return: Returns the result object.
-        """ # noqa: E501
-
-        _param = self._create_flows_serialize(
-            flow_create_dto=flow_create_dto,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _create_flows_serialize(
-        self,
-        flow_create_dto,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-            'FlowCreateDTO': '',
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if flow_create_dto is not None:
-            _body_params = flow_create_dto
+        if plugin_create_dto is not None:
+            _body_params = plugin_create_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
                 'application/json'
             ]
@@ -1950,15 +1381,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/flow/batch',
+            resource_path='/api/v1/plugin/batch',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -1967,36 +1398,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def delete_flow(
+    def delete_plugin(
         self,
-        flow_id: Annotated[StrictStr, Field(description="FlowId to be deleted")],
+        plugin_id: Annotated[StrictInt, Field(description="The pluginId to be deleted")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> bool:
-        """Delete Flow
+        """Delete Plugin
 
-        Delete flow. Return success or failure.
+        Delete plugin. Returns success or failure.
 
-        :param flow_id: FlowId to be deleted (required)
-        :type flow_id: str
+        :param plugin_id: The pluginId to be deleted (required)
+        :type plugin_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2011,60 +1442,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_flow_serialize(
-            flow_id=flow_id,
+        _param = self._delete_plugin_serialize(
+            plugin_id=plugin_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def delete_flow_with_http_info(
+    def delete_plugin_with_http_info(
         self,
-        flow_id: Annotated[StrictStr, Field(description="FlowId to be deleted")],
+        plugin_id: Annotated[StrictInt, Field(description="The pluginId to be deleted")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[bool]:
-        """Delete Flow
+        """Delete Plugin
 
-        Delete flow. Return success or failure.
+        Delete plugin. Returns success or failure.
 
-        :param flow_id: FlowId to be deleted (required)
-        :type flow_id: str
+        :param plugin_id: The pluginId to be deleted (required)
+        :type plugin_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2079,60 +1509,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_flow_serialize(
-            flow_id=flow_id,
+        _param = self._delete_plugin_serialize(
+            plugin_id=plugin_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def delete_flow_without_preload_content(
+    def delete_plugin_without_preload_content(
         self,
-        flow_id: Annotated[StrictStr, Field(description="FlowId to be deleted")],
+        plugin_id: Annotated[StrictInt, Field(description="The pluginId to be deleted")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Delete Flow
+        """Delete Plugin
 
-        Delete flow. Return success or failure.
+        Delete plugin. Returns success or failure.
 
-        :param flow_id: FlowId to be deleted (required)
-        :type flow_id: str
+        :param plugin_id: The pluginId to be deleted (required)
+        :type plugin_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2147,58 +1576,56 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_flow_serialize(
-            flow_id=flow_id,
+        _param = self._delete_plugin_serialize(
+            plugin_id=plugin_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _delete_flow_serialize(
+    def _delete_plugin_serialize(
         self,
-        flow_id,
+        plugin_id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if flow_id is not None:
-            _path_params['flowId'] = flow_id
+        if plugin_id is not None:
+            _path_params['pluginId'] = plugin_id
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
@@ -2212,15 +1639,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='DELETE',
-            resource_path='/api/v1/flow/{flowId}',
+            resource_path='/api/v1/plugin/{pluginId}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -2229,36 +1656,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def delete_flows(
+    def delete_plugins(
         self,
-        request_body: Annotated[List[StrictStr], Field(description="List of flowId to be deleted")],
+        request_body: Annotated[List[StrictInt], Field(description="List of pluginIds to be deleted")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[str]:
-        """Batch Delete Flows
+    ) -> List[int]:
+        """Batch Delete Plugins
 
-        Delete multiple flows. Ensure transactionality, return the list of successfully deleted flowId.
+        Delete multiple plugins. Ensure transactionality, return the list of successfully deleted pluginIds.
 
-        :param request_body: List of flowId to be deleted (required)
-        :type request_body: List[str]
+        :param request_body: List of pluginIds to be deleted (required)
+        :type request_body: List[int]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2273,60 +1700,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_flows_serialize(
+        _param = self._delete_plugins_serialize(
             request_body=request_body,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[int]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def delete_flows_with_http_info(
+    def delete_plugins_with_http_info(
         self,
-        request_body: Annotated[List[StrictStr], Field(description="List of flowId to be deleted")],
+        request_body: Annotated[List[StrictInt], Field(description="List of pluginIds to be deleted")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[str]]:
-        """Batch Delete Flows
+    ) -> ApiResponse[List[int]]:
+        """Batch Delete Plugins
 
-        Delete multiple flows. Ensure transactionality, return the list of successfully deleted flowId.
+        Delete multiple plugins. Ensure transactionality, return the list of successfully deleted pluginIds.
 
-        :param request_body: List of flowId to be deleted (required)
-        :type request_body: List[str]
+        :param request_body: List of pluginIds to be deleted (required)
+        :type request_body: List[int]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2341,60 +1767,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_flows_serialize(
+        _param = self._delete_plugins_serialize(
             request_body=request_body,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[int]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def delete_flows_without_preload_content(
+    def delete_plugins_without_preload_content(
         self,
-        request_body: Annotated[List[StrictStr], Field(description="List of flowId to be deleted")],
+        request_body: Annotated[List[StrictInt], Field(description="List of pluginIds to be deleted")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Batch Delete Flows
+        """Batch Delete Plugins
 
-        Delete multiple flows. Ensure transactionality, return the list of successfully deleted flowId.
+        Delete multiple plugins. Ensure transactionality, return the list of successfully deleted pluginIds.
 
-        :param request_body: List of flowId to be deleted (required)
-        :type request_body: List[str]
+        :param request_body: List of pluginIds to be deleted (required)
+        :type request_body: List[int]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2409,54 +1834,52 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_flows_serialize(
+        _param = self._delete_plugins_serialize(
             request_body=request_body,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[int]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _delete_flows_serialize(
+    def _delete_plugins_serialize(
         self,
         request_body,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
             'request_body': '',
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
@@ -2488,15 +1911,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='DELETE',
-            resource_path='/api/v1/flow/batch/delete',
+            resource_path='/api/v1/plugin/batch',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -2505,36 +1928,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def get_flow_details(
+    def get_plugin_details(
         self,
-        flow_id: Annotated[StrictStr, Field(description="FlowId to be obtained")],
+        plugin_id: Annotated[StrictInt, Field(description="PluginId to be obtained")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> FlowDetailsDTO:
-        """Get Flow Details
+    ) -> PluginDetailsDTO:
+        """Get Plugin Details
 
-        Get flow detailed information.
+        Get plugin detailed information.
 
-        :param flow_id: FlowId to be obtained (required)
-        :type flow_id: str
+        :param plugin_id: PluginId to be obtained (required)
+        :type plugin_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2549,60 +1972,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_flow_details_serialize(
-            flow_id=flow_id,
+        _param = self._get_plugin_details_serialize(
+            plugin_id=plugin_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "FlowDetailsDTO"
-            
+            '200': "PluginDetailsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def get_flow_details_with_http_info(
+    def get_plugin_details_with_http_info(
         self,
-        flow_id: Annotated[StrictStr, Field(description="FlowId to be obtained")],
+        plugin_id: Annotated[StrictInt, Field(description="PluginId to be obtained")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[FlowDetailsDTO]:
-        """Get Flow Details
+    ) -> ApiResponse[PluginDetailsDTO]:
+        """Get Plugin Details
 
-        Get flow detailed information.
+        Get plugin detailed information.
 
-        :param flow_id: FlowId to be obtained (required)
-        :type flow_id: str
+        :param plugin_id: PluginId to be obtained (required)
+        :type plugin_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2617,60 +2039,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_flow_details_serialize(
-            flow_id=flow_id,
+        _param = self._get_plugin_details_serialize(
+            plugin_id=plugin_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "FlowDetailsDTO"
-            
+            '200': "PluginDetailsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def get_flow_details_without_preload_content(
+    def get_plugin_details_without_preload_content(
         self,
-        flow_id: Annotated[StrictStr, Field(description="FlowId to be obtained")],
+        plugin_id: Annotated[StrictInt, Field(description="PluginId to be obtained")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Get Flow Details
+        """Get Plugin Details
 
-        Get flow detailed information.
+        Get plugin detailed information.
 
-        :param flow_id: FlowId to be obtained (required)
-        :type flow_id: str
+        :param plugin_id: PluginId to be obtained (required)
+        :type plugin_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2685,58 +2106,56 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_flow_details_serialize(
-            flow_id=flow_id,
+        _param = self._get_plugin_details_serialize(
+            plugin_id=plugin_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "FlowDetailsDTO"
-            
+            '200': "PluginDetailsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _get_flow_details_serialize(
+    def _get_plugin_details_serialize(
         self,
-        flow_id,
+        plugin_id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if flow_id is not None:
-            _path_params['flowId'] = flow_id
+        if plugin_id is not None:
+            _path_params['pluginId'] = plugin_id
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
@@ -2750,15 +2169,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='GET',
-            resource_path='/api/v1/flow/details/{flowId}',
+            resource_path='/api/v1/plugin/details/{pluginId}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -2767,36 +2186,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def get_flow_summary(
+    def get_plugin_summary(
         self,
-        flow_id: Annotated[StrictStr, Field(description="flowId to be obtained")],
+        plugin_id: Annotated[StrictInt, Field(description="PluginId to be obtained")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> FlowSummaryDTO:
-        """Get Flow Summary
+    ) -> PluginSummaryDTO:
+        """Get Plugin Summary
 
-        Get flow summary information.
+        Get plugin summary information.
 
-        :param flow_id: flowId to be obtained (required)
-        :type flow_id: str
+        :param plugin_id: PluginId to be obtained (required)
+        :type plugin_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2811,60 +2230,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_flow_summary_serialize(
-            flow_id=flow_id,
+        _param = self._get_plugin_summary_serialize(
+            plugin_id=plugin_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "FlowSummaryDTO"
-            
+            '200': "PluginSummaryDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def get_flow_summary_with_http_info(
+    def get_plugin_summary_with_http_info(
         self,
-        flow_id: Annotated[StrictStr, Field(description="flowId to be obtained")],
+        plugin_id: Annotated[StrictInt, Field(description="PluginId to be obtained")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[FlowSummaryDTO]:
-        """Get Flow Summary
+    ) -> ApiResponse[PluginSummaryDTO]:
+        """Get Plugin Summary
 
-        Get flow summary information.
+        Get plugin summary information.
 
-        :param flow_id: flowId to be obtained (required)
-        :type flow_id: str
+        :param plugin_id: PluginId to be obtained (required)
+        :type plugin_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2879,60 +2297,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_flow_summary_serialize(
-            flow_id=flow_id,
+        _param = self._get_plugin_summary_serialize(
+            plugin_id=plugin_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "FlowSummaryDTO"
-            
+            '200': "PluginSummaryDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def get_flow_summary_without_preload_content(
+    def get_plugin_summary_without_preload_content(
         self,
-        flow_id: Annotated[StrictStr, Field(description="flowId to be obtained")],
+        plugin_id: Annotated[StrictInt, Field(description="PluginId to be obtained")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Get Flow Summary
+        """Get Plugin Summary
 
-        Get flow summary information.
+        Get plugin summary information.
 
-        :param flow_id: flowId to be obtained (required)
-        :type flow_id: str
+        :param plugin_id: PluginId to be obtained (required)
+        :type plugin_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2947,58 +2364,56 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_flow_summary_serialize(
-            flow_id=flow_id,
+        _param = self._get_plugin_summary_serialize(
+            plugin_id=plugin_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "FlowSummaryDTO"
-            
+            '200': "PluginSummaryDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _get_flow_summary_serialize(
+    def _get_plugin_summary_serialize(
         self,
-        flow_id,
+        plugin_id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if flow_id is not None:
-            _path_params['flowId'] = flow_id
+        if plugin_id is not None:
+            _path_params['pluginId'] = plugin_id
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
@@ -3012,15 +2427,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='GET',
-            resource_path='/api/v1/flow/summary/{flowId}',
+            resource_path='/api/v1/plugin/summary/{pluginId}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -3029,36 +2444,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def list_flow_versions_by_name(
+    def refresh_plugin_info(
         self,
-        name: Annotated[StrictStr, Field(description="Flow name")],
+        plugin_id: Annotated[StrictInt, Field(description="The pluginId to be fetched")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[FlowItemForNameDTO]:
-        """List Versions by Flow Name
+    ) -> None:
+        """Refresh Plugin Information
 
-        List the versions and corresponding flowIds by flow name.
+        For online manifest, api-docs information provided at the time of entry, this interface can immediately refresh the information in the system cache (default cache time is 1 hour). Generally, there is no need to call, unless you know that the corresponding plugin platform has just updated the interface, and the business side wants to get the latest information immediately, then call this interface to delete the system cache.
 
-        :param name: Flow name (required)
-        :type name: str
+        :param plugin_id: The pluginId to be fetched (required)
+        :type plugin_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3073,60 +2488,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_flow_versions_by_name_serialize(
-            name=name,
+        _param = self._refresh_plugin_info_serialize(
+            plugin_id=plugin_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[FlowItemForNameDTO]"
-            
+            '200': None,
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def list_flow_versions_by_name_with_http_info(
+    def refresh_plugin_info_with_http_info(
         self,
-        name: Annotated[StrictStr, Field(description="Flow name")],
+        plugin_id: Annotated[StrictInt, Field(description="The pluginId to be fetched")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[FlowItemForNameDTO]]:
-        """List Versions by Flow Name
+    ) -> ApiResponse[None]:
+        """Refresh Plugin Information
 
-        List the versions and corresponding flowIds by flow name.
+        For online manifest, api-docs information provided at the time of entry, this interface can immediately refresh the information in the system cache (default cache time is 1 hour). Generally, there is no need to call, unless you know that the corresponding plugin platform has just updated the interface, and the business side wants to get the latest information immediately, then call this interface to delete the system cache.
 
-        :param name: Flow name (required)
-        :type name: str
+        :param plugin_id: The pluginId to be fetched (required)
+        :type plugin_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3141,60 +2555,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_flow_versions_by_name_serialize(
-            name=name,
+        _param = self._refresh_plugin_info_serialize(
+            plugin_id=plugin_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[FlowItemForNameDTO]"
-            
+            '200': None,
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def list_flow_versions_by_name_without_preload_content(
+    def refresh_plugin_info_without_preload_content(
         self,
-        name: Annotated[StrictStr, Field(description="Flow name")],
+        plugin_id: Annotated[StrictInt, Field(description="The pluginId to be fetched")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """List Versions by Flow Name
+        """Refresh Plugin Information
 
-        List the versions and corresponding flowIds by flow name.
+        For online manifest, api-docs information provided at the time of entry, this interface can immediately refresh the information in the system cache (default cache time is 1 hour). Generally, there is no need to call, unless you know that the corresponding plugin platform has just updated the interface, and the business side wants to get the latest information immediately, then call this interface to delete the system cache.
 
-        :param name: Flow name (required)
-        :type name: str
+        :param plugin_id: The pluginId to be fetched (required)
+        :type plugin_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3209,357 +2622,72 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_flow_versions_by_name_serialize(
-            name=name,
+        _param = self._refresh_plugin_info_serialize(
+            plugin_id=plugin_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[FlowItemForNameDTO]"
-            
+            '200': None,
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _list_flow_versions_by_name_serialize(
+    def _refresh_plugin_info_serialize(
         self,
-        name,
+        plugin_id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if name is not None:
-            _path_params['name'] = name
+        if plugin_id is not None:
+            _path_params['pluginId'] = plugin_id
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
 
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/api/v1/flow/versions/{name}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def publish_flow(
-        self,
-        flow_id: Annotated[StrictStr, Field(description="The flowId to be published")],
-        visibility: Annotated[StrictStr, Field(description="Visibility: public | private | ...")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> str:
-        """Publish Flow
-
-        Publish flow, draft content becomes formal content, version number increases by 1. After successful publication, a new flowId will be generated and returned. You need to specify the visibility for publication.
-
-        :param flow_id: The flowId to be published (required)
-        :type flow_id: str
-        :param visibility: Visibility: public | private | ... (required)
-        :type visibility: str
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :type _request_timeout: int, tuple(int, int), optional
-        :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the
-                              authentication in the spec for a single request.
-        :type _request_auth: dict, optional
-        :param _content_type: force content-type for the request.
-        :type _content_type: str, Optional
-        :param _headers: set to override the headers for a single
-                         request; this effectively ignores the headers
-                         in the spec for a single request.
-        :type _headers: dict, optional
-        :param _host_index: set to override the host_index for a single
-                            request; this effectively ignores the host_index
-                            in the spec for a single request.
-        :type _host_index: int, optional
-        :return: Returns the result object.
-        """ # noqa: E501
-
-        _param = self._publish_flow_serialize(
-            flow_id=flow_id,
-            visibility=visibility,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def publish_flow_with_http_info(
-        self,
-        flow_id: Annotated[StrictStr, Field(description="The flowId to be published")],
-        visibility: Annotated[StrictStr, Field(description="Visibility: public | private | ...")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[str]:
-        """Publish Flow
-
-        Publish flow, draft content becomes formal content, version number increases by 1. After successful publication, a new flowId will be generated and returned. You need to specify the visibility for publication.
-
-        :param flow_id: The flowId to be published (required)
-        :type flow_id: str
-        :param visibility: Visibility: public | private | ... (required)
-        :type visibility: str
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :type _request_timeout: int, tuple(int, int), optional
-        :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the
-                              authentication in the spec for a single request.
-        :type _request_auth: dict, optional
-        :param _content_type: force content-type for the request.
-        :type _content_type: str, Optional
-        :param _headers: set to override the headers for a single
-                         request; this effectively ignores the headers
-                         in the spec for a single request.
-        :type _headers: dict, optional
-        :param _host_index: set to override the host_index for a single
-                            request; this effectively ignores the host_index
-                            in the spec for a single request.
-        :type _host_index: int, optional
-        :return: Returns the result object.
-        """ # noqa: E501
-
-        _param = self._publish_flow_serialize(
-            flow_id=flow_id,
-            visibility=visibility,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def publish_flow_without_preload_content(
-        self,
-        flow_id: Annotated[StrictStr, Field(description="The flowId to be published")],
-        visibility: Annotated[StrictStr, Field(description="Visibility: public | private | ...")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Publish Flow
-
-        Publish flow, draft content becomes formal content, version number increases by 1. After successful publication, a new flowId will be generated and returned. You need to specify the visibility for publication.
-
-        :param flow_id: The flowId to be published (required)
-        :type flow_id: str
-        :param visibility: Visibility: public | private | ... (required)
-        :type visibility: str
-        :param _request_timeout: timeout setting for this request. If one
-                                 number provided, it will be total request
-                                 timeout. It can also be a pair (tuple) of
-                                 (connection, read) timeouts.
-        :type _request_timeout: int, tuple(int, int), optional
-        :param _request_auth: set to override the auth_settings for an a single
-                              request; this effectively ignores the
-                              authentication in the spec for a single request.
-        :type _request_auth: dict, optional
-        :param _content_type: force content-type for the request.
-        :type _content_type: str, Optional
-        :param _headers: set to override the headers for a single
-                         request; this effectively ignores the headers
-                         in the spec for a single request.
-        :type _headers: dict, optional
-        :param _host_index: set to override the host_index for a single
-                            request; this effectively ignores the host_index
-                            in the spec for a single request.
-        :type _host_index: int, optional
-        :return: Returns the result object.
-        """ # noqa: E501
-
-        _param = self._publish_flow_serialize(
-            flow_id=flow_id,
-            visibility=visibility,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _publish_flow_serialize(
-        self,
-        flow_id,
-        visibility,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if flow_id is not None:
-            _path_params['flowId'] = flow_id
-        if visibility is not None:
-            _path_params['visibility'] = visibility
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'text/plain'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'bearerAuth'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/api/v1/flow/publish/{flowId}/{visibility}',
+            method='PUT',
+            resource_path='/api/v1/plugin/refresh/{pluginId}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -3568,36 +2696,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def search_flow_details(
+    def search_plugin_details(
         self,
-        flow_query_dto: Annotated[FlowQueryDTO, Field(description="Query conditions")],
+        plugin_query_dto: Annotated[PluginQueryDTO, Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[FlowDetailsDTO]:
-        """Search Flow Details
+    ) -> List[PluginDetailsDTO]:
+        """Search Plugin Details
 
-        Same as /api/v1/flow/search, but returns detailed information of the flow.
+        Same as /api/v1/plugin/search, but returns detailed information of the plugin.
 
-        :param flow_query_dto: Query conditions (required)
-        :type flow_query_dto: FlowQueryDTO
+        :param plugin_query_dto: Query conditions (required)
+        :type plugin_query_dto: PluginQueryDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3612,60 +2740,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_flow_details_serialize(
-            flow_query_dto=flow_query_dto,
+        _param = self._search_plugin_details_serialize(
+            plugin_query_dto=plugin_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[FlowDetailsDTO]"
-            
+            '200': "List[PluginDetailsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def search_flow_details_with_http_info(
+    def search_plugin_details_with_http_info(
         self,
-        flow_query_dto: Annotated[FlowQueryDTO, Field(description="Query conditions")],
+        plugin_query_dto: Annotated[PluginQueryDTO, Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[FlowDetailsDTO]]:
-        """Search Flow Details
+    ) -> ApiResponse[List[PluginDetailsDTO]]:
+        """Search Plugin Details
 
-        Same as /api/v1/flow/search, but returns detailed information of the flow.
+        Same as /api/v1/plugin/search, but returns detailed information of the plugin.
 
-        :param flow_query_dto: Query conditions (required)
-        :type flow_query_dto: FlowQueryDTO
+        :param plugin_query_dto: Query conditions (required)
+        :type plugin_query_dto: PluginQueryDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3680,60 +2807,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_flow_details_serialize(
-            flow_query_dto=flow_query_dto,
+        _param = self._search_plugin_details_serialize(
+            plugin_query_dto=plugin_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[FlowDetailsDTO]"
-            
+            '200': "List[PluginDetailsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def search_flow_details_without_preload_content(
+    def search_plugin_details_without_preload_content(
         self,
-        flow_query_dto: Annotated[FlowQueryDTO, Field(description="Query conditions")],
+        plugin_query_dto: Annotated[PluginQueryDTO, Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Search Flow Details
+        """Search Plugin Details
 
-        Same as /api/v1/flow/search, but returns detailed information of the flow.
+        Same as /api/v1/plugin/search, but returns detailed information of the plugin.
 
-        :param flow_query_dto: Query conditions (required)
-        :type flow_query_dto: FlowQueryDTO
+        :param plugin_query_dto: Query conditions (required)
+        :type plugin_query_dto: PluginQueryDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3748,62 +2874,60 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_flow_details_serialize(
-            flow_query_dto=flow_query_dto,
+        _param = self._search_plugin_details_serialize(
+            plugin_query_dto=plugin_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[FlowDetailsDTO]"
-            
+            '200': "List[PluginDetailsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _search_flow_details_serialize(
+    def _search_plugin_details_serialize(
         self,
-        flow_query_dto,
+        plugin_query_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
-        if flow_query_dto is not None:
-            _body_params = flow_query_dto
+        if plugin_query_dto is not None:
+            _body_params = plugin_query_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
                 'application/json'
             ]
@@ -3826,15 +2950,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/flow/details/search',
+            resource_path='/api/v1/plugin/details/search',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -3843,36 +2967,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def search_flow_summary(
+    def search_plugin_summary(
         self,
-        flow_query_dto: Annotated[FlowQueryDTO, Field(description="Query conditions")],
+        plugin_query_dto: Annotated[PluginQueryDTO, Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[FlowSummaryDTO]:
-        """Search Flow Summary
+    ) -> List[PluginSummaryDTO]:
+        """Search Plugin Summary
 
-        Search flows: - Specifiable query fields, and relationship:   - Scope: private, public_org or public. Private can only search this account.   - Username: exact match, only valid when searching public, public_org. If not specified, search all users.   - Format: exact match, currently supported: langflow   - Tags: exact match (support and, or logic).   - Model type: exact match (support and, or logic).   - Name: left match.   - General: name, description, example, fuzzy match, one hit is enough; public scope + all user's general search does not guarantee timeliness. - A certain sorting rule can be specified, such as view count, reference count, rating, time, descending or ascending. - The search result is the flow summary content. - Support pagination. 
+        Search plugins: - Specifiable query fields, and relationship:   - Scope: private, public_org or public. Private can only search this account.   - Username: exact match, only valid when searching public, public_org. If not specified, search all users.   - Plugin information format: currently supported: dash_scope, open_ai.   - Interface information format: currently supported: openapi_v3.   - Tags: exact match (support and, or logic).   - Model type: exact match (support and, or logic).   - Name: left match.   - Provider: left match.   - General: name, provider information, manifest (real-time pull mode is not currently supported), fuzzy match, one hit is enough; public scope + all user's general search does not guarantee timeliness. - A certain sorting rule can be specified, such as view count, reference count, rating, time, descending or ascending. - The search result is the plugin summary content. - Support pagination. 
 
-        :param flow_query_dto: Query conditions (required)
-        :type flow_query_dto: FlowQueryDTO
+        :param plugin_query_dto: Query conditions (required)
+        :type plugin_query_dto: PluginQueryDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3887,60 +3011,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_flow_summary_serialize(
-            flow_query_dto=flow_query_dto,
+        _param = self._search_plugin_summary_serialize(
+            plugin_query_dto=plugin_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[FlowSummaryDTO]"
-            
+            '200': "List[PluginSummaryDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def search_flow_summary_with_http_info(
+    def search_plugin_summary_with_http_info(
         self,
-        flow_query_dto: Annotated[FlowQueryDTO, Field(description="Query conditions")],
+        plugin_query_dto: Annotated[PluginQueryDTO, Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[FlowSummaryDTO]]:
-        """Search Flow Summary
+    ) -> ApiResponse[List[PluginSummaryDTO]]:
+        """Search Plugin Summary
 
-        Search flows: - Specifiable query fields, and relationship:   - Scope: private, public_org or public. Private can only search this account.   - Username: exact match, only valid when searching public, public_org. If not specified, search all users.   - Format: exact match, currently supported: langflow   - Tags: exact match (support and, or logic).   - Model type: exact match (support and, or logic).   - Name: left match.   - General: name, description, example, fuzzy match, one hit is enough; public scope + all user's general search does not guarantee timeliness. - A certain sorting rule can be specified, such as view count, reference count, rating, time, descending or ascending. - The search result is the flow summary content. - Support pagination. 
+        Search plugins: - Specifiable query fields, and relationship:   - Scope: private, public_org or public. Private can only search this account.   - Username: exact match, only valid when searching public, public_org. If not specified, search all users.   - Plugin information format: currently supported: dash_scope, open_ai.   - Interface information format: currently supported: openapi_v3.   - Tags: exact match (support and, or logic).   - Model type: exact match (support and, or logic).   - Name: left match.   - Provider: left match.   - General: name, provider information, manifest (real-time pull mode is not currently supported), fuzzy match, one hit is enough; public scope + all user's general search does not guarantee timeliness. - A certain sorting rule can be specified, such as view count, reference count, rating, time, descending or ascending. - The search result is the plugin summary content. - Support pagination. 
 
-        :param flow_query_dto: Query conditions (required)
-        :type flow_query_dto: FlowQueryDTO
+        :param plugin_query_dto: Query conditions (required)
+        :type plugin_query_dto: PluginQueryDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3955,60 +3078,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_flow_summary_serialize(
-            flow_query_dto=flow_query_dto,
+        _param = self._search_plugin_summary_serialize(
+            plugin_query_dto=plugin_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[FlowSummaryDTO]"
-            
+            '200': "List[PluginSummaryDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def search_flow_summary_without_preload_content(
+    def search_plugin_summary_without_preload_content(
         self,
-        flow_query_dto: Annotated[FlowQueryDTO, Field(description="Query conditions")],
+        plugin_query_dto: Annotated[PluginQueryDTO, Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Search Flow Summary
+        """Search Plugin Summary
 
-        Search flows: - Specifiable query fields, and relationship:   - Scope: private, public_org or public. Private can only search this account.   - Username: exact match, only valid when searching public, public_org. If not specified, search all users.   - Format: exact match, currently supported: langflow   - Tags: exact match (support and, or logic).   - Model type: exact match (support and, or logic).   - Name: left match.   - General: name, description, example, fuzzy match, one hit is enough; public scope + all user's general search does not guarantee timeliness. - A certain sorting rule can be specified, such as view count, reference count, rating, time, descending or ascending. - The search result is the flow summary content. - Support pagination. 
+        Search plugins: - Specifiable query fields, and relationship:   - Scope: private, public_org or public. Private can only search this account.   - Username: exact match, only valid when searching public, public_org. If not specified, search all users.   - Plugin information format: currently supported: dash_scope, open_ai.   - Interface information format: currently supported: openapi_v3.   - Tags: exact match (support and, or logic).   - Model type: exact match (support and, or logic).   - Name: left match.   - Provider: left match.   - General: name, provider information, manifest (real-time pull mode is not currently supported), fuzzy match, one hit is enough; public scope + all user's general search does not guarantee timeliness. - A certain sorting rule can be specified, such as view count, reference count, rating, time, descending or ascending. - The search result is the plugin summary content. - Support pagination. 
 
-        :param flow_query_dto: Query conditions (required)
-        :type flow_query_dto: FlowQueryDTO
+        :param plugin_query_dto: Query conditions (required)
+        :type plugin_query_dto: PluginQueryDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -4023,62 +3145,60 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_flow_summary_serialize(
-            flow_query_dto=flow_query_dto,
+        _param = self._search_plugin_summary_serialize(
+            plugin_query_dto=plugin_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[FlowSummaryDTO]"
-            
+            '200': "List[PluginSummaryDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _search_flow_summary_serialize(
+    def _search_plugin_summary_serialize(
         self,
-        flow_query_dto,
+        plugin_query_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
-        if flow_query_dto is not None:
-            _body_params = flow_query_dto
+        if plugin_query_dto is not None:
+            _body_params = plugin_query_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
                 'application/json'
             ]
@@ -4101,15 +3221,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/flow/search',
+            resource_path='/api/v1/plugin/search',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -4118,39 +3238,39 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def update_flow(
+    def update_plugin(
         self,
-        flow_id: Annotated[StrictStr, Field(description="FlowId to be updated")],
-        flow_update_dto: Annotated[FlowUpdateDTO, Field(description="Flow information to be updated")],
+        plugin_id: Annotated[StrictInt, Field(description="The pluginId to be updated")],
+        plugin_update_dto: Annotated[PluginUpdateDTO, Field(description="The plugin information to be updated")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> bool:
-        """Update Flow
+        """Update Plugin
 
-        Update flow, refer to /api/v1/flow/create, required field: flowId. Return success or failure.
+        Update plugin, refer to /api/v1/plugin/create, required field: pluginId. Returns success or failure.
 
-        :param flow_id: FlowId to be updated (required)
-        :type flow_id: str
-        :param flow_update_dto: Flow information to be updated (required)
-        :type flow_update_dto: FlowUpdateDTO
+        :param plugin_id: The pluginId to be updated (required)
+        :type plugin_id: int
+        :param plugin_update_dto: The plugin information to be updated (required)
+        :type plugin_update_dto: PluginUpdateDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -4165,64 +3285,63 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_flow_serialize(
-            flow_id=flow_id,
-            flow_update_dto=flow_update_dto,
+        _param = self._update_plugin_serialize(
+            plugin_id=plugin_id,
+            plugin_update_dto=plugin_update_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def update_flow_with_http_info(
+    def update_plugin_with_http_info(
         self,
-        flow_id: Annotated[StrictStr, Field(description="FlowId to be updated")],
-        flow_update_dto: Annotated[FlowUpdateDTO, Field(description="Flow information to be updated")],
+        plugin_id: Annotated[StrictInt, Field(description="The pluginId to be updated")],
+        plugin_update_dto: Annotated[PluginUpdateDTO, Field(description="The plugin information to be updated")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[bool]:
-        """Update Flow
+        """Update Plugin
 
-        Update flow, refer to /api/v1/flow/create, required field: flowId. Return success or failure.
+        Update plugin, refer to /api/v1/plugin/create, required field: pluginId. Returns success or failure.
 
-        :param flow_id: FlowId to be updated (required)
-        :type flow_id: str
-        :param flow_update_dto: Flow information to be updated (required)
-        :type flow_update_dto: FlowUpdateDTO
+        :param plugin_id: The pluginId to be updated (required)
+        :type plugin_id: int
+        :param plugin_update_dto: The plugin information to be updated (required)
+        :type plugin_update_dto: PluginUpdateDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -4237,64 +3356,63 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_flow_serialize(
-            flow_id=flow_id,
-            flow_update_dto=flow_update_dto,
+        _param = self._update_plugin_serialize(
+            plugin_id=plugin_id,
+            plugin_update_dto=plugin_update_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def update_flow_without_preload_content(
+    def update_plugin_without_preload_content(
         self,
-        flow_id: Annotated[StrictStr, Field(description="FlowId to be updated")],
-        flow_update_dto: Annotated[FlowUpdateDTO, Field(description="Flow information to be updated")],
+        plugin_id: Annotated[StrictInt, Field(description="The pluginId to be updated")],
+        plugin_update_dto: Annotated[PluginUpdateDTO, Field(description="The plugin information to be updated")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Update Flow
+        """Update Plugin
 
-        Update flow, refer to /api/v1/flow/create, required field: flowId. Return success or failure.
+        Update plugin, refer to /api/v1/plugin/create, required field: pluginId. Returns success or failure.
 
-        :param flow_id: FlowId to be updated (required)
-        :type flow_id: str
-        :param flow_update_dto: Flow information to be updated (required)
-        :type flow_update_dto: FlowUpdateDTO
+        :param plugin_id: The pluginId to be updated (required)
+        :type plugin_id: int
+        :param plugin_update_dto: The plugin information to be updated (required)
+        :type plugin_update_dto: PluginUpdateDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -4309,66 +3427,64 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_flow_serialize(
-            flow_id=flow_id,
-            flow_update_dto=flow_update_dto,
+        _param = self._update_plugin_serialize(
+            plugin_id=plugin_id,
+            plugin_update_dto=plugin_update_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _update_flow_serialize(
+    def _update_plugin_serialize(
         self,
-        flow_id,
-        flow_update_dto,
+        plugin_id,
+        plugin_update_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if flow_id is not None:
-            _path_params['flowId'] = flow_id
+        if plugin_id is not None:
+            _path_params['pluginId'] = plugin_id
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
-        if flow_update_dto is not None:
-            _body_params = flow_update_dto
+        if plugin_update_dto is not None:
+            _body_params = plugin_update_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
                 'application/json'
             ]
@@ -4391,15 +3507,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='PUT',
-            resource_path='/api/v1/flow/{flowId}',
+            resource_path='/api/v1/plugin/{pluginId}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## Comparing `freechat-sdk/api/interactive_statistics_api.py` & `freechat_sdk/api/interactive_statistics_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,47 +1,38 @@
 # coding: utf-8
 
 """
     FreeChat OpenAPI Definition
 
-    https://github.com/freechat-fun/freechat
+    # FreeChat: Create Some Friends for Yourself with AI  English | [中文版](https://github.com/freechat-fun/freechat/blob/main/README.zh-CN.md)  ## Introduction Welcome! FreeChat aims to build a cloud-native, robust, and quickly commercializable enterprise-level AI virtual character platform.  ## Features - Primarily uses Java and emphasizes **security, robustness, scalability, traceability, and maintainability**. - oasts **account systems and permission management**, supporting OAuth2 authentication. Introduces the \"organization\" concept and related permission constraint functions. - Extensively employs **distributed technologies and caching** to support **high concurrency** access. - Provides flexible character customization options, supports direct intervention in prompts, and supports **configuring multiple backends for each character**. - **Offers a comprehensive range of Open APIs**, with more than 180 interfaces and provides java/python/typescript SDKs. These interfaces enable easy construction of systems for end-users. - Supports setting **RAG** (Retrieval Augmented Generation) for characters. - Supports **long-term memory** for characters. - Supports setting **quota limits** for characters.  ## System Snapshots  ## Character Design ```mermaid flowchart TD     A(Character) --> B(Profile)     A --> C(Knowledge/RAG)     A --> D(Album)     A --> E(Backend-1)     A --> F(Backend-n...)     E --> G(Message Window)     E --> H(Long Term Memory Settings)     E --> I(Quota Limit)     E --> J(Chat Prompt Task)     E --> K(Greeting Prompt Task)     E --> L(Moderation Settings)     J --> M(Model & Parameters)     J --> N(API Keys)     J --> O(Prompt Refence)     J --> P(Tool Specifications)     O --> Q(Template)     O --> R(Variables)     O --> S(Version)     O --> T(...)     style K stroke-dasharray: 5, 5     style L stroke-dasharray: 5, 5     style P stroke-dasharray: 5, 5 ```  After setting up a unified persona and knowledge for a character, different backends can be configured. For example, different model may be adopted for different users based on cost considerations.  ## How to Play ### Online Website You can visit [freechat.fun](https://freechat.fun) to experience FreeChat. Share your designed AI character!  ### Running in a Kubernetes Cluster FreeChat is dedicated to the principles of cloud-native design. If you have a Kubernetes cluster, you can deploy FreeChat to your environment by following these steps:  1. Put the Kubernetes configuration file in the `configs/helm/` directory, named `kube-private.conf`. 2. Place the Helm configuration file in the same directory, named `values-private.yaml`. Make sure to reference the default `values.yaml` and customize the variables as needed. 3. Switch to the `scripts/` directory. 4. If needed, execute `install-in.sh` to deploy `ingress-nginx` to the Kubernetes cluster. 5. If needed, run `install-cm.sh` to deploy `cert-manager` on the Kubernetes cluster, which automatically issues certificates for domains specified in `ingress.hosts`. 6. Run `install-pvc.sh` to install PersistentVolumeClaim resources.      > By default, FreeChat operates files by accessing the \"local file system.\" You may want to use high-availability distributed storage in the cloud. As a cloud-native-designed system, we recommend interfacing through Kubernetes CSI to avoid individually adapting storage products for each cloud platform. Most cloud service providers offer cloud storage drivers for Kubernetes, with a series of predefined StorageClass resources. Please choose the appropriate configuration according to your actual needs and set it in Helm's `global.storageClass` option.     >      > *In the future, FreeChat may be refactored to use MinIO's APIs directly, as it is now installed in the Kubernetes cluster as a dependency (serving Milvus).*  7. Execute the `install.sh` script to install FreeChat and its dependencies. 8. FreeChat aims to provide Open API services. If you like the interactive experience of [freechat.fun](https://freechat.fun), run `install-web.sh` to deploy the front-end application. 9. Execute `restart.sh` to restart the service. 10. If you modified any Helm configuration files, use `upgrade.sh` to update the corresponding Kubernetes resources. 11. To remove specific resources, run the `uninstall*.sh` script corresponding to the resource you want to uninstall.  As a cloud-native application, the services FreeChat relies on are obtained and deployed to your cluster through the helm repository.  If you prefer cloud services with SLA (Service Level Agreement) guarantees, simply make the relevant settings in `configs/helm/values-private.yaml`: ```yaml bitnami:   mysql:     enabled: false   redis:     enabled: false   milvus:     enabled: false  mysql:   url: <your mysql url>   auth:     rootPassword: <your mysql root password>     username: <your mysql username>     password: <your mysql password for the username>  redis:   url: <your redis url>   auth:     password: <your redis password>   milvus:   url: <your milvus url>   milvus:     auth:       token: <your milvus api-key> ```  With this, FreeChat will not automatically install these services, but rather use the configuration information to connect directly.  ### Running Locally You can also run FreeChat locally. Currently supported on MacOS and Linux (although only tested on MacOS). You need to install the Docker toolset and have a network that can access [Docker Hub](https://hub.docker.com/).  Once ready, enter the `scripts/` directory and run `local-run.sh`, which will download and run the necessary docker containers. After a successful startup, you can access `http://localhost` via a browser to see the locally running freechat.fun. Use `local-run.sh --help` to view the supported options of the script. Good luck!  ### Running in an IDE To run FreeChat in an IDE, you need to start all dependent services first but do not need to run the container for the FreeChat application itself. You can execute the `scripts/local-deps.sh` script to start services like `MySQL`, `Redis`, `Milvus`, etc., locally. Once done, open and debug `freechat-start/src/main/java/fun/freechat/Application.java`。Make sure you have set the following startup parameters: ```shell -Dspring.config.location=classpath:/application.yml,classpath:/application-local.yml \\ -DAPP_HOME=local-data/freechat \\ -Dspring.profiles.active=local ```  ### 使用 SDK #### Java - **Dependency** ```xml <dependency>   <groupId>fun.freechat</groupId>   <artifactId>freechat-sdk</artifactId>   <version>${freechat-sdk.version}</version> </dependency> ```  - **Example** ```java import fun.freechat.client.ApiClient; import fun.freechat.client.ApiException; import fun.freechat.client.Configuration; import fun.freechat.client.api.AccountApi; import fun.freechat.client.auth.ApiKeyAuth; import fun.freechat.client.model.UserDetailsDTO;  public class AccountClientExample {     public static void main(String[] args) {         ApiClient defaultClient = Configuration.getDefaultApiClient();         defaultClient.setBasePath(\"https://freechat.fun\");                  // Configure HTTP bearer authorization: bearerAuth         HttpBearerAuth bearerAuth = (HttpBearerAuth) defaultClient.getAuthentication(\"bearerAuth\");         bearerAuth.setBearerToken(\"FREECHAT_TOKEN\");          AccountApi apiInstance = new AccountApi(defaultClient);         try {             UserDetailsDTO result = apiInstance.getUserDetails();             System.out.println(result);         } catch (ApiException e) {             e.printStackTrace();         }     } } ```  #### Python - **Installation** ```shell pip install freechat-sdk ```  - **Example** ```python import freechat_sdk from freechat_sdk.rest import ApiException from pprint import pprint  # Defining the host is optional and defaults to https://freechat.fun # See configuration.py for a list of all supported configuration parameters. configuration = freechat_sdk.Configuration(     host = \"https://freechat.fun\" )  # Configure Bearer authorization: bearerAuth configuration = freechat_sdk.Configuration(     access_token = os.environ[\"FREECHAT_TOKEN\"] )  # Enter a context with an instance of the API client with freechat_sdk.ApiClient(configuration) as api_client:     # Create an instance of the API class     api_instance = freechat_sdk.AccountApi(api_client)      try:         details = api_instance.get_user_details()         pprint(details)     except ApiException as e:         print(\"Exception when calling AccountClient->get_user_details: %s\\n\" % e) ```  #### TypeScript - **Installation** ```shell npm install freechat-sdk --save ```  - **Example** Refer to [FreeChatApiContext.tsx](https://github.com/freechat-fun/freechat/blob/main/freechat-web/src/contexts/FreeChatApiProvider.tsx)  ## System Dependencies | | Projects | ---- | ---- | Application Framework | [Spring Boot](https://spring.io/projects/spring-boot/) | LLM Framework | [LangChain4j](https://docs.langchain4j.dev/) | Model Providers | [OpenAI](https://platform.openai.com/), [DashScope](https://dashscope.aliyun.com/) | Database Systems | [MySQL](https://www.mysql.com/), [Redis](https://redis.io/), [Milvus](https://milvus.io/) | OpenAPI Tools | [Springdoc-openapi](https://springdoc.org/), [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator), [OpenAPI Explorer](https://github.com/Authress-Engineering/openapi-explorer)  ## Collaboration ### Application Integration The FreeChat system is entirely oriented towards Open APIs. The site [freechat.fun](https://freechat.fun) is developed using its TypeScript SDK and hardly depends on private interfaces. You can use these online interfaces to develop your own applications or sites, making them fit your preferences. Currently, FreeChat is completely free with no paid plans (after all, users use their own API Key to call LLM services).  ### Model Integration FreeChat aims to explore AI virtual character technology with anthropomorphic characteristics. So far, it supports model services from OpenAI and DashScope ([HuggingFace](https://huggingface.co/) is also expected to be supported soon). However, we are more interested in supporting models that are under research and can endow AI with more personality traits. If you are researching this area and hope FreeChat supports your model, please contact us. We look forward to AI technology helping people create their own \"soul mates\" in the future.
 
-    The version of the OpenAPI document: 0.1.0
+    The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
-import io
 import warnings
-
 from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
-
-try:
-    from typing import Annotated
-except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import Field
+from typing import Any, Dict, List, Optional, Tuple, Union
 from typing_extensions import Annotated
-from pydantic import StrictInt, StrictStr
 
+from pydantic import Field, StrictInt, StrictStr
 from typing import List, Optional
-
-from freechat-sdk.models.character_summary_stats_dto import CharacterSummaryStatsDTO
-from freechat-sdk.models.flow_summary_stats_dto import FlowSummaryStatsDTO
-from freechat-sdk.models.interactive_stats_dto import InteractiveStatsDTO
-from freechat-sdk.models.plugin_summary_stats_dto import PluginSummaryStatsDTO
-from freechat-sdk.models.prompt_summary_stats_dto import PromptSummaryStatsDTO
-
-from freechat-sdk.api_client import ApiClient
-from freechat-sdk.api_response import ApiResponse
-from freechat-sdk.rest import RESTResponseType
+from typing_extensions import Annotated
+from freechat_sdk.models.agent_summary_stats_dto import AgentSummaryStatsDTO
+from freechat_sdk.models.character_summary_stats_dto import CharacterSummaryStatsDTO
+from freechat_sdk.models.hot_tag_dto import HotTagDTO
+from freechat_sdk.models.interactive_stats_dto import InteractiveStatsDTO
+from freechat_sdk.models.plugin_summary_stats_dto import PluginSummaryStatsDTO
+from freechat_sdk.models.prompt_summary_stats_dto import PromptSummaryStatsDTO
+
+from freechat_sdk.api_client import ApiClient, RequestSerialized
+from freechat_sdk.api_response import ApiResponse
+from freechat_sdk.rest import RESTResponseType
 
 
 class InteractiveStatisticsApi:
     """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
@@ -52,15 +43,15 @@
             api_client = ApiClient.get_default()
         self.api_client = api_client
 
 
     @validate_call
     def add_statistic(
         self,
-        info_type: Annotated[StrictStr, Field(description="Resource type: prompt | flow | plugin")],
+        info_type: Annotated[StrictStr, Field(description="Info type: prompt | agent | plugin | character")],
         info_id: Annotated[StrictStr, Field(description="Unique resource identifier")],
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         delta: Annotated[StrictInt, Field(description="Delta in statistical value")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
@@ -73,15 +64,15 @@
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> int:
         """Add Statistics
 
         Add the statistics of the corresponding metrics of the corresponding resources. The increment can be negative. Return the latest statistics.
 
-        :param info_type: Resource type: prompt | flow | plugin (required)
+        :param info_type: Info type: prompt | agent | plugin | character (required)
         :type info_type: str
         :param info_id: Unique resource identifier (required)
         :type info_id: str
         :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
         :type stats_type: str
         :param delta: Delta in statistical value (required)
         :type delta: int
@@ -115,16 +106,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -132,15 +122,15 @@
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
     def add_statistic_with_http_info(
         self,
-        info_type: Annotated[StrictStr, Field(description="Resource type: prompt | flow | plugin")],
+        info_type: Annotated[StrictStr, Field(description="Info type: prompt | agent | plugin | character")],
         info_id: Annotated[StrictStr, Field(description="Unique resource identifier")],
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         delta: Annotated[StrictInt, Field(description="Delta in statistical value")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
@@ -153,15 +143,15 @@
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[int]:
         """Add Statistics
 
         Add the statistics of the corresponding metrics of the corresponding resources. The increment can be negative. Return the latest statistics.
 
-        :param info_type: Resource type: prompt | flow | plugin (required)
+        :param info_type: Info type: prompt | agent | plugin | character (required)
         :type info_type: str
         :param info_id: Unique resource identifier (required)
         :type info_id: str
         :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
         :type stats_type: str
         :param delta: Delta in statistical value (required)
         :type delta: int
@@ -195,16 +185,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -212,15 +201,15 @@
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
     def add_statistic_without_preload_content(
         self,
-        info_type: Annotated[StrictStr, Field(description="Resource type: prompt | flow | plugin")],
+        info_type: Annotated[StrictStr, Field(description="Info type: prompt | agent | plugin | character")],
         info_id: Annotated[StrictStr, Field(description="Unique resource identifier")],
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         delta: Annotated[StrictInt, Field(description="Delta in statistical value")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
@@ -233,15 +222,15 @@
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
         """Add Statistics
 
         Add the statistics of the corresponding metrics of the corresponding resources. The increment can be negative. Return the latest statistics.
 
-        :param info_type: Resource type: prompt | flow | plugin (required)
+        :param info_type: Info type: prompt | agent | plugin | character (required)
         :type info_type: str
         :param info_id: Unique resource identifier (required)
         :type info_id: str
         :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
         :type stats_type: str
         :param delta: Delta in statistical value (required)
         :type delta: int
@@ -275,16 +264,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -295,27 +283,26 @@
         info_id,
         stats_type,
         delta,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if info_type is not None:
             _path_params['infoType'] = info_type
         if info_id is not None:
             _path_params['infoId'] = info_id
@@ -359,15 +346,15 @@
 
 
 
 
     @validate_call
     def get_score(
         self,
-        info_type: Annotated[StrictStr, Field(description="Resource type: prompt | flow | plugin")],
+        info_type: Annotated[StrictStr, Field(description="Info type: prompt | agent | plugin | character")],
         info_id: Annotated[StrictStr, Field(description="Unique resource identifier")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -378,15 +365,15 @@
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> int:
         """Get Score for Resource
 
         Get the current user's score for the corresponding resource.
 
-        :param info_type: Resource type: prompt | flow | plugin (required)
+        :param info_type: Info type: prompt | agent | plugin | character (required)
         :type info_type: str
         :param info_id: Unique resource identifier (required)
         :type info_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
@@ -414,16 +401,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -431,15 +417,15 @@
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
     def get_score_with_http_info(
         self,
-        info_type: Annotated[StrictStr, Field(description="Resource type: prompt | flow | plugin")],
+        info_type: Annotated[StrictStr, Field(description="Info type: prompt | agent | plugin | character")],
         info_id: Annotated[StrictStr, Field(description="Unique resource identifier")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -450,15 +436,15 @@
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[int]:
         """Get Score for Resource
 
         Get the current user's score for the corresponding resource.
 
-        :param info_type: Resource type: prompt | flow | plugin (required)
+        :param info_type: Info type: prompt | agent | plugin | character (required)
         :type info_type: str
         :param info_id: Unique resource identifier (required)
         :type info_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
@@ -486,16 +472,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -503,15 +488,15 @@
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
     def get_score_without_preload_content(
         self,
-        info_type: Annotated[StrictStr, Field(description="Resource type: prompt | flow | plugin")],
+        info_type: Annotated[StrictStr, Field(description="Info type: prompt | agent | plugin | character")],
         info_id: Annotated[StrictStr, Field(description="Unique resource identifier")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -522,15 +507,15 @@
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
         """Get Score for Resource
 
         Get the current user's score for the corresponding resource.
 
-        :param info_type: Resource type: prompt | flow | plugin (required)
+        :param info_type: Info type: prompt | agent | plugin | character (required)
         :type info_type: str
         :param info_id: Unique resource identifier (required)
         :type info_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
@@ -558,16 +543,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -576,27 +560,26 @@
         self,
         info_type,
         info_id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if info_type is not None:
             _path_params['infoType'] = info_type
         if info_id is not None:
             _path_params['infoId'] = info_id
@@ -636,15 +619,15 @@
 
 
 
 
     @validate_call
     def get_statistic(
         self,
-        info_type: Annotated[StrictStr, Field(description="Resource type: prompt | flow | plugin")],
+        info_type: Annotated[StrictStr, Field(description="Info type: prompt | agent | plugin | character")],
         info_id: Annotated[StrictStr, Field(description="Unique resource identifier")],
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
@@ -656,15 +639,15 @@
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> int:
         """Get Statistics
 
         Get the statistics of the corresponding metrics of the corresponding resources.
 
-        :param info_type: Resource type: prompt | flow | plugin (required)
+        :param info_type: Info type: prompt | agent | plugin | character (required)
         :type info_type: str
         :param info_id: Unique resource identifier (required)
         :type info_id: str
         :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
         :type stats_type: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -695,16 +678,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -712,15 +694,15 @@
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
     def get_statistic_with_http_info(
         self,
-        info_type: Annotated[StrictStr, Field(description="Resource type: prompt | flow | plugin")],
+        info_type: Annotated[StrictStr, Field(description="Info type: prompt | agent | plugin | character")],
         info_id: Annotated[StrictStr, Field(description="Unique resource identifier")],
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
@@ -732,15 +714,15 @@
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[int]:
         """Get Statistics
 
         Get the statistics of the corresponding metrics of the corresponding resources.
 
-        :param info_type: Resource type: prompt | flow | plugin (required)
+        :param info_type: Info type: prompt | agent | plugin | character (required)
         :type info_type: str
         :param info_id: Unique resource identifier (required)
         :type info_id: str
         :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
         :type stats_type: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -771,16 +753,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -788,15 +769,15 @@
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
     def get_statistic_without_preload_content(
         self,
-        info_type: Annotated[StrictStr, Field(description="Resource type: prompt | flow | plugin")],
+        info_type: Annotated[StrictStr, Field(description="Info type: prompt | agent | plugin | character")],
         info_id: Annotated[StrictStr, Field(description="Unique resource identifier")],
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
@@ -808,15 +789,15 @@
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
         """Get Statistics
 
         Get the statistics of the corresponding metrics of the corresponding resources.
 
-        :param info_type: Resource type: prompt | flow | plugin (required)
+        :param info_type: Info type: prompt | agent | plugin | character (required)
         :type info_type: str
         :param info_id: Unique resource identifier (required)
         :type info_id: str
         :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
         :type stats_type: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -847,16 +828,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -866,27 +846,26 @@
         info_type,
         info_id,
         stats_type,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if info_type is not None:
             _path_params['infoType'] = info_type
         if info_id is not None:
             _path_params['infoId'] = info_id
@@ -928,15 +907,15 @@
 
 
 
 
     @validate_call
     def get_statistics(
         self,
-        info_type: Annotated[StrictStr, Field(description="Resource type: prompt | flow | plugin")],
+        info_type: Annotated[StrictStr, Field(description="Info type: prompt | agent | plugin | character")],
         info_id: Annotated[StrictStr, Field(description="Unique resource identifier")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -947,15 +926,15 @@
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> InteractiveStatsDTO:
         """Get All Statistics
 
         Get all statistics of the corresponding resources.
 
-        :param info_type: Resource type: prompt | flow | plugin (required)
+        :param info_type: Info type: prompt | agent | plugin | character (required)
         :type info_type: str
         :param info_id: Unique resource identifier (required)
         :type info_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
@@ -983,16 +962,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InteractiveStatsDTO"
-            
+            '200': "InteractiveStatsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1000,15 +978,15 @@
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
     def get_statistics_with_http_info(
         self,
-        info_type: Annotated[StrictStr, Field(description="Resource type: prompt | flow | plugin")],
+        info_type: Annotated[StrictStr, Field(description="Info type: prompt | agent | plugin | character")],
         info_id: Annotated[StrictStr, Field(description="Unique resource identifier")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -1019,15 +997,15 @@
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[InteractiveStatsDTO]:
         """Get All Statistics
 
         Get all statistics of the corresponding resources.
 
-        :param info_type: Resource type: prompt | flow | plugin (required)
+        :param info_type: Info type: prompt | agent | plugin | character (required)
         :type info_type: str
         :param info_id: Unique resource identifier (required)
         :type info_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
@@ -1055,16 +1033,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InteractiveStatsDTO"
-            
+            '200': "InteractiveStatsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1072,15 +1049,15 @@
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
     def get_statistics_without_preload_content(
         self,
-        info_type: Annotated[StrictStr, Field(description="Resource type: prompt | flow | plugin")],
+        info_type: Annotated[StrictStr, Field(description="Info type: prompt | agent | plugin | character")],
         info_id: Annotated[StrictStr, Field(description="Unique resource identifier")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -1091,15 +1068,15 @@
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
         """Get All Statistics
 
         Get all statistics of the corresponding resources.
 
-        :param info_type: Resource type: prompt | flow | plugin (required)
+        :param info_type: Info type: prompt | agent | plugin | character (required)
         :type info_type: str
         :param info_id: Unique resource identifier (required)
         :type info_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
@@ -1127,16 +1104,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InteractiveStatsDTO"
-            
+            '200': "InteractiveStatsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -1145,27 +1121,26 @@
         self,
         info_type,
         info_id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if info_type is not None:
             _path_params['infoType'] = info_type
         if info_id is not None:
             _path_params['infoId'] = info_id
@@ -1205,15 +1180,15 @@
 
 
 
 
     @validate_call
     def increase_statistic(
         self,
-        info_type: Annotated[StrictStr, Field(description="Resource type: prompt | flow | plugin")],
+        info_type: Annotated[StrictStr, Field(description="Info type: prompt | agent | plugin | character")],
         info_id: Annotated[StrictStr, Field(description="Unique resource identifier")],
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
@@ -1225,15 +1200,15 @@
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> int:
         """Increase Statistics
 
         Increase the statistics of the corresponding metrics of the corresponding resources by one. Return the latest statistics.
 
-        :param info_type: Resource type: prompt | flow | plugin (required)
+        :param info_type: Info type: prompt | agent | plugin | character (required)
         :type info_type: str
         :param info_id: Unique resource identifier (required)
         :type info_id: str
         :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
         :type stats_type: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -1264,16 +1239,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1281,15 +1255,15 @@
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
     def increase_statistic_with_http_info(
         self,
-        info_type: Annotated[StrictStr, Field(description="Resource type: prompt | flow | plugin")],
+        info_type: Annotated[StrictStr, Field(description="Info type: prompt | agent | plugin | character")],
         info_id: Annotated[StrictStr, Field(description="Unique resource identifier")],
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
@@ -1301,15 +1275,15 @@
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[int]:
         """Increase Statistics
 
         Increase the statistics of the corresponding metrics of the corresponding resources by one. Return the latest statistics.
 
-        :param info_type: Resource type: prompt | flow | plugin (required)
+        :param info_type: Info type: prompt | agent | plugin | character (required)
         :type info_type: str
         :param info_id: Unique resource identifier (required)
         :type info_id: str
         :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
         :type stats_type: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -1340,16 +1314,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1357,15 +1330,15 @@
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
     def increase_statistic_without_preload_content(
         self,
-        info_type: Annotated[StrictStr, Field(description="Resource type: prompt | flow | plugin")],
+        info_type: Annotated[StrictStr, Field(description="Info type: prompt | agent | plugin | character")],
         info_id: Annotated[StrictStr, Field(description="Unique resource identifier")],
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
@@ -1377,15 +1350,15 @@
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
         """Increase Statistics
 
         Increase the statistics of the corresponding metrics of the corresponding resources by one. Return the latest statistics.
 
-        :param info_type: Resource type: prompt | flow | plugin (required)
+        :param info_type: Info type: prompt | agent | plugin | character (required)
         :type info_type: str
         :param info_id: Unique resource identifier (required)
         :type info_id: str
         :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
         :type stats_type: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -1416,16 +1389,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -1435,27 +1407,26 @@
         info_type,
         info_id,
         stats_type,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if info_type is not None:
             _path_params['infoType'] = info_type
         if info_id is not None:
             _path_params['infoId'] = info_id
@@ -1495,15 +1466,290 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def list_characters_by_statistic(
+    def list_agents_by_statistic(
+        self,
+        stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
+        asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> List[AgentSummaryStatsDTO]:
+        """List Agents by Statistics
+
+        List agents based on statistics, including interactive statistical data.
+
+        :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
+        :type stats_type: str
+        :param asc: Default is descending order, set asc=1 for ascending order
+        :type asc: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._list_agents_by_statistic_serialize(
+            stats_type=stats_type,
+            asc=asc,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "List[AgentSummaryStatsDTO]",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        ).data
+
+
+    @validate_call
+    def list_agents_by_statistic_with_http_info(
+        self,
+        stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
+        asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> ApiResponse[List[AgentSummaryStatsDTO]]:
+        """List Agents by Statistics
+
+        List agents based on statistics, including interactive statistical data.
+
+        :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
+        :type stats_type: str
+        :param asc: Default is descending order, set asc=1 for ascending order
+        :type asc: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._list_agents_by_statistic_serialize(
+            stats_type=stats_type,
+            asc=asc,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "List[AgentSummaryStatsDTO]",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        )
+
+
+    @validate_call
+    def list_agents_by_statistic_without_preload_content(
+        self,
+        stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
+        asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> RESTResponseType:
+        """List Agents by Statistics
+
+        List agents based on statistics, including interactive statistical data.
+
+        :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
+        :type stats_type: str
+        :param asc: Default is descending order, set asc=1 for ascending order
+        :type asc: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._list_agents_by_statistic_serialize(
+            stats_type=stats_type,
+            asc=asc,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "List[AgentSummaryStatsDTO]",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        return response_data.response
+
+
+    def _list_agents_by_statistic_serialize(
+        self,
+        stats_type,
+        asc,
+        _request_auth,
+        _content_type,
+        _headers,
+        _host_index,
+    ) -> RequestSerialized:
+
+        _host = None
+
+        _collection_formats: Dict[str, str] = {
+        }
+
+        _path_params: Dict[str, str] = {}
+        _query_params: List[Tuple[str, str]] = []
+        _header_params: Dict[str, Optional[str]] = _headers or {}
+        _form_params: List[Tuple[str, str]] = []
+        _files: Dict[str, Union[str, bytes]] = {}
+        _body_params: Optional[bytes] = None
+
+        # process the path parameters
+        if stats_type is not None:
+            _path_params['statsType'] = stats_type
+        # process the query parameters
+        if asc is not None:
+            
+            _query_params.append(('asc', asc))
+            
+        # process the header parameters
+        # process the form parameters
+        # process the body parameter
+
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            [
+                'application/json'
+            ]
+        )
+
+
+        # authentication setting
+        _auth_settings: List[str] = [
+            'bearerAuth'
+        ]
+
+        return self.api_client.param_serialize(
+            method='GET',
+            resource_path='/api/v1/stats/agents/by/{statsType}',
+            path_params=_path_params,
+            query_params=_query_params,
+            header_params=_header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            auth_settings=_auth_settings,
+            collection_formats=_collection_formats,
+            _host=_host,
+            _request_auth=_request_auth
+        )
+
+
+
+
+    @validate_call
+    def list_agents_by_statistic1(
         self,
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
         asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
@@ -1512,18 +1758,18 @@
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[CharacterSummaryStatsDTO]:
-        """List Characters by Statistics
+    ) -> List[AgentSummaryStatsDTO]:
+        """List Agents by Statistics
 
-        List characters based on statistics, including interactive statistical data.
+        List agents based on statistics, including interactive statistical data.
 
         :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
         :type stats_type: str
         :param page_size: Maximum quantity (required)
         :type page_size: int
         :param asc: Default is descending order, set asc=1 for ascending order
         :type asc: str
@@ -1545,41 +1791,40 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_characters_by_statistic_serialize(
+        _param = self._list_agents_by_statistic1_serialize(
             stats_type=stats_type,
             page_size=page_size,
             asc=asc,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[CharacterSummaryStatsDTO]"
-            
+            '200': "List[AgentSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def list_characters_by_statistic_with_http_info(
+    def list_agents_by_statistic1_with_http_info(
         self,
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
         asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
@@ -1588,18 +1833,18 @@
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[CharacterSummaryStatsDTO]]:
-        """List Characters by Statistics
+    ) -> ApiResponse[List[AgentSummaryStatsDTO]]:
+        """List Agents by Statistics
 
-        List characters based on statistics, including interactive statistical data.
+        List agents based on statistics, including interactive statistical data.
 
         :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
         :type stats_type: str
         :param page_size: Maximum quantity (required)
         :type page_size: int
         :param asc: Default is descending order, set asc=1 for ascending order
         :type asc: str
@@ -1621,41 +1866,40 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_characters_by_statistic_serialize(
+        _param = self._list_agents_by_statistic1_serialize(
             stats_type=stats_type,
             page_size=page_size,
             asc=asc,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[CharacterSummaryStatsDTO]"
-            
+            '200': "List[AgentSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def list_characters_by_statistic_without_preload_content(
+    def list_agents_by_statistic1_without_preload_content(
         self,
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
         asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
@@ -1665,17 +1909,17 @@
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """List Characters by Statistics
+        """List Agents by Statistics
 
-        List characters based on statistics, including interactive statistical data.
+        List agents based on statistics, including interactive statistical data.
 
         :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
         :type stats_type: str
         :param page_size: Maximum quantity (required)
         :type page_size: int
         :param asc: Default is descending order, set asc=1 for ascending order
         :type asc: str
@@ -1697,57 +1941,55 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_characters_by_statistic_serialize(
+        _param = self._list_agents_by_statistic1_serialize(
             stats_type=stats_type,
             page_size=page_size,
             asc=asc,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[CharacterSummaryStatsDTO]"
-            
+            '200': "List[AgentSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _list_characters_by_statistic_serialize(
+    def _list_agents_by_statistic1_serialize(
         self,
         stats_type,
         page_size,
         asc,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if stats_type is not None:
             _path_params['statsType'] = stats_type
         if page_size is not None:
             _path_params['pageSize'] = page_size
@@ -1772,15 +2014,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='GET',
-            resource_path='/api/v1/stats/characters/by/{statsType}/{pageSize}',
+            resource_path='/api/v1/stats/agents/by/{statsType}/{pageSize}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -1789,36 +2031,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def list_characters_by_statistic1(
+    def list_agents_by_statistic2(
         self,
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
-        page_num: Annotated[int, Field(strict=True, ge=0, description="Current page number")],
+        page_num: Annotated[StrictInt, Field(description="Current page number")],
         asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[CharacterSummaryStatsDTO]:
-        """List Characters by Statistics
+    ) -> List[AgentSummaryStatsDTO]:
+        """List Agents by Statistics
 
-        List characters based on statistics, including interactive statistical data.
+        List agents based on statistics, including interactive statistical data.
 
         :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
         :type stats_type: str
         :param page_size: Maximum quantity (required)
         :type page_size: int
         :param page_num: Current page number (required)
         :type page_num: int
@@ -1842,63 +2084,62 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_characters_by_statistic1_serialize(
+        _param = self._list_agents_by_statistic2_serialize(
             stats_type=stats_type,
             page_size=page_size,
             page_num=page_num,
             asc=asc,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[CharacterSummaryStatsDTO]"
-            
+            '200': "List[AgentSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def list_characters_by_statistic1_with_http_info(
+    def list_agents_by_statistic2_with_http_info(
         self,
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
-        page_num: Annotated[int, Field(strict=True, ge=0, description="Current page number")],
+        page_num: Annotated[StrictInt, Field(description="Current page number")],
         asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[CharacterSummaryStatsDTO]]:
-        """List Characters by Statistics
+    ) -> ApiResponse[List[AgentSummaryStatsDTO]]:
+        """List Agents by Statistics
 
-        List characters based on statistics, including interactive statistical data.
+        List agents based on statistics, including interactive statistical data.
 
         :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
         :type stats_type: str
         :param page_size: Maximum quantity (required)
         :type page_size: int
         :param page_num: Current page number (required)
         :type page_num: int
@@ -1922,63 +2163,62 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_characters_by_statistic1_serialize(
+        _param = self._list_agents_by_statistic2_serialize(
             stats_type=stats_type,
             page_size=page_size,
             page_num=page_num,
             asc=asc,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[CharacterSummaryStatsDTO]"
-            
+            '200': "List[AgentSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def list_characters_by_statistic1_without_preload_content(
+    def list_agents_by_statistic2_without_preload_content(
         self,
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
-        page_num: Annotated[int, Field(strict=True, ge=0, description="Current page number")],
+        page_num: Annotated[StrictInt, Field(description="Current page number")],
         asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """List Characters by Statistics
+        """List Agents by Statistics
 
-        List characters based on statistics, including interactive statistical data.
+        List agents based on statistics, including interactive statistical data.
 
         :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
         :type stats_type: str
         :param page_size: Maximum quantity (required)
         :type page_size: int
         :param page_num: Current page number (required)
         :type page_num: int
@@ -2002,59 +2242,57 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_characters_by_statistic1_serialize(
+        _param = self._list_agents_by_statistic2_serialize(
             stats_type=stats_type,
             page_size=page_size,
             page_num=page_num,
             asc=asc,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[CharacterSummaryStatsDTO]"
-            
+            '200': "List[AgentSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _list_characters_by_statistic1_serialize(
+    def _list_agents_by_statistic2_serialize(
         self,
         stats_type,
         page_size,
         page_num,
         asc,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if stats_type is not None:
             _path_params['statsType'] = stats_type
         if page_size is not None:
             _path_params['pageSize'] = page_size
@@ -2081,15 +2319,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='GET',
-            resource_path='/api/v1/stats/characters/by/{statsType}/{pageSize}/{pageNum}',
+            resource_path='/api/v1/stats/agents/by/{statsType}/{pageSize}/{pageNum}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -2098,17 +2336,18 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def list_characters_by_statistic2(
+    def list_characters_by_statistic(
         self,
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
+        page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
         asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -2121,14 +2360,16 @@
     ) -> List[CharacterSummaryStatsDTO]:
         """List Characters by Statistics
 
         List characters based on statistics, including interactive statistical data.
 
         :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
         :type stats_type: str
+        :param page_size: Maximum quantity (required)
+        :type page_size: int
         :param asc: Default is descending order, set asc=1 for ascending order
         :type asc: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
@@ -2145,42 +2386,43 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_characters_by_statistic2_serialize(
+        _param = self._list_characters_by_statistic_serialize(
             stats_type=stats_type,
+            page_size=page_size,
             asc=asc,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[CharacterSummaryStatsDTO]"
-            
+            '200': "List[CharacterSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def list_characters_by_statistic2_with_http_info(
+    def list_characters_by_statistic_with_http_info(
         self,
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
+        page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
         asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -2193,14 +2435,16 @@
     ) -> ApiResponse[List[CharacterSummaryStatsDTO]]:
         """List Characters by Statistics
 
         List characters based on statistics, including interactive statistical data.
 
         :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
         :type stats_type: str
+        :param page_size: Maximum quantity (required)
+        :type page_size: int
         :param asc: Default is descending order, set asc=1 for ascending order
         :type asc: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
@@ -2217,42 +2461,43 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_characters_by_statistic2_serialize(
+        _param = self._list_characters_by_statistic_serialize(
             stats_type=stats_type,
+            page_size=page_size,
             asc=asc,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[CharacterSummaryStatsDTO]"
-            
+            '200': "List[CharacterSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def list_characters_by_statistic2_without_preload_content(
+    def list_characters_by_statistic_without_preload_content(
         self,
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
+        page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
         asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -2265,14 +2510,16 @@
     ) -> RESTResponseType:
         """List Characters by Statistics
 
         List characters based on statistics, including interactive statistical data.
 
         :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
         :type stats_type: str
+        :param page_size: Maximum quantity (required)
+        :type page_size: int
         :param asc: Default is descending order, set asc=1 for ascending order
         :type asc: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
@@ -2289,60 +2536,62 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_characters_by_statistic2_serialize(
+        _param = self._list_characters_by_statistic_serialize(
             stats_type=stats_type,
+            page_size=page_size,
             asc=asc,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[CharacterSummaryStatsDTO]"
-            
+            '200': "List[CharacterSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _list_characters_by_statistic2_serialize(
+    def _list_characters_by_statistic_serialize(
         self,
         stats_type,
+        page_size,
         asc,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if stats_type is not None:
             _path_params['statsType'] = stats_type
+        if page_size is not None:
+            _path_params['pageSize'] = page_size
         # process the query parameters
         if asc is not None:
             
             _query_params.append(('asc', asc))
             
         # process the header parameters
         # process the form parameters
@@ -2360,15 +2609,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='GET',
-            resource_path='/api/v1/stats/characters/by/{statsType}',
+            resource_path='/api/v1/stats/characters/by/{statsType}/{pageSize}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -2377,36 +2626,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def list_flows_by_statistic(
+    def list_characters_by_statistic1(
         self,
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
-        page_num: Annotated[int, Field(strict=True, ge=0, description="Current page number")],
+        page_num: Annotated[StrictInt, Field(description="Current page number")],
         asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[FlowSummaryStatsDTO]:
-        """List Flows by Statistics
+    ) -> List[CharacterSummaryStatsDTO]:
+        """List Characters by Statistics
 
-        List flows based on statistics, including interactive statistical data.
+        List characters based on statistics, including interactive statistical data.
 
         :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
         :type stats_type: str
         :param page_size: Maximum quantity (required)
         :type page_size: int
         :param page_num: Current page number (required)
         :type page_num: int
@@ -2430,63 +2679,62 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_flows_by_statistic_serialize(
+        _param = self._list_characters_by_statistic1_serialize(
             stats_type=stats_type,
             page_size=page_size,
             page_num=page_num,
             asc=asc,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[FlowSummaryStatsDTO]"
-            
+            '200': "List[CharacterSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def list_flows_by_statistic_with_http_info(
+    def list_characters_by_statistic1_with_http_info(
         self,
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
-        page_num: Annotated[int, Field(strict=True, ge=0, description="Current page number")],
+        page_num: Annotated[StrictInt, Field(description="Current page number")],
         asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[FlowSummaryStatsDTO]]:
-        """List Flows by Statistics
+    ) -> ApiResponse[List[CharacterSummaryStatsDTO]]:
+        """List Characters by Statistics
 
-        List flows based on statistics, including interactive statistical data.
+        List characters based on statistics, including interactive statistical data.
 
         :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
         :type stats_type: str
         :param page_size: Maximum quantity (required)
         :type page_size: int
         :param page_num: Current page number (required)
         :type page_num: int
@@ -2510,63 +2758,62 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_flows_by_statistic_serialize(
+        _param = self._list_characters_by_statistic1_serialize(
             stats_type=stats_type,
             page_size=page_size,
             page_num=page_num,
             asc=asc,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[FlowSummaryStatsDTO]"
-            
+            '200': "List[CharacterSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def list_flows_by_statistic_without_preload_content(
+    def list_characters_by_statistic1_without_preload_content(
         self,
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
-        page_num: Annotated[int, Field(strict=True, ge=0, description="Current page number")],
+        page_num: Annotated[StrictInt, Field(description="Current page number")],
         asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """List Flows by Statistics
+        """List Characters by Statistics
 
-        List flows based on statistics, including interactive statistical data.
+        List characters based on statistics, including interactive statistical data.
 
         :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
         :type stats_type: str
         :param page_size: Maximum quantity (required)
         :type page_size: int
         :param page_num: Current page number (required)
         :type page_num: int
@@ -2590,59 +2837,57 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_flows_by_statistic_serialize(
+        _param = self._list_characters_by_statistic1_serialize(
             stats_type=stats_type,
             page_size=page_size,
             page_num=page_num,
             asc=asc,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[FlowSummaryStatsDTO]"
-            
+            '200': "List[CharacterSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _list_flows_by_statistic_serialize(
+    def _list_characters_by_statistic1_serialize(
         self,
         stats_type,
         page_size,
         page_num,
         asc,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if stats_type is not None:
             _path_params['statsType'] = stats_type
         if page_size is not None:
             _path_params['pageSize'] = page_size
@@ -2669,15 +2914,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='GET',
-            resource_path='/api/v1/stats/flows/by/{statsType}/{pageSize}/{pageNum}',
+            resource_path='/api/v1/stats/characters/by/{statsType}/{pageSize}/{pageNum}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -2686,15 +2931,15 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def list_flows_by_statistic1(
+    def list_characters_by_statistic2(
         self,
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
@@ -2702,18 +2947,18 @@
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[FlowSummaryStatsDTO]:
-        """List Flows by Statistics
+    ) -> List[CharacterSummaryStatsDTO]:
+        """List Characters by Statistics
 
-        List flows based on statistics, including interactive statistical data.
+        List characters based on statistics, including interactive statistical data.
 
         :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
         :type stats_type: str
         :param asc: Default is descending order, set asc=1 for ascending order
         :type asc: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -2733,40 +2978,39 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_flows_by_statistic1_serialize(
+        _param = self._list_characters_by_statistic2_serialize(
             stats_type=stats_type,
             asc=asc,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[FlowSummaryStatsDTO]"
-            
+            '200': "List[CharacterSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def list_flows_by_statistic1_with_http_info(
+    def list_characters_by_statistic2_with_http_info(
         self,
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
@@ -2774,18 +3018,18 @@
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[FlowSummaryStatsDTO]]:
-        """List Flows by Statistics
+    ) -> ApiResponse[List[CharacterSummaryStatsDTO]]:
+        """List Characters by Statistics
 
-        List flows based on statistics, including interactive statistical data.
+        List characters based on statistics, including interactive statistical data.
 
         :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
         :type stats_type: str
         :param asc: Default is descending order, set asc=1 for ascending order
         :type asc: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -2805,40 +3049,39 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_flows_by_statistic1_serialize(
+        _param = self._list_characters_by_statistic2_serialize(
             stats_type=stats_type,
             asc=asc,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[FlowSummaryStatsDTO]"
-            
+            '200': "List[CharacterSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def list_flows_by_statistic1_without_preload_content(
+    def list_characters_by_statistic2_without_preload_content(
         self,
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
@@ -2847,17 +3090,17 @@
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """List Flows by Statistics
+        """List Characters by Statistics
 
-        List flows based on statistics, including interactive statistical data.
+        List characters based on statistics, including interactive statistical data.
 
         :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
         :type stats_type: str
         :param asc: Default is descending order, set asc=1 for ascending order
         :type asc: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -2877,55 +3120,53 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_flows_by_statistic1_serialize(
+        _param = self._list_characters_by_statistic2_serialize(
             stats_type=stats_type,
             asc=asc,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[FlowSummaryStatsDTO]"
-            
+            '200': "List[CharacterSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _list_flows_by_statistic1_serialize(
+    def _list_characters_by_statistic2_serialize(
         self,
         stats_type,
         asc,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if stats_type is not None:
             _path_params['statsType'] = stats_type
         # process the query parameters
         if asc is not None:
@@ -2948,15 +3189,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='GET',
-            resource_path='/api/v1/stats/flows/by/{statsType}',
+            resource_path='/api/v1/stats/characters/by/{statsType}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -2965,42 +3206,42 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def list_flows_by_statistic2(
+    def list_hot_tags(
         self,
-        stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
+        info_type: Annotated[StrictStr, Field(description="Info type: prompt | agent | plugin | character")],
         page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
-        asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
+        text: Annotated[Optional[StrictStr], Field(description="Key word")] = None,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[FlowSummaryStatsDTO]:
-        """List Flows by Statistics
+    ) -> List[HotTagDTO]:
+        """Hot Tags
 
-        List flows based on statistics, including interactive statistical data.
+        Get popular tags for a specified info type.
 
-        :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
-        :type stats_type: str
+        :param info_type: Info type: prompt | agent | plugin | character (required)
+        :type info_type: str
         :param page_size: Maximum quantity (required)
         :type page_size: int
-        :param asc: Default is descending order, set asc=1 for ascending order
-        :type asc: str
+        :param text: Key word
+        :type text: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3015,68 +3256,67 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_flows_by_statistic2_serialize(
-            stats_type=stats_type,
+        _param = self._list_hot_tags_serialize(
+            info_type=info_type,
             page_size=page_size,
-            asc=asc,
+            text=text,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[FlowSummaryStatsDTO]"
-            
+            '200': "List[HotTagDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def list_flows_by_statistic2_with_http_info(
+    def list_hot_tags_with_http_info(
         self,
-        stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
+        info_type: Annotated[StrictStr, Field(description="Info type: prompt | agent | plugin | character")],
         page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
-        asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
+        text: Annotated[Optional[StrictStr], Field(description="Key word")] = None,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[FlowSummaryStatsDTO]]:
-        """List Flows by Statistics
+    ) -> ApiResponse[List[HotTagDTO]]:
+        """Hot Tags
 
-        List flows based on statistics, including interactive statistical data.
+        Get popular tags for a specified info type.
 
-        :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
-        :type stats_type: str
+        :param info_type: Info type: prompt | agent | plugin | character (required)
+        :type info_type: str
         :param page_size: Maximum quantity (required)
         :type page_size: int
-        :param asc: Default is descending order, set asc=1 for ascending order
-        :type asc: str
+        :param text: Key word
+        :type text: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3091,68 +3331,67 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_flows_by_statistic2_serialize(
-            stats_type=stats_type,
+        _param = self._list_hot_tags_serialize(
+            info_type=info_type,
             page_size=page_size,
-            asc=asc,
+            text=text,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[FlowSummaryStatsDTO]"
-            
+            '200': "List[HotTagDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def list_flows_by_statistic2_without_preload_content(
+    def list_hot_tags_without_preload_content(
         self,
-        stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
+        info_type: Annotated[StrictStr, Field(description="Info type: prompt | agent | plugin | character")],
         page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
-        asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
+        text: Annotated[Optional[StrictStr], Field(description="Key word")] = None,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """List Flows by Statistics
+        """Hot Tags
 
-        List flows based on statistics, including interactive statistical data.
+        Get popular tags for a specified info type.
 
-        :param stats_type: Statistics type: view_count | refer_count | recommend_count | score (required)
-        :type stats_type: str
+        :param info_type: Info type: prompt | agent | plugin | character (required)
+        :type info_type: str
         :param page_size: Maximum quantity (required)
         :type page_size: int
-        :param asc: Default is descending order, set asc=1 for ascending order
-        :type asc: str
+        :param text: Key word
+        :type text: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3167,68 +3406,66 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_flows_by_statistic2_serialize(
-            stats_type=stats_type,
+        _param = self._list_hot_tags_serialize(
+            info_type=info_type,
             page_size=page_size,
-            asc=asc,
+            text=text,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[FlowSummaryStatsDTO]"
-            
+            '200': "List[HotTagDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _list_flows_by_statistic2_serialize(
+    def _list_hot_tags_serialize(
         self,
-        stats_type,
+        info_type,
         page_size,
-        asc,
+        text,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if stats_type is not None:
-            _path_params['statsType'] = stats_type
+        if info_type is not None:
+            _path_params['infoType'] = info_type
         if page_size is not None:
             _path_params['pageSize'] = page_size
         # process the query parameters
-        if asc is not None:
+        if text is not None:
             
-            _query_params.append(('asc', asc))
+            _query_params.append(('text', text))
             
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
@@ -3242,15 +3479,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='GET',
-            resource_path='/api/v1/stats/flows/by/{statsType}/{pageSize}',
+            resource_path='/api/v1/tags/hot/{infoType}/{pageSize}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -3263,15 +3500,15 @@
 
 
     @validate_call
     def list_plugins_by_statistic(
         self,
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
-        page_num: Annotated[int, Field(strict=True, ge=0, description="Current page number")],
+        page_num: Annotated[StrictInt, Field(description="Current page number")],
         asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -3324,16 +3561,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PluginSummaryStatsDTO]"
-            
+            '200': "List[PluginSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -3343,15 +3579,15 @@
 
 
     @validate_call
     def list_plugins_by_statistic_with_http_info(
         self,
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
-        page_num: Annotated[int, Field(strict=True, ge=0, description="Current page number")],
+        page_num: Annotated[StrictInt, Field(description="Current page number")],
         asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -3404,16 +3640,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PluginSummaryStatsDTO]"
-            
+            '200': "List[PluginSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -3423,15 +3658,15 @@
 
 
     @validate_call
     def list_plugins_by_statistic_without_preload_content(
         self,
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
-        page_num: Annotated[int, Field(strict=True, ge=0, description="Current page number")],
+        page_num: Annotated[StrictInt, Field(description="Current page number")],
         asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -3484,16 +3719,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PluginSummaryStatsDTO]"
-            
+            '200': "List[PluginSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -3504,27 +3738,26 @@
         page_size,
         page_num,
         asc,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if stats_type is not None:
             _path_params['statsType'] = stats_type
         if page_size is not None:
             _path_params['pageSize'] = page_size
@@ -3629,16 +3862,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PluginSummaryStatsDTO]"
-            
+            '200': "List[PluginSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -3705,16 +3937,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PluginSummaryStatsDTO]"
-            
+            '200': "List[PluginSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -3781,16 +4012,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PluginSummaryStatsDTO]"
-            
+            '200': "List[PluginSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -3800,27 +4030,26 @@
         stats_type,
         page_size,
         asc,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if stats_type is not None:
             _path_params['statsType'] = stats_type
         if page_size is not None:
             _path_params['pageSize'] = page_size
@@ -3919,16 +4148,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PluginSummaryStatsDTO]"
-            
+            '200': "List[PluginSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -3991,16 +4219,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PluginSummaryStatsDTO]"
-            
+            '200': "List[PluginSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -4063,16 +4290,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PluginSummaryStatsDTO]"
-            
+            '200': "List[PluginSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -4081,27 +4307,26 @@
         self,
         stats_type,
         asc,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if stats_type is not None:
             _path_params['statsType'] = stats_type
         # process the query parameters
         if asc is not None:
@@ -4202,16 +4427,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PromptSummaryStatsDTO]"
-            
+            '200': "List[PromptSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -4278,16 +4502,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PromptSummaryStatsDTO]"
-            
+            '200': "List[PromptSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -4354,16 +4577,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PromptSummaryStatsDTO]"
-            
+            '200': "List[PromptSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -4373,27 +4595,26 @@
         stats_type,
         page_size,
         asc,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if stats_type is not None:
             _path_params['statsType'] = stats_type
         if page_size is not None:
             _path_params['pageSize'] = page_size
@@ -4439,15 +4660,15 @@
 
 
     @validate_call
     def list_prompts_by_statistic1(
         self,
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
-        page_num: Annotated[int, Field(strict=True, ge=0, description="Current page number")],
+        page_num: Annotated[StrictInt, Field(description="Current page number")],
         asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -4500,16 +4721,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PromptSummaryStatsDTO]"
-            
+            '200': "List[PromptSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -4519,15 +4739,15 @@
 
 
     @validate_call
     def list_prompts_by_statistic1_with_http_info(
         self,
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
-        page_num: Annotated[int, Field(strict=True, ge=0, description="Current page number")],
+        page_num: Annotated[StrictInt, Field(description="Current page number")],
         asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -4580,16 +4800,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PromptSummaryStatsDTO]"
-            
+            '200': "List[PromptSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -4599,15 +4818,15 @@
 
 
     @validate_call
     def list_prompts_by_statistic1_without_preload_content(
         self,
         stats_type: Annotated[StrictStr, Field(description="Statistics type: view_count | refer_count | recommend_count | score")],
         page_size: Annotated[StrictInt, Field(description="Maximum quantity")],
-        page_num: Annotated[int, Field(strict=True, ge=0, description="Current page number")],
+        page_num: Annotated[StrictInt, Field(description="Current page number")],
         asc: Annotated[Optional[StrictStr], Field(description="Default is descending order, set asc=1 for ascending order")] = None,
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -4660,16 +4879,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PromptSummaryStatsDTO]"
-            
+            '200': "List[PromptSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -4680,27 +4898,26 @@
         page_size,
         page_num,
         asc,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if stats_type is not None:
             _path_params['statsType'] = stats_type
         if page_size is not None:
             _path_params['pageSize'] = page_size
@@ -4801,16 +5018,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PromptSummaryStatsDTO]"
-            
+            '200': "List[PromptSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -4873,16 +5089,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PromptSummaryStatsDTO]"
-            
+            '200': "List[PromptSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -4945,16 +5160,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PromptSummaryStatsDTO]"
-            
+            '200': "List[PromptSummaryStatsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -4963,27 +5177,26 @@
         self,
         stats_type,
         asc,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if stats_type is not None:
             _path_params['statsType'] = stats_type
         # process the query parameters
         if asc is not None:
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## Comparing `freechat-sdk/api/organization_api.py` & `freechat_sdk/api/organization_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,42 +1,32 @@
 # coding: utf-8
 
 """
     FreeChat OpenAPI Definition
 
-    https://github.com/freechat-fun/freechat
+    # FreeChat: Create Some Friends for Yourself with AI  English | [中文版](https://github.com/freechat-fun/freechat/blob/main/README.zh-CN.md)  ## Introduction Welcome! FreeChat aims to build a cloud-native, robust, and quickly commercializable enterprise-level AI virtual character platform.  ## Features - Primarily uses Java and emphasizes **security, robustness, scalability, traceability, and maintainability**. - oasts **account systems and permission management**, supporting OAuth2 authentication. Introduces the \"organization\" concept and related permission constraint functions. - Extensively employs **distributed technologies and caching** to support **high concurrency** access. - Provides flexible character customization options, supports direct intervention in prompts, and supports **configuring multiple backends for each character**. - **Offers a comprehensive range of Open APIs**, with more than 180 interfaces and provides java/python/typescript SDKs. These interfaces enable easy construction of systems for end-users. - Supports setting **RAG** (Retrieval Augmented Generation) for characters. - Supports **long-term memory** for characters. - Supports setting **quota limits** for characters.  ## System Snapshots  ## Character Design ```mermaid flowchart TD     A(Character) --> B(Profile)     A --> C(Knowledge/RAG)     A --> D(Album)     A --> E(Backend-1)     A --> F(Backend-n...)     E --> G(Message Window)     E --> H(Long Term Memory Settings)     E --> I(Quota Limit)     E --> J(Chat Prompt Task)     E --> K(Greeting Prompt Task)     E --> L(Moderation Settings)     J --> M(Model & Parameters)     J --> N(API Keys)     J --> O(Prompt Refence)     J --> P(Tool Specifications)     O --> Q(Template)     O --> R(Variables)     O --> S(Version)     O --> T(...)     style K stroke-dasharray: 5, 5     style L stroke-dasharray: 5, 5     style P stroke-dasharray: 5, 5 ```  After setting up a unified persona and knowledge for a character, different backends can be configured. For example, different model may be adopted for different users based on cost considerations.  ## How to Play ### Online Website You can visit [freechat.fun](https://freechat.fun) to experience FreeChat. Share your designed AI character!  ### Running in a Kubernetes Cluster FreeChat is dedicated to the principles of cloud-native design. If you have a Kubernetes cluster, you can deploy FreeChat to your environment by following these steps:  1. Put the Kubernetes configuration file in the `configs/helm/` directory, named `kube-private.conf`. 2. Place the Helm configuration file in the same directory, named `values-private.yaml`. Make sure to reference the default `values.yaml` and customize the variables as needed. 3. Switch to the `scripts/` directory. 4. If needed, execute `install-in.sh` to deploy `ingress-nginx` to the Kubernetes cluster. 5. If needed, run `install-cm.sh` to deploy `cert-manager` on the Kubernetes cluster, which automatically issues certificates for domains specified in `ingress.hosts`. 6. Run `install-pvc.sh` to install PersistentVolumeClaim resources.      > By default, FreeChat operates files by accessing the \"local file system.\" You may want to use high-availability distributed storage in the cloud. As a cloud-native-designed system, we recommend interfacing through Kubernetes CSI to avoid individually adapting storage products for each cloud platform. Most cloud service providers offer cloud storage drivers for Kubernetes, with a series of predefined StorageClass resources. Please choose the appropriate configuration according to your actual needs and set it in Helm's `global.storageClass` option.     >      > *In the future, FreeChat may be refactored to use MinIO's APIs directly, as it is now installed in the Kubernetes cluster as a dependency (serving Milvus).*  7. Execute the `install.sh` script to install FreeChat and its dependencies. 8. FreeChat aims to provide Open API services. If you like the interactive experience of [freechat.fun](https://freechat.fun), run `install-web.sh` to deploy the front-end application. 9. Execute `restart.sh` to restart the service. 10. If you modified any Helm configuration files, use `upgrade.sh` to update the corresponding Kubernetes resources. 11. To remove specific resources, run the `uninstall*.sh` script corresponding to the resource you want to uninstall.  As a cloud-native application, the services FreeChat relies on are obtained and deployed to your cluster through the helm repository.  If you prefer cloud services with SLA (Service Level Agreement) guarantees, simply make the relevant settings in `configs/helm/values-private.yaml`: ```yaml bitnami:   mysql:     enabled: false   redis:     enabled: false   milvus:     enabled: false  mysql:   url: <your mysql url>   auth:     rootPassword: <your mysql root password>     username: <your mysql username>     password: <your mysql password for the username>  redis:   url: <your redis url>   auth:     password: <your redis password>   milvus:   url: <your milvus url>   milvus:     auth:       token: <your milvus api-key> ```  With this, FreeChat will not automatically install these services, but rather use the configuration information to connect directly.  ### Running Locally You can also run FreeChat locally. Currently supported on MacOS and Linux (although only tested on MacOS). You need to install the Docker toolset and have a network that can access [Docker Hub](https://hub.docker.com/).  Once ready, enter the `scripts/` directory and run `local-run.sh`, which will download and run the necessary docker containers. After a successful startup, you can access `http://localhost` via a browser to see the locally running freechat.fun. Use `local-run.sh --help` to view the supported options of the script. Good luck!  ### Running in an IDE To run FreeChat in an IDE, you need to start all dependent services first but do not need to run the container for the FreeChat application itself. You can execute the `scripts/local-deps.sh` script to start services like `MySQL`, `Redis`, `Milvus`, etc., locally. Once done, open and debug `freechat-start/src/main/java/fun/freechat/Application.java`。Make sure you have set the following startup parameters: ```shell -Dspring.config.location=classpath:/application.yml,classpath:/application-local.yml \\ -DAPP_HOME=local-data/freechat \\ -Dspring.profiles.active=local ```  ### 使用 SDK #### Java - **Dependency** ```xml <dependency>   <groupId>fun.freechat</groupId>   <artifactId>freechat-sdk</artifactId>   <version>${freechat-sdk.version}</version> </dependency> ```  - **Example** ```java import fun.freechat.client.ApiClient; import fun.freechat.client.ApiException; import fun.freechat.client.Configuration; import fun.freechat.client.api.AccountApi; import fun.freechat.client.auth.ApiKeyAuth; import fun.freechat.client.model.UserDetailsDTO;  public class AccountClientExample {     public static void main(String[] args) {         ApiClient defaultClient = Configuration.getDefaultApiClient();         defaultClient.setBasePath(\"https://freechat.fun\");                  // Configure HTTP bearer authorization: bearerAuth         HttpBearerAuth bearerAuth = (HttpBearerAuth) defaultClient.getAuthentication(\"bearerAuth\");         bearerAuth.setBearerToken(\"FREECHAT_TOKEN\");          AccountApi apiInstance = new AccountApi(defaultClient);         try {             UserDetailsDTO result = apiInstance.getUserDetails();             System.out.println(result);         } catch (ApiException e) {             e.printStackTrace();         }     } } ```  #### Python - **Installation** ```shell pip install freechat-sdk ```  - **Example** ```python import freechat_sdk from freechat_sdk.rest import ApiException from pprint import pprint  # Defining the host is optional and defaults to https://freechat.fun # See configuration.py for a list of all supported configuration parameters. configuration = freechat_sdk.Configuration(     host = \"https://freechat.fun\" )  # Configure Bearer authorization: bearerAuth configuration = freechat_sdk.Configuration(     access_token = os.environ[\"FREECHAT_TOKEN\"] )  # Enter a context with an instance of the API client with freechat_sdk.ApiClient(configuration) as api_client:     # Create an instance of the API class     api_instance = freechat_sdk.AccountApi(api_client)      try:         details = api_instance.get_user_details()         pprint(details)     except ApiException as e:         print(\"Exception when calling AccountClient->get_user_details: %s\\n\" % e) ```  #### TypeScript - **Installation** ```shell npm install freechat-sdk --save ```  - **Example** Refer to [FreeChatApiContext.tsx](https://github.com/freechat-fun/freechat/blob/main/freechat-web/src/contexts/FreeChatApiProvider.tsx)  ## System Dependencies | | Projects | ---- | ---- | Application Framework | [Spring Boot](https://spring.io/projects/spring-boot/) | LLM Framework | [LangChain4j](https://docs.langchain4j.dev/) | Model Providers | [OpenAI](https://platform.openai.com/), [DashScope](https://dashscope.aliyun.com/) | Database Systems | [MySQL](https://www.mysql.com/), [Redis](https://redis.io/), [Milvus](https://milvus.io/) | OpenAPI Tools | [Springdoc-openapi](https://springdoc.org/), [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator), [OpenAPI Explorer](https://github.com/Authress-Engineering/openapi-explorer)  ## Collaboration ### Application Integration The FreeChat system is entirely oriented towards Open APIs. The site [freechat.fun](https://freechat.fun) is developed using its TypeScript SDK and hardly depends on private interfaces. You can use these online interfaces to develop your own applications or sites, making them fit your preferences. Currently, FreeChat is completely free with no paid plans (after all, users use their own API Key to call LLM services).  ### Model Integration FreeChat aims to explore AI virtual character technology with anthropomorphic characteristics. So far, it supports model services from OpenAI and DashScope ([HuggingFace](https://huggingface.co/) is also expected to be supported soon). However, we are more interested in supporting models that are under research and can endow AI with more personality traits. If you are researching this area and hope FreeChat supports your model, please contact us. We look forward to AI technology helping people create their own \"soul mates\" in the future.
 
-    The version of the OpenAPI document: 0.1.0
+    The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
-import io
 import warnings
-
 from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
-
-try:
-    from typing import Annotated
-except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import Field
+from typing import Any, Dict, List, Optional, Tuple, Union
 from typing_extensions import Annotated
-from pydantic import StrictStr
 
+from pydantic import Field, StrictBool, StrictStr
 from typing import List, Optional
+from typing_extensions import Annotated
 
-
-from freechat-sdk.api_client import ApiClient
-from freechat-sdk.api_response import ApiResponse
-from freechat-sdk.rest import RESTResponseType
+from freechat_sdk.api_client import ApiClient, RequestSerialized
+from freechat_sdk.api_response import ApiResponse
+from freechat_sdk.rest import RESTResponseType
 
 
 class OrganizationApi:
     """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
@@ -98,16 +88,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -166,16 +155,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -234,16 +222,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -251,27 +238,26 @@
     def _get_owners_serialize(
         self,
         all,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         if all is not None:
             
             _query_params.append(('all', all))
@@ -362,16 +348,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -430,16 +415,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -498,16 +482,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -515,27 +498,26 @@
     def _get_owners_dot_serialize(
         self,
         all,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         if all is not None:
             
             _query_params.append(('all', all))
@@ -630,16 +612,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -702,16 +683,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -774,16 +754,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -792,27 +771,26 @@
         self,
         username,
         all,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if username is not None:
             _path_params['username'] = username
         # process the query parameters
         if all is not None:
@@ -909,16 +887,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -981,16 +958,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1053,16 +1029,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -1071,27 +1046,26 @@
         self,
         username,
         all,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if username is not None:
             _path_params['username'] = username
         # process the query parameters
         if all is not None:
@@ -1184,16 +1158,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1252,16 +1225,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1320,16 +1292,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -1337,27 +1308,26 @@
     def _get_subordinates_serialize(
         self,
         all,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         if all is not None:
             
             _query_params.append(('all', all))
@@ -1448,16 +1418,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1516,16 +1485,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1584,16 +1552,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -1601,27 +1568,26 @@
     def _get_subordinates_dot_serialize(
         self,
         all,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         if all is not None:
             
             _query_params.append(('all', all))
@@ -1712,16 +1678,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1780,16 +1745,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1848,16 +1812,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[str]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -1865,27 +1828,26 @@
     def _list_subordinate_authorities_serialize(
         self,
         username,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if username is not None:
             _path_params['username'] = username
         # process the query parameters
         # process the header parameters
@@ -1974,16 +1936,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -2042,16 +2003,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -2110,16 +2070,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -2127,27 +2086,26 @@
     def _remove_subordinate_subordinates_tree_serialize(
         self,
         username,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if username is not None:
             _path_params['username'] = username
         # process the query parameters
         # process the header parameters
@@ -2240,16 +2198,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -2312,16 +2269,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -2384,16 +2340,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -2402,28 +2357,27 @@
         self,
         username,
         request_body,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
             'request_body': '',
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if username is not None:
             _path_params['username'] = username
         # process the query parameters
         # process the header parameters
@@ -2531,16 +2485,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -2603,16 +2556,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -2675,16 +2627,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -2693,28 +2644,27 @@
         self,
         username,
         request_body,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
             'request_body': '',
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if username is not None:
             _path_params['username'] = username
         # process the query parameters
         # process the header parameters
@@ -2822,16 +2772,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -2894,16 +2843,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -2966,16 +2914,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -2984,28 +2931,27 @@
         self,
         username,
         request_body,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
             'request_body': '',
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if username is not None:
             _path_params['username'] = username
         # process the query parameters
         # process the header parameters
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## Comparing `freechat-sdk/api/plugin_api.py` & `freechat_sdk/api/agent_api.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,85 +1,76 @@
 # coding: utf-8
 
 """
     FreeChat OpenAPI Definition
 
-    https://github.com/freechat-fun/freechat
+    # FreeChat: Create Some Friends for Yourself with AI  English | [中文版](https://github.com/freechat-fun/freechat/blob/main/README.zh-CN.md)  ## Introduction Welcome! FreeChat aims to build a cloud-native, robust, and quickly commercializable enterprise-level AI virtual character platform.  ## Features - Primarily uses Java and emphasizes **security, robustness, scalability, traceability, and maintainability**. - oasts **account systems and permission management**, supporting OAuth2 authentication. Introduces the \"organization\" concept and related permission constraint functions. - Extensively employs **distributed technologies and caching** to support **high concurrency** access. - Provides flexible character customization options, supports direct intervention in prompts, and supports **configuring multiple backends for each character**. - **Offers a comprehensive range of Open APIs**, with more than 180 interfaces and provides java/python/typescript SDKs. These interfaces enable easy construction of systems for end-users. - Supports setting **RAG** (Retrieval Augmented Generation) for characters. - Supports **long-term memory** for characters. - Supports setting **quota limits** for characters.  ## System Snapshots  ## Character Design ```mermaid flowchart TD     A(Character) --> B(Profile)     A --> C(Knowledge/RAG)     A --> D(Album)     A --> E(Backend-1)     A --> F(Backend-n...)     E --> G(Message Window)     E --> H(Long Term Memory Settings)     E --> I(Quota Limit)     E --> J(Chat Prompt Task)     E --> K(Greeting Prompt Task)     E --> L(Moderation Settings)     J --> M(Model & Parameters)     J --> N(API Keys)     J --> O(Prompt Refence)     J --> P(Tool Specifications)     O --> Q(Template)     O --> R(Variables)     O --> S(Version)     O --> T(...)     style K stroke-dasharray: 5, 5     style L stroke-dasharray: 5, 5     style P stroke-dasharray: 5, 5 ```  After setting up a unified persona and knowledge for a character, different backends can be configured. For example, different model may be adopted for different users based on cost considerations.  ## How to Play ### Online Website You can visit [freechat.fun](https://freechat.fun) to experience FreeChat. Share your designed AI character!  ### Running in a Kubernetes Cluster FreeChat is dedicated to the principles of cloud-native design. If you have a Kubernetes cluster, you can deploy FreeChat to your environment by following these steps:  1. Put the Kubernetes configuration file in the `configs/helm/` directory, named `kube-private.conf`. 2. Place the Helm configuration file in the same directory, named `values-private.yaml`. Make sure to reference the default `values.yaml` and customize the variables as needed. 3. Switch to the `scripts/` directory. 4. If needed, execute `install-in.sh` to deploy `ingress-nginx` to the Kubernetes cluster. 5. If needed, run `install-cm.sh` to deploy `cert-manager` on the Kubernetes cluster, which automatically issues certificates for domains specified in `ingress.hosts`. 6. Run `install-pvc.sh` to install PersistentVolumeClaim resources.      > By default, FreeChat operates files by accessing the \"local file system.\" You may want to use high-availability distributed storage in the cloud. As a cloud-native-designed system, we recommend interfacing through Kubernetes CSI to avoid individually adapting storage products for each cloud platform. Most cloud service providers offer cloud storage drivers for Kubernetes, with a series of predefined StorageClass resources. Please choose the appropriate configuration according to your actual needs and set it in Helm's `global.storageClass` option.     >      > *In the future, FreeChat may be refactored to use MinIO's APIs directly, as it is now installed in the Kubernetes cluster as a dependency (serving Milvus).*  7. Execute the `install.sh` script to install FreeChat and its dependencies. 8. FreeChat aims to provide Open API services. If you like the interactive experience of [freechat.fun](https://freechat.fun), run `install-web.sh` to deploy the front-end application. 9. Execute `restart.sh` to restart the service. 10. If you modified any Helm configuration files, use `upgrade.sh` to update the corresponding Kubernetes resources. 11. To remove specific resources, run the `uninstall*.sh` script corresponding to the resource you want to uninstall.  As a cloud-native application, the services FreeChat relies on are obtained and deployed to your cluster through the helm repository.  If you prefer cloud services with SLA (Service Level Agreement) guarantees, simply make the relevant settings in `configs/helm/values-private.yaml`: ```yaml bitnami:   mysql:     enabled: false   redis:     enabled: false   milvus:     enabled: false  mysql:   url: <your mysql url>   auth:     rootPassword: <your mysql root password>     username: <your mysql username>     password: <your mysql password for the username>  redis:   url: <your redis url>   auth:     password: <your redis password>   milvus:   url: <your milvus url>   milvus:     auth:       token: <your milvus api-key> ```  With this, FreeChat will not automatically install these services, but rather use the configuration information to connect directly.  ### Running Locally You can also run FreeChat locally. Currently supported on MacOS and Linux (although only tested on MacOS). You need to install the Docker toolset and have a network that can access [Docker Hub](https://hub.docker.com/).  Once ready, enter the `scripts/` directory and run `local-run.sh`, which will download and run the necessary docker containers. After a successful startup, you can access `http://localhost` via a browser to see the locally running freechat.fun. Use `local-run.sh --help` to view the supported options of the script. Good luck!  ### Running in an IDE To run FreeChat in an IDE, you need to start all dependent services first but do not need to run the container for the FreeChat application itself. You can execute the `scripts/local-deps.sh` script to start services like `MySQL`, `Redis`, `Milvus`, etc., locally. Once done, open and debug `freechat-start/src/main/java/fun/freechat/Application.java`。Make sure you have set the following startup parameters: ```shell -Dspring.config.location=classpath:/application.yml,classpath:/application-local.yml \\ -DAPP_HOME=local-data/freechat \\ -Dspring.profiles.active=local ```  ### 使用 SDK #### Java - **Dependency** ```xml <dependency>   <groupId>fun.freechat</groupId>   <artifactId>freechat-sdk</artifactId>   <version>${freechat-sdk.version}</version> </dependency> ```  - **Example** ```java import fun.freechat.client.ApiClient; import fun.freechat.client.ApiException; import fun.freechat.client.Configuration; import fun.freechat.client.api.AccountApi; import fun.freechat.client.auth.ApiKeyAuth; import fun.freechat.client.model.UserDetailsDTO;  public class AccountClientExample {     public static void main(String[] args) {         ApiClient defaultClient = Configuration.getDefaultApiClient();         defaultClient.setBasePath(\"https://freechat.fun\");                  // Configure HTTP bearer authorization: bearerAuth         HttpBearerAuth bearerAuth = (HttpBearerAuth) defaultClient.getAuthentication(\"bearerAuth\");         bearerAuth.setBearerToken(\"FREECHAT_TOKEN\");          AccountApi apiInstance = new AccountApi(defaultClient);         try {             UserDetailsDTO result = apiInstance.getUserDetails();             System.out.println(result);         } catch (ApiException e) {             e.printStackTrace();         }     } } ```  #### Python - **Installation** ```shell pip install freechat-sdk ```  - **Example** ```python import freechat_sdk from freechat_sdk.rest import ApiException from pprint import pprint  # Defining the host is optional and defaults to https://freechat.fun # See configuration.py for a list of all supported configuration parameters. configuration = freechat_sdk.Configuration(     host = \"https://freechat.fun\" )  # Configure Bearer authorization: bearerAuth configuration = freechat_sdk.Configuration(     access_token = os.environ[\"FREECHAT_TOKEN\"] )  # Enter a context with an instance of the API client with freechat_sdk.ApiClient(configuration) as api_client:     # Create an instance of the API class     api_instance = freechat_sdk.AccountApi(api_client)      try:         details = api_instance.get_user_details()         pprint(details)     except ApiException as e:         print(\"Exception when calling AccountClient->get_user_details: %s\\n\" % e) ```  #### TypeScript - **Installation** ```shell npm install freechat-sdk --save ```  - **Example** Refer to [FreeChatApiContext.tsx](https://github.com/freechat-fun/freechat/blob/main/freechat-web/src/contexts/FreeChatApiProvider.tsx)  ## System Dependencies | | Projects | ---- | ---- | Application Framework | [Spring Boot](https://spring.io/projects/spring-boot/) | LLM Framework | [LangChain4j](https://docs.langchain4j.dev/) | Model Providers | [OpenAI](https://platform.openai.com/), [DashScope](https://dashscope.aliyun.com/) | Database Systems | [MySQL](https://www.mysql.com/), [Redis](https://redis.io/), [Milvus](https://milvus.io/) | OpenAPI Tools | [Springdoc-openapi](https://springdoc.org/), [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator), [OpenAPI Explorer](https://github.com/Authress-Engineering/openapi-explorer)  ## Collaboration ### Application Integration The FreeChat system is entirely oriented towards Open APIs. The site [freechat.fun](https://freechat.fun) is developed using its TypeScript SDK and hardly depends on private interfaces. You can use these online interfaces to develop your own applications or sites, making them fit your preferences. Currently, FreeChat is completely free with no paid plans (after all, users use their own API Key to call LLM services).  ### Model Integration FreeChat aims to explore AI virtual character technology with anthropomorphic characteristics. So far, it supports model services from OpenAI and DashScope ([HuggingFace](https://huggingface.co/) is also expected to be supported soon). However, we are more interested in supporting models that are under research and can endow AI with more personality traits. If you are researching this area and hope FreeChat supports your model, please contact us. We look forward to AI technology helping people create their own \"soul mates\" in the future.
 
-    The version of the OpenAPI document: 0.1.0
+    The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
-import io
 import warnings
-
 from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
-
-try:
-    from typing import Annotated
-except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import Field
+from typing import Any, Dict, List, Optional, Tuple, Union
 from typing_extensions import Annotated
-from pydantic import StrictStr
 
+from pydantic import Field, StrictBool, StrictInt, StrictStr
 from typing import List
-
-from freechat-sdk.models.plugin_create_dto import PluginCreateDTO
-from freechat-sdk.models.plugin_details_dto import PluginDetailsDTO
-from freechat-sdk.models.plugin_query_dto import PluginQueryDTO
-from freechat-sdk.models.plugin_summary_dto import PluginSummaryDTO
-from freechat-sdk.models.plugin_update_dto import PluginUpdateDTO
-
-from freechat-sdk.api_client import ApiClient
-from freechat-sdk.api_response import ApiResponse
-from freechat-sdk.rest import RESTResponseType
+from typing_extensions import Annotated
+from freechat_sdk.models.agent_create_dto import AgentCreateDTO
+from freechat_sdk.models.agent_details_dto import AgentDetailsDTO
+from freechat_sdk.models.agent_item_for_name_dto import AgentItemForNameDTO
+from freechat_sdk.models.agent_query_dto import AgentQueryDTO
+from freechat_sdk.models.agent_summary_dto import AgentSummaryDTO
+from freechat_sdk.models.agent_update_dto import AgentUpdateDTO
+
+from freechat_sdk.api_client import ApiClient, RequestSerialized
+from freechat_sdk.api_response import ApiResponse
+from freechat_sdk.rest import RESTResponseType
 
 
-class PluginApi:
+class AgentApi:
     """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     def __init__(self, api_client=None) -> None:
         if api_client is None:
             api_client = ApiClient.get_default()
         self.api_client = api_client
 
 
     @validate_call
-    def batch_search_plugin_details(
+    def batch_search_agent_details(
         self,
-        plugin_query_dto: Annotated[List[PluginQueryDTO], Field(description="Query conditions")],
+        agent_query_dto: Annotated[List[AgentQueryDTO], Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[List[PluginDetailsDTO]]:
-        """Batch Search Plugin Details
+    ) -> List[List[AgentDetailsDTO]]:
+        """Batch Search Agent Details
 
-        Batch call shortcut for /api/v1/plugin/details/search.
+        Batch call shortcut for /api/v1/agent/details/search.
 
-        :param plugin_query_dto: Query conditions (required)
-        :type plugin_query_dto: List[PluginQueryDTO]
+        :param agent_query_dto: Query conditions (required)
+        :type agent_query_dto: List[AgentQueryDTO]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -94,60 +85,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._batch_search_plugin_details_serialize(
-            plugin_query_dto=plugin_query_dto,
+        _param = self._batch_search_agent_details_serialize(
+            agent_query_dto=agent_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[List[PluginDetailsDTO]]"
-            
+            '200': "List[List[AgentDetailsDTO]]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def batch_search_plugin_details_with_http_info(
+    def batch_search_agent_details_with_http_info(
         self,
-        plugin_query_dto: Annotated[List[PluginQueryDTO], Field(description="Query conditions")],
+        agent_query_dto: Annotated[List[AgentQueryDTO], Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[List[PluginDetailsDTO]]]:
-        """Batch Search Plugin Details
+    ) -> ApiResponse[List[List[AgentDetailsDTO]]]:
+        """Batch Search Agent Details
 
-        Batch call shortcut for /api/v1/plugin/details/search.
+        Batch call shortcut for /api/v1/agent/details/search.
 
-        :param plugin_query_dto: Query conditions (required)
-        :type plugin_query_dto: List[PluginQueryDTO]
+        :param agent_query_dto: Query conditions (required)
+        :type agent_query_dto: List[AgentQueryDTO]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -162,60 +152,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._batch_search_plugin_details_serialize(
-            plugin_query_dto=plugin_query_dto,
+        _param = self._batch_search_agent_details_serialize(
+            agent_query_dto=agent_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[List[PluginDetailsDTO]]"
-            
+            '200': "List[List[AgentDetailsDTO]]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def batch_search_plugin_details_without_preload_content(
+    def batch_search_agent_details_without_preload_content(
         self,
-        plugin_query_dto: Annotated[List[PluginQueryDTO], Field(description="Query conditions")],
+        agent_query_dto: Annotated[List[AgentQueryDTO], Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Batch Search Plugin Details
+        """Batch Search Agent Details
 
-        Batch call shortcut for /api/v1/plugin/details/search.
+        Batch call shortcut for /api/v1/agent/details/search.
 
-        :param plugin_query_dto: Query conditions (required)
-        :type plugin_query_dto: List[PluginQueryDTO]
+        :param agent_query_dto: Query conditions (required)
+        :type agent_query_dto: List[AgentQueryDTO]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -230,63 +219,61 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._batch_search_plugin_details_serialize(
-            plugin_query_dto=plugin_query_dto,
+        _param = self._batch_search_agent_details_serialize(
+            agent_query_dto=agent_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[List[PluginDetailsDTO]]"
-            
+            '200': "List[List[AgentDetailsDTO]]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _batch_search_plugin_details_serialize(
+    def _batch_search_agent_details_serialize(
         self,
-        plugin_query_dto,
+        agent_query_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
-            'PluginQueryDTO': '',
+            'AgentQueryDTO': '',
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
-        if plugin_query_dto is not None:
-            _body_params = plugin_query_dto
+        if agent_query_dto is not None:
+            _body_params = agent_query_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
                 'application/json'
             ]
@@ -309,15 +296,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/plugin/batch/details/search',
+            resource_path='/api/v1/agent/batch/details/search',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -326,36 +313,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def batch_search_plugin_summary(
+    def batch_search_agent_summary(
         self,
-        plugin_query_dto: Annotated[List[PluginQueryDTO], Field(description="Query conditions")],
+        agent_query_dto: Annotated[List[AgentQueryDTO], Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[List[PluginSummaryDTO]]:
-        """Batch Search Plugin Summaries
+    ) -> List[List[AgentSummaryDTO]]:
+        """Batch Search Agent Summaries
 
-        Batch call shortcut for /api/v1/plugin/search.
+        Batch call shortcut for /api/v1/agent/search.
 
-        :param plugin_query_dto: Query conditions (required)
-        :type plugin_query_dto: List[PluginQueryDTO]
+        :param agent_query_dto: Query conditions (required)
+        :type agent_query_dto: List[AgentQueryDTO]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -370,60 +357,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._batch_search_plugin_summary_serialize(
-            plugin_query_dto=plugin_query_dto,
+        _param = self._batch_search_agent_summary_serialize(
+            agent_query_dto=agent_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[List[PluginSummaryDTO]]"
-            
+            '200': "List[List[AgentSummaryDTO]]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def batch_search_plugin_summary_with_http_info(
+    def batch_search_agent_summary_with_http_info(
         self,
-        plugin_query_dto: Annotated[List[PluginQueryDTO], Field(description="Query conditions")],
+        agent_query_dto: Annotated[List[AgentQueryDTO], Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[List[PluginSummaryDTO]]]:
-        """Batch Search Plugin Summaries
+    ) -> ApiResponse[List[List[AgentSummaryDTO]]]:
+        """Batch Search Agent Summaries
 
-        Batch call shortcut for /api/v1/plugin/search.
+        Batch call shortcut for /api/v1/agent/search.
 
-        :param plugin_query_dto: Query conditions (required)
-        :type plugin_query_dto: List[PluginQueryDTO]
+        :param agent_query_dto: Query conditions (required)
+        :type agent_query_dto: List[AgentQueryDTO]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -438,60 +424,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._batch_search_plugin_summary_serialize(
-            plugin_query_dto=plugin_query_dto,
+        _param = self._batch_search_agent_summary_serialize(
+            agent_query_dto=agent_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[List[PluginSummaryDTO]]"
-            
+            '200': "List[List[AgentSummaryDTO]]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def batch_search_plugin_summary_without_preload_content(
+    def batch_search_agent_summary_without_preload_content(
         self,
-        plugin_query_dto: Annotated[List[PluginQueryDTO], Field(description="Query conditions")],
+        agent_query_dto: Annotated[List[AgentQueryDTO], Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Batch Search Plugin Summaries
+        """Batch Search Agent Summaries
 
-        Batch call shortcut for /api/v1/plugin/search.
+        Batch call shortcut for /api/v1/agent/search.
 
-        :param plugin_query_dto: Query conditions (required)
-        :type plugin_query_dto: List[PluginQueryDTO]
+        :param agent_query_dto: Query conditions (required)
+        :type agent_query_dto: List[AgentQueryDTO]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -506,63 +491,61 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._batch_search_plugin_summary_serialize(
-            plugin_query_dto=plugin_query_dto,
+        _param = self._batch_search_agent_summary_serialize(
+            agent_query_dto=agent_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[List[PluginSummaryDTO]]"
-            
+            '200': "List[List[AgentSummaryDTO]]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _batch_search_plugin_summary_serialize(
+    def _batch_search_agent_summary_serialize(
         self,
-        plugin_query_dto,
+        agent_query_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
-            'PluginQueryDTO': '',
+            'AgentQueryDTO': '',
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
-        if plugin_query_dto is not None:
-            _body_params = plugin_query_dto
+        if agent_query_dto is not None:
+            _body_params = agent_query_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
                 'application/json'
             ]
@@ -585,15 +568,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/plugin/batch/search',
+            resource_path='/api/v1/agent/batch/search',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -602,36 +585,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def count_plugins(
+    def clone_agent(
         self,
-        plugin_query_dto: Annotated[PluginQueryDTO, Field(description="Query conditions")],
+        agent_id: Annotated[StrictInt, Field(description="The referenced agentId")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> int:
-        """Calculate Number of Plugins
+        """Clone Agent
 
-        Calculate the number of plugins according to the specified query conditions.
+        Enter the agentId, generate a new record, the content is basically the same as the original agent, but the following fields are different: - Version number is 1 - Visibility is private - The parent agent is the source agentId - The creation time is the current moment.  - All statistical indicators are zeroed.  Return the new agentId. 
 
-        :param plugin_query_dto: Query conditions (required)
-        :type plugin_query_dto: PluginQueryDTO
+        :param agent_id: The referenced agentId (required)
+        :type agent_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -646,60 +629,317 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._count_plugins_serialize(
-            plugin_query_dto=plugin_query_dto,
+        _param = self._clone_agent_serialize(
+            agent_id=agent_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def count_plugins_with_http_info(
+    def clone_agent_with_http_info(
         self,
-        plugin_query_dto: Annotated[PluginQueryDTO, Field(description="Query conditions")],
+        agent_id: Annotated[StrictInt, Field(description="The referenced agentId")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[int]:
-        """Calculate Number of Plugins
+        """Clone Agent
+
+        Enter the agentId, generate a new record, the content is basically the same as the original agent, but the following fields are different: - Version number is 1 - Visibility is private - The parent agent is the source agentId - The creation time is the current moment.  - All statistical indicators are zeroed.  Return the new agentId. 
+
+        :param agent_id: The referenced agentId (required)
+        :type agent_id: int
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._clone_agent_serialize(
+            agent_id=agent_id,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "int",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        )
+
+
+    @validate_call
+    def clone_agent_without_preload_content(
+        self,
+        agent_id: Annotated[StrictInt, Field(description="The referenced agentId")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> RESTResponseType:
+        """Clone Agent
+
+        Enter the agentId, generate a new record, the content is basically the same as the original agent, but the following fields are different: - Version number is 1 - Visibility is private - The parent agent is the source agentId - The creation time is the current moment.  - All statistical indicators are zeroed.  Return the new agentId. 
+
+        :param agent_id: The referenced agentId (required)
+        :type agent_id: int
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._clone_agent_serialize(
+            agent_id=agent_id,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "int",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        return response_data.response
+
+
+    def _clone_agent_serialize(
+        self,
+        agent_id,
+        _request_auth,
+        _content_type,
+        _headers,
+        _host_index,
+    ) -> RequestSerialized:
+
+        _host = None
+
+        _collection_formats: Dict[str, str] = {
+        }
+
+        _path_params: Dict[str, str] = {}
+        _query_params: List[Tuple[str, str]] = []
+        _header_params: Dict[str, Optional[str]] = _headers or {}
+        _form_params: List[Tuple[str, str]] = []
+        _files: Dict[str, Union[str, bytes]] = {}
+        _body_params: Optional[bytes] = None
+
+        # process the path parameters
+        if agent_id is not None:
+            _path_params['agentId'] = agent_id
+        # process the query parameters
+        # process the header parameters
+        # process the form parameters
+        # process the body parameter
+
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            [
+                'application/json'
+            ]
+        )
+
+
+        # authentication setting
+        _auth_settings: List[str] = [
+            'bearerAuth'
+        ]
+
+        return self.api_client.param_serialize(
+            method='POST',
+            resource_path='/api/v1/agent/clone/{agentId}',
+            path_params=_path_params,
+            query_params=_query_params,
+            header_params=_header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            auth_settings=_auth_settings,
+            collection_formats=_collection_formats,
+            _host=_host,
+            _request_auth=_request_auth
+        )
+
+
+
+
+    @validate_call
+    def clone_agents(
+        self,
+        request_body: Annotated[List[StrictInt], Field(description="List of agent information to be created")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> List[int]:
+        """Batch Clone Agents
+
+        Batch clone multiple agents. Ensure transactionality, return the agentId list after success.
+
+        :param request_body: List of agent information to be created (required)
+        :type request_body: List[int]
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
 
-        Calculate the number of plugins according to the specified query conditions.
+        _param = self._clone_agents_serialize(
+            request_body=request_body,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
 
-        :param plugin_query_dto: Query conditions (required)
-        :type plugin_query_dto: PluginQueryDTO
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "List[int]",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        ).data
+
+
+    @validate_call
+    def clone_agents_with_http_info(
+        self,
+        request_body: Annotated[List[StrictInt], Field(description="List of agent information to be created")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> ApiResponse[List[int]]:
+        """Batch Clone Agents
+
+        Batch clone multiple agents. Ensure transactionality, return the agentId list after success.
+
+        :param request_body: List of agent information to be created (required)
+        :type request_body: List[int]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -714,60 +954,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._count_plugins_serialize(
-            plugin_query_dto=plugin_query_dto,
+        _param = self._clone_agents_serialize(
+            request_body=request_body,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "List[int]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def count_plugins_without_preload_content(
+    def clone_agents_without_preload_content(
         self,
-        plugin_query_dto: Annotated[PluginQueryDTO, Field(description="Query conditions")],
+        request_body: Annotated[List[StrictInt], Field(description="List of agent information to be created")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Calculate Number of Plugins
+        """Batch Clone Agents
 
-        Calculate the number of plugins according to the specified query conditions.
+        Batch clone multiple agents. Ensure transactionality, return the agentId list after success.
 
-        :param plugin_query_dto: Query conditions (required)
-        :type plugin_query_dto: PluginQueryDTO
+        :param request_body: List of agent information to be created (required)
+        :type request_body: List[int]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -782,62 +1021,61 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._count_plugins_serialize(
-            plugin_query_dto=plugin_query_dto,
+        _param = self._clone_agents_serialize(
+            request_body=request_body,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "List[int]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _count_plugins_serialize(
+    def _clone_agents_serialize(
         self,
-        plugin_query_dto,
+        request_body,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
+            'request_body': '',
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
-        if plugin_query_dto is not None:
-            _body_params = plugin_query_dto
+        if request_body is not None:
+            _body_params = request_body
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
                 'application/json'
             ]
@@ -860,15 +1098,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/plugin/count',
+            resource_path='/api/v1/agent/batch/clone',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -877,36 +1115,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def create_plugin(
+    def count_agents(
         self,
-        plugin_create_dto: Annotated[PluginCreateDTO, Field(description="Information of the plugin to be created")],
+        agent_query_dto: Annotated[AgentQueryDTO, Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> str:
-        """Create Plugin
+    ) -> int:
+        """Calculate Number of Agents
 
-        Create a plugin, required fields: - Plugin name - Plugin manifestInfo (URL or JSON) - Plugin apiInfo (URL or JSON)  Limitations: - Name: 100 characters - Example: 2000 characters - Tags: 5 
+        Calculate the number of agents according to the specified query conditions.
 
-        :param plugin_create_dto: Information of the plugin to be created (required)
-        :type plugin_create_dto: PluginCreateDTO
+        :param agent_query_dto: Query conditions (required)
+        :type agent_query_dto: AgentQueryDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -921,60 +1159,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_plugin_serialize(
-            plugin_create_dto=plugin_create_dto,
+        _param = self._count_agents_serialize(
+            agent_query_dto=agent_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def create_plugin_with_http_info(
+    def count_agents_with_http_info(
         self,
-        plugin_create_dto: Annotated[PluginCreateDTO, Field(description="Information of the plugin to be created")],
+        agent_query_dto: Annotated[AgentQueryDTO, Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[str]:
-        """Create Plugin
+    ) -> ApiResponse[int]:
+        """Calculate Number of Agents
 
-        Create a plugin, required fields: - Plugin name - Plugin manifestInfo (URL or JSON) - Plugin apiInfo (URL or JSON)  Limitations: - Name: 100 characters - Example: 2000 characters - Tags: 5 
+        Calculate the number of agents according to the specified query conditions.
 
-        :param plugin_create_dto: Information of the plugin to be created (required)
-        :type plugin_create_dto: PluginCreateDTO
+        :param agent_query_dto: Query conditions (required)
+        :type agent_query_dto: AgentQueryDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -989,60 +1226,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_plugin_serialize(
-            plugin_create_dto=plugin_create_dto,
+        _param = self._count_agents_serialize(
+            agent_query_dto=agent_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def create_plugin_without_preload_content(
+    def count_agents_without_preload_content(
         self,
-        plugin_create_dto: Annotated[PluginCreateDTO, Field(description="Information of the plugin to be created")],
+        agent_query_dto: Annotated[AgentQueryDTO, Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Create Plugin
+        """Calculate Number of Agents
 
-        Create a plugin, required fields: - Plugin name - Plugin manifestInfo (URL or JSON) - Plugin apiInfo (URL or JSON)  Limitations: - Name: 100 characters - Example: 2000 characters - Tags: 5 
+        Calculate the number of agents according to the specified query conditions.
 
-        :param plugin_create_dto: Information of the plugin to be created (required)
-        :type plugin_create_dto: PluginCreateDTO
+        :param agent_query_dto: Query conditions (required)
+        :type agent_query_dto: AgentQueryDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1057,68 +1293,66 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_plugin_serialize(
-            plugin_create_dto=plugin_create_dto,
+        _param = self._count_agents_serialize(
+            agent_query_dto=agent_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _create_plugin_serialize(
+    def _count_agents_serialize(
         self,
-        plugin_create_dto,
+        agent_query_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
-        if plugin_create_dto is not None:
-            _body_params = plugin_create_dto
+        if agent_query_dto is not None:
+            _body_params = agent_query_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
-                'text/plain'
+                'application/json'
             ]
         )
 
         # set the HTTP header `Content-Type`
         if _content_type:
             _header_params['Content-Type'] = _content_type
         else:
@@ -1135,15 +1369,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/plugin',
+            resource_path='/api/v1/agent/count',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -1152,36 +1386,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def create_plugins(
+    def create_agent(
         self,
-        plugin_create_dto: Annotated[List[PluginCreateDTO], Field(description="List of plugin information to be created")],
+        agent_create_dto: Annotated[AgentCreateDTO, Field(description="Information of the agent to be created")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[str]:
-        """Batch Create Plugins
+    ) -> int:
+        """Create Agent
 
-        Batch create multiple plugins. Ensure transactionality, return the pluginId list after success.
+        Create a agent, ignore required fields: - Agent name - Agent configuration  Limitations: - Description: 300 characters - Configuration: 2000 characters - Example: 2000 characters - Tags: 5 - Parameters: 10 
 
-        :param plugin_create_dto: List of plugin information to be created (required)
-        :type plugin_create_dto: List[PluginCreateDTO]
+        :param agent_create_dto: Information of the agent to be created (required)
+        :type agent_create_dto: AgentCreateDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1196,60 +1430,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_plugins_serialize(
-            plugin_create_dto=plugin_create_dto,
+        _param = self._create_agent_serialize(
+            agent_create_dto=agent_create_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def create_plugins_with_http_info(
+    def create_agent_with_http_info(
         self,
-        plugin_create_dto: Annotated[List[PluginCreateDTO], Field(description="List of plugin information to be created")],
+        agent_create_dto: Annotated[AgentCreateDTO, Field(description="Information of the agent to be created")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[str]]:
-        """Batch Create Plugins
+    ) -> ApiResponse[int]:
+        """Create Agent
 
-        Batch create multiple plugins. Ensure transactionality, return the pluginId list after success.
+        Create a agent, ignore required fields: - Agent name - Agent configuration  Limitations: - Description: 300 characters - Configuration: 2000 characters - Example: 2000 characters - Tags: 5 - Parameters: 10 
 
-        :param plugin_create_dto: List of plugin information to be created (required)
-        :type plugin_create_dto: List[PluginCreateDTO]
+        :param agent_create_dto: Information of the agent to be created (required)
+        :type agent_create_dto: AgentCreateDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1264,60 +1497,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_plugins_serialize(
-            plugin_create_dto=plugin_create_dto,
+        _param = self._create_agent_serialize(
+            agent_create_dto=agent_create_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def create_plugins_without_preload_content(
+    def create_agent_without_preload_content(
         self,
-        plugin_create_dto: Annotated[List[PluginCreateDTO], Field(description="List of plugin information to be created")],
+        agent_create_dto: Annotated[AgentCreateDTO, Field(description="Information of the agent to be created")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Batch Create Plugins
+        """Create Agent
 
-        Batch create multiple plugins. Ensure transactionality, return the pluginId list after success.
+        Create a agent, ignore required fields: - Agent name - Agent configuration  Limitations: - Description: 300 characters - Configuration: 2000 characters - Example: 2000 characters - Tags: 5 - Parameters: 10 
 
-        :param plugin_create_dto: List of plugin information to be created (required)
-        :type plugin_create_dto: List[PluginCreateDTO]
+        :param agent_create_dto: Information of the agent to be created (required)
+        :type agent_create_dto: AgentCreateDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1332,63 +1564,60 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_plugins_serialize(
-            plugin_create_dto=plugin_create_dto,
+        _param = self._create_agent_serialize(
+            agent_create_dto=agent_create_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _create_plugins_serialize(
+    def _create_agent_serialize(
         self,
-        plugin_create_dto,
+        agent_create_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
-            'PluginCreateDTO': '',
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
-        if plugin_create_dto is not None:
-            _body_params = plugin_create_dto
+        if agent_create_dto is not None:
+            _body_params = agent_create_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
                 'application/json'
             ]
@@ -1411,15 +1640,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/plugin/batch',
+            resource_path='/api/v1/agent',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -1428,36 +1657,308 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def delete_plugin(
+    def create_agents(
+        self,
+        agent_create_dto: Annotated[List[AgentCreateDTO], Field(description="List of agent information to be created")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> List[int]:
+        """Batch Create Agents
+
+        Batch create multiple agents. Ensure transactionality, return the agentId list after success.
+
+        :param agent_create_dto: List of agent information to be created (required)
+        :type agent_create_dto: List[AgentCreateDTO]
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._create_agents_serialize(
+            agent_create_dto=agent_create_dto,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "List[int]",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        ).data
+
+
+    @validate_call
+    def create_agents_with_http_info(
+        self,
+        agent_create_dto: Annotated[List[AgentCreateDTO], Field(description="List of agent information to be created")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> ApiResponse[List[int]]:
+        """Batch Create Agents
+
+        Batch create multiple agents. Ensure transactionality, return the agentId list after success.
+
+        :param agent_create_dto: List of agent information to be created (required)
+        :type agent_create_dto: List[AgentCreateDTO]
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._create_agents_serialize(
+            agent_create_dto=agent_create_dto,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "List[int]",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        )
+
+
+    @validate_call
+    def create_agents_without_preload_content(
         self,
-        plugin_id: Annotated[StrictStr, Field(description="The pluginId to be deleted")],
+        agent_create_dto: Annotated[List[AgentCreateDTO], Field(description="List of agent information to be created")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> RESTResponseType:
+        """Batch Create Agents
+
+        Batch create multiple agents. Ensure transactionality, return the agentId list after success.
+
+        :param agent_create_dto: List of agent information to be created (required)
+        :type agent_create_dto: List[AgentCreateDTO]
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._create_agents_serialize(
+            agent_create_dto=agent_create_dto,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "List[int]",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        return response_data.response
+
+
+    def _create_agents_serialize(
+        self,
+        agent_create_dto,
+        _request_auth,
+        _content_type,
+        _headers,
+        _host_index,
+    ) -> RequestSerialized:
+
+        _host = None
+
+        _collection_formats: Dict[str, str] = {
+            'AgentCreateDTO': '',
+        }
+
+        _path_params: Dict[str, str] = {}
+        _query_params: List[Tuple[str, str]] = []
+        _header_params: Dict[str, Optional[str]] = _headers or {}
+        _form_params: List[Tuple[str, str]] = []
+        _files: Dict[str, Union[str, bytes]] = {}
+        _body_params: Optional[bytes] = None
+
+        # process the path parameters
+        # process the query parameters
+        # process the header parameters
+        # process the form parameters
+        # process the body parameter
+        if agent_create_dto is not None:
+            _body_params = agent_create_dto
+
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            [
+                'application/json'
+            ]
+        )
+
+        # set the HTTP header `Content-Type`
+        if _content_type:
+            _header_params['Content-Type'] = _content_type
+        else:
+            _default_content_type = (
+                self.api_client.select_header_content_type(
+                    [
+                        'application/json'
+                    ]
+                )
+            )
+            if _default_content_type is not None:
+                _header_params['Content-Type'] = _default_content_type
+
+        # authentication setting
+        _auth_settings: List[str] = [
+            'bearerAuth'
+        ]
+
+        return self.api_client.param_serialize(
+            method='POST',
+            resource_path='/api/v1/agent/batch',
+            path_params=_path_params,
+            query_params=_query_params,
+            header_params=_header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            auth_settings=_auth_settings,
+            collection_formats=_collection_formats,
+            _host=_host,
+            _request_auth=_request_auth
+        )
+
+
+
+
+    @validate_call
+    def delete_agent(
+        self,
+        agent_id: Annotated[StrictInt, Field(description="AgentId to be deleted")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> bool:
-        """Delete Plugin
+        """Delete Agent
 
-        Delete plugin. Returns success or failure.
+        Delete agent. Return success or failure.
 
-        :param plugin_id: The pluginId to be deleted (required)
-        :type plugin_id: str
+        :param agent_id: AgentId to be deleted (required)
+        :type agent_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1472,60 +1973,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_plugin_serialize(
-            plugin_id=plugin_id,
+        _param = self._delete_agent_serialize(
+            agent_id=agent_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def delete_plugin_with_http_info(
+    def delete_agent_with_http_info(
         self,
-        plugin_id: Annotated[StrictStr, Field(description="The pluginId to be deleted")],
+        agent_id: Annotated[StrictInt, Field(description="AgentId to be deleted")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[bool]:
-        """Delete Plugin
+        """Delete Agent
 
-        Delete plugin. Returns success or failure.
+        Delete agent. Return success or failure.
 
-        :param plugin_id: The pluginId to be deleted (required)
-        :type plugin_id: str
+        :param agent_id: AgentId to be deleted (required)
+        :type agent_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1540,60 +2040,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_plugin_serialize(
-            plugin_id=plugin_id,
+        _param = self._delete_agent_serialize(
+            agent_id=agent_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def delete_plugin_without_preload_content(
+    def delete_agent_without_preload_content(
         self,
-        plugin_id: Annotated[StrictStr, Field(description="The pluginId to be deleted")],
+        agent_id: Annotated[StrictInt, Field(description="AgentId to be deleted")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Delete Plugin
+        """Delete Agent
 
-        Delete plugin. Returns success or failure.
+        Delete agent. Return success or failure.
 
-        :param plugin_id: The pluginId to be deleted (required)
-        :type plugin_id: str
+        :param agent_id: AgentId to be deleted (required)
+        :type agent_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1608,58 +2107,56 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_plugin_serialize(
-            plugin_id=plugin_id,
+        _param = self._delete_agent_serialize(
+            agent_id=agent_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _delete_plugin_serialize(
+    def _delete_agent_serialize(
         self,
-        plugin_id,
+        agent_id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if plugin_id is not None:
-            _path_params['pluginId'] = plugin_id
+        if agent_id is not None:
+            _path_params['agentId'] = agent_id
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
@@ -1673,15 +2170,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='DELETE',
-            resource_path='/api/v1/plugin/{pluginId}',
+            resource_path='/api/v1/agent/{agentId}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -1690,36 +2187,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def delete_plugins(
+    def delete_agents(
         self,
-        request_body: Annotated[List[StrictStr], Field(description="List of pluginIds to be deleted")],
+        request_body: Annotated[List[StrictInt], Field(description="List of agentId to be deleted")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[str]:
-        """Batch Delete Plugins
+    ) -> List[int]:
+        """Batch Delete Agents
 
-        Delete multiple plugins. Ensure transactionality, return the list of successfully deleted pluginIds.
+        Delete multiple agents. Ensure transactionality, return the list of successfully deleted agentId.
 
-        :param request_body: List of pluginIds to be deleted (required)
-        :type request_body: List[str]
+        :param request_body: List of agentId to be deleted (required)
+        :type request_body: List[int]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1734,60 +2231,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_plugins_serialize(
+        _param = self._delete_agents_serialize(
             request_body=request_body,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[int]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def delete_plugins_with_http_info(
+    def delete_agents_with_http_info(
         self,
-        request_body: Annotated[List[StrictStr], Field(description="List of pluginIds to be deleted")],
+        request_body: Annotated[List[StrictInt], Field(description="List of agentId to be deleted")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[str]]:
-        """Batch Delete Plugins
+    ) -> ApiResponse[List[int]]:
+        """Batch Delete Agents
 
-        Delete multiple plugins. Ensure transactionality, return the list of successfully deleted pluginIds.
+        Delete multiple agents. Ensure transactionality, return the list of successfully deleted agentId.
 
-        :param request_body: List of pluginIds to be deleted (required)
-        :type request_body: List[str]
+        :param request_body: List of agentId to be deleted (required)
+        :type request_body: List[int]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1802,60 +2298,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_plugins_serialize(
+        _param = self._delete_agents_serialize(
             request_body=request_body,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[int]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def delete_plugins_without_preload_content(
+    def delete_agents_without_preload_content(
         self,
-        request_body: Annotated[List[StrictStr], Field(description="List of pluginIds to be deleted")],
+        request_body: Annotated[List[StrictInt], Field(description="List of agentId to be deleted")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Batch Delete Plugins
+        """Batch Delete Agents
 
-        Delete multiple plugins. Ensure transactionality, return the list of successfully deleted pluginIds.
+        Delete multiple agents. Ensure transactionality, return the list of successfully deleted agentId.
 
-        :param request_body: List of pluginIds to be deleted (required)
-        :type request_body: List[str]
+        :param request_body: List of agentId to be deleted (required)
+        :type request_body: List[int]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1870,54 +2365,52 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_plugins_serialize(
+        _param = self._delete_agents_serialize(
             request_body=request_body,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[int]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _delete_plugins_serialize(
+    def _delete_agents_serialize(
         self,
         request_body,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
             'request_body': '',
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
@@ -1949,15 +2442,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='DELETE',
-            resource_path='/api/v1/plugin/batch',
+            resource_path='/api/v1/agent/batch/delete',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -1966,36 +2459,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def get_plugin_details(
+    def get_agent_details(
         self,
-        plugin_id: Annotated[StrictStr, Field(description="PluginId to be obtained")],
+        agent_id: Annotated[StrictInt, Field(description="AgentId to be obtained")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> PluginDetailsDTO:
-        """Get Plugin Details
+    ) -> AgentDetailsDTO:
+        """Get Agent Details
 
-        Get plugin detailed information.
+        Get agent detailed information.
 
-        :param plugin_id: PluginId to be obtained (required)
-        :type plugin_id: str
+        :param agent_id: AgentId to be obtained (required)
+        :type agent_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2010,60 +2503,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_plugin_details_serialize(
-            plugin_id=plugin_id,
+        _param = self._get_agent_details_serialize(
+            agent_id=agent_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PluginDetailsDTO"
-            
+            '200': "AgentDetailsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def get_plugin_details_with_http_info(
+    def get_agent_details_with_http_info(
         self,
-        plugin_id: Annotated[StrictStr, Field(description="PluginId to be obtained")],
+        agent_id: Annotated[StrictInt, Field(description="AgentId to be obtained")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[PluginDetailsDTO]:
-        """Get Plugin Details
+    ) -> ApiResponse[AgentDetailsDTO]:
+        """Get Agent Details
 
-        Get plugin detailed information.
+        Get agent detailed information.
 
-        :param plugin_id: PluginId to be obtained (required)
-        :type plugin_id: str
+        :param agent_id: AgentId to be obtained (required)
+        :type agent_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2078,60 +2570,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_plugin_details_serialize(
-            plugin_id=plugin_id,
+        _param = self._get_agent_details_serialize(
+            agent_id=agent_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PluginDetailsDTO"
-            
+            '200': "AgentDetailsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def get_plugin_details_without_preload_content(
+    def get_agent_details_without_preload_content(
         self,
-        plugin_id: Annotated[StrictStr, Field(description="PluginId to be obtained")],
+        agent_id: Annotated[StrictInt, Field(description="AgentId to be obtained")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Get Plugin Details
+        """Get Agent Details
 
-        Get plugin detailed information.
+        Get agent detailed information.
 
-        :param plugin_id: PluginId to be obtained (required)
-        :type plugin_id: str
+        :param agent_id: AgentId to be obtained (required)
+        :type agent_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2146,58 +2637,56 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_plugin_details_serialize(
-            plugin_id=plugin_id,
+        _param = self._get_agent_details_serialize(
+            agent_id=agent_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PluginDetailsDTO"
-            
+            '200': "AgentDetailsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _get_plugin_details_serialize(
+    def _get_agent_details_serialize(
         self,
-        plugin_id,
+        agent_id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if plugin_id is not None:
-            _path_params['pluginId'] = plugin_id
+        if agent_id is not None:
+            _path_params['agentId'] = agent_id
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
@@ -2211,15 +2700,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='GET',
-            resource_path='/api/v1/plugin/details/{pluginId}',
+            resource_path='/api/v1/agent/details/{agentId}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -2228,36 +2717,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def get_plugin_summary(
+    def get_agent_summary(
         self,
-        plugin_id: Annotated[StrictStr, Field(description="PluginId to be obtained")],
+        agent_id: Annotated[StrictInt, Field(description="agentId to be obtained")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> PluginSummaryDTO:
-        """Get Plugin Summary
+    ) -> AgentSummaryDTO:
+        """Get Agent Summary
 
-        Get plugin summary information.
+        Get agent summary information.
 
-        :param plugin_id: PluginId to be obtained (required)
-        :type plugin_id: str
+        :param agent_id: agentId to be obtained (required)
+        :type agent_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2272,60 +2761,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_plugin_summary_serialize(
-            plugin_id=plugin_id,
+        _param = self._get_agent_summary_serialize(
+            agent_id=agent_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PluginSummaryDTO"
-            
+            '200': "AgentSummaryDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def get_plugin_summary_with_http_info(
+    def get_agent_summary_with_http_info(
         self,
-        plugin_id: Annotated[StrictStr, Field(description="PluginId to be obtained")],
+        agent_id: Annotated[StrictInt, Field(description="agentId to be obtained")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[PluginSummaryDTO]:
-        """Get Plugin Summary
+    ) -> ApiResponse[AgentSummaryDTO]:
+        """Get Agent Summary
 
-        Get plugin summary information.
+        Get agent summary information.
 
-        :param plugin_id: PluginId to be obtained (required)
-        :type plugin_id: str
+        :param agent_id: agentId to be obtained (required)
+        :type agent_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2340,60 +2828,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_plugin_summary_serialize(
-            plugin_id=plugin_id,
+        _param = self._get_agent_summary_serialize(
+            agent_id=agent_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PluginSummaryDTO"
-            
+            '200': "AgentSummaryDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def get_plugin_summary_without_preload_content(
+    def get_agent_summary_without_preload_content(
         self,
-        plugin_id: Annotated[StrictStr, Field(description="PluginId to be obtained")],
+        agent_id: Annotated[StrictInt, Field(description="agentId to be obtained")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Get Plugin Summary
+        """Get Agent Summary
 
-        Get plugin summary information.
+        Get agent summary information.
 
-        :param plugin_id: PluginId to be obtained (required)
-        :type plugin_id: str
+        :param agent_id: agentId to be obtained (required)
+        :type agent_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2408,58 +2895,56 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_plugin_summary_serialize(
-            plugin_id=plugin_id,
+        _param = self._get_agent_summary_serialize(
+            agent_id=agent_id,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PluginSummaryDTO"
-            
+            '200': "AgentSummaryDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _get_plugin_summary_serialize(
+    def _get_agent_summary_serialize(
         self,
-        plugin_id,
+        agent_id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if plugin_id is not None:
-            _path_params['pluginId'] = plugin_id
+        if agent_id is not None:
+            _path_params['agentId'] = agent_id
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
@@ -2473,15 +2958,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='GET',
-            resource_path='/api/v1/plugin/summary/{pluginId}',
+            resource_path='/api/v1/agent/summary/{agentId}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -2490,36 +2975,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def refresh_plugin_info(
+    def list_agent_versions_by_name(
         self,
-        plugin_id: Annotated[StrictStr, Field(description="The pluginId to be fetched")],
+        name: Annotated[StrictStr, Field(description="Agent name")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> None:
-        """Refresh Plugin Information
+    ) -> List[AgentItemForNameDTO]:
+        """List Versions by Agent Name
 
-        For online manifest, api-docs information provided at the time of entry, this interface can immediately refresh the information in the system cache (default cache time is 1 hour). Generally, there is no need to call, unless you know that the corresponding plugin platform has just updated the interface, and the business side wants to get the latest information immediately, then call this interface to delete the system cache.
+        List the versions and corresponding agentIds by agent name.
 
-        :param plugin_id: The pluginId to be fetched (required)
-        :type plugin_id: str
+        :param name: Agent name (required)
+        :type name: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2534,59 +3019,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._refresh_plugin_info_serialize(
-            plugin_id=plugin_id,
+        _param = self._list_agent_versions_by_name_serialize(
+            name=name,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            
+            '200': "List[AgentItemForNameDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def refresh_plugin_info_with_http_info(
+    def list_agent_versions_by_name_with_http_info(
         self,
-        plugin_id: Annotated[StrictStr, Field(description="The pluginId to be fetched")],
+        name: Annotated[StrictStr, Field(description="Agent name")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[None]:
-        """Refresh Plugin Information
+    ) -> ApiResponse[List[AgentItemForNameDTO]]:
+        """List Versions by Agent Name
 
-        For online manifest, api-docs information provided at the time of entry, this interface can immediately refresh the information in the system cache (default cache time is 1 hour). Generally, there is no need to call, unless you know that the corresponding plugin platform has just updated the interface, and the business side wants to get the latest information immediately, then call this interface to delete the system cache.
+        List the versions and corresponding agentIds by agent name.
 
-        :param plugin_id: The pluginId to be fetched (required)
-        :type plugin_id: str
+        :param name: Agent name (required)
+        :type name: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2601,59 +3086,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._refresh_plugin_info_serialize(
-            plugin_id=plugin_id,
+        _param = self._list_agent_versions_by_name_serialize(
+            name=name,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            
+            '200': "List[AgentItemForNameDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def refresh_plugin_info_without_preload_content(
+    def list_agent_versions_by_name_without_preload_content(
         self,
-        plugin_id: Annotated[StrictStr, Field(description="The pluginId to be fetched")],
+        name: Annotated[StrictStr, Field(description="Agent name")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Refresh Plugin Information
+        """List Versions by Agent Name
 
-        For online manifest, api-docs information provided at the time of entry, this interface can immediately refresh the information in the system cache (default cache time is 1 hour). Generally, there is no need to call, unless you know that the corresponding plugin platform has just updated the interface, and the business side wants to get the latest information immediately, then call this interface to delete the system cache.
+        List the versions and corresponding agentIds by agent name.
 
-        :param plugin_id: The pluginId to be fetched (required)
-        :type plugin_id: str
+        :param name: Agent name (required)
+        :type name: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2668,73 +3153,351 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._refresh_plugin_info_serialize(
-            plugin_id=plugin_id,
+        _param = self._list_agent_versions_by_name_serialize(
+            name=name,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            
+            '200': "List[AgentItemForNameDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _refresh_plugin_info_serialize(
+    def _list_agent_versions_by_name_serialize(
         self,
-        plugin_id,
+        name,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if plugin_id is not None:
-            _path_params['pluginId'] = plugin_id
+        if name is not None:
+            _path_params['name'] = name
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            [
+                'application/json'
+            ]
+        )
 
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
-            method='PUT',
-            resource_path='/api/v1/plugin/refresh/{pluginId}',
+            method='POST',
+            resource_path='/api/v1/agent/versions/{name}',
+            path_params=_path_params,
+            query_params=_query_params,
+            header_params=_header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            auth_settings=_auth_settings,
+            collection_formats=_collection_formats,
+            _host=_host,
+            _request_auth=_request_auth
+        )
+
+
+
+
+    @validate_call
+    def publish_agent(
+        self,
+        agent_id: Annotated[StrictInt, Field(description="The agentId to be published")],
+        visibility: Annotated[StrictStr, Field(description="Visibility: public | private | ...")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> int:
+        """Publish Agent
+
+        Publish agent, draft content becomes formal content, version number increases by 1. After successful publication, a new agentId will be generated and returned. You need to specify the visibility for publication.
+
+        :param agent_id: The agentId to be published (required)
+        :type agent_id: int
+        :param visibility: Visibility: public | private | ... (required)
+        :type visibility: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._publish_agent_serialize(
+            agent_id=agent_id,
+            visibility=visibility,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "int",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        ).data
+
+
+    @validate_call
+    def publish_agent_with_http_info(
+        self,
+        agent_id: Annotated[StrictInt, Field(description="The agentId to be published")],
+        visibility: Annotated[StrictStr, Field(description="Visibility: public | private | ...")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> ApiResponse[int]:
+        """Publish Agent
+
+        Publish agent, draft content becomes formal content, version number increases by 1. After successful publication, a new agentId will be generated and returned. You need to specify the visibility for publication.
+
+        :param agent_id: The agentId to be published (required)
+        :type agent_id: int
+        :param visibility: Visibility: public | private | ... (required)
+        :type visibility: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._publish_agent_serialize(
+            agent_id=agent_id,
+            visibility=visibility,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "int",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        )
+
+
+    @validate_call
+    def publish_agent_without_preload_content(
+        self,
+        agent_id: Annotated[StrictInt, Field(description="The agentId to be published")],
+        visibility: Annotated[StrictStr, Field(description="Visibility: public | private | ...")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> RESTResponseType:
+        """Publish Agent
+
+        Publish agent, draft content becomes formal content, version number increases by 1. After successful publication, a new agentId will be generated and returned. You need to specify the visibility for publication.
+
+        :param agent_id: The agentId to be published (required)
+        :type agent_id: int
+        :param visibility: Visibility: public | private | ... (required)
+        :type visibility: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._publish_agent_serialize(
+            agent_id=agent_id,
+            visibility=visibility,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "int",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        return response_data.response
+
+
+    def _publish_agent_serialize(
+        self,
+        agent_id,
+        visibility,
+        _request_auth,
+        _content_type,
+        _headers,
+        _host_index,
+    ) -> RequestSerialized:
+
+        _host = None
+
+        _collection_formats: Dict[str, str] = {
+        }
+
+        _path_params: Dict[str, str] = {}
+        _query_params: List[Tuple[str, str]] = []
+        _header_params: Dict[str, Optional[str]] = _headers or {}
+        _form_params: List[Tuple[str, str]] = []
+        _files: Dict[str, Union[str, bytes]] = {}
+        _body_params: Optional[bytes] = None
+
+        # process the path parameters
+        if agent_id is not None:
+            _path_params['agentId'] = agent_id
+        if visibility is not None:
+            _path_params['visibility'] = visibility
+        # process the query parameters
+        # process the header parameters
+        # process the form parameters
+        # process the body parameter
+
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            [
+                'application/json'
+            ]
+        )
+
+
+        # authentication setting
+        _auth_settings: List[str] = [
+            'bearerAuth'
+        ]
+
+        return self.api_client.param_serialize(
+            method='POST',
+            resource_path='/api/v1/agent/publish/{agentId}/{visibility}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -2743,36 +3506,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def search_plugin_details(
+    def search_agent_details(
         self,
-        plugin_query_dto: Annotated[PluginQueryDTO, Field(description="Query conditions")],
+        agent_query_dto: Annotated[AgentQueryDTO, Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[PluginDetailsDTO]:
-        """Search Plugin Details
+    ) -> List[AgentDetailsDTO]:
+        """Search Agent Details
 
-        Same as /api/v1/plugin/search, but returns detailed information of the plugin.
+        Same as /api/v1/agent/search, but returns detailed information of the agent.
 
-        :param plugin_query_dto: Query conditions (required)
-        :type plugin_query_dto: PluginQueryDTO
+        :param agent_query_dto: Query conditions (required)
+        :type agent_query_dto: AgentQueryDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2787,60 +3550,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_plugin_details_serialize(
-            plugin_query_dto=plugin_query_dto,
+        _param = self._search_agent_details_serialize(
+            agent_query_dto=agent_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PluginDetailsDTO]"
-            
+            '200': "List[AgentDetailsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def search_plugin_details_with_http_info(
+    def search_agent_details_with_http_info(
         self,
-        plugin_query_dto: Annotated[PluginQueryDTO, Field(description="Query conditions")],
+        agent_query_dto: Annotated[AgentQueryDTO, Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[PluginDetailsDTO]]:
-        """Search Plugin Details
+    ) -> ApiResponse[List[AgentDetailsDTO]]:
+        """Search Agent Details
 
-        Same as /api/v1/plugin/search, but returns detailed information of the plugin.
+        Same as /api/v1/agent/search, but returns detailed information of the agent.
 
-        :param plugin_query_dto: Query conditions (required)
-        :type plugin_query_dto: PluginQueryDTO
+        :param agent_query_dto: Query conditions (required)
+        :type agent_query_dto: AgentQueryDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2855,60 +3617,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_plugin_details_serialize(
-            plugin_query_dto=plugin_query_dto,
+        _param = self._search_agent_details_serialize(
+            agent_query_dto=agent_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PluginDetailsDTO]"
-            
+            '200': "List[AgentDetailsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def search_plugin_details_without_preload_content(
+    def search_agent_details_without_preload_content(
         self,
-        plugin_query_dto: Annotated[PluginQueryDTO, Field(description="Query conditions")],
+        agent_query_dto: Annotated[AgentQueryDTO, Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Search Plugin Details
+        """Search Agent Details
 
-        Same as /api/v1/plugin/search, but returns detailed information of the plugin.
+        Same as /api/v1/agent/search, but returns detailed information of the agent.
 
-        :param plugin_query_dto: Query conditions (required)
-        :type plugin_query_dto: PluginQueryDTO
+        :param agent_query_dto: Query conditions (required)
+        :type agent_query_dto: AgentQueryDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2923,62 +3684,60 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_plugin_details_serialize(
-            plugin_query_dto=plugin_query_dto,
+        _param = self._search_agent_details_serialize(
+            agent_query_dto=agent_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PluginDetailsDTO]"
-            
+            '200': "List[AgentDetailsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _search_plugin_details_serialize(
+    def _search_agent_details_serialize(
         self,
-        plugin_query_dto,
+        agent_query_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
-        if plugin_query_dto is not None:
-            _body_params = plugin_query_dto
+        if agent_query_dto is not None:
+            _body_params = agent_query_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
                 'application/json'
             ]
@@ -3001,15 +3760,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/plugin/details/search',
+            resource_path='/api/v1/agent/details/search',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -3018,36 +3777,36 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def search_plugin_summary(
+    def search_agent_summary(
         self,
-        plugin_query_dto: Annotated[PluginQueryDTO, Field(description="Query conditions")],
+        agent_query_dto: Annotated[AgentQueryDTO, Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[PluginSummaryDTO]:
-        """Search Plugin Summary
+    ) -> List[AgentSummaryDTO]:
+        """Search Agent Summary
 
-        Search plugins: - Specifiable query fields, and relationship:   - Scope: private, public_org or public. Private can only search this account.   - Username: exact match, only valid when searching public, public_org. If not specified, search all users.   - Plugin information format: currently supported: dash_scope, open_ai.   - Interface information format: currently supported: openapi_v3.   - Tags: exact match (support and, or logic).   - Model type: exact match (support and, or logic).   - Name: left match.   - Provider: left match.   - General: name, provider information, manifest (real-time pull mode is not currently supported), fuzzy match, one hit is enough; public scope + all user's general search does not guarantee timeliness. - A certain sorting rule can be specified, such as view count, reference count, rating, time, descending or ascending. - The search result is the plugin summary content. - Support pagination. 
+        Search agents: - Specifiable query fields, and relationship:   - Scope: private, public_org or public. Private can only search this account.   - Username: exact match, only valid when searching public, public_org. If not specified, search all users.   - Format: exact match, currently supported: langflow   - Tags: exact match (support and, or logic).   - Model type: exact match (support and, or logic).   - Name: left match.   - General: name, description, example, fuzzy match, one hit is enough; public scope + all user's general search does not guarantee timeliness. - A certain sorting rule can be specified, such as view count, reference count, rating, time, descending or ascending. - The search result is the agent summary content. - Support pagination. 
 
-        :param plugin_query_dto: Query conditions (required)
-        :type plugin_query_dto: PluginQueryDTO
+        :param agent_query_dto: Query conditions (required)
+        :type agent_query_dto: AgentQueryDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3062,60 +3821,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_plugin_summary_serialize(
-            plugin_query_dto=plugin_query_dto,
+        _param = self._search_agent_summary_serialize(
+            agent_query_dto=agent_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PluginSummaryDTO]"
-            
+            '200': "List[AgentSummaryDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def search_plugin_summary_with_http_info(
+    def search_agent_summary_with_http_info(
         self,
-        plugin_query_dto: Annotated[PluginQueryDTO, Field(description="Query conditions")],
+        agent_query_dto: Annotated[AgentQueryDTO, Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[PluginSummaryDTO]]:
-        """Search Plugin Summary
+    ) -> ApiResponse[List[AgentSummaryDTO]]:
+        """Search Agent Summary
 
-        Search plugins: - Specifiable query fields, and relationship:   - Scope: private, public_org or public. Private can only search this account.   - Username: exact match, only valid when searching public, public_org. If not specified, search all users.   - Plugin information format: currently supported: dash_scope, open_ai.   - Interface information format: currently supported: openapi_v3.   - Tags: exact match (support and, or logic).   - Model type: exact match (support and, or logic).   - Name: left match.   - Provider: left match.   - General: name, provider information, manifest (real-time pull mode is not currently supported), fuzzy match, one hit is enough; public scope + all user's general search does not guarantee timeliness. - A certain sorting rule can be specified, such as view count, reference count, rating, time, descending or ascending. - The search result is the plugin summary content. - Support pagination. 
+        Search agents: - Specifiable query fields, and relationship:   - Scope: private, public_org or public. Private can only search this account.   - Username: exact match, only valid when searching public, public_org. If not specified, search all users.   - Format: exact match, currently supported: langflow   - Tags: exact match (support and, or logic).   - Model type: exact match (support and, or logic).   - Name: left match.   - General: name, description, example, fuzzy match, one hit is enough; public scope + all user's general search does not guarantee timeliness. - A certain sorting rule can be specified, such as view count, reference count, rating, time, descending or ascending. - The search result is the agent summary content. - Support pagination. 
 
-        :param plugin_query_dto: Query conditions (required)
-        :type plugin_query_dto: PluginQueryDTO
+        :param agent_query_dto: Query conditions (required)
+        :type agent_query_dto: AgentQueryDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3130,60 +3888,59 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_plugin_summary_serialize(
-            plugin_query_dto=plugin_query_dto,
+        _param = self._search_agent_summary_serialize(
+            agent_query_dto=agent_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PluginSummaryDTO]"
-            
+            '200': "List[AgentSummaryDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def search_plugin_summary_without_preload_content(
+    def search_agent_summary_without_preload_content(
         self,
-        plugin_query_dto: Annotated[PluginQueryDTO, Field(description="Query conditions")],
+        agent_query_dto: Annotated[AgentQueryDTO, Field(description="Query conditions")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Search Plugin Summary
+        """Search Agent Summary
 
-        Search plugins: - Specifiable query fields, and relationship:   - Scope: private, public_org or public. Private can only search this account.   - Username: exact match, only valid when searching public, public_org. If not specified, search all users.   - Plugin information format: currently supported: dash_scope, open_ai.   - Interface information format: currently supported: openapi_v3.   - Tags: exact match (support and, or logic).   - Model type: exact match (support and, or logic).   - Name: left match.   - Provider: left match.   - General: name, provider information, manifest (real-time pull mode is not currently supported), fuzzy match, one hit is enough; public scope + all user's general search does not guarantee timeliness. - A certain sorting rule can be specified, such as view count, reference count, rating, time, descending or ascending. - The search result is the plugin summary content. - Support pagination. 
+        Search agents: - Specifiable query fields, and relationship:   - Scope: private, public_org or public. Private can only search this account.   - Username: exact match, only valid when searching public, public_org. If not specified, search all users.   - Format: exact match, currently supported: langflow   - Tags: exact match (support and, or logic).   - Model type: exact match (support and, or logic).   - Name: left match.   - General: name, description, example, fuzzy match, one hit is enough; public scope + all user's general search does not guarantee timeliness. - A certain sorting rule can be specified, such as view count, reference count, rating, time, descending or ascending. - The search result is the agent summary content. - Support pagination. 
 
-        :param plugin_query_dto: Query conditions (required)
-        :type plugin_query_dto: PluginQueryDTO
+        :param agent_query_dto: Query conditions (required)
+        :type agent_query_dto: AgentQueryDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3198,62 +3955,60 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_plugin_summary_serialize(
-            plugin_query_dto=plugin_query_dto,
+        _param = self._search_agent_summary_serialize(
+            agent_query_dto=agent_query_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PluginSummaryDTO]"
-            
+            '200': "List[AgentSummaryDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _search_plugin_summary_serialize(
+    def _search_agent_summary_serialize(
         self,
-        plugin_query_dto,
+        agent_query_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
-        if plugin_query_dto is not None:
-            _body_params = plugin_query_dto
+        if agent_query_dto is not None:
+            _body_params = agent_query_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
                 'application/json'
             ]
@@ -3276,15 +4031,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/plugin/search',
+            resource_path='/api/v1/agent/search',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -3293,39 +4048,39 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def update_plugin(
+    def update_agent(
         self,
-        plugin_id: Annotated[StrictStr, Field(description="The pluginId to be updated")],
-        plugin_update_dto: Annotated[PluginUpdateDTO, Field(description="The plugin information to be updated")],
+        agent_id: Annotated[StrictInt, Field(description="AgentId to be updated")],
+        agent_update_dto: Annotated[AgentUpdateDTO, Field(description="Agent information to be updated")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> bool:
-        """Update Plugin
+        """Update Agent
 
-        Update plugin, refer to /api/v1/plugin/create, required field: pluginId. Returns success or failure.
+        Update agent, refer to /api/v1/agent/create, required field: agentId. Return success or failure.
 
-        :param plugin_id: The pluginId to be updated (required)
-        :type plugin_id: str
-        :param plugin_update_dto: The plugin information to be updated (required)
-        :type plugin_update_dto: PluginUpdateDTO
+        :param agent_id: AgentId to be updated (required)
+        :type agent_id: int
+        :param agent_update_dto: Agent information to be updated (required)
+        :type agent_update_dto: AgentUpdateDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3340,64 +4095,63 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_plugin_serialize(
-            plugin_id=plugin_id,
-            plugin_update_dto=plugin_update_dto,
+        _param = self._update_agent_serialize(
+            agent_id=agent_id,
+            agent_update_dto=agent_update_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def update_plugin_with_http_info(
+    def update_agent_with_http_info(
         self,
-        plugin_id: Annotated[StrictStr, Field(description="The pluginId to be updated")],
-        plugin_update_dto: Annotated[PluginUpdateDTO, Field(description="The plugin information to be updated")],
+        agent_id: Annotated[StrictInt, Field(description="AgentId to be updated")],
+        agent_update_dto: Annotated[AgentUpdateDTO, Field(description="Agent information to be updated")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[bool]:
-        """Update Plugin
+        """Update Agent
 
-        Update plugin, refer to /api/v1/plugin/create, required field: pluginId. Returns success or failure.
+        Update agent, refer to /api/v1/agent/create, required field: agentId. Return success or failure.
 
-        :param plugin_id: The pluginId to be updated (required)
-        :type plugin_id: str
-        :param plugin_update_dto: The plugin information to be updated (required)
-        :type plugin_update_dto: PluginUpdateDTO
+        :param agent_id: AgentId to be updated (required)
+        :type agent_id: int
+        :param agent_update_dto: Agent information to be updated (required)
+        :type agent_update_dto: AgentUpdateDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3412,64 +4166,63 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_plugin_serialize(
-            plugin_id=plugin_id,
-            plugin_update_dto=plugin_update_dto,
+        _param = self._update_agent_serialize(
+            agent_id=agent_id,
+            agent_update_dto=agent_update_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def update_plugin_without_preload_content(
+    def update_agent_without_preload_content(
         self,
-        plugin_id: Annotated[StrictStr, Field(description="The pluginId to be updated")],
-        plugin_update_dto: Annotated[PluginUpdateDTO, Field(description="The plugin information to be updated")],
+        agent_id: Annotated[StrictInt, Field(description="AgentId to be updated")],
+        agent_update_dto: Annotated[AgentUpdateDTO, Field(description="Agent information to be updated")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Update Plugin
+        """Update Agent
 
-        Update plugin, refer to /api/v1/plugin/create, required field: pluginId. Returns success or failure.
+        Update agent, refer to /api/v1/agent/create, required field: agentId. Return success or failure.
 
-        :param plugin_id: The pluginId to be updated (required)
-        :type plugin_id: str
-        :param plugin_update_dto: The plugin information to be updated (required)
-        :type plugin_update_dto: PluginUpdateDTO
+        :param agent_id: AgentId to be updated (required)
+        :type agent_id: int
+        :param agent_update_dto: Agent information to be updated (required)
+        :type agent_update_dto: AgentUpdateDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3484,66 +4237,64 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_plugin_serialize(
-            plugin_id=plugin_id,
-            plugin_update_dto=plugin_update_dto,
+        _param = self._update_agent_serialize(
+            agent_id=agent_id,
+            agent_update_dto=agent_update_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _update_plugin_serialize(
+    def _update_agent_serialize(
         self,
-        plugin_id,
-        plugin_update_dto,
+        agent_id,
+        agent_update_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
-        if plugin_id is not None:
-            _path_params['pluginId'] = plugin_id
+        if agent_id is not None:
+            _path_params['agentId'] = agent_id
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
-        if plugin_update_dto is not None:
-            _body_params = plugin_update_dto
+        if agent_update_dto is not None:
+            _body_params = agent_update_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
                 'application/json'
             ]
@@ -3566,15 +4317,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='PUT',
-            resource_path='/api/v1/plugin/{pluginId}',
+            resource_path='/api/v1/agent/{agentId}',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## Comparing `freechat-sdk/api/prompt_api.py` & `freechat_sdk/api/prompt_api.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,53 +1,43 @@
 # coding: utf-8
 
 """
     FreeChat OpenAPI Definition
 
-    https://github.com/freechat-fun/freechat
+    # FreeChat: Create Some Friends for Yourself with AI  English | [中文版](https://github.com/freechat-fun/freechat/blob/main/README.zh-CN.md)  ## Introduction Welcome! FreeChat aims to build a cloud-native, robust, and quickly commercializable enterprise-level AI virtual character platform.  ## Features - Primarily uses Java and emphasizes **security, robustness, scalability, traceability, and maintainability**. - oasts **account systems and permission management**, supporting OAuth2 authentication. Introduces the \"organization\" concept and related permission constraint functions. - Extensively employs **distributed technologies and caching** to support **high concurrency** access. - Provides flexible character customization options, supports direct intervention in prompts, and supports **configuring multiple backends for each character**. - **Offers a comprehensive range of Open APIs**, with more than 180 interfaces and provides java/python/typescript SDKs. These interfaces enable easy construction of systems for end-users. - Supports setting **RAG** (Retrieval Augmented Generation) for characters. - Supports **long-term memory** for characters. - Supports setting **quota limits** for characters.  ## System Snapshots  ## Character Design ```mermaid flowchart TD     A(Character) --> B(Profile)     A --> C(Knowledge/RAG)     A --> D(Album)     A --> E(Backend-1)     A --> F(Backend-n...)     E --> G(Message Window)     E --> H(Long Term Memory Settings)     E --> I(Quota Limit)     E --> J(Chat Prompt Task)     E --> K(Greeting Prompt Task)     E --> L(Moderation Settings)     J --> M(Model & Parameters)     J --> N(API Keys)     J --> O(Prompt Refence)     J --> P(Tool Specifications)     O --> Q(Template)     O --> R(Variables)     O --> S(Version)     O --> T(...)     style K stroke-dasharray: 5, 5     style L stroke-dasharray: 5, 5     style P stroke-dasharray: 5, 5 ```  After setting up a unified persona and knowledge for a character, different backends can be configured. For example, different model may be adopted for different users based on cost considerations.  ## How to Play ### Online Website You can visit [freechat.fun](https://freechat.fun) to experience FreeChat. Share your designed AI character!  ### Running in a Kubernetes Cluster FreeChat is dedicated to the principles of cloud-native design. If you have a Kubernetes cluster, you can deploy FreeChat to your environment by following these steps:  1. Put the Kubernetes configuration file in the `configs/helm/` directory, named `kube-private.conf`. 2. Place the Helm configuration file in the same directory, named `values-private.yaml`. Make sure to reference the default `values.yaml` and customize the variables as needed. 3. Switch to the `scripts/` directory. 4. If needed, execute `install-in.sh` to deploy `ingress-nginx` to the Kubernetes cluster. 5. If needed, run `install-cm.sh` to deploy `cert-manager` on the Kubernetes cluster, which automatically issues certificates for domains specified in `ingress.hosts`. 6. Run `install-pvc.sh` to install PersistentVolumeClaim resources.      > By default, FreeChat operates files by accessing the \"local file system.\" You may want to use high-availability distributed storage in the cloud. As a cloud-native-designed system, we recommend interfacing through Kubernetes CSI to avoid individually adapting storage products for each cloud platform. Most cloud service providers offer cloud storage drivers for Kubernetes, with a series of predefined StorageClass resources. Please choose the appropriate configuration according to your actual needs and set it in Helm's `global.storageClass` option.     >      > *In the future, FreeChat may be refactored to use MinIO's APIs directly, as it is now installed in the Kubernetes cluster as a dependency (serving Milvus).*  7. Execute the `install.sh` script to install FreeChat and its dependencies. 8. FreeChat aims to provide Open API services. If you like the interactive experience of [freechat.fun](https://freechat.fun), run `install-web.sh` to deploy the front-end application. 9. Execute `restart.sh` to restart the service. 10. If you modified any Helm configuration files, use `upgrade.sh` to update the corresponding Kubernetes resources. 11. To remove specific resources, run the `uninstall*.sh` script corresponding to the resource you want to uninstall.  As a cloud-native application, the services FreeChat relies on are obtained and deployed to your cluster through the helm repository.  If you prefer cloud services with SLA (Service Level Agreement) guarantees, simply make the relevant settings in `configs/helm/values-private.yaml`: ```yaml bitnami:   mysql:     enabled: false   redis:     enabled: false   milvus:     enabled: false  mysql:   url: <your mysql url>   auth:     rootPassword: <your mysql root password>     username: <your mysql username>     password: <your mysql password for the username>  redis:   url: <your redis url>   auth:     password: <your redis password>   milvus:   url: <your milvus url>   milvus:     auth:       token: <your milvus api-key> ```  With this, FreeChat will not automatically install these services, but rather use the configuration information to connect directly.  ### Running Locally You can also run FreeChat locally. Currently supported on MacOS and Linux (although only tested on MacOS). You need to install the Docker toolset and have a network that can access [Docker Hub](https://hub.docker.com/).  Once ready, enter the `scripts/` directory and run `local-run.sh`, which will download and run the necessary docker containers. After a successful startup, you can access `http://localhost` via a browser to see the locally running freechat.fun. Use `local-run.sh --help` to view the supported options of the script. Good luck!  ### Running in an IDE To run FreeChat in an IDE, you need to start all dependent services first but do not need to run the container for the FreeChat application itself. You can execute the `scripts/local-deps.sh` script to start services like `MySQL`, `Redis`, `Milvus`, etc., locally. Once done, open and debug `freechat-start/src/main/java/fun/freechat/Application.java`。Make sure you have set the following startup parameters: ```shell -Dspring.config.location=classpath:/application.yml,classpath:/application-local.yml \\ -DAPP_HOME=local-data/freechat \\ -Dspring.profiles.active=local ```  ### 使用 SDK #### Java - **Dependency** ```xml <dependency>   <groupId>fun.freechat</groupId>   <artifactId>freechat-sdk</artifactId>   <version>${freechat-sdk.version}</version> </dependency> ```  - **Example** ```java import fun.freechat.client.ApiClient; import fun.freechat.client.ApiException; import fun.freechat.client.Configuration; import fun.freechat.client.api.AccountApi; import fun.freechat.client.auth.ApiKeyAuth; import fun.freechat.client.model.UserDetailsDTO;  public class AccountClientExample {     public static void main(String[] args) {         ApiClient defaultClient = Configuration.getDefaultApiClient();         defaultClient.setBasePath(\"https://freechat.fun\");                  // Configure HTTP bearer authorization: bearerAuth         HttpBearerAuth bearerAuth = (HttpBearerAuth) defaultClient.getAuthentication(\"bearerAuth\");         bearerAuth.setBearerToken(\"FREECHAT_TOKEN\");          AccountApi apiInstance = new AccountApi(defaultClient);         try {             UserDetailsDTO result = apiInstance.getUserDetails();             System.out.println(result);         } catch (ApiException e) {             e.printStackTrace();         }     } } ```  #### Python - **Installation** ```shell pip install freechat-sdk ```  - **Example** ```python import freechat_sdk from freechat_sdk.rest import ApiException from pprint import pprint  # Defining the host is optional and defaults to https://freechat.fun # See configuration.py for a list of all supported configuration parameters. configuration = freechat_sdk.Configuration(     host = \"https://freechat.fun\" )  # Configure Bearer authorization: bearerAuth configuration = freechat_sdk.Configuration(     access_token = os.environ[\"FREECHAT_TOKEN\"] )  # Enter a context with an instance of the API client with freechat_sdk.ApiClient(configuration) as api_client:     # Create an instance of the API class     api_instance = freechat_sdk.AccountApi(api_client)      try:         details = api_instance.get_user_details()         pprint(details)     except ApiException as e:         print(\"Exception when calling AccountClient->get_user_details: %s\\n\" % e) ```  #### TypeScript - **Installation** ```shell npm install freechat-sdk --save ```  - **Example** Refer to [FreeChatApiContext.tsx](https://github.com/freechat-fun/freechat/blob/main/freechat-web/src/contexts/FreeChatApiProvider.tsx)  ## System Dependencies | | Projects | ---- | ---- | Application Framework | [Spring Boot](https://spring.io/projects/spring-boot/) | LLM Framework | [LangChain4j](https://docs.langchain4j.dev/) | Model Providers | [OpenAI](https://platform.openai.com/), [DashScope](https://dashscope.aliyun.com/) | Database Systems | [MySQL](https://www.mysql.com/), [Redis](https://redis.io/), [Milvus](https://milvus.io/) | OpenAPI Tools | [Springdoc-openapi](https://springdoc.org/), [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator), [OpenAPI Explorer](https://github.com/Authress-Engineering/openapi-explorer)  ## Collaboration ### Application Integration The FreeChat system is entirely oriented towards Open APIs. The site [freechat.fun](https://freechat.fun) is developed using its TypeScript SDK and hardly depends on private interfaces. You can use these online interfaces to develop your own applications or sites, making them fit your preferences. Currently, FreeChat is completely free with no paid plans (after all, users use their own API Key to call LLM services).  ### Model Integration FreeChat aims to explore AI virtual character technology with anthropomorphic characteristics. So far, it supports model services from OpenAI and DashScope ([HuggingFace](https://huggingface.co/) is also expected to be supported soon). However, we are more interested in supporting models that are under research and can endow AI with more personality traits. If you are researching this area and hope FreeChat supports your model, please contact us. We look forward to AI technology helping people create their own \"soul mates\" in the future.
 
-    The version of the OpenAPI document: 0.1.0
+    The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
-import io
 import warnings
-
 from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
-
-try:
-    from typing import Annotated
-except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import Field
+from typing import Any, Dict, List, Optional, Tuple, Union
 from typing_extensions import Annotated
-from pydantic import StrictStr
 
+from pydantic import Field, StrictBool, StrictInt, StrictStr
 from typing import List
-
-from freechat-sdk.models.llm_result_dto import LlmResultDTO
-from freechat-sdk.models.prompt_ai_param_dto import PromptAiParamDTO
-from freechat-sdk.models.prompt_create_dto import PromptCreateDTO
-from freechat-sdk.models.prompt_details_dto import PromptDetailsDTO
-from freechat-sdk.models.prompt_item_for_name_dto import PromptItemForNameDTO
-from freechat-sdk.models.prompt_query_dto import PromptQueryDTO
-from freechat-sdk.models.prompt_ref_dto import PromptRefDTO
-from freechat-sdk.models.prompt_summary_dto import PromptSummaryDTO
-from freechat-sdk.models.prompt_template_dto import PromptTemplateDTO
-from freechat-sdk.models.prompt_update_dto import PromptUpdateDTO
-from freechat-sdk.models.sse_emitter import SseEmitter
-
-from freechat-sdk.api_client import ApiClient
-from freechat-sdk.api_response import ApiResponse
-from freechat-sdk.rest import RESTResponseType
+from typing_extensions import Annotated
+from freechat_sdk.models.llm_result_dto import LlmResultDTO
+from freechat_sdk.models.prompt_ai_param_dto import PromptAiParamDTO
+from freechat_sdk.models.prompt_create_dto import PromptCreateDTO
+from freechat_sdk.models.prompt_details_dto import PromptDetailsDTO
+from freechat_sdk.models.prompt_item_for_name_dto import PromptItemForNameDTO
+from freechat_sdk.models.prompt_query_dto import PromptQueryDTO
+from freechat_sdk.models.prompt_ref_dto import PromptRefDTO
+from freechat_sdk.models.prompt_summary_dto import PromptSummaryDTO
+from freechat_sdk.models.prompt_template_dto import PromptTemplateDTO
+from freechat_sdk.models.prompt_update_dto import PromptUpdateDTO
+from freechat_sdk.models.sse_emitter import SseEmitter
+
+from freechat_sdk.api_client import ApiClient, RequestSerialized
+from freechat_sdk.api_response import ApiResponse
+from freechat_sdk.rest import RESTResponseType
 
 
 class PromptApi:
     """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
@@ -56,15 +46,15 @@
     def __init__(self, api_client=None) -> None:
         if api_client is None:
             api_client = ApiClient.get_default()
         self.api_client = api_client
 
 
     @validate_call
-    def apply_string_prompt_ref(
+    def apply_prompt_ref(
         self,
         prompt_ref_dto: Annotated[PromptRefDTO, Field(description="Prompt record")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
@@ -100,39 +90,38 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._apply_string_prompt_ref_serialize(
+        _param = self._apply_prompt_ref_serialize(
             prompt_ref_dto=prompt_ref_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def apply_string_prompt_ref_with_http_info(
+    def apply_prompt_ref_with_http_info(
         self,
         prompt_ref_dto: Annotated[PromptRefDTO, Field(description="Prompt record")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
@@ -168,39 +157,38 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._apply_string_prompt_ref_serialize(
+        _param = self._apply_prompt_ref_serialize(
             prompt_ref_dto=prompt_ref_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def apply_string_prompt_ref_without_preload_content(
+    def apply_prompt_ref_without_preload_content(
         self,
         prompt_ref_dto: Annotated[PromptRefDTO, Field(description="Prompt record")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
@@ -236,68 +224,66 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._apply_string_prompt_ref_serialize(
+        _param = self._apply_prompt_ref_serialize(
             prompt_ref_dto=prompt_ref_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _apply_string_prompt_ref_serialize(
+    def _apply_prompt_ref_serialize(
         self,
         prompt_ref_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
         if prompt_ref_dto is not None:
             _body_params = prompt_ref_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
-                'application/json'
+                'text/plain'
             ]
         )
 
         # set the HTTP header `Content-Type`
         if _content_type:
             _header_params['Content-Type'] = _content_type
         else:
@@ -331,15 +317,15 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
-    def apply_string_prompt_template(
+    def apply_prompt_template(
         self,
         prompt_template_dto: Annotated[PromptTemplateDTO, Field(description="String type prompt template")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
@@ -347,17 +333,17 @@
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> str:
-        """Apply Parameters to String Prompt Template
+        """Apply Parameters to Prompt Template
 
-        Apply parameters to string type prompt template.
+        Apply parameters to prompt template.
 
         :param prompt_template_dto: String type prompt template (required)
         :type prompt_template_dto: PromptTemplateDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
@@ -375,39 +361,38 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._apply_string_prompt_template_serialize(
+        _param = self._apply_prompt_template_serialize(
             prompt_template_dto=prompt_template_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
-    def apply_string_prompt_template_with_http_info(
+    def apply_prompt_template_with_http_info(
         self,
         prompt_template_dto: Annotated[PromptTemplateDTO, Field(description="String type prompt template")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
@@ -415,17 +400,17 @@
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[str]:
-        """Apply Parameters to String Prompt Template
+        """Apply Parameters to Prompt Template
 
-        Apply parameters to string type prompt template.
+        Apply parameters to prompt template.
 
         :param prompt_template_dto: String type prompt template (required)
         :type prompt_template_dto: PromptTemplateDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
@@ -443,39 +428,38 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._apply_string_prompt_template_serialize(
+        _param = self._apply_prompt_template_serialize(
             prompt_template_dto=prompt_template_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
             response_data=response_data,
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
-    def apply_string_prompt_template_without_preload_content(
+    def apply_prompt_template_without_preload_content(
         self,
         prompt_template_dto: Annotated[PromptTemplateDTO, Field(description="String type prompt template")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
@@ -483,17 +467,17 @@
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
-        """Apply Parameters to String Prompt Template
+        """Apply Parameters to Prompt Template
 
-        Apply parameters to string type prompt template.
+        Apply parameters to prompt template.
 
         :param prompt_template_dto: String type prompt template (required)
         :type prompt_template_dto: PromptTemplateDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
@@ -511,68 +495,66 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._apply_string_prompt_template_serialize(
+        _param = self._apply_prompt_template_serialize(
             prompt_template_dto=prompt_template_dto,
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "str",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
 
-    def _apply_string_prompt_template_serialize(
+    def _apply_prompt_template_serialize(
         self,
         prompt_template_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
         if prompt_template_dto is not None:
             _body_params = prompt_template_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
-                'application/json'
+                'text/plain'
             ]
         )
 
         # set the HTTP header `Content-Type`
         if _content_type:
             _header_params['Content-Type'] = _content_type
         else:
@@ -589,15 +571,15 @@
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
         ]
 
         return self.api_client.param_serialize(
             method='POST',
-            resource_path='/api/v1/prompt/apply/string',
+            resource_path='/api/v1/prompt/apply/template',
             path_params=_path_params,
             query_params=_query_params,
             header_params=_header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             auth_settings=_auth_settings,
@@ -659,16 +641,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[List[PromptDetailsDTO]]"
-            
+            '200': "List[List[PromptDetailsDTO]]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -727,16 +708,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[List[PromptDetailsDTO]]"
-            
+            '200': "List[List[PromptDetailsDTO]]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -795,16 +775,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[List[PromptDetailsDTO]]"
-            
+            '200': "List[List[PromptDetailsDTO]]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -812,28 +791,27 @@
     def _batch_search_prompt_details_serialize(
         self,
         prompt_query_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
             'PromptQueryDTO': '',
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
@@ -935,16 +913,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[List[PromptSummaryDTO]]"
-            
+            '200': "List[List[PromptSummaryDTO]]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1003,16 +980,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[List[PromptSummaryDTO]]"
-            
+            '200': "List[List[PromptSummaryDTO]]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1071,16 +1047,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[List[PromptSummaryDTO]]"
-            
+            '200': "List[List[PromptSummaryDTO]]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -1088,28 +1063,27 @@
     def _batch_search_prompt_summary_serialize(
         self,
         prompt_query_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
             'PromptQueryDTO': '',
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
@@ -1160,34 +1134,34 @@
 
 
 
 
     @validate_call
     def clone_prompt(
         self,
-        prompt_id: Annotated[StrictStr, Field(description="The referenced promptId")],
+        prompt_id: Annotated[StrictInt, Field(description="The referenced promptId")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> str:
+    ) -> int:
         """Clone Prompt
 
         Enter the promptId, generate a new record, the content is basically the same as the original prompt, but the following fields are different: - Version number is 1 - Visibility is private - The parent prompt is the source promptId - The creation time is the current moment. - All statistical indicators are zeroed.  Return the new promptId. 
 
         :param prompt_id: The referenced promptId (required)
-        :type prompt_id: str
+        :type prompt_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1211,16 +1185,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1228,34 +1201,34 @@
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
     def clone_prompt_with_http_info(
         self,
-        prompt_id: Annotated[StrictStr, Field(description="The referenced promptId")],
+        prompt_id: Annotated[StrictInt, Field(description="The referenced promptId")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[str]:
+    ) -> ApiResponse[int]:
         """Clone Prompt
 
         Enter the promptId, generate a new record, the content is basically the same as the original prompt, but the following fields are different: - Version number is 1 - Visibility is private - The parent prompt is the source promptId - The creation time is the current moment. - All statistical indicators are zeroed.  Return the new promptId. 
 
         :param prompt_id: The referenced promptId (required)
-        :type prompt_id: str
+        :type prompt_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1279,16 +1252,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1296,15 +1268,15 @@
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
     def clone_prompt_without_preload_content(
         self,
-        prompt_id: Annotated[StrictStr, Field(description="The referenced promptId")],
+        prompt_id: Annotated[StrictInt, Field(description="The referenced promptId")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
@@ -1315,15 +1287,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
         """Clone Prompt
 
         Enter the promptId, generate a new record, the content is basically the same as the original prompt, but the following fields are different: - Version number is 1 - Visibility is private - The parent prompt is the source promptId - The creation time is the current moment. - All statistical indicators are zeroed.  Return the new promptId. 
 
         :param prompt_id: The referenced promptId (required)
-        :type prompt_id: str
+        :type prompt_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1347,16 +1319,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -1364,42 +1335,41 @@
     def _clone_prompt_serialize(
         self,
         prompt_id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if prompt_id is not None:
             _path_params['promptId'] = prompt_id
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
-                'text/plain'
+                'application/json'
             ]
         )
 
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
@@ -1422,34 +1392,34 @@
 
 
 
 
     @validate_call
     def clone_prompts(
         self,
-        request_body: Annotated[List[StrictStr], Field(description="List of prompt information to be created")],
+        request_body: Annotated[List[StrictInt], Field(description="List of prompt information to be created")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[str]:
+    ) -> List[int]:
         """Batch Clone Prompts
 
         Batch clone multiple prompts. Ensure transactionality, return the promptId list after success.
 
         :param request_body: List of prompt information to be created (required)
-        :type request_body: List[str]
+        :type request_body: List[int]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1473,16 +1443,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[int]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1490,34 +1459,34 @@
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
     def clone_prompts_with_http_info(
         self,
-        request_body: Annotated[List[StrictStr], Field(description="List of prompt information to be created")],
+        request_body: Annotated[List[StrictInt], Field(description="List of prompt information to be created")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[str]]:
+    ) -> ApiResponse[List[int]]:
         """Batch Clone Prompts
 
         Batch clone multiple prompts. Ensure transactionality, return the promptId list after success.
 
         :param request_body: List of prompt information to be created (required)
-        :type request_body: List[str]
+        :type request_body: List[int]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1541,16 +1510,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[int]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1558,15 +1526,15 @@
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
     def clone_prompts_without_preload_content(
         self,
-        request_body: Annotated[List[StrictStr], Field(description="List of prompt information to be created")],
+        request_body: Annotated[List[StrictInt], Field(description="List of prompt information to be created")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
@@ -1577,15 +1545,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
         """Batch Clone Prompts
 
         Batch clone multiple prompts. Ensure transactionality, return the promptId list after success.
 
         :param request_body: List of prompt information to be created (required)
-        :type request_body: List[str]
+        :type request_body: List[int]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -1609,16 +1577,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[int]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -1626,28 +1593,27 @@
     def _clone_prompts_serialize(
         self,
         request_body,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
             'request_body': '',
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
@@ -1749,16 +1715,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1817,16 +1782,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -1885,16 +1849,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "int"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -1902,27 +1865,26 @@
     def _count_prompts_serialize(
         self,
         prompt_query_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
@@ -1986,15 +1948,15 @@
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> str:
+    ) -> int:
         """Create Prompt
 
         Create a prompt, required fields: - Prompt name - Prompt content - Applicable model  Limitations: - Description: 300 characters - Template: 1000 characters - Example: 2000 characters - Tags: 5 - Parameters: 10 
 
         :param prompt_create_dto: Information of the prompt to be created (required)
         :type prompt_create_dto: PromptCreateDTO
         :param _request_timeout: timeout setting for this request. If one
@@ -2024,16 +1986,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -2054,15 +2015,15 @@
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[str]:
+    ) -> ApiResponse[int]:
         """Create Prompt
 
         Create a prompt, required fields: - Prompt name - Prompt content - Applicable model  Limitations: - Description: 300 characters - Template: 1000 characters - Example: 2000 characters - Tags: 5 - Parameters: 10 
 
         :param prompt_create_dto: Information of the prompt to be created (required)
         :type prompt_create_dto: PromptCreateDTO
         :param _request_timeout: timeout setting for this request. If one
@@ -2092,16 +2053,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -2160,16 +2120,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -2177,42 +2136,41 @@
     def _create_prompt_serialize(
         self,
         prompt_create_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
         if prompt_create_dto is not None:
             _body_params = prompt_create_dto
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
-                'text/plain'
+                'application/json'
             ]
         )
 
         # set the HTTP header `Content-Type`
         if _content_type:
             _header_params['Content-Type'] = _content_type
         else:
@@ -2261,15 +2219,15 @@
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[str]:
+    ) -> List[int]:
         """Batch Create Prompts
 
         Batch create multiple prompts. Ensure transactionality, return the promptId list after success.
 
         :param prompt_create_dto: List of prompt information to be created (required)
         :type prompt_create_dto: List[PromptCreateDTO]
         :param _request_timeout: timeout setting for this request. If one
@@ -2299,16 +2257,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[int]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -2329,15 +2286,15 @@
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[str]]:
+    ) -> ApiResponse[List[int]]:
         """Batch Create Prompts
 
         Batch create multiple prompts. Ensure transactionality, return the promptId list after success.
 
         :param prompt_create_dto: List of prompt information to be created (required)
         :type prompt_create_dto: List[PromptCreateDTO]
         :param _request_timeout: timeout setting for this request. If one
@@ -2367,16 +2324,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[int]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -2435,16 +2391,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[int]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -2452,28 +2407,27 @@
     def _create_prompts_serialize(
         self,
         prompt_create_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
             'PromptCreateDTO': '',
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
@@ -2524,15 +2478,15 @@
 
 
 
 
     @validate_call
     def delete_prompt(
         self,
-        prompt_id: Annotated[StrictStr, Field(description="The promptId to be deleted")],
+        prompt_id: Annotated[StrictInt, Field(description="The promptId to be deleted")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
@@ -2543,15 +2497,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> bool:
         """Delete Prompt
 
         Delete prompt. Returns success or failure.
 
         :param prompt_id: The promptId to be deleted (required)
-        :type prompt_id: str
+        :type prompt_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2575,16 +2529,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -2592,15 +2545,15 @@
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
     def delete_prompt_with_http_info(
         self,
-        prompt_id: Annotated[StrictStr, Field(description="The promptId to be deleted")],
+        prompt_id: Annotated[StrictInt, Field(description="The promptId to be deleted")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
@@ -2611,15 +2564,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[bool]:
         """Delete Prompt
 
         Delete prompt. Returns success or failure.
 
         :param prompt_id: The promptId to be deleted (required)
-        :type prompt_id: str
+        :type prompt_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2643,16 +2596,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -2660,15 +2612,15 @@
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
     def delete_prompt_without_preload_content(
         self,
-        prompt_id: Annotated[StrictStr, Field(description="The promptId to be deleted")],
+        prompt_id: Annotated[StrictInt, Field(description="The promptId to be deleted")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
@@ -2679,15 +2631,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
         """Delete Prompt
 
         Delete prompt. Returns success or failure.
 
         :param prompt_id: The promptId to be deleted (required)
-        :type prompt_id: str
+        :type prompt_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2711,16 +2663,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -2728,27 +2679,26 @@
     def _delete_prompt_serialize(
         self,
         prompt_id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if prompt_id is not None:
             _path_params['promptId'] = prompt_id
         # process the query parameters
         # process the header parameters
@@ -2784,36 +2734,294 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
+    def delete_prompt_by_name(
+        self,
+        name: Annotated[StrictStr, Field(description="The prompt name to be deleted")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> List[int]:
+        """Delete Prompt by Name
+
+        Delete prompt by name. return the list of successfully deleted promptIds.
+
+        :param name: The prompt name to be deleted (required)
+        :type name: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._delete_prompt_by_name_serialize(
+            name=name,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "List[int]",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        ).data
+
+
+    @validate_call
+    def delete_prompt_by_name_with_http_info(
+        self,
+        name: Annotated[StrictStr, Field(description="The prompt name to be deleted")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> ApiResponse[List[int]]:
+        """Delete Prompt by Name
+
+        Delete prompt by name. return the list of successfully deleted promptIds.
+
+        :param name: The prompt name to be deleted (required)
+        :type name: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._delete_prompt_by_name_serialize(
+            name=name,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "List[int]",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        )
+
+
+    @validate_call
+    def delete_prompt_by_name_without_preload_content(
+        self,
+        name: Annotated[StrictStr, Field(description="The prompt name to be deleted")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> RESTResponseType:
+        """Delete Prompt by Name
+
+        Delete prompt by name. return the list of successfully deleted promptIds.
+
+        :param name: The prompt name to be deleted (required)
+        :type name: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._delete_prompt_by_name_serialize(
+            name=name,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "List[int]",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        return response_data.response
+
+
+    def _delete_prompt_by_name_serialize(
+        self,
+        name,
+        _request_auth,
+        _content_type,
+        _headers,
+        _host_index,
+    ) -> RequestSerialized:
+
+        _host = None
+
+        _collection_formats: Dict[str, str] = {
+        }
+
+        _path_params: Dict[str, str] = {}
+        _query_params: List[Tuple[str, str]] = []
+        _header_params: Dict[str, Optional[str]] = _headers or {}
+        _form_params: List[Tuple[str, str]] = []
+        _files: Dict[str, Union[str, bytes]] = {}
+        _body_params: Optional[bytes] = None
+
+        # process the path parameters
+        if name is not None:
+            _path_params['name'] = name
+        # process the query parameters
+        # process the header parameters
+        # process the form parameters
+        # process the body parameter
+
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            [
+                'application/json'
+            ]
+        )
+
+
+        # authentication setting
+        _auth_settings: List[str] = [
+            'bearerAuth'
+        ]
+
+        return self.api_client.param_serialize(
+            method='DELETE',
+            resource_path='/api/v1/prompt/name/{name}',
+            path_params=_path_params,
+            query_params=_query_params,
+            header_params=_header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            auth_settings=_auth_settings,
+            collection_formats=_collection_formats,
+            _host=_host,
+            _request_auth=_request_auth
+        )
+
+
+
+
+    @validate_call
     def delete_prompts(
         self,
-        request_body: Annotated[List[StrictStr], Field(description="List of promptIds to be deleted")],
+        request_body: Annotated[List[StrictInt], Field(description="List of promptIds to be deleted")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[str]:
+    ) -> List[int]:
         """Batch Delete Prompts
 
         Delete multiple prompts. Ensure transactionality, return the list of successfully deleted promptIds.
 
         :param request_body: List of promptIds to be deleted (required)
-        :type request_body: List[str]
+        :type request_body: List[int]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2837,16 +3045,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[int]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -2854,34 +3061,34 @@
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
     def delete_prompts_with_http_info(
         self,
-        request_body: Annotated[List[StrictStr], Field(description="List of promptIds to be deleted")],
+        request_body: Annotated[List[StrictInt], Field(description="List of promptIds to be deleted")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[str]]:
+    ) -> ApiResponse[List[int]]:
         """Batch Delete Prompts
 
         Delete multiple prompts. Ensure transactionality, return the list of successfully deleted promptIds.
 
         :param request_body: List of promptIds to be deleted (required)
-        :type request_body: List[str]
+        :type request_body: List[int]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2905,16 +3112,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[int]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -2922,15 +3128,15 @@
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
     def delete_prompts_without_preload_content(
         self,
-        request_body: Annotated[List[StrictStr], Field(description="List of promptIds to be deleted")],
+        request_body: Annotated[List[StrictInt], Field(description="List of promptIds to be deleted")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
@@ -2941,15 +3147,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
         """Batch Delete Prompts
 
         Delete multiple prompts. Ensure transactionality, return the list of successfully deleted promptIds.
 
         :param request_body: List of promptIds to be deleted (required)
-        :type request_body: List[str]
+        :type request_body: List[int]
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -2973,16 +3179,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[str]"
-            
+            '200': "List[int]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -2990,28 +3195,27 @@
     def _delete_prompts_serialize(
         self,
         request_body,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
             'request_body': '',
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
@@ -3060,17 +3264,275 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
+    def exists_prompt_name(
+        self,
+        name: Annotated[StrictStr, Field(description="Name")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> bool:
+        """Check If Prompt Name Exists
+
+        Check if the prompt name already exists.
+
+        :param name: Name (required)
+        :type name: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._exists_prompt_name_serialize(
+            name=name,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "bool",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        ).data
+
+
+    @validate_call
+    def exists_prompt_name_with_http_info(
+        self,
+        name: Annotated[StrictStr, Field(description="Name")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> ApiResponse[bool]:
+        """Check If Prompt Name Exists
+
+        Check if the prompt name already exists.
+
+        :param name: Name (required)
+        :type name: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._exists_prompt_name_serialize(
+            name=name,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "bool",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        )
+
+
+    @validate_call
+    def exists_prompt_name_without_preload_content(
+        self,
+        name: Annotated[StrictStr, Field(description="Name")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> RESTResponseType:
+        """Check If Prompt Name Exists
+
+        Check if the prompt name already exists.
+
+        :param name: Name (required)
+        :type name: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._exists_prompt_name_serialize(
+            name=name,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "bool",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        return response_data.response
+
+
+    def _exists_prompt_name_serialize(
+        self,
+        name,
+        _request_auth,
+        _content_type,
+        _headers,
+        _host_index,
+    ) -> RequestSerialized:
+
+        _host = None
+
+        _collection_formats: Dict[str, str] = {
+        }
+
+        _path_params: Dict[str, str] = {}
+        _query_params: List[Tuple[str, str]] = []
+        _header_params: Dict[str, Optional[str]] = _headers or {}
+        _form_params: List[Tuple[str, str]] = []
+        _files: Dict[str, Union[str, bytes]] = {}
+        _body_params: Optional[bytes] = None
+
+        # process the path parameters
+        if name is not None:
+            _path_params['name'] = name
+        # process the query parameters
+        # process the header parameters
+        # process the form parameters
+        # process the body parameter
+
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            [
+                'application/json'
+            ]
+        )
+
+
+        # authentication setting
+        _auth_settings: List[str] = [
+            'bearerAuth'
+        ]
+
+        return self.api_client.param_serialize(
+            method='GET',
+            resource_path='/api/v1/prompt/exists/name/{name}',
+            path_params=_path_params,
+            query_params=_query_params,
+            header_params=_header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            auth_settings=_auth_settings,
+            collection_formats=_collection_formats,
+            _host=_host,
+            _request_auth=_request_auth
+        )
+
+
+
+
+    @validate_call
     def get_prompt_details(
         self,
-        prompt_id: Annotated[StrictStr, Field(description="PromptId to be obtained")],
+        prompt_id: Annotated[StrictInt, Field(description="PromptId to be obtained")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
@@ -3081,15 +3543,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> PromptDetailsDTO:
         """Get Prompt Details
 
         Get prompt detailed information.
 
         :param prompt_id: PromptId to be obtained (required)
-        :type prompt_id: str
+        :type prompt_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3113,16 +3575,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PromptDetailsDTO"
-            
+            '200': "PromptDetailsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -3130,15 +3591,15 @@
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
     def get_prompt_details_with_http_info(
         self,
-        prompt_id: Annotated[StrictStr, Field(description="PromptId to be obtained")],
+        prompt_id: Annotated[StrictInt, Field(description="PromptId to be obtained")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
@@ -3149,15 +3610,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[PromptDetailsDTO]:
         """Get Prompt Details
 
         Get prompt detailed information.
 
         :param prompt_id: PromptId to be obtained (required)
-        :type prompt_id: str
+        :type prompt_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3181,16 +3642,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PromptDetailsDTO"
-            
+            '200': "PromptDetailsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -3198,15 +3658,15 @@
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
     def get_prompt_details_without_preload_content(
         self,
-        prompt_id: Annotated[StrictStr, Field(description="PromptId to be obtained")],
+        prompt_id: Annotated[StrictInt, Field(description="PromptId to be obtained")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
@@ -3217,15 +3677,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
         """Get Prompt Details
 
         Get prompt detailed information.
 
         :param prompt_id: PromptId to be obtained (required)
-        :type prompt_id: str
+        :type prompt_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3249,16 +3709,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PromptDetailsDTO"
-            
+            '200': "PromptDetailsDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -3266,27 +3725,26 @@
     def _get_prompt_details_serialize(
         self,
         prompt_id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if prompt_id is not None:
             _path_params['promptId'] = prompt_id
         # process the query parameters
         # process the header parameters
@@ -3324,15 +3782,15 @@
 
 
 
 
     @validate_call
     def get_prompt_summary(
         self,
-        prompt_id: Annotated[StrictStr, Field(description="PromptId to be obtained")],
+        prompt_id: Annotated[StrictInt, Field(description="PromptId to be obtained")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
@@ -3343,15 +3801,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> PromptSummaryDTO:
         """Get Prompt Summary
 
         Get prompt summary information.
 
         :param prompt_id: PromptId to be obtained (required)
-        :type prompt_id: str
+        :type prompt_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3375,16 +3833,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PromptSummaryDTO"
-            
+            '200': "PromptSummaryDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -3392,15 +3849,15 @@
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
     def get_prompt_summary_with_http_info(
         self,
-        prompt_id: Annotated[StrictStr, Field(description="PromptId to be obtained")],
+        prompt_id: Annotated[StrictInt, Field(description="PromptId to be obtained")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
@@ -3411,15 +3868,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[PromptSummaryDTO]:
         """Get Prompt Summary
 
         Get prompt summary information.
 
         :param prompt_id: PromptId to be obtained (required)
-        :type prompt_id: str
+        :type prompt_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3443,16 +3900,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PromptSummaryDTO"
-            
+            '200': "PromptSummaryDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -3460,15 +3916,15 @@
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
     def get_prompt_summary_without_preload_content(
         self,
-        prompt_id: Annotated[StrictStr, Field(description="PromptId to be obtained")],
+        prompt_id: Annotated[StrictInt, Field(description="PromptId to be obtained")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
@@ -3479,15 +3935,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
         """Get Prompt Summary
 
         Get prompt summary information.
 
         :param prompt_id: PromptId to be obtained (required)
-        :type prompt_id: str
+        :type prompt_id: int
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the
@@ -3511,16 +3967,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PromptSummaryDTO"
-            
+            '200': "PromptSummaryDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -3528,27 +3983,26 @@
     def _get_prompt_summary_serialize(
         self,
         prompt_id,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if prompt_id is not None:
             _path_params['promptId'] = prompt_id
         # process the query parameters
         # process the header parameters
@@ -3637,16 +4091,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PromptItemForNameDTO]"
-            
+            '200': "List[PromptItemForNameDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -3705,16 +4158,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PromptItemForNameDTO]"
-            
+            '200': "List[PromptItemForNameDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -3773,16 +4225,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PromptItemForNameDTO]"
-            
+            '200': "List[PromptItemForNameDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -3790,27 +4241,26 @@
     def _list_prompt_versions_by_name_serialize(
         self,
         name,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if name is not None:
             _path_params['name'] = name
         # process the query parameters
         # process the header parameters
@@ -3846,37 +4296,295 @@
             _request_auth=_request_auth
         )
 
 
 
 
     @validate_call
+    def new_prompt_name(
+        self,
+        desired: Annotated[StrictStr, Field(description="Desired name")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> str:
+        """Create New Prompt Name
+
+        Create a new prompt name starting with a desired name.
+
+        :param desired: Desired name (required)
+        :type desired: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._new_prompt_name_serialize(
+            desired=desired,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "str",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        ).data
+
+
+    @validate_call
+    def new_prompt_name_with_http_info(
+        self,
+        desired: Annotated[StrictStr, Field(description="Desired name")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> ApiResponse[str]:
+        """Create New Prompt Name
+
+        Create a new prompt name starting with a desired name.
+
+        :param desired: Desired name (required)
+        :type desired: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._new_prompt_name_serialize(
+            desired=desired,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "str",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        response_data.read()
+        return self.api_client.response_deserialize(
+            response_data=response_data,
+            response_types_map=_response_types_map,
+        )
+
+
+    @validate_call
+    def new_prompt_name_without_preload_content(
+        self,
+        desired: Annotated[StrictStr, Field(description="Desired name")],
+        _request_timeout: Union[
+            None,
+            Annotated[StrictFloat, Field(gt=0)],
+            Tuple[
+                Annotated[StrictFloat, Field(gt=0)],
+                Annotated[StrictFloat, Field(gt=0)]
+            ]
+        ] = None,
+        _request_auth: Optional[Dict[StrictStr, Any]] = None,
+        _content_type: Optional[StrictStr] = None,
+        _headers: Optional[Dict[StrictStr, Any]] = None,
+        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+    ) -> RESTResponseType:
+        """Create New Prompt Name
+
+        Create a new prompt name starting with a desired name.
+
+        :param desired: Desired name (required)
+        :type desired: str
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :type _request_timeout: int, tuple(int, int), optional
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the
+                              authentication in the spec for a single request.
+        :type _request_auth: dict, optional
+        :param _content_type: force content-type for the request.
+        :type _content_type: str, Optional
+        :param _headers: set to override the headers for a single
+                         request; this effectively ignores the headers
+                         in the spec for a single request.
+        :type _headers: dict, optional
+        :param _host_index: set to override the host_index for a single
+                            request; this effectively ignores the host_index
+                            in the spec for a single request.
+        :type _host_index: int, optional
+        :return: Returns the result object.
+        """ # noqa: E501
+
+        _param = self._new_prompt_name_serialize(
+            desired=desired,
+            _request_auth=_request_auth,
+            _content_type=_content_type,
+            _headers=_headers,
+            _host_index=_host_index
+        )
+
+        _response_types_map: Dict[str, Optional[str]] = {
+            '200': "str",
+        }
+        response_data = self.api_client.call_api(
+            *_param,
+            _request_timeout=_request_timeout
+        )
+        return response_data.response
+
+
+    def _new_prompt_name_serialize(
+        self,
+        desired,
+        _request_auth,
+        _content_type,
+        _headers,
+        _host_index,
+    ) -> RequestSerialized:
+
+        _host = None
+
+        _collection_formats: Dict[str, str] = {
+        }
+
+        _path_params: Dict[str, str] = {}
+        _query_params: List[Tuple[str, str]] = []
+        _header_params: Dict[str, Optional[str]] = _headers or {}
+        _form_params: List[Tuple[str, str]] = []
+        _files: Dict[str, Union[str, bytes]] = {}
+        _body_params: Optional[bytes] = None
+
+        # process the path parameters
+        if desired is not None:
+            _path_params['desired'] = desired
+        # process the query parameters
+        # process the header parameters
+        # process the form parameters
+        # process the body parameter
+
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            [
+                'text/plain'
+            ]
+        )
+
+
+        # authentication setting
+        _auth_settings: List[str] = [
+            'bearerAuth'
+        ]
+
+        return self.api_client.param_serialize(
+            method='GET',
+            resource_path='/api/v1/prompt/create/name/{desired}',
+            path_params=_path_params,
+            query_params=_query_params,
+            header_params=_header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            auth_settings=_auth_settings,
+            collection_formats=_collection_formats,
+            _host=_host,
+            _request_auth=_request_auth
+        )
+
+
+
+
+    @validate_call
     def publish_prompt(
         self,
-        prompt_id: Annotated[StrictStr, Field(description="The promptId to be published")],
+        prompt_id: Annotated[StrictInt, Field(description="The promptId to be published")],
         visibility: Annotated[StrictStr, Field(description="Visibility: public | private | ...")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> str:
+    ) -> int:
         """Publish Prompt
 
         Publish prompt, draft content becomes formal content, version number increases by 1. After successful publication, a new promptId will be generated and returned. You need to specify the visibility for publication.
 
         :param prompt_id: The promptId to be published (required)
-        :type prompt_id: str
+        :type prompt_id: int
         :param visibility: Visibility: public | private | ... (required)
         :type visibility: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
@@ -3903,16 +4611,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -3920,35 +4627,35 @@
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
     def publish_prompt_with_http_info(
         self,
-        prompt_id: Annotated[StrictStr, Field(description="The promptId to be published")],
+        prompt_id: Annotated[StrictInt, Field(description="The promptId to be published")],
         visibility: Annotated[StrictStr, Field(description="Visibility: public | private | ...")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
             ]
         ] = None,
         _request_auth: Optional[Dict[StrictStr, Any]] = None,
         _content_type: Optional[StrictStr] = None,
         _headers: Optional[Dict[StrictStr, Any]] = None,
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[str]:
+    ) -> ApiResponse[int]:
         """Publish Prompt
 
         Publish prompt, draft content becomes formal content, version number increases by 1. After successful publication, a new promptId will be generated and returned. You need to specify the visibility for publication.
 
         :param prompt_id: The promptId to be published (required)
-        :type prompt_id: str
+        :type prompt_id: int
         :param visibility: Visibility: public | private | ... (required)
         :type visibility: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
@@ -3975,16 +4682,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -3992,15 +4698,15 @@
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
     def publish_prompt_without_preload_content(
         self,
-        prompt_id: Annotated[StrictStr, Field(description="The promptId to be published")],
+        prompt_id: Annotated[StrictInt, Field(description="The promptId to be published")],
         visibility: Annotated[StrictStr, Field(description="Visibility: public | private | ...")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -4012,15 +4718,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
         """Publish Prompt
 
         Publish prompt, draft content becomes formal content, version number increases by 1. After successful publication, a new promptId will be generated and returned. You need to specify the visibility for publication.
 
         :param prompt_id: The promptId to be published (required)
-        :type prompt_id: str
+        :type prompt_id: int
         :param visibility: Visibility: public | private | ... (required)
         :type visibility: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
@@ -4047,16 +4753,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "str"
-            
+            '200': "int",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -4065,27 +4770,26 @@
         self,
         prompt_id,
         visibility,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if prompt_id is not None:
             _path_params['promptId'] = prompt_id
         if visibility is not None:
             _path_params['visibility'] = visibility
@@ -4094,15 +4798,15 @@
         # process the form parameters
         # process the body parameter
 
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             [
-                'text/plain'
+                'application/json'
             ]
         )
 
 
         # authentication setting
         _auth_settings: List[str] = [
             'bearerAuth'
@@ -4176,16 +4880,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PromptDetailsDTO]"
-            
+            '200': "List[PromptDetailsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -4244,16 +4947,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PromptDetailsDTO]"
-            
+            '200': "List[PromptDetailsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -4312,16 +5014,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PromptDetailsDTO]"
-            
+            '200': "List[PromptDetailsDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -4329,27 +5030,26 @@
     def _search_prompt_details_serialize(
         self,
         prompt_query_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
@@ -4451,16 +5151,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PromptSummaryDTO]"
-            
+            '200': "List[PromptSummaryDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -4519,16 +5218,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PromptSummaryDTO]"
-            
+            '200': "List[PromptSummaryDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -4587,16 +5285,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[PromptSummaryDTO]"
-            
+            '200': "List[PromptSummaryDTO]",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -4604,27 +5301,26 @@
     def _search_prompt_summary_serialize(
         self,
         prompt_query_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
@@ -4726,16 +5422,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "LlmResultDTO"
-            
+            '200': "LlmResultDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -4794,16 +5489,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "LlmResultDTO"
-            
+            '200': "LlmResultDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -4862,16 +5556,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "LlmResultDTO"
-            
+            '200': "LlmResultDTO",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -4879,27 +5572,26 @@
     def _send_prompt_serialize(
         self,
         prompt_ai_param_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
@@ -5001,16 +5693,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SseEmitter"
-            
+            '200': "SseEmitter",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -5069,16 +5760,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SseEmitter"
-            
+            '200': "SseEmitter",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -5137,16 +5827,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SseEmitter"
-            
+            '200': "SseEmitter",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -5154,27 +5843,26 @@
     def _stream_send_prompt_serialize(
         self,
         prompt_ai_param_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         # process the query parameters
         # process the header parameters
         # process the form parameters
         # process the body parameter
@@ -5225,15 +5913,15 @@
 
 
 
 
     @validate_call
     def update_prompt(
         self,
-        prompt_id: Annotated[StrictStr, Field(description="The promptId to be updated")],
+        prompt_id: Annotated[StrictInt, Field(description="The promptId to be updated")],
         prompt_update_dto: Annotated[PromptUpdateDTO, Field(description="The prompt information to be updated")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -5245,15 +5933,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> bool:
         """Update Prompt
 
         Update prompt, refer to /api/v1/prompt/create, required field: promptId. Returns success or failure.
 
         :param prompt_id: The promptId to be updated (required)
-        :type prompt_id: str
+        :type prompt_id: int
         :param prompt_update_dto: The prompt information to be updated (required)
         :type prompt_update_dto: PromptUpdateDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
@@ -5280,16 +5968,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -5297,15 +5984,15 @@
             response_types_map=_response_types_map,
         ).data
 
 
     @validate_call
     def update_prompt_with_http_info(
         self,
-        prompt_id: Annotated[StrictStr, Field(description="The promptId to be updated")],
+        prompt_id: Annotated[StrictInt, Field(description="The promptId to be updated")],
         prompt_update_dto: Annotated[PromptUpdateDTO, Field(description="The prompt information to be updated")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -5317,15 +6004,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> ApiResponse[bool]:
         """Update Prompt
 
         Update prompt, refer to /api/v1/prompt/create, required field: promptId. Returns success or failure.
 
         :param prompt_id: The promptId to be updated (required)
-        :type prompt_id: str
+        :type prompt_id: int
         :param prompt_update_dto: The prompt information to be updated (required)
         :type prompt_update_dto: PromptUpdateDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
@@ -5352,16 +6039,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         response_data.read()
         return self.api_client.response_deserialize(
@@ -5369,15 +6055,15 @@
             response_types_map=_response_types_map,
         )
 
 
     @validate_call
     def update_prompt_without_preload_content(
         self,
-        prompt_id: Annotated[StrictStr, Field(description="The promptId to be updated")],
+        prompt_id: Annotated[StrictInt, Field(description="The promptId to be updated")],
         prompt_update_dto: Annotated[PromptUpdateDTO, Field(description="The prompt information to be updated")],
         _request_timeout: Union[
             None,
             Annotated[StrictFloat, Field(gt=0)],
             Tuple[
                 Annotated[StrictFloat, Field(gt=0)],
                 Annotated[StrictFloat, Field(gt=0)]
@@ -5389,15 +6075,15 @@
         _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
     ) -> RESTResponseType:
         """Update Prompt
 
         Update prompt, refer to /api/v1/prompt/create, required field: promptId. Returns success or failure.
 
         :param prompt_id: The promptId to be updated (required)
-        :type prompt_id: str
+        :type prompt_id: int
         :param prompt_update_dto: The prompt information to be updated (required)
         :type prompt_update_dto: PromptUpdateDTO
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :type _request_timeout: int, tuple(int, int), optional
@@ -5424,16 +6110,15 @@
             _request_auth=_request_auth,
             _content_type=_content_type,
             _headers=_headers,
             _host_index=_host_index
         )
 
         _response_types_map: Dict[str, Optional[str]] = {
-            '200': "bool"
-            
+            '200': "bool",
         }
         response_data = self.api_client.call_api(
             *_param,
             _request_timeout=_request_timeout
         )
         return response_data.response
 
@@ -5442,27 +6127,26 @@
         self,
         prompt_id,
         prompt_update_dto,
         _request_auth,
         _content_type,
         _headers,
         _host_index,
-    ) -> Tuple:
+    ) -> RequestSerialized:
 
         _host = None
 
         _collection_formats: Dict[str, str] = {
-            
         }
 
         _path_params: Dict[str, str] = {}
         _query_params: List[Tuple[str, str]] = []
         _header_params: Dict[str, Optional[str]] = _headers or {}
         _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
+        _files: Dict[str, Union[str, bytes]] = {}
         _body_params: Optional[bytes] = None
 
         # process the path parameters
         if prompt_id is not None:
             _path_params['promptId'] = prompt_id
         # process the query parameters
         # process the header parameters
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

