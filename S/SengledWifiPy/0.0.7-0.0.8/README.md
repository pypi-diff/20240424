# Comparing `tmp/sengledwifipy-0.0.7.tar.gz` & `tmp/sengledwifipy-0.0.8.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "sengledwifipy-0.0.7.tar", max compression
+gzip compressed data, was "sengledwifipy-0.0.8.tar", max compression
```

## Comparing `sengledwifipy-0.0.7.tar` & `sengledwifipy-0.0.8.tar`

### file list

```diff
@@ -1,11 +1,11 @@
--rw-r--r--   0        0        0    11357 2024-04-17 22:33:46.984934 sengledwifipy-0.0.7/LICENSE
--rw-r--r--   0        0        0     2368 2024-04-17 22:33:46.984934 sengledwifipy-0.0.7/README.md
--rw-r--r--   0        0        0     3074 2024-04-17 22:33:59.705095 sengledwifipy-0.0.7/pyproject.toml
--rw-r--r--   0        0        0     1448 2024-04-17 22:33:46.988934 sengledwifipy-0.0.7/sengledwifipy/__init__.py
--rw-r--r--   0        0        0      716 2024-04-17 22:33:46.988934 sengledwifipy-0.0.7/sengledwifipy/const.py
--rw-r--r--   0        0        0      773 2024-04-17 22:33:46.988934 sengledwifipy-0.0.7/sengledwifipy/errors.py
--rw-r--r--   0        0        0     6954 2024-04-17 22:33:46.988934 sengledwifipy-0.0.7/sengledwifipy/helpers.py
--rw-r--r--   0        0        0     6982 2024-04-17 22:33:46.988934 sengledwifipy-0.0.7/sengledwifipy/sengledwifiapi.py
--rw-r--r--   0        0        0    11888 2024-04-17 22:33:46.988934 sengledwifipy-0.0.7/sengledwifipy/sengledwifilogin.py
--rw-r--r--   0        0        0    12212 2024-04-17 22:33:46.988934 sengledwifipy-0.0.7/sengledwifipy/sengledwifimqtt.py
--rw-r--r--   0        0        0     3264 1970-01-01 00:00:00.000000 sengledwifipy-0.0.7/PKG-INFO
+-rw-r--r--   0        0        0    11357 2024-04-23 22:58:58.395581 sengledwifipy-0.0.8/LICENSE
+-rw-r--r--   0        0        0     3333 2024-04-23 22:58:58.395581 sengledwifipy-0.0.8/README.md
+-rw-r--r--   0        0        0     2847 2024-04-23 22:59:20.007888 sengledwifipy-0.0.8/pyproject.toml
+-rw-r--r--   0        0        0      228 2024-04-23 22:58:58.395581 sengledwifipy-0.0.8/sengledwifipy/__init__.py
+-rw-r--r--   0        0        0      717 2024-04-23 22:58:58.395581 sengledwifipy-0.0.8/sengledwifipy/const.py
+-rw-r--r--   0        0        0      662 2024-04-23 22:58:58.395581 sengledwifipy-0.0.8/sengledwifipy/errors.py
+-rw-r--r--   0        0        0     6497 2024-04-23 22:58:58.395581 sengledwifipy-0.0.8/sengledwifipy/helpers.py
+-rw-r--r--   0        0        0     7395 2024-04-23 22:58:58.395581 sengledwifipy-0.0.8/sengledwifipy/sengledwifiapi.py
+-rw-r--r--   0        0        0    11716 2024-04-23 22:58:58.395581 sengledwifipy-0.0.8/sengledwifipy/sengledwifilogin.py
+-rw-r--r--   0        0        0    12106 2024-04-23 22:58:58.395581 sengledwifipy-0.0.8/sengledwifipy/sengledwifimqtt.py
+-rw-r--r--   0        0        0     4233 1970-01-01 00:00:00.000000 sengledwifipy-0.0.8/PKG-INFO
```

### Comparing `sengledwifipy-0.0.7/LICENSE` & `sengledwifipy-0.0.8/LICENSE`

 * *Files identical despite different names*

### Comparing `sengledwifipy-0.0.7/pyproject.toml` & `sengledwifipy-0.0.8/pyproject.toml`

 * *Files 21% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 #  SPDX-License-Identifier: Apache-2.0
 
 [tool.poetry]
 name = "SengledWifiPy"
-version = "0.0.7"
-description = "Python API to control Sengled Wifi Devices Programmatically."
+version = "0.0.8"
+description = "Python package to control Sengled Wifi Devices Programmatically."
 authors = [
   "Cesar <gv4plolxe@mozmail.com>"
 ]
 license = "Apache-2.0"
 readme = 'README.md'
 repository = "https://github.com/cpadil/sengledwifipy"
 keywords = ['Sengled', 'Wifi', 'homeassistant']
@@ -35,17 +35,19 @@
 python-semantic-release = "^9.4.2"
 safety = ">=1.8.7"
 Sphinx = ">=3.5.0,<7.0.0"
 tomlkit = ">=0.7.0"
 sphinx-autoapi = ">=1.7.0"
 myst-parser = "^2.0.0"
 furo = "^2024.1.29"
+pre-commit = "^3.7.0"
+commitizen = "^3.24.0"
+pre-commit-hooks = "^4.6.0"
 
 [tool.ruff]
-# Exclude a variety of commonly ignored directories.
 exclude = [
     ".bzr",
     ".direnv",
     ".eggs",
     ".git",
     ".github",
     ".git-rewrite",
@@ -70,72 +72,59 @@
     "node_modules",
     "site-packages",
     "venv",
     "docs"
 ]
 line-length = 130
 indent-width = 4
+show-fixes = true
 
 [tool.ruff.format]
 docstring-code-format = false
+skip-magic-trailing-comma = false
 
 [tool.ruff.lint]
-select = ["E", "F"]
-ignore = ["F401"]
+select = ["E4", "E7", "E9", "F", "I001", "D"]
+ignore = ["F401", "D417"]
+
+[tool.ruff.lint.isort]
+known-first-party = ["sengledwifipy"]
+
+[tool.ruff.lint.pydocstyle]
+convention = "google"
 
 [tool.semantic_release]
-assets = []
+commit_author = "semantic-release <semantic-release>"
 commit_message = "[no ci] v{version}\n\nAutomatically generated by python-semantic-release"
 commit_parser = "angular"
 logging_use_named_masks = false
 major_on_zero = false
 allow_zero_version = true
 tag_format = "v{version}"
 version_toml = [
     "pyproject.toml:tool.poetry.version",
 ]
 
-[tool.semantic_release.branches.main]
-match = "main"
-prerelease_token = "rc"
-prerelease = false
-
 [tool.semantic_release.changelog]
-template_dir = "templates"
+template_dir = "docs/source/template"
 changelog_file = "CHANGELOG.md"
 exclude_commit_patterns = [
-  "[no ci] v{version}\n\nAutomatically generated by python-semantic-release"
+  "[no ci] v{version}\n\nAutomatically generated by python-semantic-release",
+  "Merge branch",
+  "Merge pull request",
 ]
 
-[tool.semantic_release.changelog.environment]
-block_start_string = "{%"
-block_end_string = "%}"
-variable_start_string = "{{"
-variable_end_string = "}}"
-comment_start_string = "{#"
-comment_end_string = "#}"
-trim_blocks = false
-lstrip_blocks = false
-newline_sequence = "\n"
-keep_trailing_newline = false
-extensions = []
-autoescape = true
-
-[tool.semantic_release.commit_author]
-env = "GIT_COMMIT_AUTHOR"
-default = "semantic-release <semantic-release>"
-
 [tool.semantic_release.commit_parser_options]
 allowed_tags = ["build", "chore", "ci", "docs", "feat", "fix", "perf", "style", "refactor", "test"]
 minor_tags = ["feat"]
 patch_tags = ["fix", "perf"]
 default_bump_level = 0
 
 [tool.semantic_release.remote]
 name = "origin"
 type = "github"
 ignore_token_for_push = false
 insecure = false
 token = { env = "GH_TOKEN" }
 
 [tool.semantic_release.publish]
-upload_to_vcs_release = false
+upload_to_vcs_release = false
```

### Comparing `sengledwifipy-0.0.7/sengledwifipy/const.py` & `sengledwifipy-0.0.8/sengledwifipy/const.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-"""Python Package for controlling Sengled Wifi devices. SPDX-License-Identifier: Apache-2.0"""
+"""Python Package for controlling Sengled Wifi devices. SPDX-License-Identifier: Apache-2.0."""
 
 HA_DOMAIN = "sengledwifi"
 """For Home Assistant integration."""
 
 APP_NAME = "Sengled Wifi"
 """For Home Assistant integration."""
```

### Comparing `sengledwifipy-0.0.7/sengledwifipy/errors.py` & `sengledwifipy-0.0.8/sengledwifipy/errors.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-"""Python Package for controlling Sengled Wifi devices. SPDX-License-Identifier: Apache-2.0"""
+"""Python Package for controlling Sengled Wifi devices. SPDX-License-Identifier: Apache-2.0."""
 
 
 class SengledWifipyError(Exception):
     """Define a base error."""
 
 
 class SengledWifipyConnectionError(SengledWifipyError):
@@ -15,11 +15,7 @@
 
 class SengledWifipyTooManyRequestsError(SengledWifipyError):
     """Define an error related to too many requests."""
 
 
 class SengledWifipyLoginCloseRequested(SengledWifipyError):
     """Define an error related to requesting access to API after requested close."""
-
-
-class SengledWifipyPyotpInvalidKey(SengledWifipyError):
-    """Define an error related to invalid 2FA key."""
```

### Comparing `sengledwifipy-0.0.7/sengledwifipy/helpers.py` & `sengledwifipy-0.0.8/sengledwifipy/helpers.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,17 +1,18 @@
-"""Python Package for controlling Sengled Wifi devices. SPDX-License-Identifier: Apache-2.0"""
+"""Python Package for controlling Sengled Wifi devices. SPDX-License-Identifier: Apache-2.0."""
 
 import functools
 import logging
 from asyncio import CancelledError
 from http.cookies import CookieError, Morsel
 from json import JSONDecodeError
 from types import MappingProxyType
-from typing import Optional, Union
+
 from aiohttp import ClientConnectionError, ContentTypeError, ServerDisconnectedError
+
 from .const import EXCEPTION_TEMPLATE
 from .errors import (
     SengledWifipyConnectionError,
     SengledWifipyLoginCloseRequested,
     SengledWifipyLoginError,
 )
 
@@ -27,15 +28,15 @@
 
 
 def hide_password(value: str) -> str:
     """Obfuscate password."""
     return f"REDACTED {len(value)} CHARS"
 
 
-def hide_serial(item: Optional[Union[dict, str, list]]) -> Union[dict, str, list]:
+def hide_serial(item: dict | str | list) -> dict | str | list:
     """Obfuscate serial."""
     if item is None:
         return ""
     if isinstance(item, dict):
         response = item.copy()
         for key, value in item.items():
             if (
@@ -108,22 +109,17 @@
             response = tuple(response)
     else:
         return item
 
     return response
 
 
-def catch_all_exceptions(func):
+def catch_all_exceptions(func):  # noqa: D103
     @functools.wraps(func)
     async def wrapper(*args, **kwargs):
-        # login: Optional["sengledwifipy.sengledwifilogin.SengledLogin"] = None
-        # for arg in args:
-        #     if isinstance(arg, sengledwifipy.sengledwifilogin.SengledLogin):
-        #         login = arg
-        #         break
         try:
             return await func(*args, **kwargs)
         except (ClientConnectionError, KeyError, ServerDisconnectedError) as ex:
             _LOGGER.warning(
                 "%s.%s(%s, %s): A connection error occurred: %s",
                 func.__module__[func.__module__.find(".") + 1 :],
                 func.__name__,
@@ -137,28 +133,24 @@
                 "%s.%s(%s, %s): A login error occurred: %s",
                 func.__module__[func.__module__.find(".") + 1 :],
                 func.__name__,
                 obfuscate(args),
                 obfuscate(kwargs),
                 EXCEPTION_TEMPLATE.format(type(ex).__name__, ex.args),
             )
-            # if login:
-            #     login.status["login_successful"] = False
             raise SengledWifipyLoginError from ex
         except ContentTypeError as ex:
             _LOGGER.warning(
                 "%s.%s(%s, %s): A login error occurred: %s",
                 func.__module__[func.__module__.find(".") + 1 :],
                 func.__name__,
                 obfuscate(args),
                 obfuscate(kwargs),
                 EXCEPTION_TEMPLATE.format(type(ex).__name__, ex.args),
             )
-            # if login:
-            #     login.status["login_successful"] = False
             raise SengledWifipyLoginError from ex
         except CancelledError as ex:
             _LOGGER.warning(
                 "%s.%s(%s, %s): Timeout error occurred accessing SengledWifiAPI: %s",
                 func.__module__[func.__module__.find(".") + 1 :],
                 func.__name__,
                 obfuscate(args),
@@ -174,23 +166,21 @@
                 func.__module__[func.__module__.find(".") + 1 :],
                 func.__name__,
                 obfuscate(args),
                 obfuscate(kwargs),
                 EXCEPTION_TEMPLATE.format(type(ex).__name__, ex.args),
             )
             raise
-            # return None
 
     return wrapper
 
 
-def valid_login_required(func):
+def valid_login_required(func):  # noqa: D103
     @functools.wraps(func)
     async def wrapper(*args, **kwargs):
-
         login = (
             getattr(args[0], "_login", None) if hasattr(args[0], "_login") else [arg for arg in args if hasattr(arg, "_urls")][0]
         )
 
         if not await login.valid_login():
             await login.login(SkipTest=True)
         return await func(*args, **kwargs)
```

### Comparing `sengledwifipy-0.0.7/sengledwifipy/sengledwifiapi.py` & `sengledwifipy-0.0.8/sengledwifipy/sengledwifiapi.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,29 +1,32 @@
-"""Python Package for controlling Sengled Wifi devices. SPDX-License-Identifier: Apache-2.0"""
+"""Python Package for controlling Sengled Wifi devices. SPDX-License-Identifier: Apache-2.0."""
 
 from __future__ import annotations
+
 import json
 import logging
 import time
-from typing import Any, Optional, TYPE_CHECKING
-from aiohttp import ClientConnectionError, ClientResponse
+from typing import TYPE_CHECKING, Any
+
 import backoff
+from aiohttp import ClientConnectionError, ClientResponse
 from yarl import URL
 
-if TYPE_CHECKING:
-    from .sengledwifilogin import SengledLogin
-    from .sengledwifimqtt import SengledWifiMQTT
-
 from .errors import (
     SengledWifipyConnectionError,
     SengledWifipyLoginCloseRequested,
     SengledWifipyLoginError,
     SengledWifipyTooManyRequestsError,
 )
 
+if TYPE_CHECKING:
+    from .sengledwifilogin import SengledLogin
+    from .sengledwifimqtt import SengledWifiMQTT
+
+
 from .helpers import catch_all_exceptions, hide_email, valid_login_required
 
 _LOGGER = logging.getLogger(__name__)
 
 
 class SengledWifiAPI:
     """Uses SengledWifiMqtt and SengledLogin to get information of the devices and set their state.
@@ -50,24 +53,24 @@
         logger=__name__,
     )
     @valid_login_required
     async def _static_request(
         method: str,
         login: SengledLogin,
         uri: str,
-        data: Optional[dict[str, str]] = None,
-        query: Optional[dict[str, str]] = None,
+        data: dict[str, str] = None,
+        query: dict[str, str] = None,
     ) -> ClientResponse:
         """Call an API.
 
         Args:
             login (SengledLogin): needs a valid login
             uri (str): will use the appserver endpoint with this uri
-            data (Optional[dict[str, str]]): payload
-            query (Optional[dict[str, str]]): query parameters
+            data (dict[str, str]): payload
+            query (dict[str, str]): query parameters
 
         Returns:
             None or aiohttp ClientResponse
         """
         session = login.session
         url: URL = URL(login.urls["appserver"] + uri).update_query(query)
 
@@ -91,27 +94,35 @@
         if response.status >= 400:
             _LOGGER.debug(f"SengledWifiApi: API Returning None due to status: {response.status}")
             return None
         return response
 
     @staticmethod
     @catch_all_exceptions
-    async def get_devices(login: SengledLogin, entity_ids: Optional[list[str]] = None) -> Optional[dict[str, Any]]:
+    async def get_devices(
+        login: SengledLogin,
+        entity_ids: list[str] = None,
+    ) -> dict[str, str | int | bool]:
         """Retrieve all Sengled Wifi Devices or the specified ones via entity_ids arg.
 
         Args:
             login (SengledLogin): Successfully logged in SengledLogin
             entity_ids (List[str]): The list of entities you want information about. \
                 Optional if all devices information is required. (replaces get_entity_state)
 
         Returns:
             Json. Device information.
         """
-
-        response = await SengledWifiAPI._static_request("post", login, "device/list.json", query=None, data={})
+        response = await SengledWifiAPI._static_request(
+            "post",
+            login,
+            "device/list.json",
+            query=None,
+            data={},
+        )
 
         SengledWifiAPI.devices[login.email] = (
             [
                 item
                 for item in (await response.json(content_type=None))["deviceList"]
                 if (item["category"] == "wifielement" and (entity_ids is None or item["deviceUuid"] in entity_ids))
             ]
@@ -125,17 +136,17 @@
 
     @staticmethod
     @catch_all_exceptions
     async def set_device_state(
         mqttc: SengledWifiMQTT,
         entity_id: str,
         power_on: bool = None,
-        brightness: Optional[int] = None,
-        color: Optional[str] = None,
-        color_temperature: Optional[int] = None,
+        brightness: int = None,
+        color: str = None,
+        color_temperature: int = None,
     ) -> bool:
         """Set state of a device.
 
         Args:
             mqttc (SengledWifiMQTT): MQTT client
             entity_id (str): Entity ID of The light.
             power_on (bool): Should the light be on or off.
@@ -149,26 +160,55 @@
 
         def convert_color_HA(hacolor):
             sengled_color = str(hacolor)
             for r in ((" ", ""), (",", ":"), ("(", ""), (")", "")):
                 sengled_color = sengled_color.replace(*r)
             return sengled_color
 
-        power_on = {"value": ("1" if power_on else "0"), "name": "switch"} if isinstance(power_on, bool) else None
+        power_on = (
+            {
+                "value": ("1" if power_on else "0"),
+                "name": "switch",
+            }
+            if isinstance(power_on, bool)
+            else None
+        )
         brightness = (
-            {"value": str(round((brightness / 255) * 100)), "name": "brightness"} if isinstance(brightness, int) else None
+            {
+                "value": str(round((brightness / 255) * 100)),
+                "name": "brightness",
+            }
+            if isinstance(brightness, int)
+            else None
+        )
+        color = (
+            {
+                "value": convert_color_HA(color),
+                "name": "color",
+            }
+            if isinstance(color, str)
+            else None
         )
-        color = {"value": convert_color_HA(color), "name": "color"} if isinstance(color, str) else None
         color_temperature = (
-            {"value": str(round((color_temperature / 6500) * 100)), "name": "colorTemperature"}
+            {
+                "value": str(round((color_temperature / 6500) * 100)),
+                "name": "colorTemperature",
+            }
             if isinstance(color_temperature, int)
             else None
         )
 
-        color_temp = {"value": "255:45:41", "name": "color"} if isinstance(color_temperature, int) else None
+        color_temp = (
+            {
+                "value": "255:45:41",
+                "name": "color",
+            }
+            if isinstance(color_temperature, int)
+            else None
+        )
 
         timev = str(int(time.time()) - 1577858400)
 
         data = [
             {
                 "dn": entity_id,
                 "type": option["name"],
```

### Comparing `sengledwifipy-0.0.7/sengledwifipy/sengledwifilogin.py` & `sengledwifipy-0.0.8/sengledwifipy/sengledwifilogin.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,25 +1,29 @@
-"""Python Package for controlling Sengled Wifi devices. SPDX-License-Identifier: Apache-2.0"""
+"""Python Package for controlling Sengled Wifi devices. SPDX-License-Identifier: Apache-2.0."""
 
 import logging
 import os as oos
+import ssl
 from datetime import datetime
 from json import JSONDecodeError, dumps
-from typing import Callable, Optional, Union
+from typing import Callable
 from uuid import uuid4
+
+import certifi
 from aiofiles import os
-from aiohttp import ContentTypeError, ClientSession, CookieJar
+from aiohttp import ClientSession, ContentTypeError, CookieJar
 from simplejson import JSONDecodeError as SimpleJSONDecodeError
-from .const import EXCEPTION_TEMPLATE, USER_AGENT, SENGLED_ENDPOINTS, HA_DOMAIN
+
+from .const import EXCEPTION_TEMPLATE, HA_DOMAIN, SENGLED_ENDPOINTS, USER_AGENT
+from .errors import SengledWifipyLoginError
 from .helpers import (
     catch_all_exceptions,
     hide_email,
     obfuscate,
 )
-from .errors import SengledWifipyLoginError
 
 _LOGGER = logging.getLogger(__name__)
 
 
 class SengledLogin:
     """Handle login connection to Sengled.
 
@@ -28,57 +32,54 @@
         _password (string): Password for Sengled login account
         _outputpath (function): os.path.join function pointing to the folder to save a session cookie
         _uuid: (string): Unique 32 char hex to serve as app serial number for registration
         _urls(dict[str, str]): points to the constant SENGLED_ENDPOINTS which is an initial list of Sengled endpoints
         _session (aiohttp.ClientSession): initializes an empty aiohttp.ClientSession to store the cookie information
         _ssl (ssl): used during the authentication
         _headers (dict[str, str]): based on USER_AGENT constant
-        status (Optional[dict[str, Union[str, bool]]]): track if the connection is still valid
-        stats (Optional[dict[str, Union[str, bool]]]): track number of api calls done
+        status (dict[str, str | bool]): track if the connection is still valid
+        stats (dict[str, str | bool]): track number of api calls done
         _cookiefile (str): in combination with _outputpath, provides the path to save the cookie
-        _customer_id (Optional[str]): to store the customer id provided by the authentication api
+        _customer_id (str): to store the customer id provided by the authentication api
         _data (dict[str,str]): body for the authentication api
     """
 
     hass_domain = HA_DOMAIN
     """class attribute; from constant HA_DOMAIN"""
 
     def __init__(
         self,
         email: str,
         password: str,
         outputpath: Callable[[str], str] = None,
-        uuid: Optional[str] = None,
+        uuid: str = None,
     ) -> None:
-        """Initialization of SengledLogin class. Calls _create_session to initialize a aiohttp.ClientSession
+        """Initialization of SengledLogin class. Calls _create_session to initialize a aiohttp.ClientSession.
 
         Args:
             email (string): Sengled login account
             password (string): Password for Sengled login account
-            outputpath (Optional[function]): Local path with write access for storing files
-            uuid: (Optional[string]): Unique 32 char hex to serve as app serial number for registration
+            outputpath (function): Local path with write access for storing files
+            uuid: (string): Unique 32 char hex to serve as app serial number for registration
 
         """
-        import ssl
-        import certifi
-
         self._urls: dict[str, str] = SENGLED_ENDPOINTS
         self._email: str = email
         self._password: str = password
-        self._session: Optional[ClientSession] = None
+        self._session: ClientSession = None
         self._ssl = ssl.create_default_context(purpose=ssl.Purpose.SERVER_AUTH, cafile=certifi.where())
         self._headers: dict[str, str] = {}
-        self.status: Optional[dict[str, Union[str, bool]]] = {}
-        self.stats: Optional[dict[str, Union[str, bool]]] = {
+        self.status: dict[str, str | bool] = {}
+        self.stats: dict[str, str | bool] = {
             "login_timestamp": datetime(1, 1, 1),
             "api_calls": 0,
         }
         self._outputpath = outputpath if outputpath is not None else (lambda b: oos.path.join("temp", b))
         self._cookiefile: str = self._outputpath(f".storage/{type(self).hass_domain}.{self.email}.pickle")
-        self._customer_id: Optional[str] = None
+        self._customer_id: str = None
         self._uuid = uuid if uuid else uuid4().hex.upper()
         self._data = {
             "user": self._email,
             "pwd": self._password,
             "uuid": self._uuid,
             "osType": "android",
             "productCode": "life",
@@ -90,29 +91,29 @@
     @property
     def urls(self) -> str:
         """SENGLED_ENDPOINTS plus the endpoints provided by _get_server_info."""
         return self._urls
 
     @property
     def email(self) -> str:
-        """email account for this Login."""
+        """Email account for this Login."""
         return self._email
 
     @property
-    def customer_id(self) -> Optional[str]:
+    def customer_id(self) -> str | None:
         """customer_id for this Login."""
         return self._customer_id
 
     @property
-    def session(self) -> Optional[ClientSession]:
-        """session for this Login."""
+    def session(self) -> ClientSession | None:
+        """Session for this Login."""
         return self._session
 
     def _create_session(self) -> None:
-        """Create an aiohttp session. Called during the initialization"""
+        """Create an aiohttp session. Called during the initialization."""
         _LOGGER.debug("SengledWifiApi: LOGIN Creating session")
 
         if not self._session:
             #  define session headers
             self._headers = {
                 "User-Agent": USER_AGENT,
                 "Accept": "*/*",
@@ -127,15 +128,14 @@
 
         Args:
             None
         Returns:
             Bool. True if the session is still valid, because the cookies has been created recently.
             False if for some reason the cookie no longer exists or there was an error with the validSession endpoint.
         """
-
         _LOGGER.debug(f'SengledWifiApi: LOGIN validation of session \
                       \n--URL {self._urls["validSession"]}  \
                       \n--Headers {dumps(self._headers)} \
                       \n--last login: {self.stats["login_timestamp"]} \
                       \n--hours: {round((datetime.now() - self.stats["login_timestamp"]).total_seconds()/3600)}h ')
         if (datetime.now() - self.stats["login_timestamp"]).total_seconds() < 86400 and await os.path.exists(self._cookiefile):
             resp = None
@@ -167,20 +167,19 @@
         return False
 
     @catch_all_exceptions
     async def login(self, SkipTest: bool = False) -> None:
         """Login to Sengled.
 
         Args:
-            SkipTest (Optional[bool]): login without validation (in case there is a cookie in storage)
+            SkipTest (bool): login without validation (in case there is a cookie in storage)
 
         Returns:
             None
         """
-
         if not SkipTest:
             if await self.valid_login():
                 return
 
         _LOGGER.debug("SengledWifiApi: LOGIN Using credentials to login")
 
         post_resp = await self._session.post(
@@ -217,25 +216,24 @@
                           \n--{EXCEPTION_TEMPLATE.format(type(ex).__name__, ex.args)}')
             raise SengledWifipyLoginError
 
         _LOGGER.debug(f"SengledWifiApi: LOGIN Saved session Cookies: \
                       \n--{self._print_session_cookies()}")
 
     def _print_session_cookies(self) -> str:
-        """Prints the value of the cookies in aiohttp session"""
+        """Prints the value of the cookies in aiohttp session."""
         result: str = ""
         if not self._session.cookie_jar:
             result = "Session cookie jar is empty."
         for cookie in self._session.cookie_jar:
             result += f"{obfuscate(cookie)}"
         return result
 
     async def _get_server_info(self) -> None:
         """Call to serverDetails endpoint to get Mqtt related endpoints. Called from Login."""
-
         _LOGGER.debug("SengledWifiApi: LOGIN Getting server endpoints from: %s", self._urls["serverDetails"])
 
         post_resp = await self._session.post(
             self._urls["serverDetails"],
             json={},
             headers=self._headers,
             ssl=self._ssl,
@@ -256,15 +254,14 @@
                 }
             )
             _LOGGER.debug(f"SengledWifiApi: LOGIN Success getting endpoints: \n {dumps(self._urls)}")
         return
 
     async def close(self) -> None:
         """Close connection for login."""
-
         if self._session and not self._session.closed:
             if self._session._connector_owner:
                 assert self._session._connector is not None
                 await self._session._connector.close()
             self._session._connector = None
 
     async def reset(self) -> None:
```

### Comparing `sengledwifipy-0.0.7/sengledwifipy/sengledwifimqtt.py` & `sengledwifipy-0.0.8/sengledwifipy/sengledwifimqtt.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,17 +1,20 @@
-"""Python Package for controlling Sengled Wifi devices. SPDX-License-Identifier: Apache-2.0"""
+"""Python Package for controlling Sengled Wifi devices. SPDX-License-Identifier: Apache-2.0."""
 
 from __future__ import annotations
-import logging
-import json
+
 import asyncio
+import json
+import logging
+from typing import TYPE_CHECKING, Any, Callable, Coroutine
+
+from paho.mqtt import client as mqtt
+from paho.mqtt import enums as mqttenums
 from yarl import URL
-from typing import Callable, Any, Optional, Iterable, TYPE_CHECKING
-from collections.abc import Coroutine
-from paho.mqtt import client as mqtt, enums as mqttenums
+
 from .helpers import valid_login_required
 
 if TYPE_CHECKING:
     from .sengledwifilogin import SengledLogin
 
 _LOGGER = logging.getLogger(__name__)
 
@@ -36,66 +39,65 @@
         error_callback (Callable): an async function to call within the on_error callback
         _loop (asyncio.AbstractEventLoop): used for callbacks
     """
 
     def __init__(
         self,
         login: SengledLogin,
-        msg_callback: Optional[Callable[[], Coroutine[Any, Any, None]]] = None,
-        open_callback: Optional[Callable[[], Coroutine[Any, Any, None]]] = None,
-        close_callback: Optional[Callable[[], Coroutine[Any, Any, None]]] = None,
-        error_callback: Optional[Callable[[], Coroutine[Any, Any, None]]] = None,
-        loop: Optional[asyncio.AbstractEventLoop] = None,
+        msg_callback: Callable[[], Coroutine[Any, Any, None]] = None,
+        open_callback: Callable[[], Coroutine[Any, Any, None]] = None,
+        close_callback: Callable[[], Coroutine[Any, Any, None]] = None,
+        error_callback: Callable[[], Coroutine[Any, Any, None]] = None,
+        loop: asyncio.AbstractEventLoop = None,
     ) -> None:
         """Initialization of SengledWifiMQTT class, requires a valid SengledLogin object.
 
         Args:
             login (SengledLogin): Defines if instance exhibits this preference.
-            msg_callback (Optional[Callable]): callback function when new messages arrive.
-            open_callback (Optional[Callable]): callback function when connection is opened.
-            close_callback (Optional[Callable]): callback function when when the connection is closed.
-            error_callback (Optional[Callable]): callback function when there is an error.
-            loop: (Optional[asyncio.AbstractEventLoop]).
+            msg_callback (Callable): callback function when new messages arrive.
+            open_callback (Callable): callback function when connection is opened.
+            close_callback (Callable): callback function when when the connection is closed.
+            error_callback (Callable): callback function when there is an error.
+            loop: (asyncio.AbstractEventLoop).
         """
         self._login = login
         self._session = login.session
         self._jsession_id = self._session.cookie_jar.filter_cookies("https://sengled.com")["JSESSIONID"].value
         self._headers = {
             "Cookie": f"JSESSIONID={self._jsession_id}",
             "X-Requested-With": "com.sengled.life2",
         }
         self._clientid = f"{self._jsession_id}@lifeApp"
         self.mqtt_server = URL(login.urls["mqtt"])
         self.mqtt_client: mqtt.Client = None
         self._status: bool = False
-        self.devices: Iterable = None
+        self.devices: dict = None
         self.open_callback: Callable[[], Coroutine[Any, Any, None]] = open_callback
         self.msg_callback: Callable[[], Coroutine[Any, Any, None]] = msg_callback
         self.close_callback: Callable[[], Coroutine[Any, Any, None]] = close_callback
         self.error_callback: Callable[[str], Coroutine[Any, Any, None]] = error_callback
         self._loop: asyncio.AbstractEventLoop = loop if loop else asyncio.get_event_loop()
         self.mqtt_client = mqtt.Client(
             callback_api_version=mqttenums.CallbackAPIVersion.VERSION2,
             client_id=self._clientid,
             transport="websockets",
-            # not supported yet ,protocol = mqttenums.MQTTProtocolVersion.MQTTv5
         )
         self.mqtt_client.tls_set_context()
         self.mqtt_client.ws_set_options(
             path=self.mqtt_server.path,
             headers=self._headers,
         )
         self.mqtt_client.on_message = self.on_message
         self.mqtt_client.on_connect = self.on_connect
         self.mqtt_client.on_disconnect = self.on_disconnect
         self.mqtt_client.on_subscribe = self.on_subscribe
         self.mqtt_client.on_log = self.on_log
 
     @valid_login_required
-    async def async_connect(self, devices: Iterable = None) -> None:
+    async def async_connect(self, devices: dict = None) -> None:
         """Initialize MQTT connection async.
 
         Args:
             devices: list of Sengled devices, used to create the topic strings and subscribe
 
         Returns:
             None
@@ -107,41 +109,50 @@
             self.mqtt_server.host,
             port=self.mqtt_server.port,
             keepalive=60,
         )
         self.mqtt_client.loop_start()
 
     def on_connect(self, mqttc, userdata, flags, rc, properties) -> None:
-        """Callback. Called when the broker responds to our connection request. Calls the async function open_callback defined. \
+        """Callback. Called when the broker responds to our connection request.
+
+        Calls the async function open_callback defined. \
             Uses devices input argument to subscribe if connection is successful.
 
         Args:
             mqttc (Client): the client instance for this callback
             userdata: the private user data as set in Client() or user_data_set()
             flags (ConnectFlags): the flags for this connection
             rc (ReasonCode): the connection reason code received from the broken. \
-                In MQTT v5.0 it’s the reason code defined by the standard.
-            properties (Properties): the MQTT v5.0 properties received from the broker. 
+                In MQTT v5.0 it is the reason code defined by the standard.
+            properties (Properties): the MQTT v5.0 properties received from the broker.
 
         Returns:
             None
         """
         if rc == 0:
             _LOGGER.debug(f"SengledWifiApi: MQTT open connection result: {rc}")
 
-            topics = [("wifielement/" + device["deviceUuid"] + "/status", 2) for device in self.devices]
+            topics = [
+                (
+                    "wifielement/" + device["deviceUuid"] + "/status",
+                    2,
+                )
+                for device in self.devices
+            ]
             self.mqtt_client.subscribe(topics)
             self._status = True
             if self.open_callback:
                 asyncio.run_coroutine_threadsafe(self.open_callback(), self._loop)
             return
         _LOGGER.debug(f"SengledWifiApi: MQTT open connection error: {rc} ")
 
     def on_message(self, mqttc, userdata, msg) -> None:
-        """Callback. Called when a message has been received from mqtt broker. \
+        """Callback. Called when a message has been received from mqtt broker.
+
             Parses the message and then calls the async function msg_callback defined.
 
         Args:
             mqttc (Client): the client instance for this callback
             userdata: the private user data as set in Client() or user_data_set()
             msg (MQTTMessage): the received message. This is a class with members topic, payload, qos, retain.
 
@@ -163,31 +174,31 @@
 
         _LOGGER.debug(f"SengledWifiApi: MQTT Message parsed: {device}")
 
         if self.msg_callback:
             asyncio.run_coroutine_threadsafe(self.msg_callback(), self._loop)
 
     def on_subscribe(self, mqttc, userdata, mid, rc_list, properties):
-        """Callback. Called when the broker responds to a subscription request. 
+        """Callback. Called when the broker responds to a subscription request.
 
         Args:
             mqttc (Client): the client instance for this callback
             userdata: the private user data as set in Client() or user_data_set()
             mid (int): matches the mid variable returned from the corresponding subscribe() call.
             rc_list (list[ReasonCode]): reason codes received from the broker for each subscription. \
-                In MQTT v5.0 it is the reason code defined by the standard. 
-            properties (Properties): the MQTT v5.0 properties received from the broker. 
+                In MQTT v5.0 it is the reason code defined by the standard.
+            properties (Properties): the MQTT v5.0 properties received from the broker.
 
         Returns:
             None
         """
         _LOGGER.debug(f"SengledWifiApi: MQTT subscribe result: {mid}")
 
     def on_log(self, mqttc, userdata, level, buf):
-        """Callback. Called when the client has log information. Only used when the logger is set to debug. 
+        """Callback. Called when the client has log information. Only used when the logger is set to debug.
 
         Args:
             mqttc (Client): the client instance for this callback
             userdata: the private user data as set in Client() or user_data_set()
             level (int): gives the severity of the message and will be one of \
                 MQTT_LOG_INFO, MQTT_LOG_NOTICE, MQTT_LOG_WARNING, MQTT_LOG_ERR, and MQTT_LOG_DEBUG.
             buf (str): the message itself
@@ -203,15 +214,15 @@
 
         Args:
             mqttc (Client): the client instance for this callback
             userdata: the private user data as set in Client() or user_data_set()
             flags (ConnectFlags): the flags for this connection
             rc (ReasonCode): the connection reason code received from the broken. \
                 In MQTT v5.0 it’s the reason code defined by the standard.
-            properties (Properties): the MQTT v5.0 properties received from the broker. 
+            properties (Properties): the MQTT v5.0 properties received from the broker.
 
         Returns:
             None
         """
         _LOGGER.debug(f"SengledWifiApi: MQTT disconnected: {rc}")
         self._status = False
 
@@ -228,15 +239,14 @@
 
         Args:
             topic (str): topic to publish the message on
             payload (str): message to send as string in json format
         Returns:
             True if publish was successful or False if there was an issue
         """
-
         if not self.mqtt_client.is_connected():
             _LOGGER.debug("SengledWifiApi: MQTT Publish - not connected, trying to connect and publish")
             self.sync_connect()
             self.mqtt_client.loop_start()
 
         r = self.mqtt_client.publish(topic, payload=payload, qos=0)
         _LOGGER.debug(f"SengledWifiApi: MQTT Publish message {r.rc}")
```

### Comparing `sengledwifipy-0.0.7/PKG-INFO` & `sengledwifipy-0.0.8/PKG-INFO`

 * *Files 23% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 Metadata-Version: 2.1
 Name: SengledWifiPy
-Version: 0.0.7
-Summary: Python API to control Sengled Wifi Devices Programmatically.
+Version: 0.0.8
+Summary: Python package to control Sengled Wifi Devices Programmatically.
 Home-page: https://github.com/cpadil/sengledwifipy
 License: Apache-2.0
 Keywords: Sengled,Wifi,homeassistant
 Author: Cesar
 Author-email: gv4plolxe@mozmail.com
 Requires-Python: >=3.11,<4
 Classifier: License :: OSI Approved :: Apache Software License
@@ -21,35 +21,35 @@
 Requires-Dist: simplejson
 Requires-Dist: yarl
 Project-URL: Repository, https://github.com/cpadil/sengledwifipy
 Description-Content-Type: text/markdown
 
 # SengledWifiPy
 
-[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
-[![Python version compatibility](https://img.shields.io/pypi/pyversions/sengledwifipy)](https://pypi.org/project/sengledwifipy)
-[![Version on PyPi](https://img.shields.io/pypi/v/sengledwifipy)](https://pypi.org/project/sengledwifipy)
+[![License][license-badge]][license]
+[![Python version compatibility][python-badge]][python]
+[![Version on PyPi][pypi-badge]][pypi]
 
 
 Python package for controlling Sengled Wifi devices. 
 
 `NOTE`: This has no relation with Sengled. There's no official API. 
 
 Features:
 * Simulates the behavior of the Android App.
 * Create a websocket connection to the MQTT broker to receive updates (Cloud Push).
 * Alternative method to publish an update without creating a websocket connection.
 
 ## Documentation
 
-[Code Documentation](https://cpadil.github.io/sengledwifipy)
+[Code Documentation][documentation]
 
 TL;DR The package is based on 3 classes:
 * `SengledWifiLogin` - Takes care of the login (requires credentials), reduces the API calls to a minimum by saving a session cookie locally.
-* `SengledWifiMqtt` - Requires a login (SengledWifiLogin), creates the connection to the MQTT server, subscribe to topics and publish updates. Is a wrapper for [paho-mqtt](https://pypi.org/project/paho-mqtt/).
+* `SengledWifiMqtt` - Requires a login (SengledWifiLogin), creates the connection to the MQTT server, subscribe to topics and publish updates. Is a wrapper for [paho-mqtt][paho-mqtt-link].
 * `SengledWifiApi` - Uses the other two classes to get/set devices state
 
 
 ## Usage example
 
 Simple example that will subscribe to all the topics related to the devices in the Sengled account. SengledWifiMqtt can also receive callbacks for new messages (will be executed when an update is received).
 
@@ -76,14 +76,40 @@
 ```
 This is a way to update the device state:
 
 ```
 SengledWifiAPI.set_device_state(MqttClient,"deviceId",power_on=True, brightness=100)
 ```
 
+## Contributing
+
+1. [Check for open features/bugs][issues].
+2. [Fork the repository][fork].
+3. (Recommended) Use the latest version of Python supported >= 3.12.
+4. (Recommended) Install [poetry][poetry-link] (recommended installation method: [pipx][pipx-link]):
+    - ```pipx install poetry```
+5. Install the development environment:
+    - ```poetry install --with dev```
+    - ```pre-commit install```
+6. Code your new feature or bug fix on a new branch.
+7. Make sure to update the docstring as required.
+8. Submit a pull request!
 
 ## Credits
 
 Inspired by:
 - [alexapy](https://gitlab.com/keatontaylor/alexapy) (design ideas)
 - [ha-sengledapi](https://github.com/jfarmer08/ha-sengledapi)
 
+[pypi]: https://pypi.org/project/sengledwifipy
+[pypi-badge]: https://img.shields.io/pypi/v/sengledwifipy
+[python]: https://pypi.org/project/sengledwifipy
+[python-badge]: https://img.shields.io/pypi/pyversions/sengledwifipy
+[license]: https://github.com/cpadil/sengledwifipy?tab=Apache-2.0-1-ov-file
+[license-badge]: https://img.shields.io/badge/License-Apache%202.0-blue.svg
+[issues]: https://github.com/cpadil/sengledwifipy/issues
+[fork]: https://github.com/cpadil/sengledwifipy/fork
+[documentation]: https://cpadil.github.io/sengledwifipy
+[paho-mqtt-link]: https://pypi.org/project/paho-mqtt/
+[poetry-link]: https://python-poetry.org/docs/#installation
+[pipx-link]: https://pipx.pypa.io/stable/
+
```

